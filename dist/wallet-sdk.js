import { jsx as fn } from "react/jsx-runtime";
import { createContext as ol, use as al, useRef as tm, useEffect as Yn, useState as jn } from "react";
const S8 = ol({}), rm = ({ children: e }) => /* @__PURE__ */ fn(S8, { value: {
  isAuthenticationRequired: !1
}, children: e }), yv = () => {
  const e = al(S8);
  if (!e)
    throw new Error("useAuth must be used within an AuthProvider");
  return e;
};
var Ft = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Nr(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function im(e) {
  if (Object.prototype.hasOwnProperty.call(e, "__esModule")) return e;
  var c = e.default;
  if (typeof c == "function") {
    var l = function w() {
      var m = !1;
      try {
        m = this instanceof w;
      } catch {
      }
      return m ? Reflect.construct(c, arguments, this.constructor) : c.apply(this, arguments);
    };
    l.prototype = c.prototype;
  } else l = {};
  return Object.defineProperty(l, "__esModule", { value: !0 }), Object.keys(e).forEach(function(w) {
    var m = Object.getOwnPropertyDescriptor(e, w);
    Object.defineProperty(l, w, m.get ? m : {
      enumerable: !0,
      get: function() {
        return e[w];
      }
    });
  }), l;
}
function ls(e) {
  throw new Error('Could not dynamically require "' + e + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var To = { exports: {} };
/*!
    localForage -- Offline Storage, Improved
    Version 1.10.0
    https://localforage.github.io/localForage
    (c) 2013-2017 Mozilla, Apache License 2.0
*/
var S1;
function nm() {
  return S1 || (S1 = 1, function(e, c) {
    (function(l) {
      e.exports = l();
    })(function() {
      return function l(w, m, f) {
        function n(s, i) {
          if (!m[s]) {
            if (!w[s]) {
              var p = typeof ls == "function" && ls;
              if (!i && p) return p(s, !0);
              if (u) return u(s, !0);
              var g = new Error("Cannot find module '" + s + "'");
              throw g.code = "MODULE_NOT_FOUND", g;
            }
            var S = m[s] = { exports: {} };
            w[s][0].call(S.exports, function(y) {
              var b = w[s][1][y];
              return n(b || y);
            }, S, S.exports, l, w, m, f);
          }
          return m[s].exports;
        }
        for (var u = typeof ls == "function" && ls, o = 0; o < f.length; o++) n(f[o]);
        return n;
      }({ 1: [function(l, w, m) {
        (function(f) {
          var n = f.MutationObserver || f.WebKitMutationObserver, u;
          if (n) {
            var o = 0, s = new n(y), i = f.document.createTextNode("");
            s.observe(i, {
              characterData: !0
            }), u = function() {
              i.data = o = ++o % 2;
            };
          } else if (!f.setImmediate && typeof f.MessageChannel < "u") {
            var p = new f.MessageChannel();
            p.port1.onmessage = y, u = function() {
              p.port2.postMessage(0);
            };
          } else "document" in f && "onreadystatechange" in f.document.createElement("script") ? u = function() {
            var h = f.document.createElement("script");
            h.onreadystatechange = function() {
              y(), h.onreadystatechange = null, h.parentNode.removeChild(h), h = null;
            }, f.document.documentElement.appendChild(h);
          } : u = function() {
            setTimeout(y, 0);
          };
          var g, S = [];
          function y() {
            g = !0;
            for (var h, a, E = S.length; E; ) {
              for (a = S, S = [], h = -1; ++h < E; )
                a[h]();
              E = S.length;
            }
            g = !1;
          }
          w.exports = b;
          function b(h) {
            S.push(h) === 1 && !g && u();
          }
        }).call(this, typeof Ft < "u" ? Ft : typeof self < "u" ? self : typeof window < "u" ? window : {});
      }, {}], 2: [function(l, w, m) {
        var f = l(1);
        function n() {
        }
        var u = {}, o = ["REJECTED"], s = ["FULFILLED"], i = ["PENDING"];
        w.exports = p;
        function p(G) {
          if (typeof G != "function")
            throw new TypeError("resolver must be a function");
          this.state = i, this.queue = [], this.outcome = void 0, G !== n && b(this, G);
        }
        p.prototype.catch = function(G) {
          return this.then(null, G);
        }, p.prototype.then = function(G, N) {
          if (typeof G != "function" && this.state === s || typeof N != "function" && this.state === o)
            return this;
          var T = new this.constructor(n);
          if (this.state !== i) {
            var A = this.state === s ? G : N;
            S(T, A, this.outcome);
          } else
            this.queue.push(new g(T, G, N));
          return T;
        };
        function g(G, N, T) {
          this.promise = G, typeof N == "function" && (this.onFulfilled = N, this.callFulfilled = this.otherCallFulfilled), typeof T == "function" && (this.onRejected = T, this.callRejected = this.otherCallRejected);
        }
        g.prototype.callFulfilled = function(G) {
          u.resolve(this.promise, G);
        }, g.prototype.otherCallFulfilled = function(G) {
          S(this.promise, this.onFulfilled, G);
        }, g.prototype.callRejected = function(G) {
          u.reject(this.promise, G);
        }, g.prototype.otherCallRejected = function(G) {
          S(this.promise, this.onRejected, G);
        };
        function S(G, N, T) {
          f(function() {
            var A;
            try {
              A = N(T);
            } catch (q) {
              return u.reject(G, q);
            }
            A === G ? u.reject(G, new TypeError("Cannot resolve promise with itself")) : u.resolve(G, A);
          });
        }
        u.resolve = function(G, N) {
          var T = h(y, N);
          if (T.status === "error")
            return u.reject(G, T.value);
          var A = T.value;
          if (A)
            b(G, A);
          else {
            G.state = s, G.outcome = N;
            for (var q = -1, _ = G.queue.length; ++q < _; )
              G.queue[q].callFulfilled(N);
          }
          return G;
        }, u.reject = function(G, N) {
          G.state = o, G.outcome = N;
          for (var T = -1, A = G.queue.length; ++T < A; )
            G.queue[T].callRejected(N);
          return G;
        };
        function y(G) {
          var N = G && G.then;
          if (G && (typeof G == "object" || typeof G == "function") && typeof N == "function")
            return function() {
              N.apply(G, arguments);
            };
        }
        function b(G, N) {
          var T = !1;
          function A(R) {
            T || (T = !0, u.reject(G, R));
          }
          function q(R) {
            T || (T = !0, u.resolve(G, R));
          }
          function _() {
            N(q, A);
          }
          var F = h(_);
          F.status === "error" && A(F.value);
        }
        function h(G, N) {
          var T = {};
          try {
            T.value = G(N), T.status = "success";
          } catch (A) {
            T.status = "error", T.value = A;
          }
          return T;
        }
        p.resolve = a;
        function a(G) {
          return G instanceof this ? G : u.resolve(new this(n), G);
        }
        p.reject = E;
        function E(G) {
          var N = new this(n);
          return u.reject(N, G);
        }
        p.all = H;
        function H(G) {
          var N = this;
          if (Object.prototype.toString.call(G) !== "[object Array]")
            return this.reject(new TypeError("must be an array"));
          var T = G.length, A = !1;
          if (!T)
            return this.resolve([]);
          for (var q = new Array(T), _ = 0, F = -1, R = new this(n); ++F < T; )
            L(G[F], F);
          return R;
          function L(fe, ue) {
            N.resolve(fe).then(ae, function(D) {
              A || (A = !0, u.reject(R, D));
            });
            function ae(D) {
              q[ue] = D, ++_ === T && !A && (A = !0, u.resolve(R, q));
            }
          }
        }
        p.race = j;
        function j(G) {
          var N = this;
          if (Object.prototype.toString.call(G) !== "[object Array]")
            return this.reject(new TypeError("must be an array"));
          var T = G.length, A = !1;
          if (!T)
            return this.resolve([]);
          for (var q = -1, _ = new this(n); ++q < T; )
            F(G[q]);
          return _;
          function F(R) {
            N.resolve(R).then(function(L) {
              A || (A = !0, u.resolve(_, L));
            }, function(L) {
              A || (A = !0, u.reject(_, L));
            });
          }
        }
      }, { 1: 1 }], 3: [function(l, w, m) {
        (function(f) {
          typeof f.Promise != "function" && (f.Promise = l(2));
        }).call(this, typeof Ft < "u" ? Ft : typeof self < "u" ? self : typeof window < "u" ? window : {});
      }, { 2: 2 }], 4: [function(l, w, m) {
        var f = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(ie) {
          return typeof ie;
        } : function(ie) {
          return ie && typeof Symbol == "function" && ie.constructor === Symbol && ie !== Symbol.prototype ? "symbol" : typeof ie;
        };
        function n(ie, be) {
          if (!(ie instanceof be))
            throw new TypeError("Cannot call a class as a function");
        }
        function u() {
          try {
            if (typeof indexedDB < "u")
              return indexedDB;
            if (typeof webkitIndexedDB < "u")
              return webkitIndexedDB;
            if (typeof mozIndexedDB < "u")
              return mozIndexedDB;
            if (typeof OIndexedDB < "u")
              return OIndexedDB;
            if (typeof msIndexedDB < "u")
              return msIndexedDB;
          } catch {
            return;
          }
        }
        var o = u();
        function s() {
          try {
            if (!o || !o.open)
              return !1;
            var ie = typeof openDatabase < "u" && /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/BlackBerry/.test(navigator.platform), be = typeof fetch == "function" && fetch.toString().indexOf("[native code") !== -1;
            return (!ie || be) && typeof indexedDB < "u" && // some outdated implementations of IDB that appear on Samsung
            // and HTC Android devices <4.4 are missing IDBKeyRange
            // See: https://github.com/mozilla/localForage/issues/128
            // See: https://github.com/mozilla/localForage/issues/272
            typeof IDBKeyRange < "u";
          } catch {
            return !1;
          }
        }
        function i(ie, be) {
          ie = ie || [], be = be || {};
          try {
            return new Blob(ie, be);
          } catch (Pe) {
            if (Pe.name !== "TypeError")
              throw Pe;
            for (var Ie = typeof BlobBuilder < "u" ? BlobBuilder : typeof MSBlobBuilder < "u" ? MSBlobBuilder : typeof MozBlobBuilder < "u" ? MozBlobBuilder : WebKitBlobBuilder, Re = new Ie(), Be = 0; Be < ie.length; Be += 1)
              Re.append(ie[Be]);
            return Re.getBlob(be.type);
          }
        }
        typeof Promise > "u" && l(3);
        var p = Promise;
        function g(ie, be) {
          be && ie.then(function(Ie) {
            be(null, Ie);
          }, function(Ie) {
            be(Ie);
          });
        }
        function S(ie, be, Ie) {
          typeof be == "function" && ie.then(be), typeof Ie == "function" && ie.catch(Ie);
        }
        function y(ie) {
          return typeof ie != "string" && (console.warn(ie + " used as a key, but it is not a string."), ie = String(ie)), ie;
        }
        function b() {
          if (arguments.length && typeof arguments[arguments.length - 1] == "function")
            return arguments[arguments.length - 1];
        }
        var h = "local-forage-detect-blob-support", a = void 0, E = {}, H = Object.prototype.toString, j = "readonly", G = "readwrite";
        function N(ie) {
          for (var be = ie.length, Ie = new ArrayBuffer(be), Re = new Uint8Array(Ie), Be = 0; Be < be; Be++)
            Re[Be] = ie.charCodeAt(Be);
          return Ie;
        }
        function T(ie) {
          return new p(function(be) {
            var Ie = ie.transaction(h, G), Re = i([""]);
            Ie.objectStore(h).put(Re, "key"), Ie.onabort = function(Be) {
              Be.preventDefault(), Be.stopPropagation(), be(!1);
            }, Ie.oncomplete = function() {
              var Be = navigator.userAgent.match(/Chrome\/(\d+)/), Pe = navigator.userAgent.match(/Edge\//);
              be(Pe || !Be || parseInt(Be[1], 10) >= 43);
            };
          }).catch(function() {
            return !1;
          });
        }
        function A(ie) {
          return typeof a == "boolean" ? p.resolve(a) : T(ie).then(function(be) {
            return a = be, a;
          });
        }
        function q(ie) {
          var be = E[ie.name], Ie = {};
          Ie.promise = new p(function(Re, Be) {
            Ie.resolve = Re, Ie.reject = Be;
          }), be.deferredOperations.push(Ie), be.dbReady ? be.dbReady = be.dbReady.then(function() {
            return Ie.promise;
          }) : be.dbReady = Ie.promise;
        }
        function _(ie) {
          var be = E[ie.name], Ie = be.deferredOperations.pop();
          if (Ie)
            return Ie.resolve(), Ie.promise;
        }
        function F(ie, be) {
          var Ie = E[ie.name], Re = Ie.deferredOperations.pop();
          if (Re)
            return Re.reject(be), Re.promise;
        }
        function R(ie, be) {
          return new p(function(Ie, Re) {
            if (E[ie.name] = E[ie.name] || Y(), ie.db)
              if (be)
                q(ie), ie.db.close();
              else
                return Ie(ie.db);
            var Be = [ie.name];
            be && Be.push(ie.version);
            var Pe = o.open.apply(o, Be);
            be && (Pe.onupgradeneeded = function(qe) {
              var Te = Pe.result;
              try {
                Te.createObjectStore(ie.storeName), qe.oldVersion <= 1 && Te.createObjectStore(h);
              } catch (Ue) {
                if (Ue.name === "ConstraintError")
                  console.warn('The database "' + ie.name + '" has been upgraded from version ' + qe.oldVersion + " to version " + qe.newVersion + ', but the storage "' + ie.storeName + '" already exists.');
                else
                  throw Ue;
              }
            }), Pe.onerror = function(qe) {
              qe.preventDefault(), Re(Pe.error);
            }, Pe.onsuccess = function() {
              var qe = Pe.result;
              qe.onversionchange = function(Te) {
                Te.target.close();
              }, Ie(qe), _(ie);
            };
          });
        }
        function L(ie) {
          return R(ie, !1);
        }
        function fe(ie) {
          return R(ie, !0);
        }
        function ue(ie, be) {
          if (!ie.db)
            return !0;
          var Ie = !ie.db.objectStoreNames.contains(ie.storeName), Re = ie.version < ie.db.version, Be = ie.version > ie.db.version;
          if (Re && (ie.version !== be && console.warn('The database "' + ie.name + `" can't be downgraded from version ` + ie.db.version + " to version " + ie.version + "."), ie.version = ie.db.version), Be || Ie) {
            if (Ie) {
              var Pe = ie.db.version + 1;
              Pe > ie.version && (ie.version = Pe);
            }
            return !0;
          }
          return !1;
        }
        function ae(ie) {
          return new p(function(be, Ie) {
            var Re = new FileReader();
            Re.onerror = Ie, Re.onloadend = function(Be) {
              var Pe = btoa(Be.target.result || "");
              be({
                __local_forage_encoded_blob: !0,
                data: Pe,
                type: ie.type
              });
            }, Re.readAsBinaryString(ie);
          });
        }
        function D(ie) {
          var be = N(atob(ie.data));
          return i([be], { type: ie.type });
        }
        function Q(ie) {
          return ie && ie.__local_forage_encoded_blob;
        }
        function W(ie) {
          var be = this, Ie = be._initReady().then(function() {
            var Re = E[be._dbInfo.name];
            if (Re && Re.dbReady)
              return Re.dbReady;
          });
          return S(Ie, ie, ie), Ie;
        }
        function oe(ie) {
          q(ie);
          for (var be = E[ie.name], Ie = be.forages, Re = 0; Re < Ie.length; Re++) {
            var Be = Ie[Re];
            Be._dbInfo.db && (Be._dbInfo.db.close(), Be._dbInfo.db = null);
          }
          return ie.db = null, L(ie).then(function(Pe) {
            return ie.db = Pe, ue(ie) ? fe(ie) : Pe;
          }).then(function(Pe) {
            ie.db = be.db = Pe;
            for (var qe = 0; qe < Ie.length; qe++)
              Ie[qe]._dbInfo.db = Pe;
          }).catch(function(Pe) {
            throw F(ie, Pe), Pe;
          });
        }
        function v(ie, be, Ie, Re) {
          Re === void 0 && (Re = 1);
          try {
            var Be = ie.db.transaction(ie.storeName, be);
            Ie(null, Be);
          } catch (Pe) {
            if (Re > 0 && (!ie.db || Pe.name === "InvalidStateError" || Pe.name === "NotFoundError"))
              return p.resolve().then(function() {
                if (!ie.db || Pe.name === "NotFoundError" && !ie.db.objectStoreNames.contains(ie.storeName) && ie.version <= ie.db.version)
                  return ie.db && (ie.version = ie.db.version + 1), fe(ie);
              }).then(function() {
                return oe(ie).then(function() {
                  v(ie, be, Ie, Re - 1);
                });
              }).catch(Ie);
            Ie(Pe);
          }
        }
        function Y() {
          return {
            // Running localForages sharing a database.
            forages: [],
            // Shared database.
            db: null,
            // Database readiness (promise).
            dbReady: null,
            // Deferred operations on the database.
            deferredOperations: []
          };
        }
        function he(ie) {
          var be = this, Ie = {
            db: null
          };
          if (ie)
            for (var Re in ie)
              Ie[Re] = ie[Re];
          var Be = E[Ie.name];
          Be || (Be = Y(), E[Ie.name] = Be), Be.forages.push(be), be._initReady || (be._initReady = be.ready, be.ready = W);
          var Pe = [];
          function qe() {
            return p.resolve();
          }
          for (var Te = 0; Te < Be.forages.length; Te++) {
            var Ue = Be.forages[Te];
            Ue !== be && Pe.push(Ue._initReady().catch(qe));
          }
          var Fe = Be.forages.slice(0);
          return p.all(Pe).then(function() {
            return Ie.db = Be.db, L(Ie);
          }).then(function(Le) {
            return Ie.db = Le, ue(Ie, be._defaultConfig.version) ? fe(Ie) : Le;
          }).then(function(Le) {
            Ie.db = Be.db = Le, be._dbInfo = Ie;
            for (var Ge = 0; Ge < Fe.length; Ge++) {
              var mt = Fe[Ge];
              mt !== be && (mt._dbInfo.db = Ie.db, mt._dbInfo.version = Ie.version);
            }
          });
        }
        function le(ie, be) {
          var Ie = this;
          ie = y(ie);
          var Re = new p(function(Be, Pe) {
            Ie.ready().then(function() {
              v(Ie._dbInfo, j, function(qe, Te) {
                if (qe)
                  return Pe(qe);
                try {
                  var Ue = Te.objectStore(Ie._dbInfo.storeName), Fe = Ue.get(ie);
                  Fe.onsuccess = function() {
                    var Le = Fe.result;
                    Le === void 0 && (Le = null), Q(Le) && (Le = D(Le)), Be(Le);
                  }, Fe.onerror = function() {
                    Pe(Fe.error);
                  };
                } catch (Le) {
                  Pe(Le);
                }
              });
            }).catch(Pe);
          });
          return g(Re, be), Re;
        }
        function ge(ie, be) {
          var Ie = this, Re = new p(function(Be, Pe) {
            Ie.ready().then(function() {
              v(Ie._dbInfo, j, function(qe, Te) {
                if (qe)
                  return Pe(qe);
                try {
                  var Ue = Te.objectStore(Ie._dbInfo.storeName), Fe = Ue.openCursor(), Le = 1;
                  Fe.onsuccess = function() {
                    var Ge = Fe.result;
                    if (Ge) {
                      var mt = Ge.value;
                      Q(mt) && (mt = D(mt));
                      var Et = ie(mt, Ge.key, Le++);
                      Et !== void 0 ? Be(Et) : Ge.continue();
                    } else
                      Be();
                  }, Fe.onerror = function() {
                    Pe(Fe.error);
                  };
                } catch (Ge) {
                  Pe(Ge);
                }
              });
            }).catch(Pe);
          });
          return g(Re, be), Re;
        }
        function Ee(ie, be, Ie) {
          var Re = this;
          ie = y(ie);
          var Be = new p(function(Pe, qe) {
            var Te;
            Re.ready().then(function() {
              return Te = Re._dbInfo, H.call(be) === "[object Blob]" ? A(Te.db).then(function(Ue) {
                return Ue ? be : ae(be);
              }) : be;
            }).then(function(Ue) {
              v(Re._dbInfo, G, function(Fe, Le) {
                if (Fe)
                  return qe(Fe);
                try {
                  var Ge = Le.objectStore(Re._dbInfo.storeName);
                  Ue === null && (Ue = void 0);
                  var mt = Ge.put(Ue, ie);
                  Le.oncomplete = function() {
                    Ue === void 0 && (Ue = null), Pe(Ue);
                  }, Le.onabort = Le.onerror = function() {
                    var Et = mt.error ? mt.error : mt.transaction.error;
                    qe(Et);
                  };
                } catch (Et) {
                  qe(Et);
                }
              });
            }).catch(qe);
          });
          return g(Be, Ie), Be;
        }
        function we(ie, be) {
          var Ie = this;
          ie = y(ie);
          var Re = new p(function(Be, Pe) {
            Ie.ready().then(function() {
              v(Ie._dbInfo, G, function(qe, Te) {
                if (qe)
                  return Pe(qe);
                try {
                  var Ue = Te.objectStore(Ie._dbInfo.storeName), Fe = Ue.delete(ie);
                  Te.oncomplete = function() {
                    Be();
                  }, Te.onerror = function() {
                    Pe(Fe.error);
                  }, Te.onabort = function() {
                    var Le = Fe.error ? Fe.error : Fe.transaction.error;
                    Pe(Le);
                  };
                } catch (Le) {
                  Pe(Le);
                }
              });
            }).catch(Pe);
          });
          return g(Re, be), Re;
        }
        function z(ie) {
          var be = this, Ie = new p(function(Re, Be) {
            be.ready().then(function() {
              v(be._dbInfo, G, function(Pe, qe) {
                if (Pe)
                  return Be(Pe);
                try {
                  var Te = qe.objectStore(be._dbInfo.storeName), Ue = Te.clear();
                  qe.oncomplete = function() {
                    Re();
                  }, qe.onabort = qe.onerror = function() {
                    var Fe = Ue.error ? Ue.error : Ue.transaction.error;
                    Be(Fe);
                  };
                } catch (Fe) {
                  Be(Fe);
                }
              });
            }).catch(Be);
          });
          return g(Ie, ie), Ie;
        }
        function I(ie) {
          var be = this, Ie = new p(function(Re, Be) {
            be.ready().then(function() {
              v(be._dbInfo, j, function(Pe, qe) {
                if (Pe)
                  return Be(Pe);
                try {
                  var Te = qe.objectStore(be._dbInfo.storeName), Ue = Te.count();
                  Ue.onsuccess = function() {
                    Re(Ue.result);
                  }, Ue.onerror = function() {
                    Be(Ue.error);
                  };
                } catch (Fe) {
                  Be(Fe);
                }
              });
            }).catch(Be);
          });
          return g(Ie, ie), Ie;
        }
        function ne(ie, be) {
          var Ie = this, Re = new p(function(Be, Pe) {
            if (ie < 0) {
              Be(null);
              return;
            }
            Ie.ready().then(function() {
              v(Ie._dbInfo, j, function(qe, Te) {
                if (qe)
                  return Pe(qe);
                try {
                  var Ue = Te.objectStore(Ie._dbInfo.storeName), Fe = !1, Le = Ue.openKeyCursor();
                  Le.onsuccess = function() {
                    var Ge = Le.result;
                    if (!Ge) {
                      Be(null);
                      return;
                    }
                    ie === 0 || Fe ? Be(Ge.key) : (Fe = !0, Ge.advance(ie));
                  }, Le.onerror = function() {
                    Pe(Le.error);
                  };
                } catch (Ge) {
                  Pe(Ge);
                }
              });
            }).catch(Pe);
          });
          return g(Re, be), Re;
        }
        function t(ie) {
          var be = this, Ie = new p(function(Re, Be) {
            be.ready().then(function() {
              v(be._dbInfo, j, function(Pe, qe) {
                if (Pe)
                  return Be(Pe);
                try {
                  var Te = qe.objectStore(be._dbInfo.storeName), Ue = Te.openKeyCursor(), Fe = [];
                  Ue.onsuccess = function() {
                    var Le = Ue.result;
                    if (!Le) {
                      Re(Fe);
                      return;
                    }
                    Fe.push(Le.key), Le.continue();
                  }, Ue.onerror = function() {
                    Be(Ue.error);
                  };
                } catch (Le) {
                  Be(Le);
                }
              });
            }).catch(Be);
          });
          return g(Ie, ie), Ie;
        }
        function d(ie, be) {
          be = b.apply(this, arguments);
          var Ie = this.config();
          ie = typeof ie != "function" && ie || {}, ie.name || (ie.name = ie.name || Ie.name, ie.storeName = ie.storeName || Ie.storeName);
          var Re = this, Be;
          if (!ie.name)
            Be = p.reject("Invalid arguments");
          else {
            var Pe = ie.name === Ie.name && Re._dbInfo.db, qe = Pe ? p.resolve(Re._dbInfo.db) : L(ie).then(function(Te) {
              var Ue = E[ie.name], Fe = Ue.forages;
              Ue.db = Te;
              for (var Le = 0; Le < Fe.length; Le++)
                Fe[Le]._dbInfo.db = Te;
              return Te;
            });
            ie.storeName ? Be = qe.then(function(Te) {
              if (Te.objectStoreNames.contains(ie.storeName)) {
                var Ue = Te.version + 1;
                q(ie);
                var Fe = E[ie.name], Le = Fe.forages;
                Te.close();
                for (var Ge = 0; Ge < Le.length; Ge++) {
                  var mt = Le[Ge];
                  mt._dbInfo.db = null, mt._dbInfo.version = Ue;
                }
                var Et = new p(function(It, kt) {
                  var Rt = o.open(ie.name, Ue);
                  Rt.onerror = function(xr) {
                    var An = Rt.result;
                    An.close(), kt(xr);
                  }, Rt.onupgradeneeded = function() {
                    var xr = Rt.result;
                    xr.deleteObjectStore(ie.storeName);
                  }, Rt.onsuccess = function() {
                    var xr = Rt.result;
                    xr.close(), It(xr);
                  };
                });
                return Et.then(function(It) {
                  Fe.db = It;
                  for (var kt = 0; kt < Le.length; kt++) {
                    var Rt = Le[kt];
                    Rt._dbInfo.db = It, _(Rt._dbInfo);
                  }
                }).catch(function(It) {
                  throw (F(ie, It) || p.resolve()).catch(function() {
                  }), It;
                });
              }
            }) : Be = qe.then(function(Te) {
              q(ie);
              var Ue = E[ie.name], Fe = Ue.forages;
              Te.close();
              for (var Le = 0; Le < Fe.length; Le++) {
                var Ge = Fe[Le];
                Ge._dbInfo.db = null;
              }
              var mt = new p(function(Et, It) {
                var kt = o.deleteDatabase(ie.name);
                kt.onerror = function() {
                  var Rt = kt.result;
                  Rt && Rt.close(), It(kt.error);
                }, kt.onblocked = function() {
                  console.warn('dropInstance blocked for database "' + ie.name + '" until all open connections are closed');
                }, kt.onsuccess = function() {
                  var Rt = kt.result;
                  Rt && Rt.close(), Et(Rt);
                };
              });
              return mt.then(function(Et) {
                Ue.db = Et;
                for (var It = 0; It < Fe.length; It++) {
                  var kt = Fe[It];
                  _(kt._dbInfo);
                }
              }).catch(function(Et) {
                throw (F(ie, Et) || p.resolve()).catch(function() {
                }), Et;
              });
            });
          }
          return g(Be, be), Be;
        }
        var B = {
          _driver: "asyncStorage",
          _initStorage: he,
          _support: s(),
          iterate: ge,
          getItem: le,
          setItem: Ee,
          removeItem: we,
          clear: z,
          length: I,
          key: ne,
          keys: t,
          dropInstance: d
        };
        function U() {
          return typeof openDatabase == "function";
        }
        var J = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", C = "~~local_forage_type~", M = /^~~local_forage_type~([^~]+)~/, $ = "__lfsc__:", r = $.length, x = "arbf", O = "blob", K = "si08", X = "ui08", P = "uic8", V = "si16", re = "si32", ce = "ur16", de = "ui32", pe = "fl32", se = "fl64", Z = r + x.length, ee = Object.prototype.toString;
        function me(ie) {
          var be = ie.length * 0.75, Ie = ie.length, Re, Be = 0, Pe, qe, Te, Ue;
          ie[ie.length - 1] === "=" && (be--, ie[ie.length - 2] === "=" && be--);
          var Fe = new ArrayBuffer(be), Le = new Uint8Array(Fe);
          for (Re = 0; Re < Ie; Re += 4)
            Pe = J.indexOf(ie[Re]), qe = J.indexOf(ie[Re + 1]), Te = J.indexOf(ie[Re + 2]), Ue = J.indexOf(ie[Re + 3]), Le[Be++] = Pe << 2 | qe >> 4, Le[Be++] = (qe & 15) << 4 | Te >> 2, Le[Be++] = (Te & 3) << 6 | Ue & 63;
          return Fe;
        }
        function Ae(ie) {
          var be = new Uint8Array(ie), Ie = "", Re;
          for (Re = 0; Re < be.length; Re += 3)
            Ie += J[be[Re] >> 2], Ie += J[(be[Re] & 3) << 4 | be[Re + 1] >> 4], Ie += J[(be[Re + 1] & 15) << 2 | be[Re + 2] >> 6], Ie += J[be[Re + 2] & 63];
          return be.length % 3 === 2 ? Ie = Ie.substring(0, Ie.length - 1) + "=" : be.length % 3 === 1 && (Ie = Ie.substring(0, Ie.length - 2) + "=="), Ie;
        }
        function Oe(ie, be) {
          var Ie = "";
          if (ie && (Ie = ee.call(ie)), ie && (Ie === "[object ArrayBuffer]" || ie.buffer && ee.call(ie.buffer) === "[object ArrayBuffer]")) {
            var Re, Be = $;
            ie instanceof ArrayBuffer ? (Re = ie, Be += x) : (Re = ie.buffer, Ie === "[object Int8Array]" ? Be += K : Ie === "[object Uint8Array]" ? Be += X : Ie === "[object Uint8ClampedArray]" ? Be += P : Ie === "[object Int16Array]" ? Be += V : Ie === "[object Uint16Array]" ? Be += ce : Ie === "[object Int32Array]" ? Be += re : Ie === "[object Uint32Array]" ? Be += de : Ie === "[object Float32Array]" ? Be += pe : Ie === "[object Float64Array]" ? Be += se : be(new Error("Failed to get type for BinaryArray"))), be(Be + Ae(Re));
          } else if (Ie === "[object Blob]") {
            var Pe = new FileReader();
            Pe.onload = function() {
              var qe = C + ie.type + "~" + Ae(this.result);
              be($ + O + qe);
            }, Pe.readAsArrayBuffer(ie);
          } else
            try {
              be(JSON.stringify(ie));
            } catch (qe) {
              console.error("Couldn't convert value into a JSON string: ", ie), be(null, qe);
            }
        }
        function ye(ie) {
          if (ie.substring(0, r) !== $)
            return JSON.parse(ie);
          var be = ie.substring(Z), Ie = ie.substring(r, Z), Re;
          if (Ie === O && M.test(be)) {
            var Be = be.match(M);
            Re = Be[1], be = be.substring(Be[0].length);
          }
          var Pe = me(be);
          switch (Ie) {
            case x:
              return Pe;
            case O:
              return i([Pe], { type: Re });
            case K:
              return new Int8Array(Pe);
            case X:
              return new Uint8Array(Pe);
            case P:
              return new Uint8ClampedArray(Pe);
            case V:
              return new Int16Array(Pe);
            case ce:
              return new Uint16Array(Pe);
            case re:
              return new Int32Array(Pe);
            case de:
              return new Uint32Array(Pe);
            case pe:
              return new Float32Array(Pe);
            case se:
              return new Float64Array(Pe);
            default:
              throw new Error("Unkown type: " + Ie);
          }
        }
        var _e = {
          serialize: Oe,
          deserialize: ye,
          stringToBuffer: me,
          bufferToString: Ae
        };
        function ke(ie, be, Ie, Re) {
          ie.executeSql("CREATE TABLE IF NOT EXISTS " + be.storeName + " (id INTEGER PRIMARY KEY, key unique, value)", [], Ie, Re);
        }
        function Me(ie) {
          var be = this, Ie = {
            db: null
          };
          if (ie)
            for (var Re in ie)
              Ie[Re] = typeof ie[Re] != "string" ? ie[Re].toString() : ie[Re];
          var Be = new p(function(Pe, qe) {
            try {
              Ie.db = openDatabase(Ie.name, String(Ie.version), Ie.description, Ie.size);
            } catch (Te) {
              return qe(Te);
            }
            Ie.db.transaction(function(Te) {
              ke(Te, Ie, function() {
                be._dbInfo = Ie, Pe();
              }, function(Ue, Fe) {
                qe(Fe);
              });
            }, qe);
          });
          return Ie.serializer = _e, Be;
        }
        function De(ie, be, Ie, Re, Be, Pe) {
          ie.executeSql(Ie, Re, Be, function(qe, Te) {
            Te.code === Te.SYNTAX_ERR ? qe.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name = ?", [be.storeName], function(Ue, Fe) {
              Fe.rows.length ? Pe(Ue, Te) : ke(Ue, be, function() {
                Ue.executeSql(Ie, Re, Be, Pe);
              }, Pe);
            }, Pe) : Pe(qe, Te);
          }, Pe);
        }
        function Ne(ie, be) {
          var Ie = this;
          ie = y(ie);
          var Re = new p(function(Be, Pe) {
            Ie.ready().then(function() {
              var qe = Ie._dbInfo;
              qe.db.transaction(function(Te) {
                De(Te, qe, "SELECT * FROM " + qe.storeName + " WHERE key = ? LIMIT 1", [ie], function(Ue, Fe) {
                  var Le = Fe.rows.length ? Fe.rows.item(0).value : null;
                  Le && (Le = qe.serializer.deserialize(Le)), Be(Le);
                }, function(Ue, Fe) {
                  Pe(Fe);
                });
              });
            }).catch(Pe);
          });
          return g(Re, be), Re;
        }
        function $e(ie, be) {
          var Ie = this, Re = new p(function(Be, Pe) {
            Ie.ready().then(function() {
              var qe = Ie._dbInfo;
              qe.db.transaction(function(Te) {
                De(Te, qe, "SELECT * FROM " + qe.storeName, [], function(Ue, Fe) {
                  for (var Le = Fe.rows, Ge = Le.length, mt = 0; mt < Ge; mt++) {
                    var Et = Le.item(mt), It = Et.value;
                    if (It && (It = qe.serializer.deserialize(It)), It = ie(It, Et.key, mt + 1), It !== void 0) {
                      Be(It);
                      return;
                    }
                  }
                  Be();
                }, function(Ue, Fe) {
                  Pe(Fe);
                });
              });
            }).catch(Pe);
          });
          return g(Re, be), Re;
        }
        function bt(ie, be, Ie, Re) {
          var Be = this;
          ie = y(ie);
          var Pe = new p(function(qe, Te) {
            Be.ready().then(function() {
              be === void 0 && (be = null);
              var Ue = be, Fe = Be._dbInfo;
              Fe.serializer.serialize(be, function(Le, Ge) {
                Ge ? Te(Ge) : Fe.db.transaction(function(mt) {
                  De(mt, Fe, "INSERT OR REPLACE INTO " + Fe.storeName + " (key, value) VALUES (?, ?)", [ie, Le], function() {
                    qe(Ue);
                  }, function(Et, It) {
                    Te(It);
                  });
                }, function(mt) {
                  if (mt.code === mt.QUOTA_ERR) {
                    if (Re > 0) {
                      qe(bt.apply(Be, [ie, Ue, Ie, Re - 1]));
                      return;
                    }
                    Te(mt);
                  }
                });
              });
            }).catch(Te);
          });
          return g(Pe, Ie), Pe;
        }
        function Ve(ie, be, Ie) {
          return bt.apply(this, [ie, be, Ie, 1]);
        }
        function je(ie, be) {
          var Ie = this;
          ie = y(ie);
          var Re = new p(function(Be, Pe) {
            Ie.ready().then(function() {
              var qe = Ie._dbInfo;
              qe.db.transaction(function(Te) {
                De(Te, qe, "DELETE FROM " + qe.storeName + " WHERE key = ?", [ie], function() {
                  Be();
                }, function(Ue, Fe) {
                  Pe(Fe);
                });
              });
            }).catch(Pe);
          });
          return g(Re, be), Re;
        }
        function _t(ie) {
          var be = this, Ie = new p(function(Re, Be) {
            be.ready().then(function() {
              var Pe = be._dbInfo;
              Pe.db.transaction(function(qe) {
                De(qe, Pe, "DELETE FROM " + Pe.storeName, [], function() {
                  Re();
                }, function(Te, Ue) {
                  Be(Ue);
                });
              });
            }).catch(Be);
          });
          return g(Ie, ie), Ie;
        }
        function Je(ie) {
          var be = this, Ie = new p(function(Re, Be) {
            be.ready().then(function() {
              var Pe = be._dbInfo;
              Pe.db.transaction(function(qe) {
                De(qe, Pe, "SELECT COUNT(key) as c FROM " + Pe.storeName, [], function(Te, Ue) {
                  var Fe = Ue.rows.item(0).c;
                  Re(Fe);
                }, function(Te, Ue) {
                  Be(Ue);
                });
              });
            }).catch(Be);
          });
          return g(Ie, ie), Ie;
        }
        function Ye(ie, be) {
          var Ie = this, Re = new p(function(Be, Pe) {
            Ie.ready().then(function() {
              var qe = Ie._dbInfo;
              qe.db.transaction(function(Te) {
                De(Te, qe, "SELECT key FROM " + qe.storeName + " WHERE id = ? LIMIT 1", [ie + 1], function(Ue, Fe) {
                  var Le = Fe.rows.length ? Fe.rows.item(0).key : null;
                  Be(Le);
                }, function(Ue, Fe) {
                  Pe(Fe);
                });
              });
            }).catch(Pe);
          });
          return g(Re, be), Re;
        }
        function Ot(ie) {
          var be = this, Ie = new p(function(Re, Be) {
            be.ready().then(function() {
              var Pe = be._dbInfo;
              Pe.db.transaction(function(qe) {
                De(qe, Pe, "SELECT key FROM " + Pe.storeName, [], function(Te, Ue) {
                  for (var Fe = [], Le = 0; Le < Ue.rows.length; Le++)
                    Fe.push(Ue.rows.item(Le).key);
                  Re(Fe);
                }, function(Te, Ue) {
                  Be(Ue);
                });
              });
            }).catch(Be);
          });
          return g(Ie, ie), Ie;
        }
        function We(ie) {
          return new p(function(be, Ie) {
            ie.transaction(function(Re) {
              Re.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name <> '__WebKitDatabaseInfoTable__'", [], function(Be, Pe) {
                for (var qe = [], Te = 0; Te < Pe.rows.length; Te++)
                  qe.push(Pe.rows.item(Te).name);
                be({
                  db: ie,
                  storeNames: qe
                });
              }, function(Be, Pe) {
                Ie(Pe);
              });
            }, function(Re) {
              Ie(Re);
            });
          });
        }
        function Ze(ie, be) {
          be = b.apply(this, arguments);
          var Ie = this.config();
          ie = typeof ie != "function" && ie || {}, ie.name || (ie.name = ie.name || Ie.name, ie.storeName = ie.storeName || Ie.storeName);
          var Re = this, Be;
          return ie.name ? Be = new p(function(Pe) {
            var qe;
            ie.name === Ie.name ? qe = Re._dbInfo.db : qe = openDatabase(ie.name, "", "", 0), ie.storeName ? Pe({
              db: qe,
              storeNames: [ie.storeName]
            }) : Pe(We(qe));
          }).then(function(Pe) {
            return new p(function(qe, Te) {
              Pe.db.transaction(function(Ue) {
                function Fe(Et) {
                  return new p(function(It, kt) {
                    Ue.executeSql("DROP TABLE IF EXISTS " + Et, [], function() {
                      It();
                    }, function(Rt, xr) {
                      kt(xr);
                    });
                  });
                }
                for (var Le = [], Ge = 0, mt = Pe.storeNames.length; Ge < mt; Ge++)
                  Le.push(Fe(Pe.storeNames[Ge]));
                p.all(Le).then(function() {
                  qe();
                }).catch(function(Et) {
                  Te(Et);
                });
              }, function(Ue) {
                Te(Ue);
              });
            });
          }) : Be = p.reject("Invalid arguments"), g(Be, be), Be;
        }
        var Tt = {
          _driver: "webSQLStorage",
          _initStorage: Me,
          _support: U(),
          iterate: $e,
          getItem: Ne,
          setItem: Ve,
          removeItem: je,
          clear: _t,
          length: Je,
          key: Ye,
          keys: Ot,
          dropInstance: Ze
        };
        function Qe() {
          try {
            return typeof localStorage < "u" && "setItem" in localStorage && // in IE8 typeof localStorage.setItem === 'object'
            !!localStorage.setItem;
          } catch {
            return !1;
          }
        }
        function rt(ie, be) {
          var Ie = ie.name + "/";
          return ie.storeName !== be.storeName && (Ie += ie.storeName + "/"), Ie;
        }
        function ur() {
          var ie = "_localforage_support_test";
          try {
            return localStorage.setItem(ie, !0), localStorage.removeItem(ie), !1;
          } catch {
            return !0;
          }
        }
        function nt() {
          return !ur() || localStorage.length > 0;
        }
        function ft(ie) {
          var be = this, Ie = {};
          if (ie)
            for (var Re in ie)
              Ie[Re] = ie[Re];
          return Ie.keyPrefix = rt(ie, be._defaultConfig), nt() ? (be._dbInfo = Ie, Ie.serializer = _e, p.resolve()) : p.reject();
        }
        function gr(ie) {
          var be = this, Ie = be.ready().then(function() {
            for (var Re = be._dbInfo.keyPrefix, Be = localStorage.length - 1; Be >= 0; Be--) {
              var Pe = localStorage.key(Be);
              Pe.indexOf(Re) === 0 && localStorage.removeItem(Pe);
            }
          });
          return g(Ie, ie), Ie;
        }
        function et(ie, be) {
          var Ie = this;
          ie = y(ie);
          var Re = Ie.ready().then(function() {
            var Be = Ie._dbInfo, Pe = localStorage.getItem(Be.keyPrefix + ie);
            return Pe && (Pe = Be.serializer.deserialize(Pe)), Pe;
          });
          return g(Re, be), Re;
        }
        function ct(ie, be) {
          var Ie = this, Re = Ie.ready().then(function() {
            for (var Be = Ie._dbInfo, Pe = Be.keyPrefix, qe = Pe.length, Te = localStorage.length, Ue = 1, Fe = 0; Fe < Te; Fe++) {
              var Le = localStorage.key(Fe);
              if (Le.indexOf(Pe) === 0) {
                var Ge = localStorage.getItem(Le);
                if (Ge && (Ge = Be.serializer.deserialize(Ge)), Ge = ie(Ge, Le.substring(qe), Ue++), Ge !== void 0)
                  return Ge;
              }
            }
          });
          return g(Re, be), Re;
        }
        function hr(ie, be) {
          var Ie = this, Re = Ie.ready().then(function() {
            var Be = Ie._dbInfo, Pe;
            try {
              Pe = localStorage.key(ie);
            } catch {
              Pe = null;
            }
            return Pe && (Pe = Pe.substring(Be.keyPrefix.length)), Pe;
          });
          return g(Re, be), Re;
        }
        function ut(ie) {
          var be = this, Ie = be.ready().then(function() {
            for (var Re = be._dbInfo, Be = localStorage.length, Pe = [], qe = 0; qe < Be; qe++) {
              var Te = localStorage.key(qe);
              Te.indexOf(Re.keyPrefix) === 0 && Pe.push(Te.substring(Re.keyPrefix.length));
            }
            return Pe;
          });
          return g(Ie, ie), Ie;
        }
        function lt(ie) {
          var be = this, Ie = be.keys().then(function(Re) {
            return Re.length;
          });
          return g(Ie, ie), Ie;
        }
        function lr(ie, be) {
          var Ie = this;
          ie = y(ie);
          var Re = Ie.ready().then(function() {
            var Be = Ie._dbInfo;
            localStorage.removeItem(Be.keyPrefix + ie);
          });
          return g(Re, be), Re;
        }
        function tt(ie, be, Ie) {
          var Re = this;
          ie = y(ie);
          var Be = Re.ready().then(function() {
            be === void 0 && (be = null);
            var Pe = be;
            return new p(function(qe, Te) {
              var Ue = Re._dbInfo;
              Ue.serializer.serialize(be, function(Fe, Le) {
                if (Le)
                  Te(Le);
                else
                  try {
                    localStorage.setItem(Ue.keyPrefix + ie, Fe), qe(Pe);
                  } catch (Ge) {
                    (Ge.name === "QuotaExceededError" || Ge.name === "NS_ERROR_DOM_QUOTA_REACHED") && Te(Ge), Te(Ge);
                  }
              });
            });
          });
          return g(Be, Ie), Be;
        }
        function it(ie, be) {
          if (be = b.apply(this, arguments), ie = typeof ie != "function" && ie || {}, !ie.name) {
            var Ie = this.config();
            ie.name = ie.name || Ie.name, ie.storeName = ie.storeName || Ie.storeName;
          }
          var Re = this, Be;
          return ie.name ? Be = new p(function(Pe) {
            ie.storeName ? Pe(rt(ie, Re._defaultConfig)) : Pe(ie.name + "/");
          }).then(function(Pe) {
            for (var qe = localStorage.length - 1; qe >= 0; qe--) {
              var Te = localStorage.key(qe);
              Te.indexOf(Pe) === 0 && localStorage.removeItem(Te);
            }
          }) : Be = p.reject("Invalid arguments"), g(Be, be), Be;
        }
        var _r = {
          _driver: "localStorageWrapper",
          _initStorage: ft,
          _support: Qe(),
          iterate: ct,
          getItem: et,
          setItem: tt,
          removeItem: lr,
          clear: gr,
          length: lt,
          key: hr,
          keys: ut,
          dropInstance: it
        }, st = function(be, Ie) {
          return be === Ie || typeof be == "number" && typeof Ie == "number" && isNaN(be) && isNaN(Ie);
        }, gt = function(be, Ie) {
          for (var Re = be.length, Be = 0; Be < Re; ) {
            if (st(be[Be], Ie))
              return !0;
            Be++;
          }
          return !1;
        }, Dr = Array.isArray || function(ie) {
          return Object.prototype.toString.call(ie) === "[object Array]";
        }, ot = {}, pt = {}, nr = {
          INDEXEDDB: B,
          WEBSQL: Tt,
          LOCALSTORAGE: _r
        }, ht = [nr.INDEXEDDB._driver, nr.WEBSQL._driver, nr.LOCALSTORAGE._driver], at = ["dropInstance"], Ke = ["clear", "getItem", "iterate", "key", "keys", "length", "removeItem", "setItem"].concat(at), Se = {
          description: "",
          driver: ht.slice(),
          name: "localforage",
          // Default DB size is _JUST UNDER_ 5MB, as it's the highest size
          // we can use without a prompt.
          size: 4980736,
          storeName: "keyvaluepairs",
          version: 1
        };
        function te(ie, be) {
          ie[be] = function() {
            var Ie = arguments;
            return ie.ready().then(function() {
              return ie[be].apply(ie, Ie);
            });
          };
        }
        function ve() {
          for (var ie = 1; ie < arguments.length; ie++) {
            var be = arguments[ie];
            if (be)
              for (var Ie in be)
                be.hasOwnProperty(Ie) && (Dr(be[Ie]) ? arguments[0][Ie] = be[Ie].slice() : arguments[0][Ie] = be[Ie]);
          }
          return arguments[0];
        }
        var Dt = function() {
          function ie(be) {
            n(this, ie);
            for (var Ie in nr)
              if (nr.hasOwnProperty(Ie)) {
                var Re = nr[Ie], Be = Re._driver;
                this[Ie] = Be, ot[Be] || this.defineDriver(Re);
              }
            this._defaultConfig = ve({}, Se), this._config = ve({}, this._defaultConfig, be), this._driverSet = null, this._initDriver = null, this._ready = !1, this._dbInfo = null, this._wrapLibraryMethodsWithReady(), this.setDriver(this._config.driver).catch(function() {
            });
          }
          return ie.prototype.config = function(Ie) {
            if ((typeof Ie > "u" ? "undefined" : f(Ie)) === "object") {
              if (this._ready)
                return new Error("Can't call config() after localforage has been used.");
              for (var Re in Ie) {
                if (Re === "storeName" && (Ie[Re] = Ie[Re].replace(/\W/g, "_")), Re === "version" && typeof Ie[Re] != "number")
                  return new Error("Database version must be a number.");
                this._config[Re] = Ie[Re];
              }
              return "driver" in Ie && Ie.driver ? this.setDriver(this._config.driver) : !0;
            } else return typeof Ie == "string" ? this._config[Ie] : this._config;
          }, ie.prototype.defineDriver = function(Ie, Re, Be) {
            var Pe = new p(function(qe, Te) {
              try {
                var Ue = Ie._driver, Fe = new Error("Custom driver not compliant; see https://mozilla.github.io/localForage/#definedriver");
                if (!Ie._driver) {
                  Te(Fe);
                  return;
                }
                for (var Le = Ke.concat("_initStorage"), Ge = 0, mt = Le.length; Ge < mt; Ge++) {
                  var Et = Le[Ge], It = !gt(at, Et);
                  if ((It || Ie[Et]) && typeof Ie[Et] != "function") {
                    Te(Fe);
                    return;
                  }
                }
                var kt = function() {
                  for (var An = function(Qp) {
                    return function() {
                      var em = new Error("Method " + Qp + " is not implemented by the current driver"), v1 = p.reject(em);
                      return g(v1, arguments[arguments.length - 1]), v1;
                    };
                  }, No = 0, Zp = at.length; No < Zp; No++) {
                    var qo = at[No];
                    Ie[qo] || (Ie[qo] = An(qo));
                  }
                };
                kt();
                var Rt = function(An) {
                  ot[Ue] && console.info("Redefining LocalForage driver: " + Ue), ot[Ue] = Ie, pt[Ue] = An, qe();
                };
                "_support" in Ie ? Ie._support && typeof Ie._support == "function" ? Ie._support().then(Rt, Te) : Rt(!!Ie._support) : Rt(!0);
              } catch (xr) {
                Te(xr);
              }
            });
            return S(Pe, Re, Be), Pe;
          }, ie.prototype.driver = function() {
            return this._driver || null;
          }, ie.prototype.getDriver = function(Ie, Re, Be) {
            var Pe = ot[Ie] ? p.resolve(ot[Ie]) : p.reject(new Error("Driver not found."));
            return S(Pe, Re, Be), Pe;
          }, ie.prototype.getSerializer = function(Ie) {
            var Re = p.resolve(_e);
            return S(Re, Ie), Re;
          }, ie.prototype.ready = function(Ie) {
            var Re = this, Be = Re._driverSet.then(function() {
              return Re._ready === null && (Re._ready = Re._initDriver()), Re._ready;
            });
            return S(Be, Ie, Ie), Be;
          }, ie.prototype.setDriver = function(Ie, Re, Be) {
            var Pe = this;
            Dr(Ie) || (Ie = [Ie]);
            var qe = this._getSupportedDrivers(Ie);
            function Te() {
              Pe._config.driver = Pe.driver();
            }
            function Ue(Ge) {
              return Pe._extend(Ge), Te(), Pe._ready = Pe._initStorage(Pe._config), Pe._ready;
            }
            function Fe(Ge) {
              return function() {
                var mt = 0;
                function Et() {
                  for (; mt < Ge.length; ) {
                    var It = Ge[mt];
                    return mt++, Pe._dbInfo = null, Pe._ready = null, Pe.getDriver(It).then(Ue).catch(Et);
                  }
                  Te();
                  var kt = new Error("No available storage method found.");
                  return Pe._driverSet = p.reject(kt), Pe._driverSet;
                }
                return Et();
              };
            }
            var Le = this._driverSet !== null ? this._driverSet.catch(function() {
              return p.resolve();
            }) : p.resolve();
            return this._driverSet = Le.then(function() {
              var Ge = qe[0];
              return Pe._dbInfo = null, Pe._ready = null, Pe.getDriver(Ge).then(function(mt) {
                Pe._driver = mt._driver, Te(), Pe._wrapLibraryMethodsWithReady(), Pe._initDriver = Fe(qe);
              });
            }).catch(function() {
              Te();
              var Ge = new Error("No available storage method found.");
              return Pe._driverSet = p.reject(Ge), Pe._driverSet;
            }), S(this._driverSet, Re, Be), this._driverSet;
          }, ie.prototype.supports = function(Ie) {
            return !!pt[Ie];
          }, ie.prototype._extend = function(Ie) {
            ve(this, Ie);
          }, ie.prototype._getSupportedDrivers = function(Ie) {
            for (var Re = [], Be = 0, Pe = Ie.length; Be < Pe; Be++) {
              var qe = Ie[Be];
              this.supports(qe) && Re.push(qe);
            }
            return Re;
          }, ie.prototype._wrapLibraryMethodsWithReady = function() {
            for (var Ie = 0, Re = Ke.length; Ie < Re; Ie++)
              te(this, Ke[Ie]);
          }, ie.prototype.createInstance = function(Ie) {
            return new ie(Ie);
          }, ie;
        }(), xe = new Dt();
        w.exports = xe;
      }, { 3: 3 }] }, {}, [4])(4);
    });
  }(To)), To.exports;
}
var sm = nm();
const E1 = /* @__PURE__ */ Nr(sm), Ds = globalThis || void 0 || self;
var E8 = {}, Ks = {};
Ks.byteLength = fm;
Ks.toByteArray = um;
Ks.fromByteArray = dm;
var Hr = [], Sr = [], om = typeof Uint8Array < "u" ? Uint8Array : Array, zo = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var Ji = 0, am = zo.length; Ji < am; ++Ji)
  Hr[Ji] = zo[Ji], Sr[zo.charCodeAt(Ji)] = Ji;
Sr[45] = 62;
Sr[95] = 63;
function I8(e) {
  var c = e.length;
  if (c % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var l = e.indexOf("=");
  l === -1 && (l = c);
  var w = l === c ? 0 : 4 - l % 4;
  return [l, w];
}
function fm(e) {
  var c = I8(e), l = c[0], w = c[1];
  return (l + w) * 3 / 4 - w;
}
function cm(e, c, l) {
  return (c + l) * 3 / 4 - l;
}
function um(e) {
  var c, l = I8(e), w = l[0], m = l[1], f = new om(cm(e, w, m)), n = 0, u = m > 0 ? w - 4 : w, o;
  for (o = 0; o < u; o += 4)
    c = Sr[e.charCodeAt(o)] << 18 | Sr[e.charCodeAt(o + 1)] << 12 | Sr[e.charCodeAt(o + 2)] << 6 | Sr[e.charCodeAt(o + 3)], f[n++] = c >> 16 & 255, f[n++] = c >> 8 & 255, f[n++] = c & 255;
  return m === 2 && (c = Sr[e.charCodeAt(o)] << 2 | Sr[e.charCodeAt(o + 1)] >> 4, f[n++] = c & 255), m === 1 && (c = Sr[e.charCodeAt(o)] << 10 | Sr[e.charCodeAt(o + 1)] << 4 | Sr[e.charCodeAt(o + 2)] >> 2, f[n++] = c >> 8 & 255, f[n++] = c & 255), f;
}
function hm(e) {
  return Hr[e >> 18 & 63] + Hr[e >> 12 & 63] + Hr[e >> 6 & 63] + Hr[e & 63];
}
function lm(e, c, l) {
  for (var w, m = [], f = c; f < l; f += 3)
    w = (e[f] << 16 & 16711680) + (e[f + 1] << 8 & 65280) + (e[f + 2] & 255), m.push(hm(w));
  return m.join("");
}
function dm(e) {
  for (var c, l = e.length, w = l % 3, m = [], f = 16383, n = 0, u = l - w; n < u; n += f)
    m.push(lm(e, n, n + f > u ? u : n + f));
  return w === 1 ? (c = e[l - 1], m.push(
    Hr[c >> 2] + Hr[c << 4 & 63] + "=="
  )) : w === 2 && (c = (e[l - 2] << 8) + e[l - 1], m.push(
    Hr[c >> 10] + Hr[c >> 4 & 63] + Hr[c << 2 & 63] + "="
  )), m.join("");
}
var fl = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
fl.read = function(e, c, l, w, m) {
  var f, n, u = m * 8 - w - 1, o = (1 << u) - 1, s = o >> 1, i = -7, p = l ? m - 1 : 0, g = l ? -1 : 1, S = e[c + p];
  for (p += g, f = S & (1 << -i) - 1, S >>= -i, i += u; i > 0; f = f * 256 + e[c + p], p += g, i -= 8)
    ;
  for (n = f & (1 << -i) - 1, f >>= -i, i += w; i > 0; n = n * 256 + e[c + p], p += g, i -= 8)
    ;
  if (f === 0)
    f = 1 - s;
  else {
    if (f === o)
      return n ? NaN : (S ? -1 : 1) * (1 / 0);
    n = n + Math.pow(2, w), f = f - s;
  }
  return (S ? -1 : 1) * n * Math.pow(2, f - w);
};
fl.write = function(e, c, l, w, m, f) {
  var n, u, o, s = f * 8 - m - 1, i = (1 << s) - 1, p = i >> 1, g = m === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, S = w ? 0 : f - 1, y = w ? 1 : -1, b = c < 0 || c === 0 && 1 / c < 0 ? 1 : 0;
  for (c = Math.abs(c), isNaN(c) || c === 1 / 0 ? (u = isNaN(c) ? 1 : 0, n = i) : (n = Math.floor(Math.log(c) / Math.LN2), c * (o = Math.pow(2, -n)) < 1 && (n--, o *= 2), n + p >= 1 ? c += g / o : c += g * Math.pow(2, 1 - p), c * o >= 2 && (n++, o /= 2), n + p >= i ? (u = 0, n = i) : n + p >= 1 ? (u = (c * o - 1) * Math.pow(2, m), n = n + p) : (u = c * Math.pow(2, p - 1) * Math.pow(2, m), n = 0)); m >= 8; e[l + S] = u & 255, S += y, u /= 256, m -= 8)
    ;
  for (n = n << m | u, s += m; s > 0; e[l + S] = n & 255, S += y, n /= 256, s -= 8)
    ;
  e[l + S - y] |= b * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(e) {
  const c = Ks, l = fl, w = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  e.Buffer = i, e.SlowBuffer = G, e.INSPECT_MAX_BYTES = 50;
  const m = 2147483647;
  e.kMaxLength = m;
  const { Uint8Array: f, ArrayBuffer: n, SharedArrayBuffer: u } = globalThis;
  i.TYPED_ARRAY_SUPPORT = o(), !i.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function o() {
    try {
      const se = new f(1), Z = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(Z, f.prototype), Object.setPrototypeOf(se, Z), se.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(i.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (i.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(i.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (i.isBuffer(this))
        return this.byteOffset;
    }
  });
  function s(se) {
    if (se > m)
      throw new RangeError('The value "' + se + '" is invalid for option "size"');
    const Z = new f(se);
    return Object.setPrototypeOf(Z, i.prototype), Z;
  }
  function i(se, Z, ee) {
    if (typeof se == "number") {
      if (typeof Z == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return y(se);
    }
    return p(se, Z, ee);
  }
  i.poolSize = 8192;
  function p(se, Z, ee) {
    if (typeof se == "string")
      return b(se, Z);
    if (n.isView(se))
      return a(se);
    if (se == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof se
      );
    if (V(se, n) || se && V(se.buffer, n) || typeof u < "u" && (V(se, u) || se && V(se.buffer, u)))
      return E(se, Z, ee);
    if (typeof se == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    const me = se.valueOf && se.valueOf();
    if (me != null && me !== se)
      return i.from(me, Z, ee);
    const Ae = H(se);
    if (Ae) return Ae;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof se[Symbol.toPrimitive] == "function")
      return i.from(se[Symbol.toPrimitive]("string"), Z, ee);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof se
    );
  }
  i.from = function(se, Z, ee) {
    return p(se, Z, ee);
  }, Object.setPrototypeOf(i.prototype, f.prototype), Object.setPrototypeOf(i, f);
  function g(se) {
    if (typeof se != "number")
      throw new TypeError('"size" argument must be of type number');
    if (se < 0)
      throw new RangeError('The value "' + se + '" is invalid for option "size"');
  }
  function S(se, Z, ee) {
    return g(se), se <= 0 ? s(se) : Z !== void 0 ? typeof ee == "string" ? s(se).fill(Z, ee) : s(se).fill(Z) : s(se);
  }
  i.alloc = function(se, Z, ee) {
    return S(se, Z, ee);
  };
  function y(se) {
    return g(se), s(se < 0 ? 0 : j(se) | 0);
  }
  i.allocUnsafe = function(se) {
    return y(se);
  }, i.allocUnsafeSlow = function(se) {
    return y(se);
  };
  function b(se, Z) {
    if ((typeof Z != "string" || Z === "") && (Z = "utf8"), !i.isEncoding(Z))
      throw new TypeError("Unknown encoding: " + Z);
    const ee = N(se, Z) | 0;
    let me = s(ee);
    const Ae = me.write(se, Z);
    return Ae !== ee && (me = me.slice(0, Ae)), me;
  }
  function h(se) {
    const Z = se.length < 0 ? 0 : j(se.length) | 0, ee = s(Z);
    for (let me = 0; me < Z; me += 1)
      ee[me] = se[me] & 255;
    return ee;
  }
  function a(se) {
    if (V(se, f)) {
      const Z = new f(se);
      return E(Z.buffer, Z.byteOffset, Z.byteLength);
    }
    return h(se);
  }
  function E(se, Z, ee) {
    if (Z < 0 || se.byteLength < Z)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (se.byteLength < Z + (ee || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let me;
    return Z === void 0 && ee === void 0 ? me = new f(se) : ee === void 0 ? me = new f(se, Z) : me = new f(se, Z, ee), Object.setPrototypeOf(me, i.prototype), me;
  }
  function H(se) {
    if (i.isBuffer(se)) {
      const Z = j(se.length) | 0, ee = s(Z);
      return ee.length === 0 || se.copy(ee, 0, 0, Z), ee;
    }
    if (se.length !== void 0)
      return typeof se.length != "number" || re(se.length) ? s(0) : h(se);
    if (se.type === "Buffer" && Array.isArray(se.data))
      return h(se.data);
  }
  function j(se) {
    if (se >= m)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + m.toString(16) + " bytes");
    return se | 0;
  }
  function G(se) {
    return +se != se && (se = 0), i.alloc(+se);
  }
  i.isBuffer = function(Z) {
    return Z != null && Z._isBuffer === !0 && Z !== i.prototype;
  }, i.compare = function(Z, ee) {
    if (V(Z, f) && (Z = i.from(Z, Z.offset, Z.byteLength)), V(ee, f) && (ee = i.from(ee, ee.offset, ee.byteLength)), !i.isBuffer(Z) || !i.isBuffer(ee))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (Z === ee) return 0;
    let me = Z.length, Ae = ee.length;
    for (let Oe = 0, ye = Math.min(me, Ae); Oe < ye; ++Oe)
      if (Z[Oe] !== ee[Oe]) {
        me = Z[Oe], Ae = ee[Oe];
        break;
      }
    return me < Ae ? -1 : Ae < me ? 1 : 0;
  }, i.isEncoding = function(Z) {
    switch (String(Z).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, i.concat = function(Z, ee) {
    if (!Array.isArray(Z))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (Z.length === 0)
      return i.alloc(0);
    let me;
    if (ee === void 0)
      for (ee = 0, me = 0; me < Z.length; ++me)
        ee += Z[me].length;
    const Ae = i.allocUnsafe(ee);
    let Oe = 0;
    for (me = 0; me < Z.length; ++me) {
      let ye = Z[me];
      if (V(ye, f))
        Oe + ye.length > Ae.length ? (i.isBuffer(ye) || (ye = i.from(ye)), ye.copy(Ae, Oe)) : f.prototype.set.call(
          Ae,
          ye,
          Oe
        );
      else if (i.isBuffer(ye))
        ye.copy(Ae, Oe);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      Oe += ye.length;
    }
    return Ae;
  };
  function N(se, Z) {
    if (i.isBuffer(se))
      return se.length;
    if (n.isView(se) || V(se, n))
      return se.byteLength;
    if (typeof se != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof se
      );
    const ee = se.length, me = arguments.length > 2 && arguments[2] === !0;
    if (!me && ee === 0) return 0;
    let Ae = !1;
    for (; ; )
      switch (Z) {
        case "ascii":
        case "latin1":
        case "binary":
          return ee;
        case "utf8":
        case "utf-8":
          return x(se).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ee * 2;
        case "hex":
          return ee >>> 1;
        case "base64":
          return X(se).length;
        default:
          if (Ae)
            return me ? -1 : x(se).length;
          Z = ("" + Z).toLowerCase(), Ae = !0;
      }
  }
  i.byteLength = N;
  function T(se, Z, ee) {
    let me = !1;
    if ((Z === void 0 || Z < 0) && (Z = 0), Z > this.length || ((ee === void 0 || ee > this.length) && (ee = this.length), ee <= 0) || (ee >>>= 0, Z >>>= 0, ee <= Z))
      return "";
    for (se || (se = "utf8"); ; )
      switch (se) {
        case "hex":
          return Y(this, Z, ee);
        case "utf8":
        case "utf-8":
          return D(this, Z, ee);
        case "ascii":
          return oe(this, Z, ee);
        case "latin1":
        case "binary":
          return v(this, Z, ee);
        case "base64":
          return ae(this, Z, ee);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return he(this, Z, ee);
        default:
          if (me) throw new TypeError("Unknown encoding: " + se);
          se = (se + "").toLowerCase(), me = !0;
      }
  }
  i.prototype._isBuffer = !0;
  function A(se, Z, ee) {
    const me = se[Z];
    se[Z] = se[ee], se[ee] = me;
  }
  i.prototype.swap16 = function() {
    const Z = this.length;
    if (Z % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let ee = 0; ee < Z; ee += 2)
      A(this, ee, ee + 1);
    return this;
  }, i.prototype.swap32 = function() {
    const Z = this.length;
    if (Z % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let ee = 0; ee < Z; ee += 4)
      A(this, ee, ee + 3), A(this, ee + 1, ee + 2);
    return this;
  }, i.prototype.swap64 = function() {
    const Z = this.length;
    if (Z % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let ee = 0; ee < Z; ee += 8)
      A(this, ee, ee + 7), A(this, ee + 1, ee + 6), A(this, ee + 2, ee + 5), A(this, ee + 3, ee + 4);
    return this;
  }, i.prototype.toString = function() {
    const Z = this.length;
    return Z === 0 ? "" : arguments.length === 0 ? D(this, 0, Z) : T.apply(this, arguments);
  }, i.prototype.toLocaleString = i.prototype.toString, i.prototype.equals = function(Z) {
    if (!i.isBuffer(Z)) throw new TypeError("Argument must be a Buffer");
    return this === Z ? !0 : i.compare(this, Z) === 0;
  }, i.prototype.inspect = function() {
    let Z = "";
    const ee = e.INSPECT_MAX_BYTES;
    return Z = this.toString("hex", 0, ee).replace(/(.{2})/g, "$1 ").trim(), this.length > ee && (Z += " ... "), "<Buffer " + Z + ">";
  }, w && (i.prototype[w] = i.prototype.inspect), i.prototype.compare = function(Z, ee, me, Ae, Oe) {
    if (V(Z, f) && (Z = i.from(Z, Z.offset, Z.byteLength)), !i.isBuffer(Z))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof Z
      );
    if (ee === void 0 && (ee = 0), me === void 0 && (me = Z ? Z.length : 0), Ae === void 0 && (Ae = 0), Oe === void 0 && (Oe = this.length), ee < 0 || me > Z.length || Ae < 0 || Oe > this.length)
      throw new RangeError("out of range index");
    if (Ae >= Oe && ee >= me)
      return 0;
    if (Ae >= Oe)
      return -1;
    if (ee >= me)
      return 1;
    if (ee >>>= 0, me >>>= 0, Ae >>>= 0, Oe >>>= 0, this === Z) return 0;
    let ye = Oe - Ae, _e = me - ee;
    const ke = Math.min(ye, _e), Me = this.slice(Ae, Oe), De = Z.slice(ee, me);
    for (let Ne = 0; Ne < ke; ++Ne)
      if (Me[Ne] !== De[Ne]) {
        ye = Me[Ne], _e = De[Ne];
        break;
      }
    return ye < _e ? -1 : _e < ye ? 1 : 0;
  };
  function q(se, Z, ee, me, Ae) {
    if (se.length === 0) return -1;
    if (typeof ee == "string" ? (me = ee, ee = 0) : ee > 2147483647 ? ee = 2147483647 : ee < -2147483648 && (ee = -2147483648), ee = +ee, re(ee) && (ee = Ae ? 0 : se.length - 1), ee < 0 && (ee = se.length + ee), ee >= se.length) {
      if (Ae) return -1;
      ee = se.length - 1;
    } else if (ee < 0)
      if (Ae) ee = 0;
      else return -1;
    if (typeof Z == "string" && (Z = i.from(Z, me)), i.isBuffer(Z))
      return Z.length === 0 ? -1 : _(se, Z, ee, me, Ae);
    if (typeof Z == "number")
      return Z = Z & 255, typeof f.prototype.indexOf == "function" ? Ae ? f.prototype.indexOf.call(se, Z, ee) : f.prototype.lastIndexOf.call(se, Z, ee) : _(se, [Z], ee, me, Ae);
    throw new TypeError("val must be string, number or Buffer");
  }
  function _(se, Z, ee, me, Ae) {
    let Oe = 1, ye = se.length, _e = Z.length;
    if (me !== void 0 && (me = String(me).toLowerCase(), me === "ucs2" || me === "ucs-2" || me === "utf16le" || me === "utf-16le")) {
      if (se.length < 2 || Z.length < 2)
        return -1;
      Oe = 2, ye /= 2, _e /= 2, ee /= 2;
    }
    function ke(De, Ne) {
      return Oe === 1 ? De[Ne] : De.readUInt16BE(Ne * Oe);
    }
    let Me;
    if (Ae) {
      let De = -1;
      for (Me = ee; Me < ye; Me++)
        if (ke(se, Me) === ke(Z, De === -1 ? 0 : Me - De)) {
          if (De === -1 && (De = Me), Me - De + 1 === _e) return De * Oe;
        } else
          De !== -1 && (Me -= Me - De), De = -1;
    } else
      for (ee + _e > ye && (ee = ye - _e), Me = ee; Me >= 0; Me--) {
        let De = !0;
        for (let Ne = 0; Ne < _e; Ne++)
          if (ke(se, Me + Ne) !== ke(Z, Ne)) {
            De = !1;
            break;
          }
        if (De) return Me;
      }
    return -1;
  }
  i.prototype.includes = function(Z, ee, me) {
    return this.indexOf(Z, ee, me) !== -1;
  }, i.prototype.indexOf = function(Z, ee, me) {
    return q(this, Z, ee, me, !0);
  }, i.prototype.lastIndexOf = function(Z, ee, me) {
    return q(this, Z, ee, me, !1);
  };
  function F(se, Z, ee, me) {
    ee = Number(ee) || 0;
    const Ae = se.length - ee;
    me ? (me = Number(me), me > Ae && (me = Ae)) : me = Ae;
    const Oe = Z.length;
    me > Oe / 2 && (me = Oe / 2);
    let ye;
    for (ye = 0; ye < me; ++ye) {
      const _e = parseInt(Z.substr(ye * 2, 2), 16);
      if (re(_e)) return ye;
      se[ee + ye] = _e;
    }
    return ye;
  }
  function R(se, Z, ee, me) {
    return P(x(Z, se.length - ee), se, ee, me);
  }
  function L(se, Z, ee, me) {
    return P(O(Z), se, ee, me);
  }
  function fe(se, Z, ee, me) {
    return P(X(Z), se, ee, me);
  }
  function ue(se, Z, ee, me) {
    return P(K(Z, se.length - ee), se, ee, me);
  }
  i.prototype.write = function(Z, ee, me, Ae) {
    if (ee === void 0)
      Ae = "utf8", me = this.length, ee = 0;
    else if (me === void 0 && typeof ee == "string")
      Ae = ee, me = this.length, ee = 0;
    else if (isFinite(ee))
      ee = ee >>> 0, isFinite(me) ? (me = me >>> 0, Ae === void 0 && (Ae = "utf8")) : (Ae = me, me = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    const Oe = this.length - ee;
    if ((me === void 0 || me > Oe) && (me = Oe), Z.length > 0 && (me < 0 || ee < 0) || ee > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    Ae || (Ae = "utf8");
    let ye = !1;
    for (; ; )
      switch (Ae) {
        case "hex":
          return F(this, Z, ee, me);
        case "utf8":
        case "utf-8":
          return R(this, Z, ee, me);
        case "ascii":
        case "latin1":
        case "binary":
          return L(this, Z, ee, me);
        case "base64":
          return fe(this, Z, ee, me);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ue(this, Z, ee, me);
        default:
          if (ye) throw new TypeError("Unknown encoding: " + Ae);
          Ae = ("" + Ae).toLowerCase(), ye = !0;
      }
  }, i.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function ae(se, Z, ee) {
    return Z === 0 && ee === se.length ? c.fromByteArray(se) : c.fromByteArray(se.slice(Z, ee));
  }
  function D(se, Z, ee) {
    ee = Math.min(se.length, ee);
    const me = [];
    let Ae = Z;
    for (; Ae < ee; ) {
      const Oe = se[Ae];
      let ye = null, _e = Oe > 239 ? 4 : Oe > 223 ? 3 : Oe > 191 ? 2 : 1;
      if (Ae + _e <= ee) {
        let ke, Me, De, Ne;
        switch (_e) {
          case 1:
            Oe < 128 && (ye = Oe);
            break;
          case 2:
            ke = se[Ae + 1], (ke & 192) === 128 && (Ne = (Oe & 31) << 6 | ke & 63, Ne > 127 && (ye = Ne));
            break;
          case 3:
            ke = se[Ae + 1], Me = se[Ae + 2], (ke & 192) === 128 && (Me & 192) === 128 && (Ne = (Oe & 15) << 12 | (ke & 63) << 6 | Me & 63, Ne > 2047 && (Ne < 55296 || Ne > 57343) && (ye = Ne));
            break;
          case 4:
            ke = se[Ae + 1], Me = se[Ae + 2], De = se[Ae + 3], (ke & 192) === 128 && (Me & 192) === 128 && (De & 192) === 128 && (Ne = (Oe & 15) << 18 | (ke & 63) << 12 | (Me & 63) << 6 | De & 63, Ne > 65535 && Ne < 1114112 && (ye = Ne));
        }
      }
      ye === null ? (ye = 65533, _e = 1) : ye > 65535 && (ye -= 65536, me.push(ye >>> 10 & 1023 | 55296), ye = 56320 | ye & 1023), me.push(ye), Ae += _e;
    }
    return W(me);
  }
  const Q = 4096;
  function W(se) {
    const Z = se.length;
    if (Z <= Q)
      return String.fromCharCode.apply(String, se);
    let ee = "", me = 0;
    for (; me < Z; )
      ee += String.fromCharCode.apply(
        String,
        se.slice(me, me += Q)
      );
    return ee;
  }
  function oe(se, Z, ee) {
    let me = "";
    ee = Math.min(se.length, ee);
    for (let Ae = Z; Ae < ee; ++Ae)
      me += String.fromCharCode(se[Ae] & 127);
    return me;
  }
  function v(se, Z, ee) {
    let me = "";
    ee = Math.min(se.length, ee);
    for (let Ae = Z; Ae < ee; ++Ae)
      me += String.fromCharCode(se[Ae]);
    return me;
  }
  function Y(se, Z, ee) {
    const me = se.length;
    (!Z || Z < 0) && (Z = 0), (!ee || ee < 0 || ee > me) && (ee = me);
    let Ae = "";
    for (let Oe = Z; Oe < ee; ++Oe)
      Ae += ce[se[Oe]];
    return Ae;
  }
  function he(se, Z, ee) {
    const me = se.slice(Z, ee);
    let Ae = "";
    for (let Oe = 0; Oe < me.length - 1; Oe += 2)
      Ae += String.fromCharCode(me[Oe] + me[Oe + 1] * 256);
    return Ae;
  }
  i.prototype.slice = function(Z, ee) {
    const me = this.length;
    Z = ~~Z, ee = ee === void 0 ? me : ~~ee, Z < 0 ? (Z += me, Z < 0 && (Z = 0)) : Z > me && (Z = me), ee < 0 ? (ee += me, ee < 0 && (ee = 0)) : ee > me && (ee = me), ee < Z && (ee = Z);
    const Ae = this.subarray(Z, ee);
    return Object.setPrototypeOf(Ae, i.prototype), Ae;
  };
  function le(se, Z, ee) {
    if (se % 1 !== 0 || se < 0) throw new RangeError("offset is not uint");
    if (se + Z > ee) throw new RangeError("Trying to access beyond buffer length");
  }
  i.prototype.readUintLE = i.prototype.readUIntLE = function(Z, ee, me) {
    Z = Z >>> 0, ee = ee >>> 0, me || le(Z, ee, this.length);
    let Ae = this[Z], Oe = 1, ye = 0;
    for (; ++ye < ee && (Oe *= 256); )
      Ae += this[Z + ye] * Oe;
    return Ae;
  }, i.prototype.readUintBE = i.prototype.readUIntBE = function(Z, ee, me) {
    Z = Z >>> 0, ee = ee >>> 0, me || le(Z, ee, this.length);
    let Ae = this[Z + --ee], Oe = 1;
    for (; ee > 0 && (Oe *= 256); )
      Ae += this[Z + --ee] * Oe;
    return Ae;
  }, i.prototype.readUint8 = i.prototype.readUInt8 = function(Z, ee) {
    return Z = Z >>> 0, ee || le(Z, 1, this.length), this[Z];
  }, i.prototype.readUint16LE = i.prototype.readUInt16LE = function(Z, ee) {
    return Z = Z >>> 0, ee || le(Z, 2, this.length), this[Z] | this[Z + 1] << 8;
  }, i.prototype.readUint16BE = i.prototype.readUInt16BE = function(Z, ee) {
    return Z = Z >>> 0, ee || le(Z, 2, this.length), this[Z] << 8 | this[Z + 1];
  }, i.prototype.readUint32LE = i.prototype.readUInt32LE = function(Z, ee) {
    return Z = Z >>> 0, ee || le(Z, 4, this.length), (this[Z] | this[Z + 1] << 8 | this[Z + 2] << 16) + this[Z + 3] * 16777216;
  }, i.prototype.readUint32BE = i.prototype.readUInt32BE = function(Z, ee) {
    return Z = Z >>> 0, ee || le(Z, 4, this.length), this[Z] * 16777216 + (this[Z + 1] << 16 | this[Z + 2] << 8 | this[Z + 3]);
  }, i.prototype.readBigUInt64LE = de(function(Z) {
    Z = Z >>> 0, C(Z, "offset");
    const ee = this[Z], me = this[Z + 7];
    (ee === void 0 || me === void 0) && M(Z, this.length - 8);
    const Ae = ee + this[++Z] * 2 ** 8 + this[++Z] * 2 ** 16 + this[++Z] * 2 ** 24, Oe = this[++Z] + this[++Z] * 2 ** 8 + this[++Z] * 2 ** 16 + me * 2 ** 24;
    return BigInt(Ae) + (BigInt(Oe) << BigInt(32));
  }), i.prototype.readBigUInt64BE = de(function(Z) {
    Z = Z >>> 0, C(Z, "offset");
    const ee = this[Z], me = this[Z + 7];
    (ee === void 0 || me === void 0) && M(Z, this.length - 8);
    const Ae = ee * 2 ** 24 + this[++Z] * 2 ** 16 + this[++Z] * 2 ** 8 + this[++Z], Oe = this[++Z] * 2 ** 24 + this[++Z] * 2 ** 16 + this[++Z] * 2 ** 8 + me;
    return (BigInt(Ae) << BigInt(32)) + BigInt(Oe);
  }), i.prototype.readIntLE = function(Z, ee, me) {
    Z = Z >>> 0, ee = ee >>> 0, me || le(Z, ee, this.length);
    let Ae = this[Z], Oe = 1, ye = 0;
    for (; ++ye < ee && (Oe *= 256); )
      Ae += this[Z + ye] * Oe;
    return Oe *= 128, Ae >= Oe && (Ae -= Math.pow(2, 8 * ee)), Ae;
  }, i.prototype.readIntBE = function(Z, ee, me) {
    Z = Z >>> 0, ee = ee >>> 0, me || le(Z, ee, this.length);
    let Ae = ee, Oe = 1, ye = this[Z + --Ae];
    for (; Ae > 0 && (Oe *= 256); )
      ye += this[Z + --Ae] * Oe;
    return Oe *= 128, ye >= Oe && (ye -= Math.pow(2, 8 * ee)), ye;
  }, i.prototype.readInt8 = function(Z, ee) {
    return Z = Z >>> 0, ee || le(Z, 1, this.length), this[Z] & 128 ? (255 - this[Z] + 1) * -1 : this[Z];
  }, i.prototype.readInt16LE = function(Z, ee) {
    Z = Z >>> 0, ee || le(Z, 2, this.length);
    const me = this[Z] | this[Z + 1] << 8;
    return me & 32768 ? me | 4294901760 : me;
  }, i.prototype.readInt16BE = function(Z, ee) {
    Z = Z >>> 0, ee || le(Z, 2, this.length);
    const me = this[Z + 1] | this[Z] << 8;
    return me & 32768 ? me | 4294901760 : me;
  }, i.prototype.readInt32LE = function(Z, ee) {
    return Z = Z >>> 0, ee || le(Z, 4, this.length), this[Z] | this[Z + 1] << 8 | this[Z + 2] << 16 | this[Z + 3] << 24;
  }, i.prototype.readInt32BE = function(Z, ee) {
    return Z = Z >>> 0, ee || le(Z, 4, this.length), this[Z] << 24 | this[Z + 1] << 16 | this[Z + 2] << 8 | this[Z + 3];
  }, i.prototype.readBigInt64LE = de(function(Z) {
    Z = Z >>> 0, C(Z, "offset");
    const ee = this[Z], me = this[Z + 7];
    (ee === void 0 || me === void 0) && M(Z, this.length - 8);
    const Ae = this[Z + 4] + this[Z + 5] * 2 ** 8 + this[Z + 6] * 2 ** 16 + (me << 24);
    return (BigInt(Ae) << BigInt(32)) + BigInt(ee + this[++Z] * 2 ** 8 + this[++Z] * 2 ** 16 + this[++Z] * 2 ** 24);
  }), i.prototype.readBigInt64BE = de(function(Z) {
    Z = Z >>> 0, C(Z, "offset");
    const ee = this[Z], me = this[Z + 7];
    (ee === void 0 || me === void 0) && M(Z, this.length - 8);
    const Ae = (ee << 24) + // Overflow
    this[++Z] * 2 ** 16 + this[++Z] * 2 ** 8 + this[++Z];
    return (BigInt(Ae) << BigInt(32)) + BigInt(this[++Z] * 2 ** 24 + this[++Z] * 2 ** 16 + this[++Z] * 2 ** 8 + me);
  }), i.prototype.readFloatLE = function(Z, ee) {
    return Z = Z >>> 0, ee || le(Z, 4, this.length), l.read(this, Z, !0, 23, 4);
  }, i.prototype.readFloatBE = function(Z, ee) {
    return Z = Z >>> 0, ee || le(Z, 4, this.length), l.read(this, Z, !1, 23, 4);
  }, i.prototype.readDoubleLE = function(Z, ee) {
    return Z = Z >>> 0, ee || le(Z, 8, this.length), l.read(this, Z, !0, 52, 8);
  }, i.prototype.readDoubleBE = function(Z, ee) {
    return Z = Z >>> 0, ee || le(Z, 8, this.length), l.read(this, Z, !1, 52, 8);
  };
  function ge(se, Z, ee, me, Ae, Oe) {
    if (!i.isBuffer(se)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (Z > Ae || Z < Oe) throw new RangeError('"value" argument is out of bounds');
    if (ee + me > se.length) throw new RangeError("Index out of range");
  }
  i.prototype.writeUintLE = i.prototype.writeUIntLE = function(Z, ee, me, Ae) {
    if (Z = +Z, ee = ee >>> 0, me = me >>> 0, !Ae) {
      const _e = Math.pow(2, 8 * me) - 1;
      ge(this, Z, ee, me, _e, 0);
    }
    let Oe = 1, ye = 0;
    for (this[ee] = Z & 255; ++ye < me && (Oe *= 256); )
      this[ee + ye] = Z / Oe & 255;
    return ee + me;
  }, i.prototype.writeUintBE = i.prototype.writeUIntBE = function(Z, ee, me, Ae) {
    if (Z = +Z, ee = ee >>> 0, me = me >>> 0, !Ae) {
      const _e = Math.pow(2, 8 * me) - 1;
      ge(this, Z, ee, me, _e, 0);
    }
    let Oe = me - 1, ye = 1;
    for (this[ee + Oe] = Z & 255; --Oe >= 0 && (ye *= 256); )
      this[ee + Oe] = Z / ye & 255;
    return ee + me;
  }, i.prototype.writeUint8 = i.prototype.writeUInt8 = function(Z, ee, me) {
    return Z = +Z, ee = ee >>> 0, me || ge(this, Z, ee, 1, 255, 0), this[ee] = Z & 255, ee + 1;
  }, i.prototype.writeUint16LE = i.prototype.writeUInt16LE = function(Z, ee, me) {
    return Z = +Z, ee = ee >>> 0, me || ge(this, Z, ee, 2, 65535, 0), this[ee] = Z & 255, this[ee + 1] = Z >>> 8, ee + 2;
  }, i.prototype.writeUint16BE = i.prototype.writeUInt16BE = function(Z, ee, me) {
    return Z = +Z, ee = ee >>> 0, me || ge(this, Z, ee, 2, 65535, 0), this[ee] = Z >>> 8, this[ee + 1] = Z & 255, ee + 2;
  }, i.prototype.writeUint32LE = i.prototype.writeUInt32LE = function(Z, ee, me) {
    return Z = +Z, ee = ee >>> 0, me || ge(this, Z, ee, 4, 4294967295, 0), this[ee + 3] = Z >>> 24, this[ee + 2] = Z >>> 16, this[ee + 1] = Z >>> 8, this[ee] = Z & 255, ee + 4;
  }, i.prototype.writeUint32BE = i.prototype.writeUInt32BE = function(Z, ee, me) {
    return Z = +Z, ee = ee >>> 0, me || ge(this, Z, ee, 4, 4294967295, 0), this[ee] = Z >>> 24, this[ee + 1] = Z >>> 16, this[ee + 2] = Z >>> 8, this[ee + 3] = Z & 255, ee + 4;
  };
  function Ee(se, Z, ee, me, Ae) {
    J(Z, me, Ae, se, ee, 7);
    let Oe = Number(Z & BigInt(4294967295));
    se[ee++] = Oe, Oe = Oe >> 8, se[ee++] = Oe, Oe = Oe >> 8, se[ee++] = Oe, Oe = Oe >> 8, se[ee++] = Oe;
    let ye = Number(Z >> BigInt(32) & BigInt(4294967295));
    return se[ee++] = ye, ye = ye >> 8, se[ee++] = ye, ye = ye >> 8, se[ee++] = ye, ye = ye >> 8, se[ee++] = ye, ee;
  }
  function we(se, Z, ee, me, Ae) {
    J(Z, me, Ae, se, ee, 7);
    let Oe = Number(Z & BigInt(4294967295));
    se[ee + 7] = Oe, Oe = Oe >> 8, se[ee + 6] = Oe, Oe = Oe >> 8, se[ee + 5] = Oe, Oe = Oe >> 8, se[ee + 4] = Oe;
    let ye = Number(Z >> BigInt(32) & BigInt(4294967295));
    return se[ee + 3] = ye, ye = ye >> 8, se[ee + 2] = ye, ye = ye >> 8, se[ee + 1] = ye, ye = ye >> 8, se[ee] = ye, ee + 8;
  }
  i.prototype.writeBigUInt64LE = de(function(Z, ee = 0) {
    return Ee(this, Z, ee, BigInt(0), BigInt("0xffffffffffffffff"));
  }), i.prototype.writeBigUInt64BE = de(function(Z, ee = 0) {
    return we(this, Z, ee, BigInt(0), BigInt("0xffffffffffffffff"));
  }), i.prototype.writeIntLE = function(Z, ee, me, Ae) {
    if (Z = +Z, ee = ee >>> 0, !Ae) {
      const ke = Math.pow(2, 8 * me - 1);
      ge(this, Z, ee, me, ke - 1, -ke);
    }
    let Oe = 0, ye = 1, _e = 0;
    for (this[ee] = Z & 255; ++Oe < me && (ye *= 256); )
      Z < 0 && _e === 0 && this[ee + Oe - 1] !== 0 && (_e = 1), this[ee + Oe] = (Z / ye >> 0) - _e & 255;
    return ee + me;
  }, i.prototype.writeIntBE = function(Z, ee, me, Ae) {
    if (Z = +Z, ee = ee >>> 0, !Ae) {
      const ke = Math.pow(2, 8 * me - 1);
      ge(this, Z, ee, me, ke - 1, -ke);
    }
    let Oe = me - 1, ye = 1, _e = 0;
    for (this[ee + Oe] = Z & 255; --Oe >= 0 && (ye *= 256); )
      Z < 0 && _e === 0 && this[ee + Oe + 1] !== 0 && (_e = 1), this[ee + Oe] = (Z / ye >> 0) - _e & 255;
    return ee + me;
  }, i.prototype.writeInt8 = function(Z, ee, me) {
    return Z = +Z, ee = ee >>> 0, me || ge(this, Z, ee, 1, 127, -128), Z < 0 && (Z = 255 + Z + 1), this[ee] = Z & 255, ee + 1;
  }, i.prototype.writeInt16LE = function(Z, ee, me) {
    return Z = +Z, ee = ee >>> 0, me || ge(this, Z, ee, 2, 32767, -32768), this[ee] = Z & 255, this[ee + 1] = Z >>> 8, ee + 2;
  }, i.prototype.writeInt16BE = function(Z, ee, me) {
    return Z = +Z, ee = ee >>> 0, me || ge(this, Z, ee, 2, 32767, -32768), this[ee] = Z >>> 8, this[ee + 1] = Z & 255, ee + 2;
  }, i.prototype.writeInt32LE = function(Z, ee, me) {
    return Z = +Z, ee = ee >>> 0, me || ge(this, Z, ee, 4, 2147483647, -2147483648), this[ee] = Z & 255, this[ee + 1] = Z >>> 8, this[ee + 2] = Z >>> 16, this[ee + 3] = Z >>> 24, ee + 4;
  }, i.prototype.writeInt32BE = function(Z, ee, me) {
    return Z = +Z, ee = ee >>> 0, me || ge(this, Z, ee, 4, 2147483647, -2147483648), Z < 0 && (Z = 4294967295 + Z + 1), this[ee] = Z >>> 24, this[ee + 1] = Z >>> 16, this[ee + 2] = Z >>> 8, this[ee + 3] = Z & 255, ee + 4;
  }, i.prototype.writeBigInt64LE = de(function(Z, ee = 0) {
    return Ee(this, Z, ee, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), i.prototype.writeBigInt64BE = de(function(Z, ee = 0) {
    return we(this, Z, ee, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function z(se, Z, ee, me, Ae, Oe) {
    if (ee + me > se.length) throw new RangeError("Index out of range");
    if (ee < 0) throw new RangeError("Index out of range");
  }
  function I(se, Z, ee, me, Ae) {
    return Z = +Z, ee = ee >>> 0, Ae || z(se, Z, ee, 4), l.write(se, Z, ee, me, 23, 4), ee + 4;
  }
  i.prototype.writeFloatLE = function(Z, ee, me) {
    return I(this, Z, ee, !0, me);
  }, i.prototype.writeFloatBE = function(Z, ee, me) {
    return I(this, Z, ee, !1, me);
  };
  function ne(se, Z, ee, me, Ae) {
    return Z = +Z, ee = ee >>> 0, Ae || z(se, Z, ee, 8), l.write(se, Z, ee, me, 52, 8), ee + 8;
  }
  i.prototype.writeDoubleLE = function(Z, ee, me) {
    return ne(this, Z, ee, !0, me);
  }, i.prototype.writeDoubleBE = function(Z, ee, me) {
    return ne(this, Z, ee, !1, me);
  }, i.prototype.copy = function(Z, ee, me, Ae) {
    if (!i.isBuffer(Z)) throw new TypeError("argument should be a Buffer");
    if (me || (me = 0), !Ae && Ae !== 0 && (Ae = this.length), ee >= Z.length && (ee = Z.length), ee || (ee = 0), Ae > 0 && Ae < me && (Ae = me), Ae === me || Z.length === 0 || this.length === 0) return 0;
    if (ee < 0)
      throw new RangeError("targetStart out of bounds");
    if (me < 0 || me >= this.length) throw new RangeError("Index out of range");
    if (Ae < 0) throw new RangeError("sourceEnd out of bounds");
    Ae > this.length && (Ae = this.length), Z.length - ee < Ae - me && (Ae = Z.length - ee + me);
    const Oe = Ae - me;
    return this === Z && typeof f.prototype.copyWithin == "function" ? this.copyWithin(ee, me, Ae) : f.prototype.set.call(
      Z,
      this.subarray(me, Ae),
      ee
    ), Oe;
  }, i.prototype.fill = function(Z, ee, me, Ae) {
    if (typeof Z == "string") {
      if (typeof ee == "string" ? (Ae = ee, ee = 0, me = this.length) : typeof me == "string" && (Ae = me, me = this.length), Ae !== void 0 && typeof Ae != "string")
        throw new TypeError("encoding must be a string");
      if (typeof Ae == "string" && !i.isEncoding(Ae))
        throw new TypeError("Unknown encoding: " + Ae);
      if (Z.length === 1) {
        const ye = Z.charCodeAt(0);
        (Ae === "utf8" && ye < 128 || Ae === "latin1") && (Z = ye);
      }
    } else typeof Z == "number" ? Z = Z & 255 : typeof Z == "boolean" && (Z = Number(Z));
    if (ee < 0 || this.length < ee || this.length < me)
      throw new RangeError("Out of range index");
    if (me <= ee)
      return this;
    ee = ee >>> 0, me = me === void 0 ? this.length : me >>> 0, Z || (Z = 0);
    let Oe;
    if (typeof Z == "number")
      for (Oe = ee; Oe < me; ++Oe)
        this[Oe] = Z;
    else {
      const ye = i.isBuffer(Z) ? Z : i.from(Z, Ae), _e = ye.length;
      if (_e === 0)
        throw new TypeError('The value "' + Z + '" is invalid for argument "value"');
      for (Oe = 0; Oe < me - ee; ++Oe)
        this[Oe + ee] = ye[Oe % _e];
    }
    return this;
  };
  const t = {};
  function d(se, Z, ee) {
    t[se] = class extends ee {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: Z.apply(this, arguments),
          writable: !0,
          configurable: !0
        }), this.name = `${this.name} [${se}]`, this.stack, delete this.name;
      }
      get code() {
        return se;
      }
      set code(Ae) {
        Object.defineProperty(this, "code", {
          configurable: !0,
          enumerable: !0,
          value: Ae,
          writable: !0
        });
      }
      toString() {
        return `${this.name} [${se}]: ${this.message}`;
      }
    };
  }
  d(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(se) {
      return se ? `${se} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  ), d(
    "ERR_INVALID_ARG_TYPE",
    function(se, Z) {
      return `The "${se}" argument must be of type number. Received type ${typeof Z}`;
    },
    TypeError
  ), d(
    "ERR_OUT_OF_RANGE",
    function(se, Z, ee) {
      let me = `The value of "${se}" is out of range.`, Ae = ee;
      return Number.isInteger(ee) && Math.abs(ee) > 2 ** 32 ? Ae = B(String(ee)) : typeof ee == "bigint" && (Ae = String(ee), (ee > BigInt(2) ** BigInt(32) || ee < -(BigInt(2) ** BigInt(32))) && (Ae = B(Ae)), Ae += "n"), me += ` It must be ${Z}. Received ${Ae}`, me;
    },
    RangeError
  );
  function B(se) {
    let Z = "", ee = se.length;
    const me = se[0] === "-" ? 1 : 0;
    for (; ee >= me + 4; ee -= 3)
      Z = `_${se.slice(ee - 3, ee)}${Z}`;
    return `${se.slice(0, ee)}${Z}`;
  }
  function U(se, Z, ee) {
    C(Z, "offset"), (se[Z] === void 0 || se[Z + ee] === void 0) && M(Z, se.length - (ee + 1));
  }
  function J(se, Z, ee, me, Ae, Oe) {
    if (se > ee || se < Z) {
      const ye = typeof Z == "bigint" ? "n" : "";
      let _e;
      throw Z === 0 || Z === BigInt(0) ? _e = `>= 0${ye} and < 2${ye} ** ${(Oe + 1) * 8}${ye}` : _e = `>= -(2${ye} ** ${(Oe + 1) * 8 - 1}${ye}) and < 2 ** ${(Oe + 1) * 8 - 1}${ye}`, new t.ERR_OUT_OF_RANGE("value", _e, se);
    }
    U(me, Ae, Oe);
  }
  function C(se, Z) {
    if (typeof se != "number")
      throw new t.ERR_INVALID_ARG_TYPE(Z, "number", se);
  }
  function M(se, Z, ee) {
    throw Math.floor(se) !== se ? (C(se, ee), new t.ERR_OUT_OF_RANGE("offset", "an integer", se)) : Z < 0 ? new t.ERR_BUFFER_OUT_OF_BOUNDS() : new t.ERR_OUT_OF_RANGE(
      "offset",
      `>= 0 and <= ${Z}`,
      se
    );
  }
  const $ = /[^+/0-9A-Za-z-_]/g;
  function r(se) {
    if (se = se.split("=")[0], se = se.trim().replace($, ""), se.length < 2) return "";
    for (; se.length % 4 !== 0; )
      se = se + "=";
    return se;
  }
  function x(se, Z) {
    Z = Z || 1 / 0;
    let ee;
    const me = se.length;
    let Ae = null;
    const Oe = [];
    for (let ye = 0; ye < me; ++ye) {
      if (ee = se.charCodeAt(ye), ee > 55295 && ee < 57344) {
        if (!Ae) {
          if (ee > 56319) {
            (Z -= 3) > -1 && Oe.push(239, 191, 189);
            continue;
          } else if (ye + 1 === me) {
            (Z -= 3) > -1 && Oe.push(239, 191, 189);
            continue;
          }
          Ae = ee;
          continue;
        }
        if (ee < 56320) {
          (Z -= 3) > -1 && Oe.push(239, 191, 189), Ae = ee;
          continue;
        }
        ee = (Ae - 55296 << 10 | ee - 56320) + 65536;
      } else Ae && (Z -= 3) > -1 && Oe.push(239, 191, 189);
      if (Ae = null, ee < 128) {
        if ((Z -= 1) < 0) break;
        Oe.push(ee);
      } else if (ee < 2048) {
        if ((Z -= 2) < 0) break;
        Oe.push(
          ee >> 6 | 192,
          ee & 63 | 128
        );
      } else if (ee < 65536) {
        if ((Z -= 3) < 0) break;
        Oe.push(
          ee >> 12 | 224,
          ee >> 6 & 63 | 128,
          ee & 63 | 128
        );
      } else if (ee < 1114112) {
        if ((Z -= 4) < 0) break;
        Oe.push(
          ee >> 18 | 240,
          ee >> 12 & 63 | 128,
          ee >> 6 & 63 | 128,
          ee & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return Oe;
  }
  function O(se) {
    const Z = [];
    for (let ee = 0; ee < se.length; ++ee)
      Z.push(se.charCodeAt(ee) & 255);
    return Z;
  }
  function K(se, Z) {
    let ee, me, Ae;
    const Oe = [];
    for (let ye = 0; ye < se.length && !((Z -= 2) < 0); ++ye)
      ee = se.charCodeAt(ye), me = ee >> 8, Ae = ee % 256, Oe.push(Ae), Oe.push(me);
    return Oe;
  }
  function X(se) {
    return c.toByteArray(r(se));
  }
  function P(se, Z, ee, me) {
    let Ae;
    for (Ae = 0; Ae < me && !(Ae + ee >= Z.length || Ae >= se.length); ++Ae)
      Z[Ae + ee] = se[Ae];
    return Ae;
  }
  function V(se, Z) {
    return se instanceof Z || se != null && se.constructor != null && se.constructor.name != null && se.constructor.name === Z.name;
  }
  function re(se) {
    return se !== se;
  }
  const ce = function() {
    const se = "0123456789abcdef", Z = new Array(256);
    for (let ee = 0; ee < 16; ++ee) {
      const me = ee * 16;
      for (let Ae = 0; Ae < 16; ++Ae)
        Z[me + Ae] = se[ee] + se[Ae];
    }
    return Z;
  }();
  function de(se) {
    return typeof BigInt > "u" ? pe : se;
  }
  function pe() {
    throw new Error("BigInt not supported");
  }
})(E8);
const k = E8.Buffer;
function bm(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var A8 = { exports: {} }, Ht = A8.exports = {}, Ur, Fr;
function tl() {
  throw new Error("setTimeout has not been defined");
}
function rl() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    typeof setTimeout == "function" ? Ur = setTimeout : Ur = tl;
  } catch {
    Ur = tl;
  }
  try {
    typeof clearTimeout == "function" ? Fr = clearTimeout : Fr = rl;
  } catch {
    Fr = rl;
  }
})();
function O8(e) {
  if (Ur === setTimeout)
    return setTimeout(e, 0);
  if ((Ur === tl || !Ur) && setTimeout)
    return Ur = setTimeout, setTimeout(e, 0);
  try {
    return Ur(e, 0);
  } catch {
    try {
      return Ur.call(null, e, 0);
    } catch {
      return Ur.call(this, e, 0);
    }
  }
}
function pm(e) {
  if (Fr === clearTimeout)
    return clearTimeout(e);
  if ((Fr === rl || !Fr) && clearTimeout)
    return Fr = clearTimeout, clearTimeout(e);
  try {
    return Fr(e);
  } catch {
    try {
      return Fr.call(null, e);
    } catch {
      return Fr.call(this, e);
    }
  }
}
var ei = [], cn = !1, ki, zs = -1;
function mm() {
  !cn || !ki || (cn = !1, ki.length ? ei = ki.concat(ei) : zs = -1, ei.length && _8());
}
function _8() {
  if (!cn) {
    var e = O8(mm);
    cn = !0;
    for (var c = ei.length; c; ) {
      for (ki = ei, ei = []; ++zs < c; )
        ki && ki[zs].run();
      zs = -1, c = ei.length;
    }
    ki = null, cn = !1, pm(e);
  }
}
Ht.nextTick = function(e) {
  var c = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var l = 1; l < arguments.length; l++)
      c[l - 1] = arguments[l];
  ei.push(new R8(e, c)), ei.length === 1 && !cn && O8(_8);
};
function R8(e, c) {
  this.fun = e, this.array = c;
}
R8.prototype.run = function() {
  this.fun.apply(null, this.array);
};
Ht.title = "browser";
Ht.browser = !0;
Ht.env = {};
Ht.argv = [];
Ht.version = "";
Ht.versions = {};
function ii() {
}
Ht.on = ii;
Ht.addListener = ii;
Ht.once = ii;
Ht.off = ii;
Ht.removeListener = ii;
Ht.removeAllListeners = ii;
Ht.emit = ii;
Ht.prependListener = ii;
Ht.prependOnceListener = ii;
Ht.listeners = function(e) {
  return [];
};
Ht.binding = function(e) {
  throw new Error("process.binding is not supported");
};
Ht.cwd = function() {
  return "/";
};
Ht.chdir = function(e) {
  throw new Error("process.chdir is not supported");
};
Ht.umask = function() {
  return 0;
};
var gm = A8.exports;
const St = /* @__PURE__ */ bm(gm);
/*!
 * assert.js - assertions for javascript
 * Copyright (c) 2018, Christopher Jeffrey (MIT License).
 * https://github.com/chjj/bsert
 */
var Co, I1;
function Xe() {
  if (I1) return Co;
  I1 = 1;
  class e extends Error {
    constructor(I) {
      typeof I == "string" && (I = { message: I }), (I === null || typeof I != "object") && (I = {});
      let ne = null, t = "fail", d = !!I.generatedMessage, B = null;
      if (I.message != null && (ne = H(I.message)), typeof I.operator == "string" && (t = I.operator), ne == null) {
        if (t === "fail")
          ne = "Assertion failed.";
        else {
          const U = E(I.actual), J = E(I.expected);
          ne = `${U} ${t} ${J}`;
        }
        d = !0;
      }
      typeof I.stackStartFunction == "function" ? B = I.stackStartFunction : typeof I.stackStartFn == "function" && (B = I.stackStartFn), super(ne), this.generatedMessage = d, this.code = "ERR_ASSERTION", this.actual = I.actual, this.expected = I.expected, this.operator = t, Object.defineProperty(this, "name", {
        value: "AssertionError [ERR_ASSERTION]",
        enumerable: !1,
        writable: !0,
        configurable: !0
      }), Error.captureStackTrace && B != null && Error.captureStackTrace(this, B), this.stack, this.name = "AssertionError";
    }
    toString() {
      return `${this.name} [${this.code}]: ${this.message}`;
    }
  }
  e.prototype.name = "AssertionError", e.prototype.type = "AssertionError";
  function c(z, I) {
    if (!z) {
      let ne = !1;
      if (arguments.length === 0)
        I = "No value argument passed to `assert()`.", ne = !0;
      else if (I == null)
        I = "Assertion failed.", ne = !0;
      else if (W(I))
        throw I;
      throw new e({
        message: I,
        actual: z,
        expected: !0,
        operator: "==",
        generatedMessage: ne,
        stackStartFn: c
      });
    }
  }
  function l(z, I, ne) {
    if (!Object.is(z, I))
      throw W(ne) ? ne : new e({
        message: ne,
        actual: z,
        expected: I,
        operator: "strictEqual",
        stackStartFn: l
      });
  }
  function w(z, I, ne) {
    if (Object.is(z, I))
      throw W(ne) ? ne : new e({
        message: ne,
        actual: z,
        expected: I,
        operator: "notStrictEqual",
        stackStartFn: w
      });
  }
  function m(z) {
    let I = !1;
    throw W(z) ? z : (z == null && (z = "Assertion failed.", I = !0), new e({
      message: z,
      actual: !1,
      expected: !0,
      operator: "fail",
      generatedMessage: I,
      stackStartFn: m
    }));
  }
  function f(z, I, ne) {
    typeof I == "string" && (ne = I, I = void 0);
    let t = !1, d = null;
    h(typeof z == "function", "func", "function");
    try {
      z();
    } catch (B) {
      t = !0, d = B;
    }
    if (!t) {
      let B = !1;
      throw ne == null && (ne = "Missing expected exception.", B = !0), new e({
        message: ne,
        actual: void 0,
        expected: I,
        operator: "throws",
        generatedMessage: B,
        stackStartFn: f
      });
    }
    if (!G(d, I, ne, f))
      throw d;
  }
  function n(z, I, ne) {
    typeof I == "string" && (ne = I, I = void 0);
    let t = !1, d = null;
    h(typeof z == "function", "func", "function");
    try {
      z();
    } catch (B) {
      t = !0, d = B;
    }
    if (t) {
      if (G(d, I, ne, n)) {
        let B = !1;
        throw ne == null && (ne = "Got unwanted exception.", B = !0), new e({
          message: ne,
          actual: d,
          expected: I,
          operator: "doesNotThrow",
          generatedMessage: B,
          stackStartFn: n
        });
      }
      throw d;
    }
  }
  async function u(z, I, ne) {
    typeof I == "string" && (ne = I, I = void 0);
    let t = !1, d = null;
    typeof z != "function" && h(Y(z), "func", "promise");
    try {
      Y(z) ? await z : await z();
    } catch (B) {
      t = !0, d = B;
    }
    if (!t) {
      let B = !1;
      throw ne == null && (ne = "Missing expected rejection.", B = !0), new e({
        message: ne,
        actual: void 0,
        expected: I,
        operator: "rejects",
        generatedMessage: B,
        stackStartFn: u
      });
    }
    if (!G(d, I, ne, u))
      throw d;
  }
  async function o(z, I, ne) {
    typeof I == "string" && (ne = I, I = void 0);
    let t = !1, d = null;
    typeof z != "function" && h(Y(z), "func", "promise");
    try {
      Y(z) ? await z : await z();
    } catch (B) {
      t = !0, d = B;
    }
    if (t) {
      if (G(d, I, ne, o)) {
        let B = !1;
        throw ne == null && (ne = "Got unwanted rejection.", B = !0), new e({
          message: ne,
          actual: void 0,
          expected: I,
          operator: "doesNotReject",
          generatedMessage: B,
          stackStartFn: o
        });
      }
      throw d;
    }
  }
  function s(z) {
    if (z != null) {
      let I = "ifError got unwanted exception: ";
      throw typeof z == "object" && typeof z.message == "string" ? z.message.length === 0 && z.constructor ? I += z.constructor.name : I += z.message : I += E(z), new e({
        message: I,
        actual: z,
        expected: null,
        operator: "ifError",
        generatedMessage: !0,
        stackStartFn: s
      });
    }
  }
  function i(z, I, ne) {
    N(z, I, ne, i, !0);
  }
  function p(z, I, ne) {
    N(z, I, ne, p, !1);
  }
  function g(z, I, ne) {
    if (!T(z, I, !1))
      throw W(ne) ? ne : new e({
        message: ne,
        actual: z,
        expected: I,
        operator: "deepStrictEqual",
        stackStartFn: g
      });
  }
  function S(z, I, ne) {
    if (T(z, I, !0))
      throw W(ne) ? ne : new e({
        message: ne,
        actual: z,
        expected: I,
        operator: "notDeepStrictEqual",
        stackStartFn: S
      });
  }
  function y(z, I, ne, t) {
    if (Ee(ne) || (t = ne, ne = null), ne == null && (ne = "hex"), I = we(z, I, ne), h(D(z), "actual", "buffer"), h(D(I), "expected", "buffer"), z !== I && !z.equals(I))
      throw W(t) ? t : new e({
        message: t,
        actual: z.toString(ne),
        expected: I.toString(ne),
        operator: "bufferEqual",
        stackStartFn: y
      });
  }
  function b(z, I, ne, t) {
    if (Ee(ne) || (t = ne, ne = null), ne == null && (ne = "hex"), I = we(z, I, ne), h(D(z), "actual", "buffer"), h(D(I), "expected", "buffer"), z === I || z.equals(I))
      throw W(t) ? t : new e({
        message: t,
        actual: z.toString(ne),
        expected: I.toString(ne),
        operator: "notBufferEqual",
        stackStartFn: b
      });
  }
  function h(z, I, ne) {
    if (!z) {
      let t;
      I == null ? t = "Invalid type for parameter." : ne == null ? t = `Invalid type for "${I}".` : t = `"${I}" must be a(n) ${ne}.`;
      const d = new TypeError(t);
      throw Error.captureStackTrace && Error.captureStackTrace(d, h), d;
    }
  }
  function a(z, I) {
    if (!z) {
      const ne = I != null ? `"${I}" is out of range.` : "Parameter is out of range.", t = new RangeError(ne);
      throw Error.captureStackTrace && Error.captureStackTrace(t, a), t;
    }
  }
  function E(z) {
    switch (typeof z) {
      case "undefined":
        return "undefined";
      case "object":
        return z === null ? "null" : `[${L(z)}]`;
      case "boolean":
        return `${z}`;
      case "number":
        return `${z}`;
      case "string":
        return z.length > 80 && (z = `${z.substring(0, 77)}...`), JSON.stringify(z);
      case "symbol":
        return j(z);
      case "function":
        return `[${fe(z)}]`;
      case "bigint":
        return `${z}n`;
      default:
        return `[${typeof z}]`;
    }
  }
  function H(z) {
    return typeof z == "string" ? z : W(z) ? j(z) : E(z);
  }
  function j(z) {
    try {
      return String(z);
    } catch {
      return "Object";
    }
  }
  function G(z, I, ne, t) {
    if (I == null)
      return !0;
    if (he(I))
      return I.test(z);
    if (typeof I != "function") {
      if (t === n || t === o)
        throw new TypeError('"expected" must not be an object.');
      if (typeof I != "object")
        throw new TypeError('"expected" must be an object.');
      let d = !1;
      if (ne == null && (ne = `Missing expected ${t === u ? "rejection" : "exception"}.`, d = !0), z == null || typeof z != "object")
        throw new e({
          actual: z,
          expected: I,
          message: ne,
          operator: t.name,
          generatedMessage: d,
          stackStartFn: t
        });
      const B = Object.keys(I);
      if (W(I) && B.push("name", "message"), B.length === 0)
        throw new TypeError('"expected" may not be an empty object.');
      for (const U of B) {
        const J = I[U], C = z[U];
        if (!(typeof C == "string" && he(J) && J.test(C)) && !(U in z && T(C, J, !1)))
          throw new e({
            actual: z,
            expected: I,
            message: ne,
            operator: t.name,
            generatedMessage: d,
            stackStartFn: t
          });
      }
      return !0;
    }
    return I.prototype !== void 0 && z instanceof I ? !0 : Error.isPrototypeOf(I) ? !1 : I.call({}, z) === !0;
  }
  function N(z, I, ne, t, d) {
    if (h(typeof z == "string", "string", "string"), h(he(I), "regexp", "RegExp"), I.test(z) !== d) {
      if (W(ne))
        throw ne;
      let B = !1;
      throw ne == null && (ne = `The input ${d ? "did" : "was expected to"} not match the regular expression ${I}. Input:

${E(z)}
`, B = !0), new e({
        actual: z,
        expected: I,
        message: ne,
        operator: t.name,
        generatedMessage: B,
        stackStartFn: t
      });
    }
  }
  function T(z, I, ne) {
    try {
      return A(z, I, null);
    } catch {
      return ne;
    }
  }
  function A(z, I, ne) {
    if (Object.is(z, I))
      return !0;
    if (!v(z) || !v(I) || F(z) !== F(I) || Object.getPrototypeOf(z) !== Object.getPrototypeOf(I))
      return !1;
    if (D(z) && D(I))
      return z.equals(I);
    if (Q(z))
      return Object.is(z.getTime(), I.getTime());
    if (he(z))
      return z.source === I.source && z.flags === I.flags;
    if (W(z) && z.message !== I.message)
      return !1;
    if (ae(z) && (z = new Uint8Array(z), I = new Uint8Array(I)), ge(z) && !D(z)) {
      if (D(I))
        return !1;
      const d = new Uint8Array(z.buffer, z.byteOffset, z.byteLength), B = new Uint8Array(I.buffer, I.byteOffset, I.byteLength);
      if (d.length !== B.length)
        return !1;
      for (let U = 0; U < d.length; U++)
        if (d[U] !== B[U])
          return !1;
      return !0;
    }
    if (le(z))
      return z.size !== I.size ? !1 : (/* @__PURE__ */ new Set([...z, ...I])).size === z.size;
    if (!ne)
      ne = {
        a: /* @__PURE__ */ new Map(),
        b: /* @__PURE__ */ new Map(),
        p: 0
      };
    else {
      const d = ne.a.get(z);
      if (d != null) {
        const B = ne.b.get(I);
        if (B != null)
          return d === B;
      }
      ne.p += 1;
    }
    ne.a.set(z, ne.p), ne.b.set(I, ne.p);
    const t = q(z, I, ne);
    return ne.a.delete(z), ne.b.delete(I), t;
  }
  function q(z, I, ne) {
    if (oe(z)) {
      if (z.size !== I.size)
        return !1;
      const U = /* @__PURE__ */ new Set([...z.keys(), ...I.keys()]);
      if (U.size !== z.size)
        return !1;
      for (const J of U)
        if (!A(z.get(J), I.get(J), ne))
          return !1;
      return !0;
    }
    if (ue(z)) {
      if (z.length !== I.length)
        return !1;
      for (let U = 0; U < z.length; U++)
        if (!A(z[U], I[U], ne))
          return !1;
      return !0;
    }
    const t = _(z), d = _(I);
    if (t.length !== d.length)
      return !1;
    const B = /* @__PURE__ */ new Set([...t, ...d]);
    if (B.size !== t.length)
      return !1;
    for (const U of B)
      if (!A(z[U], I[U], ne))
        return !1;
    return !0;
  }
  function _(z) {
    const I = Object.keys(z);
    if (!Object.getOwnPropertySymbols || !Object.getOwnPropertyDescriptor)
      return I;
    const ne = Object.getOwnPropertySymbols(z);
    for (const t of ne) {
      const d = Object.getOwnPropertyDescriptor(z, t);
      d && d.enumerable && I.push(t);
    }
    return I;
  }
  function F(z) {
    if (z === void 0)
      return "[object Undefined]";
    if (z === null)
      return "[object Null]";
    try {
      return Object.prototype.toString.call(z);
    } catch {
      return "[object Object]";
    }
  }
  function R(z) {
    return F(z).slice(8, -1);
  }
  function L(z) {
    const I = R(z);
    if (z == null || I !== "Object" && I !== "Error")
      return I;
    let ne, t;
    try {
      ne = z.constructor;
    } catch {
    }
    if (ne == null)
      return I;
    try {
      t = ne.name;
    } catch {
      return I;
    }
    return typeof t != "string" || t.length === 0 ? I : t;
  }
  function fe(z) {
    let I;
    try {
      I = z.name;
    } catch {
    }
    return typeof I != "string" || I.length === 0 ? "Function" : `Function: ${I}`;
  }
  function ue(z) {
    return Array.isArray(z);
  }
  function ae(z) {
    return z instanceof ArrayBuffer;
  }
  function D(z) {
    return v(z) && typeof z.writeUInt32LE == "function" && typeof z.equals == "function";
  }
  function Q(z) {
    return z instanceof Date;
  }
  function W(z) {
    return z instanceof Error;
  }
  function oe(z) {
    return z instanceof Map;
  }
  function v(z) {
    return z && typeof z == "object";
  }
  function Y(z) {
    return z instanceof Promise;
  }
  function he(z) {
    return z instanceof RegExp;
  }
  function le(z) {
    return z instanceof Set;
  }
  function ge(z) {
    return ArrayBuffer.isView(z);
  }
  function Ee(z) {
    if (typeof z != "string" || z.length > 9)
      return !1;
    switch (z.toLowerCase()) {
      case "ascii":
      case "binary":
      case "base64":
      case "base64url":
      case "hex":
      case "latin1":
      case "ucs2":
      case "utf8":
      case "utf16le":
      case "ucs-2":
      case "utf-8":
      case "utf-16le":
        return !0;
    }
    return !1;
  }
  function we(z, I, ne) {
    if (typeof I == "string") {
      if (!D(z))
        return null;
      const { constructor: t } = z;
      if (!t || typeof t.from != "function" || !Ee(ne))
        return null;
      const d = t.from(I, ne);
      return ne.length === 3 && d.length * 2 !== I.length ? null : d;
    }
    return I;
  }
  return c.AssertionError = e, c.assert = c, c.strict = c, c.ok = c, c.equal = l, c.notEqual = w, c.strictEqual = l, c.notStrictEqual = w, c.fail = m, c.throws = f, c.doesNotThrow = n, c.rejects = u, c.doesNotReject = o, c.ifError = s, c.match = i, c.doesNotMatch = p, c.deepEqual = g, c.notDeepEqual = S, c.deepStrictEqual = g, c.notDeepStrictEqual = S, c.bufferEqual = y, c.notBufferEqual = b, c.enforce = h, c.range = a, Co = c, Co;
}
var xm = Xe();
const dt = /* @__PURE__ */ Nr(xm);
var ze = {}, Do = {}, A1;
function P8() {
  return A1 || (A1 = 1, Do.custom = "inspect"), Do;
}
var He = {};
/*!
 * enforce.js - type enforcement for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var Uo, O1;
function mn() {
  if (O1) return Uo;
  O1 = 1;
  function e(c, l, w) {
    if (!c) {
      const m = new TypeError(`'${l}' must be a(n) ${w}.`);
      throw Error.captureStackTrace && Error.captureStackTrace(m, e), m;
    }
  }
  return Uo = e, Uo;
}
/*!
 * error.js - encoding error for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var Fo, _1;
function Jn() {
  if (_1) return Fo;
  _1 = 1;
  class e extends Error {
    /**
     * Create an encoding error.
     * @constructor
     * @param {Number} offset
     * @param {String} reason
     */
    constructor(l, w, m) {
      super(), this.type = "EncodingError", this.name = "EncodingError", this.code = "ERR_ENCODING", this.message = `${w} (offset=${l}).`, Error.captureStackTrace && Error.captureStackTrace(this, m || e);
    }
  }
  return Fo = e, Fo;
}
var R1;
function Vs() {
  if (R1) return He;
  R1 = 1;
  const e = mn(), c = Jn(), l = 1 / 4294967296, { MAX_SAFE_INTEGER: w } = Number, m = new Float32Array(1), f = new Uint8Array(m.buffer), n = new Float64Array(1), u = new Uint8Array(n.buffer);
  m[0] = -1;
  const o = f[3] === 0;
  function s(xe, ie, be) {
    switch (be) {
      case 8:
        return i(xe, ie);
      case 7:
        return p(xe, ie);
      case 6:
        return g(xe, ie);
      case 5:
        return S(xe, ie);
      case 4:
        return y(xe, ie);
      case 3:
        return b(xe, ie);
      case 2:
        return h(xe, ie);
      case 1:
        return a(xe, ie);
      default:
        throw new c(ie, "Invalid read length");
    }
  }
  function i(xe, ie) {
    const be = y(xe, ie + 4), Ie = y(xe, ie);
    return Dt((be & 4292870144) === 0, ie, "Number exceeds 2^53-1"), be * 4294967296 + Ie;
  }
  function p(xe, ie) {
    const be = b(xe, ie + 4), Ie = y(xe, ie);
    return Dt((be & 4292870144) === 0, ie, "Number exceeds 2^53-1"), be * 4294967296 + Ie;
  }
  function g(xe, ie) {
    return xe[ie++] + xe[ie++] * 256 + xe[ie++] * 65536 + xe[ie++] * 16777216 + xe[ie++] * 4294967296 + xe[ie] * 1099511627776;
  }
  function S(xe, ie) {
    return xe[ie++] + xe[ie++] * 256 + xe[ie++] * 65536 + xe[ie++] * 16777216 + xe[ie] * 4294967296;
  }
  function y(xe, ie) {
    return xe[ie++] + xe[ie++] * 256 + xe[ie++] * 65536 + xe[ie] * 16777216;
  }
  function b(xe, ie) {
    return xe[ie++] + xe[ie++] * 256 + xe[ie] * 65536;
  }
  function h(xe, ie) {
    return xe[ie++] + xe[ie] * 256;
  }
  function a(xe, ie) {
    return xe[ie];
  }
  function E(xe, ie, be) {
    switch (be) {
      case 8:
        return H(xe, ie);
      case 7:
        return j(xe, ie);
      case 6:
        return G(xe, ie);
      case 5:
        return N(xe, ie);
      case 4:
        return T(xe, ie);
      case 3:
        return A(xe, ie);
      case 2:
        return q(xe, ie);
      case 1:
        return a(xe, ie);
      default:
        throw new c(ie, "Invalid read length");
    }
  }
  function H(xe, ie) {
    const be = T(xe, ie), Ie = T(xe, ie + 4);
    return Dt((be & 4292870144) === 0, ie, "Number exceeds 2^53-1"), be * 4294967296 + Ie;
  }
  function j(xe, ie) {
    const be = A(xe, ie), Ie = T(xe, ie + 3);
    return Dt((be & 4292870144) === 0, ie, "Number exceeds 2^53-1"), be * 4294967296 + Ie;
  }
  function G(xe, ie) {
    return xe[ie++] * 1099511627776 + xe[ie++] * 4294967296 + xe[ie++] * 16777216 + xe[ie++] * 65536 + xe[ie++] * 256 + xe[ie];
  }
  function N(xe, ie) {
    return xe[ie++] * 4294967296 + xe[ie++] * 16777216 + xe[ie++] * 65536 + xe[ie++] * 256 + xe[ie];
  }
  function T(xe, ie) {
    return xe[ie++] * 16777216 + xe[ie++] * 65536 + xe[ie++] * 256 + xe[ie];
  }
  function A(xe, ie) {
    return xe[ie++] * 65536 + xe[ie++] * 256 + xe[ie];
  }
  function q(xe, ie) {
    return xe[ie++] * 256 + xe[ie];
  }
  function _(xe, ie, be) {
    switch (be) {
      case 8:
        return F(xe, ie);
      case 7:
        return R(xe, ie);
      case 6:
        return L(xe, ie);
      case 5:
        return fe(xe, ie);
      case 4:
        return ue(xe, ie);
      case 3:
        return ae(xe, ie);
      case 2:
        return D(xe, ie);
      case 1:
        return Q(xe, ie);
      default:
        throw new c(ie, "Invalid read length");
    }
  }
  function F(xe, ie) {
    const be = ue(xe, ie + 4), Ie = y(xe, ie);
    return Dt(ht(be, Ie), "Number exceeds 2^53-1"), be * 4294967296 + Ie;
  }
  function R(xe, ie) {
    const be = ae(xe, ie + 4), Ie = y(xe, ie);
    return Dt(ht(be, Ie), "Number exceeds 2^53-1"), be * 4294967296 + Ie;
  }
  function L(xe, ie) {
    const be = xe[ie + 4] + xe[ie + 5] * 256;
    return xe[ie++] + xe[ie++] * 256 + xe[ie++] * 65536 + xe[ie] * 16777216 + (be | (be & 32768) * 131070) * 4294967296;
  }
  function fe(xe, ie) {
    return xe[ie++] + xe[ie++] * 256 + xe[ie++] * 65536 + xe[ie++] * 16777216 + (xe[ie] | (xe[ie] & 128) * 33554430) * 4294967296;
  }
  function ue(xe, ie) {
    return xe[ie++] + xe[ie++] * 256 + xe[ie++] * 65536 + (xe[ie] << 24);
  }
  function ae(xe, ie) {
    const be = xe[ie++] + xe[ie++] * 256 + xe[ie] * 65536;
    return be | (be & 8388608) * 510;
  }
  function D(xe, ie) {
    const be = xe[ie++] + xe[ie] * 256;
    return be | (be & 32768) * 131070;
  }
  function Q(xe, ie) {
    const be = xe[ie];
    return be | (be & 128) * 33554430;
  }
  function W(xe, ie, be) {
    switch (be) {
      case 8:
        return oe(xe, ie);
      case 7:
        return v(xe, ie);
      case 6:
        return Y(xe, ie);
      case 5:
        return he(xe, ie);
      case 4:
        return le(xe, ie);
      case 3:
        return ge(xe, ie);
      case 2:
        return Ee(xe, ie);
      case 1:
        return Q(xe, ie);
      default:
        throw new c(ie, "Invalid read length");
    }
  }
  function oe(xe, ie) {
    const be = le(xe, ie), Ie = T(xe, ie + 4);
    return Dt(ht(be, Ie), "Number exceeds 2^53-1"), be * 4294967296 + Ie;
  }
  function v(xe, ie) {
    const be = ge(xe, ie), Ie = T(xe, ie + 3);
    return Dt(ht(be, Ie), "Number exceeds 2^53-1"), be * 4294967296 + Ie;
  }
  function Y(xe, ie) {
    const be = xe[ie++] * 256 + xe[ie++];
    return (be | (be & 32768) * 131070) * 4294967296 + xe[ie++] * 16777216 + xe[ie++] * 65536 + xe[ie++] * 256 + xe[ie];
  }
  function he(xe, ie) {
    const be = xe[ie++];
    return (be | (be & 128) * 33554430) * 4294967296 + xe[ie++] * 16777216 + xe[ie++] * 65536 + xe[ie++] * 256 + xe[ie];
  }
  function le(xe, ie) {
    return (xe[ie++] << 24) + xe[ie++] * 65536 + xe[ie++] * 256 + xe[ie];
  }
  function ge(xe, ie) {
    const be = xe[ie++] * 65536 + xe[ie++] * 256 + xe[ie];
    return be | (be & 8388608) * 510;
  }
  function Ee(xe, ie) {
    const be = xe[ie++] * 256 + xe[ie];
    return be | (be & 32768) * 131070;
  }
  function we(xe, ie) {
    return f[3] = xe[ie++], f[2] = xe[ie++], f[1] = xe[ie++], f[0] = xe[ie], m[0];
  }
  function z(xe, ie) {
    return f[0] = xe[ie++], f[1] = xe[ie++], f[2] = xe[ie++], f[3] = xe[ie], m[0];
  }
  function I(xe, ie) {
    return u[7] = xe[ie++], u[6] = xe[ie++], u[5] = xe[ie++], u[4] = xe[ie++], u[3] = xe[ie++], u[2] = xe[ie++], u[1] = xe[ie++], u[0] = xe[ie], n[0];
  }
  function ne(xe, ie) {
    return u[0] = xe[ie++], u[1] = xe[ie++], u[2] = xe[ie++], u[3] = xe[ie++], u[4] = xe[ie++], u[5] = xe[ie++], u[6] = xe[ie++], u[7] = xe[ie], n[0];
  }
  const t = o ? we : z, d = o ? z : we, B = o ? I : ne, U = o ? ne : I;
  function J(xe, ie, be, Ie) {
    switch (Ie) {
      case 8:
        return C(xe, ie, be);
      case 7:
        return M(xe, ie, be);
      case 6:
        return $(xe, ie, be);
      case 5:
        return r(xe, ie, be);
      case 4:
        return x(xe, ie, be);
      case 3:
        return O(xe, ie, be);
      case 2:
        return K(xe, ie, be);
      case 1:
        return X(xe, ie, be);
      default:
        throw new c(be, "Invalid write length");
    }
  }
  function C(xe, ie, be) {
    return e(Number.isSafeInteger(ie), "num", "integer"), at(xe, ie, be, !1);
  }
  function M(xe, ie, be) {
    return e(Number.isSafeInteger(ie), "num", "integer"), Ke(xe, ie, be, !1);
  }
  function $(xe, ie, be) {
    e(Number.isSafeInteger(ie), "num", "integer");
    const Ie = ie * l | 0;
    return xe[be++] = ie, ie >>>= 8, xe[be++] = ie, ie >>>= 8, xe[be++] = ie, ie >>>= 8, xe[be++] = ie, xe[be++] = Ie, xe[be++] = Ie >>> 8, be;
  }
  function r(xe, ie, be) {
    e(Number.isSafeInteger(ie), "num", "integer");
    const Ie = ie * l | 0;
    return xe[be++] = ie, ie >>>= 8, xe[be++] = ie, ie >>>= 8, xe[be++] = ie, ie >>>= 8, xe[be++] = ie, xe[be++] = Ie, be;
  }
  function x(xe, ie, be) {
    return e(Number.isSafeInteger(ie), "num", "integer"), xe[be++] = ie, ie >>>= 8, xe[be++] = ie, ie >>>= 8, xe[be++] = ie, ie >>>= 8, xe[be++] = ie, be;
  }
  function O(xe, ie, be) {
    return e(Number.isSafeInteger(ie), "num", "integer"), xe[be++] = ie, ie >>>= 8, xe[be++] = ie, ie >>>= 8, xe[be++] = ie, be;
  }
  function K(xe, ie, be) {
    return e(Number.isSafeInteger(ie), "num", "integer"), xe[be++] = ie, xe[be++] = ie >>> 8, be;
  }
  function X(xe, ie, be) {
    return e(Number.isSafeInteger(ie), "num", "integer"), xe[be] = ie, be + 1;
  }
  function P(xe, ie, be, Ie) {
    switch (Ie) {
      case 8:
        return V(xe, ie, be);
      case 7:
        return re(xe, ie, be);
      case 6:
        return ce(xe, ie, be);
      case 5:
        return de(xe, ie, be);
      case 4:
        return pe(xe, ie, be);
      case 3:
        return se(xe, ie, be);
      case 2:
        return Z(xe, ie, be);
      case 1:
        return X(xe, ie, be);
      default:
        throw new c(be, "Invalid write length");
    }
  }
  function V(xe, ie, be) {
    return e(Number.isSafeInteger(ie), "num", "integer"), at(xe, ie, be, !0);
  }
  function re(xe, ie, be) {
    return e(Number.isSafeInteger(ie), "num", "integer"), Ke(xe, ie, be, !0);
  }
  function ce(xe, ie, be) {
    e(Number.isSafeInteger(ie), "num", "integer");
    const Ie = ie * l | 0;
    return xe[be++] = Ie >>> 8, xe[be++] = Ie, xe[be + 3] = ie, ie >>>= 8, xe[be + 2] = ie, ie >>>= 8, xe[be + 1] = ie, ie >>>= 8, xe[be] = ie, be + 4;
  }
  function de(xe, ie, be) {
    e(Number.isSafeInteger(ie), "num", "integer");
    const Ie = ie * l | 0;
    return xe[be++] = Ie, xe[be + 3] = ie, ie >>>= 8, xe[be + 2] = ie, ie >>>= 8, xe[be + 1] = ie, ie >>>= 8, xe[be] = ie, be + 4;
  }
  function pe(xe, ie, be) {
    return e(Number.isSafeInteger(ie), "num", "integer"), xe[be + 3] = ie, ie >>>= 8, xe[be + 2] = ie, ie >>>= 8, xe[be + 1] = ie, ie >>>= 8, xe[be] = ie, be + 4;
  }
  function se(xe, ie, be) {
    return e(Number.isSafeInteger(ie), "num", "integer"), xe[be + 2] = ie, ie >>>= 8, xe[be + 1] = ie, ie >>>= 8, xe[be] = ie, be + 3;
  }
  function Z(xe, ie, be) {
    return e(Number.isSafeInteger(ie), "num", "integer"), xe[be++] = ie >>> 8, xe[be++] = ie, be;
  }
  function ee(xe, ie, be, Ie) {
    switch (Ie) {
      case 8:
        return C(xe, ie, be);
      case 7:
        return M(xe, ie, be);
      case 6:
        return $(xe, ie, be);
      case 5:
        return r(xe, ie, be);
      case 4:
        return O(xe, ie, be);
      case 3:
        return x(xe, ie, be);
      case 2:
        return K(xe, ie, be);
      case 1:
        return X(xe, ie, be);
      default:
        throw new c(be, "Invalid write length");
    }
  }
  function me(xe, ie, be) {
    return C(xe, ie, be);
  }
  function Ae(xe, ie, be) {
    return M(xe, ie, be);
  }
  function Oe(xe, ie, be) {
    return $(xe, ie, be);
  }
  function ye(xe, ie, be) {
    return r(xe, ie, be);
  }
  function _e(xe, ie, be) {
    return x(xe, ie, be);
  }
  function ke(xe, ie, be) {
    return O(xe, ie, be);
  }
  function Me(xe, ie, be) {
    return K(xe, ie, be);
  }
  function De(xe, ie, be) {
    return X(xe, ie, be);
  }
  function Ne(xe, ie, be, Ie) {
    switch (Ie) {
      case 8:
        return V(xe, ie, be);
      case 7:
        return re(xe, ie, be);
      case 6:
        return ce(xe, ie, be);
      case 5:
        return de(xe, ie, be);
      case 4:
        return pe(xe, ie, be);
      case 3:
        return se(xe, ie, be);
      case 2:
        return Z(xe, ie, be);
      case 1:
        return X(xe, ie, be);
      default:
        throw new c(be, "Invalid write length");
    }
  }
  function $e(xe, ie, be) {
    return V(xe, ie, be);
  }
  function bt(xe, ie, be) {
    return re(xe, ie, be);
  }
  function Ve(xe, ie, be) {
    return ce(xe, ie, be);
  }
  function je(xe, ie, be) {
    return de(xe, ie, be);
  }
  function _t(xe, ie, be) {
    return pe(xe, ie, be);
  }
  function Je(xe, ie, be) {
    return se(xe, ie, be);
  }
  function Ye(xe, ie, be) {
    return Z(xe, ie, be);
  }
  function Ot(xe, ie, be) {
    return e(te(ie), "num", "number"), n[0] = ie, xe[be++] = u[0], xe[be++] = u[1], xe[be++] = u[2], xe[be++] = u[3], xe[be++] = u[4], xe[be++] = u[5], xe[be++] = u[6], xe[be++] = u[7], be;
  }
  function We(xe, ie, be) {
    return e(te(ie), "num", "number"), n[0] = ie, xe[be++] = u[7], xe[be++] = u[6], xe[be++] = u[5], xe[be++] = u[4], xe[be++] = u[3], xe[be++] = u[2], xe[be++] = u[1], xe[be++] = u[0], be;
  }
  function Ze(xe, ie, be) {
    return e(te(ie), "num", "number"), m[0] = ie, xe[be++] = f[0], xe[be++] = f[1], xe[be++] = f[2], xe[be++] = f[3], be;
  }
  function Tt(xe, ie, be) {
    return e(te(ie), "num", "number"), m[0] = ie, xe[be++] = f[3], xe[be++] = f[2], xe[be++] = f[1], xe[be++] = f[0], be;
  }
  const Qe = o ? Tt : Ze, rt = o ? Ze : Tt, ur = o ? We : Ot, nt = o ? Ot : We;
  function ft(xe, ie) {
    let be, Ie;
    switch (ve(ie < xe.length, ie), xe[ie]) {
      case 255:
        Ie = 9, ve(ie + Ie <= xe.length, ie), be = i(xe, ie + 1), Dt(be > 4294967295, ie, "Non-canonical varint");
        break;
      case 254:
        Ie = 5, ve(ie + Ie <= xe.length, ie), be = y(xe, ie + 1), Dt(be > 65535, ie, "Non-canonical varint");
        break;
      case 253:
        Ie = 3, ve(ie + Ie <= xe.length, ie), be = h(xe, ie + 1), Dt(be >= 253, ie, "Non-canonical varint");
        break;
      default:
        Ie = 1, be = xe[ie];
        break;
    }
    return new Se(Ie, be);
  }
  function gr(xe, ie, be) {
    return e(Number.isSafeInteger(ie), "num", "integer"), ie < 253 ? (xe[be++] = ie, be) : ie <= 65535 ? (xe[be++] = 253, K(xe, ie, be)) : ie <= 4294967295 ? (xe[be++] = 254, x(xe, ie, be)) : (xe[be++] = 255, C(xe, ie, be));
  }
  function et(xe) {
    return e(Number.isSafeInteger(xe), "num", "integer"), xe < 253 ? 1 : xe <= 65535 ? 3 : xe <= 4294967295 ? 5 : 9;
  }
  function ct(xe, ie) {
    let be = 0, Ie = 0;
    for (; ; ) {
      ve(ie < xe.length, ie);
      const Re = xe[ie++];
      if (Ie += 1, Dt(be <= 70368744177663 - (Re & 127), ie, "Number exceeds 2^53-1"), be = be * 128 + (Re & 127), (Re & 128) === 0)
        break;
      Dt(be !== w, ie, "Number exceeds 2^53-1"), be += 1;
    }
    return new Se(Ie, be);
  }
  function hr(xe, ie, be) {
    e(Number.isSafeInteger(ie), "num", "integer");
    const Ie = [];
    let Re = 0;
    for (; Ie[Re] = ie & 127 | (Re ? 128 : 0), !(ie <= 127); )
      ie = (ie - ie % 128) / 128 - 1, Re += 1;
    ve(be + Re + 1 <= xe.length, be);
    do
      xe[be++] = Ie[Re];
    while (Re--);
    return be;
  }
  function ut(xe) {
    e(Number.isSafeInteger(xe), "num", "integer");
    let ie = 0;
    for (; ie += 1, !(xe <= 127); )
      xe = (xe - xe % 128) / 128 - 1;
    return ie;
  }
  function lt(xe, ie, be) {
    if (e(k.isBuffer(xe), "data", "buffer"), e(ie >>> 0 === ie, "off", "integer"), e(be >>> 0 === be, "size", "integer"), ie + be > xe.length)
      throw new c(ie, "Out of bounds read");
    return xe.slice(ie, ie + be);
  }
  function lr(xe, ie, be) {
    if (e(k.isBuffer(xe), "data", "buffer"), e(ie >>> 0 === ie, "off", "integer"), e(be >>> 0 === be, "size", "integer"), ie + be > xe.length)
      throw new c(ie, "Out of bounds read");
    const Ie = k.allocUnsafeSlow(be);
    return xe.copy(Ie, 0, ie, ie + be), Ie;
  }
  function tt(xe, ie, be) {
    if (e(k.isBuffer(xe), "data", "buffer"), e(k.isBuffer(ie), "value", "buffer"), e(be >>> 0 === be, "off", "integer"), be + ie.length > xe.length)
      throw new c(be, "Out of bounds write");
    return ie.copy(xe, be, 0, ie.length);
  }
  function it(xe, ie, be, Ie) {
    if (Ie == null && (Ie = "binary"), e(k.isBuffer(xe), "data", "buffer"), e(ie >>> 0 === ie, "off", "integer"), e(be >>> 0 === be, "size", "integer"), e(typeof Ie == "string", "enc", "string"), ie + be > xe.length)
      throw new c(ie, "Out of bounds read");
    return xe.toString(Ie, ie, ie + be);
  }
  function _r(xe, ie, be, Ie) {
    if (Ie == null && (Ie = "binary"), e(k.isBuffer(xe), "data", "buffer"), e(typeof ie == "string", "str", "string"), e(be >>> 0 === be, "off", "integer"), e(typeof Ie == "string", "enc", "string"), ie.length === 0)
      return 0;
    const Re = k.byteLength(ie, Ie);
    if (be + Re > xe.length)
      throw new c(be, "Out of bounds write");
    return xe.write(ie, be, Ie);
  }
  function st(xe, ie) {
    e(k.isBuffer(xe), "data", "buffer");
    const be = k.allocUnsafeSlow(ie);
    return xe.copy(be, 0), be;
  }
  function gt(xe) {
    return e(k.isBuffer(xe), "data", "buffer"), st(xe, xe.length);
  }
  function Dr(xe, ie) {
    e(k.isBuffer(xe), "a", "buffer"), e(k.isBuffer(ie), "b", "buffer");
    const be = xe.length + ie.length, Ie = k.allocUnsafeSlow(be);
    return xe.copy(Ie, 0), ie.copy(Ie, xe.length), Ie;
  }
  function ot(xe) {
    return e(k.isBuffer(xe), "data", "buffer"), et(xe.length) + xe.length;
  }
  function pt(xe) {
    return et(xe) + xe;
  }
  function nr(xe, ie) {
    if (ie == null && (ie = "binary"), e(typeof xe == "string", "str", "string"), e(typeof ie == "string", "enc", "string"), xe.length === 0)
      return 1;
    const be = k.byteLength(xe, ie);
    return et(be) + be;
  }
  function ht(xe, ie) {
    return xe < 0 && (xe = ~xe, ie === 0 && (xe += 1)), (xe & 4292870144) === 0;
  }
  function at(xe, ie, be, Ie) {
    let Re = !1;
    ie < 0 && (ie = -ie, Re = !0);
    let Be = ie * l | 0, Pe = ie | 0;
    return Re && (Pe === 0 ? Be = ~Be + 1 | 0 : (Be = ~Be, Pe = ~Pe + 1)), Ie ? (be = _t(xe, Be, be), be = _t(xe, Pe, be)) : (be = _e(xe, Pe, be), be = _e(xe, Be, be)), be;
  }
  function Ke(xe, ie, be, Ie) {
    let Re = !1;
    ie < 0 && (ie = -ie, Re = !0);
    let Be = ie * l | 0, Pe = ie | 0;
    return Re && (Pe === 0 ? Be = ~Be + 1 | 0 : (Be = ~Be, Pe = ~Pe + 1)), Ie ? (be = Je(xe, Be, be), be = _t(xe, Pe, be)) : (be = _e(xe, Pe, be), be = ke(xe, Be, be)), be;
  }
  class Se {
    constructor(ie, be) {
      this.size = ie, this.value = be;
    }
  }
  function te(xe) {
    return typeof xe == "number" && isFinite(xe);
  }
  function ve(xe, ie) {
    if (!xe)
      throw new c(ie, "Out of bounds read", ve);
  }
  function Dt(xe, ie, be) {
    if (!xe)
      throw new c(ie, be, Dt);
  }
  return He.readU = s, He.readU64 = i, He.readU56 = p, He.readU48 = g, He.readU40 = S, He.readU32 = y, He.readU24 = b, He.readU16 = h, He.readU8 = a, He.readUBE = E, He.readU64BE = H, He.readU56BE = j, He.readU48BE = G, He.readU40BE = N, He.readU32BE = T, He.readU24BE = A, He.readU16BE = q, He.readI = _, He.readI64 = F, He.readI56 = R, He.readI48 = L, He.readI40 = fe, He.readI32 = ue, He.readI24 = ae, He.readI16 = D, He.readI8 = Q, He.readIBE = W, He.readI64BE = oe, He.readI56BE = v, He.readI48BE = Y, He.readI40BE = he, He.readI32BE = le, He.readI24BE = ge, He.readI16BE = Ee, He.readFloat = t, He.readFloatBE = d, He.readDouble = B, He.readDoubleBE = U, He.writeU = J, He.writeU64 = C, He.writeU56 = M, He.writeU48 = $, He.writeU40 = r, He.writeU32 = x, He.writeU24 = O, He.writeU16 = K, He.writeU8 = X, He.writeUBE = P, He.writeU64BE = V, He.writeU56BE = re, He.writeU48BE = ce, He.writeU40BE = de, He.writeU32BE = pe, He.writeU24BE = se, He.writeU16BE = Z, He.writeI = ee, He.writeI64 = me, He.writeI56 = Ae, He.writeI48 = Oe, He.writeI40 = ye, He.writeI32 = _e, He.writeI24 = ke, He.writeI16 = Me, He.writeI8 = De, He.writeIBE = Ne, He.writeI64BE = $e, He.writeI56BE = bt, He.writeI48BE = Ve, He.writeI40BE = je, He.writeI32BE = _t, He.writeI24BE = Je, He.writeI16BE = Ye, He.writeFloat = Qe, He.writeFloatBE = rt, He.writeDouble = ur, He.writeDoubleBE = nt, He.readVarint = ft, He.writeVarint = gr, He.sizeVarint = et, He.readVarint2 = ct, He.writeVarint2 = hr, He.sizeVarint2 = ut, He.sliceBytes = lt, He.readBytes = lr, He.writeBytes = tt, He.readString = it, He.writeString = _r, He.realloc = st, He.copy = gt, He.concat = Dr, He.sizeVarBytes = ot, He.sizeVarlen = pt, He.sizeVarString = nr, He;
}
var Ho, P1;
function $s() {
  if (P1) return Ho;
  P1 = 1;
  const e = mn(), c = Vs(), l = Jn(), w = k.alloc(0);
  class m {
    /**
     * Create a buffer reader.
     * @constructor
     * @param {Buffer} data
     * @param {Boolean?} zeroCopy - Do not reallocate buffers when
     * slicing. Note that this can lead to memory leaks if not used
     * carefully.
     */
    constructor(n, u = !1) {
      e(k.isBuffer(n), "data", "buffer"), e(typeof u == "boolean", "zeroCopy", "boolean"), this.data = n, this.offset = 0, this.zeroCopy = u, this.stack = [];
    }
    /**
     * Assertion.
     * @param {Number} size
     */
    check(n) {
      if (this.offset + n > this.data.length)
        throw new l(this.offset, "Out of bounds read", this.check);
    }
    /**
     * Get total size of passed-in Buffer.
     * @returns {Buffer}
     */
    getSize() {
      return this.data.length;
    }
    /**
     * Calculate number of bytes left to read.
     * @returns {Number}
     */
    left() {
      return this.check(0), this.data.length - this.offset;
    }
    /**
     * Seek to a position to read from by offset.
     * @param {Number} off - Offset (positive or negative).
     */
    seek(n) {
      if (e(Number.isSafeInteger(n), "off", "integer"), this.offset + n < 0)
        throw new l(this.offset, "Out of bounds read");
      return this.check(n), this.offset += n, this;
    }
    /**
     * Mark the current starting position.
     */
    start() {
      return this.stack.push(this.offset), this.offset;
    }
    /**
     * Stop reading. Pop the start position off the stack
     * and calculate the size of the data read.
     * @returns {Number} Size.
     * @throws on empty stack.
     */
    end() {
      if (this.stack.length === 0)
        throw new Error("Cannot end without a stack item.");
      const n = this.stack.pop();
      return this.offset - n;
    }
    /**
     * Stop reading. Pop the start position off the stack
     * and return the data read.
     * @param {Bolean?} zeroCopy - Do a fast buffer
     * slice instead of allocating a new buffer (warning:
     * may cause memory leaks if not used with care).
     * @returns {Buffer} Data read.
     * @throws on empty stack.
     */
    endData(n = !1) {
      if (e(typeof n == "boolean", "zeroCopy", "boolean"), this.stack.length === 0)
        throw new Error("Cannot end without a stack item.");
      const u = this.stack.pop(), o = this.offset, s = o - u, i = this.data;
      if (s === i.length)
        return i;
      if (this.zeroCopy || n)
        return i.slice(u, o);
      const p = k.allocUnsafeSlow(s);
      return i.copy(p, 0, u, o), p;
    }
    /**
     * Destroy the reader. Remove references to the data.
     */
    destroy() {
      return this.data = w, this.offset = 0, this.stack.length = 0, this;
    }
    /**
     * Read uint8.
     * @returns {Number}
     */
    readU8() {
      this.check(1);
      const n = this.data[this.offset];
      return this.offset += 1, n;
    }
    /**
     * Read uint16le.
     * @returns {Number}
     */
    readU16() {
      this.check(2);
      const n = c.readU16(this.data, this.offset);
      return this.offset += 2, n;
    }
    /**
     * Read uint16be.
     * @returns {Number}
     */
    readU16BE() {
      this.check(2);
      const n = c.readU16BE(this.data, this.offset);
      return this.offset += 2, n;
    }
    /**
     * Read uint24le.
     * @returns {Number}
     */
    readU24() {
      this.check(3);
      const n = c.readU24(this.data, this.offset);
      return this.offset += 3, n;
    }
    /**
     * Read uint24be.
     * @returns {Number}
     */
    readU24BE() {
      this.check(3);
      const n = c.readU24BE(this.data, this.offset);
      return this.offset += 3, n;
    }
    /**
     * Read uint32le.
     * @returns {Number}
     */
    readU32() {
      this.check(4);
      const n = c.readU32(this.data, this.offset);
      return this.offset += 4, n;
    }
    /**
     * Read uint32be.
     * @returns {Number}
     */
    readU32BE() {
      this.check(4);
      const n = c.readU32BE(this.data, this.offset);
      return this.offset += 4, n;
    }
    /**
     * Read uint40le.
     * @returns {Number}
     */
    readU40() {
      this.check(5);
      const n = c.readU40(this.data, this.offset);
      return this.offset += 5, n;
    }
    /**
     * Read uint40be.
     * @returns {Number}
     */
    readU40BE() {
      this.check(5);
      const n = c.readU40BE(this.data, this.offset);
      return this.offset += 5, n;
    }
    /**
     * Read uint48le.
     * @returns {Number}
     */
    readU48() {
      this.check(6);
      const n = c.readU48(this.data, this.offset);
      return this.offset += 6, n;
    }
    /**
     * Read uint48be.
     * @returns {Number}
     */
    readU48BE() {
      this.check(6);
      const n = c.readU48BE(this.data, this.offset);
      return this.offset += 6, n;
    }
    /**
     * Read uint56le.
     * @returns {Number}
     */
    readU56() {
      this.check(7);
      const n = c.readU56(this.data, this.offset);
      return this.offset += 7, n;
    }
    /**
     * Read uint56be.
     * @returns {Number}
     */
    readU56BE() {
      this.check(7);
      const n = c.readU56BE(this.data, this.offset);
      return this.offset += 7, n;
    }
    /**
     * Read uint64le as a js number.
     * @returns {Number}
     * @throws on num > MAX_SAFE_INTEGER
     */
    readU64() {
      this.check(8);
      const n = c.readU64(this.data, this.offset);
      return this.offset += 8, n;
    }
    /**
     * Read uint64be as a js number.
     * @returns {Number}
     * @throws on num > MAX_SAFE_INTEGER
     */
    readU64BE() {
      this.check(8);
      const n = c.readU64BE(this.data, this.offset);
      return this.offset += 8, n;
    }
    /**
     * Read int8.
     * @returns {Number}
     */
    readI8() {
      this.check(1);
      const n = c.readI8(this.data, this.offset);
      return this.offset += 1, n;
    }
    /**
     * Read int16le.
     * @returns {Number}
     */
    readI16() {
      this.check(2);
      const n = c.readI16(this.data, this.offset);
      return this.offset += 2, n;
    }
    /**
     * Read int16be.
     * @returns {Number}
     */
    readI16BE() {
      this.check(2);
      const n = c.readI16BE(this.data, this.offset);
      return this.offset += 2, n;
    }
    /**
     * Read int24le.
     * @returns {Number}
     */
    readI24() {
      this.check(3);
      const n = c.readI24(this.data, this.offset);
      return this.offset += 3, n;
    }
    /**
     * Read int24be.
     * @returns {Number}
     */
    readI24BE() {
      this.check(3);
      const n = c.readI24BE(this.data, this.offset);
      return this.offset += 3, n;
    }
    /**
     * Read int32le.
     * @returns {Number}
     */
    readI32() {
      this.check(4);
      const n = c.readI32(this.data, this.offset);
      return this.offset += 4, n;
    }
    /**
     * Read int32be.
     * @returns {Number}
     */
    readI32BE() {
      this.check(4);
      const n = c.readI32BE(this.data, this.offset);
      return this.offset += 4, n;
    }
    /**
     * Read int40le.
     * @returns {Number}
     */
    readI40() {
      this.check(5);
      const n = c.readI40(this.data, this.offset);
      return this.offset += 5, n;
    }
    /**
     * Read int40be.
     * @returns {Number}
     */
    readI40BE() {
      this.check(5);
      const n = c.readI40BE(this.data, this.offset);
      return this.offset += 5, n;
    }
    /**
     * Read int48le.
     * @returns {Number}
     */
    readI48() {
      this.check(6);
      const n = c.readI48(this.data, this.offset);
      return this.offset += 6, n;
    }
    /**
     * Read int48be.
     * @returns {Number}
     */
    readI48BE() {
      this.check(6);
      const n = c.readI48BE(this.data, this.offset);
      return this.offset += 6, n;
    }
    /**
     * Read int56le.
     * @returns {Number}
     */
    readI56() {
      this.check(7);
      const n = c.readI56(this.data, this.offset);
      return this.offset += 7, n;
    }
    /**
     * Read int56be.
     * @returns {Number}
     */
    readI56BE() {
      this.check(7);
      const n = c.readI56BE(this.data, this.offset);
      return this.offset += 7, n;
    }
    /**
     * Read int64le as a js number.
     * @returns {Number}
     * @throws on num > MAX_SAFE_INTEGER
     */
    readI64() {
      this.check(8);
      const n = c.readI64(this.data, this.offset);
      return this.offset += 8, n;
    }
    /**
     * Read int64be as a js number.
     * @returns {Number}
     * @throws on num > MAX_SAFE_INTEGER
     */
    readI64BE() {
      this.check(8);
      const n = c.readI64BE(this.data, this.offset);
      return this.offset += 8, n;
    }
    /**
     * Read float le.
     * @returns {Number}
     */
    readFloat() {
      this.check(4);
      const n = c.readFloat(this.data, this.offset);
      return this.offset += 4, n;
    }
    /**
     * Read float be.
     * @returns {Number}
     */
    readFloatBE() {
      this.check(4);
      const n = c.readFloatBE(this.data, this.offset);
      return this.offset += 4, n;
    }
    /**
     * Read double float le.
     * @returns {Number}
     */
    readDouble() {
      this.check(8);
      const n = c.readDouble(this.data, this.offset);
      return this.offset += 8, n;
    }
    /**
     * Read double float be.
     * @returns {Number}
     */
    readDoubleBE() {
      this.check(8);
      const n = c.readDoubleBE(this.data, this.offset);
      return this.offset += 8, n;
    }
    /**
     * Read a varint.
     * @returns {Number}
     */
    readVarint() {
      const { size: n, value: u } = c.readVarint(this.data, this.offset);
      return this.offset += n, u;
    }
    /**
     * Read a varint (type 2).
     * @returns {Number}
     */
    readVarint2() {
      const { size: n, value: u } = c.readVarint2(this.data, this.offset);
      return this.offset += n, u;
    }
    /**
     * Read N bytes (will do a fast slice if zero copy).
     * @param {Number} size
     * @param {Bolean?} zeroCopy - Do a fast buffer
     * slice instead of allocating a new buffer (warning:
     * may cause memory leaks if not used with care).
     * @returns {Buffer}
     */
    readBytes(n, u = !1) {
      e(n >>> 0 === n, "size", "integer"), e(typeof u == "boolean", "zeroCopy", "boolean"), this.check(n);
      let o;
      return this.zeroCopy || u ? o = this.data.slice(this.offset, this.offset + n) : (o = k.allocUnsafeSlow(n), this.data.copy(o, 0, this.offset, this.offset + n)), this.offset += n, o;
    }
    /**
     * Read a varint number of bytes (will do a fast slice if zero copy).
     * @param {Bolean?} zeroCopy - Do a fast buffer
     * slice instead of allocating a new buffer (warning:
     * may cause memory leaks if not used with care).
     * @returns {Buffer}
     */
    readVarBytes(n = !1) {
      return this.readBytes(this.readVarint(), n);
    }
    /**
     * Slice N bytes and create a child reader.
     * @param {Number} size
     * @returns {BufferReader}
     */
    readChild(n) {
      e(n >>> 0 === n, "size", "integer"), this.check(n);
      const u = this.data.slice(0, this.offset + n), o = new this.constructor(u);
      return o.offset = this.offset, this.offset += n, o;
    }
    /**
     * Read a string.
     * @param {Number} size
     * @param {String} enc - Any buffer-supported encoding.
     * @returns {String}
     */
    readString(n, u) {
      u == null && (u = "binary"), e(n >>> 0 === n, "size", "integer"), e(typeof u == "string", "enc", "string"), this.check(n);
      const o = this.data.toString(u, this.offset, this.offset + n);
      return this.offset += n, o;
    }
    /**
     * Read a 32-byte hash.
     * @param {String} enc - `"hex"` or `null`.
     * @returns {Hash|Buffer}
     */
    readHash(n) {
      return n ? this.readString(32, n) : this.readBytes(32);
    }
    /**
     * Read string of a varint length.
     * @param {String} enc - Any buffer-supported encoding.
     * @param {Number?} limit - Size limit.
     * @returns {String}
     */
    readVarString(n, u = 0) {
      n == null && (n = "binary"), e(typeof n == "string", "enc", "string"), e(u >>> 0 === u, "limit", "integer");
      const o = this.readVarint();
      if (u !== 0 && o > u)
        throw new l(this.offset, "String exceeds limit");
      return this.readString(o, n);
    }
    /**
     * Read a null-terminated string.
     * @param {String} enc - Any buffer-supported encoding.
     * @returns {String}
     */
    readNullString(n) {
      n == null && (n = "binary"), e(typeof n == "string", "enc", "string");
      let u = this.offset;
      for (; u < this.data.length && this.data[u] !== 0; u++)
        ;
      if (u === this.data.length)
        throw new l(this.offset, "No NUL terminator");
      const o = this.readString(u - this.offset, n);
      return this.offset = u + 1, o;
    }
    /**
     * Create a checksum from the last start position.
     * @param {Function} hash
     * @returns {Number} Checksum.
     */
    createChecksum(n) {
      (!n || typeof n.digest != "function") && e(typeof n == "function", "hash", "function");
      let u = 0;
      this.stack.length > 0 && (u = this.stack[this.stack.length - 1]);
      const o = this.data.slice(u, this.offset), s = n.digest ? n.digest(o) : n(o);
      return c.readU32(s, 0);
    }
    /**
     * Verify a 4-byte checksum against a calculated checksum.
     * @param {Function} hash
     * @returns {Number} checksum
     * @throws on bad checksum
     */
    verifyChecksum(n) {
      const u = this.createChecksum(n), o = this.readU32();
      if (u !== o)
        throw new l(this.offset, "Checksum mismatch");
      return u;
    }
  }
  return Ho = m, Ho;
}
var Lo, k1;
function js() {
  if (k1) return Lo;
  k1 = 1;
  const e = mn(), c = Vs(), l = Jn(), w = 0, m = 1, f = 2, n = 3, u = 4, o = 5, s = 6, i = 7, p = 8, g = 9, S = 10, y = 11, b = 12, h = 13, a = 14, E = 15, H = 16, j = 17, G = 18, N = 19, T = 20, A = 21, q = 22, _ = 23, F = 24, R = 25, L = 26, fe = 27, ue = 28, ae = 29, D = 30, Q = 31, W = 32, oe = 33, v = 34, Y = 35, he = 36, le = 37, ge = 38, Ee = 39, we = 40;
  class z {
    /**
     * Create a buffer writer.
     * @constructor
     */
    constructor() {
      this.ops = [], this.offset = 0;
    }
    /**
     * Allocate and render the final buffer.
     * @returns {Buffer} Rendered buffer.
     */
    render() {
      const C = k.allocUnsafeSlow(this.offset);
      let M = 0;
      for (const $ of this.ops)
        switch ($.type) {
          case w:
            M += $.value;
            break;
          case m:
            M = c.writeU8(C, $.value, M);
            break;
          case f:
            M = c.writeU16(C, $.value, M);
            break;
          case n:
            M = c.writeU16BE(C, $.value, M);
            break;
          case u:
            M = c.writeU24(C, $.value, M);
            break;
          case o:
            M = c.writeU24BE(C, $.value, M);
            break;
          case s:
            M = c.writeU32(C, $.value, M);
            break;
          case i:
            M = c.writeU32BE(C, $.value, M);
            break;
          case p:
            M = c.writeU40(C, $.value, M);
            break;
          case g:
            M = c.writeU40BE(C, $.value, M);
            break;
          case S:
            M = c.writeU48(C, $.value, M);
            break;
          case y:
            M = c.writeU48BE(C, $.value, M);
            break;
          case b:
            M = c.writeU56(C, $.value, M);
            break;
          case h:
            M = c.writeU56BE(C, $.value, M);
            break;
          case a:
            M = c.writeU64(C, $.value, M);
            break;
          case E:
            M = c.writeU64BE(C, $.value, M);
            break;
          case H:
            M = c.writeI8(C, $.value, M);
            break;
          case j:
            M = c.writeI16(C, $.value, M);
            break;
          case G:
            M = c.writeI16BE(C, $.value, M);
            break;
          case N:
            M = c.writeI24(C, $.value, M);
            break;
          case T:
            M = c.writeI24BE(C, $.value, M);
            break;
          case A:
            M = c.writeI32(C, $.value, M);
            break;
          case q:
            M = c.writeI32BE(C, $.value, M);
            break;
          case _:
            M = c.writeI40(C, $.value, M);
            break;
          case F:
            M = c.writeI40BE(C, $.value, M);
            break;
          case R:
            M = c.writeI48(C, $.value, M);
            break;
          case L:
            M = c.writeI48BE(C, $.value, M);
            break;
          case fe:
            M = c.writeI56(C, $.value, M);
            break;
          case ue:
            M = c.writeI56BE(C, $.value, M);
            break;
          case ae:
            M = c.writeI64(C, $.value, M);
            break;
          case D:
            M = c.writeI64BE(C, $.value, M);
            break;
          case Q:
            M = c.writeFloat(C, $.value, M);
            break;
          case W:
            M = c.writeFloatBE(C, $.value, M);
            break;
          case oe:
            M = c.writeDouble(C, $.value, M);
            break;
          case v:
            M = c.writeDoubleBE(C, $.value, M);
            break;
          case Y:
            M = c.writeVarint(C, $.value, M);
            break;
          case he:
            M = c.writeVarint2(C, $.value, M);
            break;
          case le:
            M += $.data.copy(C, M);
            break;
          case ge:
            M += C.write($.value, M, $.enc);
            break;
          case Ee:
            M += $.func(C.slice(0, M)).copy(C, M, 0, 4);
            break;
          case we:
            C.fill($.value, M, M + $.size), M += $.size;
            break;
          default:
            throw new Error("Invalid type.");
        }
      if (M !== C.length)
        throw new l(M, "Out of bounds write");
      return this.destroy(), C;
    }
    /**
     * Get size of data written so far.
     * @returns {Number}
     */
    getSize() {
      return this.offset;
    }
    /**
     * Seek to relative offset.
     * @param {Number} offset
     */
    seek(C) {
      if (e(Number.isSafeInteger(C), "off", "integer"), this.offset + C < 0)
        throw new l(this.offset, "Out of bounds write");
      return this.offset += C, this.ops.push(new ne(w, C)), this;
    }
    /**
     * Destroy the buffer writer. Remove references to `ops`.
     */
    destroy() {
      return this.ops.length = 0, this.offset = 0, this;
    }
    /**
     * Write uint8.
     * @param {Number} value
     */
    writeU8(C) {
      return this.offset += 1, this.ops.push(new ne(m, C)), this;
    }
    /**
     * Write uint16le.
     * @param {Number} value
     */
    writeU16(C) {
      return this.offset += 2, this.ops.push(new ne(f, C)), this;
    }
    /**
     * Write uint16be.
     * @param {Number} value
     */
    writeU16BE(C) {
      return this.offset += 2, this.ops.push(new ne(n, C)), this;
    }
    /**
     * Write uint24le.
     * @param {Number} value
     */
    writeU24(C) {
      return this.offset += 3, this.ops.push(new ne(u, C)), this;
    }
    /**
     * Write uint24be.
     * @param {Number} value
     */
    writeU24BE(C) {
      return this.offset += 3, this.ops.push(new ne(o, C)), this;
    }
    /**
     * Write uint32le.
     * @param {Number} value
     */
    writeU32(C) {
      return this.offset += 4, this.ops.push(new ne(s, C)), this;
    }
    /**
     * Write uint32be.
     * @param {Number} value
     */
    writeU32BE(C) {
      return this.offset += 4, this.ops.push(new ne(i, C)), this;
    }
    /**
     * Write uint40le.
     * @param {Number} value
     */
    writeU40(C) {
      return this.offset += 5, this.ops.push(new ne(p, C)), this;
    }
    /**
     * Write uint40be.
     * @param {Number} value
     */
    writeU40BE(C) {
      return this.offset += 5, this.ops.push(new ne(g, C)), this;
    }
    /**
     * Write uint48le.
     * @param {Number} value
     */
    writeU48(C) {
      return this.offset += 6, this.ops.push(new ne(S, C)), this;
    }
    /**
     * Write uint48be.
     * @param {Number} value
     */
    writeU48BE(C) {
      return this.offset += 6, this.ops.push(new ne(y, C)), this;
    }
    /**
     * Write uint56le.
     * @param {Number} value
     */
    writeU56(C) {
      return this.offset += 7, this.ops.push(new ne(b, C)), this;
    }
    /**
     * Write uint56be.
     * @param {Number} value
     */
    writeU56BE(C) {
      return this.offset += 7, this.ops.push(new ne(h, C)), this;
    }
    /**
     * Write uint64le.
     * @param {Number} value
     */
    writeU64(C) {
      return this.offset += 8, this.ops.push(new ne(a, C)), this;
    }
    /**
     * Write uint64be.
     * @param {Number} value
     */
    writeU64BE(C) {
      return this.offset += 8, this.ops.push(new ne(E, C)), this;
    }
    /**
     * Write int8.
     * @param {Number} value
     */
    writeI8(C) {
      return this.offset += 1, this.ops.push(new ne(H, C)), this;
    }
    /**
     * Write int16le.
     * @param {Number} value
     */
    writeI16(C) {
      return this.offset += 2, this.ops.push(new ne(j, C)), this;
    }
    /**
     * Write int16be.
     * @param {Number} value
     */
    writeI16BE(C) {
      return this.offset += 2, this.ops.push(new ne(G, C)), this;
    }
    /**
     * Write int24le.
     * @param {Number} value
     */
    writeI24(C) {
      return this.offset += 3, this.ops.push(new ne(N, C)), this;
    }
    /**
     * Write int24be.
     * @param {Number} value
     */
    writeI24BE(C) {
      return this.offset += 3, this.ops.push(new ne(T, C)), this;
    }
    /**
     * Write int32le.
     * @param {Number} value
     */
    writeI32(C) {
      return this.offset += 4, this.ops.push(new ne(A, C)), this;
    }
    /**
     * Write int32be.
     * @param {Number} value
     */
    writeI32BE(C) {
      return this.offset += 4, this.ops.push(new ne(q, C)), this;
    }
    /**
     * Write int40le.
     * @param {Number} value
     */
    writeI40(C) {
      return this.offset += 5, this.ops.push(new ne(_, C)), this;
    }
    /**
     * Write int40be.
     * @param {Number} value
     */
    writeI40BE(C) {
      return this.offset += 5, this.ops.push(new ne(F, C)), this;
    }
    /**
     * Write int48le.
     * @param {Number} value
     */
    writeI48(C) {
      return this.offset += 6, this.ops.push(new ne(R, C)), this;
    }
    /**
     * Write int48be.
     * @param {Number} value
     */
    writeI48BE(C) {
      return this.offset += 6, this.ops.push(new ne(L, C)), this;
    }
    /**
     * Write int56le.
     * @param {Number} value
     */
    writeI56(C) {
      return this.offset += 7, this.ops.push(new ne(fe, C)), this;
    }
    /**
     * Write int56be.
     * @param {Number} value
     */
    writeI56BE(C) {
      return this.offset += 7, this.ops.push(new ne(ue, C)), this;
    }
    /**
     * Write int64le.
     * @param {Number} value
     */
    writeI64(C) {
      return this.offset += 8, this.ops.push(new ne(ae, C)), this;
    }
    /**
     * Write int64be.
     * @param {Number} value
     */
    writeI64BE(C) {
      return this.offset += 8, this.ops.push(new ne(D, C)), this;
    }
    /**
     * Write float le.
     * @param {Number} value
     */
    writeFloat(C) {
      return this.offset += 4, this.ops.push(new ne(Q, C)), this;
    }
    /**
     * Write float be.
     * @param {Number} value
     */
    writeFloatBE(C) {
      return this.offset += 4, this.ops.push(new ne(W, C)), this;
    }
    /**
     * Write double le.
     * @param {Number} value
     */
    writeDouble(C) {
      return this.offset += 8, this.ops.push(new ne(oe, C)), this;
    }
    /**
     * Write double be.
     * @param {Number} value
     */
    writeDoubleBE(C) {
      return this.offset += 8, this.ops.push(new ne(v, C)), this;
    }
    /**
     * Write a varint.
     * @param {Number} value
     */
    writeVarint(C) {
      return this.offset += c.sizeVarint(C), this.ops.push(new ne(Y, C)), this;
    }
    /**
     * Write a varint (type 2).
     * @param {Number} value
     */
    writeVarint2(C) {
      return this.offset += c.sizeVarint2(C), this.ops.push(new ne(he, C)), this;
    }
    /**
     * Write bytes.
     * @param {Buffer} value
     */
    writeBytes(C) {
      return e(k.isBuffer(C), "value", "buffer"), C.length === 0 ? this : (this.offset += C.length, this.ops.push(new t(le, C)), this);
    }
    /**
     * Write bytes with a varint length before them.
     * @param {Buffer} value
     */
    writeVarBytes(C) {
      return e(k.isBuffer(C), "value", "buffer"), this.offset += c.sizeVarint(C.length), this.ops.push(new ne(Y, C.length)), C.length === 0 ? this : (this.offset += C.length, this.ops.push(new t(le, C)), this);
    }
    /**
     * Copy bytes.
     * @param {Buffer} value
     * @param {Number} start
     * @param {Number} end
     */
    copy(C, M, $) {
      e(k.isBuffer(C), "value", "buffer"), e(M >>> 0 === M, "start", "integer"), e($ >>> 0 === $, "end", "integer"), e($ >= M, "start", "integer");
      const r = C.slice(M, $);
      return this.writeBytes(r), this;
    }
    /**
     * Write string to buffer.
     * @param {String} value
     * @param {String?} enc - Any buffer-supported encoding.
     */
    writeString(C, M) {
      return M == null && (M = "binary"), e(typeof C == "string", "value", "string"), e(typeof M == "string", "enc", "string"), C.length === 0 ? this : (this.offset += k.byteLength(C, M), this.ops.push(new d(ge, C, M)), this);
    }
    /**
     * Write a 32 byte hash.
     * @param {Hash} value
     */
    writeHash(C) {
      return typeof C != "string" ? (e(k.isBuffer(C), "value", "buffer"), e(C.length === 32, "value", "32-byte hash"), this.writeBytes(C), this) : (e(C.length === 64, "value", "32-byte hash"), this.writeString(C, "hex"), this);
    }
    /**
     * Write a string with a varint length before it.
     * @param {String}
     * @param {String?} enc - Any buffer-supported encoding.
     */
    writeVarString(C, M) {
      if (M == null && (M = "binary"), e(typeof C == "string", "value", "string"), e(typeof M == "string", "enc", "string"), C.length === 0)
        return this.ops.push(new ne(Y, 0)), this;
      const $ = k.byteLength(C, M);
      return this.offset += c.sizeVarint($), this.offset += $, this.ops.push(new ne(Y, $)), this.ops.push(new d(ge, C, M)), this;
    }
    /**
     * Write a null-terminated string.
     * @param {String|Buffer}
     * @param {String?} enc - Any buffer-supported encoding.
     */
    writeNullString(C, M) {
      return this.writeString(C, M), this.writeU8(0), this;
    }
    /**
     * Calculate and write a checksum for the data written so far.
     * @param {Function} hash
     */
    writeChecksum(C) {
      return C && typeof C.digest == "function" && (C = C.digest.bind(C)), e(typeof C == "function", "hash", "function"), this.offset += 4, this.ops.push(new B(Ee, C)), this;
    }
    /**
     * Fill N bytes with value.
     * @param {Number} value
     * @param {Number} size
     */
    fill(C, M) {
      return e((C & 255) === C, "value", "byte"), e(M >>> 0 === M, "size", "integer"), M === 0 ? this : (this.offset += M, this.ops.push(new U(we, C, M)), this);
    }
  }
  class I {
    constructor(C) {
      this.type = C;
    }
  }
  class ne extends I {
    constructor(C, M) {
      super(C), this.value = M;
    }
  }
  class t extends I {
    constructor(C, M) {
      super(C), this.data = M;
    }
  }
  class d extends I {
    constructor(C, M, $) {
      super(C), this.value = M, this.enc = $;
    }
  }
  class B extends I {
    constructor(C, M) {
      super(C), this.func = M;
    }
  }
  class U extends I {
    constructor(C, M, $) {
      super(C), this.value = M, this.size = $;
    }
  }
  return Lo = z, Lo;
}
var Ko, B1;
function k8() {
  if (B1) return Ko;
  B1 = 1;
  const e = mn(), c = Vs(), l = Jn(), w = k.alloc(0), m = 102400;
  let f = null;
  class n {
    /**
     * Statically allocated buffer writer.
     * @constructor
     * @param {Number|Buffer} options
     */
    constructor(o) {
      this.data = w, this.offset = 0, o != null && this.init(o);
    }
    /**
     * Assertion.
     * @param {Number} size
     */
    check(o) {
      if (this.offset + o > this.data.length)
        throw new l(this.offset, "Out of bounds write", this.check);
    }
    /**
     * Initialize options.
     * @param {Object} options
     */
    init(o) {
      return k.isBuffer(o) ? (this.data = o, this.offset = 0, this) : (e(o >>> 0 === o, "size", "integer"), this.data = k.allocUnsafeSlow(o), this.offset = 0, this);
    }
    /**
     * Allocate writer from preallocated 100kb pool.
     * @param {Number} size
     * @returns {StaticWriter}
     */
    static pool(o) {
      if (e(o >>> 0 === o, "size", "integer"), o <= m) {
        f || (f = k.allocUnsafeSlow(m));
        const s = new n();
        return s.data = f.slice(0, o), s;
      }
      return new n(o);
    }
    /**
     * Allocate and render the final buffer.
     * @returns {Buffer} Rendered buffer.
     */
    render() {
      const { data: o, offset: s } = this;
      if (s !== o.length)
        throw new l(s, "Out of bounds write");
      return this.destroy(), o;
    }
    /**
     * Slice the final buffer at written offset.
     * @returns {Buffer} Rendered buffer.
     */
    slice() {
      const { data: o, offset: s } = this;
      if (s > o.length)
        throw new l(s, "Out of bounds write");
      return this.destroy(), o.slice(0, s);
    }
    /**
     * Get size of data written so far.
     * @returns {Number}
     */
    getSize() {
      return this.offset;
    }
    /**
     * Seek to relative offset.
     * @param {Number} off
     */
    seek(o) {
      if (e(Number.isSafeInteger(o), "off", "integer"), this.offset + o < 0)
        throw new l(this.offset, "Out of bounds write");
      return this.check(o), this.offset += o, this;
    }
    /**
     * Destroy the buffer writer.
     */
    destroy() {
      return this.data = w, this.offset = 0, this;
    }
    /**
     * Write uint8.
     * @param {Number} value
     */
    writeU8(o) {
      return this.check(1), this.offset = c.writeU8(this.data, o, this.offset), this;
    }
    /**
     * Write uint16le.
     * @param {Number} value
     */
    writeU16(o) {
      return this.check(2), this.offset = c.writeU16(this.data, o, this.offset), this;
    }
    /**
     * Write uint16be.
     * @param {Number} value
     */
    writeU16BE(o) {
      return this.check(2), this.offset = c.writeU16BE(this.data, o, this.offset), this;
    }
    /**
     * Write uint24le.
     * @param {Number} value
     */
    writeU24(o) {
      return this.check(3), this.offset = c.writeU24(this.data, o, this.offset), this;
    }
    /**
     * Write uint24be.
     * @param {Number} value
     */
    writeU24BE(o) {
      return this.check(3), this.offset = c.writeU24BE(this.data, o, this.offset), this;
    }
    /**
     * Write uint32le.
     * @param {Number} value
     */
    writeU32(o) {
      return this.check(4), this.offset = c.writeU32(this.data, o, this.offset), this;
    }
    /**
     * Write uint32be.
     * @param {Number} value
     */
    writeU32BE(o) {
      return this.check(4), this.offset = c.writeU32BE(this.data, o, this.offset), this;
    }
    /**
     * Write uint40le.
     * @param {Number} value
     */
    writeU40(o) {
      return this.check(5), this.offset = c.writeU40(this.data, o, this.offset), this;
    }
    /**
     * Write uint40be.
     * @param {Number} value
     */
    writeU40BE(o) {
      return this.check(5), this.offset = c.writeU40BE(this.data, o, this.offset), this;
    }
    /**
     * Write uint48le.
     * @param {Number} value
     */
    writeU48(o) {
      return this.check(6), this.offset = c.writeU48(this.data, o, this.offset), this;
    }
    /**
     * Write uint48be.
     * @param {Number} value
     */
    writeU48BE(o) {
      return this.check(6), this.offset = c.writeU48BE(this.data, o, this.offset), this;
    }
    /**
     * Write uint56le.
     * @param {Number} value
     */
    writeU56(o) {
      return this.check(7), this.offset = c.writeU56(this.data, o, this.offset), this;
    }
    /**
     * Write uint56be.
     * @param {Number} value
     */
    writeU56BE(o) {
      return this.check(7), this.offset = c.writeU56BE(this.data, o, this.offset), this;
    }
    /**
     * Write uint64le.
     * @param {Number} value
     */
    writeU64(o) {
      return this.check(8), this.offset = c.writeU64(this.data, o, this.offset), this;
    }
    /**
     * Write uint64be.
     * @param {Number} value
     */
    writeU64BE(o) {
      return this.check(8), this.offset = c.writeU64BE(this.data, o, this.offset), this;
    }
    /**
     * Write int8.
     * @param {Number} value
     */
    writeI8(o) {
      return this.check(1), this.offset = c.writeI8(this.data, o, this.offset), this;
    }
    /**
     * Write int16le.
     * @param {Number} value
     */
    writeI16(o) {
      return this.check(2), this.offset = c.writeI16(this.data, o, this.offset), this;
    }
    /**
     * Write int16be.
     * @param {Number} value
     */
    writeI16BE(o) {
      return this.check(2), this.offset = c.writeI16BE(this.data, o, this.offset), this;
    }
    /**
     * Write int24le.
     * @param {Number} value
     */
    writeI24(o) {
      return this.check(3), this.offset = c.writeI24(this.data, o, this.offset), this;
    }
    /**
     * Write int24be.
     * @param {Number} value
     */
    writeI24BE(o) {
      return this.check(3), this.offset = c.writeI24BE(this.data, o, this.offset), this;
    }
    /**
     * Write int32le.
     * @param {Number} value
     */
    writeI32(o) {
      return this.check(4), this.offset = c.writeI32(this.data, o, this.offset), this;
    }
    /**
     * Write int32be.
     * @param {Number} value
     */
    writeI32BE(o) {
      return this.check(4), this.offset = c.writeI32BE(this.data, o, this.offset), this;
    }
    /**
     * Write int40le.
     * @param {Number} value
     */
    writeI40(o) {
      return this.check(5), this.offset = c.writeI40(this.data, o, this.offset), this;
    }
    /**
     * Write int40be.
     * @param {Number} value
     */
    writeI40BE(o) {
      return this.check(5), this.offset = c.writeI40BE(this.data, o, this.offset), this;
    }
    /**
     * Write int48le.
     * @param {Number} value
     */
    writeI48(o) {
      return this.check(6), this.offset = c.writeI48(this.data, o, this.offset), this;
    }
    /**
     * Write int48be.
     * @param {Number} value
     */
    writeI48BE(o) {
      return this.check(6), this.offset = c.writeI48BE(this.data, o, this.offset), this;
    }
    /**
     * Write int56le.
     * @param {Number} value
     */
    writeI56(o) {
      return this.check(7), this.offset = c.writeI56(this.data, o, this.offset), this;
    }
    /**
     * Write int56be.
     * @param {Number} value
     */
    writeI56BE(o) {
      return this.check(7), this.offset = c.writeI56BE(this.data, o, this.offset), this;
    }
    /**
     * Write int64le.
     * @param {Number} value
     */
    writeI64(o) {
      return this.check(8), this.offset = c.writeI64(this.data, o, this.offset), this;
    }
    /**
     * Write int64be.
     * @param {Number} value
     */
    writeI64BE(o) {
      return this.check(8), this.offset = c.writeI64BE(this.data, o, this.offset), this;
    }
    /**
     * Write float le.
     * @param {Number} value
     */
    writeFloat(o) {
      return this.check(4), this.offset = c.writeFloat(this.data, o, this.offset), this;
    }
    /**
     * Write float be.
     * @param {Number} value
     */
    writeFloatBE(o) {
      return this.check(4), this.offset = c.writeFloatBE(this.data, o, this.offset), this;
    }
    /**
     * Write double le.
     * @param {Number} value
     */
    writeDouble(o) {
      return this.check(8), this.offset = c.writeDouble(this.data, o, this.offset), this;
    }
    /**
     * Write double be.
     * @param {Number} value
     */
    writeDoubleBE(o) {
      return this.check(8), this.offset = c.writeDoubleBE(this.data, o, this.offset), this;
    }
    /**
     * Write a varint.
     * @param {Number} value
     */
    writeVarint(o) {
      return this.offset = c.writeVarint(this.data, o, this.offset), this;
    }
    /**
     * Write a varint (type 2).
     * @param {Number} value
     */
    writeVarint2(o) {
      return this.offset = c.writeVarint2(this.data, o, this.offset), this;
    }
    /**
     * Write bytes.
     * @param {Buffer} value
     */
    writeBytes(o) {
      return e(k.isBuffer(o), "value", "buffer"), this.check(o.length), this.offset += o.copy(this.data, this.offset), this;
    }
    /**
     * Write bytes with a varint length before them.
     * @param {Buffer} value
     */
    writeVarBytes(o) {
      return e(k.isBuffer(o), "value", "buffer"), this.writeVarint(o.length), this.writeBytes(o), this;
    }
    /**
     * Copy bytes.
     * @param {Buffer} value
     * @param {Number} start
     * @param {Number} end
     */
    copy(o, s, i) {
      return e(k.isBuffer(o), "value", "buffer"), e(s >>> 0 === s, "start", "integer"), e(i >>> 0 === i, "end", "integer"), e(i >= s, "start", "integer"), this.check(i - s), this.offset += o.copy(this.data, this.offset, s, i), this;
    }
    /**
     * Write string to buffer.
     * @param {String} value
     * @param {String?} enc - Any buffer-supported encoding.
     */
    writeString(o, s) {
      if (s == null && (s = "binary"), e(typeof o == "string", "value", "string"), e(typeof s == "string", "enc", "string"), o.length === 0)
        return this;
      const i = k.byteLength(o, s);
      return this.check(i), this.offset += this.data.write(o, this.offset, s), this;
    }
    /**
     * Write a 32 byte hash.
     * @param {Hash} value
     */
    writeHash(o) {
      return typeof o != "string" ? (e(k.isBuffer(o), "value", "buffer"), e(o.length === 32, "value", "32-byte hash"), this.writeBytes(o), this) : (e(o.length === 64, "value", "32-byte hash"), this.check(32), this.offset += this.data.write(o, this.offset, "hex"), this);
    }
    /**
     * Write a string with a varint length before it.
     * @param {String}
     * @param {String?} enc - Any buffer-supported encoding.
     */
    writeVarString(o, s) {
      if (s == null && (s = "binary"), e(typeof o == "string", "value", "string"), e(typeof s == "string", "enc", "string"), o.length === 0)
        return this.writeVarint(0), this;
      const i = k.byteLength(o, s);
      return this.writeVarint(i), this.check(i), this.offset += this.data.write(o, this.offset, s), this;
    }
    /**
     * Write a null-terminated string.
     * @param {String|Buffer}
     * @param {String?} enc - Any buffer-supported encoding.
     */
    writeNullString(o, s) {
      return this.writeString(o, s), this.writeU8(0), this;
    }
    /**
     * Calculate and write a checksum for the data written so far.
     * @param {Function} hash
     */
    writeChecksum(o) {
      (!o || typeof o.digest != "function") && e(typeof o == "function", "hash", "function"), this.check(4);
      const s = this.data.slice(0, this.offset);
      return (o.digest ? o.digest(s) : o(s)).copy(this.data, this.offset, 0, 4), this.offset += 4, this;
    }
    /**
     * Fill N bytes with value.
     * @param {Number} value
     * @param {Number} size
     */
    fill(o, s) {
      return e((o & 255) === o, "value", "byte"), e(s >>> 0 === s, "size", "integer"), this.check(s), this.data.fill(o, this.offset, this.offset + s), this.offset += s, this;
    }
  }
  return Ko = n, Ko;
}
var Vo, M1;
function wm() {
  if (M1) return Vo;
  M1 = 1;
  const e = mn(), c = $s(), l = js(), w = k8(), { custom: m } = P8();
  class f {
    constructor() {
    }
    inject(o) {
      return e(o instanceof this.constructor, "obj", "struct"), this.decode(o.encode());
    }
    clone() {
      return new this.constructor().inject(this);
    }
    /*
     * Bindable
     */
    getSize(o) {
      return -1;
    }
    write(o, s) {
      return o;
    }
    read(o, s) {
      return this;
    }
    toString() {
      return Object.prototype.toString.call(this);
    }
    fromString(o, s) {
      return this;
    }
    getJSON() {
      return this;
    }
    fromJSON(o, s) {
      return this;
    }
    fromOptions(o, s) {
      return this;
    }
    from(o, s) {
      return this.fromOptions(o, s);
    }
    format() {
      return this.getJSON();
    }
    /*
     * API
     */
    encode(o) {
      const s = this.getSize(o), i = s === -1 ? new l() : new w(s);
      return this.write(i, o), i.render();
    }
    decode(o, s) {
      const i = new c(o);
      return this.read(i, s), this;
    }
    toHex(o) {
      return this.encode(o).toString("hex");
    }
    fromHex(o, s) {
      e(typeof o == "string", "str", "string");
      const i = o.length >>> 1, p = k.from(o, "hex");
      if (p.length !== i)
        throw new Error("Invalid hex string.");
      return this.decode(p, s);
    }
    toBase64(o) {
      return this.encode(o).toString("base64");
    }
    fromBase64(o, s) {
      e(typeof o == "string", "str", "string");
      const i = k.from(o, "base64");
      if (o.length > n(i.length))
        throw new Error("Invalid base64 string.");
      return this.decode(i, s);
    }
    toJSON() {
      return this.getJSON();
    }
    [m]() {
      return this.format();
    }
    /*
     * Static API
     */
    static read(o, s) {
      return new this().read(o, s);
    }
    static decode(o, s) {
      return new this().decode(o, s);
    }
    static fromHex(o, s) {
      return new this().fromHex(o, s);
    }
    static fromBase64(o, s) {
      return new this().fromBase64(o, s);
    }
    static fromString(o, s) {
      return new this().fromString(o, s);
    }
    static fromJSON(o, s) {
      return new this().fromJSON(o, s);
    }
    static fromOptions(o, s) {
      return new this().fromOptions(o, s);
    }
    static from(o, s) {
      return new this().from(o, s);
    }
    /*
     * Aliases
     */
    toWriter(o, s) {
      return this.write(o, s);
    }
    fromReader(o, s) {
      return this.read(o, s);
    }
    toRaw(o) {
      return this.encode(o);
    }
    fromRaw(o, s) {
      return this.decode(o, s);
    }
    /*
     * Static Aliases
     */
    static fromReader(o, s) {
      return this.read(o, s);
    }
    static fromRaw(o, s) {
      return this.decode(o, s);
    }
  }
  function n(u) {
    return (4 * u / 3 + 3 & -4) >>> 0;
  }
  return Vo = f, Vo;
}
var N1;
function At() {
  if (N1) return ze;
  N1 = 1;
  const e = P8(), c = Vs(), l = mn(), w = Jn(), m = $s(), f = js(), n = k8(), u = wm();
  ze.custom = e, ze.encoding = c, ze.EncodingError = w, ze.BufferReader = m, ze.BufferWriter = f, ze.StaticWriter = n, ze.Struct = u, ze.read = function(b, h) {
    return new m(b, h);
  }, ze.write = function(b) {
    return b != null ? new n(b) : new f();
  }, ze.pool = function(b) {
    return n.pool(b);
  };
  function o(y, b) {
    return function(h, a) {
      if (l(k.isBuffer(h), "data", "buffer"), l(a >>> 0 === a, "off", "integer"), a + b > h.length)
        throw new w(a, "Out of bounds read");
      return y(h, a);
    };
  }
  function s(y) {
    return function(b, h, a) {
      if (l(k.isBuffer(b), "data", "buffer"), l(h >>> 0 === h, "off", "integer"), l(a >>> 0 === a, "len", "integer"), h + a > b.length)
        throw new w(h, "Out of bounds read");
      return y(b, h, a);
    };
  }
  function i(y) {
    return function(b, h) {
      return l(k.isBuffer(b), "data", "buffer"), l(h >>> 0 === h, "off", "integer"), y(b, h);
    };
  }
  function p(y, b) {
    return function(h, a, E) {
      if (l(k.isBuffer(h), "data", "buffer"), l(E >>> 0 === E, "off", "integer"), E + b > h.length)
        throw new w(E, "Out of bounds write");
      return y(h, a, E);
    };
  }
  function g(y) {
    return function(b, h, a, E) {
      if (l(k.isBuffer(b), "data", "buffer"), l(a >>> 0 === a, "off", "integer"), l(E >>> 0 === E, "len", "integer"), a + E > b.length)
        throw new w(a, "Out of bounds write");
      return y(b, h, a, E);
    };
  }
  function S(y, b) {
    return function(h, a, E) {
      if (l(k.isBuffer(h), "data", "buffer"), l(E >>> 0 === E, "off", "integer"), E + b(a) > h.length)
        throw new w(E, "Out of bounds write");
      return y(h, a, E);
    };
  }
  return ze.readU = s(c.readU), ze.readU64 = o(c.readU64, 8), ze.readU56 = o(c.readU56, 7), ze.readU48 = o(c.readU48, 6), ze.readU40 = o(c.readU40, 5), ze.readU32 = o(c.readU32, 4), ze.readU24 = o(c.readU24, 3), ze.readU16 = o(c.readU16, 2), ze.readU8 = o(c.readU8, 1), ze.readUBE = s(c.readUBE), ze.readU64BE = o(c.readU64BE, 8), ze.readU56BE = o(c.readU56BE, 7), ze.readU48BE = o(c.readU48BE, 6), ze.readU40BE = o(c.readU40BE, 5), ze.readU32BE = o(c.readU32BE, 4), ze.readU24BE = o(c.readU24BE, 3), ze.readU16BE = o(c.readU16BE, 2), ze.readI = s(c.readI), ze.readI64 = o(c.readI64, 8), ze.readI56 = o(c.readI56, 7), ze.readI48 = o(c.readI48, 6), ze.readI40 = o(c.readI40, 5), ze.readI32 = o(c.readI32, 4), ze.readI24 = o(c.readI24, 3), ze.readI16 = o(c.readI16, 2), ze.readI8 = o(c.readI8, 1), ze.readIBE = s(c.readIBE), ze.readI64BE = o(c.readI64BE, 8), ze.readI56BE = o(c.readI56BE, 7), ze.readI48BE = o(c.readI48BE, 6), ze.readI40BE = o(c.readI40BE, 5), ze.readI32BE = o(c.readI32BE, 4), ze.readI24BE = o(c.readI24BE, 3), ze.readI16BE = o(c.readI16BE, 2), ze.readFloat = o(c.readFloat, 4), ze.readFloatBE = o(c.readFloatBE, 4), ze.readDouble = o(c.readDouble, 8), ze.readDoubleBE = o(c.readDoubleBE, 8), ze.writeU = g(c.writeU), ze.writeU64 = p(c.writeU64, 8), ze.writeU56 = p(c.writeU56, 7), ze.writeU48 = p(c.writeU48, 6), ze.writeU40 = p(c.writeU40, 5), ze.writeU32 = p(c.writeU32, 4), ze.writeU24 = p(c.writeU24, 3), ze.writeU16 = p(c.writeU16, 2), ze.writeU8 = p(c.writeU8, 1), ze.writeUBE = g(c.writeUBE), ze.writeU64BE = p(c.writeU64BE, 8), ze.writeU56BE = p(c.writeU56BE, 7), ze.writeU48BE = p(c.writeU48BE, 6), ze.writeU40BE = p(c.writeU40BE, 5), ze.writeU32BE = p(c.writeU32BE, 4), ze.writeU24BE = p(c.writeU24BE, 3), ze.writeU16BE = p(c.writeU16BE, 2), ze.writeI = g(c.writeI), ze.writeI64 = p(c.writeI64, 8), ze.writeI56 = p(c.writeI56, 7), ze.writeI48 = p(c.writeI48, 6), ze.writeI40 = p(c.writeI40, 5), ze.writeI32 = p(c.writeI32, 4), ze.writeI24 = p(c.writeI24, 3), ze.writeI16 = p(c.writeI16, 2), ze.writeI8 = p(c.writeI8, 1), ze.writeIBE = g(c.writeIBE), ze.writeI64BE = p(c.writeI64BE, 8), ze.writeI56BE = p(c.writeI56BE, 7), ze.writeI48BE = p(c.writeI48BE, 6), ze.writeI40BE = p(c.writeI40BE, 5), ze.writeI32BE = p(c.writeI32BE, 4), ze.writeI24BE = p(c.writeI24BE, 3), ze.writeI16BE = p(c.writeI16BE, 2), ze.writeFloat = p(c.writeFloat, 4), ze.writeFloatBE = p(c.writeFloatBE, 4), ze.writeDouble = p(c.writeDouble, 8), ze.writeDoubleBE = p(c.writeDoubleBE, 8), ze.readVarint = i(c.readVarint), ze.writeVarint = S(c.writeVarint, c.sizeVarint), ze.sizeVarint = c.sizeVarint, ze.readVarint2 = i(c.readVarint2), ze.writeVarint2 = S(c.writeVarint2, c.sizeVarint2), ze.sizeVarint2 = c.sizeVarint2, ze.sliceBytes = c.sliceBytes, ze.readBytes = c.readBytes, ze.writeBytes = c.writeBytes, ze.readString = c.readString, ze.writeString = c.writeString, ze.realloc = c.realloc, ze.copy = c.copy, ze.concat = c.concat, ze.sizeVarBytes = c.sizeVarBytes, ze.sizeVarlen = c.sizeVarlen, ze.sizeVarString = c.sizeVarString, ze;
}
var ym = At();
const Bt = /* @__PURE__ */ Nr(ym);
var On = {}, _n = {}, q1;
function vm() {
  if (q1) return _n;
  q1 = 1;
  const e = Xe(), c = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz", l = [
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    16,
    -1,
    17,
    18,
    19,
    20,
    21,
    -1,
    22,
    23,
    24,
    25,
    26,
    27,
    28,
    29,
    30,
    31,
    32,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    33,
    34,
    35,
    36,
    37,
    38,
    39,
    40,
    41,
    42,
    43,
    -1,
    44,
    45,
    46,
    47,
    48,
    49,
    50,
    51,
    52,
    53,
    54,
    55,
    56,
    57,
    -1,
    -1,
    -1,
    -1,
    -1
  ];
  return _n.encode = function(m) {
    e(k.isBuffer(m));
    let f = 0, n = 0;
    for (; n < m.length && m[n] === 0; n++)
      f += 1;
    const u = k.allocUnsafe((m.length * 138 / 100 | 0) + 1);
    u.fill(0);
    let o = 0;
    for (; n < m.length; n++) {
      let i = m[n], p = 0;
      for (let g = u.length - 1; g >= 0 && !(i === 0 && p >= o); g--, p++)
        i += 256 * u[g], u[g] = i % 58, i = i / 58 | 0;
      e(i === 0), o = p;
    }
    for (n = u.length - o; n < u.length && u[n] === 0; )
      n += 1;
    let s = "";
    for (let i = 0; i < f; i++)
      s += "1";
    for (; n < u.length; n++)
      s += c[u[n]];
    return s;
  }, _n.decode = function(m) {
    e(typeof m == "string");
    let f = 0, n = 0;
    for (; n < m.length && m[n] === "1"; n++)
      f += 1;
    const u = k.allocUnsafe((m.length * 733 / 1e3 | 0) + 1);
    u.fill(0);
    let o = 0;
    for (; n < m.length; n++) {
      const p = m.charCodeAt(n), g = p & 65408 ? -1 : l[p];
      if (g === -1)
        throw new Error("Non-base58 character.");
      let S = g, y = 0;
      for (let b = u.length - 1; b >= 0 && !(S === 0 && y >= o); b--, y++)
        S += 58 * u[b], u[b] = S & 255, S >>>= 8;
      e(S === 0), o = y;
    }
    for (n = 0; n < u.length && u[n] === 0; )
      n += 1;
    const s = k.allocUnsafe(f + (u.length - n));
    let i;
    for (i = 0; i < f; i++)
      s[i] = 0;
    for (; n < u.length; )
      s[i++] = u[n++];
    return s;
  }, _n.test = function(m) {
    if (typeof m != "string")
      return !1;
    for (let f = 0; f < m.length; f++) {
      const n = m.charCodeAt(f);
      if (n & 65408 || l[n] === -1)
        return !1;
    }
    return !0;
  }, _n;
}
var Jr = {}, T1;
function Sm() {
  if (T1) return Jr;
  T1 = 1;
  const e = Xe(), c = k.allocUnsafe(66), l = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", w = [
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    15,
    -1,
    10,
    17,
    21,
    20,
    26,
    30,
    7,
    5,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    29,
    -1,
    24,
    13,
    25,
    9,
    8,
    23,
    -1,
    18,
    22,
    31,
    27,
    19,
    -1,
    1,
    0,
    3,
    16,
    11,
    28,
    12,
    14,
    6,
    4,
    2,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    29,
    -1,
    24,
    13,
    25,
    9,
    8,
    23,
    -1,
    18,
    22,
    31,
    27,
    19,
    -1,
    1,
    0,
    3,
    16,
    11,
    28,
    12,
    14,
    6,
    4,
    2,
    -1,
    -1,
    -1,
    -1,
    -1
  ];
  function m(b) {
    const h = b >>> 25;
    return (b & 33554431) << 5 ^ -(h >>> 0 & 1) & 996825010 ^ -(h >>> 1 & 1) & 642813549 ^ -(h >>> 2 & 1) & 513874426 ^ -(h >>> 3 & 1) & 1027748829 ^ -(h >>> 4 & 1) & 705979059;
  }
  function f(b, h) {
    e(typeof b == "string"), e(k.isBuffer(h));
    let a = 1, E;
    for (E = 0; E < b.length; E++) {
      const j = b.charCodeAt(E);
      if (j & 65280 || !(j >>> 5))
        throw new Error("Invalid bech32 character.");
      a = m(a) ^ j >>> 5;
    }
    if (E + 7 + h.length > 90)
      throw new Error("Invalid bech32 data length.");
    a = m(a);
    let H = "";
    for (let j = 0; j < b.length; j++) {
      const G = b.charCodeAt(j);
      a = m(a) ^ G & 31, H += b[j];
    }
    H += "1";
    for (let j = 0; j < h.length; j++) {
      const G = h[j];
      if (G >>> 5)
        throw new Error("Invalid bech32 value.");
      a = m(a) ^ G, H += l[G];
    }
    for (let j = 0; j < 6; j++)
      a = m(a);
    a ^= 1;
    for (let j = 0; j < 6; j++)
      H += l[a >>> (5 - j) * 5 & 31];
    return H;
  }
  function n(b) {
    if (e(typeof b == "string"), b.length < 8 || b.length > 90)
      throw new Error("Invalid bech32 string length.");
    let h = 0;
    for (; h < b.length && b[b.length - 1 - h] !== "1"; )
      h += 1;
    const a = b.length - (1 + h);
    if (1 + h >= b.length || h < 6)
      throw new Error("Invalid bech32 data length.");
    h -= 6;
    const E = k.allocUnsafe(h);
    let H = 1, j = !1, G = !1, N = "";
    for (let A = 0; A < a; A++) {
      let q = b.charCodeAt(A);
      if (q < 33 || q > 126)
        throw new Error("Invalid bech32 character.");
      q >= 97 && q <= 122 ? j = !0 : q >= 65 && q <= 90 && (G = !0, q = q - 65 + 97), N += String.fromCharCode(q), H = m(H) ^ q >>> 5;
    }
    H = m(H);
    let T;
    for (T = 0; T < a; T++)
      H = m(H) ^ b.charCodeAt(T) & 31;
    for (T += 1; T < b.length; ) {
      const A = b.charCodeAt(T), q = A & 65408 ? -1 : w[A];
      if (q === -1)
        throw new Error("Invalid bech32 character.");
      A >= 97 && A <= 122 ? j = !0 : A >= 65 && A <= 90 && (G = !0), H = m(H) ^ q, T + 6 < b.length && (E[T - (1 + a)] = q), T += 1;
    }
    if (j && G)
      throw new Error("Invalid bech32 casing.");
    if (H !== 1)
      throw new Error("Invalid bech32 checksum.");
    return [N, E.slice(0, h)];
  }
  function u(b) {
    if (typeof b != "string")
      return !1;
    try {
      n(b);
    } catch {
      return !1;
    }
    return !0;
  }
  function o(b, h, a, E, H, j, G) {
    e(k.isBuffer(b)), e(h >>> 0 === h), e(k.isBuffer(a)), e(E >>> 0 === E), e((H & 255) === H), e((j & 255) === j), e(typeof G == "boolean");
    const N = (1 << j) - 1;
    let T = 0, A = 0;
    for (; h < b.length; h++) {
      const q = b[h];
      if (q >>> H)
        throw new Error("Invalid bits.");
      for (T = T << H | q, A += H; A >= j; )
        A -= j, a[E++] = T >>> A & N;
    }
    if (G)
      A && (a[E++] = T << j - A & N);
    else if (A >= H || T << j - A & N)
      throw new Error("Invalid bits.");
    return e(E <= a.length), a.slice(0, E);
  }
  function s(b, h, a, E) {
    e(b >>> 0 === b), e((h & 255) === h), e((a & 255) === a), e(typeof E == "boolean"), e(a !== 0);
    let H = (b * h + (a - 1)) / a;
    return H >>>= 0, E && (H += 1), H;
  }
  function i(b, h, a, E) {
    e(k.isBuffer(b)), e((h & 255) === h), e((a & 255) === a), e(typeof E == "boolean");
    const H = s(b.length, h, a, E), j = k.allocUnsafe(H);
    return o(b, 0, j, 0, h, a, E);
  }
  function p(b, h, a) {
    if (e(typeof b == "string"), e((h & 255) === h), e(k.isBuffer(a)), h < 0 || h > 31)
      throw new Error("Invalid bech32 version.");
    if (a.length < 2 || a.length > 40)
      throw new Error("Invalid bech32 data length.");
    const E = c;
    E[0] = h;
    const H = o(a, 0, E, 1, 8, 5, !0);
    return f(b, H);
  }
  function g(b) {
    e(typeof b == "string");
    const [h, a] = n(b);
    if (a.length === 0 || a.length > 65)
      throw new Error("Invalid bech32 data length.");
    const E = a[0];
    if (E > 31)
      throw new Error("Invalid bech32 version.");
    const H = o(a, 1, a, 0, 5, 8, !1);
    if (H.length < 2 || H.length > 40)
      throw new Error("Invalid bech32 data length.");
    return new y(h, E, H);
  }
  function S(b) {
    if (typeof b != "string")
      return !1;
    let h;
    try {
      [, h] = n(b);
    } catch {
      return !1;
    }
    return !(h.length === 0 || h.length > 65 || h[0] > 31);
  }
  class y {
    constructor(h, a, E) {
      this.hrp = h, this.version = a, this.hash = E;
    }
  }
  return Jr.serialize = f, Jr.deserialize = n, Jr.is = u, Jr.convertBits = i, Jr.encode = p, Jr.decode = g, Jr.test = S, Jr;
}
var Rn = {}, z1;
function Em() {
  if (z1) return Rn;
  z1 = 1;
  const e = Xe();
  class c {
    constructor(a, E) {
      this.hi = a | 0, this.lo = E | 0;
    }
    ushrn32(a) {
      a &= 63;
      let E = this.lo;
      return a === 0 || (a < 32 ? (E >>>= a, E |= this.hi << 32 - a) : E = this.hi >>> a - 32), E;
    }
  }
  const l = k.allocUnsafe(105), w = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", m = [
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    15,
    -1,
    10,
    17,
    21,
    20,
    26,
    30,
    7,
    5,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    29,
    -1,
    24,
    13,
    25,
    9,
    8,
    23,
    -1,
    18,
    22,
    31,
    27,
    19,
    -1,
    1,
    0,
    3,
    16,
    11,
    28,
    12,
    14,
    6,
    4,
    2,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    29,
    -1,
    24,
    13,
    25,
    9,
    8,
    23,
    -1,
    18,
    22,
    31,
    27,
    19,
    -1,
    1,
    0,
    3,
    16,
    11,
    28,
    12,
    14,
    6,
    4,
    2,
    -1,
    -1,
    -1,
    -1,
    -1
  ], f = new c(7, 4294967295), n = [
    new c(152, 4072443489),
    new c(121, 3077413346),
    new c(243, 1046459332),
    new c(174, 783016616),
    new c(30, 1329849456)
  ];
  function u(h, a) {
    const E = h, H = E.hi >>> 3;
    E.hi &= f.hi, E.lo &= f.lo, E.hi <<= 5, E.hi |= E.lo >>> 27, E.lo <<= 5;
    for (let j = 0; j < n.length; j++)
      H >>> j & 1 && (E.hi ^= n[j].hi, E.lo ^= n[j].lo);
    return E.lo ^= a, E;
  }
  function o(h, a) {
    e(typeof h == "string"), e(k.isBuffer(a));
    const E = new c(0, 1);
    let H = "", j = !1, G = !1;
    for (let N = 0; N < h.length; N++) {
      let T = h.charCodeAt(N);
      if (T & 65280 || !(T >>> 5))
        throw new Error("Invalid cashaddr character.");
      if (T >= 97 && T <= 122)
        G = !0;
      else if (T >= 65 && T <= 90)
        j = !0, T = T - 65 + 97;
      else if (T >= 48 && T <= 57)
        throw new Error("Invalid cashaddr prefix.");
      u(E, T & 31), H += String.fromCharCode(T);
    }
    if (G && j)
      throw new Error("Invalid cashaddr prefix.");
    u(E, 0), H += ":";
    for (let N = 0; N < a.length; N++) {
      const T = a[N];
      if (T >>> 5)
        throw new Error("Invalid cashaddr value.");
      u(E, T), H += w[T];
    }
    for (let N = 0; N < 8; N++)
      u(E, 0);
    E.lo ^= 1;
    for (let N = 0; N < 8; N++) {
      const T = E.ushrn32((7 - N) * 5) & 31;
      H += w[T];
    }
    return H;
  }
  function s(h, a) {
    if (e(typeof h == "string"), h.length < 8 || h.length > 196)
      throw new Error("Invalid cashaddr data length.");
    let E = !1, H = !1, j = !1, G = 0;
    for (let F = 0; F < h.length; F++) {
      const R = h.charCodeAt(F);
      if (R >= 97 && R <= 122) {
        E = !0;
        continue;
      }
      if (R >= 65 && R <= 90) {
        H = !0;
        continue;
      }
      if (R >= 48 && R <= 57) {
        j = !0;
        continue;
      }
      if (R === 58) {
        if (j || F === 0 || F > 83)
          throw new Error("Invalid cashaddr prefix.");
        if (G !== 0)
          throw new Error("Invalid cashaddr separators.");
        G = F;
        continue;
      }
      throw new Error("Invalid cashaddr character.");
    }
    if (H && E)
      throw new Error("Invalid cashaddr casing.");
    const N = new c(0, 1);
    let T;
    G === 0 ? T = a.toLowerCase() : (T = h.substring(0, G).toLowerCase(), G += 1);
    for (let F = 0; F < T.length; F++) {
      const R = T.charCodeAt(F);
      u(N, (R | 32) & 31);
    }
    u(N, 0);
    const A = h.length - G;
    if (A <= 8 || A > 112)
      throw new Error("Invalid cashaddr data length.");
    const q = k.allocUnsafe(A);
    for (let F = G; F < h.length; F++) {
      const R = h.charCodeAt(F), L = R & 65408 ? -1 : m[R];
      if (L === -1)
        throw new Error("Invalid cashaddr character.");
      u(N, L), F + 8 < h.length && (q[F - G] = L);
    }
    if (!(N.hi === 0 && N.lo === 1 && T === a))
      throw new Error("Invalid cashaddr checksum.");
    return [T, q.slice(0, -8)];
  }
  function i(h, a, E, H, j, G, N) {
    e(k.isBuffer(h)), e(a >>> 0 === a), e(k.isBuffer(E)), e(H >>> 0 === H), e((j & 255) === j), e((G & 255) === G), e(typeof N == "boolean");
    const T = (1 << G) - 1;
    let A = 0, q = 0;
    for (; a < h.length; a++) {
      const _ = h[a];
      if (_ >>> j)
        throw new Error("Invalid bits.");
      for (A = A << j | _, q += j; q >= G; )
        q -= G, E[H++] = A >>> q & T;
    }
    if (N)
      q && (E[H++] = A << G - q & T);
    else if (q >= j || A << G - q & T)
      throw new Error("Invalid bits.");
    return e(H <= E.length), E.slice(0, H);
  }
  function p(h) {
    switch (e(h >>> 0 === h), h) {
      case 20:
        return 0;
      case 24:
        return 1;
      case 28:
        return 2;
      case 32:
        return 3;
      case 40:
        return 4;
      case 48:
        return 5;
      case 56:
        return 6;
      case 64:
        return 7;
      default:
        throw new Error("Non standard length.");
    }
  }
  function g(h, a, E) {
    if (e(typeof h == "string"), e((a & 15) === a, "Invalid cashaddr type."), e(k.isBuffer(E)), h.length === 0 || h.length > 83)
      throw new Error("Invalid cashaddr prefix.");
    const H = p(E.length), j = k.allocUnsafe(E.length + 1);
    j[0] = a << 3 | H, E.copy(j, 1);
    const N = i(j, 0, l, 0, 8, 5, !0);
    return o(h, N);
  }
  function S(h, a = "bitcoincash") {
    e(typeof h == "string"), e(typeof a == "string");
    const [E, H] = s(h, a), j = H.length * 5 & 7;
    if (j >= 5)
      throw new Error("Invalid padding in data.");
    const G = H[H.length - 1], N = (1 << j) - 1;
    if (G & N)
      throw new Error("Non zero padding.");
    const A = i(H, 0, H, 0, 5, 8, !1), q = A[0] >>> 3 & 31, _ = A.slice(1);
    let F = 20 + 4 * (A[0] & 3);
    if (A[0] & 4 && (F *= 2), F !== _.length)
      throw new Error("Invalid cashaddr data length.");
    return new b(E, q, _);
  }
  function y(h, a = "bitcoincash") {
    try {
      S(h, a);
    } catch {
      return !1;
    }
    return !0;
  }
  class b {
    constructor(a, E, H) {
      this.prefix = a, this.type = E, this.hash = H;
    }
  }
  return Rn.encode = g, Rn.decode = S, Rn.test = y, Rn;
}
/*!
 * bstring
 * Copyright (c) 2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bstring
 */
var C1;
function gn() {
  return C1 || (C1 = 1, On.base58 = vm(), On.bech32 = Sm(), On.cashaddr = Em()), On;
}
var Im = gn();
const Ys = /* @__PURE__ */ Nr(Im);
var Pn = {}, ds = {}, D1;
function cl() {
  if (D1) return ds;
  D1 = 1;
  /**
   * @license
   * https://reviews.bitcoinabc.org
   * Copyright (c) 2017-2020 Emilio Almansi
   * Copyright (c) 2023 Bitcoin ABC
   * Distributed under the MIT software license, see the accompanying
   * file LICENSE or http://www.opensource.org/licenses/mit-license.php.
   */
  Object.defineProperty(ds, "__esModule", { value: !0 });
  class e extends Error {
    constructor(w) {
      super(w), this.name = "ValidationError", Object.setPrototypeOf(this, e.prototype);
    }
  }
  function c(l, w) {
    if (!l)
      throw new e(w);
  }
  return ds.default = {
    ValidationError: e,
    validate: c
  }, ds;
}
var U1;
function Am() {
  return U1 || (U1 = 1, function(e) {
    /**
     * @license
     * https://reviews.bitcoinabc.org
     * Copyright (c) 2017-2020 Emilio Almansi
     * Copyright (c) 2023-2024 Bitcoin ABC
     * Distributed under the MIT software license, see the accompanying
     * file LICENSE or http://www.opensource.org/licenses/mit-license.php.
     */
    var c = Pn && Pn.__importDefault || function(u) {
      return u && u.__esModule ? u : { default: u };
    };
    Object.defineProperty(e, "__esModule", { value: !0 }), e.CHARSET = void 0;
    const l = c(cl()), { validate: w } = l.default;
    e.CHARSET = "qpzry9x8gf2tvdw0s3jn54khce6mua7l";
    const m = {
      q: 0,
      p: 1,
      z: 2,
      r: 3,
      y: 4,
      9: 5,
      x: 6,
      8: 7,
      g: 8,
      f: 9,
      2: 10,
      t: 11,
      v: 12,
      d: 13,
      w: 14,
      0: 15,
      s: 16,
      3: 17,
      j: 18,
      n: 19,
      5: 20,
      4: 21,
      k: 22,
      h: 23,
      c: 24,
      e: 25,
      6: 26,
      m: 27,
      u: 28,
      a: 29,
      7: 30,
      l: 31
    };
    function f(u) {
      w(u instanceof Uint8Array, "Invalid data: " + u + ".");
      let o = "";
      for (let s = 0; s < u.length; ++s) {
        const i = u[s];
        w(0 <= i && i < 32, "Invalid value: " + i + "."), o += e.CHARSET[i];
      }
      return o;
    }
    function n(u) {
      w(typeof u == "string", "Invalid base32-encoded string: " + u + ".");
      const o = new Uint8Array(u.length);
      for (let s = 0; s < u.length; ++s) {
        const i = u[s];
        w(i in m, "Invalid value: " + i + "."), o[s] = m[i];
      }
      return o;
    }
    e.default = {
      encode: f,
      decode: n
    };
  }(Pn)), Pn;
}
var Wi = {}, F1;
function Om() {
  if (F1) return Wi;
  F1 = 1;
  var e = Wi && Wi.__importDefault || function(m) {
    return m && m.__esModule ? m : { default: m };
  };
  Object.defineProperty(Wi, "__esModule", { value: !0 }), Wi.default = w;
  const c = e(cl()), { validate: l } = c.default;
  function w(m, f, n, u = !1) {
    const o = u ? Math.floor(m.length * f / n) : Math.ceil(m.length * f / n), s = (1 << n) - 1, i = new Uint8Array(o);
    let p = 0, g = 0, S = 0;
    for (let y = 0; y < m.length; ++y) {
      const b = m[y];
      for (l(0 <= b && b >> f === 0, "Invalid value: " + b + "."), g = g << f | b, S += f; S >= n; )
        S -= n, i[p] = g >> S & s, ++p;
    }
    return u ? l(S < f && (g << n - S & s) === 0, "Input cannot be converted to " + n + " bits without padding, but strict mode was used.") : S > 0 && (i[p] = g << n - S & s, ++p), i;
  }
  return Wi;
}
var $o = { exports: {} }, H1;
function _m() {
  return H1 || (H1 = 1, function(e) {
    var c = function(l) {
      var w = 1e7, m = 7, f = 9007199254740992, n = g(f), u = Math.log(f);
      function o(P, V) {
        return typeof P > "u" ? o[0] : typeof V < "u" ? +V == 10 ? K(P) : J(P, V) : K(P);
      }
      function s(P, V) {
        this.value = P, this.sign = V, this.isSmall = !1;
      }
      s.prototype = Object.create(o.prototype);
      function i(P) {
        this.value = P, this.sign = P < 0, this.isSmall = !0;
      }
      i.prototype = Object.create(o.prototype);
      function p(P) {
        return -f < P && P < f;
      }
      function g(P) {
        return P < 1e7 ? [P] : P < 1e14 ? [P % 1e7, Math.floor(P / 1e7)] : [P % 1e7, Math.floor(P / 1e7) % 1e7, Math.floor(P / 1e14)];
      }
      function S(P) {
        y(P);
        var V = P.length;
        if (V < 4 && Q(P, n) < 0)
          switch (V) {
            case 0:
              return 0;
            case 1:
              return P[0];
            case 2:
              return P[0] + P[1] * w;
            default:
              return P[0] + (P[1] + P[2] * w) * w;
          }
        return P;
      }
      function y(P) {
        for (var V = P.length; P[--V] === 0; ) ;
        P.length = V + 1;
      }
      function b(P) {
        for (var V = new Array(P), re = -1; ++re < P; )
          V[re] = 0;
        return V;
      }
      function h(P) {
        return P > 0 ? Math.floor(P) : Math.ceil(P);
      }
      function a(P, V) {
        var re = P.length, ce = V.length, de = new Array(re), pe = 0, se = w, Z, ee;
        for (ee = 0; ee < ce; ee++)
          Z = P[ee] + V[ee] + pe, pe = Z >= se ? 1 : 0, de[ee] = Z - pe * se;
        for (; ee < re; )
          Z = P[ee] + pe, pe = Z === se ? 1 : 0, de[ee++] = Z - pe * se;
        return pe > 0 && de.push(pe), de;
      }
      function E(P, V) {
        return P.length >= V.length ? a(P, V) : a(V, P);
      }
      function H(P, V) {
        var re = P.length, ce = new Array(re), de = w, pe, se;
        for (se = 0; se < re; se++)
          pe = P[se] - de + V, V = Math.floor(pe / de), ce[se] = pe - V * de, V += 1;
        for (; V > 0; )
          ce[se++] = V % de, V = Math.floor(V / de);
        return ce;
      }
      s.prototype.add = function(P) {
        var V = K(P);
        if (this.sign !== V.sign)
          return this.subtract(V.negate());
        var re = this.value, ce = V.value;
        return V.isSmall ? new s(H(re, Math.abs(ce)), this.sign) : new s(E(re, ce), this.sign);
      }, s.prototype.plus = s.prototype.add, i.prototype.add = function(P) {
        var V = K(P), re = this.value;
        if (re < 0 !== V.sign)
          return this.subtract(V.negate());
        var ce = V.value;
        if (V.isSmall) {
          if (p(re + ce)) return new i(re + ce);
          ce = g(Math.abs(ce));
        }
        return new s(H(ce, Math.abs(re)), re < 0);
      }, i.prototype.plus = i.prototype.add;
      function j(P, V) {
        var re = P.length, ce = V.length, de = new Array(re), pe = 0, se = w, Z, ee;
        for (Z = 0; Z < ce; Z++)
          ee = P[Z] - pe - V[Z], ee < 0 ? (ee += se, pe = 1) : pe = 0, de[Z] = ee;
        for (Z = ce; Z < re; Z++) {
          if (ee = P[Z] - pe, ee < 0) ee += se;
          else {
            de[Z++] = ee;
            break;
          }
          de[Z] = ee;
        }
        for (; Z < re; Z++)
          de[Z] = P[Z];
        return y(de), de;
      }
      function G(P, V, re) {
        var ce;
        return Q(P, V) >= 0 ? ce = j(P, V) : (ce = j(V, P), re = !re), ce = S(ce), typeof ce == "number" ? (re && (ce = -ce), new i(ce)) : new s(ce, re);
      }
      function N(P, V, re) {
        var ce = P.length, de = new Array(ce), pe = -V, se = w, Z, ee;
        for (Z = 0; Z < ce; Z++)
          ee = P[Z] + pe, pe = Math.floor(ee / se), ee %= se, de[Z] = ee < 0 ? ee + se : ee;
        return de = S(de), typeof de == "number" ? (re && (de = -de), new i(de)) : new s(de, re);
      }
      s.prototype.subtract = function(P) {
        var V = K(P);
        if (this.sign !== V.sign)
          return this.add(V.negate());
        var re = this.value, ce = V.value;
        return V.isSmall ? N(re, Math.abs(ce), this.sign) : G(re, ce, this.sign);
      }, s.prototype.minus = s.prototype.subtract, i.prototype.subtract = function(P) {
        var V = K(P), re = this.value;
        if (re < 0 !== V.sign)
          return this.add(V.negate());
        var ce = V.value;
        return V.isSmall ? new i(re - ce) : N(ce, Math.abs(re), re >= 0);
      }, i.prototype.minus = i.prototype.subtract, s.prototype.negate = function() {
        return new s(this.value, !this.sign);
      }, i.prototype.negate = function() {
        var P = this.sign, V = new i(-this.value);
        return V.sign = !P, V;
      }, s.prototype.abs = function() {
        return new s(this.value, !1);
      }, i.prototype.abs = function() {
        return new i(Math.abs(this.value));
      };
      function T(P, V) {
        var re = P.length, ce = V.length, de = re + ce, pe = b(de), se = w, Z, ee, me, Ae, Oe;
        for (me = 0; me < re; ++me) {
          Ae = P[me];
          for (var ye = 0; ye < ce; ++ye)
            Oe = V[ye], Z = Ae * Oe + pe[me + ye], ee = Math.floor(Z / se), pe[me + ye] = Z - ee * se, pe[me + ye + 1] += ee;
        }
        return y(pe), pe;
      }
      function A(P, V) {
        var re = P.length, ce = new Array(re), de = w, pe = 0, se, Z;
        for (Z = 0; Z < re; Z++)
          se = P[Z] * V + pe, pe = Math.floor(se / de), ce[Z] = se - pe * de;
        for (; pe > 0; )
          ce[Z++] = pe % de, pe = Math.floor(pe / de);
        return ce;
      }
      function q(P, V) {
        for (var re = []; V-- > 0; ) re.push(0);
        return re.concat(P);
      }
      function _(P, V) {
        var re = Math.max(P.length, V.length);
        if (re <= 30) return T(P, V);
        re = Math.ceil(re / 2);
        var ce = P.slice(re), de = P.slice(0, re), pe = V.slice(re), se = V.slice(0, re), Z = _(de, se), ee = _(ce, pe), me = _(E(de, ce), E(se, pe)), Ae = E(E(Z, q(j(j(me, Z), ee), re)), q(ee, 2 * re));
        return y(Ae), Ae;
      }
      function F(P, V) {
        return -0.012 * P - 0.012 * V + 15e-6 * P * V > 0;
      }
      s.prototype.multiply = function(P) {
        var V = K(P), re = this.value, ce = V.value, de = this.sign !== V.sign, pe;
        if (V.isSmall) {
          if (ce === 0) return o[0];
          if (ce === 1) return this;
          if (ce === -1) return this.negate();
          if (pe = Math.abs(ce), pe < w)
            return new s(A(re, pe), de);
          ce = g(pe);
        }
        return F(re.length, ce.length) ? new s(_(re, ce), de) : new s(T(re, ce), de);
      }, s.prototype.times = s.prototype.multiply;
      function R(P, V, re) {
        return P < w ? new s(A(V, P), re) : new s(T(V, g(P)), re);
      }
      i.prototype._multiplyBySmall = function(P) {
        return p(P.value * this.value) ? new i(P.value * this.value) : R(Math.abs(P.value), g(Math.abs(this.value)), this.sign !== P.sign);
      }, s.prototype._multiplyBySmall = function(P) {
        return P.value === 0 ? o[0] : P.value === 1 ? this : P.value === -1 ? this.negate() : R(Math.abs(P.value), this.value, this.sign !== P.sign);
      }, i.prototype.multiply = function(P) {
        return K(P)._multiplyBySmall(this);
      }, i.prototype.times = i.prototype.multiply;
      function L(P) {
        var V = P.length, re = b(V + V), ce = w, de, pe, se, Z, ee;
        for (se = 0; se < V; se++) {
          Z = P[se], pe = 0 - Z * Z;
          for (var me = se; me < V; me++)
            ee = P[me], de = 2 * (Z * ee) + re[se + me] + pe, pe = Math.floor(de / ce), re[se + me] = de - pe * ce;
          re[se + V] = pe;
        }
        return y(re), re;
      }
      s.prototype.square = function() {
        return new s(L(this.value), !1);
      }, i.prototype.square = function() {
        var P = this.value * this.value;
        return p(P) ? new i(P) : new s(L(g(Math.abs(this.value))), !1);
      };
      function fe(P, V) {
        var re = P.length, ce = V.length, de = w, pe = b(V.length), se = V[ce - 1], Z = Math.ceil(de / (2 * se)), ee = A(P, Z), me = A(V, Z), Ae, Oe, ye, _e, ke, Me, De;
        for (ee.length <= re && ee.push(0), me.push(0), se = me[ce - 1], Oe = re - ce; Oe >= 0; Oe--) {
          for (Ae = de - 1, ee[Oe + ce] !== se && (Ae = Math.floor((ee[Oe + ce] * de + ee[Oe + ce - 1]) / se)), ye = 0, _e = 0, Me = me.length, ke = 0; ke < Me; ke++)
            ye += Ae * me[ke], De = Math.floor(ye / de), _e += ee[Oe + ke] - (ye - De * de), ye = De, _e < 0 ? (ee[Oe + ke] = _e + de, _e = -1) : (ee[Oe + ke] = _e, _e = 0);
          for (; _e !== 0; ) {
            for (Ae -= 1, ye = 0, ke = 0; ke < Me; ke++)
              ye += ee[Oe + ke] - de + me[ke], ye < 0 ? (ee[Oe + ke] = ye + de, ye = 0) : (ee[Oe + ke] = ye, ye = 1);
            _e += ye;
          }
          pe[Oe] = Ae;
        }
        return ee = ae(ee, Z)[0], [S(pe), S(ee)];
      }
      function ue(P, V) {
        for (var re = P.length, ce = V.length, de = [], pe = [], se = w, Z, ee, me, Ae, Oe; re; ) {
          if (pe.unshift(P[--re]), y(pe), Q(pe, V) < 0) {
            de.push(0);
            continue;
          }
          ee = pe.length, me = pe[ee - 1] * se + pe[ee - 2], Ae = V[ce - 1] * se + V[ce - 2], ee > ce && (me = (me + 1) * se), Z = Math.ceil(me / Ae);
          do {
            if (Oe = A(V, Z), Q(Oe, pe) <= 0) break;
            Z--;
          } while (Z);
          de.push(Z), pe = j(pe, Oe);
        }
        return de.reverse(), [S(de), S(pe)];
      }
      function ae(P, V) {
        var re = P.length, ce = b(re), de = w, pe, se, Z, ee;
        for (Z = 0, pe = re - 1; pe >= 0; --pe)
          ee = Z * de + P[pe], se = h(ee / V), Z = ee - se * V, ce[pe] = se | 0;
        return [ce, Z | 0];
      }
      function D(P, V) {
        var re, ce = K(V), de = P.value, pe = ce.value, se;
        if (pe === 0) throw new Error("Cannot divide by zero");
        if (P.isSmall)
          return ce.isSmall ? [new i(h(de / pe)), new i(de % pe)] : [o[0], P];
        if (ce.isSmall) {
          if (pe === 1) return [P, o[0]];
          if (pe == -1) return [P.negate(), o[0]];
          var Z = Math.abs(pe);
          if (Z < w) {
            re = ae(de, Z), se = S(re[0]);
            var ee = re[1];
            return P.sign && (ee = -ee), typeof se == "number" ? (P.sign !== ce.sign && (se = -se), [new i(se), new i(ee)]) : [new s(se, P.sign !== ce.sign), new i(ee)];
          }
          pe = g(Z);
        }
        var me = Q(de, pe);
        if (me === -1) return [o[0], P];
        if (me === 0) return [o[P.sign === ce.sign ? 1 : -1], o[0]];
        de.length + pe.length <= 200 ? re = fe(de, pe) : re = ue(de, pe), se = re[0];
        var Ae = P.sign !== ce.sign, Oe = re[1], ye = P.sign;
        return typeof se == "number" ? (Ae && (se = -se), se = new i(se)) : se = new s(se, Ae), typeof Oe == "number" ? (ye && (Oe = -Oe), Oe = new i(Oe)) : Oe = new s(Oe, ye), [se, Oe];
      }
      s.prototype.divmod = function(P) {
        var V = D(this, P);
        return {
          quotient: V[0],
          remainder: V[1]
        };
      }, i.prototype.divmod = s.prototype.divmod, s.prototype.divide = function(P) {
        return D(this, P)[0];
      }, i.prototype.over = i.prototype.divide = s.prototype.over = s.prototype.divide, s.prototype.mod = function(P) {
        return D(this, P)[1];
      }, i.prototype.remainder = i.prototype.mod = s.prototype.remainder = s.prototype.mod, s.prototype.pow = function(P) {
        var V = K(P), re = this.value, ce = V.value, de, pe, se;
        if (ce === 0) return o[1];
        if (re === 0) return o[0];
        if (re === 1) return o[1];
        if (re === -1) return V.isEven() ? o[1] : o[-1];
        if (V.sign)
          return o[0];
        if (!V.isSmall) throw new Error("The exponent " + V.toString() + " is too large.");
        if (this.isSmall && p(de = Math.pow(re, ce)))
          return new i(h(de));
        for (pe = this, se = o[1]; ce & !0 && (se = se.times(pe), --ce), ce !== 0; )
          ce /= 2, pe = pe.square();
        return se;
      }, i.prototype.pow = s.prototype.pow, s.prototype.modPow = function(P, V) {
        if (P = K(P), V = K(V), V.isZero()) throw new Error("Cannot take modPow with modulus 0");
        for (var re = o[1], ce = this.mod(V); P.isPositive(); ) {
          if (ce.isZero()) return o[0];
          P.isOdd() && (re = re.multiply(ce).mod(V)), P = P.divide(2), ce = ce.square().mod(V);
        }
        return re;
      }, i.prototype.modPow = s.prototype.modPow;
      function Q(P, V) {
        if (P.length !== V.length)
          return P.length > V.length ? 1 : -1;
        for (var re = P.length - 1; re >= 0; re--)
          if (P[re] !== V[re]) return P[re] > V[re] ? 1 : -1;
        return 0;
      }
      s.prototype.compareAbs = function(P) {
        var V = K(P), re = this.value, ce = V.value;
        return V.isSmall ? 1 : Q(re, ce);
      }, i.prototype.compareAbs = function(P) {
        var V = K(P), re = Math.abs(this.value), ce = V.value;
        return V.isSmall ? (ce = Math.abs(ce), re === ce ? 0 : re > ce ? 1 : -1) : -1;
      }, s.prototype.compare = function(P) {
        if (P === 1 / 0)
          return -1;
        if (P === -1 / 0)
          return 1;
        var V = K(P), re = this.value, ce = V.value;
        return this.sign !== V.sign ? V.sign ? 1 : -1 : V.isSmall ? this.sign ? -1 : 1 : Q(re, ce) * (this.sign ? -1 : 1);
      }, s.prototype.compareTo = s.prototype.compare, i.prototype.compare = function(P) {
        if (P === 1 / 0)
          return -1;
        if (P === -1 / 0)
          return 1;
        var V = K(P), re = this.value, ce = V.value;
        return V.isSmall ? re == ce ? 0 : re > ce ? 1 : -1 : re < 0 !== V.sign ? re < 0 ? -1 : 1 : re < 0 ? 1 : -1;
      }, i.prototype.compareTo = i.prototype.compare, s.prototype.equals = function(P) {
        return this.compare(P) === 0;
      }, i.prototype.eq = i.prototype.equals = s.prototype.eq = s.prototype.equals, s.prototype.notEquals = function(P) {
        return this.compare(P) !== 0;
      }, i.prototype.neq = i.prototype.notEquals = s.prototype.neq = s.prototype.notEquals, s.prototype.greater = function(P) {
        return this.compare(P) > 0;
      }, i.prototype.gt = i.prototype.greater = s.prototype.gt = s.prototype.greater, s.prototype.lesser = function(P) {
        return this.compare(P) < 0;
      }, i.prototype.lt = i.prototype.lesser = s.prototype.lt = s.prototype.lesser, s.prototype.greaterOrEquals = function(P) {
        return this.compare(P) >= 0;
      }, i.prototype.geq = i.prototype.greaterOrEquals = s.prototype.geq = s.prototype.greaterOrEquals, s.prototype.lesserOrEquals = function(P) {
        return this.compare(P) <= 0;
      }, i.prototype.leq = i.prototype.lesserOrEquals = s.prototype.leq = s.prototype.lesserOrEquals, s.prototype.isEven = function() {
        return (this.value[0] & 1) === 0;
      }, i.prototype.isEven = function() {
        return (this.value & 1) === 0;
      }, s.prototype.isOdd = function() {
        return (this.value[0] & 1) === 1;
      }, i.prototype.isOdd = function() {
        return (this.value & 1) === 1;
      }, s.prototype.isPositive = function() {
        return !this.sign;
      }, i.prototype.isPositive = function() {
        return this.value > 0;
      }, s.prototype.isNegative = function() {
        return this.sign;
      }, i.prototype.isNegative = function() {
        return this.value < 0;
      }, s.prototype.isUnit = function() {
        return !1;
      }, i.prototype.isUnit = function() {
        return Math.abs(this.value) === 1;
      }, s.prototype.isZero = function() {
        return !1;
      }, i.prototype.isZero = function() {
        return this.value === 0;
      }, s.prototype.isDivisibleBy = function(P) {
        var V = K(P), re = V.value;
        return re === 0 ? !1 : re === 1 ? !0 : re === 2 ? this.isEven() : this.mod(V).equals(o[0]);
      }, i.prototype.isDivisibleBy = s.prototype.isDivisibleBy;
      function W(P) {
        var V = P.abs();
        if (V.isUnit()) return !1;
        if (V.equals(2) || V.equals(3) || V.equals(5)) return !0;
        if (V.isEven() || V.isDivisibleBy(3) || V.isDivisibleBy(5)) return !1;
        if (V.lesser(49)) return !0;
      }
      function oe(P, V) {
        for (var re = P.prev(), ce = re, de = 0, pe, se, Z; ce.isEven(); ) ce = ce.divide(2), de++;
        e: for (se = 0; se < V.length; se++)
          if (!P.lesser(V[se]) && (Z = c(V[se]).modPow(ce, P), !(Z.equals(o[1]) || Z.equals(re)))) {
            for (pe = de - 1; pe != 0; pe--) {
              if (Z = Z.square().mod(P), Z.isUnit()) return !1;
              if (Z.equals(re)) continue e;
            }
            return !1;
          }
        return !0;
      }
      s.prototype.isPrime = function(P) {
        var V = W(this);
        if (V !== l) return V;
        var re = this.abs(), ce = re.bitLength();
        if (ce <= 64)
          return oe(re, [2, 325, 9375, 28178, 450775, 9780504, 1795265022]);
        for (var de = Math.log(2) * ce, pe = Math.ceil(P === !0 ? 2 * Math.pow(de, 2) : de), se = [], Z = 0; Z < pe; Z++)
          se.push(c(Z + 2));
        return oe(re, se);
      }, i.prototype.isPrime = s.prototype.isPrime, s.prototype.isProbablePrime = function(P) {
        var V = W(this);
        if (V !== l) return V;
        for (var re = this.abs(), ce = P === l ? 5 : P, de = [], pe = 0; pe < ce; pe++)
          de.push(c.randBetween(2, re.minus(2)));
        return oe(re, de);
      }, i.prototype.isProbablePrime = s.prototype.isProbablePrime, s.prototype.modInv = function(P) {
        for (var V = c.zero, re = c.one, ce = K(P), de = this.abs(), pe, se, Z; !de.equals(c.zero); )
          pe = ce.divide(de), se = V, Z = ce, V = re, ce = de, re = se.subtract(pe.multiply(re)), de = Z.subtract(pe.multiply(de));
        if (!ce.equals(1)) throw new Error(this.toString() + " and " + P.toString() + " are not co-prime");
        return V.compare(0) === -1 && (V = V.add(P)), this.isNegative() ? V.negate() : V;
      }, i.prototype.modInv = s.prototype.modInv, s.prototype.next = function() {
        var P = this.value;
        return this.sign ? N(P, 1, this.sign) : new s(H(P, 1), this.sign);
      }, i.prototype.next = function() {
        var P = this.value;
        return P + 1 < f ? new i(P + 1) : new s(n, !1);
      }, s.prototype.prev = function() {
        var P = this.value;
        return this.sign ? new s(H(P, 1), !0) : N(P, 1, this.sign);
      }, i.prototype.prev = function() {
        var P = this.value;
        return P - 1 > -f ? new i(P - 1) : new s(n, !0);
      };
      for (var v = [1]; 2 * v[v.length - 1] <= w; ) v.push(2 * v[v.length - 1]);
      var Y = v.length, he = v[Y - 1];
      function le(P) {
        return (typeof P == "number" || typeof P == "string") && +Math.abs(P) <= w || P instanceof s && P.value.length <= 1;
      }
      s.prototype.shiftLeft = function(P) {
        if (!le(P))
          throw new Error(String(P) + " is too large for shifting.");
        if (P = +P, P < 0) return this.shiftRight(-P);
        var V = this;
        if (V.isZero()) return V;
        for (; P >= Y; )
          V = V.multiply(he), P -= Y - 1;
        return V.multiply(v[P]);
      }, i.prototype.shiftLeft = s.prototype.shiftLeft, s.prototype.shiftRight = function(P) {
        var V;
        if (!le(P))
          throw new Error(String(P) + " is too large for shifting.");
        if (P = +P, P < 0) return this.shiftLeft(-P);
        for (var re = this; P >= Y; ) {
          if (re.isZero() || re.isNegative() && re.isUnit()) return re;
          V = D(re, he), re = V[1].isNegative() ? V[0].prev() : V[0], P -= Y - 1;
        }
        return V = D(re, v[P]), V[1].isNegative() ? V[0].prev() : V[0];
      }, i.prototype.shiftRight = s.prototype.shiftRight;
      function ge(P, V, re) {
        V = K(V);
        for (var ce = P.isNegative(), de = V.isNegative(), pe = ce ? P.not() : P, se = de ? V.not() : V, Z = 0, ee = 0, me = null, Ae = null, Oe = []; !pe.isZero() || !se.isZero(); )
          me = D(pe, he), Z = me[1].toJSNumber(), ce && (Z = he - 1 - Z), Ae = D(se, he), ee = Ae[1].toJSNumber(), de && (ee = he - 1 - ee), pe = me[0], se = Ae[0], Oe.push(re(Z, ee));
        for (var ye = re(ce ? 1 : 0, de ? 1 : 0) !== 0 ? c(-1) : c(0), _e = Oe.length - 1; _e >= 0; _e -= 1)
          ye = ye.multiply(he).add(c(Oe[_e]));
        return ye;
      }
      s.prototype.not = function() {
        return this.negate().prev();
      }, i.prototype.not = s.prototype.not, s.prototype.and = function(P) {
        return ge(this, P, function(V, re) {
          return V & re;
        });
      }, i.prototype.and = s.prototype.and, s.prototype.or = function(P) {
        return ge(this, P, function(V, re) {
          return V | re;
        });
      }, i.prototype.or = s.prototype.or, s.prototype.xor = function(P) {
        return ge(this, P, function(V, re) {
          return V ^ re;
        });
      }, i.prototype.xor = s.prototype.xor;
      var Ee = 1 << 30, we = (w & -w) * (w & -w) | Ee;
      function z(P) {
        var V = P.value, re = typeof V == "number" ? V | Ee : V[0] + V[1] * w | we;
        return re & -re;
      }
      function I(P, V) {
        if (V.compareTo(P) <= 0) {
          var re = I(P, V.square(V)), ce = re.p, de = re.e, pe = ce.multiply(V);
          return pe.compareTo(P) <= 0 ? { p: pe, e: de * 2 + 1 } : { p: ce, e: de * 2 };
        }
        return { p: c(1), e: 0 };
      }
      s.prototype.bitLength = function() {
        var P = this;
        return P.compareTo(c(0)) < 0 && (P = P.negate().subtract(c(1))), P.compareTo(c(0)) === 0 ? c(0) : c(I(P, c(2)).e).add(c(1));
      }, i.prototype.bitLength = s.prototype.bitLength;
      function ne(P, V) {
        return P = K(P), V = K(V), P.greater(V) ? P : V;
      }
      function t(P, V) {
        return P = K(P), V = K(V), P.lesser(V) ? P : V;
      }
      function d(P, V) {
        if (P = K(P).abs(), V = K(V).abs(), P.equals(V)) return P;
        if (P.isZero()) return V;
        if (V.isZero()) return P;
        for (var re = o[1], ce, de; P.isEven() && V.isEven(); )
          ce = Math.min(z(P), z(V)), P = P.divide(ce), V = V.divide(ce), re = re.multiply(ce);
        for (; P.isEven(); )
          P = P.divide(z(P));
        do {
          for (; V.isEven(); )
            V = V.divide(z(V));
          P.greater(V) && (de = V, V = P, P = de), V = V.subtract(P);
        } while (!V.isZero());
        return re.isUnit() ? P : P.multiply(re);
      }
      function B(P, V) {
        return P = K(P).abs(), V = K(V).abs(), P.divide(d(P, V)).multiply(V);
      }
      function U(P, V) {
        P = K(P), V = K(V);
        var re = t(P, V), ce = ne(P, V), de = ce.subtract(re).add(1);
        if (de.isSmall) return re.add(Math.floor(Math.random() * de));
        for (var pe = de.value.length - 1, se = [], Z = !0, ee = pe; ee >= 0; ee--) {
          var me = Z ? de.value[ee] : w, Ae = h(Math.random() * me);
          se.unshift(Ae), Ae < me && (Z = !1);
        }
        return se = S(se), re.add(typeof se == "number" ? new i(se) : new s(se, !1));
      }
      var J = function(P, V) {
        for (var re = P.length, ce, de = Math.abs(V), ce = 0; ce < re; ce++) {
          var pe = P[ce].toLowerCase();
          if (pe !== "-" && /[a-z0-9]/.test(pe)) {
            if (/[0-9]/.test(pe) && +pe >= de) {
              if (pe === "1" && de === 1) continue;
              throw new Error(pe + " is not a valid digit in base " + V + ".");
            } else if (pe.charCodeAt(0) - 87 >= de)
              throw new Error(pe + " is not a valid digit in base " + V + ".");
          }
        }
        if (2 <= V && V <= 36 && re <= u / Math.log(V)) {
          var se = parseInt(P, V);
          if (isNaN(se))
            throw new Error(pe + " is not a valid digit in base " + V + ".");
          return new i(parseInt(P, V));
        }
        V = K(V);
        var Z = [], ee = P[0] === "-";
        for (ce = ee ? 1 : 0; ce < P.length; ce++) {
          var pe = P[ce].toLowerCase(), me = pe.charCodeAt(0);
          if (48 <= me && me <= 57) Z.push(K(pe));
          else if (97 <= me && me <= 122) Z.push(K(pe.charCodeAt(0) - 87));
          else if (pe === "<") {
            var Ae = ce;
            do
              ce++;
            while (P[ce] !== ">");
            Z.push(K(P.slice(Ae + 1, ce)));
          } else throw new Error(pe + " is not a valid character");
        }
        return C(Z, V, ee);
      };
      function C(P, V, re) {
        var ce = o[0], de = o[1], pe;
        for (pe = P.length - 1; pe >= 0; pe--)
          ce = ce.add(P[pe].times(de)), de = de.times(V);
        return re ? ce.negate() : ce;
      }
      function M(P) {
        return P <= 35 ? "0123456789abcdefghijklmnopqrstuvwxyz".charAt(P) : "<" + P + ">";
      }
      function $(P, V) {
        if (V = c(V), V.isZero()) {
          if (P.isZero()) return { value: [0], isNegative: !1 };
          throw new Error("Cannot convert nonzero numbers to base 0.");
        }
        if (V.equals(-1)) {
          if (P.isZero()) return { value: [0], isNegative: !1 };
          if (P.isNegative())
            return {
              value: [].concat.apply(
                [],
                Array.apply(null, Array(-P)).map(Array.prototype.valueOf, [1, 0])
              ),
              isNegative: !1
            };
          var re = Array.apply(null, Array(+P - 1)).map(Array.prototype.valueOf, [0, 1]);
          return re.unshift([1]), {
            value: [].concat.apply([], re),
            isNegative: !1
          };
        }
        var ce = !1;
        if (P.isNegative() && V.isPositive() && (ce = !0, P = P.abs()), V.equals(1))
          return P.isZero() ? { value: [0], isNegative: !1 } : {
            value: Array.apply(null, Array(+P)).map(Number.prototype.valueOf, 1),
            isNegative: ce
          };
        for (var de = [], pe = P, se; pe.isNegative() || pe.compareAbs(V) >= 0; ) {
          se = pe.divmod(V), pe = se.quotient;
          var Z = se.remainder;
          Z.isNegative() && (Z = V.minus(Z).abs(), pe = pe.next()), de.push(Z.toJSNumber());
        }
        return de.push(pe.toJSNumber()), { value: de.reverse(), isNegative: ce };
      }
      function r(P, V) {
        var re = $(P, V);
        return (re.isNegative ? "-" : "") + re.value.map(M).join("");
      }
      s.prototype.toArray = function(P) {
        return $(this, P);
      }, i.prototype.toArray = function(P) {
        return $(this, P);
      }, s.prototype.toString = function(P) {
        if (P === l && (P = 10), P !== 10) return r(this, P);
        for (var V = this.value, re = V.length, ce = String(V[--re]), de = "0000000", pe; --re >= 0; )
          pe = String(V[re]), ce += de.slice(pe.length) + pe;
        var se = this.sign ? "-" : "";
        return se + ce;
      }, i.prototype.toString = function(P) {
        return P === l && (P = 10), P != 10 ? r(this, P) : String(this.value);
      }, s.prototype.toJSON = i.prototype.toJSON = function() {
        return this.toString();
      }, s.prototype.valueOf = function() {
        return parseInt(this.toString(), 10);
      }, s.prototype.toJSNumber = s.prototype.valueOf, i.prototype.valueOf = function() {
        return this.value;
      }, i.prototype.toJSNumber = i.prototype.valueOf;
      function x(P) {
        if (p(+P)) {
          var V = +P;
          if (V === h(V))
            return new i(V);
          throw new Error("Invalid integer: " + P);
        }
        var re = P[0] === "-";
        re && (P = P.slice(1));
        var ce = P.split(/e/i);
        if (ce.length > 2) throw new Error("Invalid integer: " + ce.join("e"));
        if (ce.length === 2) {
          var de = ce[1];
          if (de[0] === "+" && (de = de.slice(1)), de = +de, de !== h(de) || !p(de)) throw new Error("Invalid integer: " + de + " is not a valid exponent.");
          var pe = ce[0], se = pe.indexOf(".");
          if (se >= 0 && (de -= pe.length - se - 1, pe = pe.slice(0, se) + pe.slice(se + 1)), de < 0) throw new Error("Cannot include negative exponent part for integers");
          pe += new Array(de + 1).join("0"), P = pe;
        }
        var Z = /^([0-9][0-9]*)$/.test(P);
        if (!Z) throw new Error("Invalid integer: " + P);
        for (var ee = [], me = P.length, Ae = m, Oe = me - Ae; me > 0; )
          ee.push(+P.slice(Oe, me)), Oe -= Ae, Oe < 0 && (Oe = 0), me -= Ae;
        return y(ee), new s(ee, re);
      }
      function O(P) {
        if (p(P)) {
          if (P !== h(P)) throw new Error(P + " is not an integer.");
          return new i(P);
        }
        return x(P.toString());
      }
      function K(P) {
        return typeof P == "number" ? O(P) : typeof P == "string" ? x(P) : P;
      }
      for (var X = 0; X < 1e3; X++)
        o[X] = new i(X), X > 0 && (o[-X] = new i(-X));
      return o.one = o[1], o.zero = o[0], o.minusOne = o[-1], o.max = ne, o.min = t, o.gcd = d, o.lcm = B, o.isInstance = function(P) {
        return P instanceof s || P instanceof i;
      }, o.randBetween = U, o.fromArray = function(P, V, re) {
        return C(P.map(K), K(V || 10), re);
      }, o;
    }();
    e.hasOwnProperty("exports") && (e.exports = c);
  }($o)), $o.exports;
}
var Rr = {}, qt = {}, Jt = {}, jo = {}, kn = {}, L1;
function Rm() {
  return L1 || (L1 = 1, Object.defineProperty(kn, "__esModule", { value: !0 }), kn.crypto = void 0, kn.crypto = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0), kn;
}
var K1;
function B8() {
  return K1 || (K1 = 1, function(e) {
    /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
    Object.defineProperty(e, "__esModule", { value: !0 }), e.wrapXOFConstructorWithOpts = e.wrapConstructorWithOpts = e.wrapConstructor = e.Hash = e.nextTick = e.swap32IfBE = e.byteSwapIfBE = e.swap8IfBE = e.isLE = void 0, e.isBytes = l, e.anumber = w, e.abytes = m, e.ahash = f, e.aexists = n, e.aoutput = u, e.u8 = o, e.u32 = s, e.clean = i, e.createView = p, e.rotr = g, e.rotl = S, e.byteSwap = y, e.byteSwap32 = b, e.bytesToHex = E, e.hexToBytes = G, e.asyncLoop = T, e.utf8ToBytes = A, e.bytesToUtf8 = q, e.toBytes = _, e.kdfInputToBytes = F, e.concatBytes = R, e.checkOpts = L, e.createHasher = ue, e.createOptHasher = ae, e.createXOFer = D, e.randomBytes = Q;
    const c = /* @__PURE__ */ Rm();
    function l(W) {
      return W instanceof Uint8Array || ArrayBuffer.isView(W) && W.constructor.name === "Uint8Array";
    }
    function w(W) {
      if (!Number.isSafeInteger(W) || W < 0)
        throw new Error("positive integer expected, got " + W);
    }
    function m(W, ...oe) {
      if (!l(W))
        throw new Error("Uint8Array expected");
      if (oe.length > 0 && !oe.includes(W.length))
        throw new Error("Uint8Array expected of length " + oe + ", got length=" + W.length);
    }
    function f(W) {
      if (typeof W != "function" || typeof W.create != "function")
        throw new Error("Hash should be wrapped by utils.createHasher");
      w(W.outputLen), w(W.blockLen);
    }
    function n(W, oe = !0) {
      if (W.destroyed)
        throw new Error("Hash instance has been destroyed");
      if (oe && W.finished)
        throw new Error("Hash#digest() has already been called");
    }
    function u(W, oe) {
      m(W);
      const v = oe.outputLen;
      if (W.length < v)
        throw new Error("digestInto() expects output buffer of length at least " + v);
    }
    function o(W) {
      return new Uint8Array(W.buffer, W.byteOffset, W.byteLength);
    }
    function s(W) {
      return new Uint32Array(W.buffer, W.byteOffset, Math.floor(W.byteLength / 4));
    }
    function i(...W) {
      for (let oe = 0; oe < W.length; oe++)
        W[oe].fill(0);
    }
    function p(W) {
      return new DataView(W.buffer, W.byteOffset, W.byteLength);
    }
    function g(W, oe) {
      return W << 32 - oe | W >>> oe;
    }
    function S(W, oe) {
      return W << oe | W >>> 32 - oe >>> 0;
    }
    e.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
    function y(W) {
      return W << 24 & 4278190080 | W << 8 & 16711680 | W >>> 8 & 65280 | W >>> 24 & 255;
    }
    e.swap8IfBE = e.isLE ? (W) => W : (W) => y(W), e.byteSwapIfBE = e.swap8IfBE;
    function b(W) {
      for (let oe = 0; oe < W.length; oe++)
        W[oe] = y(W[oe]);
      return W;
    }
    e.swap32IfBE = e.isLE ? (W) => W : b;
    const h = /* @ts-ignore */ typeof Uint8Array.from([]).toHex == "function" && typeof Uint8Array.fromHex == "function", a = /* @__PURE__ */ Array.from({ length: 256 }, (W, oe) => oe.toString(16).padStart(2, "0"));
    function E(W) {
      if (m(W), h)
        return W.toHex();
      let oe = "";
      for (let v = 0; v < W.length; v++)
        oe += a[W[v]];
      return oe;
    }
    const H = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
    function j(W) {
      if (W >= H._0 && W <= H._9)
        return W - H._0;
      if (W >= H.A && W <= H.F)
        return W - (H.A - 10);
      if (W >= H.a && W <= H.f)
        return W - (H.a - 10);
    }
    function G(W) {
      if (typeof W != "string")
        throw new Error("hex string expected, got " + typeof W);
      if (h)
        return Uint8Array.fromHex(W);
      const oe = W.length, v = oe / 2;
      if (oe % 2)
        throw new Error("hex string expected, got unpadded hex of length " + oe);
      const Y = new Uint8Array(v);
      for (let he = 0, le = 0; he < v; he++, le += 2) {
        const ge = j(W.charCodeAt(le)), Ee = j(W.charCodeAt(le + 1));
        if (ge === void 0 || Ee === void 0) {
          const we = W[le] + W[le + 1];
          throw new Error('hex string expected, got non-hex character "' + we + '" at index ' + le);
        }
        Y[he] = ge * 16 + Ee;
      }
      return Y;
    }
    const N = async () => {
    };
    e.nextTick = N;
    async function T(W, oe, v) {
      let Y = Date.now();
      for (let he = 0; he < W; he++) {
        v(he);
        const le = Date.now() - Y;
        le >= 0 && le < oe || (await (0, e.nextTick)(), Y += le);
      }
    }
    function A(W) {
      if (typeof W != "string")
        throw new Error("string expected");
      return new Uint8Array(new TextEncoder().encode(W));
    }
    function q(W) {
      return new TextDecoder().decode(W);
    }
    function _(W) {
      return typeof W == "string" && (W = A(W)), m(W), W;
    }
    function F(W) {
      return typeof W == "string" && (W = A(W)), m(W), W;
    }
    function R(...W) {
      let oe = 0;
      for (let Y = 0; Y < W.length; Y++) {
        const he = W[Y];
        m(he), oe += he.length;
      }
      const v = new Uint8Array(oe);
      for (let Y = 0, he = 0; Y < W.length; Y++) {
        const le = W[Y];
        v.set(le, he), he += le.length;
      }
      return v;
    }
    function L(W, oe) {
      if (oe !== void 0 && {}.toString.call(oe) !== "[object Object]")
        throw new Error("options should be object or undefined");
      return Object.assign(W, oe);
    }
    class fe {
    }
    e.Hash = fe;
    function ue(W) {
      const oe = (Y) => W().update(_(Y)).digest(), v = W();
      return oe.outputLen = v.outputLen, oe.blockLen = v.blockLen, oe.create = () => W(), oe;
    }
    function ae(W) {
      const oe = (Y, he) => W(he).update(_(Y)).digest(), v = W({});
      return oe.outputLen = v.outputLen, oe.blockLen = v.blockLen, oe.create = (Y) => W(Y), oe;
    }
    function D(W) {
      const oe = (Y, he) => W(he).update(_(Y)).digest(), v = W({});
      return oe.outputLen = v.outputLen, oe.blockLen = v.blockLen, oe.create = (Y) => W(Y), oe;
    }
    e.wrapConstructor = ue, e.wrapConstructorWithOpts = ae, e.wrapXOFConstructorWithOpts = D;
    function Q(W = 32) {
      if (c.crypto && typeof c.crypto.getRandomValues == "function")
        return c.crypto.getRandomValues(new Uint8Array(W));
      if (c.crypto && typeof c.crypto.randomBytes == "function")
        return Uint8Array.from(c.crypto.randomBytes(W));
      throw new Error("crypto.getRandomValues must be defined");
    }
  }(jo)), jo;
}
var V1;
function Pm() {
  if (V1) return Jt;
  V1 = 1, Object.defineProperty(Jt, "__esModule", { value: !0 }), Jt.SHA512_IV = Jt.SHA384_IV = Jt.SHA224_IV = Jt.SHA256_IV = Jt.HashMD = void 0, Jt.setBigUint64 = c, Jt.Chi = l, Jt.Maj = w;
  const e = /* @__PURE__ */ B8();
  function c(f, n, u, o) {
    if (typeof f.setBigUint64 == "function")
      return f.setBigUint64(n, u, o);
    const s = BigInt(32), i = BigInt(4294967295), p = Number(u >> s & i), g = Number(u & i), S = o ? 4 : 0, y = o ? 0 : 4;
    f.setUint32(n + S, p, o), f.setUint32(n + y, g, o);
  }
  function l(f, n, u) {
    return f & n ^ ~f & u;
  }
  function w(f, n, u) {
    return f & n ^ f & u ^ n & u;
  }
  class m extends e.Hash {
    constructor(n, u, o, s) {
      super(), this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.blockLen = n, this.outputLen = u, this.padOffset = o, this.isLE = s, this.buffer = new Uint8Array(n), this.view = (0, e.createView)(this.buffer);
    }
    update(n) {
      (0, e.aexists)(this), n = (0, e.toBytes)(n), (0, e.abytes)(n);
      const { view: u, buffer: o, blockLen: s } = this, i = n.length;
      for (let p = 0; p < i; ) {
        const g = Math.min(s - this.pos, i - p);
        if (g === s) {
          const S = (0, e.createView)(n);
          for (; s <= i - p; p += s)
            this.process(S, p);
          continue;
        }
        o.set(n.subarray(p, p + g), this.pos), this.pos += g, p += g, this.pos === s && (this.process(u, 0), this.pos = 0);
      }
      return this.length += n.length, this.roundClean(), this;
    }
    digestInto(n) {
      (0, e.aexists)(this), (0, e.aoutput)(n, this), this.finished = !0;
      const { buffer: u, view: o, blockLen: s, isLE: i } = this;
      let { pos: p } = this;
      u[p++] = 128, (0, e.clean)(this.buffer.subarray(p)), this.padOffset > s - p && (this.process(o, 0), p = 0);
      for (let h = p; h < s; h++)
        u[h] = 0;
      c(o, s - 8, BigInt(this.length * 8), i), this.process(o, 0);
      const g = (0, e.createView)(n), S = this.outputLen;
      if (S % 4)
        throw new Error("_sha2: outputLen should be aligned to 32bit");
      const y = S / 4, b = this.get();
      if (y > b.length)
        throw new Error("_sha2: outputLen bigger than state");
      for (let h = 0; h < y; h++)
        g.setUint32(4 * h, b[h], i);
    }
    digest() {
      const { buffer: n, outputLen: u } = this;
      this.digestInto(n);
      const o = n.slice(0, u);
      return this.destroy(), o;
    }
    _cloneInto(n) {
      n || (n = new this.constructor()), n.set(...this.get());
      const { blockLen: u, buffer: o, length: s, finished: i, destroyed: p, pos: g } = this;
      return n.destroyed = p, n.finished = i, n.length = s, n.pos = g, s % u && n.buffer.set(o), n;
    }
    clone() {
      return this._cloneInto();
    }
  }
  return Jt.HashMD = m, Jt.SHA256_IV = Uint32Array.from([
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ]), Jt.SHA224_IV = Uint32Array.from([
    3238371032,
    914150663,
    812702999,
    4144912697,
    4290775857,
    1750603025,
    1694076839,
    3204075428
  ]), Jt.SHA384_IV = Uint32Array.from([
    3418070365,
    3238371032,
    1654270250,
    914150663,
    2438529370,
    812702999,
    355462360,
    4144912697,
    1731405415,
    4290775857,
    2394180231,
    1750603025,
    3675008525,
    1694076839,
    1203062813,
    3204075428
  ]), Jt.SHA512_IV = Uint32Array.from([
    1779033703,
    4089235720,
    3144134277,
    2227873595,
    1013904242,
    4271175723,
    2773480762,
    1595750129,
    1359893119,
    2917565137,
    2600822924,
    725511199,
    528734635,
    4215389547,
    1541459225,
    327033209
  ]), Jt;
}
var xt = {}, $1;
function km() {
  if ($1) return xt;
  $1 = 1, Object.defineProperty(xt, "__esModule", { value: !0 }), xt.toBig = xt.shrSL = xt.shrSH = xt.rotrSL = xt.rotrSH = xt.rotrBL = xt.rotrBH = xt.rotr32L = xt.rotr32H = xt.rotlSL = xt.rotlSH = xt.rotlBL = xt.rotlBH = xt.add5L = xt.add5H = xt.add4L = xt.add4H = xt.add3L = xt.add3H = void 0, xt.add = a, xt.fromBig = l, xt.split = w;
  const e = /* @__PURE__ */ BigInt(2 ** 32 - 1), c = /* @__PURE__ */ BigInt(32);
  function l(q, _ = !1) {
    return _ ? { h: Number(q & e), l: Number(q >> c & e) } : { h: Number(q >> c & e) | 0, l: Number(q & e) | 0 };
  }
  function w(q, _ = !1) {
    const F = q.length;
    let R = new Uint32Array(F), L = new Uint32Array(F);
    for (let fe = 0; fe < F; fe++) {
      const { h: ue, l: ae } = l(q[fe], _);
      [R[fe], L[fe]] = [ue, ae];
    }
    return [R, L];
  }
  const m = (q, _) => BigInt(q >>> 0) << c | BigInt(_ >>> 0);
  xt.toBig = m;
  const f = (q, _, F) => q >>> F;
  xt.shrSH = f;
  const n = (q, _, F) => q << 32 - F | _ >>> F;
  xt.shrSL = n;
  const u = (q, _, F) => q >>> F | _ << 32 - F;
  xt.rotrSH = u;
  const o = (q, _, F) => q << 32 - F | _ >>> F;
  xt.rotrSL = o;
  const s = (q, _, F) => q << 64 - F | _ >>> F - 32;
  xt.rotrBH = s;
  const i = (q, _, F) => q >>> F - 32 | _ << 64 - F;
  xt.rotrBL = i;
  const p = (q, _) => _;
  xt.rotr32H = p;
  const g = (q, _) => q;
  xt.rotr32L = g;
  const S = (q, _, F) => q << F | _ >>> 32 - F;
  xt.rotlSH = S;
  const y = (q, _, F) => _ << F | q >>> 32 - F;
  xt.rotlSL = y;
  const b = (q, _, F) => _ << F - 32 | q >>> 64 - F;
  xt.rotlBH = b;
  const h = (q, _, F) => q << F - 32 | _ >>> 64 - F;
  xt.rotlBL = h;
  function a(q, _, F, R) {
    const L = (_ >>> 0) + (R >>> 0);
    return { h: q + F + (L / 2 ** 32 | 0) | 0, l: L | 0 };
  }
  const E = (q, _, F) => (q >>> 0) + (_ >>> 0) + (F >>> 0);
  xt.add3L = E;
  const H = (q, _, F, R) => _ + F + R + (q / 2 ** 32 | 0) | 0;
  xt.add3H = H;
  const j = (q, _, F, R) => (q >>> 0) + (_ >>> 0) + (F >>> 0) + (R >>> 0);
  xt.add4L = j;
  const G = (q, _, F, R, L) => _ + F + R + L + (q / 2 ** 32 | 0) | 0;
  xt.add4H = G;
  const N = (q, _, F, R, L) => (q >>> 0) + (_ >>> 0) + (F >>> 0) + (R >>> 0) + (L >>> 0);
  xt.add5L = N;
  const T = (q, _, F, R, L, fe) => _ + F + R + L + fe + (q / 2 ** 32 | 0) | 0;
  xt.add5H = T;
  const A = {
    fromBig: l,
    split: w,
    toBig: m,
    shrSH: f,
    shrSL: n,
    rotrSH: u,
    rotrSL: o,
    rotrBH: s,
    rotrBL: i,
    rotr32H: p,
    rotr32L: g,
    rotlSH: S,
    rotlSL: y,
    rotlBH: b,
    rotlBL: h,
    add: a,
    add3L: E,
    add3H: H,
    add4L: j,
    add4H: G,
    add5H: T,
    add5L: N
  };
  return xt.default = A, xt;
}
var j1;
function Bm() {
  if (j1) return qt;
  j1 = 1, Object.defineProperty(qt, "__esModule", { value: !0 }), qt.sha512_224 = qt.sha512_256 = qt.sha384 = qt.sha512 = qt.sha224 = qt.sha256 = qt.SHA512_256 = qt.SHA512_224 = qt.SHA384 = qt.SHA512 = qt.SHA224 = qt.SHA256 = void 0;
  const e = /* @__PURE__ */ Pm(), c = /* @__PURE__ */ km(), l = /* @__PURE__ */ B8(), w = /* @__PURE__ */ Uint32Array.from([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ]), m = /* @__PURE__ */ new Uint32Array(64);
  class f extends e.HashMD {
    constructor(H = 32) {
      super(64, H, 8, !1), this.A = e.SHA256_IV[0] | 0, this.B = e.SHA256_IV[1] | 0, this.C = e.SHA256_IV[2] | 0, this.D = e.SHA256_IV[3] | 0, this.E = e.SHA256_IV[4] | 0, this.F = e.SHA256_IV[5] | 0, this.G = e.SHA256_IV[6] | 0, this.H = e.SHA256_IV[7] | 0;
    }
    get() {
      const { A: H, B: j, C: G, D: N, E: T, F: A, G: q, H: _ } = this;
      return [H, j, G, N, T, A, q, _];
    }
    // prettier-ignore
    set(H, j, G, N, T, A, q, _) {
      this.A = H | 0, this.B = j | 0, this.C = G | 0, this.D = N | 0, this.E = T | 0, this.F = A | 0, this.G = q | 0, this.H = _ | 0;
    }
    process(H, j) {
      for (let L = 0; L < 16; L++, j += 4)
        m[L] = H.getUint32(j, !1);
      for (let L = 16; L < 64; L++) {
        const fe = m[L - 15], ue = m[L - 2], ae = (0, l.rotr)(fe, 7) ^ (0, l.rotr)(fe, 18) ^ fe >>> 3, D = (0, l.rotr)(ue, 17) ^ (0, l.rotr)(ue, 19) ^ ue >>> 10;
        m[L] = D + m[L - 7] + ae + m[L - 16] | 0;
      }
      let { A: G, B: N, C: T, D: A, E: q, F: _, G: F, H: R } = this;
      for (let L = 0; L < 64; L++) {
        const fe = (0, l.rotr)(q, 6) ^ (0, l.rotr)(q, 11) ^ (0, l.rotr)(q, 25), ue = R + fe + (0, e.Chi)(q, _, F) + w[L] + m[L] | 0, D = ((0, l.rotr)(G, 2) ^ (0, l.rotr)(G, 13) ^ (0, l.rotr)(G, 22)) + (0, e.Maj)(G, N, T) | 0;
        R = F, F = _, _ = q, q = A + ue | 0, A = T, T = N, N = G, G = ue + D | 0;
      }
      G = G + this.A | 0, N = N + this.B | 0, T = T + this.C | 0, A = A + this.D | 0, q = q + this.E | 0, _ = _ + this.F | 0, F = F + this.G | 0, R = R + this.H | 0, this.set(G, N, T, A, q, _, F, R);
    }
    roundClean() {
      (0, l.clean)(m);
    }
    destroy() {
      this.set(0, 0, 0, 0, 0, 0, 0, 0), (0, l.clean)(this.buffer);
    }
  }
  qt.SHA256 = f;
  class n extends f {
    constructor() {
      super(28), this.A = e.SHA224_IV[0] | 0, this.B = e.SHA224_IV[1] | 0, this.C = e.SHA224_IV[2] | 0, this.D = e.SHA224_IV[3] | 0, this.E = e.SHA224_IV[4] | 0, this.F = e.SHA224_IV[5] | 0, this.G = e.SHA224_IV[6] | 0, this.H = e.SHA224_IV[7] | 0;
    }
  }
  qt.SHA224 = n;
  const u = c.split([
    "0x428a2f98d728ae22",
    "0x7137449123ef65cd",
    "0xb5c0fbcfec4d3b2f",
    "0xe9b5dba58189dbbc",
    "0x3956c25bf348b538",
    "0x59f111f1b605d019",
    "0x923f82a4af194f9b",
    "0xab1c5ed5da6d8118",
    "0xd807aa98a3030242",
    "0x12835b0145706fbe",
    "0x243185be4ee4b28c",
    "0x550c7dc3d5ffb4e2",
    "0x72be5d74f27b896f",
    "0x80deb1fe3b1696b1",
    "0x9bdc06a725c71235",
    "0xc19bf174cf692694",
    "0xe49b69c19ef14ad2",
    "0xefbe4786384f25e3",
    "0x0fc19dc68b8cd5b5",
    "0x240ca1cc77ac9c65",
    "0x2de92c6f592b0275",
    "0x4a7484aa6ea6e483",
    "0x5cb0a9dcbd41fbd4",
    "0x76f988da831153b5",
    "0x983e5152ee66dfab",
    "0xa831c66d2db43210",
    "0xb00327c898fb213f",
    "0xbf597fc7beef0ee4",
    "0xc6e00bf33da88fc2",
    "0xd5a79147930aa725",
    "0x06ca6351e003826f",
    "0x142929670a0e6e70",
    "0x27b70a8546d22ffc",
    "0x2e1b21385c26c926",
    "0x4d2c6dfc5ac42aed",
    "0x53380d139d95b3df",
    "0x650a73548baf63de",
    "0x766a0abb3c77b2a8",
    "0x81c2c92e47edaee6",
    "0x92722c851482353b",
    "0xa2bfe8a14cf10364",
    "0xa81a664bbc423001",
    "0xc24b8b70d0f89791",
    "0xc76c51a30654be30",
    "0xd192e819d6ef5218",
    "0xd69906245565a910",
    "0xf40e35855771202a",
    "0x106aa07032bbd1b8",
    "0x19a4c116b8d2d0c8",
    "0x1e376c085141ab53",
    "0x2748774cdf8eeb99",
    "0x34b0bcb5e19b48a8",
    "0x391c0cb3c5c95a63",
    "0x4ed8aa4ae3418acb",
    "0x5b9cca4f7763e373",
    "0x682e6ff3d6b2b8a3",
    "0x748f82ee5defb2fc",
    "0x78a5636f43172f60",
    "0x84c87814a1f0ab72",
    "0x8cc702081a6439ec",
    "0x90befffa23631e28",
    "0xa4506cebde82bde9",
    "0xbef9a3f7b2c67915",
    "0xc67178f2e372532b",
    "0xca273eceea26619c",
    "0xd186b8c721c0c207",
    "0xeada7dd6cde0eb1e",
    "0xf57d4f7fee6ed178",
    "0x06f067aa72176fba",
    "0x0a637dc5a2c898a6",
    "0x113f9804bef90dae",
    "0x1b710b35131c471b",
    "0x28db77f523047d84",
    "0x32caab7b40c72493",
    "0x3c9ebe0a15c9bebc",
    "0x431d67c49c100d4c",
    "0x4cc5d4becb3e42b6",
    "0x597f299cfc657e2a",
    "0x5fcb6fab3ad6faec",
    "0x6c44198c4a475817"
  ].map((E) => BigInt(E))), o = u[0], s = u[1], i = /* @__PURE__ */ new Uint32Array(80), p = /* @__PURE__ */ new Uint32Array(80);
  class g extends e.HashMD {
    constructor(H = 64) {
      super(128, H, 16, !1), this.Ah = e.SHA512_IV[0] | 0, this.Al = e.SHA512_IV[1] | 0, this.Bh = e.SHA512_IV[2] | 0, this.Bl = e.SHA512_IV[3] | 0, this.Ch = e.SHA512_IV[4] | 0, this.Cl = e.SHA512_IV[5] | 0, this.Dh = e.SHA512_IV[6] | 0, this.Dl = e.SHA512_IV[7] | 0, this.Eh = e.SHA512_IV[8] | 0, this.El = e.SHA512_IV[9] | 0, this.Fh = e.SHA512_IV[10] | 0, this.Fl = e.SHA512_IV[11] | 0, this.Gh = e.SHA512_IV[12] | 0, this.Gl = e.SHA512_IV[13] | 0, this.Hh = e.SHA512_IV[14] | 0, this.Hl = e.SHA512_IV[15] | 0;
    }
    // prettier-ignore
    get() {
      const { Ah: H, Al: j, Bh: G, Bl: N, Ch: T, Cl: A, Dh: q, Dl: _, Eh: F, El: R, Fh: L, Fl: fe, Gh: ue, Gl: ae, Hh: D, Hl: Q } = this;
      return [H, j, G, N, T, A, q, _, F, R, L, fe, ue, ae, D, Q];
    }
    // prettier-ignore
    set(H, j, G, N, T, A, q, _, F, R, L, fe, ue, ae, D, Q) {
      this.Ah = H | 0, this.Al = j | 0, this.Bh = G | 0, this.Bl = N | 0, this.Ch = T | 0, this.Cl = A | 0, this.Dh = q | 0, this.Dl = _ | 0, this.Eh = F | 0, this.El = R | 0, this.Fh = L | 0, this.Fl = fe | 0, this.Gh = ue | 0, this.Gl = ae | 0, this.Hh = D | 0, this.Hl = Q | 0;
    }
    process(H, j) {
      for (let v = 0; v < 16; v++, j += 4)
        i[v] = H.getUint32(j), p[v] = H.getUint32(j += 4);
      for (let v = 16; v < 80; v++) {
        const Y = i[v - 15] | 0, he = p[v - 15] | 0, le = c.rotrSH(Y, he, 1) ^ c.rotrSH(Y, he, 8) ^ c.shrSH(Y, he, 7), ge = c.rotrSL(Y, he, 1) ^ c.rotrSL(Y, he, 8) ^ c.shrSL(Y, he, 7), Ee = i[v - 2] | 0, we = p[v - 2] | 0, z = c.rotrSH(Ee, we, 19) ^ c.rotrBH(Ee, we, 61) ^ c.shrSH(Ee, we, 6), I = c.rotrSL(Ee, we, 19) ^ c.rotrBL(Ee, we, 61) ^ c.shrSL(Ee, we, 6), ne = c.add4L(ge, I, p[v - 7], p[v - 16]), t = c.add4H(ne, le, z, i[v - 7], i[v - 16]);
        i[v] = t | 0, p[v] = ne | 0;
      }
      let { Ah: G, Al: N, Bh: T, Bl: A, Ch: q, Cl: _, Dh: F, Dl: R, Eh: L, El: fe, Fh: ue, Fl: ae, Gh: D, Gl: Q, Hh: W, Hl: oe } = this;
      for (let v = 0; v < 80; v++) {
        const Y = c.rotrSH(L, fe, 14) ^ c.rotrSH(L, fe, 18) ^ c.rotrBH(L, fe, 41), he = c.rotrSL(L, fe, 14) ^ c.rotrSL(L, fe, 18) ^ c.rotrBL(L, fe, 41), le = L & ue ^ ~L & D, ge = fe & ae ^ ~fe & Q, Ee = c.add5L(oe, he, ge, s[v], p[v]), we = c.add5H(Ee, W, Y, le, o[v], i[v]), z = Ee | 0, I = c.rotrSH(G, N, 28) ^ c.rotrBH(G, N, 34) ^ c.rotrBH(G, N, 39), ne = c.rotrSL(G, N, 28) ^ c.rotrBL(G, N, 34) ^ c.rotrBL(G, N, 39), t = G & T ^ G & q ^ T & q, d = N & A ^ N & _ ^ A & _;
        W = D | 0, oe = Q | 0, D = ue | 0, Q = ae | 0, ue = L | 0, ae = fe | 0, { h: L, l: fe } = c.add(F | 0, R | 0, we | 0, z | 0), F = q | 0, R = _ | 0, q = T | 0, _ = A | 0, T = G | 0, A = N | 0;
        const B = c.add3L(z, ne, d);
        G = c.add3H(B, we, I, t), N = B | 0;
      }
      ({ h: G, l: N } = c.add(this.Ah | 0, this.Al | 0, G | 0, N | 0)), { h: T, l: A } = c.add(this.Bh | 0, this.Bl | 0, T | 0, A | 0), { h: q, l: _ } = c.add(this.Ch | 0, this.Cl | 0, q | 0, _ | 0), { h: F, l: R } = c.add(this.Dh | 0, this.Dl | 0, F | 0, R | 0), { h: L, l: fe } = c.add(this.Eh | 0, this.El | 0, L | 0, fe | 0), { h: ue, l: ae } = c.add(this.Fh | 0, this.Fl | 0, ue | 0, ae | 0), { h: D, l: Q } = c.add(this.Gh | 0, this.Gl | 0, D | 0, Q | 0), { h: W, l: oe } = c.add(this.Hh | 0, this.Hl | 0, W | 0, oe | 0), this.set(G, N, T, A, q, _, F, R, L, fe, ue, ae, D, Q, W, oe);
    }
    roundClean() {
      (0, l.clean)(i, p);
    }
    destroy() {
      (0, l.clean)(this.buffer), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
  }
  qt.SHA512 = g;
  class S extends g {
    constructor() {
      super(48), this.Ah = e.SHA384_IV[0] | 0, this.Al = e.SHA384_IV[1] | 0, this.Bh = e.SHA384_IV[2] | 0, this.Bl = e.SHA384_IV[3] | 0, this.Ch = e.SHA384_IV[4] | 0, this.Cl = e.SHA384_IV[5] | 0, this.Dh = e.SHA384_IV[6] | 0, this.Dl = e.SHA384_IV[7] | 0, this.Eh = e.SHA384_IV[8] | 0, this.El = e.SHA384_IV[9] | 0, this.Fh = e.SHA384_IV[10] | 0, this.Fl = e.SHA384_IV[11] | 0, this.Gh = e.SHA384_IV[12] | 0, this.Gl = e.SHA384_IV[13] | 0, this.Hh = e.SHA384_IV[14] | 0, this.Hl = e.SHA384_IV[15] | 0;
    }
  }
  qt.SHA384 = S;
  const y = /* @__PURE__ */ Uint32Array.from([
    2352822216,
    424955298,
    1944164710,
    2312950998,
    502970286,
    855612546,
    1738396948,
    1479516111,
    258812777,
    2077511080,
    2011393907,
    79989058,
    1067287976,
    1780299464,
    286451373,
    2446758561
  ]), b = /* @__PURE__ */ Uint32Array.from([
    573645204,
    4230739756,
    2673172387,
    3360449730,
    596883563,
    1867755857,
    2520282905,
    1497426621,
    2519219938,
    2827943907,
    3193839141,
    1401305490,
    721525244,
    746961066,
    246885852,
    2177182882
  ]);
  class h extends g {
    constructor() {
      super(28), this.Ah = y[0] | 0, this.Al = y[1] | 0, this.Bh = y[2] | 0, this.Bl = y[3] | 0, this.Ch = y[4] | 0, this.Cl = y[5] | 0, this.Dh = y[6] | 0, this.Dl = y[7] | 0, this.Eh = y[8] | 0, this.El = y[9] | 0, this.Fh = y[10] | 0, this.Fl = y[11] | 0, this.Gh = y[12] | 0, this.Gl = y[13] | 0, this.Hh = y[14] | 0, this.Hl = y[15] | 0;
    }
  }
  qt.SHA512_224 = h;
  class a extends g {
    constructor() {
      super(32), this.Ah = b[0] | 0, this.Al = b[1] | 0, this.Bh = b[2] | 0, this.Bl = b[3] | 0, this.Ch = b[4] | 0, this.Cl = b[5] | 0, this.Dh = b[6] | 0, this.Dl = b[7] | 0, this.Eh = b[8] | 0, this.El = b[9] | 0, this.Fh = b[10] | 0, this.Fl = b[11] | 0, this.Gh = b[12] | 0, this.Gl = b[13] | 0, this.Hh = b[14] | 0, this.Hl = b[15] | 0;
    }
  }
  return qt.SHA512_256 = a, qt.sha256 = (0, l.createHasher)(() => new f()), qt.sha224 = (0, l.createHasher)(() => new n()), qt.sha512 = (0, l.createHasher)(() => new g()), qt.sha384 = (0, l.createHasher)(() => new S()), qt.sha512_256 = (0, l.createHasher)(() => new a()), qt.sha512_224 = (0, l.createHasher)(() => new h()), qt;
}
var Y1;
function Mm() {
  if (Y1) return Rr;
  Y1 = 1, Object.defineProperty(Rr, "__esModule", { value: !0 }), Rr.sha224 = Rr.SHA224 = Rr.sha256 = Rr.SHA256 = void 0;
  const e = /* @__PURE__ */ Bm();
  return Rr.SHA256 = e.SHA256, Rr.sha256 = e.sha256, Rr.SHA224 = e.SHA224, Rr.sha224 = e.sha224, Rr;
}
var Yo, X1;
function Nm() {
  if (X1) return Yo;
  X1 = 1;
  function e(c) {
    if (c.length >= 255)
      throw new TypeError("Alphabet too long");
    for (var l = new Uint8Array(256), w = 0; w < l.length; w++)
      l[w] = 255;
    for (var m = 0; m < c.length; m++) {
      var f = c.charAt(m), n = f.charCodeAt(0);
      if (l[n] !== 255)
        throw new TypeError(f + " is ambiguous");
      l[n] = m;
    }
    var u = c.length, o = c.charAt(0), s = Math.log(u) / Math.log(256), i = Math.log(256) / Math.log(u);
    function p(y) {
      if (y instanceof Uint8Array || (ArrayBuffer.isView(y) ? y = new Uint8Array(y.buffer, y.byteOffset, y.byteLength) : Array.isArray(y) && (y = Uint8Array.from(y))), !(y instanceof Uint8Array))
        throw new TypeError("Expected Uint8Array");
      if (y.length === 0)
        return "";
      for (var b = 0, h = 0, a = 0, E = y.length; a !== E && y[a] === 0; )
        a++, b++;
      for (var H = (E - a) * i + 1 >>> 0, j = new Uint8Array(H); a !== E; ) {
        for (var G = y[a], N = 0, T = H - 1; (G !== 0 || N < h) && T !== -1; T--, N++)
          G += 256 * j[T] >>> 0, j[T] = G % u >>> 0, G = G / u >>> 0;
        if (G !== 0)
          throw new Error("Non-zero carry");
        h = N, a++;
      }
      for (var A = H - h; A !== H && j[A] === 0; )
        A++;
      for (var q = o.repeat(b); A < H; ++A)
        q += c.charAt(j[A]);
      return q;
    }
    function g(y) {
      if (typeof y != "string")
        throw new TypeError("Expected String");
      if (y.length === 0)
        return new Uint8Array();
      for (var b = 0, h = 0, a = 0; y[b] === o; )
        h++, b++;
      for (var E = (y.length - b) * s + 1 >>> 0, H = new Uint8Array(E); y[b]; ) {
        var j = y.charCodeAt(b);
        if (j > 255)
          return;
        var G = l[j];
        if (G === 255)
          return;
        for (var N = 0, T = E - 1; (G !== 0 || N < a) && T !== -1; T--, N++)
          G += u * H[T] >>> 0, H[T] = G % 256 >>> 0, G = G / 256 >>> 0;
        if (G !== 0)
          throw new Error("Non-zero carry");
        a = N, b++;
      }
      for (var A = E - a; A !== E && H[A] === 0; )
        A++;
      for (var q = new Uint8Array(h + (E - A)), _ = h; A !== E; )
        q[_++] = H[A++];
      return q;
    }
    function S(y) {
      var b = g(y);
      if (b)
        return b;
      throw new Error("Non-base" + u + " character");
    }
    return {
      encode: p,
      decodeUnsafe: g,
      decode: S
    };
  }
  return Yo = e, Yo;
}
var Xo, G1;
function qm() {
  return G1 || (G1 = 1, Xo = Nm()("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz")), Xo;
}
var Go, J1;
function Tm() {
  if (J1) return Go;
  J1 = 1;
  var e = qm();
  return Go = function(c) {
    function l(n) {
      var u = Uint8Array.from(n), o = c(u), s = u.length + 4, i = new Uint8Array(s);
      return i.set(u, 0), i.set(o.subarray(0, 4), u.length), e.encode(i, s);
    }
    function w(n) {
      var u = n.slice(0, -4), o = n.slice(-4), s = c(u);
      if (!(o[0] ^ s[0] | o[1] ^ s[1] | o[2] ^ s[2] | o[3] ^ s[3]))
        return u;
    }
    function m(n) {
      var u = e.decodeUnsafe(n);
      if (u)
        return w(u);
    }
    function f(n) {
      var u = e.decode(n), o = w(u);
      if (!o) throw new Error("Invalid checksum");
      return o;
    }
    return {
      encode: l,
      decode: f,
      decodeUnsafe: m
    };
  }, Go;
}
var Jo, W1;
function zm() {
  if (W1) return Jo;
  W1 = 1;
  var { sha256: e } = /* @__PURE__ */ Mm(), c = Tm();
  function l(w) {
    return e(e(w));
  }
  return Jo = c(l), Jo;
}
var Bn, Z1;
function M8() {
  if (Z1) return Bn;
  Z1 = 1;
  /**
   * @license
   * https://reviews.bitcoinabc.org
   * Copyright (c) 2017-2020 Emilio Almansi
   * Copyright (c) 2023-2024 Bitcoin ABC
   * Distributed under the MIT software license, see the accompanying
   * file LICENSE or http://www.opensource.org/licenses/mit-license.php.
   */
  var e = Bn && Bn.__importDefault || function(D) {
    return D && D.__esModule ? D : { default: D };
  };
  const c = e(Am()), l = e(Om()), w = e(_m()), m = e(zm()), f = e(cl()), { validate: n, ValidationError: u } = f.default;
  function o(D, Q, W) {
    n(typeof D == "string" && g(D), "Invalid prefix: " + D + "."), n(typeof Q == "string", "Invalid type: " + Q + "."), n(W instanceof Uint8Array || typeof W == "string", "Invalid hash: " + W + ". Must be string or Uint8Array."), typeof W == "string" && (W = q(W));
    const oe = G(S(D), new Uint8Array(1)), v = b(Q) + a(W), Y = H(G(new Uint8Array([v]), W)), he = G(G(oe, Y), new Uint8Array(8)), le = G(Y, y(N(he)));
    return D + ":" + c.default.encode(le);
  }
  function s(D, Q = !1) {
    n(typeof D == "string" && A(D), "Invalid address: " + D + ".");
    const W = D.toLowerCase().split(":");
    let oe, v;
    if (W.length === 1) {
      let Ee = !1;
      for (let we = 0; we < i.length; we += 1) {
        const z = i[we], I = c.default.decode(W[0]);
        if (Ee = T(z, I), Ee) {
          oe = z, v = I;
          break;
        }
      }
      n(Ee, `Prefixless address ${D} does not have valid checksum for any valid prefix (${i.join(", ")})`);
    } else
      n(W.length === 2, "Invalid address: " + D + "."), oe = W[0], v = c.default.decode(W[1]), n(T(oe, v), "Invalid checksum: " + D + ".");
    const Y = j(v.subarray(0, -8)), he = Y[0], le = Y.subarray(1);
    n(E(he) === le.length * 8, "Invalid hash size: " + D + ".");
    const ge = h(he);
    return {
      prefix: oe,
      type: Q ? ge.toLowerCase() : ge,
      hash: Q ? _(le) : le
    };
  }
  const i = [
    "ecash",
    "bitcoincash",
    "simpleledger",
    "etoken",
    "ectest",
    "ecregtest",
    "bchtest",
    "bchreg"
  ], p = [
    "ecash",
    "bitcoincash",
    "simpleledger",
    "etoken"
  ];
  function g(D) {
    return A(D) && i.indexOf(D.toLowerCase()) !== -1;
  }
  function S(D) {
    const Q = new Uint8Array(D.length);
    for (let W = 0; W < D.length; ++W)
      Q[W] = D[W].charCodeAt(0) & 31;
    return Q;
  }
  function y(D) {
    const Q = new Uint8Array(8);
    for (let W = 0; W < 8; ++W)
      Q[7 - W] = D.and(31).toJSNumber(), D = D.shiftRight(5);
    return Q;
  }
  function b(D) {
    switch (D) {
      case "p2pkh":
      case "P2PKH":
        return 0;
      case "p2sh":
      case "P2SH":
        return 8;
      default:
        throw new u("Invalid type: " + D + ".");
    }
  }
  function h(D) {
    switch (D & 120) {
      case 0:
        return "P2PKH";
      case 8:
        return "P2SH";
      default:
        throw new u("Invalid address type in version byte: " + D + ".");
    }
  }
  function a(D) {
    switch (D.length * 8) {
      case 160:
        return 0;
      case 192:
        return 1;
      case 224:
        return 2;
      case 256:
        return 3;
      case 320:
        return 4;
      case 384:
        return 5;
      case 448:
        return 6;
      case 512:
        return 7;
      default:
        throw new u("Invalid hash size: " + D.length + ".");
    }
  }
  function E(D) {
    switch (D & 7) {
      case 0:
        return 160;
      case 1:
        return 192;
      case 2:
        return 224;
      case 3:
        return 256;
      case 4:
        return 320;
      case 5:
        return 384;
      case 6:
        return 448;
      case 7:
        return 512;
      default:
        throw new Error("Invalid input");
    }
  }
  function H(D) {
    return (0, l.default)(D, 8, 5);
  }
  function j(D) {
    return (0, l.default)(D, 5, 8, !0);
  }
  function G(D, Q) {
    const W = new Uint8Array(D.length + Q.length);
    return W.set(D), W.set(Q, D.length), W;
  }
  function N(D) {
    const Q = [
      656907472481,
      522768456162,
      1044723512260,
      748107326120,
      130178868336
    ];
    let W = (0, w.default)(1);
    for (let oe = 0; oe < D.length; ++oe) {
      const v = D[oe], Y = W.shiftRight(35);
      W = W.and(34359738367).shiftLeft(5).xor(v);
      for (let he = 0; he < Q.length; ++he)
        Y.shiftRight(he).and(1).equals(1) && (W = W.xor(Q[he]));
    }
    return W.xor(1);
  }
  function T(D, Q) {
    const W = G(S(D), new Uint8Array(1)), oe = G(W, Q);
    return N(oe).equals(0);
  }
  function A(D) {
    return D === D.toLowerCase() || D === D.toUpperCase();
  }
  function q(D) {
    const Q = new Uint8Array(D.length / 2);
    for (let W = 0; W < D.length; W += 2)
      Q[W / 2] = parseInt(D.slice(W, W + 2), 16);
    return Q;
  }
  function _(D) {
    let Q = "";
    for (let W = 0; W < D.length; W++) {
      let oe = D[W].toString(16);
      oe = oe.length === 1 ? "0" + oe : oe, Q += oe;
    }
    return Q;
  }
  function F(D) {
    const Q = "76a914", W = "88ac", oe = "a914";
    let Y, he;
    if (D.slice(0, Q.length) === Q && D.slice(-1 * W.length) === W)
      he = "p2pkh", Y = D.substring(D.indexOf(Q) + Q.length, D.lastIndexOf(W));
    else if (D.slice(0, oe.length) === oe && D.slice(-2) === "87")
      he = "p2sh", Y = D.substring(D.indexOf(oe) + oe.length, D.lastIndexOf("87"));
    else
      throw new u("Unsupported outputScript: " + D);
    if (![20, 24, 28, 32, 40, 48, 56, 64].includes(Y.length / 2))
      throw new u("Invalid hash size in outputScript: " + D);
    return { type: he, hash: Y };
  }
  function R(D, Q = "ecash") {
    const { type: W, hash: oe } = F(D);
    return o(Q, W, oe);
  }
  function L(D) {
    const { prefix: Q, type: W, hash: oe } = s(D), v = p.includes(Q);
    let Y;
    switch (W) {
      case "P2PKH":
        Y = v ? 0 : 111;
        break;
      case "P2SH":
        Y = v ? 5 : 196;
        break;
      default:
        throw new u("Unsupported address type: " + W);
    }
    const he = new Uint8Array(1 + oe.length);
    return he[0] = Y, he.set(oe, 1), m.default.encode(he);
  }
  function fe(D, Q = !1) {
    try {
      const { prefix: W } = s(D);
      return Q ? W === Q : !0;
    } catch {
      return !1;
    }
  }
  function ue(D) {
    const { type: Q, hash: W } = s(D, !0);
    let oe;
    return Q === "p2pkh" ? oe = `76a914${W}88ac` : oe = `a914${W}87`, oe;
  }
  return Bn = {
    encode: o,
    decode: s,
    uint8arrayToHexString: _,
    encodeOutputScript: R,
    getTypeAndHashFromOutputScript: F,
    toLegacy: L,
    isValidCashAddress: fe,
    getOutputScriptFromAddress: ue
  }, Bn;
}
var Cm = M8();
const Bi = /* @__PURE__ */ Nr(Cm);
var Mn = {};
/*!
 * int64.js - int64 object for javascript.
 * Copyright (c) 2017, Christopher Jeffrey (MIT License).
 * https://github.com/chjj/n64
 */
var Q1;
function ul() {
  if (Q1) return Mn;
  Q1 = 1;
  function e(b) {
    n(this instanceof e, "this", "N64"), n(b === 0 || b === 1, "sign", "bit"), this.hi = 0, this.lo = 0, this.sign = b;
  }
  e.prototype._add = function(h, a) {
    const E = this.hi, H = this.lo, j = H + a | 0, G = j >> 31, N = H >> 31, T = a >> 31, A = (N & T | ~G & (N ^ T)) & 1, q = (E + h | 0) + A;
    return this.hi = q | 0, this.lo = j, this;
  }, e.prototype.iadd = function(h) {
    return n(e.isN64(h), "operand", "int64"), this._add(h.hi, h.lo);
  }, e.prototype.iaddn = function(h) {
    return n(u(h), "operand", "number"), this._add(h >> 31 & -this.sign, h | 0);
  }, e.prototype.add = function(h) {
    return this.clone().iadd(h);
  }, e.prototype.addn = function(h) {
    return this.clone().iaddn(h);
  }, e.prototype._sub = function(h, a) {
    return h = ~h, a = ~a, a === -1 ? (a = 0, h += 1, h |= 0) : a += 1, this._add(h, a);
  }, e.prototype.isub = function(h) {
    return n(e.isN64(h), "operand", "int64"), this._sub(h.hi, h.lo);
  }, e.prototype.isubn = function(h) {
    return n(u(h), "operand", "number"), this._sub(h >> 31 & -this.sign, h | 0);
  }, e.prototype.sub = function(h) {
    return this.clone().isub(h);
  }, e.prototype.subn = function(h) {
    return this.clone().isubn(h);
  }, e.prototype._mul = function(h, a) {
    const E = this.hi, H = this.lo, j = E >>> 16, G = E & 65535, N = H >>> 16, T = H & 65535, A = h >>> 16, q = h & 65535, _ = a >>> 16, F = a & 65535;
    let R = 0, L = 0, fe = 0, ue = 0;
    ue += T * F, fe += ue >>> 16, ue &= 65535, fe += N * F, L += fe >>> 16, fe &= 65535, fe += T * _, L += fe >>> 16, fe &= 65535, L += G * F, R += L >>> 16, L &= 65535, L += N * _, R += L >>> 16, L &= 65535, L += T * q, R += L >>> 16, L &= 65535, R += j * F + G * _ + N * q + T * A, R &= 65535;
    const ae = R << 16 | L, D = fe << 16 | ue;
    return this.hi = ae, this.lo = D, this;
  }, e.prototype.imul = function(h) {
    return n(e.isN64(h), "multiplicand", "int64"), this._mul(h.hi, h.lo);
  }, e.prototype.imuln = function(h) {
    return n(u(h), "multiplicand", "number"), this._mul(h >> 31 & -this.sign, h | 0);
  }, e.prototype.mul = function(h) {
    return this.clone().imul(h);
  }, e.prototype.muln = function(h) {
    return this.clone().imuln(h);
  }, e.prototype.idiv = function(h) {
    let a = this;
    if (n(e.isN64(h), "divisor", "int64"), h.isZero())
      throw new Error("Cannot divide by zero.");
    if (a.isZero())
      return a;
    if (a.eq(h))
      return a.set(1);
    if (a.isSafe() && h.isSafe()) {
      const A = a.toDouble(), q = h.toDouble(), _ = f(A / q);
      return a.set(_);
    }
    let E = !1;
    a.sign && (a.hi < 0 ? h.hi < 0 ? (a = a.ineg(), h = h.neg()) : (a = a.ineg(), E = !0) : h.hi < 0 && (h = h.neg(), E = !0));
    const H = a.toU64(), j = h.toU64();
    if (H.lt(j))
      return a.set(0);
    if (H.ushrn(1).lt(j))
      return a.set(E ? -1 : 1);
    const G = new c(), N = new c();
    let T = H.bitLength();
    for (; T--; )
      N.ishln(1), N.lo |= H.testn(T), N.gte(j) && (N.isub(j), G.setn(T, 1));
    return a.hi = G.hi, a.lo = G.lo, E && a.ineg(), a;
  }, e.prototype.idivn = function(h) {
    return n(u(h), "divisor", "number"), this.idiv(this._small(h));
  }, e.prototype.div = function(h) {
    return this.clone().idiv(h);
  }, e.prototype.divn = function(h) {
    return this.clone().idivn(h);
  }, e.prototype.imod = function(h) {
    const a = this;
    if (n(e.isN64(h), "divisor", "int64"), h.isZero())
      throw new Error("Cannot divide by zero.");
    if (a.isZero())
      return a;
    if (a.eq(h))
      return a.set(0);
    if (a.isSafe() && h.isSafe()) {
      const E = a.toDouble(), H = h.toDouble(), j = E % H;
      return a.set(j);
    }
    return a.isub(a.div(h).imul(h));
  }, e.prototype.imodn = function(h) {
    return n(u(h), "divisor", "number"), this.imod(this._small(h));
  }, e.prototype.mod = function(h) {
    return this.clone().imod(h);
  }, e.prototype.modn = function(h) {
    return this.clone().imodn(h);
  }, e.prototype.ipow = function(h) {
    return n(e.isN64(h), "exponent", "int64"), this.ipown(h.lo);
  }, e.prototype.ipown = function(h) {
    if (n(u(h), "exponent", "number"), this.isZero())
      return this;
    const a = this.clone(), E = this;
    let H = h >>> 0;
    for (E.set(1); H > 0; )
      H & 1 && E.imul(a), H >>>= 1, a.imul(a);
    return E;
  }, e.prototype.pow = function(h) {
    return this.clone().ipow(h);
  }, e.prototype.pown = function(h) {
    return this.clone().ipown(h);
  }, e.prototype.sqr = function() {
    return this.mul(this);
  }, e.prototype.isqr = function() {
    return this.imul(this);
  }, e.prototype.iand = function(h) {
    return n(e.isN64(h), "operand", "int64"), this.hi &= h.hi, this.lo &= h.lo, this;
  }, e.prototype.iandn = function(h) {
    return n(u(h), "operand", "number"), this.hi &= h >> 31 & -this.sign, this.lo &= h | 0, this;
  }, e.prototype.and = function(h) {
    return this.clone().iand(h);
  }, e.prototype.andn = function(h) {
    return this.clone().iandn(h);
  }, e.prototype.ior = function(h) {
    return n(e.isN64(h), "operand", "int64"), this.hi |= h.hi, this.lo |= h.lo, this;
  }, e.prototype.iorn = function(h) {
    return n(u(h), "operand", "number"), this.hi |= h >> 31 & -this.sign, this.lo |= h | 0, this;
  }, e.prototype.or = function(h) {
    return this.clone().ior(h);
  }, e.prototype.orn = function(h) {
    return this.clone().iorn(h);
  }, e.prototype.ixor = function(h) {
    return n(e.isN64(h), "operand", "int64"), this.hi ^= h.hi, this.lo ^= h.lo, this;
  }, e.prototype.ixorn = function(h) {
    return n(u(h), "operand", "number"), this.hi ^= h >> 31 & -this.sign, this.lo ^= h | 0, this;
  }, e.prototype.xor = function(h) {
    return this.clone().ixor(h);
  }, e.prototype.xorn = function(h) {
    return this.clone().ixorn(h);
  }, e.prototype.inot = function() {
    return this.hi = ~this.hi, this.lo = ~this.lo, this;
  }, e.prototype.not = function() {
    return this.clone().inot();
  }, e.prototype.ishl = function(h) {
    return n(e.isN64(h), "bits", "int64"), this.ishln(h.lo);
  }, e.prototype.ishln = function(h) {
    if (n(u(h), "bits", "number"), h &= 63, h === 0)
      return this;
    let a = this.hi, E = this.lo;
    return h < 32 ? (a <<= h, a |= E >>> 32 - h, E <<= h) : (a = E << h - 32, E = 0), this.hi = a, this.lo = E, this;
  }, e.prototype.shl = function(h) {
    return this.clone().ishl(h);
  }, e.prototype.shln = function(h) {
    return this.clone().ishln(h);
  }, e.prototype.ishr = function(h) {
    return n(e.isN64(h), "bits", "int64"), this.ishrn(h.lo);
  }, e.prototype.ishrn = function(h) {
    if (!this.sign)
      return this.iushrn(h);
    if (n(u(h), "bits", "number"), h &= 63, h === 0)
      return this;
    let a = this.hi, E = this.lo;
    return h < 32 ? (E >>>= h, E |= a << 32 - h, a >>= h) : (E = a >> h - 32, a = a >> 31), this.hi = a, this.lo = E, this;
  }, e.prototype.shr = function(h) {
    return this.clone().ishr(h);
  }, e.prototype.shrn = function(h) {
    return this.clone().ishrn(h);
  }, e.prototype.iushr = function(h) {
    return n(e.isN64(h), "bits", "int64"), this.iushrn(h.lo);
  }, e.prototype.iushrn = function(h) {
    if (n(u(h), "bits", "number"), h &= 63, h === 0)
      return this;
    let a = this.hi, E = this.lo;
    return h < 32 ? (E >>>= h, E |= a << 32 - h, a >>>= h) : (E = a >>> h - 32, a = 0), this.hi = a | 0, this.lo = E | 0, this;
  }, e.prototype.ushr = function(h) {
    return this.clone().iushr(h);
  }, e.prototype.ushrn = function(h) {
    return this.clone().iushrn(h);
  }, e.prototype.setn = function(h, a) {
    return n(u(h), "bit", "number"), h &= 63, h < 32 ? a ? this.lo |= 1 << h : this.lo &= ~(1 << h) : a ? this.hi |= 1 << h - 32 : this.hi &= ~(1 << h - 32), this;
  }, e.prototype.testn = function(h) {
    return n(u(h), "bit", "number"), h &= 63, h < 32 ? this.lo >>> h & 1 : this.hi >>> h - 32 & 1;
  }, e.prototype.setb = function(h, a) {
    return n(u(h), "pos", "number"), n(u(a), "ch", "number"), h &= 7, a &= 255, h < 4 ? (this.lo &= ~(255 << h * 8), this.lo |= a << h * 8) : (this.hi &= ~(255 << (h - 4) * 8), this.hi |= a << (h - 4) * 8), this;
  }, e.prototype.orb = function(h, a) {
    return n(u(h), "pos", "number"), n(u(a), "ch", "number"), h &= 7, a &= 255, h < 4 ? this.lo |= a << h * 8 : this.hi |= a << (h - 4) * 8, this;
  }, e.prototype.getb = function(h) {
    return n(u(h), "pos", "number"), h &= 7, h < 4 ? this.lo >> h * 8 & 255 : this.hi >> (h - 4) * 8 & 255;
  }, e.prototype.imaskn = function(h) {
    return n(u(h), "bit", "number"), h &= 63, h < 32 ? (this.hi = 0, this.lo &= (1 << h) - 1) : (this.hi &= (1 << h - 32) - 1, this.lo &= 4294967295), this;
  }, e.prototype.maskn = function(h) {
    return this.clone().imaskn(h);
  }, e.prototype.andln = function(h) {
    return n(u(h), "operand", "number"), this.lo & h;
  }, e.prototype.ineg = function() {
    let h = ~this.hi, a = ~this.lo;
    return a === -1 ? (a = 0, h += 1, h |= 0) : a += 1, this.hi = h, this.lo = a, this;
  }, e.prototype.neg = function() {
    return this.clone().ineg();
  }, e.prototype.iabs = function() {
    return this.isNeg() && this.ineg(), this;
  }, e.prototype.abs = function() {
    return this.clone().iabs();
  }, e.prototype._cmp = function(h, a) {
    const E = this;
    let H = E.hi, j = E.lo;
    if (H === h && j === a)
      return 0;
    let G = !1;
    if (E.sign) {
      const N = H < 0, T = h < 0;
      if (N && !T)
        return -1;
      if (!N && T)
        return 1;
      G = N;
    }
    return G || (H >>>= 0, h >>>= 0), H < h ? -1 : H > h ? 1 : (j >>>= 0, a >>>= 0, j < a ? -1 : 1);
  }, e.prototype.cmp = function(h) {
    return n(e.isN64(h), "value", "int64"), this._cmp(h.hi, h.lo);
  }, e.prototype.cmpn = function(h) {
    return n(u(h), "value", "number"), this._cmp(h >> 31 & -this.sign, h | 0);
  }, e.prototype.eq = function(h) {
    return n(e.isN64(h), "value", "int64"), this.hi === h.hi && this.lo === h.lo;
  }, e.prototype.eqn = function(h) {
    return n(u(h), "value", "number"), this.hi === (h >> 31 & -this.sign) && this.lo === (h | 0);
  }, e.prototype.gt = function(h) {
    return this.cmp(h) > 0;
  }, e.prototype.gtn = function(h) {
    return this.cmpn(h) > 0;
  }, e.prototype.gte = function(h) {
    return this.cmp(h) >= 0;
  }, e.prototype.gten = function(h) {
    return this.cmpn(h) >= 0;
  }, e.prototype.lt = function(h) {
    return this.cmp(h) < 0;
  }, e.prototype.ltn = function(h) {
    return this.cmpn(h) < 0;
  }, e.prototype.lte = function(h) {
    return this.cmp(h) <= 0;
  }, e.prototype.lten = function(h) {
    return this.cmpn(h) <= 0;
  }, e.prototype.isZero = function() {
    return this.hi === 0 && this.lo === 0;
  }, e.prototype.isNeg = function() {
    return this.sign === 1 && this.hi < 0;
  }, e.prototype.isOdd = function() {
    return (this.lo & 1) === 1;
  }, e.prototype.isEven = function() {
    return (this.lo & 1) === 0;
  }, e.prototype.clone = function() {
    const h = new this.constructor();
    return h.hi = this.hi, h.lo = this.lo, h;
  }, e.prototype.inject = function(h) {
    return n(e.isN64(h), "value", "int64"), this.hi = h.hi, this.lo = h.lo, this;
  }, e.prototype.set = function(h) {
    n(s(h), "number", "integer");
    let a = !1;
    return h < 0 && (h = -h, a = !0), this.hi = h * (1 / 4294967296) | 0, this.lo = h | 0, a && this.ineg(), this;
  }, e.prototype.join = function(h, a) {
    return n(u(h), "hi", "number"), n(u(a), "lo", "number"), this.hi = h | 0, this.lo = a | 0, this;
  }, e.prototype._small = function(h) {
    const a = new this.constructor();
    return a.hi = h >> 31 & -this.sign, a.lo = h | 0, a;
  }, e.prototype.bitLength = function() {
    let h = this;
    return this.isNeg() && (h = this.neg()), h.hi === 0 ? m(h.lo) : m(h.hi) + 32;
  }, e.prototype.byteLength = function() {
    return Math.ceil(this.bitLength() / 8);
  }, e.prototype.isSafe = function() {
    let h = this.hi;
    return this.isNeg() && (h = ~h, this.lo === 0 && (h += 1)), (h & 4292870144) === 0;
  }, e.prototype.inspect = function() {
    let h = "I64";
    return this.sign || (h = "U64"), `<${h}: ${this.toString(10)}>`;
  }, e.prototype.readLE = function(h, a) {
    return n(h && typeof h.length == "number", "data", "arraylike"), n(a >> 0 === a, "offset", "integer"), n(a + 8 <= h.length, "offset", "valid offset"), this.lo = p(h, a), this.hi = p(h, a + 4), a + 8;
  }, e.prototype.readBE = function(h, a) {
    return n(h && typeof h.length == "number", "data", "arraylike"), n(a >> 0 === a, "offset", "integer"), n(a + 8 <= h.length, "offset", "valid offset"), this.hi = g(h, a), this.lo = g(h, a + 4), a + 8;
  }, e.prototype.readRaw = function(h, a) {
    return this.readLE(h, a);
  }, e.prototype.writeLE = function(h, a) {
    return n(h && typeof h.length == "number", "data", "arraylike"), n(a >> 0 === a, "offset", "integer"), n(a + 8 <= h.length, "offset", "valid offset"), S(h, this.lo, a), S(h, this.hi, a + 4), a + 8;
  }, e.prototype.writeBE = function(h, a) {
    return n(h && typeof h.length == "number", "data", "arraylike"), n(a >> 0 === a, "offset", "integer"), n(a + 8 <= h.length, "offset", "valid offset"), y(h, this.hi, a), y(h, this.lo, a + 4), a + 8;
  }, e.prototype.writeRaw = function(h, a) {
    return this.writeLE(h, a);
  }, e.prototype.toU64 = function() {
    const h = new c();
    return h.hi = this.hi, h.lo = this.lo, h;
  }, e.prototype.toI64 = function() {
    const h = new l();
    return h.hi = this.hi, h.lo = this.lo, h;
  }, e.prototype.toNumber = function() {
    if (!this.isSafe())
      throw new Error("Number exceeds 53 bits.");
    return this.toDouble();
  }, e.prototype.toDouble = function() {
    let h = this.hi;
    return this.sign || (h >>>= 0), h * 4294967296 + (this.lo >>> 0);
  }, e.prototype.toInt = function() {
    return this.sign ? this.lo : this.lo >>> 0;
  }, e.prototype.toBool = function() {
    return !this.isZero();
  }, e.prototype.toBits = function() {
    return [this.hi, this.lo];
  }, e.prototype.toObject = function() {
    return { hi: this.hi, lo: this.lo };
  }, e.prototype.toString = function(h, a) {
    if (h = w(h), a == null && (a = 0), n(h >>> 0 === h, "base", "integer"), n(a >>> 0 === a, "pad", "integer"), h < 2 || h > 16)
      throw new Error("Base ranges between 2 and 16.");
    if (a > 64)
      throw new Error("Maximum padding is 64 characters.");
    let E = this, H = !1;
    E.isNeg() && (E = E.neg(), H = !0);
    let j = E.hi >>> 0, G = E.lo >>> 0, N = "";
    do {
      const T = j % h;
      j -= T, j /= h, G += T * 4294967296;
      const A = G % h;
      G -= A, G /= h;
      let q = A;
      q < 10 ? q += 48 : q += 87, N = String.fromCharCode(q) + N;
    } while (G > 0 || j > 0);
    for (; N.length < a; )
      N = "0" + N;
    return H && (N = "-" + N), N;
  }, e.prototype.toJSON = function() {
    return this.toString(16, 16);
  }, e.prototype.toBN = function(h) {
    const a = this.isNeg();
    let E = this.hi, H = this.lo;
    a && (E = ~E, H = ~H, H === -1 ? (H = 0, E += 1, E |= 0) : H += 1), E >>>= 0, H >>>= 0;
    const j = new h(E);
    return j.ishln(32), j.iadd(new h(H)), a && j.ineg(), j;
  }, e.prototype.toLE = function(h) {
    n(typeof h == "function", "ArrayLike", "constructor");
    const a = i(h, 8);
    return this.writeLE(a, 0), a;
  }, e.prototype.toBE = function(h) {
    n(typeof h == "function", "ArrayLike", "constructor");
    const a = i(h, 8);
    return this.writeBE(a, 0), a;
  }, e.prototype.toRaw = function(h) {
    return this.toLE(h);
  }, e.prototype.fromNumber = function(h) {
    return this.set(h);
  }, e.prototype.fromInt = function(h) {
    return n(u(h), "integer", "number"), this.join(h >> 31 & -this.sign, h);
  }, e.prototype.fromBool = function(h) {
    return n(typeof h == "boolean", "value", "boolean"), this.hi = 0, this.lo = h ? 1 : 0, this;
  }, e.prototype.fromBits = function(h, a) {
    return this.join(h, a);
  }, e.prototype.fromObject = function(h) {
    return n(h && typeof h == "object", "number", "object"), this.fromBits(h.hi, h.lo);
  }, e.prototype.fromString = function(h, a) {
    if (a = w(a), n(typeof h == "string", "string", "string"), n(a >>> 0 === a, "base", "integer"), a < 2 || a > 16)
      throw new Error("Base ranges between 2 and 16.");
    let E = !1, H = 0;
    if (h.length > 0 && h[0] === "-" && (H += 1, E = !0), h.length === H || h.length > H + 64)
      throw new Error("Invalid string (bad length).");
    let j = 0, G = 0;
    for (; H < h.length; H++) {
      let N = h.charCodeAt(H);
      if (N >= 48 && N <= 57 ? N -= 48 : N >= 65 && N <= 90 ? N -= 55 : N >= 97 && N <= 122 ? N -= 87 : N = a, N >= a)
        throw new Error("Invalid string (parse error).");
      if (G *= a, G += N, j *= a, G > 4294967295 && (N = G % 4294967296, j += (G - N) / 4294967296, G = N), j > 4294967295)
        throw new Error("Invalid string (overflow).");
    }
    return this.hi = j | 0, this.lo = G | 0, E && this.ineg(), this;
  }, e.prototype.fromJSON = function(h) {
    return this.fromString(h, 16);
  }, e.prototype.fromBN = function(h) {
    n(h && o(h.words), "number", "big number");
    const a = this, E = h.clone(), H = E.isNeg();
    if (a.sign && E.testn(63))
      throw new Error("Big number overflow.");
    let j = 0;
    for (; !E.isZero(); ) {
      if (j === 8)
        throw new Error("Big number overflow.");
      a.orb(j, E.andln(255)), E.iushrn(8), j++;
    }
    return H && a.ineg(), a;
  }, e.prototype.fromLE = function(h) {
    return this.readLE(h, 0), this;
  }, e.prototype.fromBE = function(h) {
    return this.readBE(h, 0), this;
  }, e.prototype.fromRaw = function(h) {
    return this.fromLE(h);
  }, e.prototype.from = function(h, a) {
    if (h == null)
      return this;
    if (typeof h == "number")
      return typeof a == "number" ? this.fromBits(h, a) : this.fromNumber(h);
    if (typeof h == "string")
      return this.fromString(h, a);
    if (typeof h == "object")
      return o(h.words) ? this.fromBN(h) : typeof h.length == "number" ? this.fromRaw(h) : this.fromObject(h);
    if (typeof h == "boolean")
      return this.fromBool(h);
    throw new TypeError("Non-numeric object passed to N64.");
  }, e.min = function(h, a) {
    return h.cmp(a) < 0 ? h : a;
  }, e.max = function(h, a) {
    return h.cmp(a) > 0 ? h : a;
  }, e.random = function() {
    const h = new this();
    return h.hi = Math.random() * 4294967296 | 0, h.lo = Math.random() * 4294967296 | 0, h;
  }, e.pow = function(h, a) {
    return new this().fromInt(h).ipown(a);
  }, e.shift = function(h, a) {
    return new this().fromInt(h).ishln(a);
  }, e.readLE = function(h, a) {
    const E = new this();
    return E.readLE(h, a), E;
  }, e.readBE = function(h, a) {
    const E = new this();
    return E.readBE(h, a), E;
  }, e.readRaw = function(h, a) {
    const E = new this();
    return E.readRaw(h, a), E;
  }, e.fromNumber = function(h) {
    return new this().fromNumber(h);
  }, e.fromInt = function(h) {
    return new this().fromInt(h);
  }, e.fromBool = function(h) {
    return new this().fromBool(h);
  }, e.fromBits = function(h, a) {
    return new this().fromBits(h, a);
  }, e.fromObject = function(h) {
    return new this().fromObject(h);
  }, e.fromString = function(h, a) {
    return new this().fromString(h, a);
  }, e.fromJSON = function(h) {
    return new this().fromJSON(h);
  }, e.fromBN = function(h) {
    return new this().fromBN(h);
  }, e.fromLE = function(h) {
    return new this().fromLE(h);
  }, e.fromBE = function(h) {
    return new this().fromBE(h);
  }, e.fromRaw = function(h) {
    return new this().fromRaw(h);
  }, e.from = function(h, a) {
    return new this().from(h, a);
  }, e.isN64 = function(h) {
    return h instanceof e;
  }, e.isU64 = function(h) {
    return h instanceof c;
  }, e.isI64 = function(h) {
    return h instanceof l;
  };
  function c(b, h) {
    if (!(this instanceof c))
      return new c(b, h);
    e.call(this, 0), this.from(b, h);
  }
  c.__proto__ = e, c.prototype.__proto__ = e.prototype, c.ULONG_MIN = 0, c.ULONG_MAX = 4294967295, c.UINT32_MIN = c(0, 0), c.UINT32_MAX = c(0, 4294967295), c.UINT64_MIN = c(0, 0), c.UINT64_MAX = c(4294967295, 4294967295);
  function l(b, h) {
    if (!(this instanceof l))
      return new l(b, h);
    e.call(this, 1), this.from(b, h);
  }
  l.__proto__ = e, l.prototype.__proto__ = e.prototype, l.LONG_MIN = -2147483648, l.LONG_MAX = 2147483647, l.INT32_MIN = l(4294967295, 2147483648), l.INT32_MAX = l(0, 2147483647), l.INT64_MIN = l(2147483648, 0), l.INT64_MAX = l(2147483647, 4294967295);
  function w(b) {
    if (b == null)
      return 10;
    if (typeof b == "number")
      return b;
    switch (b) {
      case "bin":
        return 2;
      case "oct":
        return 8;
      case "dec":
        return 10;
      case "hex":
        return 16;
    }
    return 0;
  }
  function m(b) {
    if (Math.clz32)
      return 32 - Math.clz32(b);
    let h = 31;
    for (; h >= 0 && (b & 1 << h) === 0; h--)
      ;
    return h + 1;
  }
  function f(b) {
    return b < 0 ? -Math.floor(-b) : Math.floor(b);
  }
  function n(b, h, a) {
    if (!b) {
      const E = new TypeError(`'${h}' must be a(n) ${a}.`);
      throw Error.captureStackTrace && Error.captureStackTrace(E, n), E;
    }
  }
  function u(b) {
    return typeof b == "number" && isFinite(b);
  }
  function o(b) {
    return Array.isArray ? Array.isArray(b) : {}.toString.call(b).slice(8, -1) === "Array";
  }
  function s(b) {
    return Number.isSafeInteger ? Number.isSafeInteger(b) : u(b) && Math.floor(b) === b && b >= -9007199254740991 && b <= 9007199254740991;
  }
  function i(b, h) {
    return b.allocUnsafe ? b.allocUnsafe(h) : new b(h);
  }
  function p(b, h) {
    return b[h] | b[h + 1] << 8 | b[h + 2] << 16 | b[h + 3] << 24;
  }
  function g(b, h) {
    return b[h] << 24 | b[h + 1] << 16 | b[h + 2] << 8 | b[h + 3];
  }
  function S(b, h, a) {
    b[a] = h & 255, b[a + 1] = h >>> 8 & 255, b[a + 2] = h >>> 16 & 255, b[a + 3] = h >>> 24 & 255;
  }
  function y(b, h, a) {
    b[a] = h >>> 24 & 255, b[a + 1] = h >>> 16 & 255, b[a + 2] = h >>> 8 & 255, b[a + 3] = h & 255;
  }
  return Mn.N64 = e, Mn.U64 = c, Mn.I64 = l, Mn;
}
var N8 = ul();
const q8 = /* @__PURE__ */ Nr(N8);
var bs = {}, Wo = {}, ed;
function Dm() {
  return ed || (ed = 1, Wo.custom = "inspect"), Wo;
}
var td;
function $r() {
  if (td) return bs;
  td = 1;
  const { custom: e } = Dm();
  class c {
    /**
     * @constructor
     * @param {Iterable<[BufferLike, V]>} [iterable]
     */
    constructor(p) {
      if (this.map = /* @__PURE__ */ new Map(), p != null)
        for (const [g, S] of p)
          this.set(g, S);
    }
    get size() {
      return this.map.size;
    }
    /**
     * @param {BufferLike} key
     * @returns {V?}
     */
    get(p) {
      const g = this.map.get(o(p));
      if (g)
        return g.value;
    }
    /**
     * @param {BufferLike} key
     * @returns {Boolean}
     */
    has(p) {
      return this.map.has(o(p));
    }
    /**
     * @param {BufferLike} key
     * @param {V} value
     * @returns {BufferMap<V>}
     */
    set(p, g) {
      return this.map.set(o(p), new w(p, g)), this;
    }
    /**
     * @param {BufferLike} key
     * @returns {Boolean}
     */
    delete(p) {
      return this.map.delete(o(p));
    }
    clear() {
      this.map.clear();
    }
    [Symbol.iterator]() {
      return this.entries();
    }
    *entries() {
      for (const { key: p, value: g } of this.map.values())
        yield [p, g];
    }
    *keys() {
      for (const { key: p } of this.map.values())
        yield p;
    }
    *values() {
      for (const { value: p } of this.map.values())
        yield p;
    }
    forEach(p, g) {
      if (typeof p != "function")
        throw new TypeError(`${typeof p} is not a function`);
      for (const { key: S, value: y } of this.map.values())
        p.call(g, y, S, this);
    }
    toKeys() {
      const p = [];
      for (const { key: g } of this.map.values())
        p.push(g);
      return p;
    }
    toValues() {
      const p = [];
      for (const { value: g } of this.map.values())
        p.push(g);
      return p;
    }
    toArray() {
      return this.toValues();
    }
    [e]() {
      const p = /* @__PURE__ */ new Map();
      for (const { key: g, value: S } of this.map.values())
        p.set(s(g), S);
      return p;
    }
  }
  class l {
    /**
     * @constructor
     * @param {Iterable<BufferLike>} [iterable]
     */
    constructor(p) {
      if (this.map = /* @__PURE__ */ new Map(), p != null)
        for (const g of p)
          this.add(g);
    }
    get size() {
      return this.map.size;
    }
    /**
     * @param {BufferLike} key
     * @returns {Boolean}
     */
    has(p) {
      return this.map.has(o(p));
    }
    /**
     * @param {BufferLike} key
     * @returns {BufferSet}
     */
    add(p) {
      return this.map.set(o(p), p), this;
    }
    /**
     * @param {BufferLike} key
     * @returns {Boolean}
     */
    delete(p) {
      return this.map.delete(o(p));
    }
    clear() {
      this.map.clear();
    }
    [Symbol.iterator]() {
      return this.keys();
    }
    *entries() {
      for (const p of this.map.values())
        yield [p, p];
    }
    keys() {
      return this.map.values();
    }
    values() {
      return this.map.values();
    }
    forEach(p, g) {
      if (typeof p != "function")
        throw new TypeError(`${typeof p} is not a function`);
      for (const S of this.map.values())
        p.call(g, S, S, this);
    }
    toKeys() {
      const p = [];
      for (const g of this.map.values())
        p.push(g);
      return p;
    }
    toValues() {
      return this.toKeys();
    }
    toArray() {
      return this.toKeys();
    }
    [e]() {
      const p = /* @__PURE__ */ new Set();
      for (const g of this.map.values())
        p.add(s(g));
      return p;
    }
  }
  class w {
    /**
     * @param {BufferLike} key
     * @param {V} value
     */
    constructor(p, g) {
      this.key = p, this.value = g;
    }
  }
  const m = typeof SharedArrayBuffer == "function";
  function f(i) {
    return !!(i instanceof ArrayBuffer || m && i instanceof SharedArrayBuffer);
  }
  function n(i) {
    if (ArrayBuffer.isView(i))
      return k.from(i.buffer, i.byteOffset, i.byteLength);
    if (f(i))
      return k.from(i, 0, i.byteLength);
    throw new TypeError("Non-buffer passed to buffer map/set.");
  }
  function u(i, p) {
    return k.isBuffer(i) || (i = n(i)), i.toString(p);
  }
  function o(i) {
    return u(i, "binary");
  }
  function s(i) {
    return u(i, "hex");
  }
  return bs.BufferMap = c, bs.BufferSet = l, bs;
}
var Um = $r();
const xn = /* @__PURE__ */ Nr(Um);
/*!
 * lru.js - LRU cache for bcoin
 * Copyright (c) 2014-2018, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var Zo, rd;
function Fm() {
  if (rd) return Zo;
  rd = 1;
  const e = Xe();
  class c {
    /**
     * Create an LRU cache.
     * @constructor
     * @param {Number} capacity
     * @param {Function?} getSize
     * @param {Function?} CustomMap
     */
    constructor(n, u, o) {
      e(typeof n == "number", "Capacity must be a number."), e(n >= 0, "Capacity cannot be negative."), e(!u || typeof u == "function", "Bad size callback."), e(!o || typeof o == "function"), this.map = o ? new o() : /* @__PURE__ */ new Map(), this.size = 0, this.items = 0, this.head = null, this.tail = null, this.pending = null, this.capacity = n, this.getSize = u;
    }
    /**
     * Calculate size of an item.
     * @private
     * @param {LRUItem} item
     * @returns {Number} Size.
     */
    _getSize(n) {
      return this.getSize ? 120 + this.getSize(n.value, n.key) : 1;
    }
    /**
     * Compact the LRU linked list.
     * @private
     */
    _compact() {
      if (this.size <= this.capacity)
        return;
      let n = null, u = null;
      for (n = this.head; n && !(this.size <= this.capacity); n = u)
        this.size -= this._getSize(n), this.items -= 1, this.map.delete(n.key), u = n.next, n.prev = null, n.next = null;
      if (!n) {
        this.head = null, this.tail = null;
        return;
      }
      this.head = n, n.prev = null;
    }
    /**
     * Reset the cache. Clear all items.
     */
    reset() {
      let n, u;
      for (n = this.head; n; n = u)
        this.map.delete(n.key), this.items -= 1, u = n.next, n.prev = null, n.next = null;
      e(!n), this.size = 0, this.head = null, this.tail = null;
    }
    /**
     * Add an item to the cache.
     * @param {String|Number} key
     * @param {Object} value
     */
    set(n, u) {
      if (this.capacity === 0)
        return;
      let o = this.map.get(n);
      if (o) {
        this.size -= this._getSize(o), o.value = u, this.size += this._getSize(o), this._removeList(o), this._appendList(o), this._compact();
        return;
      }
      o = new l(n, u), this.map.set(n, o), this._appendList(o), this.size += this._getSize(o), this.items += 1, this._compact();
    }
    /**
     * Retrieve an item from the cache.
     * @param {String|Number} key
     * @returns {Object} Item.
     */
    get(n) {
      if (this.capacity === 0)
        return null;
      const u = this.map.get(n);
      return u ? (this._removeList(u), this._appendList(u), u.value) : null;
    }
    /**
     * Test whether the cache contains a key.
     * @param {String|Number} key
     * @returns {Boolean}
     */
    has(n) {
      return this.capacity === 0 ? !1 : this.map.has(n);
    }
    /**
     * Remove an item from the cache.
     * @param {String|Number} key
     * @returns {Boolean} Whether an item was removed.
     */
    remove(n) {
      if (this.capacity === 0)
        return !1;
      const u = this.map.get(n);
      return u ? (this.size -= this._getSize(u), this.items -= 1, this.map.delete(n), this._removeList(u), !0) : !1;
    }
    /**
     * Prepend an item to the linked list (sets new head).
     * @private
     * @param {LRUItem}
     */
    _prependList(n) {
      this._insertList(null, n);
    }
    /**
     * Append an item to the linked list (sets new tail).
     * @private
     * @param {LRUItem}
     */
    _appendList(n) {
      this._insertList(this.tail, n);
    }
    /**
     * Insert item into the linked list.
     * @private
     * @param {LRUItem|null} ref
     * @param {LRUItem} item
     */
    _insertList(n, u) {
      if (e(!u.next), e(!u.prev), n == null) {
        this.head ? (this.head.prev = u, u.next = this.head, this.head = u) : (this.head = u, this.tail = u);
        return;
      }
      u.next = n.next, u.prev = n, n.next = u, u.next && (u.next.prev = u), n === this.tail && (this.tail = u);
    }
    /**
     * Remove item from the linked list.
     * @private
     * @param {LRUItem}
     */
    _removeList(n) {
      n.prev && (n.prev.next = n.next), n.next && (n.next.prev = n.prev), n === this.head && (this.head = n.next), n === this.tail && (this.tail = n.prev || this.head), this.head || e(!this.tail), this.tail || e(!this.head), n.prev = null, n.next = null;
    }
    /**
     * Collect all keys in the cache, sorted by LRU.
     * @returns {String[]}
     */
    keys() {
      const n = [];
      for (let u = this.head; u; u = u.next)
        u === this.head && e(!u.prev), u.prev || e(u === this.head), u.next || e(u === this.tail), n.push(u.key);
      return n;
    }
    /**
     * Collect all values in the cache, sorted by LRU.
     * @returns {String[]}
     */
    values() {
      const n = [];
      for (let u = this.head; u; u = u.next)
        n.push(u.value);
      return n;
    }
    /**
     * Convert the LRU cache to an array of items.
     * @returns {Object[]}
     */
    toArray() {
      const n = [];
      for (let u = this.head; u; u = u.next)
        n.push(u);
      return n;
    }
    /**
     * Create an atomic batch for the lru
     * (used for caching database writes).
     * @returns {LRUBatch}
     */
    batch() {
      return new w(this);
    }
    /**
     * Start the pending batch.
     */
    start() {
      e(!this.pending), this.pending = this.batch();
    }
    /**
     * Clear the pending batch.
     */
    clear() {
      e(this.pending), this.pending.clear();
    }
    /**
     * Drop the pending batch.
     */
    drop() {
      e(this.pending), this.pending = null;
    }
    /**
     * Commit the pending batch.
     */
    commit() {
      e(this.pending), this.pending.commit(), this.pending = null;
    }
    /**
     * Push an item onto the pending batch.
     * @param {String} key
     * @param {Object} value
     */
    push(n, u) {
      e(this.pending), this.capacity !== 0 && this.pending.set(n, u);
    }
    /**
     * Push a removal onto the pending batch.
     * @param {String} key
     */
    unpush(n) {
      e(this.pending), this.capacity !== 0 && this.pending.remove(n);
    }
  }
  class l {
    /**
     * Create an LRU item.
     * @constructor
     * @private
     * @param {String} key
     * @param {Object} value
     */
    constructor(n, u) {
      this.key = n, this.value = u, this.next = null, this.prev = null;
    }
  }
  class w {
    /**
     * Create an LRU batch.
     * @constructor
     * @param {LRU} lru
     */
    constructor(n) {
      this.lru = n, this.ops = [];
    }
    /**
     * Push an item onto the batch.
     * @param {String} key
     * @param {Object} value
     */
    set(n, u) {
      this.ops.push(new m(!1, n, u));
    }
    /**
     * Push a removal onto the batch.
     * @param {String} key
     */
    remove(n) {
      this.ops.push(new m(!0, n, null));
    }
    /**
     * Clear the batch.
     */
    clear() {
      this.ops.length = 0;
    }
    /**
     * Commit the batch.
     */
    commit() {
      for (const n of this.ops) {
        if (n.remove) {
          this.lru.remove(n.key);
          continue;
        }
        this.lru.set(n.key, n.value);
      }
      this.ops.length = 0;
    }
  }
  class m {
    /**
     * Create an LRU op.
     * @constructor
     * @param {Boolean} remove
     * @param {String} key
     * @param {Object} value
     */
    constructor(n, u, o) {
      this.remove = n, this.key = u, this.value = o;
    }
  }
  return Zo = c, Zo;
}
var Qo, id;
function T8() {
  return id || (id = 1, Qo = Fm()), Qo;
}
var Hm = T8();
const Lm = /* @__PURE__ */ Nr(Hm);
var Km = $s();
const Vm = /* @__PURE__ */ Nr(Km);
var $m = js();
const jm = /* @__PURE__ */ Nr($m);
var dn = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof Ds < "u" ? Ds : typeof self < "u" ? self : {};
function Ym(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function hl(e) {
  if (Object.prototype.hasOwnProperty.call(e, "__esModule")) return e;
  var c = e.default;
  if (typeof c == "function") {
    var l = function w() {
      return this instanceof w ? Reflect.construct(c, arguments, this.constructor) : c.apply(this, arguments);
    };
    l.prototype = c.prototype;
  } else l = {};
  return Object.defineProperty(l, "__esModule", { value: !0 }), Object.keys(e).forEach(function(w) {
    var m = Object.getOwnPropertyDescriptor(e, w);
    Object.defineProperty(l, w, m.get ? m : {
      enumerable: !0,
      get: function() {
        return e[w];
      }
    });
  }), l;
}
var ps = { exports: {} }, ms = {}, ea = {};
/*!
 * fixed.js - fixed number parsing
 * Copyright (c) 2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var nd;
function z8() {
  return nd || (nd = 1, function(e) {
    const c = dt;
    e.encode = function(n, u) {
      c(Number.isSafeInteger(n), "Invalid integer value.");
      let o = "";
      n < 0 && (n = -n, o = "-");
      const s = l(u);
      let i = n % s, p = (n - i) / s;
      for (i = i.toString(10), p = p.toString(10); i.length < u; )
        i = "0" + i;
      return i = i.replace(/0+$/, ""), c(i.length <= u, "Invalid integer value."), i.length === 0 && (i = "0"), u === 0 ? `${o}${p}` : `${o}${p}.${i}`;
    }, e.decode = function(n, u) {
      c(typeof n == "string"), c(n.length <= 32, "Fixed number string too large.");
      let o = 1;
      n.length > 0 && n[0] === "-" && (n = n.substring(1), o = -1);
      let s = n, i = "0";
      const p = n.indexOf(".");
      for (p !== -1 && (s = n.substring(0, p), i = n.substring(p + 1)), s = s.replace(/^0+/, ""), i = i.replace(/0+$/, ""), c(
        s.length <= 16 - u,
        "Fixed number string exceeds 2^53-1."
      ), c(
        i.length <= u,
        "Too many decimal places in fixed number string."
      ), s.length === 0 && (s = "0"); i.length < u; )
        i += "0";
      i.length === 0 && (i = "0"), c(
        /^\d+$/.test(s) && /^\d+$/.test(i),
        "Non-numeric characters in fixed number string."
      ), s = parseInt(s, 10), i = parseInt(i, 10);
      const g = l(u), S = w(g), y = m(g);
      return c(
        s < y || s === y && i <= S,
        "Fixed number string exceeds 2^53-1."
      ), o * (s * g + i);
    }, e.toFloat = function(n, u) {
      return parseFloat(e.encode(n, u));
    }, e.fromFloat = function(n, u) {
      return c(typeof n == "number" && isFinite(n)), c(Number.isSafeInteger(u)), e.decode(n.toFixed(u), u);
    };
    function l(f) {
      switch (f) {
        case 0:
          return 1;
        case 1:
          return 10;
        case 2:
          return 100;
        case 3:
          return 1e3;
        case 4:
          return 1e4;
        case 5:
          return 1e5;
        case 6:
          return 1e6;
        case 7:
          return 1e7;
        case 8:
          return 1e8;
      }
      throw new Error("Exponent is too large.");
    }
    function w(f) {
      switch (f) {
        case 1:
          return 0;
        case 10:
          return 1;
        case 100:
          return 91;
        case 1e3:
          return 991;
        case 1e4:
          return 991;
        case 1e5:
          return 40991;
        case 1e6:
          return 740991;
        case 1e7:
          return 4740991;
        case 1e8:
          return 54740991;
      }
      throw new Error("Exponent is too large.");
    }
    function m(f) {
      switch (f) {
        case 1:
          return 9007199254740991;
        case 10:
          return 900719925474099;
        case 100:
          return 90071992547409;
        case 1e3:
          return 9007199254740;
        case 1e4:
          return 900719925474;
        case 1e5:
          return 90071992547;
        case 1e6:
          return 9007199254;
        case 1e7:
          return 900719925;
        case 1e8:
          return 90071992;
      }
      throw new Error("Exponent is too large.");
    }
  }(ea)), ea;
}
/*!
 * amount.js - amount object for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var ta, sd;
function Di() {
  if (sd) return ta;
  sd = 1;
  const e = dt, c = z8();
  class l {
    /**
     * Create an amount.
     * @constructor
     * @param {(String|Number)?} value
     * @param {String?} unit
     */
    constructor(m, f) {
      this.value = 0, m != null && this.fromOptions(m, f);
    }
    /**
     * Inject properties from options.
     * @private
     * @param {(String|Number)?} value
     * @param {String?} unit
     * @returns {Amount}
     */
    fromOptions(m, f) {
      return typeof f == "string" ? this.from(f, m) : typeof m == "number" ? this.fromValue(m) : this.fromBTC(m);
    }
    /**
     * Get satoshi value.
     * @returns {Amount}
     */
    toValue() {
      return this.value;
    }
    /**
     * Get satoshi string or value.
     * @param {Boolean?} num
     * @returns {String|Amount}
     */
    toSatoshis(m) {
      return m ? this.value : this.value.toString(10);
    }
    /**
     * Get bits string or value.
     * @param {Boolean?} num
     * @returns {String|Amount}
     */
    toBits(m) {
      return l.encode(this.value, 2, m);
    }
    /**
     * Get mbtc string or value.
     * @param {Boolean?} num
     * @returns {String|Amount}
     */
    toMBTC(m) {
      return l.encode(this.value, 5, m);
    }
    /**
     * Get btc string or value.
     * @param {Boolean?} num
     * @returns {String|Amount}
     */
    toBTC(m) {
      return l.encode(this.value, 8, m);
    }
    /**
     * Get unit string or value.
     * @param {String} unit - Can be `sat`,
     * `ubtc`, `bits`, `mbtc`, or `btc`.
     * @param {Boolean?} num
     * @returns {String|Amount}
     */
    to(m, f) {
      switch (m) {
        case "sat":
          return this.toSatoshis(f);
        case "ubtc":
        case "bits":
          return this.toBits(f);
        case "mbtc":
          return this.toMBTC(f);
        case "btc":
          return this.toBTC(f);
      }
      throw new Error(`Unknown unit "${m}".`);
    }
    /**
     * Convert amount to bitcoin string.
     * @returns {String}
     */
    toString() {
      return this.toBTC();
    }
    /**
     * Inject properties from value.
     * @private
     * @param {Amount} value
     * @returns {Amount}
     */
    fromValue(m) {
      return e(
        Number.isSafeInteger(m) && m >= 0,
        "Value must be an int64."
      ), this.value = m, this;
    }
    /**
     * Inject properties from satoshis.
     * @private
     * @param {Number|String} value
     * @returns {Amount}
     */
    fromSatoshis(m) {
      return this.value = l.decode(m, 0), this;
    }
    /**
     * Inject properties from bits.
     * @private
     * @param {Number|String} value
     * @returns {Amount}
     */
    fromBits(m) {
      return this.value = l.decode(m, 2), this;
    }
    /**
     * Inject properties from mbtc.
     * @private
     * @param {Number|String} value
     * @returns {Amount}
     */
    fromMBTC(m) {
      return this.value = l.decode(m, 5), this;
    }
    /**
     * Inject properties from btc.
     * @private
     * @param {Number|String} value
     * @returns {Amount}
     */
    fromBTC(m) {
      return this.value = l.decode(m, 8), this;
    }
    /**
     * Inject properties from unit.
     * @private
     * @param {String} unit
     * @param {Number|String} value
     * @returns {Amount}
     */
    from(m, f) {
      switch (m) {
        case "sat":
          return this.fromSatoshis(f);
        case "ubtc":
        case "bits":
          return this.fromBits(f);
        case "mbtc":
          return this.fromMBTC(f);
        case "btc":
          return this.fromBTC(f);
      }
      throw new Error(`Unknown unit "${m}".`);
    }
    /**
     * Instantiate amount from options.
     * @param {(String|Number)?} value
     * @param {String?} unit
     * @returns {Amount}
     */
    static fromOptions(m, f) {
      return new this().fromOptions(m, f);
    }
    /**
     * Instantiate amount from value.
     * @private
     * @param {Amount} value
     * @returns {Amount}
     */
    static fromValue(m) {
      return new this().fromValue(m);
    }
    /**
     * Instantiate amount from satoshis.
     * @param {Number|String} value
     * @returns {Amount}
     */
    static fromSatoshis(m) {
      return new this().fromSatoshis(m);
    }
    /**
     * Instantiate amount from bits.
     * @param {Number|String} value
     * @returns {Amount}
     */
    static fromBits(m) {
      return new this().fromBits(m);
    }
    /**
     * Instantiate amount from mbtc.
     * @param {Number|String} value
     * @returns {Amount}
     */
    static fromMBTC(m) {
      return new this().fromMBTC(m);
    }
    /**
     * Instantiate amount from btc.
     * @param {Number|String} value
     * @returns {Amount}
     */
    static fromBTC(m) {
      return new this().fromBTC(m);
    }
    /**
     * Instantiate amount from unit.
     * @param {String} unit
     * @param {Number|String} value
     * @returns {Amount}
     */
    static from(m, f) {
      return new this().from(m, f);
    }
    /**
     * Inspect amount.
     * @returns {String}
     */
    inspect() {
      return `<Amount: ${this.toString()}>`;
    }
    /**
     * Safely convert satoshis to a BTC string.
     * This function explicitly avoids any
     * floating point arithmetic.
     * @param {Amount} value - Satoshis.
     * @returns {String} BTC string.
     */
    static btc(m, f) {
      return typeof m == "string" ? m : l.encode(m, 8, f);
    }
    /**
     * Safely convert a BTC string to satoshis.
     * @param {String} str - BTC
     * @returns {Amount} Satoshis.
     * @throws on parse error
     */
    static value(m) {
      return typeof m == "number" ? m : l.decode(m, 8);
    }
    /**
     * Safely convert satoshis to a BTC string.
     * @param {Amount} value
     * @param {Number} exp - Exponent.
     * @param {Boolean} num - Return a number.
     * @returns {String|Number}
     */
    static encode(m, f, n) {
      return n ? c.toFloat(m, f) : c.encode(m, f);
    }
    /**
     * Safely convert a BTC string to satoshis.
     * @param {String|Number} value - BTC
     * @param {Number} exp - Exponent.
     * @returns {Amount} Satoshis.
     * @throws on parse error
     */
    static decode(m, f) {
      return typeof m == "number" ? c.fromFloat(m, f) : c.decode(m, f);
    }
  }
  return ta = l, ta;
}
/*!
 * assert.js - assert for bcrypto
 * Copyright (c) 2020, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var ra, od;
function Mt() {
  if (od) return ra;
  od = 1;
  function e(c, l) {
    if (!c) {
      const w = new Error(l || "Assertion failed");
      throw Error.captureStackTrace && Error.captureStackTrace(w, e), w;
    }
  }
  return ra = e, ra;
}
/*!
 * hmac.js - hmac for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/hash.js:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/hash.js
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/HMAC
 *   https://tools.ietf.org/html/rfc2104
 *   https://github.com/indutny/hash.js/blob/master/lib/hash/hmac.js
 */
var ia, ad;
function ni() {
  if (ad) return ia;
  ad = 1;
  const e = Mt();
  class c {
    /**
     * Create an HMAC.
     * @param {Function} Hash
     * @param {Number} size
     * @param {Array} [x=[]]
     * @param {Array} [y=[]]
     */
    constructor(w, m, f = [], n = []) {
      e(typeof w == "function"), e(m >>> 0 === m), e(Array.isArray(f)), e(Array.isArray(n)), this.hash = w, this.size = m, this.x = f, this.y = n, this.inner = new w(), this.outer = new w();
    }
    /**
     * Initialize HMAC context.
     * @param {Buffer} data
     */
    init(w) {
      if (e(k.isBuffer(w)), w.length > this.size) {
        const f = this.hash, n = new f();
        n.init(...this.x), n.update(w), w = n.final(...this.y), e(w.length <= this.size);
      }
      const m = k.alloc(this.size);
      for (let f = 0; f < w.length; f++)
        m[f] = w[f] ^ 54;
      for (let f = w.length; f < m.length; f++)
        m[f] = 54;
      this.inner.init(...this.x), this.inner.update(m);
      for (let f = 0; f < w.length; f++)
        m[f] = w[f] ^ 92;
      for (let f = w.length; f < m.length; f++)
        m[f] = 92;
      return this.outer.init(...this.x), this.outer.update(m), this;
    }
    /**
     * Update HMAC context.
     * @param {Buffer} data
     */
    update(w) {
      return this.inner.update(w), this;
    }
    /**
     * Finalize HMAC context.
     * @returns {Buffer}
     */
    final() {
      return this.outer.update(this.inner.final(...this.y)), this.outer.final(...this.y);
    }
  }
  return ia = c, ia;
}
/*!
 * sha256.js - SHA256 implementation for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/hash.js:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/hash.js
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/SHA-2
 *   https://tools.ietf.org/html/rfc4634
 *   https://github.com/indutny/hash.js/blob/master/lib/hash/sha/256.js
 */
var na, fd;
function br() {
  if (fd) return na;
  fd = 1;
  const e = Mt(), c = ni(), l = -1, w = k.alloc(8, 0), m = k.alloc(64, 0);
  m[0] = 128;
  const f = new Uint32Array([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ]);
  class n {
    constructor() {
      this.state = new Uint32Array(8), this.msg = new Uint32Array(64), this.block = k.alloc(64), this.size = l;
    }
    init() {
      return this.state[0] = 1779033703, this.state[1] = 3144134277, this.state[2] = 1013904242, this.state[3] = 2773480762, this.state[4] = 1359893119, this.state[5] = 2600822924, this.state[6] = 528734635, this.state[7] = 1541459225, this.size = 0, this;
    }
    update(h) {
      return e(k.isBuffer(h)), this._update(h, h.length), this;
    }
    final() {
      return this._final(k.alloc(32));
    }
    _update(h, a) {
      e(this.size !== l, "Context is not initialized.");
      let E = this.size & 63, H = 0;
      if (this.size += a, E > 0) {
        let j = 64 - E;
        if (j > a && (j = a), h.copy(this.block, E, H, H + j), E += j, a -= j, H += j, E < 64)
          return;
        this._transform(this.block, 0);
      }
      for (; a >= 64; )
        this._transform(h, H), H += 64, a -= 64;
      a > 0 && h.copy(this.block, 0, H, H + a);
    }
    _final(h) {
      e(this.size !== l, "Context is not initialized.");
      const a = this.size & 63, E = this.size * 8;
      y(w, E * (1 / 4294967296) >>> 0, 0), y(w, E >>> 0, 4), this._update(m, 1 + (119 - a & 63)), this._update(w, 8);
      for (let H = 0; H < 8; H++)
        y(h, this.state[H], H * 4), this.state[H] = 0;
      for (let H = 0; H < 64; H++)
        this.msg[H] = 0;
      for (let H = 0; H < 64; H++)
        this.block[H] = 0;
      return this.size = l, h;
    }
    _transform(h, a) {
      const E = this.msg;
      let H = this.state[0], j = this.state[1], G = this.state[2], N = this.state[3], T = this.state[4], A = this.state[5], q = this.state[6], _ = this.state[7], F = 0;
      for (; F < 16; F++)
        E[F] = S(h, a + F * 4);
      for (; F < 64; F++)
        E[F] = i(E[F - 2]) + E[F - 7] + s(E[F - 15]) + E[F - 16];
      for (F = 0; F < 64; F++) {
        const R = _ + o(T) + p(T, A, q) + f[F] + E[F], L = u(H) + g(H, j, G);
        _ = q, q = A, A = T, T = N + R >>> 0, N = G, G = j, j = H, H = R + L >>> 0;
      }
      this.state[0] += H, this.state[1] += j, this.state[2] += G, this.state[3] += N, this.state[4] += T, this.state[5] += A, this.state[6] += q, this.state[7] += _;
    }
    static hash() {
      return new n();
    }
    static hmac() {
      return new c(n, 64);
    }
    static digest(h) {
      return n.ctx.init().update(h).final();
    }
    static root(h, a) {
      return e(k.isBuffer(h) && h.length === 32), e(k.isBuffer(a) && a.length === 32), n.ctx.init().update(h).update(a).final();
    }
    static multi(h, a, E) {
      const { ctx: H } = n;
      return H.init(), H.update(h), H.update(a), E && H.update(E), H.final();
    }
    static mac(h, a) {
      return n.hmac().init(a).update(h).final();
    }
  }
  n.native = 0, n.id = "SHA256", n.size = 32, n.bits = 256, n.blockSize = 64, n.zero = k.alloc(32, 0), n.ctx = new n();
  function u(b) {
    return (b >>> 2 | b << 30) ^ (b >>> 13 | b << 19) ^ (b >>> 22 | b << 10);
  }
  function o(b) {
    return (b >>> 6 | b << 26) ^ (b >>> 11 | b << 21) ^ (b >>> 25 | b << 7);
  }
  function s(b) {
    return (b >>> 7 | b << 25) ^ (b >>> 18 | b << 14) ^ b >>> 3;
  }
  function i(b) {
    return (b >>> 17 | b << 15) ^ (b >>> 19 | b << 13) ^ b >>> 10;
  }
  function p(b, h, a) {
    return a ^ b & (h ^ a);
  }
  function g(b, h, a) {
    return b & h | a & (b | h);
  }
  function S(b, h) {
    return b[h++] * 16777216 + b[h++] * 65536 + b[h++] * 256 + b[h];
  }
  function y(b, h, a) {
    return b[a++] = h >>> 24, b[a++] = h >>> 16, b[a++] = h >>> 8, b[a++] = h, a;
  }
  return na = n, na;
}
/*!
 * ripemd160.js - RIPEMD160 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/hash.js:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/hash.js
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/RIPEMD-160
 *   https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf
 *   https://github.com/indutny/hash.js/blob/master/lib/hash/ripemd.js
 */
var sa, cd;
function ll() {
  if (cd) return sa;
  cd = 1;
  const e = Mt(), c = ni(), l = -1, w = k.alloc(8, 0), m = k.alloc(64, 0);
  m[0] = 128;
  const f = new Uint8Array([
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    7,
    4,
    13,
    1,
    10,
    6,
    15,
    3,
    12,
    0,
    9,
    5,
    2,
    14,
    11,
    8,
    3,
    10,
    14,
    4,
    9,
    15,
    8,
    1,
    2,
    7,
    0,
    6,
    13,
    11,
    5,
    12,
    1,
    9,
    11,
    10,
    0,
    8,
    12,
    4,
    13,
    3,
    7,
    15,
    14,
    5,
    6,
    2,
    4,
    0,
    5,
    9,
    7,
    12,
    2,
    10,
    14,
    1,
    3,
    8,
    11,
    6,
    15,
    13
  ]), n = new Uint8Array([
    5,
    14,
    7,
    0,
    9,
    2,
    11,
    4,
    13,
    6,
    15,
    8,
    1,
    10,
    3,
    12,
    6,
    11,
    3,
    7,
    0,
    13,
    5,
    10,
    14,
    15,
    8,
    12,
    4,
    9,
    1,
    2,
    15,
    5,
    1,
    3,
    7,
    14,
    6,
    9,
    11,
    8,
    12,
    2,
    10,
    0,
    4,
    13,
    8,
    6,
    4,
    1,
    3,
    11,
    15,
    0,
    5,
    12,
    2,
    13,
    9,
    7,
    10,
    14,
    12,
    15,
    10,
    4,
    1,
    5,
    8,
    7,
    6,
    2,
    13,
    14,
    0,
    3,
    9,
    11
  ]), u = new Uint8Array([
    11,
    14,
    15,
    12,
    5,
    8,
    7,
    9,
    11,
    13,
    14,
    15,
    6,
    7,
    9,
    8,
    7,
    6,
    8,
    13,
    11,
    9,
    7,
    15,
    7,
    12,
    15,
    9,
    11,
    7,
    13,
    12,
    11,
    13,
    6,
    7,
    14,
    9,
    13,
    15,
    14,
    8,
    13,
    6,
    5,
    12,
    7,
    5,
    11,
    12,
    14,
    15,
    14,
    15,
    9,
    8,
    9,
    14,
    5,
    6,
    8,
    6,
    5,
    12,
    9,
    15,
    5,
    11,
    6,
    8,
    13,
    12,
    5,
    12,
    13,
    14,
    11,
    8,
    5,
    6
  ]), o = new Uint8Array([
    8,
    9,
    9,
    11,
    13,
    15,
    15,
    5,
    7,
    7,
    8,
    11,
    14,
    14,
    12,
    6,
    9,
    13,
    15,
    7,
    12,
    8,
    9,
    11,
    7,
    7,
    12,
    7,
    6,
    15,
    13,
    11,
    9,
    7,
    15,
    11,
    8,
    6,
    6,
    14,
    12,
    13,
    5,
    14,
    13,
    13,
    7,
    5,
    15,
    5,
    8,
    11,
    14,
    14,
    6,
    14,
    6,
    9,
    12,
    9,
    12,
    5,
    15,
    8,
    8,
    5,
    12,
    9,
    12,
    5,
    14,
    6,
    8,
    13,
    6,
    5,
    15,
    13,
    11,
    11
  ]);
  class s {
    constructor() {
      this.state = new Uint32Array(5), this.msg = new Uint32Array(16), this.block = k.alloc(64), this.size = l;
    }
    init() {
      return this.state[0] = 1732584193, this.state[1] = 4023233417, this.state[2] = 2562383102, this.state[3] = 271733878, this.state[4] = 3285377520, this.size = 0, this;
    }
    update(a) {
      return e(k.isBuffer(a)), this._update(a, a.length), this;
    }
    final() {
      return this._final(k.alloc(20));
    }
    _update(a, E) {
      e(this.size !== l, "Context is not initialized.");
      let H = this.size & 63, j = 0;
      if (this.size += E, H > 0) {
        let G = 64 - H;
        if (G > E && (G = E), a.copy(this.block, H, j, j + G), H += G, E -= G, j += G, H < 64)
          return;
        this._transform(this.block, 0);
      }
      for (; E >= 64; )
        this._transform(a, j), j += 64, E -= 64;
      E > 0 && a.copy(this.block, 0, j, j + E);
    }
    _final(a) {
      e(this.size !== l, "Context is not initialized.");
      const E = this.size & 63, H = this.size * 8;
      b(w, H >>> 0, 0), b(w, H * (1 / 4294967296) >>> 0, 4), this._update(m, 1 + (119 - E & 63)), this._update(w, 8);
      for (let j = 0; j < 5; j++)
        b(a, this.state[j], j * 4), this.state[j] = 0;
      for (let j = 0; j < 16; j++)
        this.msg[j] = 0;
      for (let j = 0; j < 64; j++)
        this.block[j] = 0;
      return this.size = l, a;
    }
    _transform(a, E) {
      const H = this.msg;
      let j = this.state[0], G = this.state[1], N = this.state[2], T = this.state[3], A = this.state[4], q = j, _ = G, F = N, R = T, L = A;
      for (let ue = 0; ue < 16; ue++)
        H[ue] = y(a, E + ue * 4);
      for (let ue = 0; ue < 80; ue++) {
        let ae = j + p(ue, G, N, T) + H[f[ue]] + g(ue), D = i(ae, u[ue]), Q = D + A;
        j = A, A = T, T = i(N, 10), N = G, G = Q, ae = q + p(79 - ue, _, F, R) + H[n[ue]] + S(ue), D = i(ae, o[ue]), Q = D + L, q = L, L = R, R = i(F, 10), F = _, _ = Q;
      }
      const fe = this.state[1] + N + R;
      this.state[1] = this.state[2] + T + L, this.state[2] = this.state[3] + A + q, this.state[3] = this.state[4] + j + _, this.state[4] = this.state[0] + G + F, this.state[0] = fe;
    }
    static hash() {
      return new s();
    }
    static hmac() {
      return new c(s, 64);
    }
    static digest(a) {
      return s.ctx.init().update(a).final();
    }
    static root(a, E) {
      return e(k.isBuffer(a) && a.length === 20), e(k.isBuffer(E) && E.length === 20), s.ctx.init().update(a).update(E).final();
    }
    static multi(a, E, H) {
      const { ctx: j } = s;
      return j.init(), j.update(a), j.update(E), H && j.update(H), j.final();
    }
    static mac(a, E) {
      return s.hmac().init(E).update(a).final();
    }
  }
  s.native = 0, s.id = "RIPEMD160", s.size = 20, s.bits = 160, s.blockSize = 64, s.zero = k.alloc(20, 0), s.ctx = new s();
  function i(h, a) {
    return h << a | h >>> 32 - a;
  }
  function p(h, a, E, H) {
    return h <= 15 ? a ^ E ^ H : h <= 31 ? a & E | ~a & H : h <= 47 ? (a | ~E) ^ H : h <= 63 ? a & H | E & ~H : a ^ (E | ~H);
  }
  function g(h) {
    return h <= 15 ? 0 : h <= 31 ? 1518500249 : h <= 47 ? 1859775393 : h <= 63 ? 2400959708 : 2840853838;
  }
  function S(h) {
    return h <= 15 ? 1352829926 : h <= 31 ? 1548603684 : h <= 47 ? 1836072691 : h <= 63 ? 2053994217 : 0;
  }
  function y(h, a) {
    return h[a++] + h[a++] * 256 + h[a++] * 65536 + h[a] * 16777216;
  }
  function b(h, a, E) {
    return h[E++] = a, a >>>= 8, h[E++] = a, a >>>= 8, h[E++] = a, a >>>= 8, h[E++] = a, E;
  }
  return sa = s, sa;
}
/*!
 * hash160.js - Hash160 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://github.com/bitcoin/bitcoin/blob/master/src/hash.h
 */
var oa, ud;
function wn() {
  if (ud) return oa;
  ud = 1;
  const e = Mt(), c = br(), l = ll(), w = ni(), m = new l();
  class f {
    constructor() {
      this.ctx = new c();
    }
    init() {
      return this.ctx.init(), this;
    }
    update(u) {
      return this.ctx.update(u), this;
    }
    final() {
      const u = k.alloc(32);
      return this.ctx._final(u), m.init(), m.update(u), m._final(u), u.slice(0, 20);
    }
    static hash() {
      return new f();
    }
    static hmac() {
      return new w(f, 64);
    }
    static digest(u) {
      return f.ctx.init().update(u).final();
    }
    static root(u, o) {
      return e(k.isBuffer(u) && u.length === 20), e(k.isBuffer(o) && o.length === 20), f.ctx.init().update(u).update(o).final();
    }
    static multi(u, o, s) {
      const { ctx: i } = f;
      return i.init(), i.update(u), i.update(o), s && i.update(s), i.final();
    }
    static mac(u, o) {
      return f.hmac().init(o).update(u).final();
    }
  }
  return f.native = 0, f.id = "HASH160", f.size = 20, f.bits = 160, f.blockSize = 64, f.zero = k.alloc(20, 0), f.ctx = new f(), oa = f, oa;
}
/*!
 * hash256.js - Hash256 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://github.com/bitcoin/bitcoin/blob/master/src/hash.h
 */
var aa, hd;
function qr() {
  if (hd) return aa;
  hd = 1;
  const e = Mt(), c = br(), l = ni();
  class w {
    constructor() {
      this.ctx = new c();
    }
    init() {
      return this.ctx.init(), this;
    }
    update(f) {
      return this.ctx.update(f), this;
    }
    final() {
      const f = k.alloc(32);
      return this.ctx._final(f), this.ctx.init(), this.ctx.update(f), this.ctx._final(f), f;
    }
    static hash() {
      return new w();
    }
    static hmac() {
      return new l(w, 64);
    }
    static digest(f) {
      return w.ctx.init().update(f).final();
    }
    static root(f, n) {
      return e(k.isBuffer(f) && f.length === 32), e(k.isBuffer(n) && n.length === 32), w.ctx.init().update(f).update(n).final();
    }
    static multi(f, n, u) {
      const { ctx: o } = w;
      return o.init(), o.update(f), o.update(n), u && o.update(u), o.final();
    }
    static mac(f, n) {
      return w.hmac().init(n).update(f).final();
    }
  }
  return w.native = 0, w.id = "HASH256", w.size = 32, w.bits = 256, w.blockSize = 64, w.zero = k.alloc(32, 0), w.ctx = new w(), aa = w, aa;
}
var fa = {};
/*!
 * binary.js - binary search utils for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var ld;
function dl() {
  return ld || (ld = 1, function(e) {
    e.search = function(w, m, f, n) {
      let u = 0, o = w.length - 1;
      for (; u <= o; ) {
        const s = u + o >>> 1, i = f(w[s], m);
        if (i === 0)
          return s;
        i < 0 ? u = s + 1 : o = s - 1;
      }
      return n ? u : -1;
    }, e.insert = function(w, m, f, n) {
      const u = e.search(w, m, f, !0);
      return n && u < w.length && f(w[u], m) === 0 ? -1 : (u === 0 ? w.unshift(m) : u === w.length ? w.push(m) : w.splice(u, 0, m), u);
    }, e.remove = function(w, m, f) {
      const n = e.search(w, m, f, !1);
      return n === -1 ? !1 : (c(w, n), !0);
    };
    function c(l, w) {
      if (w === 0) {
        l.shift();
        return;
      }
      let m = w + 1;
      for (; m < l.length; )
        l[w++] = l[m++];
      l.pop();
    }
  }(fa)), fa;
}
var ca = {}, ua = {}, zi = typeof Ds < "u" ? Ds : typeof self < "u" ? self : typeof window < "u" ? window : {}, Lr = [], Er = [], Xm = typeof Uint8Array < "u" ? Uint8Array : Array, bl = !1;
function C8() {
  bl = !0;
  for (var e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", c = 0, l = e.length; c < l; ++c)
    Lr[c] = e[c], Er[e.charCodeAt(c)] = c;
  Er[45] = 62, Er[95] = 63;
}
function Gm(e) {
  bl || C8();
  var c, l, w, m, f, n, u = e.length;
  if (u % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  f = e[u - 2] === "=" ? 2 : e[u - 1] === "=" ? 1 : 0, n = new Xm(u * 3 / 4 - f), w = f > 0 ? u - 4 : u;
  var o = 0;
  for (c = 0, l = 0; c < w; c += 4, l += 3)
    m = Er[e.charCodeAt(c)] << 18 | Er[e.charCodeAt(c + 1)] << 12 | Er[e.charCodeAt(c + 2)] << 6 | Er[e.charCodeAt(c + 3)], n[o++] = m >> 16 & 255, n[o++] = m >> 8 & 255, n[o++] = m & 255;
  return f === 2 ? (m = Er[e.charCodeAt(c)] << 2 | Er[e.charCodeAt(c + 1)] >> 4, n[o++] = m & 255) : f === 1 && (m = Er[e.charCodeAt(c)] << 10 | Er[e.charCodeAt(c + 1)] << 4 | Er[e.charCodeAt(c + 2)] >> 2, n[o++] = m >> 8 & 255, n[o++] = m & 255), n;
}
function Jm(e) {
  return Lr[e >> 18 & 63] + Lr[e >> 12 & 63] + Lr[e >> 6 & 63] + Lr[e & 63];
}
function Wm(e, c, l) {
  for (var w, m = [], f = c; f < l; f += 3)
    w = (e[f] << 16) + (e[f + 1] << 8) + e[f + 2], m.push(Jm(w));
  return m.join("");
}
function dd(e) {
  bl || C8();
  for (var c, l = e.length, w = l % 3, m = "", f = [], n = 16383, u = 0, o = l - w; u < o; u += n)
    f.push(Wm(e, u, u + n > o ? o : u + n));
  return w === 1 ? (c = e[l - 1], m += Lr[c >> 2], m += Lr[c << 4 & 63], m += "==") : w === 2 && (c = (e[l - 2] << 8) + e[l - 1], m += Lr[c >> 10], m += Lr[c >> 4 & 63], m += Lr[c << 2 & 63], m += "="), f.push(m), f.join("");
}
function Xs(e, c, l, w, m) {
  var f, n, u = m * 8 - w - 1, o = (1 << u) - 1, s = o >> 1, i = -7, p = l ? m - 1 : 0, g = l ? -1 : 1, S = e[c + p];
  for (p += g, f = S & (1 << -i) - 1, S >>= -i, i += u; i > 0; f = f * 256 + e[c + p], p += g, i -= 8)
    ;
  for (n = f & (1 << -i) - 1, f >>= -i, i += w; i > 0; n = n * 256 + e[c + p], p += g, i -= 8)
    ;
  if (f === 0)
    f = 1 - s;
  else {
    if (f === o)
      return n ? NaN : (S ? -1 : 1) * (1 / 0);
    n = n + Math.pow(2, w), f = f - s;
  }
  return (S ? -1 : 1) * n * Math.pow(2, f - w);
}
function D8(e, c, l, w, m, f) {
  var n, u, o, s = f * 8 - m - 1, i = (1 << s) - 1, p = i >> 1, g = m === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, S = w ? 0 : f - 1, y = w ? 1 : -1, b = c < 0 || c === 0 && 1 / c < 0 ? 1 : 0;
  for (c = Math.abs(c), isNaN(c) || c === 1 / 0 ? (u = isNaN(c) ? 1 : 0, n = i) : (n = Math.floor(Math.log(c) / Math.LN2), c * (o = Math.pow(2, -n)) < 1 && (n--, o *= 2), n + p >= 1 ? c += g / o : c += g * Math.pow(2, 1 - p), c * o >= 2 && (n++, o /= 2), n + p >= i ? (u = 0, n = i) : n + p >= 1 ? (u = (c * o - 1) * Math.pow(2, m), n = n + p) : (u = c * Math.pow(2, p - 1) * Math.pow(2, m), n = 0)); m >= 8; e[l + S] = u & 255, S += y, u /= 256, m -= 8)
    ;
  for (n = n << m | u, s += m; s > 0; e[l + S] = n & 255, S += y, n /= 256, s -= 8)
    ;
  e[l + S - y] |= b * 128;
}
var Zm = {}.toString, U8 = Array.isArray || function(e) {
  return Zm.call(e) == "[object Array]";
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
var Qm = 50;
Ce.TYPED_ARRAY_SUPPORT = zi.TYPED_ARRAY_SUPPORT !== void 0 ? zi.TYPED_ARRAY_SUPPORT : !0;
Us();
function Us() {
  return Ce.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
}
function ti(e, c) {
  if (Us() < c)
    throw new RangeError("Invalid typed array length");
  return Ce.TYPED_ARRAY_SUPPORT ? (e = new Uint8Array(c), e.__proto__ = Ce.prototype) : (e === null && (e = new Ce(c)), e.length = c), e;
}
function Ce(e, c, l) {
  if (!Ce.TYPED_ARRAY_SUPPORT && !(this instanceof Ce))
    return new Ce(e, c, l);
  if (typeof e == "number") {
    if (typeof c == "string")
      throw new Error(
        "If encoding is specified then the first argument must be a string"
      );
    return pl(this, e);
  }
  return F8(this, e, c, l);
}
Ce.poolSize = 8192;
Ce._augment = function(e) {
  return e.__proto__ = Ce.prototype, e;
};
function F8(e, c, l, w) {
  if (typeof c == "number")
    throw new TypeError('"value" argument must not be a number');
  return typeof ArrayBuffer < "u" && c instanceof ArrayBuffer ? r9(e, c, l, w) : typeof c == "string" ? t9(e, c, l) : i9(e, c);
}
Ce.from = function(e, c, l) {
  return F8(null, e, c, l);
};
Ce.TYPED_ARRAY_SUPPORT && (Ce.prototype.__proto__ = Uint8Array.prototype, Ce.__proto__ = Uint8Array, typeof Symbol < "u" && Symbol.species && Ce[Symbol.species]);
function H8(e) {
  if (typeof e != "number")
    throw new TypeError('"size" argument must be a number');
  if (e < 0)
    throw new RangeError('"size" argument must not be negative');
}
function e9(e, c, l, w) {
  return H8(c), c <= 0 ? ti(e, c) : l !== void 0 ? typeof w == "string" ? ti(e, c).fill(l, w) : ti(e, c).fill(l) : ti(e, c);
}
Ce.alloc = function(e, c, l) {
  return e9(null, e, c, l);
};
function pl(e, c) {
  if (H8(c), e = ti(e, c < 0 ? 0 : ml(c) | 0), !Ce.TYPED_ARRAY_SUPPORT)
    for (var l = 0; l < c; ++l)
      e[l] = 0;
  return e;
}
Ce.allocUnsafe = function(e) {
  return pl(null, e);
};
Ce.allocUnsafeSlow = function(e) {
  return pl(null, e);
};
function t9(e, c, l) {
  if ((typeof l != "string" || l === "") && (l = "utf8"), !Ce.isEncoding(l))
    throw new TypeError('"encoding" must be a valid string encoding');
  var w = L8(c, l) | 0;
  e = ti(e, w);
  var m = e.write(c, l);
  return m !== w && (e = e.slice(0, m)), e;
}
function il(e, c) {
  var l = c.length < 0 ? 0 : ml(c.length) | 0;
  e = ti(e, l);
  for (var w = 0; w < l; w += 1)
    e[w] = c[w] & 255;
  return e;
}
function r9(e, c, l, w) {
  if (c.byteLength, l < 0 || c.byteLength < l)
    throw new RangeError("'offset' is out of bounds");
  if (c.byteLength < l + (w || 0))
    throw new RangeError("'length' is out of bounds");
  return l === void 0 && w === void 0 ? c = new Uint8Array(c) : w === void 0 ? c = new Uint8Array(c, l) : c = new Uint8Array(c, l, w), Ce.TYPED_ARRAY_SUPPORT ? (e = c, e.__proto__ = Ce.prototype) : e = il(e, c), e;
}
function i9(e, c) {
  if (Vr(c)) {
    var l = ml(c.length) | 0;
    return e = ti(e, l), e.length === 0 || c.copy(e, 0, 0, l), e;
  }
  if (c) {
    if (typeof ArrayBuffer < "u" && c.buffer instanceof ArrayBuffer || "length" in c)
      return typeof c.length != "number" || S9(c.length) ? ti(e, 0) : il(e, c);
    if (c.type === "Buffer" && U8(c.data))
      return il(e, c.data);
  }
  throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
}
function ml(e) {
  if (e >= Us())
    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + Us().toString(16) + " bytes");
  return e | 0;
}
Ce.isBuffer = an;
function Vr(e) {
  return !!(e != null && e._isBuffer);
}
Ce.compare = function(c, l) {
  if (!Vr(c) || !Vr(l))
    throw new TypeError("Arguments must be Buffers");
  if (c === l) return 0;
  for (var w = c.length, m = l.length, f = 0, n = Math.min(w, m); f < n; ++f)
    if (c[f] !== l[f]) {
      w = c[f], m = l[f];
      break;
    }
  return w < m ? -1 : m < w ? 1 : 0;
};
Ce.isEncoding = function(c) {
  switch (String(c).toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "latin1":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return !0;
    default:
      return !1;
  }
};
Ce.concat = function(c, l) {
  if (!U8(c))
    throw new TypeError('"list" argument must be an Array of Buffers');
  if (c.length === 0)
    return Ce.alloc(0);
  var w;
  if (l === void 0)
    for (l = 0, w = 0; w < c.length; ++w)
      l += c[w].length;
  var m = Ce.allocUnsafe(l), f = 0;
  for (w = 0; w < c.length; ++w) {
    var n = c[w];
    if (!Vr(n))
      throw new TypeError('"list" argument must be an Array of Buffers');
    n.copy(m, f), f += n.length;
  }
  return m;
};
function L8(e, c) {
  if (Vr(e))
    return e.length;
  if (typeof ArrayBuffer < "u" && typeof ArrayBuffer.isView == "function" && (ArrayBuffer.isView(e) || e instanceof ArrayBuffer))
    return e.byteLength;
  typeof e != "string" && (e = "" + e);
  var l = e.length;
  if (l === 0) return 0;
  for (var w = !1; ; )
    switch (c) {
      case "ascii":
      case "latin1":
      case "binary":
        return l;
      case "utf8":
      case "utf-8":
      case void 0:
        return Fs(e).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return l * 2;
      case "hex":
        return l >>> 1;
      case "base64":
        return G8(e).length;
      default:
        if (w) return Fs(e).length;
        c = ("" + c).toLowerCase(), w = !0;
    }
}
Ce.byteLength = L8;
function n9(e, c, l) {
  var w = !1;
  if ((c === void 0 || c < 0) && (c = 0), c > this.length || ((l === void 0 || l > this.length) && (l = this.length), l <= 0) || (l >>>= 0, c >>>= 0, l <= c))
    return "";
  for (e || (e = "utf8"); ; )
    switch (e) {
      case "hex":
        return b9(this, c, l);
      case "utf8":
      case "utf-8":
        return $8(this, c, l);
      case "ascii":
        return l9(this, c, l);
      case "latin1":
      case "binary":
        return d9(this, c, l);
      case "base64":
        return u9(this, c, l);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return p9(this, c, l);
      default:
        if (w) throw new TypeError("Unknown encoding: " + e);
        e = (e + "").toLowerCase(), w = !0;
    }
}
Ce.prototype._isBuffer = !0;
function Mi(e, c, l) {
  var w = e[c];
  e[c] = e[l], e[l] = w;
}
Ce.prototype.swap16 = function() {
  var c = this.length;
  if (c % 2 !== 0)
    throw new RangeError("Buffer size must be a multiple of 16-bits");
  for (var l = 0; l < c; l += 2)
    Mi(this, l, l + 1);
  return this;
};
Ce.prototype.swap32 = function() {
  var c = this.length;
  if (c % 4 !== 0)
    throw new RangeError("Buffer size must be a multiple of 32-bits");
  for (var l = 0; l < c; l += 4)
    Mi(this, l, l + 3), Mi(this, l + 1, l + 2);
  return this;
};
Ce.prototype.swap64 = function() {
  var c = this.length;
  if (c % 8 !== 0)
    throw new RangeError("Buffer size must be a multiple of 64-bits");
  for (var l = 0; l < c; l += 8)
    Mi(this, l, l + 7), Mi(this, l + 1, l + 6), Mi(this, l + 2, l + 5), Mi(this, l + 3, l + 4);
  return this;
};
Ce.prototype.toString = function() {
  var c = this.length | 0;
  return c === 0 ? "" : arguments.length === 0 ? $8(this, 0, c) : n9.apply(this, arguments);
};
Ce.prototype.equals = function(c) {
  if (!Vr(c)) throw new TypeError("Argument must be a Buffer");
  return this === c ? !0 : Ce.compare(this, c) === 0;
};
Ce.prototype.inspect = function() {
  var c = "", l = Qm;
  return this.length > 0 && (c = this.toString("hex", 0, l).match(/.{2}/g).join(" "), this.length > l && (c += " ... ")), "<Buffer " + c + ">";
};
Ce.prototype.compare = function(c, l, w, m, f) {
  if (!Vr(c))
    throw new TypeError("Argument must be a Buffer");
  if (l === void 0 && (l = 0), w === void 0 && (w = c ? c.length : 0), m === void 0 && (m = 0), f === void 0 && (f = this.length), l < 0 || w > c.length || m < 0 || f > this.length)
    throw new RangeError("out of range index");
  if (m >= f && l >= w)
    return 0;
  if (m >= f)
    return -1;
  if (l >= w)
    return 1;
  if (l >>>= 0, w >>>= 0, m >>>= 0, f >>>= 0, this === c) return 0;
  for (var n = f - m, u = w - l, o = Math.min(n, u), s = this.slice(m, f), i = c.slice(l, w), p = 0; p < o; ++p)
    if (s[p] !== i[p]) {
      n = s[p], u = i[p];
      break;
    }
  return n < u ? -1 : u < n ? 1 : 0;
};
function K8(e, c, l, w, m) {
  if (e.length === 0) return -1;
  if (typeof l == "string" ? (w = l, l = 0) : l > 2147483647 ? l = 2147483647 : l < -2147483648 && (l = -2147483648), l = +l, isNaN(l) && (l = m ? 0 : e.length - 1), l < 0 && (l = e.length + l), l >= e.length) {
    if (m) return -1;
    l = e.length - 1;
  } else if (l < 0)
    if (m) l = 0;
    else return -1;
  if (typeof c == "string" && (c = Ce.from(c, w)), Vr(c))
    return c.length === 0 ? -1 : bd(e, c, l, w, m);
  if (typeof c == "number")
    return c = c & 255, Ce.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf == "function" ? m ? Uint8Array.prototype.indexOf.call(e, c, l) : Uint8Array.prototype.lastIndexOf.call(e, c, l) : bd(e, [c], l, w, m);
  throw new TypeError("val must be string, number or Buffer");
}
function bd(e, c, l, w, m) {
  var f = 1, n = e.length, u = c.length;
  if (w !== void 0 && (w = String(w).toLowerCase(), w === "ucs2" || w === "ucs-2" || w === "utf16le" || w === "utf-16le")) {
    if (e.length < 2 || c.length < 2)
      return -1;
    f = 2, n /= 2, u /= 2, l /= 2;
  }
  function o(S, y) {
    return f === 1 ? S[y] : S.readUInt16BE(y * f);
  }
  var s;
  if (m) {
    var i = -1;
    for (s = l; s < n; s++)
      if (o(e, s) === o(c, i === -1 ? 0 : s - i)) {
        if (i === -1 && (i = s), s - i + 1 === u) return i * f;
      } else
        i !== -1 && (s -= s - i), i = -1;
  } else
    for (l + u > n && (l = n - u), s = l; s >= 0; s--) {
      for (var p = !0, g = 0; g < u; g++)
        if (o(e, s + g) !== o(c, g)) {
          p = !1;
          break;
        }
      if (p) return s;
    }
  return -1;
}
Ce.prototype.includes = function(c, l, w) {
  return this.indexOf(c, l, w) !== -1;
};
Ce.prototype.indexOf = function(c, l, w) {
  return K8(this, c, l, w, !0);
};
Ce.prototype.lastIndexOf = function(c, l, w) {
  return K8(this, c, l, w, !1);
};
function s9(e, c, l, w) {
  l = Number(l) || 0;
  var m = e.length - l;
  w ? (w = Number(w), w > m && (w = m)) : w = m;
  var f = c.length;
  if (f % 2 !== 0) throw new TypeError("Invalid hex string");
  w > f / 2 && (w = f / 2);
  for (var n = 0; n < w; ++n) {
    var u = parseInt(c.substr(n * 2, 2), 16);
    if (isNaN(u)) return n;
    e[l + n] = u;
  }
  return n;
}
function o9(e, c, l, w) {
  return Ws(Fs(c, e.length - l), e, l, w);
}
function V8(e, c, l, w) {
  return Ws(y9(c), e, l, w);
}
function a9(e, c, l, w) {
  return V8(e, c, l, w);
}
function f9(e, c, l, w) {
  return Ws(G8(c), e, l, w);
}
function c9(e, c, l, w) {
  return Ws(v9(c, e.length - l), e, l, w);
}
Ce.prototype.write = function(c, l, w, m) {
  if (l === void 0)
    m = "utf8", w = this.length, l = 0;
  else if (w === void 0 && typeof l == "string")
    m = l, w = this.length, l = 0;
  else if (isFinite(l))
    l = l | 0, isFinite(w) ? (w = w | 0, m === void 0 && (m = "utf8")) : (m = w, w = void 0);
  else
    throw new Error(
      "Buffer.write(string, encoding, offset[, length]) is no longer supported"
    );
  var f = this.length - l;
  if ((w === void 0 || w > f) && (w = f), c.length > 0 && (w < 0 || l < 0) || l > this.length)
    throw new RangeError("Attempt to write outside buffer bounds");
  m || (m = "utf8");
  for (var n = !1; ; )
    switch (m) {
      case "hex":
        return s9(this, c, l, w);
      case "utf8":
      case "utf-8":
        return o9(this, c, l, w);
      case "ascii":
        return V8(this, c, l, w);
      case "latin1":
      case "binary":
        return a9(this, c, l, w);
      case "base64":
        return f9(this, c, l, w);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return c9(this, c, l, w);
      default:
        if (n) throw new TypeError("Unknown encoding: " + m);
        m = ("" + m).toLowerCase(), n = !0;
    }
};
Ce.prototype.toJSON = function() {
  return {
    type: "Buffer",
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};
function u9(e, c, l) {
  return c === 0 && l === e.length ? dd(e) : dd(e.slice(c, l));
}
function $8(e, c, l) {
  l = Math.min(e.length, l);
  for (var w = [], m = c; m < l; ) {
    var f = e[m], n = null, u = f > 239 ? 4 : f > 223 ? 3 : f > 191 ? 2 : 1;
    if (m + u <= l) {
      var o, s, i, p;
      switch (u) {
        case 1:
          f < 128 && (n = f);
          break;
        case 2:
          o = e[m + 1], (o & 192) === 128 && (p = (f & 31) << 6 | o & 63, p > 127 && (n = p));
          break;
        case 3:
          o = e[m + 1], s = e[m + 2], (o & 192) === 128 && (s & 192) === 128 && (p = (f & 15) << 12 | (o & 63) << 6 | s & 63, p > 2047 && (p < 55296 || p > 57343) && (n = p));
          break;
        case 4:
          o = e[m + 1], s = e[m + 2], i = e[m + 3], (o & 192) === 128 && (s & 192) === 128 && (i & 192) === 128 && (p = (f & 15) << 18 | (o & 63) << 12 | (s & 63) << 6 | i & 63, p > 65535 && p < 1114112 && (n = p));
      }
    }
    n === null ? (n = 65533, u = 1) : n > 65535 && (n -= 65536, w.push(n >>> 10 & 1023 | 55296), n = 56320 | n & 1023), w.push(n), m += u;
  }
  return h9(w);
}
var pd = 4096;
function h9(e) {
  var c = e.length;
  if (c <= pd)
    return String.fromCharCode.apply(String, e);
  for (var l = "", w = 0; w < c; )
    l += String.fromCharCode.apply(
      String,
      e.slice(w, w += pd)
    );
  return l;
}
function l9(e, c, l) {
  var w = "";
  l = Math.min(e.length, l);
  for (var m = c; m < l; ++m)
    w += String.fromCharCode(e[m] & 127);
  return w;
}
function d9(e, c, l) {
  var w = "";
  l = Math.min(e.length, l);
  for (var m = c; m < l; ++m)
    w += String.fromCharCode(e[m]);
  return w;
}
function b9(e, c, l) {
  var w = e.length;
  (!c || c < 0) && (c = 0), (!l || l < 0 || l > w) && (l = w);
  for (var m = "", f = c; f < l; ++f)
    m += w9(e[f]);
  return m;
}
function p9(e, c, l) {
  for (var w = e.slice(c, l), m = "", f = 0; f < w.length; f += 2)
    m += String.fromCharCode(w[f] + w[f + 1] * 256);
  return m;
}
Ce.prototype.slice = function(c, l) {
  var w = this.length;
  c = ~~c, l = l === void 0 ? w : ~~l, c < 0 ? (c += w, c < 0 && (c = 0)) : c > w && (c = w), l < 0 ? (l += w, l < 0 && (l = 0)) : l > w && (l = w), l < c && (l = c);
  var m;
  if (Ce.TYPED_ARRAY_SUPPORT)
    m = this.subarray(c, l), m.__proto__ = Ce.prototype;
  else {
    var f = l - c;
    m = new Ce(f, void 0);
    for (var n = 0; n < f; ++n)
      m[n] = this[n + c];
  }
  return m;
};
function $t(e, c, l) {
  if (e % 1 !== 0 || e < 0) throw new RangeError("offset is not uint");
  if (e + c > l) throw new RangeError("Trying to access beyond buffer length");
}
Ce.prototype.readUIntLE = function(c, l, w) {
  c = c | 0, l = l | 0, w || $t(c, l, this.length);
  for (var m = this[c], f = 1, n = 0; ++n < l && (f *= 256); )
    m += this[c + n] * f;
  return m;
};
Ce.prototype.readUIntBE = function(c, l, w) {
  c = c | 0, l = l | 0, w || $t(c, l, this.length);
  for (var m = this[c + --l], f = 1; l > 0 && (f *= 256); )
    m += this[c + --l] * f;
  return m;
};
Ce.prototype.readUInt8 = function(c, l) {
  return l || $t(c, 1, this.length), this[c];
};
Ce.prototype.readUInt16LE = function(c, l) {
  return l || $t(c, 2, this.length), this[c] | this[c + 1] << 8;
};
Ce.prototype.readUInt16BE = function(c, l) {
  return l || $t(c, 2, this.length), this[c] << 8 | this[c + 1];
};
Ce.prototype.readUInt32LE = function(c, l) {
  return l || $t(c, 4, this.length), (this[c] | this[c + 1] << 8 | this[c + 2] << 16) + this[c + 3] * 16777216;
};
Ce.prototype.readUInt32BE = function(c, l) {
  return l || $t(c, 4, this.length), this[c] * 16777216 + (this[c + 1] << 16 | this[c + 2] << 8 | this[c + 3]);
};
Ce.prototype.readIntLE = function(c, l, w) {
  c = c | 0, l = l | 0, w || $t(c, l, this.length);
  for (var m = this[c], f = 1, n = 0; ++n < l && (f *= 256); )
    m += this[c + n] * f;
  return f *= 128, m >= f && (m -= Math.pow(2, 8 * l)), m;
};
Ce.prototype.readIntBE = function(c, l, w) {
  c = c | 0, l = l | 0, w || $t(c, l, this.length);
  for (var m = l, f = 1, n = this[c + --m]; m > 0 && (f *= 256); )
    n += this[c + --m] * f;
  return f *= 128, n >= f && (n -= Math.pow(2, 8 * l)), n;
};
Ce.prototype.readInt8 = function(c, l) {
  return l || $t(c, 1, this.length), this[c] & 128 ? (255 - this[c] + 1) * -1 : this[c];
};
Ce.prototype.readInt16LE = function(c, l) {
  l || $t(c, 2, this.length);
  var w = this[c] | this[c + 1] << 8;
  return w & 32768 ? w | 4294901760 : w;
};
Ce.prototype.readInt16BE = function(c, l) {
  l || $t(c, 2, this.length);
  var w = this[c + 1] | this[c] << 8;
  return w & 32768 ? w | 4294901760 : w;
};
Ce.prototype.readInt32LE = function(c, l) {
  return l || $t(c, 4, this.length), this[c] | this[c + 1] << 8 | this[c + 2] << 16 | this[c + 3] << 24;
};
Ce.prototype.readInt32BE = function(c, l) {
  return l || $t(c, 4, this.length), this[c] << 24 | this[c + 1] << 16 | this[c + 2] << 8 | this[c + 3];
};
Ce.prototype.readFloatLE = function(c, l) {
  return l || $t(c, 4, this.length), Xs(this, c, !0, 23, 4);
};
Ce.prototype.readFloatBE = function(c, l) {
  return l || $t(c, 4, this.length), Xs(this, c, !1, 23, 4);
};
Ce.prototype.readDoubleLE = function(c, l) {
  return l || $t(c, 8, this.length), Xs(this, c, !0, 52, 8);
};
Ce.prototype.readDoubleBE = function(c, l) {
  return l || $t(c, 8, this.length), Xs(this, c, !1, 52, 8);
};
function fr(e, c, l, w, m, f) {
  if (!Vr(e)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (c > m || c < f) throw new RangeError('"value" argument is out of bounds');
  if (l + w > e.length) throw new RangeError("Index out of range");
}
Ce.prototype.writeUIntLE = function(c, l, w, m) {
  if (c = +c, l = l | 0, w = w | 0, !m) {
    var f = Math.pow(2, 8 * w) - 1;
    fr(this, c, l, w, f, 0);
  }
  var n = 1, u = 0;
  for (this[l] = c & 255; ++u < w && (n *= 256); )
    this[l + u] = c / n & 255;
  return l + w;
};
Ce.prototype.writeUIntBE = function(c, l, w, m) {
  if (c = +c, l = l | 0, w = w | 0, !m) {
    var f = Math.pow(2, 8 * w) - 1;
    fr(this, c, l, w, f, 0);
  }
  var n = w - 1, u = 1;
  for (this[l + n] = c & 255; --n >= 0 && (u *= 256); )
    this[l + n] = c / u & 255;
  return l + w;
};
Ce.prototype.writeUInt8 = function(c, l, w) {
  return c = +c, l = l | 0, w || fr(this, c, l, 1, 255, 0), Ce.TYPED_ARRAY_SUPPORT || (c = Math.floor(c)), this[l] = c & 255, l + 1;
};
function Gs(e, c, l, w) {
  c < 0 && (c = 65535 + c + 1);
  for (var m = 0, f = Math.min(e.length - l, 2); m < f; ++m)
    e[l + m] = (c & 255 << 8 * (w ? m : 1 - m)) >>> (w ? m : 1 - m) * 8;
}
Ce.prototype.writeUInt16LE = function(c, l, w) {
  return c = +c, l = l | 0, w || fr(this, c, l, 2, 65535, 0), Ce.TYPED_ARRAY_SUPPORT ? (this[l] = c & 255, this[l + 1] = c >>> 8) : Gs(this, c, l, !0), l + 2;
};
Ce.prototype.writeUInt16BE = function(c, l, w) {
  return c = +c, l = l | 0, w || fr(this, c, l, 2, 65535, 0), Ce.TYPED_ARRAY_SUPPORT ? (this[l] = c >>> 8, this[l + 1] = c & 255) : Gs(this, c, l, !1), l + 2;
};
function Js(e, c, l, w) {
  c < 0 && (c = 4294967295 + c + 1);
  for (var m = 0, f = Math.min(e.length - l, 4); m < f; ++m)
    e[l + m] = c >>> (w ? m : 3 - m) * 8 & 255;
}
Ce.prototype.writeUInt32LE = function(c, l, w) {
  return c = +c, l = l | 0, w || fr(this, c, l, 4, 4294967295, 0), Ce.TYPED_ARRAY_SUPPORT ? (this[l + 3] = c >>> 24, this[l + 2] = c >>> 16, this[l + 1] = c >>> 8, this[l] = c & 255) : Js(this, c, l, !0), l + 4;
};
Ce.prototype.writeUInt32BE = function(c, l, w) {
  return c = +c, l = l | 0, w || fr(this, c, l, 4, 4294967295, 0), Ce.TYPED_ARRAY_SUPPORT ? (this[l] = c >>> 24, this[l + 1] = c >>> 16, this[l + 2] = c >>> 8, this[l + 3] = c & 255) : Js(this, c, l, !1), l + 4;
};
Ce.prototype.writeIntLE = function(c, l, w, m) {
  if (c = +c, l = l | 0, !m) {
    var f = Math.pow(2, 8 * w - 1);
    fr(this, c, l, w, f - 1, -f);
  }
  var n = 0, u = 1, o = 0;
  for (this[l] = c & 255; ++n < w && (u *= 256); )
    c < 0 && o === 0 && this[l + n - 1] !== 0 && (o = 1), this[l + n] = (c / u >> 0) - o & 255;
  return l + w;
};
Ce.prototype.writeIntBE = function(c, l, w, m) {
  if (c = +c, l = l | 0, !m) {
    var f = Math.pow(2, 8 * w - 1);
    fr(this, c, l, w, f - 1, -f);
  }
  var n = w - 1, u = 1, o = 0;
  for (this[l + n] = c & 255; --n >= 0 && (u *= 256); )
    c < 0 && o === 0 && this[l + n + 1] !== 0 && (o = 1), this[l + n] = (c / u >> 0) - o & 255;
  return l + w;
};
Ce.prototype.writeInt8 = function(c, l, w) {
  return c = +c, l = l | 0, w || fr(this, c, l, 1, 127, -128), Ce.TYPED_ARRAY_SUPPORT || (c = Math.floor(c)), c < 0 && (c = 255 + c + 1), this[l] = c & 255, l + 1;
};
Ce.prototype.writeInt16LE = function(c, l, w) {
  return c = +c, l = l | 0, w || fr(this, c, l, 2, 32767, -32768), Ce.TYPED_ARRAY_SUPPORT ? (this[l] = c & 255, this[l + 1] = c >>> 8) : Gs(this, c, l, !0), l + 2;
};
Ce.prototype.writeInt16BE = function(c, l, w) {
  return c = +c, l = l | 0, w || fr(this, c, l, 2, 32767, -32768), Ce.TYPED_ARRAY_SUPPORT ? (this[l] = c >>> 8, this[l + 1] = c & 255) : Gs(this, c, l, !1), l + 2;
};
Ce.prototype.writeInt32LE = function(c, l, w) {
  return c = +c, l = l | 0, w || fr(this, c, l, 4, 2147483647, -2147483648), Ce.TYPED_ARRAY_SUPPORT ? (this[l] = c & 255, this[l + 1] = c >>> 8, this[l + 2] = c >>> 16, this[l + 3] = c >>> 24) : Js(this, c, l, !0), l + 4;
};
Ce.prototype.writeInt32BE = function(c, l, w) {
  return c = +c, l = l | 0, w || fr(this, c, l, 4, 2147483647, -2147483648), c < 0 && (c = 4294967295 + c + 1), Ce.TYPED_ARRAY_SUPPORT ? (this[l] = c >>> 24, this[l + 1] = c >>> 16, this[l + 2] = c >>> 8, this[l + 3] = c & 255) : Js(this, c, l, !1), l + 4;
};
function j8(e, c, l, w, m, f) {
  if (l + w > e.length) throw new RangeError("Index out of range");
  if (l < 0) throw new RangeError("Index out of range");
}
function Y8(e, c, l, w, m) {
  return m || j8(e, c, l, 4), D8(e, c, l, w, 23, 4), l + 4;
}
Ce.prototype.writeFloatLE = function(c, l, w) {
  return Y8(this, c, l, !0, w);
};
Ce.prototype.writeFloatBE = function(c, l, w) {
  return Y8(this, c, l, !1, w);
};
function X8(e, c, l, w, m) {
  return m || j8(e, c, l, 8), D8(e, c, l, w, 52, 8), l + 8;
}
Ce.prototype.writeDoubleLE = function(c, l, w) {
  return X8(this, c, l, !0, w);
};
Ce.prototype.writeDoubleBE = function(c, l, w) {
  return X8(this, c, l, !1, w);
};
Ce.prototype.copy = function(c, l, w, m) {
  if (w || (w = 0), !m && m !== 0 && (m = this.length), l >= c.length && (l = c.length), l || (l = 0), m > 0 && m < w && (m = w), m === w || c.length === 0 || this.length === 0) return 0;
  if (l < 0)
    throw new RangeError("targetStart out of bounds");
  if (w < 0 || w >= this.length) throw new RangeError("sourceStart out of bounds");
  if (m < 0) throw new RangeError("sourceEnd out of bounds");
  m > this.length && (m = this.length), c.length - l < m - w && (m = c.length - l + w);
  var f = m - w, n;
  if (this === c && w < l && l < m)
    for (n = f - 1; n >= 0; --n)
      c[n + l] = this[n + w];
  else if (f < 1e3 || !Ce.TYPED_ARRAY_SUPPORT)
    for (n = 0; n < f; ++n)
      c[n + l] = this[n + w];
  else
    Uint8Array.prototype.set.call(
      c,
      this.subarray(w, w + f),
      l
    );
  return f;
};
Ce.prototype.fill = function(c, l, w, m) {
  if (typeof c == "string") {
    if (typeof l == "string" ? (m = l, l = 0, w = this.length) : typeof w == "string" && (m = w, w = this.length), c.length === 1) {
      var f = c.charCodeAt(0);
      f < 256 && (c = f);
    }
    if (m !== void 0 && typeof m != "string")
      throw new TypeError("encoding must be a string");
    if (typeof m == "string" && !Ce.isEncoding(m))
      throw new TypeError("Unknown encoding: " + m);
  } else typeof c == "number" && (c = c & 255);
  if (l < 0 || this.length < l || this.length < w)
    throw new RangeError("Out of range index");
  if (w <= l)
    return this;
  l = l >>> 0, w = w === void 0 ? this.length : w >>> 0, c || (c = 0);
  var n;
  if (typeof c == "number")
    for (n = l; n < w; ++n)
      this[n] = c;
  else {
    var u = Vr(c) ? c : Fs(new Ce(c, m).toString()), o = u.length;
    for (n = 0; n < w - l; ++n)
      this[n + l] = u[n % o];
  }
  return this;
};
var m9 = /[^+\/0-9A-Za-z-_]/g;
function g9(e) {
  if (e = x9(e).replace(m9, ""), e.length < 2) return "";
  for (; e.length % 4 !== 0; )
    e = e + "=";
  return e;
}
function x9(e) {
  return e.trim ? e.trim() : e.replace(/^\s+|\s+$/g, "");
}
function w9(e) {
  return e < 16 ? "0" + e.toString(16) : e.toString(16);
}
function Fs(e, c) {
  c = c || 1 / 0;
  for (var l, w = e.length, m = null, f = [], n = 0; n < w; ++n) {
    if (l = e.charCodeAt(n), l > 55295 && l < 57344) {
      if (!m) {
        if (l > 56319) {
          (c -= 3) > -1 && f.push(239, 191, 189);
          continue;
        } else if (n + 1 === w) {
          (c -= 3) > -1 && f.push(239, 191, 189);
          continue;
        }
        m = l;
        continue;
      }
      if (l < 56320) {
        (c -= 3) > -1 && f.push(239, 191, 189), m = l;
        continue;
      }
      l = (m - 55296 << 10 | l - 56320) + 65536;
    } else m && (c -= 3) > -1 && f.push(239, 191, 189);
    if (m = null, l < 128) {
      if ((c -= 1) < 0) break;
      f.push(l);
    } else if (l < 2048) {
      if ((c -= 2) < 0) break;
      f.push(
        l >> 6 | 192,
        l & 63 | 128
      );
    } else if (l < 65536) {
      if ((c -= 3) < 0) break;
      f.push(
        l >> 12 | 224,
        l >> 6 & 63 | 128,
        l & 63 | 128
      );
    } else if (l < 1114112) {
      if ((c -= 4) < 0) break;
      f.push(
        l >> 18 | 240,
        l >> 12 & 63 | 128,
        l >> 6 & 63 | 128,
        l & 63 | 128
      );
    } else
      throw new Error("Invalid code point");
  }
  return f;
}
function y9(e) {
  for (var c = [], l = 0; l < e.length; ++l)
    c.push(e.charCodeAt(l) & 255);
  return c;
}
function v9(e, c) {
  for (var l, w, m, f = [], n = 0; n < e.length && !((c -= 2) < 0); ++n)
    l = e.charCodeAt(n), w = l >> 8, m = l % 256, f.push(m), f.push(w);
  return f;
}
function G8(e) {
  return Gm(g9(e));
}
function Ws(e, c, l, w) {
  for (var m = 0; m < w && !(m + l >= c.length || m >= e.length); ++m)
    c[m + l] = e[m];
  return m;
}
function S9(e) {
  return e !== e;
}
function an(e) {
  return e != null && (!!e._isBuffer || J8(e) || E9(e));
}
function J8(e) {
  return !!e.constructor && typeof e.constructor.isBuffer == "function" && e.constructor.isBuffer(e);
}
function E9(e) {
  return typeof e.readFloatLE == "function" && typeof e.slice == "function" && J8(e.slice(0, 0));
}
function W8() {
  throw new Error("setTimeout has not been defined");
}
function Z8() {
  throw new Error("clearTimeout has not been defined");
}
var pi = W8, mi = Z8;
typeof zi.setTimeout == "function" && (pi = setTimeout);
typeof zi.clearTimeout == "function" && (mi = clearTimeout);
function Q8(e) {
  if (pi === setTimeout)
    return setTimeout(e, 0);
  if ((pi === W8 || !pi) && setTimeout)
    return pi = setTimeout, setTimeout(e, 0);
  try {
    return pi(e, 0);
  } catch {
    try {
      return pi.call(null, e, 0);
    } catch {
      return pi.call(this, e, 0);
    }
  }
}
function I9(e) {
  if (mi === clearTimeout)
    return clearTimeout(e);
  if ((mi === Z8 || !mi) && clearTimeout)
    return mi = clearTimeout, clearTimeout(e);
  try {
    return mi(e);
  } catch {
    try {
      return mi.call(null, e);
    } catch {
      return mi.call(this, e);
    }
  }
}
var ri = [], un = !1, Ni, Cs = -1;
function A9() {
  !un || !Ni || (un = !1, Ni.length ? ri = Ni.concat(ri) : Cs = -1, ri.length && e7());
}
function e7() {
  if (!un) {
    var e = Q8(A9);
    un = !0;
    for (var c = ri.length; c; ) {
      for (Ni = ri, ri = []; ++Cs < c; )
        Ni && Ni[Cs].run();
      Cs = -1, c = ri.length;
    }
    Ni = null, un = !1, I9(e);
  }
}
function O9(e) {
  var c = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var l = 1; l < arguments.length; l++)
      c[l - 1] = arguments[l];
  ri.push(new t7(e, c)), ri.length === 1 && !un && Q8(e7);
}
function t7(e, c) {
  this.fun = e, this.array = c;
}
t7.prototype.run = function() {
  this.fun.apply(null, this.array);
};
var _9 = "browser", R9 = "browser", P9 = !0, k9 = {}, B9 = [], M9 = "", N9 = {}, q9 = {}, T9 = {};
function Ui() {
}
var z9 = Ui, C9 = Ui, D9 = Ui, U9 = Ui, F9 = Ui, H9 = Ui, L9 = Ui;
function K9(e) {
  throw new Error("process.binding is not supported");
}
function V9() {
  return "/";
}
function $9(e) {
  throw new Error("process.chdir is not supported");
}
function j9() {
  return 0;
}
var sn = zi.performance || {}, Y9 = sn.now || sn.mozNow || sn.msNow || sn.oNow || sn.webkitNow || function() {
  return (/* @__PURE__ */ new Date()).getTime();
};
function X9(e) {
  var c = Y9.call(sn) * 1e-3, l = Math.floor(c), w = Math.floor(c % 1 * 1e9);
  return e && (l = l - e[0], w = w - e[1], w < 0 && (l--, w += 1e9)), [l, w];
}
var G9 = /* @__PURE__ */ new Date();
function J9() {
  var e = /* @__PURE__ */ new Date(), c = e - G9;
  return c / 1e3;
}
var hn = {
  nextTick: O9,
  title: _9,
  browser: P9,
  env: k9,
  argv: B9,
  version: M9,
  versions: N9,
  on: z9,
  addListener: C9,
  once: D9,
  off: U9,
  removeListener: F9,
  removeAllListeners: H9,
  emit: L9,
  binding: K9,
  cwd: V9,
  chdir: $9,
  umask: j9,
  hrtime: X9,
  platform: R9,
  release: q9,
  config: T9,
  uptime: J9
}, Xn;
typeof Object.create == "function" ? Xn = function(c, l) {
  c.super_ = l, c.prototype = Object.create(l.prototype, {
    constructor: {
      value: c,
      enumerable: !1,
      writable: !0,
      configurable: !0
    }
  });
} : Xn = function(c, l) {
  c.super_ = l;
  var w = function() {
  };
  w.prototype = l.prototype, c.prototype = new w(), c.prototype.constructor = c;
};
var r7 = Object.getOwnPropertyDescriptors || function(c) {
  for (var l = Object.keys(c), w = {}, m = 0; m < l.length; m++)
    w[l[m]] = Object.getOwnPropertyDescriptor(c, l[m]);
  return w;
}, W9 = /%[sdj%]/g;
function Zs(e) {
  if (!Zn(e)) {
    for (var c = [], l = 0; l < arguments.length; l++)
      c.push(Mr(arguments[l]));
    return c.join(" ");
  }
  for (var l = 1, w = arguments, m = w.length, f = String(e).replace(W9, function(u) {
    if (u === "%%") return "%";
    if (l >= m) return u;
    switch (u) {
      case "%s":
        return String(w[l++]);
      case "%d":
        return Number(w[l++]);
      case "%j":
        try {
          return JSON.stringify(w[l++]);
        } catch {
          return "[Circular]";
        }
      default:
        return u;
    }
  }), n = w[l]; l < m; n = w[++l])
    Wn(n) || !Fi(n) ? f += " " + n : f += " " + Mr(n);
  return f;
}
function gl(e, c) {
  if (Kr(zi.process))
    return function() {
      return gl(e, c).apply(this, arguments);
    };
  if (hn.noDeprecation === !0)
    return e;
  var l = !1;
  function w() {
    if (!l) {
      if (hn.throwDeprecation)
        throw new Error(c);
      hn.traceDeprecation ? console.trace(c) : console.error(c), l = !0;
    }
    return e.apply(this, arguments);
  }
  return w;
}
var gs = {}, ha;
function i7(e) {
  if (Kr(ha) && (ha = hn.env.NODE_DEBUG || ""), e = e.toUpperCase(), !gs[e])
    if (new RegExp("\\b" + e + "\\b", "i").test(ha)) {
      var c = 0;
      gs[e] = function() {
        var l = Zs.apply(null, arguments);
        console.error("%s %d: %s", e, c, l);
      };
    } else
      gs[e] = function() {
      };
  return gs[e];
}
function Mr(e, c) {
  var l = {
    seen: [],
    stylize: Q9
  };
  return arguments.length >= 3 && (l.depth = arguments[2]), arguments.length >= 4 && (l.colors = arguments[3]), Qs(c) ? l.showHidden = c : c && vl(l, c), Kr(l.showHidden) && (l.showHidden = !1), Kr(l.depth) && (l.depth = 2), Kr(l.colors) && (l.colors = !1), Kr(l.customInspect) && (l.customInspect = !0), l.colors && (l.stylize = Z9), Hs(l, e, l.depth);
}
Mr.colors = {
  bold: [1, 22],
  italic: [3, 23],
  underline: [4, 24],
  inverse: [7, 27],
  white: [37, 39],
  grey: [90, 39],
  black: [30, 39],
  blue: [34, 39],
  cyan: [36, 39],
  green: [32, 39],
  magenta: [35, 39],
  red: [31, 39],
  yellow: [33, 39]
};
Mr.styles = {
  special: "cyan",
  number: "yellow",
  boolean: "yellow",
  undefined: "grey",
  null: "bold",
  string: "green",
  date: "magenta",
  // "name": intentionally not styling
  regexp: "red"
};
function Z9(e, c) {
  var l = Mr.styles[c];
  return l ? "\x1B[" + Mr.colors[l][0] + "m" + e + "\x1B[" + Mr.colors[l][1] + "m" : e;
}
function Q9(e, c) {
  return e;
}
function eg(e) {
  var c = {};
  return e.forEach(function(l, w) {
    c[l] = !0;
  }), c;
}
function Hs(e, c, l) {
  if (e.customInspect && c && Ti(c.inspect) && // Filter out the util module, it's inspect function is special
  c.inspect !== Mr && // Also filter out any prototype objects using the circular check.
  !(c.constructor && c.constructor.prototype === c)) {
    var w = c.inspect(l, e);
    return Zn(w) || (w = Hs(e, w, l)), w;
  }
  var m = tg(e, c);
  if (m)
    return m;
  var f = Object.keys(c), n = eg(f);
  if (e.showHidden && (f = Object.getOwnPropertyNames(c)), ln(c) && (f.indexOf("message") >= 0 || f.indexOf("description") >= 0))
    return la(c);
  if (f.length === 0) {
    if (Ti(c)) {
      var u = c.name ? ": " + c.name : "";
      return e.stylize("[Function" + u + "]", "special");
    }
    if (qi(c))
      return e.stylize(RegExp.prototype.toString.call(c), "regexp");
    if (bn(c))
      return e.stylize(Date.prototype.toString.call(c), "date");
    if (ln(c))
      return la(c);
  }
  var o = "", s = !1, i = ["{", "}"];
  if (xl(c) && (s = !0, i = ["[", "]"]), Ti(c)) {
    var p = c.name ? ": " + c.name : "";
    o = " [Function" + p + "]";
  }
  if (qi(c) && (o = " " + RegExp.prototype.toString.call(c)), bn(c) && (o = " " + Date.prototype.toUTCString.call(c)), ln(c) && (o = " " + la(c)), f.length === 0 && (!s || c.length == 0))
    return i[0] + o + i[1];
  if (l < 0)
    return qi(c) ? e.stylize(RegExp.prototype.toString.call(c), "regexp") : e.stylize("[Object]", "special");
  e.seen.push(c);
  var g;
  return s ? g = rg(e, c, l, n, f) : g = f.map(function(S) {
    return nl(e, c, l, n, S, s);
  }), e.seen.pop(), ig(g, o, i);
}
function tg(e, c) {
  if (Kr(c))
    return e.stylize("undefined", "undefined");
  if (Zn(c)) {
    var l = "'" + JSON.stringify(c).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
    return e.stylize(l, "string");
  }
  if (wl(c))
    return e.stylize("" + c, "number");
  if (Qs(c))
    return e.stylize("" + c, "boolean");
  if (Wn(c))
    return e.stylize("null", "null");
}
function la(e) {
  return "[" + Error.prototype.toString.call(e) + "]";
}
function rg(e, c, l, w, m) {
  for (var f = [], n = 0, u = c.length; n < u; ++n)
    f7(c, String(n)) ? f.push(nl(
      e,
      c,
      l,
      w,
      String(n),
      !0
    )) : f.push("");
  return m.forEach(function(o) {
    o.match(/^\d+$/) || f.push(nl(
      e,
      c,
      l,
      w,
      o,
      !0
    ));
  }), f;
}
function nl(e, c, l, w, m, f) {
  var n, u, o;
  if (o = Object.getOwnPropertyDescriptor(c, m) || { value: c[m] }, o.get ? o.set ? u = e.stylize("[Getter/Setter]", "special") : u = e.stylize("[Getter]", "special") : o.set && (u = e.stylize("[Setter]", "special")), f7(w, m) || (n = "[" + m + "]"), u || (e.seen.indexOf(o.value) < 0 ? (Wn(l) ? u = Hs(e, o.value, null) : u = Hs(e, o.value, l - 1), u.indexOf(`
`) > -1 && (f ? u = u.split(`
`).map(function(s) {
    return "  " + s;
  }).join(`
`).substr(2) : u = `
` + u.split(`
`).map(function(s) {
    return "   " + s;
  }).join(`
`))) : u = e.stylize("[Circular]", "special")), Kr(n)) {
    if (f && m.match(/^\d+$/))
      return u;
    n = JSON.stringify("" + m), n.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (n = n.substr(1, n.length - 2), n = e.stylize(n, "name")) : (n = n.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), n = e.stylize(n, "string"));
  }
  return n + ": " + u;
}
function ig(e, c, l) {
  var w = e.reduce(function(m, f) {
    return f.indexOf(`
`) >= 0, m + f.replace(/\u001b\[\d\d?m/g, "").length + 1;
  }, 0);
  return w > 60 ? l[0] + (c === "" ? "" : c + `
 `) + " " + e.join(`,
  `) + " " + l[1] : l[0] + c + " " + e.join(", ") + " " + l[1];
}
function xl(e) {
  return Array.isArray(e);
}
function Qs(e) {
  return typeof e == "boolean";
}
function Wn(e) {
  return e === null;
}
function n7(e) {
  return e == null;
}
function wl(e) {
  return typeof e == "number";
}
function Zn(e) {
  return typeof e == "string";
}
function s7(e) {
  return typeof e == "symbol";
}
function Kr(e) {
  return e === void 0;
}
function qi(e) {
  return Fi(e) && yl(e) === "[object RegExp]";
}
function Fi(e) {
  return typeof e == "object" && e !== null;
}
function bn(e) {
  return Fi(e) && yl(e) === "[object Date]";
}
function ln(e) {
  return Fi(e) && (yl(e) === "[object Error]" || e instanceof Error);
}
function Ti(e) {
  return typeof e == "function";
}
function Ls(e) {
  return e === null || typeof e == "boolean" || typeof e == "number" || typeof e == "string" || typeof e == "symbol" || // ES6 symbol
  typeof e > "u";
}
function o7(e) {
  return Ce.isBuffer(e);
}
function yl(e) {
  return Object.prototype.toString.call(e);
}
function da(e) {
  return e < 10 ? "0" + e.toString(10) : e.toString(10);
}
var ng = [
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "May",
  "Jun",
  "Jul",
  "Aug",
  "Sep",
  "Oct",
  "Nov",
  "Dec"
];
function sg() {
  var e = /* @__PURE__ */ new Date(), c = [
    da(e.getHours()),
    da(e.getMinutes()),
    da(e.getSeconds())
  ].join(":");
  return [e.getDate(), ng[e.getMonth()], c].join(" ");
}
function a7() {
  console.log("%s - %s", sg(), Zs.apply(null, arguments));
}
function vl(e, c) {
  if (!c || !Fi(c)) return e;
  for (var l = Object.keys(c), w = l.length; w--; )
    e[l[w]] = c[l[w]];
  return e;
}
function f7(e, c) {
  return Object.prototype.hasOwnProperty.call(e, c);
}
var Pi = typeof Symbol < "u" ? Symbol("util.promisify.custom") : void 0;
function Sl(e) {
  if (typeof e != "function")
    throw new TypeError('The "original" argument must be of type Function');
  if (Pi && e[Pi]) {
    var c = e[Pi];
    if (typeof c != "function")
      throw new TypeError('The "util.promisify.custom" argument must be of type Function');
    return Object.defineProperty(c, Pi, {
      value: c,
      enumerable: !1,
      writable: !1,
      configurable: !0
    }), c;
  }
  function c() {
    for (var l, w, m = new Promise(function(u, o) {
      l = u, w = o;
    }), f = [], n = 0; n < arguments.length; n++)
      f.push(arguments[n]);
    f.push(function(u, o) {
      u ? w(u) : l(o);
    });
    try {
      e.apply(this, f);
    } catch (u) {
      w(u);
    }
    return m;
  }
  return Object.setPrototypeOf(c, Object.getPrototypeOf(e)), Pi && Object.defineProperty(c, Pi, {
    value: c,
    enumerable: !1,
    writable: !1,
    configurable: !0
  }), Object.defineProperties(
    c,
    r7(e)
  );
}
Sl.custom = Pi;
function og(e, c) {
  if (!e) {
    var l = new Error("Promise was rejected with a falsy value");
    l.reason = e, e = l;
  }
  return c(e);
}
function c7(e) {
  if (typeof e != "function")
    throw new TypeError('The "original" argument must be of type Function');
  function c() {
    for (var l = [], w = 0; w < arguments.length; w++)
      l.push(arguments[w]);
    var m = l.pop();
    if (typeof m != "function")
      throw new TypeError("The last argument must be of type Function");
    var f = this, n = function() {
      return m.apply(f, arguments);
    };
    e.apply(this, l).then(
      function(u) {
        hn.nextTick(n.bind(null, null, u));
      },
      function(u) {
        hn.nextTick(og.bind(null, u, n));
      }
    );
  }
  return Object.setPrototypeOf(c, Object.getPrototypeOf(e)), Object.defineProperties(c, r7(e)), c;
}
var ag = {
  inherits: Xn,
  _extend: vl,
  log: a7,
  isBuffer: o7,
  isPrimitive: Ls,
  isFunction: Ti,
  isError: ln,
  isDate: bn,
  isObject: Fi,
  isRegExp: qi,
  isUndefined: Kr,
  isSymbol: s7,
  isString: Zn,
  isNumber: wl,
  isNullOrUndefined: n7,
  isNull: Wn,
  isBoolean: Qs,
  isArray: xl,
  inspect: Mr,
  deprecate: gl,
  format: Zs,
  debuglog: i7,
  promisify: Sl,
  callbackify: c7
}, fg = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  _extend: vl,
  callbackify: c7,
  debuglog: i7,
  default: ag,
  deprecate: gl,
  format: Zs,
  inherits: Xn,
  inspect: Mr,
  isArray: xl,
  isBoolean: Qs,
  isBuffer: o7,
  isDate: bn,
  isError: ln,
  isFunction: Ti,
  isNull: Wn,
  isNullOrUndefined: n7,
  isNumber: wl,
  isObject: Fi,
  isPrimitive: Ls,
  isRegExp: qi,
  isString: Zn,
  isSymbol: s7,
  isUndefined: Kr,
  log: a7,
  promisify: Sl
}), u7 = /* @__PURE__ */ hl(fg);
/*!
 * custom.js - custom inspect symbol for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var md;
function h7() {
  if (md) return ua;
  md = 1;
  const { inspect: e } = u7;
  return ua.custom = e.custom || "inspect", ua;
}
/*!
 * bn.js - big numbers for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/bn.js:
 *   Copyright (c) 2015, Fedor Indutny (MIT License).
 *   https://github.com/indutny/bn.js
 *
 * Parts of this software are based on golang/go:
 *   Copyright (c) 2009, The Go Authors. All rights reserved.
 *   https://github.com/golang/go
 *
 * Parts of this software are based on openssl/openssl:
 *   Copyright (c) 1998-2018, The OpenSSL Project (Apache License v2.0).
 *   Copyright (c) 1995-1998, Eric A. Young, Tim J. Hudson. All rights reserved.
 *   https://github.com/openssl/openssl
 *
 * Parts of this software are based on libgmp:
 *   Copyright (c) 1991-1997, 1999-2014, Free Software Foundation, Inc.
 *   https://gmplib.org/
 *
 * Parts of this software are based on v8/v8:
 *   Copyright (c) 2017, The V8 Project Authors (BSD-Style License).
 *   https://github.com/v8/v8
 *
 * Resources:
 *   https://github.com/indutny/bn.js/blob/master/lib/bn.js
 *   https://github.com/indutny/miller-rabin/blob/master/lib/mr.js
 *   https://github.com/golang/go/blob/master/src/math/big/int.go
 *   https://github.com/golang/go/blob/master/src/math/big/nat.go
 *   https://github.com/golang/go/blob/master/src/math/big/prime.go
 *   https://github.com/openssl/openssl/tree/master/crypto/bn
 *   https://github.com/openssl/openssl/blob/master/crypto/bn/bn_kron.c
 *   https://github.com/gnutls/nettle/blob/master/mini-gmp.c
 *   https://github.com/v8/v8/blob/master/src/objects/bigint.cc
 */
var ba, gd;
function jr() {
  if (gd) return ba;
  gd = 1;
  const { custom: e } = h7(), c = [
    "",
    "0",
    "00",
    "000",
    "0000",
    "00000",
    "000000",
    "0000000",
    "00000000",
    "000000000",
    "0000000000",
    "00000000000",
    "000000000000",
    "0000000000000",
    "00000000000000",
    "000000000000000",
    "0000000000000000",
    "00000000000000000",
    "000000000000000000",
    "0000000000000000000",
    "00000000000000000000",
    "000000000000000000000",
    "0000000000000000000000",
    "00000000000000000000000",
    "000000000000000000000000",
    "0000000000000000000000000"
  ], l = [
    0,
    25,
    16,
    12,
    11,
    10,
    9,
    8,
    8,
    7,
    7,
    7,
    7,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5
  ], w = [
    0,
    33554432,
    43046721,
    16777216,
    48828125,
    60466176,
    40353607,
    16777216,
    43046721,
    1e7,
    19487171,
    35831808,
    62748517,
    7529536,
    11390625,
    16777216,
    24137569,
    34012224,
    47045881,
    64e6,
    4084101,
    5153632,
    6436343,
    7962624,
    9765625,
    11881376,
    14348907,
    17210368,
    20511149,
    243e5,
    28629151,
    33554432,
    39135393,
    45435424,
    52521875,
    60466176
  ], m = {
    p192: null,
    p224: null,
    p521: null,
    k256: null,
    p251: null,
    p25519: null,
    p448: null
  }, f = {
    NONE: 0,
    QUO: 1,
    REM: 2,
    BOTH: 3,
    EUCLID: 4,
    ALL: 7
  }, n = 4, u = 1 << n - 1, o = typeof BigInt == "function";
  class s {
    constructor(t, d, B) {
      this.words = [0], this.length = 1, this.negative = 0, this.red = null, this.from(t, d, B);
    }
    /*
     * Addition Engine
     */
    _iadd(t, d) {
      let B = 0, U = 0;
      for (t.length < d.length && ([t, d] = [d, t]), t !== this && this._alloc(t.length); U < d.length; U++) {
        const J = (t.words[U] | 0) + (d.words[U] | 0) + B;
        this.words[U] = J & 67108863, B = J >>> 26;
      }
      for (; B !== 0 && U < t.length; U++) {
        const J = (t.words[U] | 0) + B;
        this.words[U] = J & 67108863, B = J >>> 26;
      }
      if (this.length = t.length, B !== 0)
        this._alloc(this.length + 1), this.words[this.length++] = B;
      else if (t !== this)
        for (; U < t.length; U++)
          this.words[U] = t.words[U];
      return this;
    }
    _iaddn(t) {
      if (this.words[0] += t, this.words[0] < 67108864)
        return this;
      let d = 0;
      for (this._alloc(this.length + 1), this.words[this.length] = 0; d < this.length && this.words[d] >= 67108864; d++)
        this.words[d] -= 67108864, this.words[d + 1] += 1;
      return this.length = Math.max(this.length, d + 1), this;
    }
    /*
     * Addition
     */
    iadd(t) {
      if (_(s.isBN(t), "num", "bignum"), this.negative === t.negative)
        this._iadd(this, t);
      else {
        const d = this.ucmp(t);
        if (d === 0)
          return this.words[0] = 0, this.length = 1, this.negative = 0, this;
        d < 0 ? (this._isub(t, this), this.negative ^= 1) : this._isub(this, t);
      }
      return this;
    }
    iaddn(t) {
      _(D(t), "num", "smi");
      const d = t < 0 | 0;
      return d && (t = -t), this.negative === d ? this._iaddn(t) : this.length === 1 && this.words[0] < t ? (this.words[0] = t - this.words[0], this.negative ^= 1) : this._isubn(t), this;
    }
    add(t) {
      return _(s.isBN(t), "num", "bignum"), t.length > this.length ? t.clone().iadd(this) : this.clone().iadd(t);
    }
    addn(t) {
      return this.clone().iaddn(t);
    }
    /*
     * Subtraction Engine
     */
    _isub(t, d) {
      let B = 0, U = 0;
      for (q(t.length >= d.length), t !== this && this._alloc(t.length); U < d.length; U++) {
        const J = (t.words[U] | 0) - (d.words[U] | 0) + B;
        B = J >> 26, this.words[U] = J & 67108863;
      }
      for (; B !== 0 && U < t.length; U++) {
        const J = (t.words[U] | 0) + B;
        B = J >> 26, this.words[U] = J & 67108863;
      }
      if (q(B === 0), t !== this)
        for (; U < t.length; U++)
          this.words[U] = t.words[U];
      return this.length = Math.max(this.length, U), this._strip();
    }
    _isubn(t) {
      if (this.words[0] -= t, this.words[0] >= 0)
        return this._normalize();
      q(this.length !== 1), this._alloc(this.length + 1);
      for (let d = 0; d < this.length && this.words[d] < 0; d++)
        this.words[d] += 67108864, this.words[d + 1] -= 1;
      return this.words[this.length] = 0, this._strip();
    }
    /*
     * Subtraction
     */
    isub(t) {
      if (_(s.isBN(t), "num", "bignum"), this.negative !== t.negative)
        this._iadd(this, t);
      else {
        const d = this.ucmp(t);
        if (d === 0)
          return this.words[0] = 0, this.length = 1, this.negative = 0, this;
        d < 0 ? (this._isub(t, this), this.negative ^= 1) : this._isub(this, t);
      }
      return this;
    }
    isubn(t) {
      _(D(t), "num", "smi");
      const d = t < 0 | 0;
      return d && (t = -t), this.negative !== d ? this._iaddn(t) : this.length === 1 && this.words[0] < t ? (this.words[0] = t - this.words[0], this.negative ^= 1) : this._isubn(t), this;
    }
    sub(t) {
      return this.clone().isub(t);
    }
    subn(t) {
      return this.clone().isubn(t);
    }
    /*
     * Multiplication Engine
     */
    _mul(t, d) {
      if (_(s.isBN(t), "num", "bignum"), _(s.isBN(d), "out", "bignum"), this.length === 10 && t.length === 10)
        return I(this, t, d);
      const B = this.length + t.length;
      return B < 63 ? Ee(this, t, d) : B < 1024 ? we(this, t, d) : z(this, t, d);
    }
    /*
     * Multiplication
     */
    imul(t) {
      return this.mul(t)._move(this);
    }
    imuln(t) {
      _(D(t), "num", "smi");
      const d = t < 0 | 0;
      d && (t = -t);
      let B = 0;
      for (let U = 0; U < this.length; U++) {
        const J = this.words[U] * t, C = (J & 67108863) + (B & 67108863);
        B >>= 26, B += J / 67108864 | 0, B += C >>> 26, this.words[U] = C & 67108863;
      }
      return this.negative ^= d, B !== 0 ? (this._alloc(this.length + 1), this.words[this.length++] = B) : this._strip(), this;
    }
    mul(t) {
      _(s.isBN(t), "num", "bignum");
      const d = this.length + t.length, B = new s();
      B.words = new Array(d);
      for (let U = 0; U < d; U++)
        B.words[U] = 0;
      return this._mul(t, B);
    }
    muln(t) {
      return this.clone().imuln(t);
    }
    /*
     * Multiplication + Shift
     */
    mulShift(t, d) {
      _(s.isBN(t), "num", "bignum"), _(d >>> 0 === d, "bits", "uint32");
      const B = this.mul(t), U = B.utestn(d - 1);
      return B.iushrn(d), this.negative ^ t.negative ? B.isubn(U) : B.iaddn(U);
    }
    /*
     * Division Engine
     */
    _div(t, d) {
      _(s.isBN(t), "num", "bignum"), q((d & f.ALL) === d), q(d !== f.NONE);
      const B = this, U = t;
      if (fe(!U.isZero()), B.isZero())
        return [new s(0), new s(0)];
      const J = B.negative, C = U.negative;
      B.negative = 0, U.negative = 0;
      let M = null, $ = null;
      return B.ucmp(U) < 0 ? (d & f.QUO && (M = new s(0)), d & f.REM && ($ = B.clone())) : U.length === 1 ? (d & f.QUO && (M = B.quon(U.words[0])), d & f.REM && ($ = B.remn(U.words[0]))) : [M, $] = B._wordDiv(U, d), B.negative = J, U.negative = C, d & f.QUO && (M.negative = B.negative ^ U.negative, M._normalize()), d & f.REM && ($.negative = B.negative, $._normalize()), d & f.EUCLID && (d & f.QUO && (q((d & f.REM) !== 0), $.negative !== 0 && (U.negative !== 0 ? M.iaddn(1) : M.isubn(1))), d & f.REM && $.negative !== 0 && (U.negative !== 0 ? $.isub(U) : $.iadd(U))), [M, $];
    }
    _wordDiv(t, d) {
      let B = this.clone(), U = t, J = null, C;
      const M = U.words[U.length - 1] | 0, $ = 26 - oe(M);
      $ !== 0 ? (U = U.clone(), B.iushln($), U.iushln($), C = U.words[U.length - 1] | 0) : C = M;
      const r = B.length - U.length;
      if (q(r >= 0), d & f.QUO) {
        J = new s(0), J.length = r + 1, J.words = new Array(J.length);
        for (let O = 0; O < J.length; O++)
          J.words[O] = 0;
      }
      const x = B.clone();
      x._ishlnsubmul(U, 1, r), x.negative === 0 && (J && (J.words[r] = 1), B = x);
      for (let O = r - 1; O >= 0; O--) {
        const K = B.words[U.length + O], X = B.words[U.length + O - 1], P = (K * 67108864 + X) / C | 0;
        let V = Math.min(P, 67108863);
        for (B._ishlnsubmul(U, V, O); B.negative !== 0; )
          V -= 1, B.negative = 0, B._ishlnsubmul(U, 1, O), B.ineg();
        J && (J.words[O] = V);
      }
      return J && J._strip(), d & f.REM && $ !== 0 && B.iushrn($), [J, B];
    }
    _ishlnsubmul(t, d, B) {
      let U = 0, J = 0;
      for (this._expand(t.length + B); J < t.length; J++) {
        const C = (this.words[J + B] | 0) + U, M = t.words[J] * d, $ = C - (M & 67108863);
        U = ($ >> 26) - (M / 67108864 | 0), this.words[J + B] = $ & 67108863;
      }
      for (; J < this.length - B; J++) {
        const C = (this.words[J + B] | 0) + U;
        U = C >> 26, this.words[J + B] = C & 67108863;
      }
      if (U === 0)
        return this._strip();
      q(U === -1), U = 0;
      for (let C = 0; C < this.length; C++) {
        const M = -(this.words[C] | 0) + U;
        U = M >> 26, this.words[C] = M & 67108863;
      }
      return this.negative = 1, this._strip();
    }
    /*
     * Truncation Division + Modulo
     */
    quorem(t) {
      return this._div(t, f.BOTH);
    }
    /*
     * Truncation Division
     */
    iquo(t) {
      return this.quo(t)._move(this);
    }
    iquon(t) {
      _(D(t), "num", "smi"), fe(t !== 0);
      const d = t < 0 | 0;
      d && (t = -t);
      let B = 0;
      for (let U = this.length - 1; U >= 0; U--) {
        const J = (this.words[U] | 0) + B * 67108864;
        this.words[U] = J / t | 0, B = J % t;
      }
      return this.negative ^= d, this._strip();
    }
    quo(t) {
      return this._div(t, f.QUO)[0];
    }
    quon(t) {
      return this.clone().iquon(t);
    }
    /*
     * Truncation Modulo
     */
    irem(t) {
      return this.rem(t)._move(this);
    }
    iremn(t) {
      let d = this.remrn(t);
      return d < 0 && (d = -d), this.words[0] = d, this.length = 1, this._normalize();
    }
    rem(t) {
      return this._div(t, f.REM)[1];
    }
    remn(t) {
      return this.clone().iremn(t);
    }
    remrn(t) {
      _(D(t), "num", "smi"), fe(t !== 0), t < 0 && (t = -t);
      const d = (1 << 26) % t;
      let B = 0;
      for (let U = this.length - 1; U >= 0; U--)
        B = (d * B + (this.words[U] | 0)) % t;
      return this.negative !== 0 ? -B | 0 : B;
    }
    /*
     * Euclidean Division + Modulo
     */
    divmod(t) {
      return this._div(t, f.BOTH | f.EUCLID);
    }
    /*
     * Euclidean Division
     */
    idiv(t) {
      return this.div(t)._move(this);
    }
    idivn(t) {
      if (this.negative === 0)
        return this.iquon(t);
      const d = this.remrn(t);
      return this.iquon(t), d < 0 && (t < 0 ? this.iaddn(1) : this.isubn(1)), this;
    }
    div(t) {
      return this._div(t, f.BOTH | f.EUCLID)[0];
    }
    divn(t) {
      return this.clone().idivn(t);
    }
    /*
     * Euclidean Modulo
     */
    imod(t) {
      return this.ucmp(t) < 0 ? (this.negative !== 0 && (this._isub(t, this), this.negative = 0), this) : this.mod(t)._move(this);
    }
    imodn(t) {
      return this.words[0] = this.modrn(t), this.length = 1, this.negative = 0, this;
    }
    mod(t) {
      return this._div(t, f.REM | f.EUCLID)[1];
    }
    modn(t) {
      return this.clone().imodn(t);
    }
    modrn(t) {
      _(D(t), "num", "smi");
      let d = this.remrn(t);
      return d < 0 && (t < 0 ? d -= t : d += t), d;
    }
    /*
     * Round Division
     */
    divRound(t) {
      const [d, B] = this.quorem(t);
      if (B.isZero())
        return d;
      const U = t.words[0] & 1;
      t.iushrn(1);
      const J = B.ucmp(t);
      return t.iushln(1), t.words[0] |= U, J < 0 || t.isOdd() && J === 0 ? d : this.negative ^ t.negative ? d.isubn(1) : d.iaddn(1);
    }
    /*
     * Exponentiation
     */
    ipow(t) {
      return this.pow(t)._move(this);
    }
    ipown(t) {
      return this.pown(t)._move(this);
    }
    pow(t) {
      _(s.isBN(t), "num", "bignum");
      let d = oe(t.words[t.length - 1]), B = new s(1);
      for (let U = t.length - 1; U >= 0; U--) {
        const J = t.words[U];
        for (let C = d - 1; C >= 0; C--)
          B = B.sqr(), J >> C & 1 && (B = B.mul(this));
        d = 26;
      }
      return B;
    }
    pown(t) {
      if (_(D(t), "num", "smi"), t < 0 && (t = -t), t === 0)
        return new s(1);
      if (t === 1)
        return this.clone();
      const d = oe(t);
      let B = this;
      for (let U = d - 2; U >= 0; U--)
        B = B.sqr(), t >> U & 1 && (B = B.mul(this));
      return B;
    }
    isqr() {
      return this.imul(this);
    }
    sqr() {
      return this.mul(this);
    }
    /*
     * Roots Engine
     */
    _rootrem(t, d) {
      if (_(t >>> 0 === t, "num", "uint32"), t === 0)
        throw new RangeError("Zeroth root.");
      if (~t & this.negative)
        throw new RangeError("Negative with even root.");
      if (this.ucmpn(1) <= 0)
        return [this.clone(), new s(0)];
      let B = new s(0), U = s.shift(1, this.bitLength() / t + 1 | 0), J, C;
      if (this.negative !== 0 && U.ineg(), t === 2)
        do
          B = U, U = this.quo(B), U.iadd(B), U.iushrn(1);
        while (U.ucmp(B) < 0);
      else
        do
          B = U, U = B.pown(t - 1), U = this.quo(U), J = B.muln(t - 1), U.iadd(J), U = U.quon(t);
        while (U.ucmp(B) < 0);
      return d && (U = B.pown(t), C = this.sub(U)), [B, C];
    }
    /*
     * Roots
     */
    rootrem(t) {
      return this._rootrem(t, 1);
    }
    iroot(t) {
      return this.root(t)._move(this);
    }
    root(t) {
      return this._rootrem(t, 0)[0];
    }
    isPower(t) {
      if (_(t >>> 0 === t, "num", "uint32"), t === 0 || ~t & this.negative)
        return !1;
      const [, d] = this.rootrem(t);
      return d.sign() === 0;
    }
    sqrtrem() {
      return this.rootrem(2);
    }
    isqrt() {
      return this.sqrt()._move(this);
    }
    sqrt() {
      return this.root(2);
    }
    isSquare() {
      return this.isPower(2);
    }
    /*
     * AND
     */
    iand(t) {
      _(s.isBN(t), "num", "bignum");
      let d = this, B = t;
      if (d === B)
        return d;
      if ((d.negative | B.negative) === 0)
        return d.iuand(B);
      if ((d.negative & B.negative) === 1)
        return d.iaddn(1), B.iaddn(1), d.iuor(B), d.isubn(1), B.isubn(1), d;
      d.negative !== 0 && ([d, B] = [B.clone(), d]);
      const U = d.bitLength();
      return B.iaddn(1), B.inotn(U), d.iuand(B), B.inotn(U), B.isubn(1), d._move(this);
    }
    iandn(t) {
      return _(D(t), "num", "smi"), (this.negative | t < 0) !== 0 ? this.iand(new s(t)) : (this.words[0] &= t, this.length = 1, this);
    }
    and(t) {
      return this.clone().iand(t);
    }
    andn(t) {
      return this.clone().iandn(t);
    }
    andrn(t) {
      if (_(D(t), "num", "smi"), (this.negative | t < 0) !== 0) {
        const d = this.iand(new s(t));
        if (d.length > 1)
          throw new RangeError("Number exceeds 26 bits.");
        return d.negative !== 0 ? -d.words[0] : d.words[0];
      }
      return this.words[0] & t;
    }
    /*
     * Unsigned AND
     */
    iuand(t) {
      _(s.isBN(t), "num", "bignum"), this.length = Math.min(this.length, t.length);
      for (let d = 0; d < this.length; d++)
        this.words[d] &= t.words[d];
      return this._strip();
    }
    iuandn(t) {
      return _(D(t), "num", "smi"), this.words[0] &= Math.abs(t), this.length = 1, this._normalize();
    }
    uand(t) {
      return this.clone().iuand(t);
    }
    uandn(t) {
      return this.clone().iuandn(t);
    }
    uandrn(t) {
      _(D(t), "num", "smi");
      const d = this.words[0] & Math.abs(t);
      return this.negative !== 0 ? -d | 0 : d;
    }
    /*
     * OR
     */
    ior(t) {
      _(s.isBN(t), "num", "bignum");
      let d = this, B = t;
      return d === B ? d : (d.negative | B.negative) === 0 ? d.iuor(B) : (d.negative & B.negative) === 1 ? (d.iaddn(1), B.iaddn(1), d.iuand(B), d.isubn(1), B.isubn(1), d) : (B = B.clone(), d.negative !== 0 && ([d, B] = [B, d]), B.iaddn(1), d.inotn(B.bitLength()), B.iuand(d), B.isubn(1), B._move(this));
    }
    iorn(t) {
      return _(D(t), "num", "smi"), (this.negative | t < 0) !== 0 ? this.ior(new s(t)) : (this.words[0] |= t, this);
    }
    or(t) {
      return this.clone().ior(t);
    }
    orn(t) {
      return this.clone().iorn(t);
    }
    /*
     * Unsigned OR
     */
    iuor(t) {
      _(s.isBN(t), "num", "bignum"), this._expand(t.length);
      for (let d = 0; d < t.length; d++)
        this.words[d] |= t.words[d];
      return this;
    }
    iuorn(t) {
      return _(D(t), "num", "smi"), this.words[0] |= Math.abs(t), this;
    }
    uor(t) {
      return this.clone().iuor(t);
    }
    uorn(t) {
      return this.clone().iuorn(t);
    }
    /*
     * XOR
     */
    ixor(t) {
      _(s.isBN(t), "num", "bignum");
      let d = this, B = t;
      return d === B ? (d.words[0] = 0, d.length = 1, d.negative = 0, d) : (d.negative | B.negative) === 0 ? d.iuxor(B) : (d.negative & B.negative) === 1 ? (d.iaddn(1), B.iaddn(1), d.iuxor(B), d.ineg(), B.isubn(1), d) : (d.negative !== 0 && ([d, B] = [B.clone(), d]), B.iaddn(1), d.iuxor(B), d.iaddn(1), d.ineg(), B.isubn(1), d._move(this));
    }
    ixorn(t) {
      return _(D(t), "num", "smi"), (this.negative | t < 0) !== 0 ? this.ixor(new s(t)) : (this.words[0] ^= t, this);
    }
    xor(t) {
      return this.clone().ixor(t);
    }
    xorn(t) {
      return this.clone().ixorn(t);
    }
    /*
     * Unsigned XOR
     */
    iuxor(t) {
      _(s.isBN(t), "num", "bignum");
      let d = this, B = t;
      d.length < B.length && ([d, B] = [B, d]);
      let U = 0;
      for (; U < B.length; U++)
        this.words[U] = d.words[U] ^ B.words[U];
      if (d !== this)
        for (this._alloc(d.length); U < d.length; U++)
          this.words[U] = d.words[U];
      return this.length = d.length, this._strip();
    }
    iuxorn(t) {
      return _(D(t), "num", "smi"), this.words[0] ^= Math.abs(t), this._normalize();
    }
    uxor(t) {
      return this.clone().iuxor(t);
    }
    uxorn(t) {
      return this.clone().iuxorn(t);
    }
    /*
     * NOT
     */
    inot() {
      return this.negative !== 0 ? this.ineg().isubn(1) : this.iaddn(1).ineg(), this;
    }
    not() {
      return this.clone().inot();
    }
    inotn(t) {
      _(t >>> 0 === t, "width", "uint32");
      const d = t % 26;
      let B = Math.ceil(t / 26), U = 0;
      for (this._expand(B), d > 0 && (B -= 1); U < B; U++)
        this.words[U] ^= 67108863;
      return d > 0 && (this.words[U] ^= (1 << d) - 1), this._strip();
    }
    notn(t) {
      return this.clone().inotn(t);
    }
    /*
     * Left Shift
     */
    ishl(t) {
      return _(s.isBN(t), "bits", "bignum"), _(t.bitLength() <= 32, "bits", "uint32"), this.ishln(t.toNumber());
    }
    ishln(t) {
      return this.iushln(t);
    }
    shl(t) {
      return this.clone().ishl(t);
    }
    shln(t) {
      return this.clone().ishln(t);
    }
    /*
     * Unsigned Left Shift
     */
    iushl(t) {
      return _(s.isBN(t), "bits", "bignum"), _(t.bitLength() <= 32, "bits", "uint32"), this.iushln(t.toNumber());
    }
    iushln(t) {
      _(t >>> 0 === t, "bits", "uint32");
      const d = t % 26, B = (t - d) / 26, U = (1 << d) - 1 << 26 - d;
      if (d !== 0) {
        let J = 0;
        for (let C = 0; C < this.length; C++) {
          const M = this.words[C] & U, $ = (this.words[C] | 0) - M << d;
          this.words[C] = $ | J, J = M >>> 26 - d;
        }
        J !== 0 && (this._alloc(this.length + 1), this.words[this.length++] = J);
      }
      if (B !== 0) {
        this._alloc(this.length + B);
        for (let J = this.length - 1; J >= 0; J--)
          this.words[J + B] = this.words[J];
        for (let J = 0; J < B; J++)
          this.words[J] = 0;
        this.length += B;
      }
      return this._strip();
    }
    ushl(t) {
      return this.clone().iushl(t);
    }
    ushln(t) {
      return this.clone().iushln(t);
    }
    /*
     * Right Shift Engine
     */
    _split(t, d) {
      const B = t % 26, U = Math.min((t - B) / 26, this.length), J = (1 << B) - 1;
      if (d) {
        d._alloc(U);
        for (let M = 0; M < U; M++)
          d.words[M] = this.words[M];
        d.length = U;
      }
      if (U !== 0) if (this.length > U) {
        this.length -= U;
        for (let M = 0; M < this.length; M++)
          this.words[M] = this.words[M + U];
      } else
        this.words[0] = 0, this.length = 1;
      let C = 0;
      if (B !== 0)
        for (let M = this.length - 1; M >= 0; M--) {
          const $ = this.words[M] | 0;
          this.words[M] = C << 26 - B | $ >>> B, C = $ & J;
        }
      return d && (C !== 0 ? (d._alloc(d.length + 1), d.words[d.length++] = C) : (d.length === 0 && (d.words[d.length++] = 0), d._strip())), this._strip();
    }
    /*
     * Right Shift
     */
    ishr(t) {
      return _(s.isBN(t), "bits", "bignum"), _(t.bitLength() <= 32, "bits", "uint32"), this.ishrn(t.toNumber());
    }
    ishrn(t) {
      return _(t >>> 0 === t, "bits", "uint32"), this.negative !== 0 ? (this.iaddn(1), this.iushrn(t), this.isubn(1), this) : this.iushrn(t);
    }
    shr(t) {
      return this.clone().ishr(t);
    }
    shrn(t) {
      return this.clone().ishrn(t);
    }
    /*
     * Unsigned Right Shift
     */
    iushr(t) {
      return _(s.isBN(t), "bits", "bignum"), _(t.bitLength() <= 32, "bits", "uint32"), this.iushrn(t.toNumber());
    }
    iushrn(t) {
      return _(t >>> 0 === t, "bits", "uint32"), this._split(t, null);
    }
    ushr(t) {
      return this.clone().iushr(t);
    }
    ushrn(t) {
      return this.clone().iushrn(t);
    }
    /*
     * Bit Manipulation
     */
    setn(t, d) {
      return _(t >>> 0 === t, "bit", "uint32"), this.negative !== 0 ? (this.iaddn(1), this.usetn(t, !d), this.isubn(1), this) : this.usetn(t, d);
    }
    usetn(t, d) {
      _(t >>> 0 === t, "bit", "uint32");
      const B = t % 26, U = (t - B) / 26;
      return this._expand(U + 1), d ? this.words[U] |= 1 << B : this.words[U] &= ~(1 << B), this._strip();
    }
    testn(t) {
      _(t >>> 0 === t, "bit", "uint32");
      const d = t % 26, B = (t - d) / 26;
      if (this.length <= B)
        return this.negative;
      const U = this.words[B], J = U >> d & 1;
      if (this.negative !== 0) {
        if (d > 0 && U & (1 << d) - 1)
          return J ^ 1;
        let C = B;
        for (; C--; )
          if (this.words[C] > 0)
            return J ^ 1;
      }
      return J;
    }
    utestn(t) {
      _(t >>> 0 === t, "bit", "uint32");
      const d = t % 26, B = (t - d) / 26;
      return this.length <= B ? 0 : this.words[B] >> d & 1;
    }
    imaskn(t) {
      return _(t >>> 0 === t, "bits", "uint32"), this.negative !== 0 && (this.iaddn(1), this.inotn(t + 1), this.ineg()), this.iumaskn(t);
    }
    maskn(t) {
      return this.clone().imaskn(t);
    }
    iumaskn(t) {
      _(t >>> 0 === t, "bits", "uint32");
      const d = t % 26;
      let B = (t - d) / 26;
      return this.length <= B ? this : (d !== 0 && (B += 1), this.length = Math.min(B, this.length), d !== 0 && (this.words[this.length - 1] &= (1 << d) - 1), this.length === 0 && (this.words[this.length++] = 0), this._strip());
    }
    umaskn(t) {
      return this.clone().iumaskn(t);
    }
    andln(t) {
      return this.words[0] & t;
    }
    bit(t) {
      return this.utestn(t);
    }
    bits(t, d) {
      _(t >>> 0 === t, "pos", "uint32"), _(d >>> 0 === d, "width", "uint32"), _(d <= 26, "width", "width");
      const B = t % 26, U = (t - B) / 26;
      if (U >= this.length)
        return 0;
      let J = this.words[U] >> B & (1 << d) - 1;
      if (B + d > 26 && U + 1 < this.length) {
        const C = B + d - 26, M = this.words[U + 1] & (1 << C) - 1;
        J |= M << 26 - B;
      }
      return J;
    }
    /*
     * Negation
     */
    ineg() {
      return this.isZero() || (this.negative ^= 1), this;
    }
    neg() {
      return this.clone().ineg();
    }
    iabs() {
      return this.negative = 0, this;
    }
    abs() {
      return this.clone().iabs();
    }
    /*
     * Comparison
     */
    cmp(t) {
      if (_(s.isBN(t), "num", "bignum"), this.negative !== t.negative)
        return t.negative - this.negative;
      const d = this.ucmp(t);
      return this.negative !== 0 ? -d | 0 : d;
    }
    cmpn(t) {
      _(D(t), "num", "smi");
      const d = t < 0 | 0;
      if (this.negative !== d)
        return d - this.negative;
      const B = this.ucmpn(t);
      return this.negative !== 0 ? -B | 0 : B;
    }
    eq(t) {
      return this.cmp(t) === 0;
    }
    eqn(t) {
      return this.cmpn(t) === 0;
    }
    gt(t) {
      return this.cmp(t) > 0;
    }
    gtn(t) {
      return this.cmpn(t) > 0;
    }
    gte(t) {
      return this.cmp(t) >= 0;
    }
    gten(t) {
      return this.cmpn(t) >= 0;
    }
    lt(t) {
      return this.cmp(t) < 0;
    }
    ltn(t) {
      return this.cmpn(t) < 0;
    }
    lte(t) {
      return this.cmp(t) <= 0;
    }
    lten(t) {
      return this.cmpn(t) <= 0;
    }
    sign() {
      return this.negative !== 0 ? -1 : this.length === 1 && this.words[0] === 0 ? 0 : 1;
    }
    isZero() {
      return this.length === 1 && this.words[0] === 0;
    }
    isNeg() {
      return this.negative !== 0;
    }
    isPos() {
      return this.negative === 0;
    }
    isOdd() {
      return (this.words[0] & 1) === 1;
    }
    isEven() {
      return (this.words[0] & 1) === 0;
    }
    /*
     * Unsigned Comparison
     */
    ucmp(t) {
      if (_(s.isBN(t), "num", "bignum"), this.length < t.length)
        return -1;
      if (this.length > t.length)
        return 1;
      for (let d = this.length - 1; d >= 0; d--) {
        const B = this.words[d] | 0, U = t.words[d] | 0;
        if (B !== U)
          return (B > U) - (B < U);
      }
      return 0;
    }
    ucmpn(t) {
      if (_(D(t), "num", "smi"), this.length > 1)
        return 1;
      const d = this.words[0] | 0;
      return t < 0 && (t = -t), (d > t) - (d < t);
    }
    /*
     * Number Theoretic Functions
     */
    legendre(t) {
      const d = o ? s.red(t) : s.mont(t);
      return this.toRed(d).redLegendre();
    }
    jacobi(t) {
      if (_(s.isBN(t), "num", "bignum"), t.isZero() || t.isEven())
        throw new Error("jacobi: `num` must be odd.");
      let d = this._cloneNormal(), B = t.clone(), U = 1;
      for (B.isNeg() && (d.isNeg() && (U = -1), B.ineg()), (d.isNeg() || d.ucmp(B) >= 0) && d.imod(B); !d.isZero(); ) {
        if (d._makeOdd() & 1) {
          const M = B.andln(7);
          (M === 3 || M === 5) && (U = -U);
        }
        d.ucmp(B) < 0 && ([d, B] = [B, d], d.andln(3) === 3 && B.andln(3) === 3 && (U = -U)), d._isub(d, B).iushrn(1);
        const C = B.andln(7);
        (C === 3 || C === 5) && (U = -U);
      }
      return B.cmpn(1) !== 0 ? 0 : U;
    }
    kronecker(t) {
      if (_(s.isBN(t), "num", "bignum"), this.isZero())
        return t.ucmpn(1) === 0 ? 1 : 0;
      if (t.isZero())
        return this.ucmpn(1) === 0 ? 1 : 0;
      if (((this.words[0] | t.words[0]) & 1) === 0)
        return 0;
      const d = this, B = t.clone(), U = B._makeOdd(), J = [0, 1, 0, -1, 0, -1, 0, 1];
      let C = d.jacobi(B);
      return U & 1 && (C *= J[d.andln(7)]), C | 0;
    }
    igcd(t) {
      return this.gcd(t)._move(this);
    }
    gcd(t) {
      if (_(s.isBN(t), "num", "bignum"), this.isZero())
        return t.abs();
      if (t.isZero())
        return this.abs();
      let d = this.clone(), B = t.clone();
      d.negative = 0, B.negative = 0;
      const U = d._factor2(B);
      for (U !== 0 && (d.iushrn(U), B.iushrn(U)); ; ) {
        d._makeOdd(), B._makeOdd();
        const J = d.ucmp(B);
        if (J < 0)
          [d, B] = [B, d];
        else if (J === 0 || B.ucmpn(1) === 0)
          break;
        d._isub(d, B);
      }
      return B.iushln(U);
    }
    ilcm(t) {
      return this.lcm(t)._move(this);
    }
    lcm(t) {
      return _(s.isBN(t), "num", "bignum"), this.isZero() || t.isZero() ? new s(0) : this.quo(this.gcd(t)).mul(t).iabs();
    }
    egcd(t) {
      if (_(s.isBN(t), "num", "bignum"), this.isZero())
        return [
          new s(0),
          new s(t.sign()),
          t.abs()
        ];
      if (t.isZero())
        return [
          new s(this.sign()),
          new s(0),
          this.abs()
        ];
      const d = this.clone(), B = t.clone();
      d.negative = 0, B.negative = 0;
      const U = new s(1), J = new s(0), C = new s(0), M = new s(1), $ = d._factor2(B);
      $ > 0 && (d.iushrn($), B.iushrn($));
      const r = d.clone(), x = B.clone();
      for (; !d.isZero(); ) {
        let O = d._makeOdd(), K = B._makeOdd();
        for (; O--; )
          (U.isOdd() || J.isOdd()) && (U.iadd(x), J.isub(r)), U.iushrn(1), J.iushrn(1);
        for (; K--; )
          (C.isOdd() || M.isOdd()) && (C.iadd(x), M.isub(r)), C.iushrn(1), M.iushrn(1);
        d.cmp(B) >= 0 ? (d.isub(B), U.isub(C), J.isub(M)) : (B.isub(d), C.isub(U), M.isub(J));
      }
      return this.negative !== 0 && C.ineg(), t.negative !== 0 && M.ineg(), [C, M, B.iushln($)];
    }
    iinvert(t) {
      return this.invert(t)._move(this);
    }
    invert(t) {
      if (_(s.isBN(t), "num", "bignum"), F(t.sign() > 0, "invert"), t.isOdd())
        return this._invertp(t);
      if (t.cmpn(1) === 0)
        throw new RangeError("Not invertible.");
      const [d, , B] = this.egcd(t);
      if (B.cmpn(1) !== 0)
        throw new RangeError("Not invertible.");
      return d.imod(t);
    }
    ifermat(t) {
      return this.fermat(t)._move(this);
    }
    fermat(t) {
      const d = o ? s.red(t) : s.mont(t);
      return this.toRed(d).redFermat().fromRed();
    }
    ipowm(t, d, B) {
      return this.powm(t, d, B)._move(this);
    }
    powm(t, d, B) {
      const U = !o && B ? s.mont(d) : s.red(d);
      return this.toRed(U).redPow(t).fromRed();
    }
    ipowmn(t, d, B) {
      return this.powmn(t, d, B)._move(this);
    }
    powmn(t, d, B) {
      const U = B ? s.mont(d) : s.red(d);
      return this.toRed(U).redPown(t).fromRed();
    }
    isqrtm(t) {
      return this.sqrtm(t)._move(this);
    }
    sqrtm(t) {
      _(s.isBN(t), "p", "bignum");
      let d;
      return t.andln(3) === 3 || t.andln(7) === 5 ? d = s.red(t) : d = s.mont(t), this.toRed(d).redSqrt().fromRed();
    }
    isqrtpq(t, d) {
      return this.sqrtpq(t, d)._move(this);
    }
    sqrtpq(t, d) {
      const B = this.sqrtm(t), U = this.sqrtm(d), [J, C] = t.egcd(d), M = U.mul(J).mul(t), $ = B.mul(C).mul(d), r = t.mul(d);
      return M.iadd($).imod(r);
    }
    /*
     * Primality Testing
     */
    isPrime(t, d, B) {
      return _(d >>> 0 === d, "reps", "uint32"), !(!this.isPrimeMR(t, d + 1, !0) || !this.isPrimeLucas(B));
    }
    isPrimeMR(t, d, B = !1) {
      _(d >>> 0 === d, "reps", "uint32"), _(d > 0, "reps", "integer"), _(typeof B == "boolean", "force2", "boolean");
      const U = this;
      if (U.cmpn(7) < 0)
        return U.cmpn(2) === 0 || U.cmpn(3) === 0 || U.cmpn(5) === 0;
      if (U.isEven())
        return !1;
      const J = U.subn(1), C = J.subn(2), M = J.zeroBits(), $ = J.ushrn(M), r = s.red(U), x = J.toRed(r), O = new s(1).toRed(r);
      e:
        for (let K = 0; K < d; K++) {
          let X;
          K === d - 1 && B ? X = new s(2) : (X = s.random(t, 0, C), X.iaddn(2));
          let P = X.toRed(r).redPow($);
          if (!(P.cmp(O) === 0 || P.cmp(x) === 0)) {
            for (let V = 1; V < M; V++) {
              if (P = P.redSqr(), P.cmp(x) === 0)
                continue e;
              if (P.cmp(O) === 0)
                return !1;
            }
            return !1;
          }
        }
      return !0;
    }
    isPrimeLucas(t = 0) {
      _(t >>> 0 === t, "limit", "uint32");
      const d = this;
      if (d.cmpn(1) <= 0)
        return !1;
      if (d.isEven())
        return d.cmpn(2) === 0;
      let B = 3;
      for (; ; ) {
        if (B > 1e4)
          throw new Error(`Cannot find (D/n) = -1 for ${d.toString(10)}.`);
        if (t !== 0 && B > t)
          return !1;
        const r = new s(B * B - 4).jacobi(d);
        if (r === -1)
          break;
        if (r === 0)
          return d.cmpn(B + 2) === 0;
        if (B === 40 && d.isSquare())
          return !1;
        B += 1;
      }
      const U = d.addn(1), J = U._makeOdd();
      let C = new s(2), M = new s(B);
      for (let $ = U.bitLength(); $ >= 0; $--)
        U.utestn($) ? (C = C.mul(M).isubn(B).imod(d), M = M.sqr().isubn(2).imod(d)) : (M = M.mul(C).isubn(B).imod(d), C = C.sqr().isubn(2).imod(d));
      if (C.cmpn(2) === 0 || C.cmp(d.subn(2)) === 0) {
        const $ = C.muln(B).imod(d), r = M.ushln(1).imod(d);
        if ($.cmp(r) === 0)
          return !0;
      }
      for (let $ = 0; $ < J - 1; $++) {
        if (C.isZero())
          return !0;
        if (C.cmpn(2) === 0)
          return !1;
        C = C.sqr().isubn(2).imod(d);
      }
      return !1;
    }
    /*
     * Twos Complement
     */
    toTwos(t) {
      return this.negative !== 0 ? this.abs().inotn(t).iaddn(1) : this.clone();
    }
    fromTwos(t) {
      return _(t >>> 0 === t, "width", "uint32"), F(t > 0, "width"), this.testn(t - 1) ? this.notn(t).iaddn(1).ineg() : this.clone();
    }
    /*
     * Reduction Context
     */
    toRed(t) {
      if (_(t instanceof G, "ctx", "reduction context"), this.red)
        throw new Error("Already in reduction context.");
      return t.convertTo(this);
    }
    fromRed() {
      return R(this.red, "fromRed"), this.red.convertFrom(this);
    }
    forceRed(t) {
      if (_(t instanceof G, "ctx", "reduction context"), this.red) {
        if (!t.m.eq(this.red.m) || t.mont !== this.red.mont)
          throw new Error("Already in reduction context.");
      } else
        F(this.negative === 0, "red"), F(this.ucmp(t.m) < 0, "red");
      return this.clone()._forceRed(t);
    }
    redIAdd(t) {
      return _(s.isBN(t), "num", "bignum"), R(this.red, "redIAdd"), this.red.iadd(this, t);
    }
    redAdd(t) {
      return _(s.isBN(t), "num", "bignum"), R(this.red, "redAdd"), this.red.add(this, t);
    }
    redIAddn(t) {
      return _(D(t), "num", "smi"), R(this.red, "redIAddn"), this.red.iaddn(this, t);
    }
    redAddn(t) {
      return _(D(t), "num", "smi"), R(this.red, "redAddn"), this.red.addn(this, t);
    }
    redISub(t) {
      return _(s.isBN(t), "num", "bignum"), R(this.red, "redISub"), this.red.isub(this, t);
    }
    redSub(t) {
      return _(s.isBN(t), "num", "bignum"), R(this.red, "redSub"), this.red.sub(this, t);
    }
    redISubn(t) {
      return _(D(t), "num", "smi"), R(this.red, "redISubn"), this.red.isubn(this, t);
    }
    redSubn(t) {
      return _(D(t), "num", "smi"), R(this.red, "redSubn"), this.red.subn(this, t);
    }
    redIMul(t) {
      return _(s.isBN(t), "num", "bignum"), R(this.red, "redIMul"), this.red.imul(this, t);
    }
    redMul(t) {
      return _(s.isBN(t), "num", "bignum"), R(this.red, "redMul"), this.red.mul(this, t);
    }
    redIMuln(t) {
      return _(D(t), "num", "smi"), R(this.red, "redIMuln"), this.red.imuln(this, t);
    }
    redMuln(t) {
      return _(D(t), "num", "smi"), R(this.red, "redMuln"), this.red.muln(this, t);
    }
    redIDiv(t) {
      return _(s.isBN(t), "num", "bignum"), R(this.red, "redIDiv"), this.red.idiv(this, t);
    }
    redDiv(t) {
      return _(s.isBN(t), "num", "bignum"), R(this.red, "redDiv"), this.red.div(this, t);
    }
    redIDivn(t) {
      return _(D(t), "num", "smi"), R(this.red, "redIDivn"), this.red.idivn(this, t);
    }
    redDivn(t) {
      return _(D(t), "num", "smi"), R(this.red, "redDivn"), this.red.divn(this, t);
    }
    redIPow(t) {
      return _(s.isBN(t), "num", "bignum"), R(this.red, "redIPow"), L(!t.red, "redIPow"), this.red.ipow(this, t);
    }
    redPow(t) {
      return _(s.isBN(t), "num", "bignum"), R(this.red, "redPow"), L(!t.red, "redPow"), this.red.pow(this, t);
    }
    redIPown(t) {
      return _(D(t), "num", "smi"), R(this.red, "redIPown"), this.red.ipown(this, t);
    }
    redPown(t) {
      return _(D(t), "num", "smi"), R(this.red, "redPown"), this.red.pown(this, t);
    }
    redISqr() {
      return R(this.red, "redISqr"), this.red.isqr(this);
    }
    redSqr() {
      return R(this.red, "redSqr"), this.red.sqr(this);
    }
    redISqrt() {
      return R(this.red, "redISqrt"), this.red.isqrt(this);
    }
    redSqrt() {
      return R(this.red, "redSqrt"), this.red.sqrt(this);
    }
    redIDivSqrt(t) {
      return R(this.red, "redIDivSqrt"), this.red.idivsqrt(this, t);
    }
    redDivSqrt(t) {
      return R(this.red, "redDivSqrt"), this.red.divsqrt(this, t);
    }
    redIsSquare() {
      return R(this.red, "redIsSquare"), this.red.isSquare(this);
    }
    redIShl(t) {
      return _(s.isBN(t), "num", "bignum"), R(this.red, "redIShl"), L(!t.red, "redIShl"), this.red.ishl(this, t);
    }
    redShl(t) {
      return _(s.isBN(t), "num", "bignum"), R(this.red, "redShl"), L(!t.red, "redShl"), this.red.shl(this, t);
    }
    redIShln(t) {
      return _(t >>> 0 === t, "num", "uint32"), R(this.red, "redIShln"), this.red.ishln(this, t);
    }
    redShln(t) {
      return _(t >>> 0 === t, "num", "uint32"), R(this.red, "redShln"), this.red.shln(this, t);
    }
    redINeg() {
      return R(this.red, "redINeg"), this.red.ineg(this);
    }
    redNeg() {
      return R(this.red, "redNeg"), this.red.neg(this);
    }
    redEq(t) {
      return _(s.isBN(t), "num", "bignum"), R(this.red, "redEq"), this.red.eq(this, t);
    }
    redEqn(t) {
      return _(D(t), "num", "smi"), R(this.red, "redEqn"), this.red.eqn(this, t);
    }
    redIsHigh() {
      return R(this.red, "redIsHigh"), this.red.isHigh(this);
    }
    redIsLow() {
      return R(this.red, "redIsLow"), this.red.isLow(this);
    }
    redIsOdd() {
      return R(this.red, "redIsOdd"), this.red.isOdd(this);
    }
    redIsEven() {
      return R(this.red, "redIsEven"), this.red.isEven(this);
    }
    redLegendre() {
      return R(this.red, "redLegendre"), this.red.legendre(this);
    }
    redJacobi() {
      return R(this.red, "redJacobi"), this.red.jacobi(this);
    }
    redKronecker() {
      return R(this.red, "redKronecker"), this.red.kronecker(this);
    }
    redIInvert() {
      return R(this.red, "redIInvert"), this.red.iinvert(this);
    }
    redInvert() {
      return R(this.red, "redInvert"), this.red.invert(this);
    }
    redIFermat() {
      return R(this.red, "redIFermat"), this.red.ifermat(this);
    }
    redFermat() {
      return R(this.red, "redFermat"), this.red.fermat(this);
    }
    /*
     * Internal
     */
    _move(t) {
      return t.words = this.words, t.length = this.length, t.negative = this.negative, t.red = this.red, t;
    }
    _alloc(t) {
      for (; this.words.length < t; )
        this.words.push(0);
      return this;
    }
    _expand(t) {
      for (this._alloc(t); this.length < t; )
        this.words[this.length++] = 0;
      return this;
    }
    _strip() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length -= 1;
      return this._normalize();
    }
    _normalize() {
      return q(this.length > 0), this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }
    _check() {
      return q(this.length > 0), q(this.length <= this.words.length), this.length === 1 ? (this.words[0] === 0 && q(this.negative === 0), this) : (q(this.words[this.length - 1] !== 0), this);
    }
    _invertp(t) {
      if (_(s.isBN(t), "p", "bignum"), F(t.sign() > 0, "invert"), q(t.isOdd()), t.cmpn(1) === 0)
        throw new RangeError("Not invertible.");
      const d = this.clone(), B = t.clone(), U = new s(1), J = new s(0);
      for ((d.isNeg() || d.ucmp(B) >= 0) && d.imod(B); !d.isZero(); ) {
        let C = d._makeOdd(), M = B._makeOdd();
        for (; C--; )
          U.isOdd() && U._iadd(U, t), U.iushrn(1);
        for (; M--; )
          J.isOdd() && J._iadd(J, t), J.iushrn(1);
        d.ucmp(B) >= 0 ? (d._isub(d, B), U.ucmp(J) < 0 ? (U._isub(J, U), U._isub(t, U)) : U._isub(U, J)) : (B._isub(B, d), J.ucmp(U) < 0 ? (J._isub(U, J), J._isub(t, J)) : J._isub(J, U));
      }
      if (B.cmpn(1) !== 0)
        throw new RangeError("Not invertible.");
      return q(J.negative === 0), q(J.ucmp(t) < 0), J;
    }
    _makeOdd() {
      const t = this.zeroBits();
      return t > 0 && this.iushrn(t), t;
    }
    _factor2(t) {
      if ((this.words[0] | t.words[0]) & 1)
        return 0;
      const d = Math.min(this.length, t.length);
      let B = 0;
      for (let U = 0; U < d; U++) {
        const J = v(this.words[U] | t.words[U]);
        if (B += J, J !== 26)
          break;
      }
      return B;
    }
    _cloneNormal() {
      return this.red ? this.fromRed() : this.clone();
    }
    _forceRed(t) {
      return this.red = t, this;
    }
    /*
     * Helpers
     */
    clone() {
      const t = new s();
      t.words = new Array(this.length);
      for (let d = 0; d < this.length; d++)
        t.words[d] = this.words[d];
      return t.length = this.length, t.negative = this.negative, t.red = this.red, t;
    }
    inject(t) {
      _(s.isBN(t), "num", "bignum"), this._alloc(t.length);
      for (let d = 0; d < t.length; d++)
        this.words[d] = t.words[d];
      return this.length = t.length, this.negative = t.negative, this.red = t.red, this;
    }
    set(t, d) {
      return this.fromNumber(t, d);
    }
    swap(t) {
      _(s.isBN(t), "num", "bignum");
      const d = this, B = t;
      return [d.words, B.words] = [B.words, d.words], [d.length, B.length] = [B.length, d.length], [d.negative, B.negative] = [B.negative, d.negative], [d.red, B.red] = [B.red, d.red], d;
    }
    reverse() {
      const t = this.negative;
      return this.fromBuffer(this.toBuffer("be"), "le"), this.negative = t, this;
    }
    byteLength() {
      return Math.ceil(this.bitLength() / 8);
    }
    bitLength() {
      const t = this.words[this.length - 1], d = oe(t);
      return (this.length - 1) * 26 + d;
    }
    zeroBits() {
      if (this.isZero() || this.isOdd())
        return 0;
      let t = 0;
      for (let d = 0; d < this.length; d++) {
        const B = v(this.words[d]);
        if (t += B, B !== 26)
          break;
      }
      return t;
    }
    isSafe() {
      return this.length <= 2 || this.length === 3 && this.words[2] === 1;
    }
    word(t) {
      return _(t >>> 0 === t, "pos", "uint32"), t >= this.length ? 0 : this.words[t];
    }
    [e]() {
      let t = "BN";
      return this.red && (t = "BN-R"), `<${t}: ${this.toString(10)}>`;
    }
    /*
     * Conversion
     */
    toNumber() {
      let t = this.words[0];
      if (this.length === 2)
        t += this.words[1] * 67108864;
      else if (this.length === 3 && this.words[2] === 1)
        t += 4503599627370496 + this.words[1] * 67108864;
      else if (this.length > 2)
        throw new RangeError("Number can only safely store up to 53 bits.");
      return this.negative !== 0 ? -t : t;
    }
    toDouble() {
      let t = 0;
      for (let d = this.length - 1; d >= 0; d--)
        t = t * 67108864 + this.words[d];
      return this.negative !== 0 ? -t : t;
    }
    valueOf() {
      return this.toDouble();
    }
    toBigInt() {
      if (!o)
        throw new Error("BigInt is not supported!");
      const t = BigInt(52), d = BigInt(26);
      let B = this.length - 1, U = BigInt(0);
      for (; B >= 1; B -= 2) {
        const J = this.words[B] * 67108864, C = this.words[B - 1];
        U = U << t | BigInt(J + C);
      }
      return B >= 0 && (U = U << d | BigInt(this.words[0])), this.negative !== 0 ? -U : U;
    }
    toBool() {
      return !this.isZero();
    }
    toString(t, d) {
      if (t = W(t), d == null && (d = 0), d === 0 && (d = 1), _(t >>> 0 === t, "base", "uint32"), _(d >>> 0 === d, "padding", "uint32"), t < 2 || t > 36)
        throw new RangeError("Base ranges between 2 and 36.");
      if (this._check(), t === 16) {
        let M = "", $ = 0, r = 0;
        for (let x = 0; x < this.length; x++) {
          const O = this.words[x], K = ((O << $ | r) & 16777215).toString(16);
          r = O >>> 24 - $ & 16777215, r !== 0 || x !== this.length - 1 ? M = c[6 - K.length] + K + M : M = K + M, $ += 2, $ >= 26 && ($ -= 26, x -= 1);
        }
        for (r !== 0 && (M = r.toString(16) + M); M.length % d !== 0; )
          M = "0" + M;
        return this.negative !== 0 && (M = "-" + M), M;
      }
      const B = l[t - 1], U = w[t - 1], J = this.clone();
      let C = "";
      for (J.negative = 0; !J.isZero(); ) {
        const M = J.remrn(U).toString(t);
        J.iquon(U), J.isZero() ? C = M + C : C = c[B - M.length] + M + C;
      }
      for (this.isZero() && (C = "0"); C.length % d !== 0; )
        C = "0" + C;
      return this.negative !== 0 && (C = "-" + C), C;
    }
    toJSON() {
      return this.toString(16, 2);
    }
    toArray(t, d) {
      return this.toArrayLike(Array, t, d);
    }
    toBuffer(t, d) {
      return this.toArrayLike(k, t, d);
    }
    toArrayLike(t, d, B) {
      d == null && (d = "be"), B == null && (B = 0), _(typeof t == "function", "ArrayType", "function"), _(d === "be" || d === "le", "endian", "endianness"), _(B >>> 0 === B, "length", "uint32"), this._check();
      const U = this.byteLength(), J = B || Math.max(1, U);
      if (U > J)
        throw new RangeError("Byte array longer than desired length.");
      const C = Q(t, J);
      if (d === "be") {
        let M = C.length - 1, $ = 0;
        for (let r = 0; r < this.length; r++) {
          const x = (r & 3) << 1, O = this.words[r] << x | $;
          C[M--] = O & 255, M >= 0 && (C[M--] = O >>> 8 & 255), M >= 0 && (C[M--] = O >>> 16 & 255), x === 6 ? (M >= 0 && (C[M--] = O >>> 24 & 255), $ = 0) : $ = O >>> 24;
        }
        if (M >= 0) {
          for (C[M--] = $; M >= 0; )
            C[M--] = 0;
          $ = 0;
        }
        q($ === 0);
      } else {
        let M = 0, $ = 0;
        for (let r = 0; r < this.length; r++) {
          const x = (r & 3) << 1, O = this.words[r] << x | $;
          C[M++] = O & 255, M < C.length && (C[M++] = O >>> 8 & 255), M < C.length && (C[M++] = O >>> 16 & 255), x === 6 ? (M < C.length && (C[M++] = O >>> 24 & 255), $ = 0) : $ = O >>> 24;
        }
        if (M < C.length) {
          for (C[M++] = $; M < C.length; )
            C[M++] = 0;
          $ = 0;
        }
        q($ === 0);
      }
      return C;
    }
    encode(t, d) {
      return this.toBuffer(t, d);
    }
    /*
     * Instantiation
     */
    of(t, d) {
      return this.fromNumber(t, d);
    }
    fromNumber(t, d) {
      d == null && (d = "be"), _(ae(t), "num", "integer"), _(d === "be" || d === "le", "endian", "endianness");
      const B = t < 0 | 0;
      return B && (t = -t), t < 67108864 ? (this.words[0] = t & 67108863, this.length = 1) : t < 4503599627370496 ? (this.words = [
        t & 67108863,
        t / 67108864 & 67108863
      ], this.length = 2) : (this.words = [
        t & 67108863,
        t / 67108864 & 67108863,
        1
      ], this.length = 3), this.negative = B, d === "le" && this.reverse(), this;
    }
    fromDouble(t, d) {
      d == null && (d = "be"), _(typeof t == "number", "num", "double"), _(d === "be" || d === "le", "endian", "endianness"), isFinite(t) || (t = 0);
      const B = t <= -1 | 0;
      for (t < 0 && (t = -t), t = Math.floor(t), this.words = []; t > 0; ) {
        const U = t % 67108864, J = (t - U) / 67108864;
        this.words.push(U), t = J;
      }
      return this.words.length === 0 && this.words.push(0), this.length = this.words.length, this.negative = B, d === "le" && this.reverse(), this;
    }
    fromBigInt(t, d) {
      if (d == null && (d = "be"), _(typeof t == "bigint", "num", "bigint"), _(d === "be" || d === "le", "endian", "endianness"), !o)
        throw new Error("BigInt is not supported!");
      const B = t < BigInt(0) | 0;
      return this._fromHex(t.toString(16), B), this.negative = B, d === "le" && this.reverse(), this;
    }
    fromBool(t) {
      return _(typeof t == "boolean", "value", "boolean"), this.words[0] = t | 0, this.length = 1, this.negative = 0, this;
    }
    fromString(t, d, B) {
      if ((d === "le" || d === "be") && ([d, B] = [B, d]), d = W(d), B == null && (B = "be"), _(typeof t == "string", "string", "string"), _(d >>> 0 === d, "base", "uint32"), _(B === "be" || B === "le", "endian", "endianness"), d < 2 || d > 36)
        throw new Error("Base ranges between 2 and 36.");
      t = t.replace(/\s+/g, "");
      let U = 0;
      return t.length > 0 && t.charCodeAt(0) === 45 && (U = 1), d === 16 ? this._fromHex(t, U) : this._fromBase(t, d, U), this.negative = U, this._normalize(), B === "le" && this.reverse(), this;
    }
    _fromHex(t, d) {
      this.length = Math.max(2, Math.ceil((t.length - d) / 6)), this.words = new Array(this.length);
      for (let C = 0; C < this.length; C++)
        this.words[C] = 0;
      let B = 0, U = t.length - 6, J = 0;
      for (; U >= d; U -= 6) {
        const C = Y(t, U, U + 6);
        this.words[J] |= C << B & 67108863, this.words[J + 1] |= C >>> 26 - B & 4194303, B += 24, B >= 26 && (B -= 26, J += 1);
      }
      if (U + 6 !== d) {
        const C = Y(t, d, U + 6);
        this.words[J] |= C << B & 67108863, this.words[J + 1] |= C >>> 26 - B & 4194303;
      }
      return this._strip();
    }
    _fromBase(t, d, B) {
      this.words[0] = 0, this.length = 1, this.negative = 0;
      let U = 0, J = 1;
      for (; J <= 67108863; J *= d)
        U += 1;
      U -= 1, J = J / d | 0;
      const C = t.length - B, M = C % U, $ = Math.min(C, C - M) + B;
      let r = B;
      for (; r < $; r += U) {
        const x = he(t, r, r + U, d);
        this.imuln(J), this._iaddn(x);
      }
      if (M !== 0) {
        const x = Math.pow(d, M), O = he(t, r, t.length, d);
        this.imuln(x), this._iaddn(O);
      }
      return this;
    }
    fromJSON(t) {
      if (s.isBN(t))
        return t.red ? t.fromRed() : t.clone();
      if (Array.isArray(t)) {
        for (const d of t)
          _(typeof d == "string", "chunk", "string");
        t = t.join("");
      }
      return this.fromString(t, 16);
    }
    fromBN(t) {
      return this.inject(t);
    }
    fromArray(t, d) {
      return _(Array.isArray(t), "data", "array"), this.fromArrayLike(t, d);
    }
    fromBuffer(t, d) {
      return _(k.isBuffer(t), "data", "buffer"), this.fromArrayLike(t, d);
    }
    fromArrayLike(t, d) {
      if (d == null && (d = "be"), _(t && t.length >>> 0 === t.length, "data", "array-like"), _(d === "be" || d === "le", "endian", "endianness"), t.length === 0)
        return this.words[0] = 0, this.length = 1, this.negative = 0, this;
      this.length = Math.max(2, Math.ceil(t.length / 3)), this.words = new Array(this.length), this.negative = 0;
      for (let M = 0; M < this.length; M++)
        this.words[M] = 0;
      const B = t.length % 3;
      let U = 0, J = 0, C = 0;
      if (d === "be") {
        for (let M = t.length - 1; M >= 2; M -= 3) {
          const $ = t[M] | t[M - 1] << 8 | t[M - 2] << 16;
          this.words[J] |= $ << U & 67108863, this.words[J + 1] = $ >>> 26 - U & 67108863, U += 24, U >= 26 && (U -= 26, J += 1);
        }
        switch (B) {
          case 2:
            C = t[1] | t[0] << 8;
            break;
          case 1:
            C = t[0];
            break;
        }
      } else {
        const M = t.length - B;
        for (let $ = 0; $ < M; $ += 3) {
          const r = t[$] | t[$ + 1] << 8 | t[$ + 2] << 16;
          this.words[J] |= r << U & 67108863, this.words[J + 1] = r >>> 26 - U & 67108863, U += 24, U >= 26 && (U -= 26, J += 1);
        }
        switch (B) {
          case 2:
            C = t[M] | t[M + 1] << 8;
            break;
          case 1:
            C = t[M];
            break;
        }
      }
      return B > 0 && (this.words[J] |= C << U & 67108863, this.words[J + 1] = C >>> 26 - U & 67108863), this._strip();
    }
    decode(t, d) {
      return this.fromBuffer(t, d);
    }
    from(t, d, B) {
      if (t == null)
        return this;
      if ((d === "le" || d === "be") && ([d, B] = [B, d]), typeof t == "number")
        return this.fromNumber(t, B);
      if (typeof t == "bigint")
        return this.fromBigInt(t, B);
      if (typeof t == "string")
        return this.fromString(t, d, B);
      if (typeof t == "object") {
        if (s.isBN(t))
          return this.fromBN(t, B);
        if (t.length >>> 0 === t.length)
          return this.fromArrayLike(t, B);
      }
      if (typeof t == "boolean")
        return this.fromBool(t);
      throw new TypeError("Non-numeric object passed to BN.");
    }
    /*
     * Static Methods
     */
    static min(...t) {
      let d = null;
      for (const B of t)
        _(s.isBN(B), "num", "bignum"), (!d || B.cmp(d) < 0) && (d = B);
      return d || new s(0);
    }
    static max(...t) {
      let d = null;
      for (const B of t)
        _(s.isBN(B), "num", "bignum"), (!d || B.cmp(d) > 0) && (d = B);
      return d || new s(0);
    }
    static cmp(t, d) {
      return _(s.isBN(t), "a", "bignum"), t.cmp(d);
    }
    static ucmp(t, d) {
      return _(s.isBN(t), "a", "bignum"), t.ucmp(d);
    }
    static red(t) {
      return new G(t);
    }
    static barrett(t) {
      return new N(t);
    }
    static mont(t) {
      return new T(t);
    }
    static _prime(t) {
      if (m[t])
        return m[t];
      let d;
      if (t === "p192")
        d = new y();
      else if (t === "p224")
        d = new b();
      else if (t === "p521")
        d = new h();
      else if (t === "k256")
        d = new a();
      else if (t === "p251")
        d = new E();
      else if (t === "p25519")
        d = new H();
      else if (t === "p448")
        d = new j();
      else
        throw new Error(`Unknown prime: "${t}".`);
      return m[t] = d, d;
    }
    static prime(t) {
      return s._prime(t).p.clone();
    }
    static pow(t, d) {
      return t === 2 ? s.shift(1, d) : new s().fromNumber(t).pown(d);
    }
    static shift(t, d) {
      return t === 1 ? new s(0).usetn(d, 1) : new s().fromNumber(t).ishln(d);
    }
    static mask(t) {
      return s.shift(1, t).isubn(1);
    }
    static randomBits(t, d) {
      if (_(t != null, "rng", "rng"), _(d >>> 0 === d, "bits", "uint32"), typeof t == "object") {
        _(typeof t.randomBytes == "function", "rng", "rng");
        const U = d + 7 >>> 3, J = U * 8, C = t.randomBytes(U);
        if (_(k.isBuffer(C), "bytes", "buffer"), C.length !== U)
          throw new RangeError("Invalid number of bytes returned from RNG.");
        const M = s.fromBuffer(C);
        return J > d && M.iushrn(J - d), M;
      }
      _(typeof t == "function", "rng", "rng");
      const B = t(d);
      if (_(s.isBN(B), "num", "bignum"), F(B.negative === 0, "RNG"), L(!B.red, "RNG"), B.bitLength() > d)
        throw new RangeError("Invalid number of bits returned from RNG.");
      return B;
    }
    static random(t, d, B) {
      if (d = s.cast(d, 16), B = s.cast(B, 16), d.cmp(B) > 0)
        throw new RangeError("Minimum cannot be greater than maximum.");
      const U = B.sub(d).iabs(), J = U.bitLength();
      if (J === 0)
        return d.clone();
      for (; ; ) {
        const C = s.randomBits(t, J);
        if (!(C.cmp(U) >= 0))
          return C.iadd(d), C;
      }
    }
    static of(t, d) {
      return new s().of(t, d);
    }
    static fromNumber(t, d) {
      return new s().fromNumber(t, d);
    }
    static fromDouble(t, d) {
      return new s().fromDouble(t, d);
    }
    static fromBigInt(t, d) {
      return new s().fromBigInt(t, d);
    }
    static fromBool(t) {
      return new s().fromBool(t);
    }
    static fromString(t, d, B) {
      return new s().fromString(t, d, B);
    }
    static fromJSON(t) {
      return new s().fromJSON(t);
    }
    static fromBN(t) {
      return new s().fromBN(t);
    }
    static fromArray(t, d) {
      return new s().fromArray(t, d);
    }
    static fromBuffer(t, d) {
      return new s().fromBuffer(t, d);
    }
    static fromArrayLike(t, d) {
      return new s().fromArrayLike(t, d);
    }
    static decode(t, d) {
      return new s().decode(t, d);
    }
    static from(t, d, B) {
      return new s().from(t, d, B);
    }
    static cast(t, d, B) {
      return s.isBN(t) ? t : new s(t, d, B);
    }
    static isBN(t) {
      return t instanceof s;
    }
  }
  s.BN = s, s.wordSize = 26, s.native = 0;
  class i {
    constructor(t, d) {
      this.name = t, this.p = new s(d, 16), this.n = this.p.bitLength(), this.k = s.shift(1, this.n).isub(this.p), this.lo = this.p.clone(), this.one = this.p.clone();
    }
    ireduce(t) {
      const d = t.negative !== 0;
      let B = t.bitLength();
      for (q(B <= this.n * 2), t.negative = 0; B > this.n; )
        this.split(t, this.lo), this.imulK(t), t._iadd(t, this.lo), B = t.bitLength();
      const U = B < this.n ? -1 : t.ucmp(this.p);
      return U === 0 ? (t.words[0] = 0, t.length = 1) : U > 0 && t._isub(t, this.p), d && !t.isZero() && t._isub(this.p, t), t;
    }
    split(t, d) {
      t._split(this.n, d);
    }
    imulK(t) {
      return t.imul(this.k);
    }
    pm2(t) {
      throw new Error("Not implemented.");
    }
    fermat(t) {
      return this.pm2(t);
    }
  }
  class p extends i {
    constructor(t, d) {
      super(t, d);
    }
    pm3d4(t) {
      throw new Error("Not implemented.");
    }
    pp1d4(t) {
      throw new Error("Not implemented.");
    }
    sqrt(t) {
      const { red: d } = t, B = this.pp1d4(t);
      if (!d.sqr(B).eq(t))
        throw new ue(B);
      return B;
    }
    divsqrt(t, d) {
      const { red: B } = t, U = B.sqr(t), J = B.mul(U, t), C = B.mul(J, U), M = B.mul(B.sqr(d), d), $ = this.pm3d4(B.mul(C, M)), r = B.mul(B.mul(J, d), $);
      if (B.mul(d, B.sqr(r)).eq(t))
        return r;
      throw new ue(r);
    }
  }
  class g extends i {
    constructor(t, d, B) {
      super(t, d), this.sm1 = new s(B, 16);
    }
    pm5d8(t) {
      throw new Error("Not implemented.");
    }
    pp3d8(t) {
      throw new Error("Not implemented.");
    }
    sqrt(t) {
      const { red: d } = t, B = this.sm1._forceRed(d), U = this.pp3d8(t);
      if (d.sqr(U).eq(t))
        return U;
      const J = d.mul(U, B);
      if (d.sqr(J).eq(t))
        return J;
      throw new ue(U);
    }
    divsqrt(t, d) {
      const { red: B } = t, U = this.sm1._forceRed(B), J = B.mul(B.sqr(d), d), C = B.mul(B.sqr(J), d), M = this.pm5d8(B.mul(t, C)), $ = B.mul(B.mul(t, J), M), r = B.mul(d, B.sqr($));
      if (r.eq(t))
        return $;
      const x = B.ineg(r);
      if (x.eq(t))
        return B.mul($, U);
      throw x.eq(B.mul(t, U)) ? new ue(B.mul($, U)) : new ue($);
    }
  }
  class S extends i {
    constructor(t, d, B) {
      super(t, d), this.g = new s(B, 16), this.z = this.p.subn(1).zeroBits();
    }
    powS(t) {
      throw new Error("Not implemented.");
    }
    powE(t) {
      throw new Error("Not implemented.");
    }
    sqrt(t) {
      const { red: d } = t;
      switch (d.jacobi(t)) {
        case -1:
          throw new ue(t);
        case 0:
          return t.clone();
      }
      let B = this.g._forceRed(d), U = this.powE(t), J = this.powS(t), C = this.z;
      for (; ; ) {
        let M = J, $ = 0;
        for (; M.cmpn(1) !== 0 && $ < C; )
          M = d.sqr(M), $ += 1;
        if ($ === 0)
          break;
        q($ < C), M = d.sqrn(B, C - $ - 1), B = d.sqr(M), U = d.mul(U, M), J = d.mul(J, B), C = $;
      }
      return U;
    }
    divsqrt(t, d) {
      const { red: B } = t;
      if (d.isZero())
        throw new ue(d);
      return this.sqrt(B.div(t, d));
    }
  }
  class y extends p {
    constructor() {
      super("p192", "ffffffff ffffffff ffffffff fffffffeffffffff ffffffff");
    }
    imulK(t) {
      const d = this.one.inject(t);
      return t.iushln(64)._iadd(t, d);
    }
    core(t) {
      const { red: d } = t, B = d.sqrnmul(t, 1, t), U = d.sqrnmul(B, 1, t), J = d.sqrnmul(U, 3, U), C = d.sqrnmul(J, 6, J), M = d.sqrnmul(C, 12, C), $ = d.sqrnmul(M, 6, J), r = d.sqrnmul($, 1, t), x = d.sqrnmul(r, 31, r), O = d.sqrnmul(x, 62, x), K = d.sqrnmul(O, 3, U), X = d.sqrn(K, 1);
      return d.sqrnmul(X, 62, x);
    }
    pm3d4(t) {
      return this.core(t);
    }
    pm2(t) {
      const { red: d } = t, B = this.core(t), U = d.sqrn(B, 1);
      return d.sqrnmul(U, 1, t);
    }
    pp1d4(t) {
      const { red: d } = t, B = d.sqrnmul(t, 1, t), U = d.sqrnmul(B, 2, B), J = d.sqrnmul(U, 4, U), C = d.sqrnmul(J, 8, J), M = d.sqrnmul(C, 16, C), $ = d.sqrnmul(M, 32, M), r = d.sqrnmul($, 64, $);
      return d.sqrn(r, 62);
    }
  }
  class b extends S {
    constructor() {
      super(
        "p224",
        "ffffffff ffffffff ffffffff ffffffff00000000 00000000 00000001",
        "6a0fec67 8598a792 0c55b2d4 0b2d6ffbbea3d8ce f3fb3632 dc691b74"
      );
    }
    imulK(t) {
      const d = this.one.inject(t);
      return t.iushln(96)._isub(t, d);
    }
    powS(t) {
      const { red: d } = t, B = d.sqrnmul(t, 1, t), U = d.sqrnmul(B, 2, B), J = d.sqrnmul(U, 4, U), C = d.sqrnmul(J, 8, J), M = d.sqrnmul(C, 16, C), $ = d.sqrnmul(M, 32, M);
      return d.sqrnmul($, 64, $);
    }
    powE(t) {
      const { red: d } = t;
      return d.sqrn(t, 127);
    }
    pm2(t) {
      const { red: d } = t, B = d.sqrnmul(t, 1, t), U = d.sqrnmul(B, 1, t), J = d.sqrnmul(U, 3, U), C = d.sqrnmul(J, 6, J), M = d.sqrnmul(C, 12, C), $ = d.sqrnmul(M, 24, M), r = d.sqrnmul($, 48, $), x = d.sqrnmul(r, 24, M), O = d.sqrnmul(x, 6, J), K = d.sqrnmul(O, 1, t), X = d.sqrn(K, 1);
      return d.sqrnmul(X, 96, r);
    }
  }
  class h extends p {
    constructor() {
      super("p521", "000001ff ffffffff ffffffff ffffffffffffffff ffffffff ffffffff ffffffffffffffff ffffffff ffffffff ffffffffffffffff ffffffff ffffffff ffffffffffffffff");
    }
    imulK(t) {
      return t;
    }
    core(t) {
      const { red: d } = t, B = d.sqrnmul(t, 1, t), U = d.sqrnmul(B, 1, t), J = d.sqrnmul(U, 3, U), C = d.sqrnmul(J, 1, t), M = d.sqrnmul(C, 1, t), $ = d.sqrnmul(M, 8, M), r = d.sqrnmul($, 16, $), x = d.sqrnmul(r, 32, r), O = d.sqrnmul(x, 64, x), K = d.sqrnmul(O, 128, O), X = d.sqrnmul(K, 256, K);
      return d.sqrnmul(X, 7, C);
    }
    pm3d4(t) {
      return this.core(t);
    }
    pm2(t) {
      const { red: d } = t, B = this.core(t), U = d.sqrn(B, 1);
      return d.sqrnmul(U, 1, t);
    }
    pp1d4(t) {
      const { red: d } = t;
      return d.sqrn(t, 519);
    }
  }
  class a extends p {
    constructor() {
      super("k256", "ffffffff ffffffff ffffffff ffffffffffffffff ffffffff fffffffe fffffc2f");
    }
    split(t, d) {
      const U = Math.min(t.length, 9);
      d._alloc(U + 1);
      for (let M = 0; M < U; M++)
        d.words[M] = t.words[M];
      if (d.length = U, t.length <= 9) {
        d._strip(), t.words[0] = 0, t.length = 1;
        return;
      }
      let J = t.words[9], C = 10;
      for (d.words[d.length++] = J & 4194303, d._strip(); C < t.length; C++) {
        const M = t.words[C] | 0;
        t.words[C - 10] = (M & 4194303) << 4 | J >>> 22, J = M;
      }
      J >>>= 22, t.words[C - 10] = J, J === 0 && t.length > 10 ? t.length -= 10 : t.length -= 9, t._strip();
    }
    imulK(t) {
      t._expand(t.length + 2);
      let d = 0;
      for (let B = 0; B < t.length; B++) {
        const U = t.words[B];
        d += U * 977, t.words[B] = d & 67108863, d = U * 64 + Math.floor(d / 67108864);
      }
      return t.words[t.length - 1] === 0 && (t.length -= 1, t.words[t.length - 1] === 0 && (t.length -= 1)), t;
    }
    core(t, d) {
      const { red: B } = t, U = B.sqrnmul(d, 1, t), J = B.sqrnmul(U, 3, U), C = B.sqrnmul(J, 3, U), M = B.sqrnmul(C, 2, d), $ = B.sqrnmul(M, 11, M), r = B.sqrnmul($, 22, $), x = B.sqrnmul(r, 44, r), O = B.sqrnmul(x, 88, x), K = B.sqrnmul(O, 44, r), X = B.sqrnmul(K, 3, U), P = B.sqrn(X, 1), V = B.sqrnmul(P, 22, $);
      return B.sqrn(V, 4);
    }
    pm3d4(t) {
      const { red: d } = t, B = d.sqrnmul(t, 1, t), U = this.core(t, B), J = d.sqrnmul(U, 1, t), C = d.sqrn(J, 1);
      return d.sqrnmul(C, 2, B);
    }
    pm2(t) {
      const { red: d } = t, B = d.sqrnmul(t, 1, t), U = this.core(t, B), J = d.sqrnmul(U, 1, t), C = d.sqrn(J, 1), M = d.sqrnmul(C, 2, B), $ = d.sqrn(M, 1);
      return d.sqrnmul($, 1, t);
    }
    pp1d4(t) {
      const { red: d } = t, B = d.sqrnmul(t, 1, t), U = this.core(t, B), J = d.sqrnmul(U, 2, B);
      return d.sqrn(J, 2);
    }
  }
  class E extends p {
    constructor() {
      super("p251", "07ffffff ffffffff ffffffff ffffffffffffffff ffffffff ffffffff fffffff7");
    }
    imulK(t) {
      if (t.isZero())
        return t;
      let d = 0;
      for (let B = 0; B < t.length; B++) {
        const U = t.words[B] * 9 + d;
        d = U >>> 26, t.words[B] = U & 67108863;
      }
      return d !== 0 && (t._alloc(t.length + 1), t.words[t.length++] = d), t;
    }
    core(t) {
      const { red: d } = t, B = d.sqrnmul(t, 1, t), U = d.sqrnmul(B, 1, t), J = d.sqrnmul(U, 3, U), C = d.sqrnmul(J, 6, J), M = d.sqrnmul(C, 12, C), $ = d.sqrnmul(M, 24, M), r = d.sqrnmul($, 48, $), x = d.sqrnmul(r, 96, r), O = d.sqrnmul(x, 48, $), K = d.sqrnmul(O, 6, J);
      return d.sqrnmul(K, 1, t);
    }
    pm3d4(t) {
      const { red: d } = t, B = this.core(t), U = d.sqrn(B, 1);
      return d.sqrnmul(U, 1, t);
    }
    pm2(t) {
      const { red: d } = t, B = this.core(t), U = d.sqrn(B, 1), J = d.sqrnmul(U, 1, t), C = d.sqrn(J, 1);
      return d.sqrnmul(C, 1, t);
    }
    pp1d4(t) {
      const { red: d } = t, B = this.core(t), U = d.sqrnmul(B, 1, t);
      return d.sqrn(U, 1);
    }
  }
  class H extends g {
    constructor() {
      super(
        "p25519",
        "7fffffff ffffffff ffffffff ffffffffffffffff ffffffff ffffffff ffffffed",
        "2b832480 4fc1df0b 2b4d0099 3dfbd7a72f431806 ad2fe478 c4ee1b27 4a0ea0b0"
      );
    }
    imulK(t) {
      let d = 0;
      for (let B = 0; B < t.length; B++) {
        const U = t.words[B] * 19 + d;
        d = U >>> 26, t.words[B] = U & 67108863;
      }
      return d !== 0 && (t._alloc(t.length + 1), t.words[t.length++] = d), t;
    }
    core(t, d) {
      const { red: B } = t, U = B.sqrnmul(d, 2, d), J = B.sqrnmul(U, 1, t), C = B.sqrnmul(J, 5, J), M = B.sqrnmul(C, 10, C), $ = B.sqrnmul(M, 20, M), r = B.sqrnmul($, 10, C), x = B.sqrnmul(r, 50, r), O = B.sqrnmul(x, 100, x);
      return B.sqrnmul(O, 50, r);
    }
    pm5d8(t) {
      const { red: d } = t, B = d.sqrnmul(t, 1, t), U = this.core(t, B), J = d.sqrn(U, 1);
      return d.sqrnmul(J, 1, t);
    }
    pm2(t) {
      const { red: d } = t, B = d.sqrnmul(t, 1, t), U = this.core(t, B), J = d.sqrn(U, 1), C = d.sqrnmul(J, 1, t), M = d.sqrn(C, 1);
      return d.sqrnmul(M, 2, B);
    }
    pp3d8(t) {
      const { red: d } = t, B = d.sqrnmul(t, 1, t), U = this.core(t, B), J = d.sqrnmul(U, 1, t);
      return d.sqrn(J, 1);
    }
  }
  class j extends p {
    constructor() {
      super("p448", "ffffffff ffffffff ffffffff ffffffffffffffff ffffffff fffffffe ffffffffffffffff ffffffff ffffffff ffffffffffffffff ffffffff");
    }
    imulK(t) {
      const d = this.one.inject(t);
      return t.iushln(224)._iadd(t, d);
    }
    core(t, d) {
      const { red: B } = t, U = B.sqrnmul(d, 1, t), J = B.sqrnmul(U, 3, U), C = B.sqrnmul(J, 3, U), M = B.sqrnmul(C, 2, d), $ = B.sqrnmul(M, 11, M), r = B.sqrnmul($, 22, $), x = B.sqrnmul(r, 44, r), O = B.sqrnmul(x, 88, x), K = B.sqrnmul(O, 44, r);
      return B.sqrnmul(K, 2, d);
    }
    pm3d4(t) {
      const { red: d } = t, B = d.sqrnmul(t, 1, t), U = this.core(t, B), J = d.sqrnmul(U, 1, t), C = d.sqrn(J, 1);
      return d.sqrnmul(C, 222, U);
    }
    pm2(t) {
      const { red: d } = t, B = this.pm3d4(t), U = d.sqrn(B, 1);
      return d.sqrnmul(U, 1, t);
    }
    pp1d4(t) {
      const { red: d } = t, B = d.sqrnmul(t, 1, t), U = this.core(t, B), J = d.sqrnmul(U, 2, B);
      return d.sqrn(J, 222);
    }
  }
  class G {
    constructor(t) {
      let d = null;
      typeof t == "string" && (d = s._prime(t), t = d.p), _(s.isBN(t), "m", "bignum"), L(!t.red, "reduction"), F(t.sign() > 0, "reduction"), this.m = t, this.prime = d, this.mb = null, this.sm1 = null;
    }
    _verify1(t) {
      F(t.negative === 0, "red"), R(t.red != null, "red");
    }
    _verify2(t, d) {
      F((t.negative | d.negative) === 0, "red"), R(t.red != null && t.red === d.red, "red");
    }
    get mont() {
      return !1;
    }
    precompute() {
      if (this.sm1 === null && this.m.andln(7) === 5)
        if (this.prime)
          this.sm1 = this.prime.sm1.clone()._forceRed(this);
        else {
          const t = new s(2).toRed(this), d = this.m.subn(1).iushrn(2);
          this.sm1 = this.pow(t, d);
        }
      return this;
    }
    convertTo(t) {
      const d = t.mod(this.m);
      return d.red = this, d;
    }
    convertFrom(t) {
      const d = t.clone();
      return d.red = null, d;
    }
    intTo(t) {
      return t;
    }
    intFrom(t) {
      return t;
    }
    imod(t) {
      return this.prime ? this.prime.ireduce(t)._forceRed(this) : t.imod(this.m)._forceRed(this);
    }
    iadd(t, d) {
      return this._verify2(t, d), t._iadd(t, d), t.ucmp(this.m) >= 0 && t._isub(t, this.m), t;
    }
    add(t, d) {
      return t.length < d.length ? this.iadd(d.clone(), t) : this.iadd(t.clone(), d);
    }
    iaddn(t, d) {
      return this._verify1(t), d < 0 ? this.isubn(t, -d) : (this.m.length === 1 && (d %= this.m.words[0]), t._iaddn(d), t.ucmp(this.m) >= 0 && t._isub(t, this.m), t);
    }
    addn(t, d) {
      return this.iaddn(t.clone(), d);
    }
    isub(t, d) {
      this._verify2(t, d);
      const B = t.ucmp(d);
      return B === 0 ? (t.words[0] = 0, t.length = 1, t) : (B < 0 ? (t._isub(d, t), t._isub(this.m, t)) : t._isub(t, d), t);
    }
    sub(t, d) {
      return this.isub(t.clone(), d);
    }
    isubn(t, d) {
      return this._verify1(t), d < 0 ? this.iaddn(t, -d) : (this.m.length === 1 && (d %= this.m.words[0]), t.length === 1 && t.words[0] < d ? (t.words[0] = d - t.words[0], t._isub(this.m, t)) : t._isubn(d), t);
    }
    subn(t, d) {
      return this.isubn(t.clone(), d);
    }
    imul(t, d) {
      return this._verify2(t, d), this.imod(t.imul(d));
    }
    mul(t, d) {
      return this._verify2(t, d), this.imod(t.mul(d));
    }
    imuln(t, d) {
      if (this._verify1(t), t.isZero())
        return t;
      if (d === 0)
        return t.words[0] = 0, t.length = 1, t;
      const B = d < 0;
      if (B && (d = -d), this.m.length === 1 && (d %= this.m.words[0]), t.imuln(d), d <= 16)
        for (; t.ucmp(this.m) >= 0; )
          t._isub(t, this.m);
      else
        this.imod(t);
      return B && this.ineg(t), t;
    }
    muln(t, d) {
      return this.imuln(t.clone(), d);
    }
    idiv(t, d) {
      return this.div(t, d)._move(t);
    }
    div(t, d) {
      return this.mul(t, this.invert(d));
    }
    idivn(t, d) {
      return this.divn(t, d)._move(t);
    }
    divn(t, d) {
      return this.div(t, this.convertTo(new s(d)));
    }
    ipow(t, d) {
      return this.pow(t, d)._move(t);
    }
    pow(t, d) {
      return this._verify1(t), d.isNeg() && (t = this.invert(t)), d.length === 1 ? this.pown(t, d.words[0]) : o && !this.prime ? this.powInt(t, d) : this.powNum(t, d);
    }
    powNum(t, d) {
      const B = new s(1).toRed(this), U = new Array(u), J = this.sqr(t);
      U[0] = t;
      for (let $ = 1; $ < u; $++)
        U[$] = this.mul(U[$ - 1], J);
      let C = d.bitLength(), M = B;
      for (; C >= n; ) {
        let $ = n, r = d.bits(C - $, $);
        if (r < u) {
          M = this.sqr(M), C -= 1;
          continue;
        }
        for (; (r & 1) === 0; )
          $ -= 1, r >>= 1;
        M === B ? M = U[r >> 1].clone() : (M = this.sqrn(M, $), M = this.mul(M, U[r >> 1])), C -= $;
      }
      if (C > 0) {
        const $ = d.bits(0, C);
        for (; C--; )
          M = this.sqr(M), $ >> C & 1 && (M = this.mul(M, t));
      }
      return M;
    }
    powInt(t, d) {
      this.mb === null && (this.mb = this.m.toBigInt());
      const B = this.intFrom(t.toBigInt()), U = le(B, d, this.mb), J = this.intTo(U);
      return s.fromBigInt(J)._forceRed(this);
    }
    sqrn(t, d) {
      for (; d--; )
        t = this.sqr(t);
      return t;
    }
    sqrnmul(t, d, B) {
      return this.mul(this.sqrn(t, d), B);
    }
    ipown(t, d) {
      return this.pown(t, d)._move(t);
    }
    pown(t, d) {
      if (this._verify1(t), d < 0 && (t = this.invert(t), d = -d), d === 0)
        return new s(1).toRed(this);
      if (d === 1)
        return t.clone();
      const B = oe(d);
      let U = t;
      for (let J = B - 2; J >= 0; J--)
        U = this.sqr(U), d >> J & 1 && (U = this.mul(U, t));
      return U;
    }
    isqr(t) {
      return this.imul(t, t);
    }
    sqr(t) {
      return this.mul(t, t);
    }
    isqrt(t) {
      return this.sqrt(t)._move(t);
    }
    sqrt(t) {
      return this._verify1(t), this.prime ? this.prime.sqrt(t) : this.m.andln(3) === 3 ? this.sqrt3mod4(t) : this.m.andln(7) === 5 ? this.sm1 != null ? this.sqrt5mod8sm1(t) : this.sqrt5mod8(t) : this.sqrt0(t);
    }
    sqrt3mod4(t) {
      const d = this.m.addn(1).iushrn(2), B = this.pow(t, d);
      if (!this.sqr(B).eq(t))
        throw new ue(B);
      return B;
    }
    sqrt5mod8(t) {
      const d = new s(1).toRed(this), B = this.m.ushrn(3), U = this.add(t, t), J = this.pow(U, B), C = this.mul(U, this.sqr(J)), M = this.mul(this.mul(J, t), this.isub(C, d));
      if (!this.sqr(M).eq(t))
        throw new ue(M);
      return M;
    }
    sqrt5mod8sm1(t) {
      const d = this.m.addn(3).iushrn(3), B = this.pow(t, d);
      if (this.sqr(B).eq(t))
        return B;
      const U = this.mul(B, this.sm1);
      if (this.sqr(U).eq(t))
        return U;
      throw new ue(B);
    }
    sqrt0(t) {
      if (this.m.cmpn(1) === 0 || !this.m.isOdd())
        throw new Error("Invalid prime.");
      switch (this.jacobi(t)) {
        case -1:
          throw new ue(t);
        case 0:
          return t.clone();
      }
      const d = new s(1).toRed(this), B = this.m.subn(1), U = B._makeOdd(), J = new s(2).toRed(this);
      for (; this.jacobi(J) !== -1; )
        this.iadd(J, d);
      let C = this.pow(J, B), M = this.pow(t, B), $ = this.pow(t, B.iaddn(1).iushrn(1)), r = U;
      for (; ; ) {
        let x = M, O = 0;
        for (; !x.eq(d) && O < r; )
          x = this.sqr(x), O += 1;
        if (O === 0)
          break;
        q(O < r), x = this.sqrn(C, r - O - 1), C = this.sqr(x), $ = this.mul($, x), M = this.mul(M, C), r = O;
      }
      return $;
    }
    idivsqrt(t, d) {
      return this.divsqrt(t, d)._move(t);
    }
    divsqrt(t, d) {
      if (this._verify2(t, d), t.isZero() && d.isZero())
        throw new ue(d);
      if (this.prime)
        return this.prime.divsqrt(t, d);
      if (this.m.andln(3) === 3)
        return this.divsqrt3mod4(t, d);
      if (this.sm1 != null && this.m.andln(7) === 5)
        return this.divsqrt5mod8(t, d);
      if (d.isZero())
        throw new ue(d);
      return this.sqrt(this.div(t, d));
    }
    divsqrt3mod4(t, d) {
      const B = this.m.subn(3).iushrn(2), U = this.sqr(t), J = this.mul(U, t), C = this.mul(J, U), M = this.mul(this.sqr(d), d), $ = this.pow(this.mul(C, M), B), r = this.mul(this.mul(J, d), $);
      if (this.mul(d, this.sqr(r)).eq(t))
        return r;
      throw new ue(r);
    }
    divsqrt5mod8(t, d) {
      const B = this.m.subn(5).iushrn(3), U = this.mul(this.sqr(d), d), J = this.mul(this.sqr(U), d), C = this.pow(this.mul(t, J), B), M = this.mul(this.mul(t, U), C), $ = this.mul(d, this.sqr(M));
      if ($.eq(t))
        return M;
      const r = this.ineg($);
      if (r.eq(t))
        return this.mul(M, this.sm1);
      throw r.eq(this.mul(t, this.sm1)) ? new ue(this.mul(M, this.sm1)) : new ue(M);
    }
    isSquare(t) {
      return this.m.isOdd() ? this.jacobi(t) >= 0 : this.kronecker(t) >= 0;
    }
    ishl(t, d) {
      return this._verify1(t), this.imod(t.iushl(d));
    }
    shl(t, d) {
      return this.ishl(t.clone(), d);
    }
    ishln(t, d) {
      if (this._verify1(t), t.iushln(d), d <= 4)
        for (; t.ucmp(this.m) >= 0; )
          t._isub(t, this.m);
      else
        this.imod(t);
      return t;
    }
    shln(t, d) {
      return this.ishln(t.clone(), d);
    }
    ineg(t) {
      return this._verify1(t), t.isZero() || t._isub(this.m, t), t;
    }
    neg(t) {
      return this.ineg(t.clone());
    }
    eq(t, d) {
      return this._verify2(t, d), t.ucmp(d) === 0;
    }
    eqn(t, d) {
      if (this._verify1(t), this.m.length === 1)
        return d %= this.m.words[0], d < 0 && (d += this.m.words[0]), t.ucmpn(d) === 0;
      if (d < 0) {
        this.m._isubn(-d);
        const B = t.ucmp(this.m);
        return this.m._iaddn(-d), B === 0;
      }
      return t.ucmpn(d) === 0;
    }
    isHigh(t) {
      return !this.isLow(t);
    }
    isLow(t) {
      return this._verify1(t), t.ucmp(this.m.ushrn(1)) <= 0;
    }
    isOdd(t) {
      return this._verify1(t), t.isOdd();
    }
    isEven(t) {
      return this._verify1(t), t.isEven();
    }
    legendre(t) {
      if (this._verify1(t), this.m.isEven())
        throw new Error("legendre: `num` must be odd.");
      const d = this.m.subn(1).iushrn(1), B = this.pow(t, d);
      if (B.isZero())
        return 0;
      const U = new s(1).toRed(this);
      if (B.eq(U))
        return 1;
      if (B.eq(this.ineg(U)))
        return -1;
      throw new Error("Invalid prime.");
    }
    jacobi(t) {
      return this._verify1(t), t.jacobi(this.m);
    }
    kronecker(t) {
      return this._verify1(t), t.kronecker(this.m);
    }
    iinvert(t) {
      return this.invert(t)._move(t);
    }
    invert(t) {
      return this._verify1(t), t.invert(this.m)._forceRed(this);
    }
    ifermat(t) {
      return this.fermat(t)._move(t);
    }
    fermat(t) {
      if (this._verify1(t), t.isZero() || this.m.cmpn(1) === 0)
        throw new RangeError("Not invertible.");
      return this.prime ? this.prime.fermat(t) : this.pow(t, this.m.subn(2));
    }
    invertAll(t) {
      _(Array.isArray(t), "elems", "array");
      for (const J of t)
        _(s.isBN(J), "elem", "bignum"), this._verify1(J);
      if (this.m.cmpn(1) === 0 || this.m.isEven())
        throw new RangeError("Not invertible.");
      const d = t.length, B = new Array(d);
      if (d === 0)
        return B;
      let U = new s(1).toRed(this);
      for (let J = 0; J < d; J++) {
        if (t[J].isZero()) {
          B[J] = t[J].clone();
          continue;
        }
        B[J] = U, U = this.mul(U, t[J]);
      }
      U = this.invert(U);
      for (let J = d - 1; J >= 0; J--)
        t[J].isZero() || (B[J] = this.mul(U, B[J]), U = this.mul(U, t[J]));
      return B;
    }
    [e]() {
      return this.prime ? `<Red: ${this.prime.name}>` : `<Red: ${this.m.toString(10)}>`;
    }
  }
  class N extends G {
    constructor(t) {
      super(t), this.prime = null, this.n = this.m.bitLength(), this.n % 26 !== 0 && (this.n += 26 - this.n % 26), this.k = this.n * 2, this.w = this.k / 26, this.b = s.shift(1, this.k).div(this.m);
    }
    convertTo(t) {
      return t.length > this.w ? super.convertTo(t) : this.imod(t.clone());
    }
    _shift(t) {
      let d = 0, B = this.w;
      for (; B < t.length; )
        t.words[d++] = t.words[B++];
      d === 0 && (t.words[d++] = 0), t.length = d;
    }
    imod(t) {
      const d = t.negative;
      q(t.length <= this.w), t.negative = 0;
      const B = t.mul(this.b);
      return this._shift(B), t._isub(t, B.mul(this.m)), t.ucmp(this.m) >= 0 && t._isub(t, this.m), d && !t.isZero() && t._isub(this.m, t), t.red = this, t;
    }
  }
  class T extends G {
    constructor(t) {
      super(t), this.prime = null, this.n = this.m.length * 26, this.r = s.shift(1, this.n), this.r2 = s.shift(1, this.n * 2).imod(this.m), this.ri = this.r.invert(this.m), this.mi = this.r.mul(this.ri).isubn(1).div(this.m), this.rib = null;
    }
    get mont() {
      return !0;
    }
    convertTo(t) {
      return t.isNeg() || t.ucmp(this.m) >= 0 ? this.imod(t.ushln(this.n)) : this.mul(t, this.r2);
    }
    convertFrom(t) {
      const d = this.mul(t, new s(1));
      return d.red = null, d;
    }
    intTo(t) {
      return (t << BigInt(this.n)) % this.mb;
    }
    intFrom(t) {
      return this.rib === null && (this.rib = this.ri.toBigInt()), t * this.rib % this.mb;
    }
    iaddn(t, d) {
      return this.iadd(t, this.convertTo(new s(d)));
    }
    isubn(t, d) {
      return this.isub(t, this.convertTo(new s(d)));
    }
    imul(t, d) {
      return this.mul(t, d)._move(t);
    }
    mul(t, d) {
      if (t.isZero() || d.isZero())
        return new s(0)._forceRed(this);
      const B = t.mul(d), U = B.umaskn(this.n).mul(this.mi).iumaskn(this.n), J = B.iadd(U.mul(this.m)).iushrn(this.n);
      return J.ucmp(this.m) >= 0 && J._isub(J, this.m), J._forceRed(this);
    }
    imuln(t, d) {
      if (this._verify1(t), t.isZero())
        return t;
      if (d === 0)
        return t.words[0] = 0, t.length = 1, t;
      const B = d < 0;
      B && (d = -d), this.m.length === 1 && (d %= this.m.words[0]);
      const U = oe(d);
      if (U > 5)
        this.imul(t, this.convertTo(new s(d)));
      else if ((d & d - 1) === 0)
        for (let J = 0; J < U - 1; J++)
          this.iadd(t, t);
      else {
        const J = t.clone();
        for (let C = U - 2; C >= 0; C--)
          this.iadd(t, t), d >> C & 1 && this.iadd(t, J);
      }
      return B && this.ineg(t), t;
    }
    eqn(t, d) {
      return this._verify1(t), d === 0 ? t.isZero() : t.ucmp(this.convertTo(new s(d))) === 0;
    }
    isLow(t) {
      return this._verify1(t), this.convertFrom(t).ucmp(this.m.ushrn(1)) <= 0;
    }
    isOdd(t) {
      return this._verify1(t), this.convertFrom(t).isOdd();
    }
    isEven(t) {
      return this._verify1(t), this.convertFrom(t).isEven();
    }
    invert(t) {
      return this._verify1(t), this.imod(t.invert(this.m).mul(this.r2));
    }
  }
  function A(ne, t, d) {
    const B = new ne(t);
    return ne.captureStackTrace && ne.captureStackTrace(B, d), B;
  }
  function q(ne, t) {
    if (!ne)
      throw A(Error, t || "Assertion failed.", q);
  }
  function _(ne, t, d) {
    if (!ne) {
      const B = `"${t}" must be a(n) ${d}.`;
      throw A(TypeError, B, _);
    }
  }
  function F(ne, t) {
    if (!ne) {
      const d = `"${t}" only works with positive numbers.`;
      throw A(RangeError, d, F);
    }
  }
  function R(ne, t) {
    if (!ne) {
      const d = `"${t}" only works with red numbers.`;
      throw A(TypeError, d, R);
    }
  }
  function L(ne, t) {
    if (!ne) {
      const d = `"${t}" only works with normal numbers.`;
      throw A(TypeError, d, L);
    }
  }
  function fe(ne) {
    if (!ne)
      throw A(RangeError, "Cannot divide by zero.", fe);
  }
  class ue extends Error {
    constructor(t) {
      super(), this.name = "SquareRootError", this.message = "X is not a square mod P.", this.result = t.fromRed(), Error.captureStackTrace && Error.captureStackTrace(this, ue);
    }
  }
  function ae(ne) {
    return Number.isSafeInteger(ne);
  }
  function D(ne) {
    return ae(ne) && ne >= -67108863 && ne <= 67108863;
  }
  function Q(ne, t) {
    return ne.allocUnsafeSlow ? ne.allocUnsafeSlow(t) : new ne(t);
  }
  function W(ne) {
    if (ne == null)
      return 10;
    if (typeof ne == "number")
      return ne;
    switch (ne) {
      case "bin":
        return 2;
      case "oct":
        return 8;
      case "dec":
        return 10;
      case "hex":
        return 16;
    }
    return 0;
  }
  function oe(ne) {
    if (Math.clz32)
      return 32 - Math.clz32(ne);
    let t = ne, d = 0;
    return t >= 4096 && (d += 13, t >>>= 13), t >= 64 && (d += 7, t >>>= 7), t >= 8 && (d += 4, t >>>= 4), t >= 2 && (d += 2, t >>>= 2), d + t;
  }
  function v(ne) {
    if (ne === 0)
      return 26;
    let t = ne, d = 0;
    return (t & 8191) === 0 && (d += 13, t >>>= 13), (t & 127) === 0 && (d += 7, t >>>= 7), (t & 15) === 0 && (d += 4, t >>>= 4), (t & 3) === 0 && (d += 2, t >>>= 2), (t & 1) === 0 && (d += 1), d;
  }
  function Y(ne, t, d) {
    const B = Math.min(ne.length, d);
    let U = 0, J = 0;
    for (let C = t; C < B; C++) {
      const M = ne.charCodeAt(C) - 48;
      U <<= 4;
      let $;
      M >= 49 && M <= 54 ? $ = M - 49 + 10 : M >= 17 && M <= 22 ? $ = M - 17 + 10 : $ = M, U |= $, J |= $;
    }
    if (J & -16)
      throw new Error("Invalid string.");
    return U;
  }
  function he(ne, t, d, B) {
    const U = Math.min(ne.length, d);
    let J = 0;
    for (let C = t; C < U; C++) {
      const M = ne.charCodeAt(C) - 48;
      J *= B;
      let $;
      if (M >= 49 ? $ = M - 49 + 10 : M >= 17 ? $ = M - 17 + 10 : $ = M, M < 0 || M > 207 || $ >= B)
        throw new Error("Invalid string.");
      J += $;
    }
    return J;
  }
  function le(ne, t, d) {
    const B = BigInt(1), U = new Array(u), J = ne * ne % d;
    U[0] = ne;
    for (let $ = 1; $ < u; $++)
      U[$] = U[$ - 1] * J % d;
    let C = t.bitLength(), M = B;
    for (; C >= n; ) {
      let $ = n, r = t.bits(C - $, $);
      if (r < u) {
        M = M * M % d, C -= 1;
        continue;
      }
      for (; (r & 1) === 0; )
        $ -= 1, r >>= 1;
      M === B ? M = U[r >> 1] : (M = ge(M, $, d), M = M * U[r >> 1] % d), C -= $;
    }
    if (C > 0) {
      const $ = t.bits(0, C);
      for (; C--; )
        M = M * M % d, $ >> C & 1 && (M = M * ne % d);
    }
    return M;
  }
  function ge(ne, t, d) {
    for (let B = 0; B < t; B++)
      ne = ne * ne % d;
    return ne;
  }
  function Ee(ne, t, d) {
    const B = ne.length + t.length;
    d.negative = ne.negative ^ t.negative, d._alloc(B), d.length = B;
    const U = ne.words[0], J = t.words[0], C = U * J, M = C & 67108863;
    let $ = C / 67108864 | 0, r = 1;
    for (d.words[0] = M; r < d.length - 1; r++) {
      let x = $ >>> 26, O = $ & 67108863;
      const K = Math.max(0, r - ne.length + 1), X = Math.min(r, t.length - 1);
      for (let P = K; P <= X; P++) {
        const V = r - P, re = ne.words[V], ce = t.words[P], de = re * ce + O;
        x += de / 67108864 | 0, O = de & 67108863;
      }
      d.words[r] = O | 0, $ = x | 0;
    }
    return $ !== 0 ? d.words[r] = $ | 0 : d.length -= 1, d._strip();
  }
  function we(ne, t, d) {
    const B = ne.length + t.length;
    d.negative = ne.negative ^ t.negative, d._alloc(B), d.length = B;
    let U = 0, J = 0, C = 0;
    for (; C < d.length - 1; C++) {
      let M = J;
      J = 0;
      let $ = U & 67108863;
      const r = Math.max(0, C - ne.length + 1), x = Math.min(C, t.length - 1);
      for (let O = r; O <= x; O++) {
        const K = C - O, X = ne.words[K], P = t.words[O], V = X * P;
        let re = V & 67108863;
        M = M + (V / 67108864 | 0) | 0, re = re + $ | 0, $ = re & 67108863, M = M + (re >>> 26) | 0, J += M >>> 26, M &= 67108863;
      }
      d.words[C] = $, U = M, M = J;
    }
    return U !== 0 ? d.words[C] = U : d.length -= 1, d._strip();
  }
  function z(ne, t, d) {
    if (!o || ne.length + t.length > 82595519)
      return we(ne, t, d);
    const B = BigInt(0), U = BigInt(67108863), J = BigInt(26);
    let C = ne.toBigInt() * t.toBigInt();
    const M = C < B | 0;
    M && (C = -C);
    let $ = 0;
    for (; C > B; )
      d.words[$++] = Number(C & U), C >>= J;
    return $ === 0 && (d.words[$++] = 0), d.length = $, d.negative = M, d;
  }
  function I(ne, t, d) {
    const B = ne.words, U = t.words, J = d.words, C = B[0] | 0, M = C & 8191, $ = C >>> 13, r = B[1] | 0, x = r & 8191, O = r >>> 13, K = B[2] | 0, X = K & 8191, P = K >>> 13, V = B[3] | 0, re = V & 8191, ce = V >>> 13, de = B[4] | 0, pe = de & 8191, se = de >>> 13, Z = B[5] | 0, ee = Z & 8191, me = Z >>> 13, Ae = B[6] | 0, Oe = Ae & 8191, ye = Ae >>> 13, _e = B[7] | 0, ke = _e & 8191, Me = _e >>> 13, De = B[8] | 0, Ne = De & 8191, $e = De >>> 13, bt = B[9] | 0, Ve = bt & 8191, je = bt >>> 13, _t = U[0] | 0, Je = _t & 8191, Ye = _t >>> 13, Ot = U[1] | 0, We = Ot & 8191, Ze = Ot >>> 13, Tt = U[2] | 0, Qe = Tt & 8191, rt = Tt >>> 13, ur = U[3] | 0, nt = ur & 8191, ft = ur >>> 13, gr = U[4] | 0, et = gr & 8191, ct = gr >>> 13, hr = U[5] | 0, ut = hr & 8191, lt = hr >>> 13, lr = U[6] | 0, tt = lr & 8191, it = lr >>> 13, _r = U[7] | 0, st = _r & 8191, gt = _r >>> 13, Dr = U[8] | 0, ot = Dr & 8191, pt = Dr >>> 13, nr = U[9] | 0, ht = nr & 8191, at = nr >>> 13;
    let Ke = 0, Se, te, ve;
    d.negative = ne.negative ^ t.negative, d._alloc(20), d.length = 19, Se = Math.imul(M, Je), te = Math.imul(M, Ye), te = te + Math.imul($, Je) | 0, ve = Math.imul($, Ye);
    let Dt = (Ke + Se | 0) + ((te & 8191) << 13) | 0;
    Ke = (ve + (te >>> 13) | 0) + (Dt >>> 26) | 0, Dt &= 67108863, Se = Math.imul(x, Je), te = Math.imul(x, Ye), te = te + Math.imul(O, Je) | 0, ve = Math.imul(O, Ye), Se = Se + Math.imul(M, We) | 0, te = te + Math.imul(M, Ze) | 0, te = te + Math.imul($, We) | 0, ve = ve + Math.imul($, Ze) | 0;
    let xe = (Ke + Se | 0) + ((te & 8191) << 13) | 0;
    Ke = (ve + (te >>> 13) | 0) + (xe >>> 26) | 0, xe &= 67108863, Se = Math.imul(X, Je), te = Math.imul(X, Ye), te = te + Math.imul(P, Je) | 0, ve = Math.imul(P, Ye), Se = Se + Math.imul(x, We) | 0, te = te + Math.imul(x, Ze) | 0, te = te + Math.imul(O, We) | 0, ve = ve + Math.imul(O, Ze) | 0, Se = Se + Math.imul(M, Qe) | 0, te = te + Math.imul(M, rt) | 0, te = te + Math.imul($, Qe) | 0, ve = ve + Math.imul($, rt) | 0;
    let ie = (Ke + Se | 0) + ((te & 8191) << 13) | 0;
    Ke = (ve + (te >>> 13) | 0) + (ie >>> 26) | 0, ie &= 67108863, Se = Math.imul(re, Je), te = Math.imul(re, Ye), te = te + Math.imul(ce, Je) | 0, ve = Math.imul(ce, Ye), Se = Se + Math.imul(X, We) | 0, te = te + Math.imul(X, Ze) | 0, te = te + Math.imul(P, We) | 0, ve = ve + Math.imul(P, Ze) | 0, Se = Se + Math.imul(x, Qe) | 0, te = te + Math.imul(x, rt) | 0, te = te + Math.imul(O, Qe) | 0, ve = ve + Math.imul(O, rt) | 0, Se = Se + Math.imul(M, nt) | 0, te = te + Math.imul(M, ft) | 0, te = te + Math.imul($, nt) | 0, ve = ve + Math.imul($, ft) | 0;
    let be = (Ke + Se | 0) + ((te & 8191) << 13) | 0;
    Ke = (ve + (te >>> 13) | 0) + (be >>> 26) | 0, be &= 67108863, Se = Math.imul(pe, Je), te = Math.imul(pe, Ye), te = te + Math.imul(se, Je) | 0, ve = Math.imul(se, Ye), Se = Se + Math.imul(re, We) | 0, te = te + Math.imul(re, Ze) | 0, te = te + Math.imul(ce, We) | 0, ve = ve + Math.imul(ce, Ze) | 0, Se = Se + Math.imul(X, Qe) | 0, te = te + Math.imul(X, rt) | 0, te = te + Math.imul(P, Qe) | 0, ve = ve + Math.imul(P, rt) | 0, Se = Se + Math.imul(x, nt) | 0, te = te + Math.imul(x, ft) | 0, te = te + Math.imul(O, nt) | 0, ve = ve + Math.imul(O, ft) | 0, Se = Se + Math.imul(M, et) | 0, te = te + Math.imul(M, ct) | 0, te = te + Math.imul($, et) | 0, ve = ve + Math.imul($, ct) | 0;
    let Ie = (Ke + Se | 0) + ((te & 8191) << 13) | 0;
    Ke = (ve + (te >>> 13) | 0) + (Ie >>> 26) | 0, Ie &= 67108863, Se = Math.imul(ee, Je), te = Math.imul(ee, Ye), te = te + Math.imul(me, Je) | 0, ve = Math.imul(me, Ye), Se = Se + Math.imul(pe, We) | 0, te = te + Math.imul(pe, Ze) | 0, te = te + Math.imul(se, We) | 0, ve = ve + Math.imul(se, Ze) | 0, Se = Se + Math.imul(re, Qe) | 0, te = te + Math.imul(re, rt) | 0, te = te + Math.imul(ce, Qe) | 0, ve = ve + Math.imul(ce, rt) | 0, Se = Se + Math.imul(X, nt) | 0, te = te + Math.imul(X, ft) | 0, te = te + Math.imul(P, nt) | 0, ve = ve + Math.imul(P, ft) | 0, Se = Se + Math.imul(x, et) | 0, te = te + Math.imul(x, ct) | 0, te = te + Math.imul(O, et) | 0, ve = ve + Math.imul(O, ct) | 0, Se = Se + Math.imul(M, ut) | 0, te = te + Math.imul(M, lt) | 0, te = te + Math.imul($, ut) | 0, ve = ve + Math.imul($, lt) | 0;
    let Re = (Ke + Se | 0) + ((te & 8191) << 13) | 0;
    Ke = (ve + (te >>> 13) | 0) + (Re >>> 26) | 0, Re &= 67108863, Se = Math.imul(Oe, Je), te = Math.imul(Oe, Ye), te = te + Math.imul(ye, Je) | 0, ve = Math.imul(ye, Ye), Se = Se + Math.imul(ee, We) | 0, te = te + Math.imul(ee, Ze) | 0, te = te + Math.imul(me, We) | 0, ve = ve + Math.imul(me, Ze) | 0, Se = Se + Math.imul(pe, Qe) | 0, te = te + Math.imul(pe, rt) | 0, te = te + Math.imul(se, Qe) | 0, ve = ve + Math.imul(se, rt) | 0, Se = Se + Math.imul(re, nt) | 0, te = te + Math.imul(re, ft) | 0, te = te + Math.imul(ce, nt) | 0, ve = ve + Math.imul(ce, ft) | 0, Se = Se + Math.imul(X, et) | 0, te = te + Math.imul(X, ct) | 0, te = te + Math.imul(P, et) | 0, ve = ve + Math.imul(P, ct) | 0, Se = Se + Math.imul(x, ut) | 0, te = te + Math.imul(x, lt) | 0, te = te + Math.imul(O, ut) | 0, ve = ve + Math.imul(O, lt) | 0, Se = Se + Math.imul(M, tt) | 0, te = te + Math.imul(M, it) | 0, te = te + Math.imul($, tt) | 0, ve = ve + Math.imul($, it) | 0;
    let Be = (Ke + Se | 0) + ((te & 8191) << 13) | 0;
    Ke = (ve + (te >>> 13) | 0) + (Be >>> 26) | 0, Be &= 67108863, Se = Math.imul(ke, Je), te = Math.imul(ke, Ye), te = te + Math.imul(Me, Je) | 0, ve = Math.imul(Me, Ye), Se = Se + Math.imul(Oe, We) | 0, te = te + Math.imul(Oe, Ze) | 0, te = te + Math.imul(ye, We) | 0, ve = ve + Math.imul(ye, Ze) | 0, Se = Se + Math.imul(ee, Qe) | 0, te = te + Math.imul(ee, rt) | 0, te = te + Math.imul(me, Qe) | 0, ve = ve + Math.imul(me, rt) | 0, Se = Se + Math.imul(pe, nt) | 0, te = te + Math.imul(pe, ft) | 0, te = te + Math.imul(se, nt) | 0, ve = ve + Math.imul(se, ft) | 0, Se = Se + Math.imul(re, et) | 0, te = te + Math.imul(re, ct) | 0, te = te + Math.imul(ce, et) | 0, ve = ve + Math.imul(ce, ct) | 0, Se = Se + Math.imul(X, ut) | 0, te = te + Math.imul(X, lt) | 0, te = te + Math.imul(P, ut) | 0, ve = ve + Math.imul(P, lt) | 0, Se = Se + Math.imul(x, tt) | 0, te = te + Math.imul(x, it) | 0, te = te + Math.imul(O, tt) | 0, ve = ve + Math.imul(O, it) | 0, Se = Se + Math.imul(M, st) | 0, te = te + Math.imul(M, gt) | 0, te = te + Math.imul($, st) | 0, ve = ve + Math.imul($, gt) | 0;
    let Pe = (Ke + Se | 0) + ((te & 8191) << 13) | 0;
    Ke = (ve + (te >>> 13) | 0) + (Pe >>> 26) | 0, Pe &= 67108863, Se = Math.imul(Ne, Je), te = Math.imul(Ne, Ye), te = te + Math.imul($e, Je) | 0, ve = Math.imul($e, Ye), Se = Se + Math.imul(ke, We) | 0, te = te + Math.imul(ke, Ze) | 0, te = te + Math.imul(Me, We) | 0, ve = ve + Math.imul(Me, Ze) | 0, Se = Se + Math.imul(Oe, Qe) | 0, te = te + Math.imul(Oe, rt) | 0, te = te + Math.imul(ye, Qe) | 0, ve = ve + Math.imul(ye, rt) | 0, Se = Se + Math.imul(ee, nt) | 0, te = te + Math.imul(ee, ft) | 0, te = te + Math.imul(me, nt) | 0, ve = ve + Math.imul(me, ft) | 0, Se = Se + Math.imul(pe, et) | 0, te = te + Math.imul(pe, ct) | 0, te = te + Math.imul(se, et) | 0, ve = ve + Math.imul(se, ct) | 0, Se = Se + Math.imul(re, ut) | 0, te = te + Math.imul(re, lt) | 0, te = te + Math.imul(ce, ut) | 0, ve = ve + Math.imul(ce, lt) | 0, Se = Se + Math.imul(X, tt) | 0, te = te + Math.imul(X, it) | 0, te = te + Math.imul(P, tt) | 0, ve = ve + Math.imul(P, it) | 0, Se = Se + Math.imul(x, st) | 0, te = te + Math.imul(x, gt) | 0, te = te + Math.imul(O, st) | 0, ve = ve + Math.imul(O, gt) | 0, Se = Se + Math.imul(M, ot) | 0, te = te + Math.imul(M, pt) | 0, te = te + Math.imul($, ot) | 0, ve = ve + Math.imul($, pt) | 0;
    let qe = (Ke + Se | 0) + ((te & 8191) << 13) | 0;
    Ke = (ve + (te >>> 13) | 0) + (qe >>> 26) | 0, qe &= 67108863, Se = Math.imul(Ve, Je), te = Math.imul(Ve, Ye), te = te + Math.imul(je, Je) | 0, ve = Math.imul(je, Ye), Se = Se + Math.imul(Ne, We) | 0, te = te + Math.imul(Ne, Ze) | 0, te = te + Math.imul($e, We) | 0, ve = ve + Math.imul($e, Ze) | 0, Se = Se + Math.imul(ke, Qe) | 0, te = te + Math.imul(ke, rt) | 0, te = te + Math.imul(Me, Qe) | 0, ve = ve + Math.imul(Me, rt) | 0, Se = Se + Math.imul(Oe, nt) | 0, te = te + Math.imul(Oe, ft) | 0, te = te + Math.imul(ye, nt) | 0, ve = ve + Math.imul(ye, ft) | 0, Se = Se + Math.imul(ee, et) | 0, te = te + Math.imul(ee, ct) | 0, te = te + Math.imul(me, et) | 0, ve = ve + Math.imul(me, ct) | 0, Se = Se + Math.imul(pe, ut) | 0, te = te + Math.imul(pe, lt) | 0, te = te + Math.imul(se, ut) | 0, ve = ve + Math.imul(se, lt) | 0, Se = Se + Math.imul(re, tt) | 0, te = te + Math.imul(re, it) | 0, te = te + Math.imul(ce, tt) | 0, ve = ve + Math.imul(ce, it) | 0, Se = Se + Math.imul(X, st) | 0, te = te + Math.imul(X, gt) | 0, te = te + Math.imul(P, st) | 0, ve = ve + Math.imul(P, gt) | 0, Se = Se + Math.imul(x, ot) | 0, te = te + Math.imul(x, pt) | 0, te = te + Math.imul(O, ot) | 0, ve = ve + Math.imul(O, pt) | 0, Se = Se + Math.imul(M, ht) | 0, te = te + Math.imul(M, at) | 0, te = te + Math.imul($, ht) | 0, ve = ve + Math.imul($, at) | 0;
    let Te = (Ke + Se | 0) + ((te & 8191) << 13) | 0;
    Ke = (ve + (te >>> 13) | 0) + (Te >>> 26) | 0, Te &= 67108863, Se = Math.imul(Ve, We), te = Math.imul(Ve, Ze), te = te + Math.imul(je, We) | 0, ve = Math.imul(je, Ze), Se = Se + Math.imul(Ne, Qe) | 0, te = te + Math.imul(Ne, rt) | 0, te = te + Math.imul($e, Qe) | 0, ve = ve + Math.imul($e, rt) | 0, Se = Se + Math.imul(ke, nt) | 0, te = te + Math.imul(ke, ft) | 0, te = te + Math.imul(Me, nt) | 0, ve = ve + Math.imul(Me, ft) | 0, Se = Se + Math.imul(Oe, et) | 0, te = te + Math.imul(Oe, ct) | 0, te = te + Math.imul(ye, et) | 0, ve = ve + Math.imul(ye, ct) | 0, Se = Se + Math.imul(ee, ut) | 0, te = te + Math.imul(ee, lt) | 0, te = te + Math.imul(me, ut) | 0, ve = ve + Math.imul(me, lt) | 0, Se = Se + Math.imul(pe, tt) | 0, te = te + Math.imul(pe, it) | 0, te = te + Math.imul(se, tt) | 0, ve = ve + Math.imul(se, it) | 0, Se = Se + Math.imul(re, st) | 0, te = te + Math.imul(re, gt) | 0, te = te + Math.imul(ce, st) | 0, ve = ve + Math.imul(ce, gt) | 0, Se = Se + Math.imul(X, ot) | 0, te = te + Math.imul(X, pt) | 0, te = te + Math.imul(P, ot) | 0, ve = ve + Math.imul(P, pt) | 0, Se = Se + Math.imul(x, ht) | 0, te = te + Math.imul(x, at) | 0, te = te + Math.imul(O, ht) | 0, ve = ve + Math.imul(O, at) | 0;
    let Ue = (Ke + Se | 0) + ((te & 8191) << 13) | 0;
    Ke = (ve + (te >>> 13) | 0) + (Ue >>> 26) | 0, Ue &= 67108863, Se = Math.imul(Ve, Qe), te = Math.imul(Ve, rt), te = te + Math.imul(je, Qe) | 0, ve = Math.imul(je, rt), Se = Se + Math.imul(Ne, nt) | 0, te = te + Math.imul(Ne, ft) | 0, te = te + Math.imul($e, nt) | 0, ve = ve + Math.imul($e, ft) | 0, Se = Se + Math.imul(ke, et) | 0, te = te + Math.imul(ke, ct) | 0, te = te + Math.imul(Me, et) | 0, ve = ve + Math.imul(Me, ct) | 0, Se = Se + Math.imul(Oe, ut) | 0, te = te + Math.imul(Oe, lt) | 0, te = te + Math.imul(ye, ut) | 0, ve = ve + Math.imul(ye, lt) | 0, Se = Se + Math.imul(ee, tt) | 0, te = te + Math.imul(ee, it) | 0, te = te + Math.imul(me, tt) | 0, ve = ve + Math.imul(me, it) | 0, Se = Se + Math.imul(pe, st) | 0, te = te + Math.imul(pe, gt) | 0, te = te + Math.imul(se, st) | 0, ve = ve + Math.imul(se, gt) | 0, Se = Se + Math.imul(re, ot) | 0, te = te + Math.imul(re, pt) | 0, te = te + Math.imul(ce, ot) | 0, ve = ve + Math.imul(ce, pt) | 0, Se = Se + Math.imul(X, ht) | 0, te = te + Math.imul(X, at) | 0, te = te + Math.imul(P, ht) | 0, ve = ve + Math.imul(P, at) | 0;
    let Fe = (Ke + Se | 0) + ((te & 8191) << 13) | 0;
    Ke = (ve + (te >>> 13) | 0) + (Fe >>> 26) | 0, Fe &= 67108863, Se = Math.imul(Ve, nt), te = Math.imul(Ve, ft), te = te + Math.imul(je, nt) | 0, ve = Math.imul(je, ft), Se = Se + Math.imul(Ne, et) | 0, te = te + Math.imul(Ne, ct) | 0, te = te + Math.imul($e, et) | 0, ve = ve + Math.imul($e, ct) | 0, Se = Se + Math.imul(ke, ut) | 0, te = te + Math.imul(ke, lt) | 0, te = te + Math.imul(Me, ut) | 0, ve = ve + Math.imul(Me, lt) | 0, Se = Se + Math.imul(Oe, tt) | 0, te = te + Math.imul(Oe, it) | 0, te = te + Math.imul(ye, tt) | 0, ve = ve + Math.imul(ye, it) | 0, Se = Se + Math.imul(ee, st) | 0, te = te + Math.imul(ee, gt) | 0, te = te + Math.imul(me, st) | 0, ve = ve + Math.imul(me, gt) | 0, Se = Se + Math.imul(pe, ot) | 0, te = te + Math.imul(pe, pt) | 0, te = te + Math.imul(se, ot) | 0, ve = ve + Math.imul(se, pt) | 0, Se = Se + Math.imul(re, ht) | 0, te = te + Math.imul(re, at) | 0, te = te + Math.imul(ce, ht) | 0, ve = ve + Math.imul(ce, at) | 0;
    let Le = (Ke + Se | 0) + ((te & 8191) << 13) | 0;
    Ke = (ve + (te >>> 13) | 0) + (Le >>> 26) | 0, Le &= 67108863, Se = Math.imul(Ve, et), te = Math.imul(Ve, ct), te = te + Math.imul(je, et) | 0, ve = Math.imul(je, ct), Se = Se + Math.imul(Ne, ut) | 0, te = te + Math.imul(Ne, lt) | 0, te = te + Math.imul($e, ut) | 0, ve = ve + Math.imul($e, lt) | 0, Se = Se + Math.imul(ke, tt) | 0, te = te + Math.imul(ke, it) | 0, te = te + Math.imul(Me, tt) | 0, ve = ve + Math.imul(Me, it) | 0, Se = Se + Math.imul(Oe, st) | 0, te = te + Math.imul(Oe, gt) | 0, te = te + Math.imul(ye, st) | 0, ve = ve + Math.imul(ye, gt) | 0, Se = Se + Math.imul(ee, ot) | 0, te = te + Math.imul(ee, pt) | 0, te = te + Math.imul(me, ot) | 0, ve = ve + Math.imul(me, pt) | 0, Se = Se + Math.imul(pe, ht) | 0, te = te + Math.imul(pe, at) | 0, te = te + Math.imul(se, ht) | 0, ve = ve + Math.imul(se, at) | 0;
    let Ge = (Ke + Se | 0) + ((te & 8191) << 13) | 0;
    Ke = (ve + (te >>> 13) | 0) + (Ge >>> 26) | 0, Ge &= 67108863, Se = Math.imul(Ve, ut), te = Math.imul(Ve, lt), te = te + Math.imul(je, ut) | 0, ve = Math.imul(je, lt), Se = Se + Math.imul(Ne, tt) | 0, te = te + Math.imul(Ne, it) | 0, te = te + Math.imul($e, tt) | 0, ve = ve + Math.imul($e, it) | 0, Se = Se + Math.imul(ke, st) | 0, te = te + Math.imul(ke, gt) | 0, te = te + Math.imul(Me, st) | 0, ve = ve + Math.imul(Me, gt) | 0, Se = Se + Math.imul(Oe, ot) | 0, te = te + Math.imul(Oe, pt) | 0, te = te + Math.imul(ye, ot) | 0, ve = ve + Math.imul(ye, pt) | 0, Se = Se + Math.imul(ee, ht) | 0, te = te + Math.imul(ee, at) | 0, te = te + Math.imul(me, ht) | 0, ve = ve + Math.imul(me, at) | 0;
    let mt = (Ke + Se | 0) + ((te & 8191) << 13) | 0;
    Ke = (ve + (te >>> 13) | 0) + (mt >>> 26) | 0, mt &= 67108863, Se = Math.imul(Ve, tt), te = Math.imul(Ve, it), te = te + Math.imul(je, tt) | 0, ve = Math.imul(je, it), Se = Se + Math.imul(Ne, st) | 0, te = te + Math.imul(Ne, gt) | 0, te = te + Math.imul($e, st) | 0, ve = ve + Math.imul($e, gt) | 0, Se = Se + Math.imul(ke, ot) | 0, te = te + Math.imul(ke, pt) | 0, te = te + Math.imul(Me, ot) | 0, ve = ve + Math.imul(Me, pt) | 0, Se = Se + Math.imul(Oe, ht) | 0, te = te + Math.imul(Oe, at) | 0, te = te + Math.imul(ye, ht) | 0, ve = ve + Math.imul(ye, at) | 0;
    let Et = (Ke + Se | 0) + ((te & 8191) << 13) | 0;
    Ke = (ve + (te >>> 13) | 0) + (Et >>> 26) | 0, Et &= 67108863, Se = Math.imul(Ve, st), te = Math.imul(Ve, gt), te = te + Math.imul(je, st) | 0, ve = Math.imul(je, gt), Se = Se + Math.imul(Ne, ot) | 0, te = te + Math.imul(Ne, pt) | 0, te = te + Math.imul($e, ot) | 0, ve = ve + Math.imul($e, pt) | 0, Se = Se + Math.imul(ke, ht) | 0, te = te + Math.imul(ke, at) | 0, te = te + Math.imul(Me, ht) | 0, ve = ve + Math.imul(Me, at) | 0;
    let It = (Ke + Se | 0) + ((te & 8191) << 13) | 0;
    Ke = (ve + (te >>> 13) | 0) + (It >>> 26) | 0, It &= 67108863, Se = Math.imul(Ve, ot), te = Math.imul(Ve, pt), te = te + Math.imul(je, ot) | 0, ve = Math.imul(je, pt), Se = Se + Math.imul(Ne, ht) | 0, te = te + Math.imul(Ne, at) | 0, te = te + Math.imul($e, ht) | 0, ve = ve + Math.imul($e, at) | 0;
    let kt = (Ke + Se | 0) + ((te & 8191) << 13) | 0;
    Ke = (ve + (te >>> 13) | 0) + (kt >>> 26) | 0, kt &= 67108863, Se = Math.imul(Ve, ht), te = Math.imul(Ve, at), te = te + Math.imul(je, ht) | 0, ve = Math.imul(je, at);
    let Rt = (Ke + Se | 0) + ((te & 8191) << 13) | 0;
    return Ke = (ve + (te >>> 13) | 0) + (Rt >>> 26) | 0, Rt &= 67108863, J[0] = Dt, J[1] = xe, J[2] = ie, J[3] = be, J[4] = Ie, J[5] = Re, J[6] = Be, J[7] = Pe, J[8] = qe, J[9] = Te, J[10] = Ue, J[11] = Fe, J[12] = Le, J[13] = Ge, J[14] = mt, J[15] = Et, J[16] = It, J[17] = kt, J[18] = Rt, Ke !== 0 && (J[19] = Ke, d.length += 1), d;
  }
  return Math.imul || (I = Ee), s.Red = G, ba = s, ba;
}
/*!
 * network.js - bitcoin networks for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * Copyright (c) 2019-2020, Jonathan Gonzalez (MIT License).
 * https://github.com/cash-org/cashnode
 */
var xd;
function El() {
  return xd || (xd = 1, function(e) {
    const c = jr(), l = e;
    function w(o) {
      return k.from(o, "hex");
    }
    l.types = ["main", "testnet", "regtest", "simnet"];
    const m = {};
    m.type = "main", m.seeds = [
      "seed.flowee.cash",
      "seed-bch.bitcoinforks.org",
      "btccash-seeder.bitcoinunlimited.info",
      "seed.bchd.cash",
      "seed.bch.loping.net",
      "dnsseed.electroncash.de"
    ], m.magic = 3908297187, m.port = 8333, m.checkpointMap = {
      11111: w("1d7c6eb2fd42f55925e92efad68b61edd22fba29fde8783df744e26900000000"),
      33333: w("a6d0b5df7d0df069ceb1e736a216ad187a50b07aaa4e78748a58d52d00000000"),
      74e3: w("201a66b853f9e7814a820e2af5f5dc79c07144e31ce4c9a39339570000000000"),
      105e3: w("97dc6b1d15fbeef373a744fee0b254b0d2c820a3ae7f0228ce91020000000000"),
      134444: w("feb0d2420d4a18914c81ac30f494a5d4ff34cd15d34cfd2fb105000000000000"),
      168e3: w("63b703835cb735cb9a89d733cbe66f212f63795e0172ea619e09000000000000"),
      193e3: w("17138bca83bdc3e6f60f01177c3877a98266de40735f2a459f05000000000000"),
      21e4: w("2e3471a19b8e22b7f939c63663076603cf692f19837e34958b04000000000000"),
      216116: w("4edf231bf170234e6a811460f95c94af9464e41ee833b4f4b401000000000000"),
      225430: w("32595730b165f097e7b806a679cf7f3e439040f750433808c101000000000000"),
      25e4: w("14d2f24d29bed75354f3f88a5fb50022fc064b02291fdf873800000000000000"),
      279e3: w("407ebde958e44190fa9e810ea1fc3a7ef601c3b0a0728cae0100000000000000"),
      295e3: w("83a93246c67003105af33ae0b29dd66f689d0f0ff54e9b4d0000000000000000"),
      300255: w("b2f3a0f0de4120c1089d5f5280a263059f9b6e7c520428160000000000000000"),
      319400: w("3bf115fd057391587ca39a531c5d4989e1adec9b2e05c6210000000000000000"),
      343185: w("548536d48e7678fcfa034202dd45d4a76b1ad061f38b2b070000000000000000"),
      352940: w("ffc9520143e41c94b6e03c2fa3e62bb76b55ba2df45d75100000000000000000"),
      382320: w("b28afdde92b0899715e40362f56afdb20e3d135bedc68d0a0000000000000000"),
      401465: w("eed16cb3e893ed9366f27c39a9ecd95465d02e3ef40e45010000000000000000"),
      42e4: w("a1ff746b2d42b834cb7d6b8981b09c265c2cabc016e8cc020000000000000000"),
      44e4: w("9bf296b8de5f834f7635d5e258a434ad51b4dbbcf7c08c030000000000000000"),
      45e4: w("0ba2070c62cd9da1f8cef88a0648c661a411d33e728340010000000000000000"),
      46e4: w("8c25fc7e414d3e868d6ce0ec473c30ad44e7e8bc1b75ef000000000000000000"),
      47e4: w("89756d1ed75901437300af10d5ab69070a282e729c536c000000000000000000"),
      // UAHF fork block:
      478559: w("ec5e1a193601f25ff1d94b421ddead0dbefcb99cf91e65000000000000000000"),
      48e4: w("f93408ffca92d88a6e46d3b90046f97bde6be0c08e7ed40c0000000000000000"),
      49e4: w("d1c65d766c6dc270b8ff4f1edb052fb71dc2b4750ede8a010000000000000000"),
      5e5: w("01b2328355f4a4dc9efa5c610687304507b7df9f3f4de1050000000000000000"),
      // DAA fork block
      504031: w("9cabb6ee1b1a4c3b659d70be75810be83d0a0db665bf1e010000000000000000"),
      51e4: w("040e6b1f2f4cb198a5780d366bf81e591de257642b9267030000000000000000"),
      525e3: w("c994fba2bf168333fd969bcfa64f03ca1b62074f9a8f1b010000000000000000"),
      // Monolith Activation
      530359: w("0391c40195cf8ae3436f3955f1a8444f07468fd08bda1a010000000000000000"),
      // Magnetic Anomaly Activation:
      556767: w("6cd5e644acccee5743ce2e93c541d34169933b6eff2646000000000000000000"),
      // Great Wall Activation:
      582680: w("18cc7d8c39ca16dc749acb7278a471964f7dec6ae3b8b4010000000000000000"),
      // Graviton Activation:
      609136: w("b1c55b4f69aa2e3209c91ae413c355c65aacfa07b28bb4000000000000000000"),
      // Phonon Activation:
      635259: w("f73075b2c598f49b3a19558c070b52d5a5d6c21fefdf33000000000000000000"),
      // Axion Activation:
      661648: w("7d7510f907bdc9bd2907e56beceaef31f78f2c8b9d4c28040000000000000000"),
      664198: w("60824622a1d2b689fbb234ce2c5939ff92e8ed8c57902f0c0000000000000000"),
      680140: w("0b7c2ff6c3658cb3f846aa092145c44a1d45638b56482c230000000000000000"),
      // Tachyon Activation
      686621: w("45b7e5be980bd6e98a22f895fcdc80546d9f0a57f7e68f3c0000000000000000"),
      // Selectron Activation
      713661: w("8defaaea383ab73c75ceea3f08190f3ab5ccc70743f876060000000000000000"),
      // Gluon activation
      739536: w("617bfc596bce59b129242fe67b5afe0509560946cd04db060000000000000000"),
      // Jefferson activation
      766195: w("94e0246db72955957dedb431eb1096de9a5b715348c92b100000000000000000")
    }, m.lastCheckpoint = 525e3, m.halvingInterval = 21e4, m.genesis = {
      version: 1,
      hash: w("6fe28c0ab6f1b372c1a6a246ae63f74f931e8365e15a089c68d6190000000000"),
      prevBlock: w("0000000000000000000000000000000000000000000000000000000000000000"),
      merkleRoot: w("3ba3edfd7a7b12b27ac72c3e67768f617fc81bc3888a51323a9fb8aa4b1e5e4a"),
      time: 1231006505,
      bits: 486604799,
      nonce: 2083236893,
      height: 0
    }, m.genesisBlock = "0100000000000000000000000000000000000000000000000000000000000000000000003ba3edfd7a7b12b27ac72c3e67768f617fc81bc3888a51323a9fb8aa4b1e5e4a29ab5f49ffff001d1dac2b7c0101000000010000000000000000000000000000000000000000000000000000000000000000ffffffff4d04ffff001d0104455468652054696d65732030332f4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66207365636f6e64206261696c6f757420666f722062616e6b73ffffffff0100f2052a01000000434104678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5fac00000000", m.pow = {
      /**
       * Default target.
       * @const {BN}
       */
      limit: new c(
        "00000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
        "hex"
      ),
      /**
       * Compact pow limit.
       * @const {Number}
       * @default
       */
      bits: 486604799,
      /**
       * Half Life value used in DAA.
       * Represents the value of two days in seconds
       * @const {Number}
       * @default
       */
      halfLife: 172800,
      /**
       * Minimum chainwork for best chain.
       * @const {BN}
       */
      chainwork: new c(
        "0000000000000000000000000000000000000000013c95e14d4d9db91d671020",
        "hex"
      ),
      /**
       * Desired retarget period in seconds.
       * @const {Number}
       * @default
       */
      targetTimespan: 336 * 60 * 60,
      /**
       * Average block time.
       * @const {Number}
       * @default
       */
      targetSpacing: 600,
      /**
       * Retarget interval in blocks.
       * @const {Number}
       * @default
       */
      retargetInterval: 2016,
      /**
       * Whether to reset target if a block
       * has not been mined recently.
       * @const {Boolean}
       * @default
       */
      targetReset: !1,
      /**
       * Do not allow retargetting.
       * @const {Boolean}
       * @default
       */
      noRetargeting: !1
    }, m.block = {
      /**
       * Height at which bip34 was activated.
       * Used for avoiding bip30 checks.
       */
      bip34height: 227931,
      /**
       * Hash of the block that activated bip34.
       */
      bip34hash: w("b808089c756add1591b1d17bab44bba3fed9e02f942ab4894b02000000000000"),
      /**
       * Height at which bip65 was activated.
       */
      bip65height: 388381,
      /**
       * Hash of the block that activated bip65.
       */
      bip65hash: w("f035476cfaeb9f677c2cdad00fd908c556775ded24b6c2040000000000000000"),
      /**
       * Height at which bip66 was activated.
       */
      bip66height: 363725,
      /**
       * Hash of the block that activated bip66.
       */
      bip66hash: w("3109b588941188a9f1c2576aae462d729b8cce9da1ea79030000000000000000"),
      /**
       * Height at which UAHF was activated.
       */
      uahfHeight: 478558,
      /**
       * Hash of the block that activated UAHF.
       */
      uahfHash: w("432d350741fbf28f2e1486eabe2c4e143bfe2241af6518010000000000000000"),
      /**
       * Height at which DAA was activated.
       * November 13, 2017 hard fork
       */
      daaHeight: 504031,
      /**
       * Hash of the block that activated DAA
       */
      daaHash: w("9cabb6ee1b1a4c3b659d70be75810be83d0a0db665bf1e010000000000000000"),
      /**
       * Height at which Magnetic Anomaly was activated.
       * Nov 15, 2018 hard fork
       */
      magneticAnomalyHeight: 556767,
      /**
       * Hash of the block that activatd Magnetic Anomaly.
       * November 15, 2018
       */
      maaHash: w("6cd5e644acccee5743ce2e93c541d34169933b6eff2646000000000000000000"),
      /**
       * Height at which Great Wall was activated.
       * Wed, 15 May 2019 hard fork
       */
      greatWallActivationHeight: 582680,
      /**
       * Hash of the block that activated Great Wall.
       * May 15, 2019
       */
      gwaHash: w("18cc7d8c39ca16dc749acb7278a471964f7dec6ae3b8b4010000000000000000"),
      /**
       * Graviton Hard Fork activation time.
       * Nov 15, 2019 12:00:00 UTC
       */
      gravitonActivationTime: 1573819200,
      /**
       * Height at which Graviton was activated.
       * Friday, 15 November 2019 hard fork
       */
      gravitonHeight: 609136,
      /**
       * Hash of the block that activated Graviton.
       * November 15th, 2019
       */
      gravitonHash: w("b1c55b4f69aa2e3209c91ae413c355c65aacfa07b28bb4000000000000000000"),
      /**
       * Time at which Phonon was activated.
       * May 15, 2020 12:00:00 UTC
       */
      phononActivationTime: 1589544e3,
      /**
      * Height at which Phonon Activation occured.
      * May 15, 2020
      */
      phononHeight: 635259,
      /**
      * Hash of the block that activated Phonon.
      * May 15th 2020
      */
      phononHash: w("f73075b2c598f49b3a19558c070b52d5a5d6c21fefdf33000000000000000000"),
      /**
       * Time at which Asert3d-2i was activated.
       * November 15, 2020 12:00:00 UTC
       */
      asertActivationTime: 1605441600,
      /**
       * Time at which Axion was activated.
       * November 15, 2020 12:00:00 UTC
       */
      axionActivationTime: 1605441600,
      /**
      * Height at which Axion Activation occured.
      * November 15, 2020
      */
      axionHeight: 661648,
      /**
      * Hash of the block that activated Axion.
      * November 15th 2020
      */
      axionHash: w("7d7510f907bdc9bd2907e56beceaef31f78f2c8b9d4c28040000000000000000"),
      /**
       * Time at which Tachyon was activated.
       * May 15, 2021 12:00:00 UTC
       */
      tachyonActivationTime: 162108e4,
      /**
      * Height at which Tachyon Activation occured.
      * May 15, 2021 12:00:00 UTC
      */
      tachyonHeight: 686621,
      /**
      * Hash of the block that activated Tachyon.
      * May 15, 2021 12:00:00 UTC
      */
      tachyonHash: w("45b7e5be980bd6e98a22f895fcdc80546d9f0a57f7e68f3c0000000000000000"),
      /**
       * Time at which Selectron was activated.
       * November 15, 2021 12:00:00 UTC
       */
      selectronActivationTime: 1636977600,
      /**
      * Height at which Selectron Activation occured.
      *  November 15, 2021 12:00:00 UTC
      */
      selectronHeight: 713661,
      /**
      * Hash of the block that activated Selectron.
      * November 15, 2021 12:00:00 UTC
      */
      selectronHash: w("8defaaea383ab73c75ceea3f08190f3ab5ccc70743f876060000000000000000"),
      /**
       * Time at which Gluon was activated.
       * May 15, 2022 12:00:00 UTC
       */
      gluonActivationTime: 1652572800,
      /**
      * Height at which Gluon activation occured.
      *  May 15, 2022 12:00:00 UTC
      */
      gluonHeight: 739536,
      /**
      * Hash of the block that activated Gluon.
      * May 15, 2022 12:00:00 UTC
      */
      gluonHash: w("617bfc596bce59b129242fe67b5afe0509560946cd04db060000000000000000"),
      /**
       * Time at which Jefferson was activated.
       * November 15, 2022 12:00:00 UTC
       */
      jeffersonActivationTime: 1668470400,
      /**
      * Height at which Gluon activation occured.
      *  November 15, 2022 12:00:00 UTC
      */
      jeffersonHeight: 766195,
      /**
      * Hash of the block that activated Gluon.
      * November 15, 2022 12:00:00 UTC
      */
      jeffersonHash: w("94e0246db72955957dedb431eb1096de9a5b715348c92b100000000000000000"),
      /**
       * Time at which Wellington was activated.
       * May 15, 2023 12:00:00 UTC
       */
      wellingtonActivationTime: 1684108800,
      /**
       * Safe height to start pruning.
       */
      pruneAfterHeight: 1e3,
      /**
       * Safe number of blocks to keep.
       */
      keepBlocks: 288,
      /**
       * Age used for the time delta to
       * determine whether the chain is synced.
       */
      maxTipAge: 1440 * 60,
      /**
       * Height at which block processing is
       * slow enough that we can output
       * logs without spamming.
       */
      slowHeight: 325e3
    }, m.bip30 = {
      91842: w("eccae000e3c8e4e093936360431f3b7603c563c1ff6181390a4d0a0000000000"),
      91880: w("21d77ccb4c08386a04ac0196ae10f6a1d2c2a377558ca190f143070000000000")
    }, m.activationThreshold = 1916, m.minerWindow = 2016, m.deployments = {
      csv: {
        name: "csv",
        bit: 0,
        startTime: 1462060800,
        // May 1st, 2016
        timeout: 1493596800,
        // May 1st, 2017
        threshold: -1,
        window: -1,
        required: !1,
        force: !0
      },
      testdummy: {
        name: "testdummy",
        bit: 28,
        startTime: 1199145601,
        // January 1, 2008
        timeout: 1230767999,
        // December 31, 2008
        threshold: -1,
        window: -1,
        required: !1,
        force: !0
      }
    }, m.deploys = [
      m.deployments.csv,
      m.deployments.testdummy
    ], m.keyPrefix = {
      privkey: 128,
      xpubkey: 76067358,
      xprivkey: 76066276,
      xpubkey58: "xpub",
      xprivkey58: "xprv",
      coinType: 0
    }, m.addressPrefix = {
      pubkeyhash: 0,
      scripthash: 5,
      cashaddr: "ecash"
    }, m.requireStandard = !0, m.rpcPort = 8332, m.walletPort = 8334, m.minRelay = 1e3, m.feeRate = 1e5, m.maxFeeRate = 4e5, m.selfConnect = !1, m.requestMempool = !1;
    const f = {};
    f.type = "testnet", f.seeds = [
      "testnet-seed.bitcoinabc.org",
      // Bitcoin ABC seeder
      "testnet-seed-abc.bitcoinforks.org",
      // bitcoinforks seeders
      "testnet-seed.deadalnix.me",
      // Amaury SÉCHET
      "testnet-seed.bchd.cash"
    ], f.magic = 4109624820, f.port = 18333, f.checkpointMap = {
      546: w("70cb6af7ebbcb1315d3414029c556c55f3e2fc353c4c9063a76c932a00000000"),
      1e4: w("02a1b43f52591e53b660069173ac83b675798e12599dbb0442b7580000000000"),
      5e4: w("0c6ceabe803cec55ba2831e445956d0a43ba9521743a802cddac7e0700000000"),
      9e4: w("cafc21e17faf90461a5905aa03302c394912651ed9475ae711723e0d00000000"),
      1e5: w("1e0a16bbadccde1d80c66597b1939e45f91b570d29f95fc158299e0000000000"),
      14e4: w("92c0877b54c556889b72175ccbe0c91a1208f6ef7efb2c006101062300000000"),
      17e4: w("508125560d202b89757889bb0e49c712477be20440058f05db4f0e0000000000"),
      21e4: w("32365454b5f29a826bff8ad9b0448cad0072fc73d50e482d91a3dece00000000"),
      23e4: w("b11a447e62643e0b27406eb0fc270cb8126d7b5b70822fb642d9513400000000"),
      27e4: w("1c42b811cf9c163932f6e95ec55bf9b5e2cb5324e7e93001572e000000000000"),
      3e5: w("a141bf3972424853f04367b47995e220e0b5a2706e5618766f22000000000000"),
      34e4: w("67edd4d92e405608109164b15f92b193377d49325b0ed036739c010000000000"),
      35e4: w("592b44bc0f7a4286cf07ead8497114c6952c1c7dea7305193deacf8e00000000"),
      39e4: w("f217e183484fb6d695609cc71fa2ae24c3020943407e0150b298030000000000"),
      42e4: w("de9e73a3b91fbb014e036e8583a17d6b638a699aeb2de8573d12580800000000"),
      46e4: w("2e8baaffc107f15c87aebe01664b63d07476afa53bcbada1281a030000000000"),
      5e5: w("06f60922a2aab2757317820fc6ffaf6a470e2cbb0f63a2aac0a7010000000000"),
      54e4: w("8dd0bebfbc4878f5af09d3e848dcc57827d2c1cebea8ec5d8cbe420500000000"),
      57e4: w("87acbd4cd3c40ec9bd648f8698ed226b31187274c06cc7a9af79030000000000"),
      6e5: w("169a05b3bb04b7d13ad628915630900a5ed2e89f3a9dc6064f62000000000000"),
      63e4: w("bbbe117035432a6a4effcb297207a02b031735b43e0d19a9217c000000000000"),
      67e4: w("080bfe75caed8624fcfdfbc65973c8f962d7bdc495a891f5d16b7d0000000000"),
      7e5: w("c14d3f6a1e7c7d66fd940951e44f3c3be1273bea4d2ab1786140000000000000"),
      74e4: w("b3b423f0462fd78a01e4f1a59a2737a0525b5dbb9bba0b4634f9000000000000"),
      78e4: w("0381582e34c3755964dc2813e2b33e521e5596367144e1670851050000000000"),
      8e5: w("03b5f8ab257e02903f509f5ff2935220eec2e77b1819651d099b200000000000"),
      84e4: w("dac1648107bd4394e57e4083c86d42b548b1cfb119665f179ea80a0000000000"),
      88e4: w("ff90b4bb07eded8e96715bf595c09c7d21dd8c61b8306ff48705d60000000000"),
      9e5: w("9bd8ac418beeb1a2cf5d68c8b5c6ebaa947a5b766e5524898d6f350000000000"),
      94e4: w("c98f1651a475b00d12f8c25eb166ee843affaa90610e36a19d68030000000000"),
      98e4: w("cc8e9774542d044a9698ca2336ae02d5987157e676f1c76aa3877c0000000000"),
      101e4: w("9d9fb11abc2712d80368229e97b8d827b2a07d27eb5335e5c924000000000000"),
      105e4: w("d8190cf0af7f08e179cab51d67db0b44b87951a78f7fdc31b4a01a0000000000"),
      109e4: w("41f83c47e02a8852d033ac884df7cca877726b384a461fb9e802000000000000"),
      113e4: w("b8d63c3830e3c5685d3f7d2c2271fdb2ce3315619a473c324ea1a4ce00000000"),
      // UAHF fork block.
      1155875: w("38f1ae7f0ea8c1b589884c5fbd0b83721e3ab6759a4b897206857cf100000000"),
      // DAA fork block.
      1188697: w("fb47e0ab0d2448f71192a09fe61bc9c46cd3b4e7bd778091d00e170000000000"),
      // GWA fork block.
      1303885: w("d323ee8d7ede5bef62f84db98f93cc8c47fae4f02e8938914700000000000000"),
      // Graviton fork block
      1341712: w("5ba3af2992073940ed9e5a9d9eef9194bbfba905d92b202eea44fcff00000000"),
      // Phonon fork block.
      1378461: w("d715e9fab7bbdf301081eeadbe6e931db282cf6b92b1365f9b50f59900000000")
    }, f.lastCheckpoint = 1341712, f.halvingInterval = 21e4, f.genesis = {
      version: 1,
      hash: w("43497fd7f826957108f4a30fd9cec3aeba79972084e90ead01ea330900000000"),
      prevBlock: w("0000000000000000000000000000000000000000000000000000000000000000"),
      merkleRoot: w("3ba3edfd7a7b12b27ac72c3e67768f617fc81bc3888a51323a9fb8aa4b1e5e4a"),
      time: 1296688602,
      bits: 486604799,
      nonce: 414098458,
      height: 0
    }, f.genesisBlock = "0100000000000000000000000000000000000000000000000000000000000000000000003ba3edfd7a7b12b27ac72c3e67768f617fc81bc3888a51323a9fb8aa4b1e5e4adae5494dffff001d1aa4ae180101000000010000000000000000000000000000000000000000000000000000000000000000ffffffff4d04ffff001d0104455468652054696d65732030332f4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66207365636f6e64206261696c6f757420666f722062616e6b73ffffffff0100f2052a01000000434104678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5fac00000000", f.pow = {
      limit: new c(
        "00000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
        "hex"
      ),
      bits: 486604799,
      chainwork: new c(
        "00000000000000000000000000000000000000000000006956e7298fb096a1cc",
        "hex"
      ),
      halfLife: 172800,
      targetTimespan: 336 * 60 * 60,
      targetSpacing: 600,
      retargetInterval: 2016,
      targetReset: !0,
      noRetargeting: !1
    }, f.block = {
      bip34height: 21111,
      bip34hash: w("f88ecd9912d00d3f5c2a8e0f50417d3e415c75b3abe584346da9b32300000000"),
      bip65height: 581885,
      bip65hash: w("b61e864fbec41dfaf09da05d1d76dc068b0dd82ee7982ff255667f0000000000"),
      bip66height: 330776,
      bip66hash: w("82a14b9e5ea81d4832b8e2cd3c2a6092b5a3853285a8995ec4c8042100000000"),
      uahfHeight: 1155875,
      uahfHash: w("38f1ae7f0ea8c1b589884c5fbd0b83721e3ab6759a4b897206857cf100000000"),
      daaHeight: 1188697,
      daaHash: w("fb47e0ab0d2448f71192a09fe61bc9c46cd3b4e7bd778091d00e170000000000"),
      magneticAnomalyHeight: 1267996,
      maaHash: w("244b485f4871816d3ca060f6f363abe81c6fa1bed45c09e0fa01000000000000"),
      greatWallActivationHeight: 1303885,
      gwaHash: w("d323ee8d7ede5bef62f84db98f93cc8c47fae4f02e8938914700000000000000"),
      gravitonActivationTime: 1573819200,
      gravitonHeight: 1341712,
      gravitonHash: w("5ba3af2992073940ed9e5a9d9eef9194bbfba905d92b202eea44fcff00000000"),
      phononActivationTime: 1589544e3,
      asertActivationTime: 1605441600,
      pruneAfterHeight: 1e3,
      keepBlocks: 1e4,
      maxTipAge: 1440 * 60,
      slowHeight: 95e4
    }, f.bip30 = {}, f.activationThreshold = 1512, f.minerWindow = 2016, f.deployments = {
      csv: {
        name: "csv",
        bit: 0,
        startTime: 1456790400,
        // March 1st, 2016
        timeout: 1493596800,
        // May 1st, 2017
        threshold: -1,
        window: -1,
        required: !1,
        force: !0
      },
      testdummy: {
        name: "testdummy",
        bit: 28,
        startTime: 1199145601,
        // January 1, 2008
        timeout: 1230767999,
        // December 31, 2008
        threshold: -1,
        window: -1,
        required: !1,
        force: !0
      }
    }, f.deploys = [
      f.deployments.csv,
      f.deployments.testdummy
    ], f.keyPrefix = {
      privkey: 239,
      xpubkey: 70617039,
      xprivkey: 70615956,
      xpubkey58: "tpub",
      xprivkey58: "tprv",
      coinType: 1
    }, f.addressPrefix = {
      pubkeyhash: 111,
      scripthash: 196,
      cashaddr: "xectest"
    }, f.requireStandard = !1, f.rpcPort = 18332, f.walletPort = 18334, f.minRelay = 1e3, f.feeRate = 2e4, f.maxFeeRate = 6e4, f.selfConnect = !1, f.requestMempool = !1;
    const n = {};
    n.type = "regtest", n.seeds = [
      "127.0.0.1"
    ], n.magic = 4206867930, n.port = 48444, n.checkpointMap = {}, n.lastCheckpoint = 0, n.halvingInterval = 150, n.genesis = {
      version: 1,
      hash: w("06226e46111a0b59caaf126043eb5bbf28c34f3a5e332a1fc7b2b73cf188910f"),
      prevBlock: w("0000000000000000000000000000000000000000000000000000000000000000"),
      merkleRoot: w("3ba3edfd7a7b12b27ac72c3e67768f617fc81bc3888a51323a9fb8aa4b1e5e4a"),
      time: 1296688602,
      bits: 545259519,
      nonce: 2,
      height: 0
    }, n.genesisBlock = "0100000000000000000000000000000000000000000000000000000000000000000000003ba3edfd7a7b12b27ac72c3e67768f617fc81bc3888a51323a9fb8aa4b1e5e4adae5494dffff7f20020000000101000000010000000000000000000000000000000000000000000000000000000000000000ffffffff4d04ffff001d0104455468652054696d65732030332f4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66207365636f6e64206261696c6f757420666f722062616e6b73ffffffff0100f2052a01000000434104678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5fac00000000", n.pow = {
      limit: new c(
        "7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
        "hex"
      ),
      bits: 545259519,
      chainwork: new c(
        "0000000000000000000000000000000000000000000000000000000000000002",
        "hex"
      ),
      halfLife: 172800,
      targetTimespan: 336 * 60 * 60,
      targetSpacing: 600,
      retargetInterval: 2016,
      targetReset: !0,
      noRetargeting: !0
    }, n.block = {
      bip34height: 1e8,
      bip34hash: null,
      bip65height: 1351,
      bip65hash: null,
      bip66height: 1251,
      bip66hash: null,
      uahfHeight: 0,
      uahfHash: null,
      daaHeight: 0,
      daaHash: null,
      magneticAnomalyHeight: 0,
      maaHash: null,
      greatWallActivationHeight: 0,
      gwaHash: null,
      gravitonHeight: 0,
      gravitonHash: null,
      phononActivationTime: 0,
      asertActivationTime: 0,
      pruneAfterHeight: 1e3,
      keepBlocks: 1e4,
      maxTipAge: 4294967295,
      slowHeight: 0
    }, n.bip30 = {}, n.activationThreshold = 108, n.minerWindow = 144, n.deployments = {
      csv: {
        name: "csv",
        bit: 0,
        startTime: 0,
        timeout: 4294967295,
        threshold: -1,
        window: -1,
        required: !1,
        force: !0
      },
      testdummy: {
        name: "testdummy",
        bit: 28,
        startTime: 0,
        timeout: 4294967295,
        threshold: -1,
        window: -1,
        required: !1,
        force: !0
      }
    }, n.deploys = [
      n.deployments.csv,
      n.deployments.testdummy
    ], n.keyPrefix = {
      privkey: 90,
      xpubkey: 3937729029,
      xprivkey: 3937666247,
      xpubkey58: "rpub",
      xprivkey58: "rprv",
      coinType: 1
    }, n.addressPrefix = {
      pubkeyhash: 60,
      scripthash: 38,
      cashaddr: "xecreg"
    }, n.requireStandard = !1, n.rpcPort = 48332, n.walletPort = 48334, n.minRelay = 1e3, n.feeRate = 2e4, n.maxFeeRate = 6e4, n.selfConnect = !0, n.requestMempool = !0;
    const u = {};
    u.type = "simnet", u.seeds = [
      "127.0.0.1"
    ], u.magic = 4076531172, u.port = 18555, u.checkpointMap = {}, u.lastCheckpoint = 0, u.halvingInterval = 21e4, u.genesis = {
      version: 1,
      hash: w("f67ad7695d9b662a72ff3d8edbbb2de0bfa67b13974bb9910d116d5cbd863e68"),
      prevBlock: w("0000000000000000000000000000000000000000000000000000000000000000"),
      merkleRoot: w("3ba3edfd7a7b12b27ac72c3e67768f617fc81bc3888a51323a9fb8aa4b1e5e4a"),
      time: 1401292357,
      bits: 545259519,
      nonce: 2,
      height: 0
    }, u.genesisBlock = "0100000000000000000000000000000000000000000000000000000000000000000000003ba3edfd7a7b12b27ac72c3e67768f617fc81bc3888a51323a9fb8aa4b1e5e4a45068653ffff7f20020000000101000000010000000000000000000000000000000000000000000000000000000000000000ffffffff4d04ffff001d0104455468652054696d65732030332f4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66207365636f6e64206261696c6f757420666f722062616e6b73ffffffff0100f2052a01000000434104678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5fac00000000", u.pow = {
      limit: new c(
        // High target of 0x207fffff (545259519)
        "7fffff0000000000000000000000000000000000000000000000000000000000",
        "hex"
      ),
      bits: 545259519,
      chainwork: new c(
        "0000000000000000000000000000000000000000000000000000000000000002",
        "hex"
      ),
      halfLife: 172800,
      targetTimespan: 336 * 60 * 60,
      targetSpacing: 600,
      retargetInterval: 2016,
      targetReset: !0,
      noRetargeting: !1
    }, u.block = {
      bip34height: 0,
      bip34hash: w("f67ad7695d9b662a72ff3d8edbbb2de0bfa67b13974bb9910d116d5cbd863e68"),
      bip65height: 0,
      bip65hash: w("f67ad7695d9b662a72ff3d8edbbb2de0bfa67b13974bb9910d116d5cbd863e68"),
      bip66height: 0,
      bip66hash: w("f67ad7695d9b662a72ff3d8edbbb2de0bfa67b13974bb9910d116d5cbd863e68"),
      uahfHeight: 0,
      uahfHash: null,
      daaHeight: 0,
      daaHash: null,
      magneticAnomalyActivationTime: 15423e5,
      greatWallActivationTime: 1557921600,
      pruneAfterHeight: 1e3,
      keepBlocks: 1e4,
      maxTipAge: 4294967295,
      slowHeight: 0
    }, u.bip30 = {}, u.activationThreshold = 75, u.minerWindow = 100, u.deployments = {
      csv: {
        name: "csv",
        bit: 0,
        startTime: 0,
        // March 1st, 2016
        timeout: 4294967295,
        // May 1st, 2017
        threshold: -1,
        window: -1,
        required: !1,
        force: !0
      },
      testdummy: {
        name: "testdummy",
        bit: 28,
        startTime: 1199145601,
        // January 1, 2008
        timeout: 1230767999,
        // December 31, 2008
        threshold: -1,
        window: -1,
        required: !1,
        force: !0
      }
    }, u.deploys = [
      u.deployments.csv,
      u.deployments.testdummy
    ], u.keyPrefix = {
      privkey: 100,
      xpubkey: 69254458,
      xprivkey: 69253376,
      xpubkey58: "spub",
      xprivkey58: "sprv",
      coinType: 115
    }, u.addressPrefix = {
      pubkeyhash: 63,
      scripthash: 123,
      cashaddr: "xecsim"
    }, u.requireStandard = !1, u.rpcPort = 18556, u.walletPort = 18558, u.minRelay = 1e3, u.feeRate = 2e4, u.maxFeeRate = 6e4, u.selfConnect = !1, u.requestMempool = !1, l.main = m, l.testnet = f, l.regtest = n, l.simnet = u;
  }(ca)), ca;
}
var pa = {};
/*!
 * consensus.js - consensus constants and helpers for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var wd;
function Xt() {
  return wd || (wd = 1, function(e) {
    const c = dt, l = jr();
    e.COIN = 1e8, e.MAX_MONEY = 21e6 * e.COIN, e.BASE_REWARD = 50 * e.COIN, e.HALF_REWARD = Math.floor(e.BASE_REWARD / 2), e.MAX_BLOCK_SIZE = 1e6, e.MAX_FORK_BLOCK_SIZE = 32e6, e.MAX_TX_VERSION = 2, e.MAX_TX_SIZE = 1e6, e.MAX_TX_SIGCHECKS = 3e3, e.MAX_BLOCK_SIGCHECKS_RATIO = 141, e.MIN_TX_SIZE = 100, e.MAX_RAW_BLOCK_SIZE = 32e6, e.MAX_BLOCK_SIGOPS_PER_MB = 2e4, e.MAX_TX_SIGOPS = 2e4, e.MAX_BLOCK_SIGOPS_COST = 8e4, e.MAX_COINBASE_SCRIPTSIG_SIZE = 100, e.COINBASE_RULE_ADDR = [
      "ecash:pqnqv9lt7e5vjyp0w88zf2af0l92l8rxdg2jj94l5j",
      "ecash:prfhcnyqnl5cgrnmlfmms675w93ld7mvvqd0y8lz07"
    ], e.MEDIAN_TIMESPAN = 11, e.VERSION_TOP_BITS = 536870912, e.VERSION_TOP_MASK = 3758096384, e.COINBASE_MATURITY = 100, e.LOCKTIME_THRESHOLD = 5e8, e.SEQUENCE_DISABLE_FLAG = 1 << 31 >>> 0, e.SEQUENCE_TYPE_FLAG = 1 << 22, e.SEQUENCE_GRANULARITY = 9, e.SEQUENCE_MASK = 65535, e.MAX_SCRIPT_SIZE = 1e4, e.MAX_SCRIPT_STACK = 1e3, e.MAX_SCRIPT_PUSH = 520, e.MAX_SCRIPT_OPS = 201, e.MAX_MULTISIG_PUBKEYS = 20, e.BIP16_TIME = 1333238400, e.ZERO_HASH = k.alloc(32, 0), e.NULL_HASH = "0000000000000000000000000000000000000000000000000000000000000000", e.ANTI_REPLAY_COMMITMENT = "Bitcoin: A Peer-to-Peer Electronic Cash System", e.fromCompact = function(m) {
      if (m === 0)
        return new l(0);
      const f = m >>> 24, n = m >>> 23 & 1;
      let u = m & 8388607, o;
      return f <= 3 ? (u >>>= 8 * (3 - f), o = new l(u)) : (o = new l(u), o.iushln(8 * (f - 3))), n && o.ineg(), o;
    }, e.toCompact = function(m) {
      if (m.isZero())
        return 0;
      let f = m.byteLength(), n;
      f <= 3 ? (n = m.toNumber(), n <<= 8 * (3 - f)) : n = m.ushrn(8 * (f - 3)).toNumber(), n & 8388608 && (n >>= 8, f++);
      let u = f << 24 | n;
      return m.isNeg() && (u |= 8388608), u >>>= 0, u;
    }, e.verifyPOW = function(m, f) {
      const n = e.fromCompact(f);
      return !(n.isNeg() || n.isZero() || n.bitLength() > 256 || new l(m, "le").gt(n));
    }, e.getReward = function(m, f) {
      c(m >= 0, "Bad height for reward.");
      const n = Math.floor(m / f);
      return n >= 33 ? 0 : n === 0 ? e.BASE_REWARD : e.HALF_REWARD >>> n - 1;
    }, e.hasBit = function(m, f) {
      const n = e.VERSION_TOP_MASK, u = e.VERSION_TOP_BITS, o = (m & n) >>> 0, s = 1 << f;
      return o === u && (m & s) !== 0;
    }, e.maxBlockSigops = function(m) {
      return (1 + ((m - 1) / 1e6 | 0)) * e.MAX_BLOCK_SIGOPS_PER_MB;
    }, e.maxBlockSigchecks = function(m) {
      return m / e.MAX_BLOCK_SIGCHECKS_RATIO;
    };
  }(pa)), pa;
}
var ma;
function gi() {
}
gi.prototype = /* @__PURE__ */ Object.create(null);
function Pt() {
  Pt.init.call(this);
}
Pt.EventEmitter = Pt;
Pt.usingDomains = !1;
Pt.prototype.domain = void 0;
Pt.prototype._events = void 0;
Pt.prototype._maxListeners = void 0;
Pt.defaultMaxListeners = 10;
Pt.init = function() {
  this.domain = null, Pt.usingDomains && ma.active && !(this instanceof ma.Domain) && (this.domain = ma.active), (!this._events || this._events === Object.getPrototypeOf(this)._events) && (this._events = new gi(), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
};
Pt.prototype.setMaxListeners = function(c) {
  if (typeof c != "number" || c < 0 || isNaN(c))
    throw new TypeError('"n" argument must be a positive number');
  return this._maxListeners = c, this;
};
function l7(e) {
  return e._maxListeners === void 0 ? Pt.defaultMaxListeners : e._maxListeners;
}
Pt.prototype.getMaxListeners = function() {
  return l7(this);
};
function cg(e, c, l) {
  if (c)
    e.call(l);
  else
    for (var w = e.length, m = Qn(e, w), f = 0; f < w; ++f)
      m[f].call(l);
}
function ug(e, c, l, w) {
  if (c)
    e.call(l, w);
  else
    for (var m = e.length, f = Qn(e, m), n = 0; n < m; ++n)
      f[n].call(l, w);
}
function hg(e, c, l, w, m) {
  if (c)
    e.call(l, w, m);
  else
    for (var f = e.length, n = Qn(e, f), u = 0; u < f; ++u)
      n[u].call(l, w, m);
}
function lg(e, c, l, w, m, f) {
  if (c)
    e.call(l, w, m, f);
  else
    for (var n = e.length, u = Qn(e, n), o = 0; o < n; ++o)
      u[o].call(l, w, m, f);
}
function dg(e, c, l, w) {
  if (c)
    e.apply(l, w);
  else
    for (var m = e.length, f = Qn(e, m), n = 0; n < m; ++n)
      f[n].apply(l, w);
}
Pt.prototype.emit = function(c) {
  var l, w, m, f, n, u, o, s = c === "error";
  if (u = this._events, u)
    s = s && u.error == null;
  else if (!s)
    return !1;
  if (o = this.domain, s) {
    if (l = arguments[1], o)
      l || (l = new Error('Uncaught, unspecified "error" event')), l.domainEmitter = this, l.domain = o, l.domainThrown = !1, o.emit("error", l);
    else {
      if (l instanceof Error)
        throw l;
      var i = new Error('Uncaught, unspecified "error" event. (' + l + ")");
      throw i.context = l, i;
    }
    return !1;
  }
  if (w = u[c], !w)
    return !1;
  var p = typeof w == "function";
  switch (m = arguments.length, m) {
    // fast cases
    case 1:
      cg(w, p, this);
      break;
    case 2:
      ug(w, p, this, arguments[1]);
      break;
    case 3:
      hg(w, p, this, arguments[1], arguments[2]);
      break;
    case 4:
      lg(w, p, this, arguments[1], arguments[2], arguments[3]);
      break;
    // slower
    default:
      for (f = new Array(m - 1), n = 1; n < m; n++)
        f[n - 1] = arguments[n];
      dg(w, p, this, f);
  }
  return !0;
};
function d7(e, c, l, w) {
  var m, f, n;
  if (typeof l != "function")
    throw new TypeError('"listener" argument must be a function');
  if (f = e._events, f ? (f.newListener && (e.emit(
    "newListener",
    c,
    l.listener ? l.listener : l
  ), f = e._events), n = f[c]) : (f = e._events = new gi(), e._eventsCount = 0), !n)
    n = f[c] = l, ++e._eventsCount;
  else if (typeof n == "function" ? n = f[c] = w ? [l, n] : [n, l] : w ? n.unshift(l) : n.push(l), !n.warned && (m = l7(e), m && m > 0 && n.length > m)) {
    n.warned = !0;
    var u = new Error("Possible EventEmitter memory leak detected. " + n.length + " " + c + " listeners added. Use emitter.setMaxListeners() to increase limit");
    u.name = "MaxListenersExceededWarning", u.emitter = e, u.type = c, u.count = n.length, bg(u);
  }
  return e;
}
function bg(e) {
  typeof console.warn == "function" ? console.warn(e) : console.log(e);
}
Pt.prototype.addListener = function(c, l) {
  return d7(this, c, l, !1);
};
Pt.prototype.on = Pt.prototype.addListener;
Pt.prototype.prependListener = function(c, l) {
  return d7(this, c, l, !0);
};
function b7(e, c, l) {
  var w = !1;
  function m() {
    e.removeListener(c, m), w || (w = !0, l.apply(e, arguments));
  }
  return m.listener = l, m;
}
Pt.prototype.once = function(c, l) {
  if (typeof l != "function")
    throw new TypeError('"listener" argument must be a function');
  return this.on(c, b7(this, c, l)), this;
};
Pt.prototype.prependOnceListener = function(c, l) {
  if (typeof l != "function")
    throw new TypeError('"listener" argument must be a function');
  return this.prependListener(c, b7(this, c, l)), this;
};
Pt.prototype.removeListener = function(c, l) {
  var w, m, f, n, u;
  if (typeof l != "function")
    throw new TypeError('"listener" argument must be a function');
  if (m = this._events, !m)
    return this;
  if (w = m[c], !w)
    return this;
  if (w === l || w.listener && w.listener === l)
    --this._eventsCount === 0 ? this._events = new gi() : (delete m[c], m.removeListener && this.emit("removeListener", c, w.listener || l));
  else if (typeof w != "function") {
    for (f = -1, n = w.length; n-- > 0; )
      if (w[n] === l || w[n].listener && w[n].listener === l) {
        u = w[n].listener, f = n;
        break;
      }
    if (f < 0)
      return this;
    if (w.length === 1) {
      if (w[0] = void 0, --this._eventsCount === 0)
        return this._events = new gi(), this;
      delete m[c];
    } else
      pg(w, f);
    m.removeListener && this.emit("removeListener", c, u || l);
  }
  return this;
};
Pt.prototype.off = function(e, c) {
  return this.removeListener(e, c);
};
Pt.prototype.removeAllListeners = function(c) {
  var l, w;
  if (w = this._events, !w)
    return this;
  if (!w.removeListener)
    return arguments.length === 0 ? (this._events = new gi(), this._eventsCount = 0) : w[c] && (--this._eventsCount === 0 ? this._events = new gi() : delete w[c]), this;
  if (arguments.length === 0) {
    for (var m = Object.keys(w), f = 0, n; f < m.length; ++f)
      n = m[f], n !== "removeListener" && this.removeAllListeners(n);
    return this.removeAllListeners("removeListener"), this._events = new gi(), this._eventsCount = 0, this;
  }
  if (l = w[c], typeof l == "function")
    this.removeListener(c, l);
  else if (l)
    do
      this.removeListener(c, l[l.length - 1]);
    while (l[0]);
  return this;
};
Pt.prototype.listeners = function(c) {
  var l, w, m = this._events;
  return m ? (l = m[c], l ? typeof l == "function" ? w = [l.listener || l] : w = mg(l) : w = []) : w = [], w;
};
Pt.listenerCount = function(e, c) {
  return typeof e.listenerCount == "function" ? e.listenerCount(c) : p7.call(e, c);
};
Pt.prototype.listenerCount = p7;
function p7(e) {
  var c = this._events;
  if (c) {
    var l = c[e];
    if (typeof l == "function")
      return 1;
    if (l)
      return l.length;
  }
  return 0;
}
Pt.prototype.eventNames = function() {
  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
};
function pg(e, c) {
  for (var l = c, w = l + 1, m = e.length; w < m; l += 1, w += 1)
    e[l] = e[w];
  e.pop();
}
function Qn(e, c) {
  for (var l = new Array(c); c--; )
    l[c] = e[c];
  return l;
}
function mg(e) {
  for (var c = new Array(e.length), l = 0; l < c.length; ++l)
    c[l] = e[l].listener || e[l];
  return c;
}
var gg = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  EventEmitter: Pt,
  default: Pt
}), xg = /* @__PURE__ */ hl(gg), ga = {};
/*!
 * util.js - utils for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var yd;
function pr() {
  return yd || (yd = 1, function(e) {
    const c = dt, l = e;
    l.bench = function(m) {
      if (!St.hrtime) {
        const f = Date.now();
        if (m) {
          const [s, i] = m, p = s * 1e3 + i / 1e6;
          return f - p;
        }
        const n = f % 1e3, u = (f - n) / 1e3, o = n * 1e6;
        return [u, o];
      }
      if (m) {
        const [f, n] = St.hrtime(m);
        return f * 1e3 + n / 1e6;
      }
      return St.hrtime();
    }, l.now = function() {
      return Math.floor(Date.now() / 1e3);
    }, l.ms = function() {
      return Date.now();
    }, l.date = function(m) {
      return m == null && (m = l.now()), new Date(m * 1e3).toISOString().slice(0, -5) + "Z";
    }, l.time = function(m) {
      return m == null ? l.now() : new Date(m) / 1e3 | 0;
    }, l.revHex = function(m) {
      return c(k.isBuffer(m)), k.from(m).reverse().toString("hex");
    }, l.fromRev = function(m) {
      return c(typeof m == "string"), c((m.length & 1) === 0), k.from(m, "hex").reverse();
    };
  }(ga)), ga;
}
/*!
 * timedata.js - time management for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var xa, vd;
function m7() {
  if (vd) return xa;
  vd = 1;
  const e = xg, c = pr(), l = dl();
  class w extends e {
    /**
     * Create time data.
     * @constructor
     * @param {Number} [limit=200]
     */
    constructor(n) {
      super(), n == null && (n = 200), this.samples = [], this.known = /* @__PURE__ */ new Map(), this.limit = n, this.offset = 0, this.checked = !1;
    }
    /**
     * Add time data.
     * @param {String} id
     * @param {Number} time
     */
    add(n, u) {
      if (this.samples.length >= this.limit || this.known.has(n))
        return;
      const o = u - c.now();
      if (this.known.set(n, o), l.insert(this.samples, o, m), this.emit("sample", o, this.samples.length), this.samples.length >= 5 && this.samples.length % 2 === 1) {
        let s = this.samples[this.samples.length >>> 1];
        if (Math.abs(s) >= 4200) {
          if (!this.checked) {
            let i = !1;
            for (const p of this.samples)
              if (p !== 0 && Math.abs(p) < 300) {
                i = !0;
                break;
              }
            i || (this.checked = !0, this.emit("mismatch"));
          }
          s = 0;
        }
        this.offset = s, this.emit("offset", this.offset);
      }
    }
    /**
     * Get the current adjusted time.
     * @returns {Number} Adjusted Time.
     */
    now() {
      return c.now() + this.offset;
    }
    /**
     * Adjust a timestamp.
     * @param {Number} time
     * @returns {Number} Adjusted Time.
     */
    adjust(n) {
      return n + this.offset;
    }
    /**
     * Unadjust a timestamp.
     * @param {Number} time
     * @returns {Number} Local Time.
     */
    local(n) {
      return n - this.offset;
    }
    /**
     * Get the current adjusted time in milliseconds.
     * @returns {Number} Adjusted Time.
     */
    ms() {
      return Date.now() + this.offset * 1e3;
    }
  }
  function m(f, n) {
    return f - n;
  }
  return xa = w, xa;
}
/*!
 * network.js - network object for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var wa, Sd;
function Tr() {
  if (Sd) return wa;
  Sd = 1;
  const e = dt, c = dl(), l = El(), w = Xt(), m = m7();
  class f {
    /**
     * Create a network.
     * @constructor
     * @param {Object} options
     */
    constructor(a) {
      e(!f[a.type], "Cannot create two networks."), this.type = a.type, this.seeds = a.seeds, this.magic = a.magic, this.port = a.port, this.checkpointMap = a.checkpointMap, this.lastCheckpoint = a.lastCheckpoint, this.checkpoints = [], this.halvingInterval = a.halvingInterval, this.genesis = a.genesis, this.genesisBlock = a.genesisBlock, this.pow = a.pow, this.block = a.block, this.bip30 = a.bip30, this.activationThreshold = a.activationThreshold, this.minerWindow = a.minerWindow, this.deployments = a.deployments, this.deploys = a.deploys, this.unknownBits = ~w.VERSION_TOP_MASK, this.keyPrefix = a.keyPrefix, this.addressPrefix = a.addressPrefix, this.requireStandard = a.requireStandard, this.rpcPort = a.rpcPort, this.walletPort = a.walletPort, this.minRelay = a.minRelay, this.feeRate = a.feeRate, this.maxFeeRate = a.maxFeeRate, this.selfConnect = a.selfConnect, this.requestMempool = a.requestMempool, this.time = new m(), this.init();
    }
    /**
     * Get a deployment by bit index.
     * @param {Number} bit
     * @returns {Object}
     */
    init() {
      let a = 0;
      for (const E of this.deploys)
        a |= 1 << E.bit;
      a |= w.VERSION_TOP_MASK, this.unknownBits = ~a >>> 0;
      for (const E of Object.keys(this.checkpointMap)) {
        const H = this.checkpointMap[E], j = Number(E);
        this.checkpoints.push({ hash: H, height: j });
      }
      this.checkpoints.sort(u);
    }
    /**
     * Get a deployment by bit index.
     * @param {Number} bit
     * @returns {Object}
     */
    byBit(a) {
      const E = c.search(this.deploys, a, n);
      return E === -1 ? null : this.deploys[E];
    }
    /**
     * Get network adjusted time.
     * @returns {Number}
     */
    now() {
      return this.time.now();
    }
    /**
     * Get network adjusted time in milliseconds.
     * @returns {Number}
     */
    ms() {
      return this.time.ms();
    }
    /**
     * Create a network. Get existing network if possible.
     * @param {NetworkType|Object} options
     * @returns {Network}
     */
    static create(a) {
      if (typeof a == "string" && (a = l[a]), e(a, "Unknown network."), f[a.type])
        return f[a.type];
      const E = new f(a);
      return f[E.type] = E, f.primary || (f.primary = E), E;
    }
    /**
     * Set the default network. This network will be used
     * if nothing is passed as the `network` option for
     * certain objects.
     * @param {NetworkType} type - Network type.
     * @returns {Network}
     */
    static set(a) {
      return e(typeof a == "string", "Bad network."), f.primary = f.get(a), f.type = a, f.primary;
    }
    /**
     * Get a network with a string or a Network object.
     * @param {NetworkType|Network} type - Network type.
     * @returns {Network}
     */
    static get(a) {
      if (!a)
        return e(f.primary, "No default network."), f.primary;
      if (a instanceof f)
        return a;
      if (typeof a == "string")
        return f.create(a);
      throw new Error("Unknown network.");
    }
    /**
     * Get a network with a string or a Network object.
     * @param {NetworkType|Network} type - Network type.
     * @returns {Network}
     */
    static ensure(a) {
      return a ? a instanceof f ? a : typeof a == "string" && l[a] ? f.create(a) : (e(f.primary, "No default network."), f.primary) : (e(f.primary, "No default network."), f.primary);
    }
    /**
     * Get a network by an associated comparator.
     * @private
     * @param {Object} value
     * @param {Function} compare
     * @param {Network|null} network
     * @param {String} name
     * @returns {Network}
     */
    static by(a, E, H, j) {
      if (H) {
        if (H = f.get(H), E(H, a))
          return H;
        throw new Error(`Network mismatch for ${j}.`);
      }
      for (const G of l.types)
        if (H = l[G], E(H, a))
          return f.get(G);
      throw new Error(`Network not found for ${j}.`);
    }
    /**
     * Get a network by its magic number.
     * @param {Number} value
     * @param {Network?} network
     * @returns {Network}
     */
    static fromMagic(a, E) {
      return f.by(a, o, E, "magic number");
    }
    /**
     * Get a network by its WIF prefix.
     * @param {Number} value
     * @param {Network?} network
     * @returns {Network}
     */
    static fromWIF(a, E) {
      return f.by(a, s, E, "WIF");
    }
    /**
     * Get a network by its xpubkey prefix.
     * @param {Number} value
     * @param {Network?} network
     * @returns {Network}
     */
    static fromPublic(a, E) {
      return f.by(a, i, E, "xpubkey");
    }
    /**
     * Get a network by its xprivkey prefix.
     * @param {Number} value
     * @param {Network?} network
     * @returns {Network}
     */
    static fromPrivate(a, E) {
      return f.by(a, p, E, "xprivkey");
    }
    /**
     * Get a network by its xpubkey base58 prefix.
     * @param {String} prefix
     * @param {Network?} network
     * @returns {Network}
     */
    static fromPublic58(a, E) {
      return f.by(a, g, E, "xpubkey");
    }
    /**
     * Get a network by its xprivkey base58 prefix.
     * @param {String} prefix
     * @param {Network?} network
     * @returns {Network}
     */
    static fromPrivate58(a, E) {
      return f.by(a, S, E, "xprivkey");
    }
    /**
     * Get a network by its base58 address prefix.
     * @param {Number} value
     * @param {Network?} network
     * @returns {Network}
     */
    static fromAddress(a, E) {
      return f.by(a, y, E, "base58 address");
    }
    /**
     * Get a network by its cashaddr address prefix.
     * @param {String} hrp
     * @param {Network?} network
     * @returns {Network}
     */
    static fromCashAddr(a, E) {
      return f.by(a, b, E, "cashaddr address");
    }
    /**
     * Convert the network to a string.
     * @returns {String}
     */
    toString() {
      return this.type;
    }
    /**
     * Inspect the network.
     * @returns {String}
     */
    inspect() {
      return `<Network: ${this.type}>`;
    }
    /**
     * Test an object to see if it is a Network.
     * @param {Object} obj
     * @returns {Boolean}
     */
    static isNetwork(a) {
      return a instanceof f;
    }
  }
  f.primary = null, f.type = null, f.main = null, f.testnet = null, f.regtest = null, f.segnet4 = null, f.simnet = null, f.set(St.env.BCASH_NETWORK || "main");
  function n(h, a) {
    return h.bit - a;
  }
  function u(h, a) {
    return h.height - a.height;
  }
  function o(h, a) {
    return h.magic === a;
  }
  function s(h, a) {
    return h.keyPrefix.privkey === a;
  }
  function i(h, a) {
    return h.keyPrefix.xpubkey === a;
  }
  function p(h, a) {
    return h.keyPrefix.xprivkey === a;
  }
  function g(h, a) {
    return h.keyPrefix.xpubkey58 === a;
  }
  function S(h, a) {
    return h.keyPrefix.xprivkey58 === a;
  }
  function y(h, a) {
    const E = h.addressPrefix;
    switch (a) {
      case E.pubkeyhash:
      case E.scripthash:
        return !0;
    }
    return !1;
  }
  function b(h, a) {
    return h.addressPrefix.cashaddr === a;
  }
  return wa = f, wa;
}
var Ii = {}, ya = {}, Ai = {};
/*!
 * random.js - random number generator for bcrypto
 * Copyright (c) 2014-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://wiki.openssl.org/index.php/Random_Numbers
 *   https://csrc.nist.gov/projects/random-bit-generation/
 *   http://www.pcg-random.org/posts/bounded-rands.html
 *   https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues
 */
var Ed;
function Hi() {
  if (Ed) return Ai;
  Ed = 1;
  const e = Mt(), c = dn.crypto || dn.msCrypto, l = c && typeof c.getRandomValues == "function", w = l ? c.getRandomValues.bind(c) : null, m = new Uint32Array(16), f = 65536;
  let n = 0;
  function u(S) {
    e(S >>> 0 === S);
    const y = k.alloc(S);
    return g(y, 0, S), y;
  }
  function o(S, y, b) {
    return e(k.isBuffer(S)), y == null && (y = 0), e(y >>> 0 === y), b == null && (b = S.length - y), e(b >>> 0 === b), e(y + b <= S.length), g(S, y, b), S;
  }
  function s() {
    return (n & 15) === 0 && (p(m), n = 0), m[n++];
  }
  function i(S, y) {
    e(S >>> 0 === S), e(y >>> 0 === y), e(y >= S);
    const b = y - S;
    if (b === 0)
      return S;
    const h = -b >>> 0;
    let a, E;
    do
      a = s(), E = a % b;
    while (a - E > h);
    return E + S;
  }
  function p(S) {
    if (!l)
      throw new Error("Entropy source not available.");
    return w(S);
  }
  function g(S, y, b) {
    if (e(k.isBuffer(S)), e(S.buffer instanceof ArrayBuffer), e(S.byteOffset >>> 0 === S.byteOffset), e(S.byteLength >>> 0 === S.byteLength), e(y >>> 0 === y), e(b >>> 0 === b), e(y + b <= S.byteLength), b > 2 ** 31 - 1)
      throw new RangeError('The value "size" is out of range.');
    const h = S.byteOffset + y, a = new Uint8Array(S.buffer, h, b);
    if (a.length > f)
      for (let E = 0; E < a.length; E += f) {
        let H = E + f;
        H > a.length && (H = a.length), p(a.subarray(E, H));
      }
    else
      a.length > 0 && p(a);
  }
  return Ai.native = 0, Ai.randomBytes = u, Ai.randomFill = o, Ai.randomInt = s, Ai.randomRange = i, Ai;
}
var sr = {};
function Id(e, c) {
  if (e === c)
    return 0;
  for (var l = e.length, w = c.length, m = 0, f = Math.min(l, w); m < f; ++m)
    if (e[m] !== c[m]) {
      l = e[m], w = c[m];
      break;
    }
  return l < w ? -1 : w < l ? 1 : 0;
}
var wg = Object.prototype.hasOwnProperty, Ad = Object.keys || function(e) {
  var c = [];
  for (var l in e)
    wg.call(e, l) && c.push(l);
  return c;
}, Od = Array.prototype.slice, va;
function g7() {
  return typeof va < "u" ? va : va = function() {
    return (function() {
    }).name === "foo";
  }();
}
function _d(e) {
  return Object.prototype.toString.call(e);
}
function Rd(e) {
  return an(e) || typeof zi.ArrayBuffer != "function" ? !1 : typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(e) : e ? !!(e instanceof DataView || e.buffer && e.buffer instanceof ArrayBuffer) : !1;
}
function ir(e, c) {
  e || rr(e, !0, c, "==", Gn);
}
var yg = /\s*function\s+([^\(\s]*)\s*/;
function x7(e) {
  if (Ti(e)) {
    if (g7())
      return e.name;
    var c = e.toString(), l = c.match(yg);
    return l && l[1];
  }
}
ir.AssertionError = eo;
function eo(e) {
  this.name = "AssertionError", this.actual = e.actual, this.expected = e.expected, this.operator = e.operator, e.message ? (this.message = e.message, this.generatedMessage = !1) : (this.message = vg(this), this.generatedMessage = !0);
  var c = e.stackStartFunction || rr;
  if (Error.captureStackTrace)
    Error.captureStackTrace(this, c);
  else {
    var l = new Error();
    if (l.stack) {
      var w = l.stack, m = x7(c), f = w.indexOf(`
` + m);
      if (f >= 0) {
        var n = w.indexOf(`
`, f + 1);
        w = w.substring(n + 1);
      }
      this.stack = w;
    }
  }
}
Xn(eo, Error);
function Pd(e, c) {
  return typeof e == "string" ? e.length < c ? e : e.slice(0, c) : e;
}
function kd(e) {
  if (g7() || !Ti(e))
    return Mr(e);
  var c = x7(e), l = c ? ": " + c : "";
  return "[Function" + l + "]";
}
function vg(e) {
  return Pd(kd(e.actual), 128) + " " + e.operator + " " + Pd(kd(e.expected), 128);
}
function rr(e, c, l, w, m) {
  throw new eo({
    message: l,
    actual: e,
    expected: c,
    operator: w,
    stackStartFunction: m
  });
}
ir.fail = rr;
function Gn(e, c) {
  e || rr(e, !0, c, "==", Gn);
}
ir.ok = Gn;
ir.equal = Il;
function Il(e, c, l) {
  e != c && rr(e, c, l, "==", Il);
}
ir.notEqual = Al;
function Al(e, c, l) {
  e == c && rr(e, c, l, "!=", Al);
}
ir.deepEqual = Ol;
function Ol(e, c, l) {
  pn(e, c, !1) || rr(e, c, l, "deepEqual", Ol);
}
ir.deepStrictEqual = _l;
function _l(e, c, l) {
  pn(e, c, !0) || rr(e, c, l, "deepStrictEqual", _l);
}
function pn(e, c, l, w) {
  if (e === c)
    return !0;
  if (an(e) && an(c))
    return Id(e, c) === 0;
  if (bn(e) && bn(c))
    return e.getTime() === c.getTime();
  if (qi(e) && qi(c))
    return e.source === c.source && e.global === c.global && e.multiline === c.multiline && e.lastIndex === c.lastIndex && e.ignoreCase === c.ignoreCase;
  if ((e === null || typeof e != "object") && (c === null || typeof c != "object"))
    return l ? e === c : e == c;
  if (Rd(e) && Rd(c) && _d(e) === _d(c) && !(e instanceof Float32Array || e instanceof Float64Array))
    return Id(
      new Uint8Array(e.buffer),
      new Uint8Array(c.buffer)
    ) === 0;
  if (an(e) !== an(c))
    return !1;
  w = w || { actual: [], expected: [] };
  var m = w.actual.indexOf(e);
  return m !== -1 && m === w.expected.indexOf(c) ? !0 : (w.actual.push(e), w.expected.push(c), Sg(e, c, l, w));
}
function Bd(e) {
  return Object.prototype.toString.call(e) == "[object Arguments]";
}
function Sg(e, c, l, w) {
  if (e == null || c === null || c === void 0)
    return !1;
  if (Ls(e) || Ls(c))
    return e === c;
  if (l && Object.getPrototypeOf(e) !== Object.getPrototypeOf(c))
    return !1;
  var m = Bd(e), f = Bd(c);
  if (m && !f || !m && f)
    return !1;
  if (m)
    return e = Od.call(e), c = Od.call(c), pn(e, c, l);
  var n = Ad(e), u = Ad(c), o, s;
  if (n.length !== u.length)
    return !1;
  for (n.sort(), u.sort(), s = n.length - 1; s >= 0; s--)
    if (n[s] !== u[s])
      return !1;
  for (s = n.length - 1; s >= 0; s--)
    if (o = n[s], !pn(e[o], c[o], l, w))
      return !1;
  return !0;
}
ir.notDeepEqual = Rl;
function Rl(e, c, l) {
  pn(e, c, !1) && rr(e, c, l, "notDeepEqual", Rl);
}
ir.notDeepStrictEqual = Pl;
function Pl(e, c, l) {
  pn(e, c, !0) && rr(e, c, l, "notDeepStrictEqual", Pl);
}
ir.strictEqual = kl;
function kl(e, c, l) {
  e !== c && rr(e, c, l, "===", kl);
}
ir.notStrictEqual = Bl;
function Bl(e, c, l) {
  e === c && rr(e, c, l, "!==", Bl);
}
function Md(e, c) {
  if (!e || !c)
    return !1;
  if (Object.prototype.toString.call(c) == "[object RegExp]")
    return c.test(e);
  try {
    if (e instanceof c)
      return !0;
  } catch {
  }
  return Error.isPrototypeOf(c) ? !1 : c.call({}, e) === !0;
}
function Eg(e) {
  var c;
  try {
    e();
  } catch (l) {
    c = l;
  }
  return c;
}
function w7(e, c, l, w) {
  var m;
  if (typeof c != "function")
    throw new TypeError('"block" argument must be a function');
  typeof l == "string" && (w = l, l = null), m = Eg(c), w = (l && l.name ? " (" + l.name + ")." : ".") + (w ? " " + w : "."), e && !m && rr(m, l, "Missing expected exception" + w);
  var f = typeof w == "string", n = !e && ln(m), u = !e && m && !l;
  if ((n && f && Md(m, l) || u) && rr(m, l, "Got unwanted exception" + w), e && m && l && !Md(m, l) || !e && m)
    throw m;
}
ir.throws = y7;
function y7(e, c, l) {
  w7(!0, e, c, l);
}
ir.doesNotThrow = v7;
function v7(e, c, l) {
  w7(!1, e, c, l);
}
ir.ifError = S7;
function S7(e) {
  if (e) throw e;
}
var Ig = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  AssertionError: eo,
  assert: Gn,
  deepEqual: Ol,
  deepStrictEqual: _l,
  default: ir,
  doesNotThrow: v7,
  equal: Il,
  fail: rr,
  ifError: S7,
  notDeepEqual: Rl,
  notDeepStrictEqual: Pl,
  notEqual: Al,
  notStrictEqual: Bl,
  ok: Gn,
  strictEqual: kl,
  throws: y7
}), Ag = /* @__PURE__ */ hl(Ig);
/*!
 * asn1.js - asn1 parsing for bcrypto
 * Copyright (c) 2020, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var Nd;
function E7() {
  if (Nd) return sr;
  Nd = 1;
  const e = Ag, c = jr();
  function l(y, b, h) {
    if (e(k.isBuffer(y)), e(b >>> 0 === b), e(typeof h == "boolean"), b >= y.length)
      throw new Error("Invalid size.");
    const a = y[b], E = a & 127;
    if (b += 1, (a & 128) === 0)
      return [E, b];
    if (h && E === 0)
      throw new Error("Indefinite length.");
    let H = 0;
    for (let j = 0; j < E; j++) {
      e(b < y.length);
      const G = y[b];
      if (b += 1, H >= 1 << 24)
        throw new Error("Length too large.");
      if (H *= 256, H += G, h && H === 0)
        throw new Error("Unexpected leading zeroes.");
    }
    if (h && H < 128)
      throw new Error("Non-minimal length.");
    return [H, b];
  }
  function w(y, b, h = !0) {
    if (e(k.isBuffer(y)), e(b >>> 0 === b), e(typeof h == "boolean"), b >= y.length || y[b] !== 48)
      throw new Error("Invalid sequence tag.");
    b += 1;
    let a;
    if ([a, b] = l(y, b, h), h && b + a !== y.length)
      throw new Error("Trailing bytes.");
    return b;
  }
  function m(y, b, h = !0) {
    if (e(k.isBuffer(y)), e(b >>> 0 === b), e(typeof h == "boolean"), b >= y.length || y[b] !== 2)
      throw new Error("Invalid integer tag.");
    b += 1;
    let a;
    if ([a, b] = l(y, b, h), b + a > y.length)
      throw new Error("Integer body out of bounds.");
    if (h) {
      if (a === 0)
        throw new Error("Zero length integer.");
      if (y[b] & 128)
        throw new Error("Integers must be positive.");
      if (a > 1 && y[b] === 0 && (y[b + 1] & 128) === 0)
        throw new Error("Unexpected leading zeroes.");
    }
    for (; a > 0 && y[b] === 0; )
      b += 1, a -= 1;
    if (a > 2048)
      throw new Error("Invalid integer size.");
    const E = c.decode(y.slice(b, b + a));
    return b += a, [E, b];
  }
  function f(y, b, h, a = !0) {
    e(k.isBuffer(y)), e(b >>> 0 === b), e((h & 255) === h), e(typeof a == "boolean");
    let E;
    if ([E, b] = m(y, b, a), E.cmpn(h) !== 0)
      throw new Error("Invalid version.");
    return b;
  }
  function n(y) {
    return e(y >>> 0 === y), y <= 127 ? 1 : y <= 255 ? 2 : (e(y <= 65535), 3);
  }
  function u(y) {
    return 1 + n(y) + y;
  }
  function o(y) {
    e(y instanceof c);
    const b = y.bitLength();
    let h = b + 7 >>> 3;
    return b > 0 && (b & 7) === 0 && (h += y.testn(b - 1)), b === 0 && (h = 1), 1 + n(h) + h;
  }
  function s(y) {
    return e((y & 255) === y), 3;
  }
  function i(y, b, h) {
    return e(k.isBuffer(y)), e(b >>> 0 === b), e(h >>> 0 === h), h <= 127 ? y[b++] = h : h <= 255 ? (y[b++] = 129, y[b++] = h) : (e(h <= 65535), y[b++] = 130, y[b++] = h >> 8, y[b++] = h & 255), e(b <= y.length), b;
  }
  function p(y, b, h) {
    return e(k.isBuffer(y)), e(b >>> 0 === b), y[b++] = 48, i(y, b, h);
  }
  function g(y, b, h) {
    e(k.isBuffer(y)), e(b >>> 0 === b), e(h instanceof c);
    const a = h.bitLength();
    let E = a + 7 >>> 3, H = 0;
    return a > 0 && (a & 7) === 0 && (H = h.testn(a - 1)), a === 0 && (E = 1), y[b++] = 2, b = i(y, b, H + E), H && (y[b++] = 0), a !== 0 ? h.encode().copy(y, b) : y[b] = 0, b += E, e(b <= y.length), b;
  }
  function S(y, b, h) {
    return e(k.isBuffer(y)), e(b >>> 0 === b), e((h & 255) === h), e(b + 3 <= y.length), y[b++] = 2, y[b++] = 1, y[b++] = h, b;
  }
  return sr.readSize = l, sr.readSeq = w, sr.readInt = m, sr.readVersion = f, sr.sizeSize = n, sr.sizeSeq = u, sr.sizeInt = o, sr.sizeVersion = s, sr.writeSize = i, sr.writeSeq = p, sr.writeInt = g, sr.writeVersion = S, sr;
}
/*!
 * chacha20.js - chacha20 for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources
 *   https://en.wikipedia.org/wiki/Chacha20
 *   https://tools.ietf.org/html/rfc7539#section-2
 *   https://cr.yp.to/chacha.html
 */
var Sa, qd;
function I7() {
  if (qd) return Sa;
  qd = 1;
  const e = Mt(), c = new Int8Array(new Int16Array([1]).buffer)[0] === 0;
  class l {
    /**
     * Create a ChaCha20 context.
     * @constructor
     */
    constructor() {
      this.state = new Uint32Array(16), this.stream = new Uint32Array(16), this.bytes = new Uint8Array(this.stream.buffer), this.pos = -1, c && (this.bytes = k.alloc(64));
    }
    /**
     * Initialize chacha20 with a key, nonce, and counter.
     * @param {Buffer} key
     * @param {Buffer} nonce
     * @param {Number} counter
     */
    init(o, s, i) {
      if (i == null && (i = 0), e(k.isBuffer(o)), e(k.isBuffer(s)), e(Number.isSafeInteger(i)), o.length !== 16 && o.length !== 32)
        throw new RangeError("Invalid key size.");
      if (s.length >= 24 && (o = l.derive(o, s.slice(0, 16)), s = s.slice(16)), this.state[0] = 1634760805, this.state[1] = o.length < 32 ? 824206446 : 857760878, this.state[2] = o.length < 32 ? 2036477238 : 2036477234, this.state[3] = 1797285236, this.state[4] = f(o, 0), this.state[5] = f(o, 4), this.state[6] = f(o, 8), this.state[7] = f(o, 12), this.state[8] = f(o, 16 % o.length), this.state[9] = f(o, 20 % o.length), this.state[10] = f(o, 24 % o.length), this.state[11] = f(o, 28 % o.length), this.state[12] = i >>> 0, s.length === 8)
        this.state[13] = i / 4294967296 >>> 0, this.state[14] = f(s, 0), this.state[15] = f(s, 4);
      else if (s.length === 12)
        this.state[13] = f(s, 0), this.state[14] = f(s, 4), this.state[15] = f(s, 8);
      else if (s.length === 16)
        this.state[12] = f(s, 0), this.state[13] = f(s, 4), this.state[14] = f(s, 8), this.state[15] = f(s, 12);
      else
        throw new RangeError("Invalid nonce size.");
      return this.pos = 0, this;
    }
    /**
     * Encrypt/decrypt data.
     * @param {Buffer} data - Will be mutated.
     * @returns {Buffer}
     */
    encrypt(o) {
      if (e(k.isBuffer(o)), this.pos === -1)
        throw new Error("Context is not initialized.");
      for (let s = 0; s < o.length; s++)
        (this.pos & 63) === 0 && (this._block(), this.pos = 0), o[s] ^= this.bytes[this.pos++];
      return o;
    }
    /**
     * Stir the stream.
     */
    _block() {
      for (let o = 0; o < 16; o++)
        this.stream[o] = this.state[o];
      for (let o = 0; o < 10; o++)
        w(this.stream, 0, 4, 8, 12), w(this.stream, 1, 5, 9, 13), w(this.stream, 2, 6, 10, 14), w(this.stream, 3, 7, 11, 15), w(this.stream, 0, 5, 10, 15), w(this.stream, 1, 6, 11, 12), w(this.stream, 2, 7, 8, 13), w(this.stream, 3, 4, 9, 14);
      for (let o = 0; o < 16; o++)
        this.stream[o] += this.state[o];
      if (c)
        for (let o = 0; o < 16; o++)
          n(this.bytes, this.stream[o], o * 4);
      this.state[12] += 1, this.state[12] === 0 && (this.state[13] += 1);
    }
    /**
     * Destroy context.
     */
    destroy() {
      for (let o = 0; o < 16; o++)
        this.state[o] = 0, this.stream[o] = 0;
      if (c)
        for (let o = 0; o < 64; o++)
          this.bytes[o] = 0;
      return this.pos = -1, this;
    }
    /**
     * Derive key with XChaCha20.
     * @param {Buffer} key
     * @param {Buffer} nonce
     * @returns {Buffer}
     */
    static derive(o, s) {
      if (e(k.isBuffer(o)), e(k.isBuffer(s)), o.length !== 16 && o.length !== 32)
        throw new RangeError("Invalid key size.");
      if (s.length !== 16)
        throw new RangeError("Invalid nonce size.");
      const i = new Uint32Array(16);
      i[0] = 1634760805, i[1] = o.length < 32 ? 824206446 : 857760878, i[2] = o.length < 32 ? 2036477238 : 2036477234, i[3] = 1797285236, i[4] = f(o, 0), i[5] = f(o, 4), i[6] = f(o, 8), i[7] = f(o, 12), i[8] = f(o, 16 % o.length), i[9] = f(o, 20 % o.length), i[10] = f(o, 24 % o.length), i[11] = f(o, 28 % o.length), i[12] = f(s, 0), i[13] = f(s, 4), i[14] = f(s, 8), i[15] = f(s, 12);
      for (let g = 0; g < 10; g++)
        w(i, 0, 4, 8, 12), w(i, 1, 5, 9, 13), w(i, 2, 6, 10, 14), w(i, 3, 7, 11, 15), w(i, 0, 5, 10, 15), w(i, 1, 6, 11, 12), w(i, 2, 7, 8, 13), w(i, 3, 4, 9, 14);
      const p = k.alloc(32);
      return n(p, i[0], 0), n(p, i[1], 4), n(p, i[2], 8), n(p, i[3], 12), n(p, i[12], 16), n(p, i[13], 20), n(p, i[14], 24), n(p, i[15], 28), p;
    }
  }
  l.native = 0;
  function w(u, o, s, i, p) {
    u[o] += u[s], u[p] = m(u[p] ^ u[o], 16), u[i] += u[p], u[s] = m(u[s] ^ u[i], 12), u[o] += u[s], u[p] = m(u[p] ^ u[o], 8), u[i] += u[p], u[s] = m(u[s] ^ u[i], 7);
  }
  function m(u, o) {
    return u << o | u >>> 32 - o;
  }
  function f(u, o) {
    return u[o++] + u[o++] * 256 + u[o++] * 65536 + u[o] * 16777216;
  }
  function n(u, o, s) {
    return u[s++] = o, o >>>= 8, u[s++] = o, o >>>= 8, u[s++] = o, o >>>= 8, u[s++] = o, s;
  }
  return Sa = l, Sa;
}
/*!
 * batch-rng.js - batch rng for bcrypto
 * Copyright (c) 2019-2020, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on ElementsProject/secp256k1-zkp:
 *   Copyright (c) 2013, Pieter Wuille.
 *   https://github.com/ElementsProject/secp256k1-zkp
 *
 * Resources:
 *   https://github.com/ElementsProject/secp256k1-zkp/blob/11af701/src/modules/schnorrsig/main_impl.h#L166
 *   https://github.com/ElementsProject/secp256k1-zkp/blob/11af701/src/scalar_4x64_impl.h#L972
 *   https://github.com/ElementsProject/secp256k1-zkp/blob/11af701/src/scalar_8x32_impl.h#L747
 */
var Ea, Td;
function Og() {
  if (Td) return Ea;
  Td = 1;
  const e = Mt(), c = jr(), l = I7(), w = br();
  class m {
    constructor(n, u = (o) => o) {
      this.curve = n, this.encode = u, this.hash = new w(), this.chacha = new l(), this.key = k.alloc(32, 0), this.iv = k.alloc(8, 0), this.cache = [new c(1), new c(1)];
    }
    init(n) {
      e(Array.isArray(n)), this.hash.init();
      for (const [u, o, s] of n)
        this.hash.update(w.digest(u)), this.hash.update(o), this.hash.update(this.encode(s));
      return this.key = this.hash.final(), this.cache[0] = new c(1), this.cache[1] = new c(1), this;
    }
    encrypt(n) {
      const u = this.curve.scalarSize * 2, o = k.alloc(u, 0), s = o.slice(0, this.curve.scalarSize), i = o.slice(this.curve.scalarSize);
      return this.chacha.init(this.key, this.iv, n), this.chacha.encrypt(o), [
        this.curve.decodeScalar(s),
        this.curve.decodeScalar(i)
      ];
    }
    refresh(n) {
      let u = 0;
      for (; ; ) {
        this.iv[4] = u, this.iv[5] = u >>> 8, this.iv[6] = u >>> 16, this.iv[7] = u >>> 24, u += 1;
        const [o, s] = this.encrypt(n);
        if (!(o.isZero() || o.cmp(this.curve.n) >= 0) && !(s.isZero() || s.cmp(this.curve.n) >= 0)) {
          this.cache[0] = o, this.cache[1] = s;
          break;
        }
      }
    }
    generate(n) {
      return e(n >>> 0 === n), n & 1 && this.refresh(n >>> 1), this.cache[n & 1];
    }
  }
  return Ea = m, Ea;
}
/*!
 * schnorr-legacy.js - bip-schnorr for bcrypto
 * Copyright (c) 2019-2020, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on sipa/bip-schnorr:
 *   Copyright (c) 2018-2019, Pieter Wuille (2-clause BSD License).
 *   https://github.com/sipa/bips/blob/d194620/bip-schnorr/reference.py
 *
 * Parts of this software are based on ElementsProject/secp256k1-zkp:
 *   Copyright (c) 2013, Pieter Wuille.
 *   https://github.com/ElementsProject/secp256k1-zkp
 *
 * Resources:
 *   https://github.com/sipa/bips/blob/d194620/bip-schnorr.mediawiki
 *   https://github.com/sipa/bips/blob/d194620/bip-schnorr/reference.py
 *   https://github.com/sipa/bips/blob/d194620/bip-schnorr/test-vectors.csv
 *   https://github.com/ElementsProject/secp256k1-zkp/tree/11af701/src/modules/schnorrsig
 *   https://github.com/bitcoincashorg/bitcoincash.org/blob/master/spec/2019-05-15-schnorr.md
 *
 * References:
 *
 *   [SCHNORR] Schnorr Signatures for secp256k1
 *     Pieter Wuille
 *     https://github.com/sipa/bips/blob/d194620/bip-schnorr.mediawiki
 *
 *   [CASH] Schnorr Signature specification
 *     Mark B. Lundeberg
 *     https://github.com/bitcoincashorg/bitcoincash.org/blob/master/spec/2019-05-15-schnorr.md
 */
var Ia, zd;
function _g() {
  if (zd) return Ia;
  zd = 1;
  const e = Mt(), c = Og(), l = jr();
  class w {
    constructor(f, n) {
      this.curve = f, this.hash = n, this.rng = new c(this.curve, this.encode.bind(this));
    }
    check() {
      if (this.curve.p.andln(3) !== 3)
        throw new Error(`Schnorr is not supported for ${this.curve.id}.`);
    }
    encode(f) {
      e(k.isBuffer(f));
      const { fieldSize: n } = this.curve;
      if (f.length === 1 + n)
        return f;
      if (f.length !== 1 + n * 2)
        throw new Error("Invalid point.");
      const u = k.alloc(1 + n);
      return u[0] = 2 | f[f.length - 1] & 1, f.copy(u, 1, 1, 1 + n), u;
    }
    hashInt(...f) {
      const n = new this.hash();
      n.init();
      for (const s of f)
        n.update(s);
      let u = n.final(this.curve.scalarSize);
      u.length > this.curve.scalarSize && (u = u.slice(0, this.curve.scalarSize));
      const o = l.decode(u, this.curve.endian);
      return o.iumaskn(this.curve.scalarBits), o.imod(this.curve.n);
    }
    hashNonce(f, n) {
      return this.hashInt(f, n);
    }
    hashChallenge(f, n, u) {
      return this.hashInt(f, this.encode(n), u);
    }
    sign(f, n) {
      return e(k.isBuffer(f)), this.check(), this._sign(f, n);
    }
    _sign(f, n) {
      const { n: u } = this.curve, o = this.curve.g, s = this.curve.decodeScalar(n);
      if (s.isZero() || s.cmp(u) >= 0)
        throw new Error("Invalid private key.");
      const i = o.mulBlind(s), p = this.hashNonce(n, f);
      if (p.isZero())
        throw new Error("Signing failed (k' = 0).");
      const g = o.mulBlind(p);
      g.isSquare() || p.ineg().imod(u);
      const S = g.encodeX(), y = i.encode(), b = this.hashChallenge(S, y, f), h = p.add(b.mul(s)).imod(u);
      return k.concat([S, this.curve.encodeScalar(h)]);
    }
    verify(f, n, u) {
      if (e(k.isBuffer(f)), e(k.isBuffer(n)), e(k.isBuffer(u)), this.check(), n.length !== this.curve.fieldSize + this.curve.scalarSize)
        return !1;
      try {
        return this._verify(f, n, u);
      } catch {
        return !1;
      }
    }
    _verify(f, n, u) {
      const { p: o, n: s } = this.curve, i = this.curve.g, p = n.slice(0, this.curve.fieldSize), g = n.slice(this.curve.fieldSize), S = this.curve.decodeField(p), y = this.curve.decodeScalar(g), b = this.curve.decodePoint(u);
      if (S.cmp(o) >= 0 || y.cmp(s) >= 0)
        return !1;
      const h = this.hashChallenge(p, u, f), a = i.jmulAdd(y, b, h.ineg().imod(s));
      return !(!a.isSquare() || !a.eqX(S));
    }
    verifyBatch(f) {
      e(Array.isArray(f)), this.check();
      for (const n of f) {
        e(Array.isArray(n) && n.length === 3);
        const [u, o, s] = n;
        if (e(k.isBuffer(u)), e(k.isBuffer(o)), e(k.isBuffer(s)), o.length !== this.curve.fieldSize + this.curve.scalarSize)
          return !1;
      }
      try {
        return this._verifyBatch(f);
      } catch {
        return !1;
      }
    }
    _verifyBatch(f) {
      const { n } = this.curve, u = this.curve.g, o = new Array(1 + f.length * 2), s = new Array(1 + f.length * 2), i = new l(0);
      this.rng.init(f), o[0] = u, s[0] = i;
      for (let p = 0; p < f.length; p++) {
        const [g, S, y] = f[p], b = S.slice(0, this.curve.fieldSize), h = S.slice(this.curve.fieldSize), a = this.curve.decodeSquare(b), E = this.curve.decodeScalar(h), H = this.curve.decodePoint(y);
        if (E.cmp(n) >= 0)
          return !1;
        const j = this.hashChallenge(b, y, g), G = this.rng.generate(p), N = j.mul(G).imod(n);
        i.iadd(E.mul(G)).imod(n), o[1 + p * 2 + 0] = a, s[1 + p * 2 + 0] = G, o[1 + p * 2 + 1] = H, s[1 + p * 2 + 1] = N;
      }
      return i.ineg().imod(n), this.curve.jmulAll(o, s).isInfinity();
    }
  }
  return Ia = w, Ia;
}
/*!
 * hmac-drbg.js - hmac-drbg implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/hmac-drbg:
 *   Copyright Fedor Indutny, 2017.
 *   https://github.com/indutny/hmac-drbg
 *
 * Resources:
 *   https://tools.ietf.org/html/rfc6979
 *   https://csrc.nist.gov/publications/detail/sp/800-90a/archive/2012-01-23
 *   https://github.com/indutny/hmac-drbg/blob/master/lib/hmac-drbg.js
 */
var Aa, Cd;
function A7() {
  if (Cd) return Aa;
  Cd = 1;
  const e = Mt(), c = 281474976710656, l = k.from([0]), w = k.from([1]);
  class m {
    constructor(n, u, o, s) {
      e(n && typeof n.id == "string"), this.hash = n, this.minEntropy = n.id === "SHA1" ? 10 : 24, this.K = k.alloc(n.size), this.V = k.alloc(n.size), this.rounds = 0, u && this.init(u, o, s);
    }
    init(n, u, o) {
      u == null && (u = k.alloc(0)), o == null && (o = k.alloc(0)), e(k.isBuffer(n)), e(k.isBuffer(u)), e(k.isBuffer(o));
      for (let i = 0; i < this.V.length; i++)
        this.K[i] = 0, this.V[i] = 1;
      const s = k.concat([n, u, o]);
      if (s.length < this.minEntropy)
        throw new Error("Not enough entropy.");
      return this.update(s), this.rounds = 1, this;
    }
    reseed(n, u) {
      if (u == null && (u = k.alloc(0)), e(k.isBuffer(n)), e(k.isBuffer(u)), this.rounds === 0)
        throw new Error("DRBG not initialized.");
      const o = k.concat([n, u]);
      if (o.length < this.minEntropy)
        throw new Error("Not enough entropy.");
      return this.update(o), this.rounds = 1, this;
    }
    generate(n, u) {
      if (e(n >>> 0 === n), e(u == null || k.isBuffer(u)), this.rounds === 0)
        throw new Error("DRBG not initialized.");
      if (this.rounds > c)
        throw new Error("Reseed is required.");
      u && u.length > 0 && this.update(u);
      const o = Math.ceil(n / this.hash.size), s = k.alloc(o * this.hash.size);
      for (let i = 0; i < o; i++)
        this.V = this.mac(this.V), this.V.copy(s, i * this.hash.size);
      return this.update(u), this.rounds += 1, s.slice(0, n);
    }
    randomBytes(n) {
      return this.generate(n);
    }
    /*
     * Helpers
     */
    mac(n) {
      return this.hash.mac(n, this.K);
    }
    hmac() {
      return this.hash.hmac().init(this.K);
    }
    update(n) {
      e(n == null || k.isBuffer(n));
      const u = this.hmac();
      if (u.update(this.V), u.update(l), n && u.update(n), this.K = u.final(), this.V = this.mac(this.V), n && n.length > 0) {
        const o = this.hmac();
        o.update(this.V), o.update(w), o.update(n), this.K = o.final(), this.V = this.mac(this.V);
      }
      return this;
    }
  }
  return m.native = 0, Aa = m, Aa;
}
var er = {};
/*!
 * elliptic.js - elliptic curves for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/elliptic:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/elliptic
 *
 * Formulas from DJB and Tanja Lange [EFD].
 *
 * References:
 *
 *   [GECC] Guide to Elliptic Curve Cryptography
 *     D. Hankerson, A. Menezes, and S. Vanstone
 *     https://tinyurl.com/guide-to-ecc
 *
 *   [GLV] Faster Point Multiplication on Elliptic Curves
 *     R. Gallant, R. Lambert, and S. Vanstone
 *     https://link.springer.com/content/pdf/10.1007/3-540-44647-8_11.pdf
 *
 *   [MONT1] Montgomery curves and the Montgomery ladder
 *     Daniel J. Bernstein, Tanja Lange
 *     https://eprint.iacr.org/2017/293.pdf
 *
 *   [SQUARED] Elligator Squared
 *     Mehdi Tibouchi
 *     https://eprint.iacr.org/2014/043.pdf
 *
 *   [SEC1] SEC 1 - Standards for Efficient Cryptography Group
 *     Certicom Research
 *     https://www.secg.org/sec1-v2.pdf
 *
 *   [SEC2] SEC 2: Recommended Elliptic Curve Domain Parameters
 *     Certicom Research
 *     https://www.secg.org/sec2-v2.pdf
 *
 *   [SIDE1] Elliptic Curves and Side-Channel Attacks
 *     Marc Joye
 *     https://pdfs.semanticscholar.org/8d69/9645033e25d74fcfd4cbf07a770d2e943e14.pdf
 *
 *   [BLIND] Side-Channel Analysis on Blinding Regular Scalar Multiplications
 *     B. Feix, M. Roussellet, A. Venelli
 *     https://eprint.iacr.org/2014/191.pdf
 *
 *   [ALT] Alternative Elliptic Curve Representations
 *     R. Struik
 *     https://tools.ietf.org/id/draft-ietf-lwig-curve-representations-02.html
 *
 *   [ARITH1] Arithmetic of Elliptic Curves
 *     Christophe Doche, Tanja Lange
 *     Handbook of Elliptic and Hyperelliptic Curve Cryptography
 *     Page 267, Section 13 (978-1-58488-518-4)
 *     https://hyperelliptic.org/HEHCC/index.html
 *
 *   [ARITH2] The Arithmetic of Elliptic Curves, 2nd Edition
 *     Joseph H. Silverman
 *     http://www.pdmi.ras.ru/~lowdimma/BSD/Silverman-Arithmetic_of_EC.pdf
 *
 *   [EFD] Explicit-Formulas Database
 *     Daniel J. Bernstein, Tanja Lange
 *     https://hyperelliptic.org/EFD/index.html
 *
 *   [SAFE] SafeCurves: choosing safe curves for elliptic-curve cryptography
 *     Daniel J. Bernstein
 *     https://safecurves.cr.yp.to/
 *
 *   [4GLV] Refinement of the Four-Dimensional GLV Method on Elliptic Curves
 *     Hairong Yi, Yuqing Zhu, and Dongdai Lin
 *     http://www.site.uottawa.ca/~cadams/papers/prepro/paper_19_slides.pdf
 *
 *   [SSWU1] Efficient Indifferentiable Hashing into Ordinary Elliptic Curves
 *     E. Brier, J. Coron, T. Icart, D. Madore, H. Randriam, M. Tibouchi
 *     https://eprint.iacr.org/2009/340.pdf
 *
 *   [SSWU2] Rational points on certain hyperelliptic curves over finite fields
 *     Maciej Ulas
 *     https://arxiv.org/abs/0706.1448
 *
 *   [H2EC] Hashing to Elliptic Curves
 *     A. Faz-Hernandez, S. Scott, N. Sullivan, R. S. Wahby, C. A. Wood
 *     https://git.io/JeWz6
 *     https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve
 *
 *   [SVDW1] Construction of Rational Points on Elliptic Curves
 *     A. Shallue, C. E. van de Woestijne
 *     https://works.bepress.com/andrew_shallue/1/download/
 *
 *   [SVDW2] Indifferentiable Hashing to Barreto-Naehrig Curves
 *     Pierre-Alain Fouque, Mehdi Tibouchi
 *     https://www.di.ens.fr/~fouque/pub/latincrypt12.pdf
 *
 *   [SVDW3] Covert ECDH over secp256k1
 *     Pieter Wuille
 *     https://gist.github.com/sipa/29118d3fcfac69f9930d57433316c039
 *
 *   [MONT2] Montgomery Curve (wikipedia)
 *     https://en.wikipedia.org/wiki/Montgomery_curve
 *
 *   [MONT3] Montgomery Curves and their arithmetic
 *     C. Costello, B. Smith
 *     https://eprint.iacr.org/2017/212.pdf
 *
 *   [ELL2] Elliptic-curve points indistinguishable from uniform random strings
 *     D. Bernstein, M. Hamburg, A. Krasnova, T. Lange
 *     https://elligator.cr.yp.to/elligator-20130828.pdf
 *
 *   [RFC7748] Elliptic Curves for Security
 *     A. Langley, M. Hamburg, S. Turner
 *     https://tools.ietf.org/html/rfc7748
 *
 *   [TWISTED] Twisted Edwards Curves
 *     D. Bernstein, P. Birkner, M. Joye, T. Lange, C. Peters
 *     https://eprint.iacr.org/2008/013.pdf
 *
 *   [ELL1] Injective Encodings to Elliptic Curves
 *     P. Fouque, A. Joux, M. Tibouchi
 *     https://eprint.iacr.org/2013/373.pdf
 *
 *   [ISOGENY] Twisting Edwards curves with isogenies
 *     Mike Hamburg
 *     https://www.shiftleft.org/papers/isogeny/isogeny.pdf
 *
 *   [RFC8032] Edwards-Curve Digital Signature Algorithm (EdDSA)
 *     S. Josefsson, SJD AB, I. Liusvaara
 *     https://tools.ietf.org/html/rfc8032
 *
 *   [SCHNORR] Schnorr Signatures for secp256k1
 *     Pieter Wuille
 *     https://github.com/sipa/bips/blob/d194620/bip-schnorr.mediawiki
 *
 *   [BIP340] Schnorr Signatures for secp256k1
 *     Pieter Wuille, Jonas Nick, Tim Ruffing
 *     https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki
 *
 *   [JCEN12] Efficient Software Implementation of Public-Key Cryptography
 *            on Sensor Networks Using the MSP430X Microcontroller
 *     C. P. L. Gouvea, L. B. Oliveira, J. Lopez
 *     http://conradoplg.cryptoland.net/files/2010/12/jcen12.pdf
 *
 *   [FIPS186] Federal Information Processing Standards Publication
 *     National Institute of Standards and Technology
 *     https://tinyurl.com/fips-186-3
 *
 *   [RFC5639] Elliptic Curve Cryptography (ECC) Brainpool
 *             Standard Curves and Curve Generation
 *     M. Lochter, BSI, J. Merkle
 *     https://tools.ietf.org/html/rfc5639
 *
 *   [TWISTEQ] Twisted Edwards & Short Weierstrass Equivalence
 *     Christopher Jeffrey
 *     https://gist.github.com/chjj/16ba7fa08d64e8dda269a9fe5b2a8bbc
 *
 *   [ECPM] Elliptic Curve Point Multiplication (wikipedia)
 *     https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication
 */
var Dd;
function Rg() {
  if (Dd) return er;
  Dd = 1;
  const { custom: e } = h7(), c = jr(), l = {
    AFFINE: 0,
    JACOBIAN: 1,
    PROJECTIVE: 2,
    EXTENDED: 3
  }, w = [
    -3,
    // -1 -1
    -1,
    // -1 0
    -5,
    // -1 1
    -7,
    // 0 -1
    0,
    // 0 0
    7,
    // 0 1
    5,
    // 1 -1
    1,
    // 1 0
    3
    // 1 1
  ];
  let m = 0;
  class f {
    constructor(r, x, O) {
      this.Point = null, this.id = null, this.uid = m++, this.ossl = null, this.type = "base", this.endian = "be", this.hash = null, this.prefix = null, this.context = !1, this.prime = null, this.p = null, this.red = null, this.fieldSize = 0, this.fieldBits = 0, this.adjustedSize = 0, this.signBit = 0, this.mask = 0, this.n = null, this.h = null, this.q = null, this.z = null, this.g = null, this.nh = null, this.scalarSize = 0, this.scalarBits = 0, this.zero = null, this.one = null, this.two = null, this.three = null, this.four = null, this.i2 = null, this.i3 = null, this.i4 = null, this.i6 = null, this.torsion = null, this.endo = null, this.hi = null, this._init(r, x, O);
    }
    _init(r, x, O) {
      I(typeof r == "function"), I(typeof x == "string"), I(O && typeof O == "object"), I(O.red == null || O.red instanceof c.Red), I(O.p != null, "Must pass a prime."), I(O.id == null || typeof O.id == "string"), I(O.ossl == null || typeof O.ossl == "string"), I(O.endian == null || typeof O.endian == "string"), I(O.hash == null || typeof O.hash == "string"), I(O.prefix == null || typeof O.prefix == "string"), I(O.context == null || typeof O.context == "boolean"), I(O.prime == null || typeof O.prime == "string"), I(O.torsion == null || Array.isArray(O.torsion)), this.Point = r, this.id = O.id || null, this.ossl = O.ossl || null, this.type = x, this.endian = O.endian || (x === "short" ? "be" : "le"), this.hash = O.hash || null, this.prefix = O.prefix ? k.from(O.prefix, "binary") : null, this.context = O.context || !1, this.prime = O.prime || null, this.p = c.fromJSON(O.p), O.red ? this.red = O.red : (this.red = O.prime ? c.red(O.prime) : c.mont(this.p), this.red.precompute()), this.fieldSize = this.p.byteLength(), this.fieldBits = this.p.bitLength(), this.adjustedSize = this.fieldSize + ((this.fieldBits & 7) === 0), this.signBit = this.adjustedSize * 8 - 1, this.mask = 255, (this.fieldBits & 7) !== 0 && (this.mask = (1 << (this.fieldBits & 7)) - 1), this.n = c.fromJSON(O.n || "0"), this.h = c.fromJSON(O.h || "1"), this.q = this.n.mul(this.h), this.z = c.fromJSON(O.z || "0").toRed(this.red), this.g = null, this.nh = this.n.ushrn(1), this.scalarSize = this.n.byteLength(), this.scalarBits = this.n.bitLength(), this.zero = new c(0).toRed(this.red), this.one = new c(1).toRed(this.red), this.two = new c(2).toRed(this.red), this.three = new c(3).toRed(this.red), this.four = new c(4).toRed(this.red), this.i2 = this.two.redInvert(), this.i3 = this.three.redInvert(), this.i4 = this.i2.redSqr(), this.i6 = this.i2.redMul(this.i3), this.torsion = new Array(this.h.word(0));
      for (let K = 0; K < this.torsion.length; K++)
        this.torsion[K] = this.point();
      return this.endo = null, this.hi = null, this._scale = C(this._scale, this), this.isIsomorphic = C(this.isIsomorphic, this), this.isIsogenous = C(this.isIsogenous, this), I(this.p.sign() > 0 && this.p.isOdd()), I(this.n.sign() >= 0), I(this.h.sign() > 0 && this.h.cmpn(255) <= 0), I(this.endian === "be" || this.endian === "le"), this;
    }
    _finalize(r) {
      if (I(r && typeof r == "object"), this.g = r.g ? this.pointFromJSON(r.g) : this.point(), r.torsion) {
        I(r.torsion.length === this.torsion.length);
        for (let x = 0; x < this.torsion.length; x++)
          this.torsion[x] = this.pointFromJSON(r.torsion[x]);
      }
      return this;
    }
    _findTorsion() {
      I(!this.n.isZero());
      const r = this.h.word(0), x = this.one.redNeg(), O = [this.point()], K = /* @__PURE__ */ new Set();
      let X = r;
      for (; O.length < X; ) {
        let P;
        x.redIAdd(this.one);
        try {
          P = this.pointFromX(x.clone());
        } catch {
          continue;
        }
        try {
          P = P.mul(this.n);
        } catch {
          X = 2;
          continue;
        }
        if (!P.isInfinity()) {
          P.normalize();
          for (const V of [P, P.neg()]) {
            const re = V.key();
            K.has(re) || (O.push(V), K.add(re));
          }
        }
      }
      for (O.sort((P, V) => P.cmp(V)); O.length < r; )
        O.push(this.point());
      return O;
    }
    _fixedMul(r, x) {
      I(r instanceof n), I(x instanceof c), I(r.pre && r.pre.windows);
      const { width: O, points: K } = r._getWindows(0, 0), X = 1 << O, V = (x.bitLength() + O - 1) / O >>> 0;
      let re = this.jpoint();
      for (let ce = 0; ce < V; ce++) {
        const de = x.bits(ce * O, O);
        re = re.add(K[ce * X + de]);
      }
      return x.isNeg() && (re = re.neg()), re;
    }
    _fixedNafMul(r, x) {
      I(r instanceof n), I(x instanceof c), I(r.pre && r.pre.doubles);
      const { step: O, points: K } = r._getDoubles(0, 0), X = Ee(x, 2, x.bitLength() + 1, O), P = ((1 << O + 1) - (O % 2 === 0 ? 2 : 1)) / 3;
      let V = this.jpoint(), re = this.jpoint();
      for (let ce = P; ce > 0; ce--) {
        for (let de = 0; de < X.length; de++) {
          const pe = X[de];
          pe === ce ? re = re.add(K[de]) : pe === -ce && (re = re.sub(K[de]));
        }
        V = V.add(re);
      }
      return V;
    }
    _wnafMul(r, x, O) {
      I(x instanceof n), I(O instanceof c);
      const { width: K, points: X } = x._safeNAF(r), P = ge(O, K, O.bitLength() + 1);
      let V = this.jpoint();
      for (let re = P.length - 1; re >= 0; re--) {
        const ce = P[re];
        re !== P.length - 1 && (V = V.dbl()), ce > 0 ? V = V.add(X[ce - 1 >> 1]) : ce < 0 && (V = V.sub(X[-ce - 1 >> 1]));
      }
      return V;
    }
    _wnafMulAdd(r, x, O) {
      I(r >>> 0 === r), I(Array.isArray(x)), I(Array.isArray(O)), I(x.length === O.length);
      const K = x.length, X = new Array(K), P = new Array(K);
      let V = 0;
      for (let se = 0; se < K; se++) {
        const Z = x[se], ee = O[se];
        if (I(Z instanceof n), I(ee instanceof c), se > 0 && Z.type !== x[se - 1].type)
          throw new Error("Cannot mix points.");
        X[se] = null, P[se] = null, V = Math.max(V, ee.bitLength() + 1);
      }
      let re = null, ce = null, de = 0;
      for (let se = 0; se < K; se++) {
        const Z = x[se], ee = O[se], me = Z._getNAF(0);
        if (me) {
          X[de] = me.points, P[de] = ge(ee, me.width, V), de += 1;
          continue;
        }
        if (!re) {
          re = Z, ce = ee;
          continue;
        }
        X[de] = re._getJNAF(Z), P[de] = z(ce, ee, V), re = null, ce = null, de += 1;
      }
      if (re) {
        const se = re._safeNAF(r);
        X[de] = se.points, P[de] = ge(ce, se.width, V), de += 1;
      }
      let pe = this.jpoint();
      for (let se = V - 1; se >= 0; se--) {
        se !== V - 1 && (pe = pe.dbl());
        for (let Z = 0; Z < de; Z++) {
          const ee = P[Z][se];
          ee > 0 ? pe = pe.add(X[Z][ee - 1 >> 1]) : ee < 0 && (pe = pe.sub(X[Z][-ee - 1 >> 1]));
        }
      }
      return pe;
    }
    _endoWnafMulAdd(r, x) {
      throw new Error("Not implemented.");
    }
    _scale(r, x) {
      switch (I(r instanceof f), I(r.p.eq(this.p)), r.type) {
        case "short":
          return this._scaleShort(r, x);
        case "mont":
          return this._scaleMont(r, x);
        case "edwards":
          return this._scaleEdwards(r, x);
        default:
          throw new Error("Not implemented.");
      }
    }
    _scaleShort(r, x) {
      throw new Error("Not implemented.");
    }
    _scaleMont(r, x) {
      throw new Error("Not implemented.");
    }
    _scaleEdwards(r, x) {
      throw new Error("Not implemented.");
    }
    isElliptic() {
      throw new Error("Not implemented.");
    }
    jinv() {
      throw new Error("Not implemented.");
    }
    isComplete() {
      return !1;
    }
    precompute(r) {
      return I(!this.g.isInfinity(), "Must have base point."), I(!this.n.isZero(), "Must have order."), this.g.precompute(this.n.bitLength(), r), this;
    }
    scalar(r, x, O) {
      const K = new c(r, x, O);
      return I(!K.red), this.n.isZero() ? K : K.imod(this.n);
    }
    field(r, x, O) {
      const K = c.cast(r, x, O);
      return K.red ? K.forceRed(this.red) : K.toRed(this.red);
    }
    point(r, x) {
      throw new Error("Not implemented.");
    }
    jpoint(r, x, O) {
      throw new Error("Not implemented.");
    }
    xpoint(r, x) {
      throw new Error("Not implemented.");
    }
    cpoint(r, x, O, K) {
      if (I(r instanceof c), I(x instanceof c), I(O instanceof c), I(K instanceof c), x.isZero() || K.isZero())
        return this.point();
      const X = x.redMul(K).redInvert(), P = r.redMul(K).redMul(X), V = O.redMul(x).redMul(X);
      return this.point(P, V);
    }
    solveX2(r) {
      throw new Error("Not implemented.");
    }
    solveX(r) {
      return this.solveX2(r).redSqrt();
    }
    solveY2(r) {
      throw new Error("Not implemented.");
    }
    solveY(r) {
      return this.solveY2(r).redSqrt();
    }
    validate(r) {
      throw new Error("Not implemented.");
    }
    pointFromX(r, x) {
      throw new Error("Not implemented.");
    }
    pointFromY(r, x) {
      throw new Error("Not implemented.");
    }
    isIsomorphic(r) {
      throw new Error("Not implemented.");
    }
    isIsogenous(r) {
      throw new Error("Not implemented.");
    }
    pointFromShort(r) {
      throw new Error("Not implemented.");
    }
    pointFromMont(r, x) {
      throw new Error("Not implemented.");
    }
    pointFromEdwards(r) {
      throw new Error("Not implemented.");
    }
    pointFromUniform(r) {
      throw new Error("Not implemented.");
    }
    pointToUniform(r) {
      throw new Error("Not implemented.");
    }
    pointFromHash(r, x = !1) {
      if (I(k.isBuffer(r)), I(typeof x == "boolean"), r.length !== this.fieldSize * 2)
        throw new Error("Invalid hash size.");
      const O = r.slice(0, this.fieldSize), K = r.slice(this.fieldSize), X = this.decodeUniform(O), P = this.decodeUniform(K), V = this.pointFromUniform(X), re = this.pointFromUniform(P), ce = V.add(re);
      return x ? ce.mulH() : ce;
    }
    pointToHash(r, x, O) {
      I(r instanceof this.Point), I(x >>> 0 === x);
      const K = x % this.torsion.length, X = r.add(this.torsion[K]);
      for (; ; ) {
        const P = this.randomField(O), V = this.pointFromUniform(P);
        if (V.neg().eq(V))
          continue;
        const re = X.sub(V), ce = J(O);
        let de;
        try {
          de = this.pointToUniform(re, ce & 15);
        } catch (Z) {
          if (Z.message === "Invalid point.")
            continue;
          throw Z;
        }
        const pe = this.encodeUniform(P, ce >>> 8), se = this.encodeUniform(de, ce >>> 16);
        return k.concat([pe, se]);
      }
    }
    randomScalar(r) {
      const x = this.n.isZero() ? this.p : this.n;
      return c.random(r, 1, x);
    }
    randomField(r) {
      return c.random(r, 1, this.p).toRed(this.red);
    }
    randomPoint(r) {
      let x;
      for (; ; ) {
        const O = this.randomField(r), K = (J(r) & 1) !== 0;
        try {
          x = this.pointFromX(O, K);
        } catch {
          continue;
        }
        return I(x.validate()), x.mulH();
      }
    }
    mulAll(r, x) {
      return this.jmulAll(r, x);
    }
    jmulAll(r, x) {
      return I(Array.isArray(r)), I(r.length === 0 || r[0] instanceof n), this.endo && r.length > 0 && r[0].type === l.AFFINE ? this._endoWnafMulAdd(r, x) : this._wnafMulAdd(5, r, x);
    }
    mulH(r) {
      return I(r instanceof c), this.imulH(r.clone());
    }
    imulH(r) {
      I(r instanceof c), I(!r.red);
      const x = this.h.word(0);
      if ((x & x - 1) === 0) {
        const O = this.h.bitLength();
        return r.iushln(O - 1).imod(this.n);
      }
      return r.imuln(x).imod(this.n);
    }
    normalizeAll(r) {
      I(Array.isArray(r));
      const x = r.length, O = new Array(x);
      for (let P = 0; P < x; P++) {
        const V = r[P];
        if (I(V instanceof n), I(V.curve === this), V.type === l.AFFINE) {
          O[P] = this.one;
          continue;
        }
        O[P] = V.z;
      }
      const K = this.red.invertAll(O), X = new Array(x);
      for (let P = 0; P < x; P++)
        X[P] = r[P].scale(K[P]);
      return X;
    }
    affinizeAll(r) {
      return this.normalizeAll(r);
    }
    clamp(r) {
      I(k.isBuffer(r)), I(r.length === this.scalarSize), I(this.scalarSize <= this.fieldSize);
      let x = this.fieldBits & 7 || 8, O = 0, K = this.scalarSize - 1;
      return this.endian === "be" && ([O, K] = [K, O]), this.scalarSize < this.fieldSize && (x = 8), r[O] &= -this.h.word(0) & 255, r[K] &= (1 << x) - 1, r[K] |= 1 << x - 1, r;
    }
    splitHash(r) {
      I(k.isBuffer(r)), I(r.length === this.adjustedSize * 2), I(this.scalarSize <= this.adjustedSize);
      let x = 0;
      this.endian === "be" && (x = this.adjustedSize - this.scalarSize);
      const O = r.slice(x, x + this.scalarSize), K = r.slice(this.adjustedSize);
      return this.clamp(O), [O, K];
    }
    encodeField(r) {
      return I(r instanceof c), I(!r.red), r.encode(this.endian, this.fieldSize);
    }
    decodeField(r) {
      if (I(k.isBuffer(r)), r.length !== this.fieldSize)
        throw new Error("Invalid field element size.");
      return c.decode(r, this.endian);
    }
    encodeAdjusted(r) {
      return I(r instanceof c), I(!r.red), r.encode(this.endian, this.adjustedSize);
    }
    decodeAdjusted(r) {
      if (I(k.isBuffer(r)), r.length !== this.adjustedSize)
        throw new Error("Invalid field element size.");
      return c.decode(r, this.endian);
    }
    encodeScalar(r) {
      return I(r instanceof c), I(!r.red), r.encode(this.endian, this.scalarSize);
    }
    decodeScalar(r) {
      if (I(k.isBuffer(r)), r.length !== this.scalarSize)
        throw new Error("Invalid scalar size.");
      return c.decode(r, this.endian);
    }
    encodeClamped(r) {
      return this.clamp(this.encodeScalar(r));
    }
    decodeClamped(r) {
      if (I(k.isBuffer(r)), r.length !== this.scalarSize)
        throw new Error("Invalid scalar size.");
      const x = this.clamp(k.from(r));
      return c.decode(x, this.endian);
    }
    encodeUniform(r, x) {
      I(r instanceof c), I(x >>> 0 === x);
      const O = this.endian === "le" ? this.fieldSize - 1 : 0, K = r.fromRed().encode(this.endian, this.fieldSize);
      return K[O] |= x & ~this.mask & 255, K;
    }
    decodeUniform(r) {
      if (I(k.isBuffer(r)), r.length !== this.fieldSize)
        throw new Error("Invalid field size.");
      const x = c.decode(r, this.endian);
      return x.iumaskn(this.fieldBits), x.toRed(this.red);
    }
    encodePoint(r, x) {
      return I(r instanceof n), r.encode(x);
    }
    decodePoint(r) {
      throw new Error("Not implemented.");
    }
    encodeX(r) {
      throw new Error("Not implemented.");
    }
    decodeX(r) {
      throw new Error("Not implemented.");
    }
    decodeEven(r) {
      throw new Error("Not implemented.");
    }
    decodeSquare(r) {
      throw new Error("Not implemented.");
    }
    toShort() {
      throw new Error("Not implemented.");
    }
    toMont(r) {
      throw new Error("Not implemented.");
    }
    toEdwards(r) {
      throw new Error("Not implemented.");
    }
    pointToJSON(r, x) {
      return I(r instanceof n), r.toJSON(x);
    }
    pointFromJSON(r) {
      throw new Error("Not implemented.");
    }
    toJSON(r) {
      let x, O, K, X, P;
      return this.type === "edwards" && (x = this.prefix ? this.prefix.toString() : null, O = this.context), this.n.isZero() || (K = this.n.toJSON()), this.z.isZero() || (X = this.z.fromRed(), this.z.redIsHigh() && X.isub(this.p), X = X.toString(16)), this.endo && (P = this.endo.toJSON()), {
        id: this.id,
        ossl: this.ossl,
        type: this.type,
        endian: this.endian,
        hash: this.hash,
        prefix: x,
        context: O,
        prime: this.prime,
        p: this.p.toJSON(),
        a: void 0,
        b: void 0,
        d: void 0,
        n: K,
        h: this.h.toString(16),
        s: void 0,
        z: X,
        c: void 0,
        g: this.g.toJSON(r),
        endo: P
      };
    }
    static fromJSON(r) {
      return new this(r);
    }
  }
  class n {
    constructor(r, x) {
      I(r instanceof f), I(x >>> 0 === x), this.curve = r, this.type = x, this.pre = null;
    }
    _init() {
      throw new Error("Not implemented.");
    }
    _safeNAF(r) {
      if (I(r >>> 0 === r), this.pre && this.pre.naf)
        return this.pre.naf;
      if (r === 0)
        return null;
      const x = 1 << r - 2, O = new Array(x), K = this.toJ(), X = x === 1 ? null : K.dbl();
      O[0] = K;
      for (let P = 1; P < x; P++)
        O[P] = O[P - 1].add(X);
      return new h(r, O);
    }
    _getNAF(r) {
      if (I(r >>> 0 === r), this.pre && this.pre.naf)
        return this.pre.naf;
      if (r === 0)
        return null;
      const x = this._safeNAF(r).points, O = this.curve.affinizeAll(x);
      return new h(r, O);
    }
    _getWindows(r, x) {
      if (I(r >>> 0 === r), I(x >>> 0 === x), this.pre && this.pre.windows)
        return this.pre.windows;
      if (r === 0)
        return null;
      const O = 1 << r, K = (x + r - 1) / r >>> 0, X = new Array(K * O);
      let P = this.toJ();
      for (let re = 0; re < K; re++) {
        X[re * O] = this.curve.jpoint();
        for (let ce = 1; ce < O; ce++)
          X[re * O + ce] = X[re * O + ce - 1].add(P);
        P = P.dblp(r);
      }
      const V = this.curve.affinizeAll(X);
      return new a(r, x, V);
    }
    _getDoubles(r, x) {
      if (I(r >>> 0 === r), I(x >>> 0 === x), this.pre && this.pre.doubles)
        return this.pre.doubles;
      if (r === 0)
        return null;
      const O = Math.ceil(x / r) + 1, K = new Array(O);
      let X = this.toJ(), P = 0;
      K[P++] = X;
      for (let re = 0; re < x; re += r) {
        for (let ce = 0; ce < r; ce++)
          X = X.dbl();
        K[P++] = X;
      }
      I(P === O);
      const V = this.curve.affinizeAll(K);
      return new E(r, V);
    }
    _getBeta() {
      return null;
    }
    _getBlinding(r) {
      if (this.pre && this.pre.blinding)
        return this.pre.blinding;
      if (!r || this.curve.n.isZero())
        return null;
      const x = this.curve.randomScalar(r), O = this.mul(x);
      return new H(x, O);
    }
    _hasWindows(r) {
      if (I(r instanceof c), !this.pre || !this.pre.windows)
        return !1;
      const { width: x, bits: O } = this.pre.windows, K = (O + x - 1) / x >>> 0;
      return r.bitLength() <= K * x;
    }
    _hasDoubles(r) {
      if (I(r instanceof c), !this.pre || !this.pre.doubles)
        return !1;
      const { step: x, points: O } = this.pre.doubles, K = r.bitLength() + 1;
      return O.length >= Math.ceil(K / x) + 1;
    }
    _getJNAF(r) {
      return I(r instanceof n), I(r.type === this.type), [
        this,
        // 1
        this.add(r),
        // 3
        this.sub(r),
        // 5
        r
        // 7
      ];
    }
    _blind(r, x) {
      if (I(r instanceof c), I(!r.red), this.pre && this.pre.blinding) {
        const { blind: K, unblind: X } = this.pre.blinding, P = r.sub(K);
        return [this, P, X];
      }
      if (!x)
        return [this, r, null];
      if (this.pre) {
        if (this.curve.n.isZero())
          return [this, r, null];
        const P = this.curve.randomScalar(x).mul(this.curve.n).iadd(r);
        return [this, P, null];
      }
      return [this.randomize(x), r, null];
    }
    clone() {
      throw new Error("Not implemented.");
    }
    precompute(r, x) {
      return I(r >>> 0 === r), this.pre || (this.pre = new b()), this.pre.naf || (this.pre.naf = this._getNAF(9)), this.pre.doubles || (this.pre.doubles = this._getDoubles(4, r + 1)), this.pre.beta || (this.pre.beta = this._getBeta()), this.pre.blinding || (this.pre.blinding = this._getBlinding(x)), this;
    }
    validate() {
      return this.curve.validate(this);
    }
    normalize() {
      return this;
    }
    scale(r) {
      throw new Error("Not implemented.");
    }
    randomize(r) {
      const x = this.curve.randomField(r);
      return this.scale(x);
    }
    neg() {
      throw new Error("Not implemented.");
    }
    add(r) {
      throw new Error("Not implemented.");
    }
    sub(r) {
      return I(r instanceof n), this.add(r.neg());
    }
    dbl() {
      throw new Error("Not implemented.");
    }
    dblp(r) {
      I(r >>> 0 === r);
      let x = this;
      for (let O = 0; O < r; O++)
        x = x.dbl();
      return x;
    }
    diffAddDbl(r, x) {
      throw new Error("Not implemented.");
    }
    getX() {
      throw new Error("Not implemented.");
    }
    getY() {
      throw new Error("Not implemented.");
    }
    eq(r) {
      throw new Error("Not implemented.");
    }
    cmp(r) {
      throw new Error("Not implemented.");
    }
    isInfinity() {
      throw new Error("Not implemented.");
    }
    isOrder2() {
      throw new Error("Not implemented.");
    }
    isOdd() {
      throw new Error("Not implemented.");
    }
    isEven() {
      throw new Error("Not implemented.");
    }
    isSquare() {
      throw new Error("Not implemented.");
    }
    eqX(r) {
      throw new Error("Not implemented.");
    }
    eqR(r) {
      throw new Error("Not implemented.");
    }
    isSmall() {
      return this.isInfinity() ? !1 : this.jmulH().isInfinity();
    }
    hasTorsion() {
      return this.isInfinity() ? !1 : !this.jmul(this.curve.n).isInfinity();
    }
    order() {
      const { h: r, n: x } = this.curve;
      let O = this.toJ(), K = new c(1);
      for (; !O.isInfinity(); ) {
        if (K.iaddn(1), K.cmp(r) > 0) {
          K = x.clone();
          break;
        }
        O = O.add(this);
      }
      return K;
    }
    mul(r) {
      return this.jmul(r);
    }
    muln(r) {
      return this.jmuln(r);
    }
    mulBlind(r, x) {
      return this.jmulBlind(r, x);
    }
    mulAdd(r, x, O) {
      return this.jmulAdd(r, x, O);
    }
    mulH() {
      return this.jmulH();
    }
    div(r) {
      return this.jdiv(r);
    }
    divn(r) {
      return this.jdivn(r);
    }
    divH() {
      return this.jdivH();
    }
    jmul(r) {
      return this._hasDoubles(r) ? this.curve._fixedNafMul(this, r) : this.curve.endo && this.type === l.AFFINE ? this.curve._endoWnafMulAdd([this], [r]) : this.curve._wnafMul(5, this, r);
    }
    jmuln(r) {
      return I((r | 0) === r), this.jmul(new c(r));
    }
    jmulBlind(r, x = null) {
      const [O, K, X] = this._blind(r, x), P = O.jmul(K);
      return X ? P.add(X) : P;
    }
    jmulAdd(r, x, O) {
      return this.curve.endo && this.type === l.AFFINE ? this.curve._endoWnafMulAdd([this, x], [r, O]) : this.curve._wnafMulAdd(5, [this, x], [r, O]);
    }
    jmulH() {
      const r = this.curve.h.word(0);
      if ((r & r - 1) === 0) {
        const x = this.curve.h.bitLength();
        return this.toJ().dblp(x - 1);
      }
      return this.jmul(this.curve.h);
    }
    jdiv(r) {
      return I(r instanceof c), I(!r.red), this.jmul(r.invert(this.curve.n));
    }
    jdivn(r) {
      return I(!this.curve.n.isZero()), this.curve.h.cmpn(r) === 0 ? this.jdivH() : this.jdiv(new c(r));
    }
    jdivH() {
      return this.curve.n.isZero() ? this.toJ() : this.curve.h.cmpn(1) === 0 ? this.toJ() : (this.curve.hi === null && (this.curve.hi = this.curve.h.invert(this.curve.n)), this.jmul(this.curve.hi));
    }
    toP() {
      return this.normalize();
    }
    toJ() {
      return this;
    }
    toX() {
      return this;
    }
    key() {
      if (this.isInfinity())
        return `${this.curve.uid}:oo`;
      this.normalize();
      const r = this.getX().toString(16), x = this.getY().toString(16);
      return `${this.curve.uid}:${r},${x}`;
    }
    encode(r) {
      throw new Error("Not implemented.");
    }
    static decode(r, x) {
      throw new Error("Not implemented.");
    }
    encodeX() {
      throw new Error("Not implemented.");
    }
    static decodeX(r, x) {
      throw new Error("Not implemented.");
    }
    static decodeEven(r, x) {
      throw new Error("Not implemented.");
    }
    static decodeSquare(r, x) {
      throw new Error("Not implemented.");
    }
    toJSON(r) {
      throw new Error("Not implemented.");
    }
    static fromJSON(r, x) {
      throw new Error("Not implemented.");
    }
    [e]() {
      return "<Point>";
    }
  }
  class u extends f {
    constructor(r) {
      super(o, "short", r), this.a = c.fromJSON(r.a).toRed(this.red), this.b = c.fromJSON(r.b).toRed(this.red), this.c = c.fromJSON(r.c || "0").toRed(this.red), this.ai = this.a.isZero() ? this.zero : this.a.redInvert(), this.zi = this.z.isZero() ? this.zero : this.z.redInvert(), this.zeroA = this.a.isZero(), this.threeA = this.a.eq(this.three.redNeg()), this.redN = this.n.toRed(this.red), this.pmodn = this.p.clone(), this.highOrder = this.n.cmp(this.p) >= 0, this.smallGap = !1, this._finalize(r);
    }
    _finalize(r) {
      return super._finalize(r), r.endo != null ? this.endo = j.fromJSON(this, r.endo) : this.endo = this._getEndomorphism(), this.n.isZero() || (this.pmodn = this.p.mod(this.n), this.smallGap = this.p.div(this.n).cmpn(1) <= 0), this;
    }
    static _isomorphism(r, x, O, K) {
      if (I(r instanceof c), I(x instanceof c), I(O instanceof c), I(K == null || typeof K == "boolean"), I(!r.isZero() || !x.isZero()), O.isZero())
        throw new Error("Invalid coefficient.");
      if (r.isZero()) {
        const pe = O, se = pe.redDiv(x), Z = U(se);
        return I(Z.redJacobi() === 1), [r.clone(), pe.clone()];
      }
      if (x.isZero()) {
        const pe = O, Z = pe.redDiv(r).redSqrt();
        if (Z.redJacobi() !== 1 && Z.redINeg(), Z.redJacobi() !== 1)
          throw new Error("Invalid `a` coefficient.");
        return [pe.clone(), x.clone()];
      }
      const X = O, P = X.redDiv(r), V = P.redSqrt();
      if (K != null ? V.redIsOdd() !== K && V.redINeg() : V.redJacobi() !== 1 && V.redINeg(), V.redJacobi() !== 1)
        throw new Error("Invalid `a` coefficient.");
      const re = P.redMul(V), ce = r.redMul(P), de = x.redMul(re);
      return I(ce.eq(X)), [ce, de];
    }
    _short(r, x) {
      return u._isomorphism(this.a, this.b, r, x);
    }
    _mont(r, x) {
      const [O, K] = this._findRS(x), X = K.redInvert(), P = O.redMuln(3).redMul(X);
      return r != null ? i._isomorphism(P, X, r) : [P, X];
    }
    _edwards(r, x) {
      const [O, K] = this._findRS(x), X = O.redMuln(3), P = K.redMuln(2), V = X.redAdd(P), re = X.redSub(P);
      return r != null ? S._isomorphism(V, re, r) : [V, re];
    }
    _findRS(r) {
      I(r == null || typeof r == "boolean"), I(this.h.word(0) >= 4), I(!this.n.isZero());
      const x = this.one.redNeg();
      let O;
      for (; ; ) {
        x.redIAdd(this.one);
        try {
          O = this.pointFromX(x.clone());
        } catch {
          continue;
        }
        if (O = O.mul(this.n), !O.isInfinity() && O.y.isZero())
          break;
      }
      const K = O.x, P = K.redSqr().redMuln(3).redIAdd(this.a).redSqrt();
      return r != null && P.redIsOdd() !== r && P.redINeg(), [K, P];
    }
    _scale0(r, x) {
      if (I(this.a.isZero() === r.isZero()), I(this.b.isZero() === x.isZero()), this.a.isZero()) {
        const re = this.b.redDiv(this.field(x)), ce = U(re), de = ce.redSqrt(), pe = ce.redMul(de);
        return I(pe.redSqr().eq(re)), I(!de.isZero()), [ce, pe];
      }
      if (this.b.isZero()) {
        const re = this.a.redDiv(this.field(r)), ce = re.redSqrt();
        ce.redJacobi() !== 1 && ce.redINeg();
        const de = ce.redSqrt(), pe = ce.redMul(de);
        return I(pe.redMul(de).eq(re)), I(!de.isZero()), [ce, pe];
      }
      const O = this.a.redDiv(this.field(r)), K = this.b.redDiv(this.field(x)), X = O.redSqrt();
      O.redMul(X).eq(K) || X.redINeg(), I(O.redMul(X).eq(K));
      const P = X.redSqrt(), V = X.redMul(P);
      return I(!P.isZero()), [X, V];
    }
    _scale1(r, x) {
      const O = this.g.x.redDiv(this.field(r)), K = this.g.y.redDiv(this.field(x)), X = O.redSqrt();
      return O.redMul(X).eq(K) || X.redINeg(), I(O.redMul(X).eq(K)), I(!X.isZero()), [O, K];
    }
    _scaleShort(r) {
      return I(r instanceof u), this.g.isInfinity() || r.g.isInfinity() ? this._scale0(r.a, r.b) : this._scale1(r.g.x, r.g.y);
    }
    _scaleMont(r) {
      if (I(r instanceof i), this.g.isInfinity() || r.g.isInfinity()) {
        const [P, V] = r._short();
        return this._scale0(P, V);
      }
      const { x, y: O } = r.g, K = x.redAdd(r.a3).redMul(r.bi), X = O.redMul(r.bi);
      return this._scale1(K, X);
    }
    _scaleEdwards(r) {
      if (I(r instanceof S), this.g.isInfinity() || r.g.isInfinity()) {
        const [_e, ke] = r._short();
        return this._scale0(_e, ke);
      }
      const { x, y: O, z: K } = r.g, X = r.a.redMuln(5), P = r.d.redMuln(5), V = r.d.redSub(r.a), re = P.redSub(r.a), ce = r.d.redSub(X), de = O.redAdd(K), pe = O.redSub(K), se = re.redMul(O).redIAdd(ce.redMul(K)), Z = pe.redMuln(12), ee = V.redMul(de).redMul(K), me = pe.redMul(x).redIMuln(4), Ae = Z.redMul(me).redInvert(), Oe = se.redMul(me).redMul(Ae), ye = ee.redMul(Z).redMul(Ae);
      return this._scale1(Oe, ye);
    }
    _getEndomorphism(r = 0) {
      if (this.n.isZero() || this.g.isInfinity() || !this.zeroA || this.p.modrn(3) !== 1 || this.n.modrn(3) !== 1)
        return null;
      const [x, O] = this._getEndoRoots(this.p), K = [x, O][r & 1].toRed(this.red), [X, P] = this._getEndoRoots(this.n), V = this.point(this.g.x.redMul(K), this.g.y);
      let re;
      this.g.mul(X).eq(V) ? re = X : (I(this.g.mul(P).eq(V)), re = P);
      const ce = this._getEndoBasis(re), de = this._getEndoPrecomp(ce);
      return new j(K, re, ce, de);
    }
    _getEndoRoots(r) {
      const x = r === this.p ? this.red : c.mont(r), O = new c(2).toRed(x), K = new c(3).toRed(x), X = O.redInvert(), P = K.redNeg().redSqrt().redMul(X), V = P.redNeg(), re = P.redSub(X).fromRed(), ce = V.redSub(X).fromRed();
      return [re, ce].sort(c.cmp);
    }
    _getEndoBasis(r) {
      const [x, O, K, X, P, V] = this._egcdSqrt(r), re = K, ce = X.neg(), de = x.sqr().iadd(O.sqr()), pe = P.sqr().iadd(V.sqr());
      let se, Z;
      return de.cmp(pe) <= 0 ? (se = x, Z = O.neg()) : (se = P, Z = V.neg()), [
        new G(re, ce),
        new G(se, Z)
      ];
    }
    _egcdSqrt(r) {
      I(r instanceof c), I(!r.red), I(r.sign() > 0), I(this.n.sign() > 0);
      const x = this.n.ushrn(this.n.bitLength() >>> 1);
      let O = r, K = this.n.clone(), X = new c(1), P = new c(0), V = new c(0), re = new c(1), ce, de, pe, se, Z = 0, ee = 0, me;
      for (; !O.isZero() && Z < 2; ) {
        const ye = K.quo(O), _e = K.sub(ye.mul(O)), ke = V.sub(ye.mul(X)), Me = re.sub(ye.mul(P));
        ee === 0 && _e.cmp(x) < 0 && (ce = me, de = X, pe = _e, se = ke, ee = 1), me = _e, K = O, O = _e, V = X, X = ke, re = P, P = Me, Z += ee;
      }
      return I(ee !== 0, "Could not find r < sqrt(n)."), [
        ce,
        de,
        pe,
        se,
        V,
        X
      ];
    }
    _getEndoPrecomp(r) {
      I(Array.isArray(r)), I(r.length === 2), I(r[0] instanceof G), I(r[1] instanceof G);
      const [x, O] = r, K = x.a.mul(O.b).isub(x.b.mul(O.a)), X = K.bitLength(), P = X >= 160;
      I(K.eq(this.n));
      let V = X + Math.ceil(X / 2) + 1, re, ce;
      for (P && (V -= V & 63); V > X && (re = O.b.ushln(V).divRound(K), ce = x.b.ushln(V).divRound(K), !(re.ucmp(K) < 0 && ce.ucmp(K) < 0)); )
        P ? V -= 64 : V -= 1;
      if (V <= X)
        throw new Error("Could not calculate g1 and g2.");
      return [V, re, ce];
    }
    _endoSplit(r) {
      I(r instanceof c), I(!r.red), I(!this.n.isZero());
      const [x, O] = this.endo.basis, K = O.b.mul(r).divRound(this.n), X = x.b.neg().mul(r).divRound(this.n), P = K.mul(x.a), V = X.mul(O.a), re = K.ineg().mul(x.b), ce = X.mul(O.b), de = r.sub(P).isub(V), pe = re.isub(ce);
      return [de, pe];
    }
    _endoBeta(r) {
      return I(r instanceof o), [r, r._getBeta()];
    }
    _endoWnafMulAdd(r, x) {
      I(Array.isArray(r)), I(Array.isArray(x)), I(r.length === x.length), I(this.endo != null);
      const O = r.length, K = new Array(O * 2), X = new Array(O * 2);
      for (let P = 0; P < O; P++) {
        const [V, re] = this._endoBeta(r[P]), [ce, de] = this._endoSplit(x[P]);
        K[P * 2 + 0] = V, X[P * 2 + 0] = ce, K[P * 2 + 1] = re, X[P * 2 + 1] = de;
      }
      return this._wnafMulAdd(5, K, X);
    }
    _sswu(r) {
      const { b: x, z: O, ai: K, zi: X, one: P } = this, V = O.redSqr(), re = x.redNeg().redMul(K), ce = x.redMul(X).redMul(K), de = r.redSqr(), pe = de.redSqr(), se = V.redMul(pe).redIAdd(O.redMul(de)), Z = se.isZero() ? se : se.redInvert(), ee = Z.isZero() ? ce : re.redMul(P.redAdd(Z)), me = O.redMul(de).redMul(ee), Ae = this.solveY2(ee), Oe = this.solveY2(me), ye = Ae.redIsSquare() | 0, _e = [ee, me][ye ^ 1], ke = [Ae, Oe][ye ^ 1].redSqrt();
      return ke.redIsOdd() !== r.redIsOdd() && ke.redINeg(), this.point(_e, ke);
    }
    _sswui(r, x) {
      const { a: O, b: K, z: X } = this, { x: P, y: V } = r, re = x & 3, ce = O.redSqr().redMul(P.redSqr()), de = O.redMul(K).redMul(P).redIMuln(2), pe = K.redSqr().redMuln(3), se = O.redMul(P).redIAdd(K), Z = ce.redISub(de).redISub(pe).redSqrt(), ee = se.redSub(Z).redINeg(), me = se.redAdd(Z).redINeg(), Ae = se.redMul(X).redIMuln(2), Oe = K.redMul(X).redIMuln(2), ye = [ee, me][re & 1], _e = [Ae, Oe][re >>> 1], ke = ye.redDivSqrt(_e);
      return ke.redIsOdd() !== V.redIsOdd() && ke.redINeg(), ke;
    }
    _svdwf(r) {
      const { c: x, z: O, zi: K, i2: X, i3: P } = this, V = this.solveY2(O), re = P.redMul(K.redSqr()), ce = r.redSqr(), de = ce.redSqr(), pe = ce.redAdd(V), se = ce.redMul(pe), Z = se.isZero() ? se : se.redInvert(), ee = de.redMul(Z).redMul(x), me = pe.redSqr().redMul(pe), Ae = x.redSub(O).redMul(X).redISub(ee), Oe = ee.redSub(x.redAdd(O).redMul(X)), ye = O.redSub(me.redMul(Z).redMul(re)), _e = this.solveY2(Ae), ke = this.solveY2(Oe), Me = this.solveY2(ye), De = _e.redJacobi() | 1, Ne = ke.redJacobi() | 1, $e = t((De - 1) * Ne, 3), bt = [Ae, Oe, ye][$e], Ve = [_e, ke, Me][$e];
      return [bt, Ve];
    }
    _svdw(r) {
      const [x, O] = this._svdwf(r), K = O.redSqrt();
      return K.redIsOdd() !== r.redIsOdd() && K.redINeg(), this.point(x, K);
    }
    _svdwi(r, x) {
      const { b: O, c: K, z: X, zero: P, two: V } = this, { x: re, y: ce } = r, de = x & 3, pe = X.redSqr(), se = pe.redMul(X), Z = pe.redSqr(), ee = se.redAdd(O), me = ee.redMuln(2), Ae = re.redSqr(), Oe = re.redMuln(2).redIAdd(X), ye = re.redMul(pe), _e = K.redSub(Oe), ke = K.redAdd(Oe), Me = Ae.redMul(pe).redIAdd(Z).redIMuln(9), De = re.redMul(se).redIMuln(18), Ne = ee.redMul(re.redSub(X)).redIMuln(12), bt = (de >= 2 ? Me.redISub(De).redIAdd(Ne).redSqrt() : P).redMul(X), Ve = se.redISub(ye).redIMuln(3).redISub(me), je = ee.redMul(_e), _t = ee.redMul(ke), Je = Ve.redAdd(bt), Ye = Ve.redSub(bt), Ot = V, We = [je, _t, Je, Ye][de], Ze = [ke, _e, Ot, Ot][de], Tt = We.redDivSqrt(Ze), [Qe] = this._svdwf(Tt);
      if (!Qe.eq(re))
        throw new Error("Invalid point.");
      return Tt.redIsOdd() !== ce.redIsOdd() && Tt.redINeg(), Tt;
    }
    isElliptic() {
      const { a: r, b: x } = this, K = r.redSqr().redMul(r);
      return !x.redSqr().redMuln(27).redIAdd(K.redMuln(4)).isZero();
    }
    jinv() {
      const { a: r, b: x } = this, K = r.redSqr().redMul(r), X = x.redSqr(), P = K.redMuln(4), V = P.redMuln(1728), re = X.redMuln(27).redIAdd(P);
      if (re.isZero())
        throw new Error("Curve is not elliptic.");
      return V.redDiv(re).fromRed();
    }
    point(r, x) {
      return new o(this, r, x);
    }
    jpoint(r, x, O) {
      return new s(this, r, x, O);
    }
    solveX(r) {
      if (I(r instanceof c), !this.a.isZero())
        throw new Error("Not implemented.");
      const O = r.redSqr().redSub(this.b);
      return B(O);
    }
    solveY2(r) {
      I(r instanceof c);
      const O = r.redSqr().redMul(r).redIAdd(this.b);
      return this.zeroA || (this.threeA ? O.redIAdd(r.redMuln(-3)) : O.redIAdd(this.a.redMul(r))), O;
    }
    validate(r) {
      if (I(r instanceof o), r.inf)
        return !0;
      const { x, y: O } = r, K = this.solveY2(x);
      return O.redSqr().eq(K);
    }
    pointFromX(r, x = null) {
      I(r instanceof c), I(x == null || typeof x == "boolean"), r.red || (r = r.toRed(this.red));
      const O = this.solveY(r);
      if (x != null) {
        if (this.h.cmpn(1) > 0 && O.isZero() && x)
          throw new Error("Invalid point.");
        O.redIsOdd() !== x && O.redINeg();
      }
      return this.point(r, O);
    }
    pointFromY(r, x = 0) {
      I(r instanceof c), I(x >>> 0 === x), r.red || (r = r.toRed(this.red));
      const O = this.solveX(r);
      if (x >= O.length)
        throw new Error("Invalid X coordinate index.");
      const K = O[x];
      return this.point(K, r);
    }
    isIsomorphic(r) {
      if (I(r instanceof f), !r.p.eq(this.p))
        return !1;
      let x, O;
      try {
        [x, O] = this._scale(r);
      } catch {
        return !1;
      }
      if (r.type === "short") {
        const K = this.field(r.a).redMul(x.redSqr()), X = this.field(r.b).redMul(O.redSqr());
        return this.a.eq(K) && this.b.eq(X);
      }
      if (r.type === "mont") {
        const { a3: K, bi: X } = r, P = this.field(K.redMul(X)).redMul(x);
        return this.solveY2(P).isZero();
      }
      if (r.type === "edwards") {
        const K = this.field(r.ad6).redMul(x);
        return this.solveY2(K).isZero();
      }
      return !1;
    }
    isIsogenous(r) {
      return I(r instanceof f), !1;
    }
    pointFromShort(r) {
      if (I(r instanceof o), this.isIsomorphic(r.curve)) {
        if (r.isInfinity())
          return this.point();
        const [x, O] = this._scale(r.curve), K = this.field(r.x), X = this.field(r.y), P = K.redMul(x), V = X.redMul(O);
        return this.point(P, V);
      }
      throw new Error("Not implemented.");
    }
    pointFromMont(r) {
      if (I(r instanceof p), this.isIsomorphic(r.curve)) {
        if (r.isInfinity())
          return this.point();
        const { a3: x, bi: O } = r.curve, [K, X] = this._scale(r.curve), P = r.x.redAdd(x).redMul(O), V = r.y.redMul(O);
        return this.point(
          this.field(P).redMul(K),
          this.field(V).redMul(X)
        );
      }
      throw new Error("Not implemented.");
    }
    pointFromEdwards(r) {
      if (I(r instanceof y), this.isIsomorphic(r.curve)) {
        const { a: x, d: O, ad6: K } = r.curve, [X, P] = this._scale(r.curve);
        if (r.isInfinity())
          return this.point();
        if (r.x.isZero()) {
          const Me = this.field(K).redMul(X);
          return this.point(Me, this.zero);
        }
        const { x: V, y: re, z: ce } = r, de = x.redMuln(5), pe = O.redMuln(5), se = O.redSub(x), Z = pe.redSub(x), ee = O.redSub(de), me = re.redAdd(ce), Ae = re.redSub(ce), Oe = Z.redMul(re).redIAdd(ee.redMul(ce)), ye = Ae.redMuln(12), _e = se.redMul(me).redMul(ce), ke = Ae.redMul(V).redIMuln(4);
        return this.cpoint(
          this.field(Oe).redMul(X),
          this.field(ye),
          this.field(_e).redMul(P),
          this.field(ke)
        );
      }
      throw new Error("Not implemented.");
    }
    pointFromUniform(r) {
      if (I(r instanceof c), this.z.isZero() || this.b.isZero())
        throw new Error("Not implemented.");
      if (!this.a.isZero())
        return this._sswu(r);
      if (!this.c.isZero())
        return this._svdw(r);
      throw new Error("Not implemented.");
    }
    pointToUniform(r, x) {
      if (I(r instanceof o), I(x >>> 0 === x), this.z.isZero() || this.b.isZero())
        throw new Error("Not implemented.");
      if (r.isInfinity())
        throw new Error("Invalid point.");
      const O = (x >>> 4 & 15) % this.torsion.length, K = r.add(this.torsion[O]);
      return ne(() => {
        if (!this.a.isZero())
          return this._sswui(K, x);
        if (!this.c.isZero())
          return this._svdwi(K, x);
        throw new Error("Not implemented.");
      });
    }
    mulAll(r, x) {
      return super.mulAll(r, x).toP();
    }
    affinizeAll(r) {
      const x = this.normalizeAll(r);
      for (let O = 0; O < x.length; O++)
        x[O] = x[O].toP();
      return x;
    }
    decodePoint(r) {
      return o.decode(this, r);
    }
    encodeX(r) {
      return I(r instanceof n), r.encodeX();
    }
    decodeEven(r) {
      return o.decodeEven(this, r);
    }
    decodeSquare(r) {
      return o.decodeSquare(this, r);
    }
    toShort(r, x, O = null) {
      const [K, X] = this._short(r, x), P = new u({
        red: this.red,
        prime: this.prime,
        p: this.p,
        a: K,
        b: X,
        n: this.n,
        h: this.h
      });
      if (O != null) {
        const [, V] = P._scale(this);
        V.redIsOdd() !== O && V.redINeg();
      }
      this.g.isInfinity() || (P.g = P.pointFromShort(this.g));
      for (let V = 0; V < this.h.word(0); V++)
        P.torsion[V] = P.pointFromShort(this.torsion[V]);
      return P;
    }
    toMont(r, x, O = null) {
      const [K, X] = this._mont(r, x), P = new i({
        red: this.red,
        prime: this.prime,
        p: this.p,
        a: K,
        b: X,
        n: this.n,
        h: this.h
      });
      if (O != null) {
        const [, V] = this._scale(P);
        V.redIsOdd() !== O && V.redINeg();
      }
      this.g.isInfinity() || (P.g = P.pointFromShort(this.g));
      for (let V = 0; V < this.h.word(0); V++)
        P.torsion[V] = P.pointFromShort(this.torsion[V]);
      return P;
    }
    toEdwards(r, x, O = null) {
      const [K, X] = this._edwards(r, x), P = new S({
        red: this.red,
        prime: this.prime,
        p: this.p,
        a: K,
        d: X,
        n: this.n,
        h: this.h
      });
      if (O != null) {
        const [, V] = this._scale(P);
        V.redIsOdd() !== O && V.redINeg();
      }
      if (this.g.isInfinity() || (P.g = P.pointFromShort(this.g), P.g.normalize()), P.isComplete())
        for (let V = 0; V < this.h.word(0); V++)
          P.torsion[V] = P.pointFromShort(this.torsion[V]), P.torsion[V].normalize();
      return P;
    }
    pointFromJSON(r) {
      return o.fromJSON(this, r);
    }
    toJSON(r) {
      const x = super.toJSON(r);
      return x.a = this.a.fromRed().toJSON(), x.b = this.b.fromRed().toJSON(), this.c.isZero() || (x.c = this.c.fromRed().toJSON()), x;
    }
  }
  class o extends n {
    constructor(r, x, O) {
      I(r instanceof u), super(r, l.AFFINE), this.x = this.curve.zero, this.y = this.curve.zero, this.inf = !0, x != null && this._init(x, O);
    }
    _init(r, x) {
      I(r instanceof c), I(x instanceof c), this.x = r, this.y = x, this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1;
    }
    _getBeta() {
      if (!this.curve.endo)
        return null;
      if (this.pre && this.pre.beta)
        return this.pre.beta;
      const r = this.x.redMul(this.curve.endo.beta), x = this.curve.point(r, this.y);
      return this.pre && (x.pre = this.pre.map((O) => {
        const K = O.x.redMul(this.curve.endo.beta);
        return this.curve.point(K, O.y);
      }), this.pre.beta = x), x;
    }
    _getJNAF(r) {
      if (I(r instanceof o), this.inf || r.inf)
        return super._getJNAF(r);
      const x = [
        this,
        // 1
        null,
        // 3
        null,
        // 5
        r
        // 7
      ];
      return this.y.eq(r.y) ? (x[1] = this.add(r), x[2] = this.toJ().sub(r)) : this.y.eq(r.y.redNeg()) ? (x[1] = this.toJ().add(r), x[2] = this.sub(r)) : (x[1] = this.toJ().add(r), x[2] = this.toJ().sub(r)), x;
    }
    clone() {
      return this.inf ? this.curve.point() : this.curve.point(this.x, this.y);
    }
    scale(r) {
      return this.toJ().scale(r);
    }
    neg() {
      return this.inf ? this : this.curve.point(this.x, this.y.redNeg());
    }
    add(r) {
      if (I(r instanceof o), this.inf)
        return r;
      if (r.inf)
        return this;
      if (this.x.eq(r.x))
        return this.y.eq(r.y) ? this.dbl() : this.curve.point();
      if (this.y.eq(r.y)) {
        const V = this.x.redNeg().redISub(r.x), re = this.y.redNeg();
        return this.curve.point(V, re);
      }
      const x = this.x.redSub(r.x), K = this.y.redSub(r.y).redDiv(x), X = K.redSqr().redISub(this.x).redISub(r.x), P = K.redMul(this.x.redSub(X)).redISub(this.y);
      return this.curve.point(X, P);
    }
    dbl() {
      if (this.inf)
        return this;
      if (this.y.isZero())
        return this.curve.point();
      const x = this.x.redSqr().redIMuln(3).redIAdd(this.curve.a), O = this.y.redMuln(2), K = x.redDiv(O), X = K.redSqr().redISub(this.x).redISub(this.x), P = K.redMul(this.x.redSub(X)).redISub(this.y);
      return this.curve.point(X, P);
    }
    dblp(r) {
      return this.toJ().dblp(r).toP();
    }
    getX() {
      if (this.inf)
        throw new Error("Invalid point.");
      return this.x.fromRed();
    }
    getY() {
      if (this.inf)
        throw new Error("Invalid point.");
      return this.y.fromRed();
    }
    eq(r) {
      return I(r instanceof o), this === r ? !0 : this.inf ? r.inf : r.inf ? !1 : this.x.eq(r.x) && this.y.eq(r.y);
    }
    cmp(r) {
      return I(r instanceof o), this.inf && !r.inf ? -1 : !this.inf && r.inf ? 1 : this.inf && r.inf ? 0 : this.order().cmp(r.order()) || this.getX().cmp(r.getX()) || this.getY().cmp(r.getY());
    }
    isInfinity() {
      return this.inf;
    }
    isOrder2() {
      return this.inf ? !1 : this.y.isZero();
    }
    isOdd() {
      return this.inf ? !1 : this.y.redIsOdd();
    }
    isEven() {
      return this.inf ? !1 : this.y.redIsEven();
    }
    isSquare() {
      return this.inf ? !1 : this.y.redJacobi() !== -1;
    }
    eqX(r) {
      return I(r instanceof c), I(!r.red), this.inf ? !1 : this.getX().eq(r);
    }
    eqR(r) {
      return I(r instanceof c), I(!r.red), I(!this.curve.n.isZero()), this.inf ? !1 : this.getX().imod(this.curve.n).eq(r);
    }
    mul(r) {
      return super.mul(r).toP();
    }
    muln(r) {
      return super.muln(r).toP();
    }
    mulBlind(r, x) {
      return super.mulBlind(r, x).toP();
    }
    mulAdd(r, x, O) {
      return super.mulAdd(r, x, O).toP();
    }
    mulH() {
      return super.mulH().toP();
    }
    div(r) {
      return super.div(r).toP();
    }
    divn(r) {
      return super.divn(r).toP();
    }
    divH() {
      return super.divH().toP();
    }
    toP() {
      return this;
    }
    toJ() {
      return this.inf ? this.curve.jpoint() : this.curve.jpoint(this.x, this.y, this.curve.one);
    }
    encode(r) {
      r == null && (r = !0), I(typeof r == "boolean");
      const { fieldSize: x } = this.curve;
      if (this.inf)
        throw new Error("Invalid point.");
      if (r) {
        const P = k.alloc(1 + x), V = this.curve.encodeField(this.getX());
        return P[0] = 2 | this.y.redIsOdd(), V.copy(P, 1), P;
      }
      const O = k.alloc(1 + x * 2), K = this.curve.encodeField(this.getX()), X = this.curve.encodeField(this.getY());
      return O[0] = 4, K.copy(O, 1), X.copy(O, 1 + x), O;
    }
    static decode(r, x) {
      I(r instanceof u), I(k.isBuffer(x));
      const O = r.fieldSize;
      if (x.length < 1 + O)
        throw new Error("Not a point.");
      const K = x[0];
      switch (K) {
        case 2:
        case 3: {
          if (x.length !== 1 + O)
            throw new Error("Invalid point size for compressed.");
          const X = r.decodeField(x.slice(1, 1 + O));
          if (X.cmp(r.p) >= 0)
            throw new Error("Invalid point.");
          const P = r.pointFromX(X, K === 3);
          return I(!P.isInfinity()), P;
        }
        case 4:
        case 6:
        case 7: {
          if (x.length !== 1 + O * 2)
            throw new Error("Invalid point size for uncompressed.");
          const X = r.decodeField(x.slice(1, 1 + O)), P = r.decodeField(x.slice(1 + O, 1 + 2 * O));
          if (X.cmp(r.p) >= 0 || P.cmp(r.p) >= 0)
            throw new Error("Invalid point.");
          if (K !== 4 && K !== (6 | P.isOdd()))
            throw new Error("Invalid hybrid encoding.");
          const V = r.point(X, P);
          if (!V.validate())
            throw new Error("Invalid point.");
          return I(!V.isInfinity()), V;
        }
        default:
          throw new Error("Unknown point format.");
      }
    }
    encodeX() {
      return this.curve.encodeField(this.getX());
    }
    static decodeEven(r, x) {
      I(r instanceof u);
      const O = r.decodeField(x);
      if (O.cmp(r.p) >= 0)
        throw new Error("Invalid point.");
      return r.pointFromX(O, !1);
    }
    static decodeSquare(r, x) {
      I(r instanceof u);
      const O = r.decodeField(x);
      if (O.cmp(r.p) >= 0)
        throw new Error("Invalid point.");
      return r.pointFromX(O);
    }
    toJSON(r) {
      if (this.inf)
        return [];
      const x = this.getX().toJSON(), O = this.getY().toJSON();
      return r === !0 && this.pre ? [x, O, this.pre.toJSON()] : [x, O];
    }
    toPretty() {
      if (this.inf)
        return [];
      const r = this.curve.fieldSize * 2, x = M(this.getX(), r), O = M(this.getY(), r);
      return [x, O];
    }
    static fromJSON(r, x) {
      if (I(r instanceof u), I(Array.isArray(x)), I(x.length === 0 || x.length === 2 || x.length === 3), x.length === 0)
        return r.point();
      const O = c.fromJSON(x[0]), K = c.fromJSON(x[1]), X = r.point(O, K);
      return x.length > 2 && x[2] != null && (X.pre = b.fromJSON(X, x[2])), X;
    }
    [e]() {
      return this.inf ? "<ShortPoint: Infinity>" : "<ShortPoint: x=" + this.x.fromRed().toString(16, 2) + " y=" + this.y.fromRed().toString(16, 2) + ">";
    }
  }
  class s extends n {
    constructor(r, x, O, K) {
      I(r instanceof u), super(r, l.JACOBIAN), this.x = this.curve.one, this.y = this.curve.one, this.z = this.curve.zero, this.zOne = !1, x != null && this._init(x, O, K);
    }
    _init(r, x, O) {
      I(r instanceof c), I(x instanceof c), I(O == null || O instanceof c), this.x = r, this.y = x, this.z = O || this.curve.one, this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z.eq(this.curve.one);
    }
    clone() {
      return this.curve.jpoint(this.x, this.y, this.z);
    }
    validate() {
      const { a: r, b: x } = this.curve;
      if (this.isInfinity())
        return !0;
      if (this.zOne)
        return this.curve.validate(this.toP());
      const O = this.y.redSqr(), K = this.x.redSqr().redMul(this.x), X = this.z.redSqr(), P = X.redSqr(), V = P.redMul(X), re = K.redIAdd(x.redMul(V));
      return this.curve.zeroA || (this.curve.threeA ? re.redIAdd(P.redIMuln(-3).redMul(this.x)) : re.redIAdd(r.redMul(P).redMul(this.x))), O.eq(re);
    }
    normalize() {
      if (this.zOne)
        return this;
      if (this.isInfinity())
        return this;
      const r = this.z.redInvert(), x = r.redSqr();
      return this.x = this.x.redMul(x), this.y = this.y.redMul(x).redMul(r), this.z = this.curve.one, this.zOne = !0, this;
    }
    scale(r) {
      if (I(r instanceof c), this.isInfinity())
        return this.curve.jpoint();
      const x = r.redSqr(), O = this.x.redMul(x), K = this.y.redMul(x).redMul(r), X = this.z.redMul(r);
      return this.curve.jpoint(O, K, X);
    }
    neg() {
      return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
    }
    add(r) {
      return I(r instanceof n), r.type === l.AFFINE ? this._mixedAdd(r) : this._add(r);
    }
    _add(r) {
      return I(r instanceof s), this.isInfinity() ? r : r.isInfinity() ? this : this.zOne ? r._addJA(this) : r.zOne ? this._addJA(r) : this._addJJ(r);
    }
    _mixedAdd(r) {
      return I(r instanceof o), this.isInfinity() ? r.toJ() : r.isInfinity() ? this : this._addJA(r);
    }
    _addJJ(r) {
      const x = this.z.redSqr(), O = r.z.redSqr(), K = this.x.redMul(O), X = r.x.redMul(x), P = this.y.redMul(r.z).redMul(O), V = r.y.redMul(this.z).redMul(x), re = X.redISub(K), ce = V.redISub(P);
      if (re.isZero())
        return ce.isZero() ? this.dbl() : this.curve.jpoint();
      const de = re.redSqr(), pe = re.redMul(de), se = K.redMul(de), Z = ce.redSqr().redISub(pe).redISub(se).redISub(se), ee = ce.redMul(se.redISub(Z)).redISub(P.redMul(pe)), me = this.z.redMul(r.z).redMul(re);
      return this.curve.jpoint(Z, ee, me);
    }
    _addJA(r) {
      const x = this.z.redSqr(), O = r.x.redMul(x), K = r.y.redMul(this.z).redMul(x), X = O.redISub(this.x), P = K.redISub(this.y).redIMuln(2);
      if (X.isZero())
        return P.isZero() ? this.dbl() : this.curve.jpoint();
      const V = X.redMuln(2).redSqr(), re = X.redMul(V), ce = this.x.redMul(V), de = P.redSqr().redISub(re).redISub(ce).redISub(ce), pe = P.redMul(ce.redISub(de)).redISub(this.y.redMul(re).redIMuln(2)), se = this.z.redMul(X).redIMuln(2);
      return this.curve.jpoint(de, pe, se);
    }
    dbl() {
      return this.isInfinity() ? this : this.y.isZero() ? this.curve.jpoint() : this.curve.zeroA ? this._dbl0() : this.curve.threeA ? this._dbl3() : this._dblJ();
    }
    _dblJ() {
      const r = this.x.redSqr(), x = this.y.redSqr(), O = this.z.redSqr(), K = this.x.redMul(x).redIMuln(4), X = r.redIMuln(3).redIAdd(this.curve.a.redMul(O.redSqr())), P = X.redSqr().redISub(K).redISub(K), V = P, re = X.redMul(K.redISub(P)).redISub(x.redSqr().redIMuln(8)), ce = this.y.redMul(this.z).redIMuln(2);
      return this.curve.jpoint(V, re, ce);
    }
    _dbl0() {
      const r = this.x.redSqr(), x = this.y.redSqr(), O = x.redSqr(), X = x.redIAdd(this.x).redSqr().redISub(r).redISub(O).redIMuln(2), P = r.redIMuln(3), re = P.redSqr().redISub(X).redISub(X), ce = P.redMul(X.redISub(re)).redISub(O.redIMuln(8)), de = this.y.redMul(this.z).redIMuln(2);
      return this.curve.jpoint(re, ce, de);
    }
    _dbl3() {
      const r = this.z.redSqr(), x = this.y.redSqr(), O = this.x.redMul(x), K = this.x.redSub(r), X = this.x.redAdd(r), P = K.redMul(X).redIMuln(3), V = O.redIMuln(4), re = V.redMuln(2), ce = x.redSqr().redIMuln(8), de = P.redSqr().redISub(re), pe = this.y.redAdd(this.z).redSqr().redISub(x).redISub(r), se = P.redMul(V.redISub(de)).redISub(ce);
      return this.curve.jpoint(de, se, pe);
    }
    getX() {
      if (this.isInfinity())
        throw new Error("Invalid point.");
      return this.normalize(), this.x.fromRed();
    }
    getY() {
      if (this.isInfinity())
        throw new Error("Invalid point.");
      return this.normalize(), this.y.fromRed();
    }
    eq(r) {
      if (I(r instanceof s), this === r)
        return !0;
      if (this.isInfinity())
        return r.isInfinity();
      if (r.isInfinity())
        return !1;
      if (this.z.eq(r.z))
        return this.x.eq(r.x) && this.y.eq(r.y);
      const x = this.z.redSqr(), O = r.z.redSqr(), K = this.x.redMul(O), X = r.x.redMul(x);
      if (!K.eq(X))
        return !1;
      const P = x.redMul(this.z), V = O.redMul(r.z), re = this.y.redMul(V), ce = r.y.redMul(P);
      return re.eq(ce);
    }
    cmp(r) {
      I(r instanceof s);
      const x = this.isInfinity(), O = r.isInfinity();
      return x && !O ? -1 : !x && O ? 1 : x && O ? 0 : this.order().cmp(r.order()) || this.getX().cmp(r.getX()) || this.getY().cmp(r.getY());
    }
    isInfinity() {
      return this.z.isZero();
    }
    isOrder2() {
      return this.isInfinity() ? !1 : this.y.isZero();
    }
    isOdd() {
      return this.isInfinity() ? !1 : (this.normalize(), this.y.redIsOdd());
    }
    isEven() {
      return this.isInfinity() ? !1 : (this.normalize(), this.y.redIsEven());
    }
    isSquare() {
      return this.isInfinity() ? !1 : this.y.redMul(this.z).redJacobi() !== -1;
    }
    eqX(r) {
      if (I(r instanceof c), I(!r.red), this.isInfinity())
        return !1;
      const x = this.z.redSqr(), O = r.toRed(this.curve.red).redMul(x);
      return this.x.eq(O);
    }
    eqR(r) {
      if (I(r instanceof c), I(!r.red), !this.curve.smallGap)
        return this.toP().eqR(r);
      if (this.isInfinity() || r.cmp(this.curve.p) >= 0)
        return !1;
      const x = this.z.redSqr(), O = r.toRed(this.curve.red).redMul(x);
      if (this.x.eq(O))
        return !0;
      if (this.curve.highOrder || r.cmp(this.curve.pmodn) >= 0)
        return !1;
      const K = this.curve.redN.redMul(x);
      return O.redIAdd(K), this.x.eq(O);
    }
    toP() {
      return this.isInfinity() ? this.curve.point() : (this.normalize(), this.curve.point(this.x, this.y));
    }
    toJ() {
      return this;
    }
    encode(r) {
      return this.toP().encode(r);
    }
    static decode(r, x) {
      return o.decode(r, x).toJ();
    }
    encodeX() {
      return this.toP().encodeX();
    }
    static decodeEven(r, x) {
      return o.decodeEven(r, x).toJ();
    }
    static decodeSquare(r, x) {
      return o.decodeSquare(r, x).toJ();
    }
    toJSON(r) {
      return this.toP().toJSON(r);
    }
    toPretty() {
      return this.toP().toPretty();
    }
    static fromJSON(r, x) {
      return o.fromJSON(r, x).toJ();
    }
    [e]() {
      return this.isInfinity() ? "<JPoint: Infinity>" : "<JPoint: x=" + this.x.fromRed().toString(16, 2) + " y=" + this.y.fromRed().toString(16, 2) + " z=" + this.z.fromRed().toString(16, 2) + ">";
    }
  }
  class i extends f {
    constructor(r) {
      super(p, "mont", r), this.a = c.fromJSON(r.a).toRed(this.red), this.b = c.fromJSON(r.b).toRed(this.red), this.bi = this.b.redInvert(), this.a2 = this.a.redAdd(this.two), this.a24 = this.a2.redMul(this.i4), this.a3 = this.a.redMul(this.i3), this.a0 = this.a.redMul(this.bi), this.b0 = this.bi.redSqr(), this._finalize(r);
    }
    static _isomorphism(r, x, O) {
      I(r instanceof c), I(x instanceof c), I(O instanceof c);
      const K = r.clone(), X = O.clone();
      if (x.redDiv(O).redJacobi() !== 1)
        throw new Error("Invalid `b` coefficient.");
      return [K, X];
    }
    _short(r, x) {
      const { a: O, b: K, three: X } = this, P = O.redSqr(), V = P.redMul(O), re = K.redSqr(), ce = re.redMul(K), de = X.redSub(P), pe = re.redMuln(3), se = V.redMuln(2).redISub(O.redMuln(9)), Z = ce.redMuln(27), ee = de.redDiv(pe), me = se.redDiv(Z);
      return r != null ? u._isomorphism(ee, me, r, x) : [ee, me];
    }
    _mont(r) {
      return i._isomorphism(this.a, this.b, r);
    }
    _edwards(r, x = !1) {
      I(typeof x == "boolean");
      const { two: O, bi: K } = this, X = this.a.redAdd(O).redMul(K), P = this.a.redSub(O).redMul(K);
      return x && X.swap(P), r != null ? S._isomorphism(X, P, r) : [X, P];
    }
    _scaleShort(r) {
      I(r instanceof u);
      const [x, O] = r._scale(this);
      return [
        this.field(x.redInvert()),
        this.field(O.redInvert())
      ];
    }
    _scaleMont(r) {
      return I(r instanceof i), this.g.isInfinity() || r.g.isInfinity() ? this.field(r.b).redDivSqrt(this.b) : this.g.y.redDiv(this.field(r.g.y));
    }
    _scaleEdwards(r, x) {
      I(r instanceof S);
      const O = r._scale(this, x);
      return this.field(O);
    }
    _solveY0(r) {
      I(r instanceof c);
      const x = this.a0, O = this.b0, K = r.redSqr();
      return K.redMul(r).redIAdd(x.redMul(K)).redIAdd(O.redMul(r));
    }
    _elligator2(r) {
      const x = this.a0.redNeg(), O = this.one.redAdd(this.z.redMul(r.redSqr()));
      O.isZero() && O.inject(this.one);
      const K = x.redMul(O.redInvert()), X = K.redNeg().redISub(this.a0), P = this._solveY0(K), V = this._solveY0(X), re = P.redIsSquare() | 0, ce = [K, X][re ^ 1], de = [P, V][re ^ 1].redSqrt();
      de.redIsOdd() !== r.redIsOdd() && de.redINeg();
      const pe = this.b.redMul(ce), se = this.b.redMul(de);
      return this.point(pe, se);
    }
    _invert2(r, x) {
      const { x: O, y: K } = r, X = x & 1, P = O.redMul(this.bi), V = K.redMul(this.bi), re = P.redAdd(this.a0), ce = P, de = [re, ce][X].redINeg(), pe = [ce, re][X].redMul(this.z), se = de.redDivSqrt(pe);
      return se.redIsOdd() !== V.redIsOdd() && se.redINeg(), se;
    }
    isElliptic() {
      const r = this.a.redSqr();
      return !this.b.redMul(r.redSub(this.four)).isZero();
    }
    jinv() {
      const { a: r, three: x, four: O } = this, K = r.redSqr(), P = K.redSub(x).redPown(3).redIMuln(256), V = K.redSub(O);
      if (V.isZero())
        throw new Error("Curve is not elliptic.");
      return P.redDiv(V).fromRed();
    }
    point(r, x) {
      return new p(this, r, x);
    }
    jpoint(r, x, O) {
      return I(r == null && x == null && O == null), this.point();
    }
    xpoint(r, x) {
      return new g(this, r, x);
    }
    solveY2(r) {
      I(r instanceof c);
      const x = r.redSqr();
      return x.redMul(r).redIAdd(this.a.redMul(x)).redIAdd(r).redMul(this.bi);
    }
    validate(r) {
      if (I(r instanceof p), r.isInfinity())
        return !0;
      const { x, y: O } = r, K = this.solveY2(x);
      return O.redSqr().eq(K);
    }
    pointFromX(r, x = null) {
      I(r instanceof c), I(x == null || typeof x == "boolean"), r.red || (r = r.toRed(this.red));
      const O = this.solveY(r);
      if (x != null) {
        if (O.isZero() && x)
          throw new Error("Invalid point.");
        O.redIsOdd() !== x && O.redINeg();
      }
      return this.point(r, O);
    }
    isIsomorphic(r, x) {
      if (I(r instanceof f), !r.p.eq(this.p))
        return !1;
      if (r.type === "mont") {
        const O = this.field(r.a), K = this.field(r.b);
        return !this.a.eq(O) || this.b.isZero() ? !1 : K.redDiv(this.b).redJacobi() === 1;
      }
      return r.isIsomorphic(this, x);
    }
    isIsogenous(r) {
      return I(r instanceof f), r.type === "mont" ? !1 : r.isIsogenous(this);
    }
    pointFromShort(r) {
      if (I(r instanceof o), this.isIsomorphic(r.curve)) {
        if (r.isInfinity())
          return this.point();
        const { a3: x, b: O } = this, [K, X] = this._scale(r.curve), P = this.field(r.x).redMul(K), V = this.field(r.y).redMul(X), re = O.redMul(P).redISub(x), ce = O.redMul(V);
        return this.point(re, ce);
      }
      throw new Error("Not implemented.");
    }
    pointFromMont(r) {
      if (I(r instanceof p), this.isIsomorphic(r.curve)) {
        if (r.isInfinity())
          return this.point();
        const x = this._scale(r.curve), O = this.field(r.x), K = this.field(r.y), X = O, P = x.redMul(K);
        return this.point(X, P);
      }
      throw new Error("Not implemented.");
    }
    pointFromEdwards(r) {
      I(r instanceof y), I(r.curve.p.eq(this.p));
      const x = this.field(r.x), O = this.field(r.y), K = this.field(r.z);
      if (this.isIsogenous(r.curve)) {
        if (r.isInfinity())
          return this.point();
        if (r.x.isZero())
          return this.point(this.zero, this.zero);
        const X = K.redSqr().redIMuln(2), P = O.redSqr(), V = x.redSqr(), re = X.redISub(V).redISub(P).redMul(O), ce = V.redMul(x);
        return this.cpoint(P, V, re, ce);
      }
      if (this.isIsomorphic(r.curve, !0)) {
        if (r.isInfinity())
          return this.point();
        if (r.x.isZero())
          return this.point(this.zero, this.zero);
        const X = this._scale(r.curve, !0), P = O.redAdd(K), V = O.redSub(K), re = X.redMul(K).redMul(P), ce = x.redMul(V);
        return this.cpoint(P, V, re, ce);
      }
      if (this.isIsomorphic(r.curve, !1)) {
        if (r.isInfinity())
          return this.point();
        if (r.x.isZero())
          return this.point(this.zero, this.zero);
        const X = this._scale(r.curve, !1), P = K.redAdd(O), V = K.redSub(O), re = X.redMul(K).redMul(P), ce = x.redMul(V);
        return this.cpoint(P, V, re, ce);
      }
      throw new Error("Not implemented.");
    }
    pointFromUniform(r) {
      if (I(r instanceof c), this.z.isZero() || this.a.isZero())
        throw new Error("Not implemented.");
      return this._elligator2(r);
    }
    pointToUniform(r, x) {
      if (I(r instanceof p), I(x >>> 0 === x), this.z.isZero() || this.a.isZero())
        throw new Error("Not implemented.");
      if (r.isInfinity())
        throw new Error("Invalid point.");
      const O = (x >>> 4 & 15) % this.torsion.length, K = r.add(this.torsion[O]);
      return ne(() => this._invert2(K, x));
    }
    decodePoint(r, x) {
      return p.decode(this, r, x);
    }
    encodeX(r) {
      return I(r instanceof g), r.encode();
    }
    decodeX(r) {
      return g.decode(this, r);
    }
    toShort(r, x, O = null) {
      const [K, X] = this._short(r, x), P = new u({
        red: this.red,
        prime: this.prime,
        p: this.p,
        a: K,
        b: X,
        n: this.n,
        h: this.h
      });
      if (O != null) {
        const [, V] = P._scale(this);
        V.redIsOdd() !== O && V.redINeg();
      }
      this.g.isInfinity() || (P.g = P.pointFromMont(this.g));
      for (let V = 0; V < this.h.word(0); V++)
        P.torsion[V] = P.pointFromMont(this.torsion[V]);
      return P;
    }
    toMont(r, x = null) {
      const [O, K] = this._mont(r), X = new i({
        red: this.red,
        prime: this.prime,
        p: this.p,
        a: O,
        b: K,
        n: this.n,
        h: this.h,
        z: this.z
      });
      if (x != null) {
        const P = X._scale(this);
        P.redIsOdd() !== x && P.redINeg();
      }
      this.g.isInfinity() || (X.g = X.pointFromMont(this.g));
      for (let P = 0; P < this.h.word(0); P++)
        X.torsion[P] = X.pointFromMont(this.torsion[P]);
      return X;
    }
    toEdwards(r, x, O = null) {
      const [K, X] = this._edwards(r, x), P = new S({
        red: this.red,
        prime: this.prime,
        p: this.p,
        a: K,
        d: X,
        n: this.n,
        h: this.h,
        z: this.z
      });
      if (O != null) {
        const V = P._scale(this, x);
        V.redIsOdd() !== O && V.redINeg();
      }
      if (this.g.isInfinity() || (P.g = P.pointFromMont(this.g), P.g.normalize()), P.isComplete())
        for (let V = 0; V < this.h.word(0); V++)
          P.torsion[V] = P.pointFromMont(this.torsion[V]), P.torsion[V].normalize();
      return P;
    }
    pointFromJSON(r) {
      return p.fromJSON(this, r);
    }
    toJSON(r) {
      const x = super.toJSON(r);
      return x.a = this.a.fromRed().toJSON(), x.b = this.b.fromRed().toJSON(), x;
    }
  }
  class p extends n {
    constructor(r, x, O) {
      I(r instanceof i), super(r, l.AFFINE), this.x = this.curve.zero, this.y = this.curve.zero, this.inf = !0, x != null && this._init(x, O);
    }
    _init(r, x) {
      I(r instanceof c), I(x instanceof c), this.x = r, this.y = x, this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1;
    }
    clone() {
      return this.inf ? this.curve.point() : this.curve.point(this.x, this.y);
    }
    scale(r) {
      return this.clone();
    }
    randomize(r) {
      return this.clone();
    }
    neg() {
      return this.inf ? this : this.curve.point(this.x, this.y.redNeg());
    }
    add(r) {
      if (I(r instanceof p), this.inf)
        return r;
      if (r.inf)
        return this;
      if (this.x.eq(r.x))
        return this.y.eq(r.y) ? this.dbl() : this.curve.point();
      const x = r.x.redSub(this.x), K = r.y.redSub(this.y).redDiv(x), P = this.curve.b.redMul(K.redSqr()).redISub(this.curve.a).redISub(this.x).redISub(r.x), V = K.redMul(this.x.redSub(P)).redISub(this.y);
      return this.curve.point(P, V);
    }
    dbl() {
      if (this.inf)
        return this;
      if (this.y.isZero())
        return this.curve.point();
      const r = this.x.redSqr().redIMuln(3), x = this.curve.a.redMul(this.x).redIMuln(2), O = r.redIAdd(x).redIAdd(this.curve.one), K = this.curve.b.redMul(this.y).redIMuln(2), X = O.redDiv(K), V = this.curve.b.redMul(X.redSqr()).redISub(this.curve.a).redISub(this.x).redISub(this.x), re = X.redMul(this.x.redSub(V)).redISub(this.y);
      return this.curve.point(V, re);
    }
    getX() {
      if (this.inf)
        throw new Error("Invalid point.");
      return this.x.fromRed();
    }
    getY() {
      if (this.inf)
        throw new Error("Invalid point.");
      return this.y.fromRed();
    }
    eq(r) {
      return I(r instanceof p), this === r ? !0 : this.inf ? r.inf : r.inf ? !1 : this.x.eq(r.x) && this.y.eq(r.y);
    }
    cmp(r) {
      return I(r instanceof p), this.inf && !r.inf ? -1 : !this.inf && r.inf ? 1 : this.inf && r.inf ? 0 : this.order().cmp(r.order()) || this.getX().cmp(r.getX()) || this.getY().cmp(r.getY());
    }
    isInfinity() {
      return this.inf;
    }
    isOrder2() {
      return this.inf ? !1 : this.y.isZero();
    }
    isOdd() {
      return this.inf ? !1 : this.y.redIsOdd();
    }
    isEven() {
      return this.inf ? !1 : this.y.redIsEven();
    }
    toP() {
      return this;
    }
    toJ() {
      return this;
    }
    toX() {
      return this.inf ? this.curve.xpoint() : this.curve.xpoint(this.x, this.curve.one);
    }
    encode() {
      return this.toX().encode();
    }
    static decode(r, x, O) {
      return I(r instanceof i), r.decodeX(x).toP(O);
    }
    toJSON(r) {
      if (this.inf)
        return [];
      const x = this.getX().toJSON(), O = this.getY().toJSON();
      return [x, O];
    }
    toPretty() {
      if (this.inf)
        return [];
      const r = this.curve.fieldSize * 2, x = M(this.getX(), r), O = M(this.getY(), r);
      return [x, O];
    }
    static fromJSON(r, x) {
      if (I(r instanceof i), I(Array.isArray(x)), I(x.length === 0 || x.length === 2 || x.length === 3), x.length === 0)
        return r.point();
      const O = c.fromJSON(x[0]), K = c.fromJSON(x[1]);
      return r.point(O, K);
    }
    [e]() {
      return this.inf ? "<MontPoint: Infinity>" : "<MontPoint: x=" + this.x.fromRed().toString(16, 2) + " y=" + this.y.fromRed().toString(16, 2) + ">";
    }
  }
  class g extends n {
    constructor(r, x, O) {
      I(r instanceof i), super(r, l.PROJECTIVE), this.x = this.curve.one, this.z = this.curve.zero, x != null && this._init(x, O);
    }
    _init(r, x) {
      I(r instanceof c), I(x == null || x instanceof c), this.x = r, this.z = x || this.curve.one, this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red));
    }
    clone() {
      return this.curve.xpoint(this.x, this.z);
    }
    precompute(r, x) {
      return this;
    }
    validate() {
      if (this.isInfinity())
        return !0;
      const { x: r, z: x } = this, O = r.redSqr(), K = O.redMul(r), X = x.redSqr(), P = this.curve.a.redMul(O).redMul(x);
      return K.redIAdd(P).redIAdd(r.redMul(X)).redMul(this.curve.bi).redMul(x).redJacobi() !== -1;
    }
    normalize() {
      return this.isInfinity() ? this : this.z.eq(this.curve.one) ? this : (this.x = this.x.redDiv(this.z), this.z = this.curve.one, this);
    }
    scale(r) {
      if (I(r instanceof c), this.isInfinity())
        return this.curve.xpoint();
      const x = this.x.redMul(r), O = this.z.redMul(r);
      return this.curve.xpoint(x, O);
    }
    neg() {
      return this;
    }
    dbl() {
      const x = this.x.redAdd(this.z).redSqr(), K = this.x.redSub(this.z).redSqr(), X = x.redSub(K), P = x.redMul(K), V = X.redMul(K.redIAdd(this.curve.a24.redMul(X)));
      return this.curve.xpoint(P, V);
    }
    diffAddDbl(r, x) {
      I(r instanceof g), I(x instanceof g);
      const O = r.x.redAdd(r.z), K = O.redSqr(), X = r.x.redSub(r.z), P = X.redSqr(), V = K.redSub(P), re = x.x.redAdd(x.z), de = x.x.redSub(x.z).redMul(O), pe = re.redMul(X), se = this.z.redMul(de.redAdd(pe).redSqr()), Z = this.x.redMul(de.redISub(pe).redSqr()), ee = K.redMul(P), me = V.redMul(P.redIAdd(this.curve.a24.redMul(V)));
      return [
        this.curve.xpoint(ee, me),
        this.curve.xpoint(se, Z)
      ];
    }
    getX() {
      if (this.isInfinity())
        throw new Error("Invalid point.");
      return this.normalize(), this.x.fromRed();
    }
    getY(r) {
      return this.toP(r).getY();
    }
    eq(r) {
      if (I(r instanceof g), this === r)
        return !0;
      if (this.isInfinity())
        return r.isInfinity();
      if (r.isInfinity())
        return !1;
      if (this.z.eq(r.z))
        return this.x.eq(r.x);
      const x = this.x.redMul(r.z), O = r.x.redMul(this.z);
      return x.eq(O);
    }
    cmp(r) {
      I(r instanceof g);
      const x = this.isInfinity(), O = r.isInfinity();
      return x && !O ? -1 : !x && O ? 1 : x && O ? 0 : this.order().cmp(r.order()) || this.getX().cmp(r.getX());
    }
    isInfinity() {
      return this.z.isZero();
    }
    isOrder2() {
      return this.isInfinity() ? !1 : this.x.isZero();
    }
    isOdd() {
      return !1;
    }
    isEven() {
      return !1;
    }
    hasTorsion() {
      return this.isInfinity() ? !1 : this.x.isZero() ? !0 : super.hasTorsion();
    }
    order() {
      try {
        return this.toP().order();
      } catch {
        return new c(1);
      }
    }
    jmul(r) {
      I(r instanceof c), I(!r.red);
      const x = r.bitLength();
      let O = this.curve.xpoint(), K = this;
      for (let X = x - 1; X >= 0; X--)
        r.bit(X) === 0 ? [O, K] = this.diffAddDbl(O, K) : [K, O] = this.diffAddDbl(K, O);
      return O;
    }
    jmulBlind(r, x) {
      return x ? this.randomize(x).jmul(r) : this.jmul(r);
    }
    jmulAdd(r, x, O) {
      throw new Error("Not implemented.");
    }
    toP(r = null) {
      return I(r == null || typeof r == "boolean"), this.isInfinity() ? this.curve.point() : (this.normalize(), this.curve.pointFromX(this.x, r));
    }
    toJ() {
      return this;
    }
    toX() {
      return this;
    }
    key() {
      if (this.isInfinity())
        return `${this.curve.uid}:oo`;
      this.normalize();
      const r = this.getX().toString(16);
      return `${this.curve.uid}:${r}`;
    }
    encode() {
      return this.curve.encodeField(this.getX());
    }
    static decode(r, x) {
      I(r instanceof i);
      const O = r.decodeField(x);
      O.iumaskn(r.fieldBits);
      const K = r.xpoint(O, r.one);
      return I(!K.isInfinity()), K;
    }
    toJSON(r) {
      return this.toP().toJSON(r);
    }
    toPretty() {
      return this.toP().toPretty();
    }
    static fromJSON(r, x) {
      return p.fromJSON(r, x).toX();
    }
    [e]() {
      return this.isInfinity() ? "<XPoint: Infinity>" : "<XPoint: x=" + this.x.fromRed().toString(16, 2) + " z=" + this.z.fromRed().toString(16, 2) + ">";
    }
  }
  class S extends f {
    constructor(r) {
      super(y, "edwards", r), this.a = c.fromJSON(r.a).toRed(this.red), this.d = c.fromJSON(r.d).toRed(this.red), this.s = c.fromJSON(r.s || "0").toRed(this.red), this.si = this.s.isZero() ? this.zero : this.s.redInvert(), this.k = this.d.redMuln(2), this.smi = -this.d.redNeg().word(0), this.ad6 = this.a.redAdd(this.d).redMul(this.i6), this.twisted = !this.a.eq(this.one), this.oneA = this.a.eq(this.one), this.mOneA = this.a.eq(this.one.redNeg()), this.smallD = this.prime != null && this.d.redNeg().length === 1, this.alt = null, this._finalize(r);
    }
    static _isomorphism(r, x, O) {
      I(r instanceof c), I(x instanceof c), I(O instanceof c);
      const K = O.clone(), X = O.redMul(x).redDiv(r);
      if (r.redDiv(O).redJacobi() !== 1)
        throw new Error("Invalid `a` coefficient.");
      return [K, X];
    }
    _short(r, x) {
      const { a: O, d: K } = this, X = O.redSqr(), P = X.redMul(O), V = K.redSqr(), re = V.redMul(K), ce = O.redMul(K).redIMuln(14), de = X.redMul(K), pe = O.redMul(V), se = de.redIAdd(pe).redIMuln(33), Z = X.redAdd(ce).redIAdd(V).redDivn(-48), ee = se.redISub(P).redISub(re).redDivn(864);
      return r != null ? u._isomorphism(Z, ee, r, x) : [Z, ee];
    }
    _mont(r, x = !1) {
      I(typeof x == "boolean");
      let O, K;
      x ? (O = this.d.redAdd(this.a), K = this.d.redSub(this.a)) : (O = this.a.redAdd(this.d), K = this.a.redSub(this.d));
      const X = K.redInvert(), P = O.redMuln(2).redMul(X), V = X.redMuln(4);
      return r != null ? i._isomorphism(P, V, r) : [P, V];
    }
    _edwards(r) {
      return S._isomorphism(this.a, this.d, r);
    }
    _scaleShort(r) {
      I(r instanceof u);
      const [x, O] = r._scale(this);
      return [
        this.field(x.redInvert()),
        this.field(O.redInvert())
      ];
    }
    _scaleMont(r, x = !1) {
      if (I(r instanceof i), I(typeof x == "boolean"), this.g.isInfinity() || r.g.isInfinity()) {
        const [K] = r._edwards(null, x);
        return this.field(K).redDivSqrt(this.a);
      }
      const O = r.g.x.redDiv(r.g.y);
      return this.g.x.redDiv(this.field(O));
    }
    _scaleEdwards(r) {
      return I(r instanceof S), this.g.isInfinity() || r.g.isInfinity() ? this.field(r.a).redDivSqrt(this.a) : this.g.x.redDiv(this.field(r.g.x));
    }
    _mulA(r) {
      return I(r instanceof c), this.oneA ? r.clone() : this.mOneA ? r.redNeg() : this.a.redMul(r);
    }
    _mulD(r) {
      return I(r instanceof c), this.smallD ? r.redMuln(this.smi) : this.d.redMul(r);
    }
    _elligator1(r) {
      const { s: x, si: O, i2: K, one: X, two: P } = this, V = O.redSqr().redIMuln(2), re = x.redSqr().redMul(K), ce = re.redSqr(), de = V.redAdd(re), pe = de.redSqr().redISub(P), se = V.redSub(X), Z = X.redSub(r), ee = X.redAdd(r), me = ee.isZero() ? ee : Z.redDiv(ee), Ae = me.redSqr(), Oe = Ae.redMul(me), _e = Oe.redMul(Ae).redAdd(pe.redMul(Oe)).redIAdd(me), ke = this.field(_e.redJacobi()), Me = this.field(Ae.redAdd(ce).redJacobi()), De = ke.redMul(Me), Ne = ke.redMul(me), $e = ke.redMul(_e).redSqrt().redMul(De), bt = X.redAdd(Ne), Ve = de.redMul(Ne), je = bt.redSqr(), _t = se.redMul(x).redMul(Ne).redMul(bt), Je = me.isZero() ? this.one : $e, Ye = Ve.redSub(je), Ot = Ve.redAdd(je);
      return this.cpoint(_t, Je, Ye, Ot);
    }
    _invert1(r, x) {
      const { s: O, si: K, i2: X, one: P } = this, { x: V, y: re, z: ce } = r, de = x & 1, pe = K.redSqr().redIMuln(2), se = O.redSqr().redMul(X), Z = se.redSqr(), ee = pe.redAdd(se), me = pe.redSub(P), Ae = re.redSub(ce), Oe = re.redAdd(ce).redIMuln(2), ye = Oe.isZero() ? Oe : Ae.redDiv(Oe), _e = P.redAdd(ye.redMul(ee)), De = _e.redSqr().redISub(P).redSqrt().redSub(_e), Ne = P.redAdd(De), bt = me.redMul(O).redMul(De).redMul(Ne).redMul(V.redMul(ce)), Ve = De.redSqr().redIAdd(Z), _t = this.field(bt.redMul(Ve).redJacobi()).redMul(De), Je = P.redSub(_t), Ye = P.redAdd(_t), Ot = Ye.isZero() ? Ye : Je.redDiv(Ye);
      return Ot.redIsOdd() !== !!de && Ot.redINeg(), Ot;
    }
    _alt() {
      return this.alt || (this.alt = this.toMont()), this.alt;
    }
    isElliptic() {
      const r = this.a.redMul(this.d), x = this.a.redSub(this.d);
      return !r.redMul(x).isZero();
    }
    jinv() {
      const { a: r, d: x } = this, O = r.redMul(x), K = r.redSub(x).redPown(4), X = r.redSqr(), P = x.redSqr(), re = X.redAdd(O.redMuln(14)).redIAdd(P).redPown(3).redIMuln(16), ce = O.redMul(K);
      if (ce.isZero())
        throw new Error("Curve is not elliptic.");
      return re.redDiv(ce).fromRed();
    }
    isComplete() {
      return this.a.redJacobi() === 1 && this.d.redJacobi() === -1;
    }
    point(r, x, O, K) {
      return new y(this, r, x, O, K);
    }
    jpoint(r, x, O) {
      return I(r == null && x == null && O == null), this.point();
    }
    cpoint(r, x, O, K) {
      I(r instanceof c), I(x instanceof c), I(O instanceof c), I(K instanceof c);
      const X = r.redMul(K), P = O.redMul(x), V = x.redMul(K), re = r.redMul(O);
      return this.point(X, P, V, re);
    }
    solveX2(r) {
      I(r instanceof c);
      const x = r.redSqr(), O = this._mulD(x).redISub(this.a);
      return x.redISub(this.one).redDiv(O);
    }
    solveX(r) {
      const x = r.redSqr(), O = this._mulD(x).redISub(this.a);
      return x.redISub(this.one).redDivSqrt(O);
    }
    solveY2(r) {
      I(r instanceof c);
      const x = r.redSqr(), O = this._mulA(x).redISub(this.one), K = this._mulD(x).redISub(this.one);
      return O.redDiv(K);
    }
    solveY(r) {
      const x = r.redSqr(), O = this._mulA(x).redISub(this.one), K = this._mulD(x).redISub(this.one);
      return O.redDivSqrt(K);
    }
    validate(r) {
      if (I(r instanceof y), r.zOne) {
        const pe = r.x.redSqr(), se = r.y.redSqr(), Z = this._mulD(pe).redMul(se), ee = this._mulA(pe).redIAdd(se), me = this.one.redAdd(Z), Ae = r.t, Oe = r.x.redMul(r.y);
        return ee.eq(me) && Ae.eq(Oe);
      }
      const x = r.x.redSqr(), O = r.y.redSqr(), K = r.z.redSqr(), X = K.redSqr(), P = this._mulD(x).redMul(O), V = this._mulA(x).redIAdd(O).redMul(K), re = X.redIAdd(P), ce = r.t.redMul(r.z), de = r.x.redMul(r.y);
      return V.eq(re) && ce.eq(de);
    }
    pointFromX(r, x = null) {
      I(r instanceof c), I(x == null || typeof x == "boolean"), r.red || (r = r.toRed(this.red));
      const O = this.solveY(r);
      if (x != null) {
        if (O.isZero() && x)
          throw new Error("Invalid point.");
        O.redIsOdd() !== x && O.redINeg();
      }
      return this.point(r, O);
    }
    pointFromY(r, x = null) {
      I(r instanceof c), I(x == null || typeof x == "boolean"), r.red || (r = r.toRed(this.red));
      const O = this.solveX(r);
      if (x != null) {
        if (O.isZero() && x)
          throw new Error("Invalid point.");
        O.redIsOdd() !== x && O.redINeg();
      }
      return this.point(O, r);
    }
    isIsomorphic(r, x = !1) {
      if (I(r instanceof f), I(typeof x == "boolean"), !r.p.eq(this.p))
        return !1;
      if (r.type === "short")
        return r.isIsomorphic(this);
      if (r.type === "mont") {
        const O = this.field(r.a);
        let K, X;
        return x ? (K = this.d.redAdd(this.a), X = this.d.redSub(this.a)) : (K = this.a.redAdd(this.d), X = this.a.redSub(this.d)), O.redMul(X).eq(K.redIMuln(2));
      }
      if (r.type === "edwards") {
        const O = this.field(r.a), K = this.field(r.d);
        return this.a.redMul(K).eq(O.redMul(this.d));
      }
      return !1;
    }
    isIsogenous(r) {
      if (I(r instanceof f), !r.p.eq(this.p))
        return !1;
      if (r.type === "mont") {
        if (!this.a.eq(this.one))
          return !1;
        const x = this.field(r.a), O = this.field(r.b), K = this.two.redSub(this.d.redMuln(4));
        return x.eq(K) && O.eq(this.one);
      }
      if (r.type === "edwards") {
        const x = this.field(r.a), O = this.field(r.d);
        return x.eq(this.a.redNeg()) && O.eq(this.d.redSub(this.a));
      }
      return !1;
    }
    pointFromShort(r) {
      if (I(r instanceof o), this.isIsomorphic(r.curve)) {
        if (r.isInfinity())
          return this.point();
        if (r.y.isZero())
          return this.point(this.zero, this.one.redNeg());
        const { a: x, d: O } = this, [K, X] = this._scale(r.curve), P = x.redMuln(5), V = O.redMuln(5), re = this.field(r.x).redMul(K), ce = this.field(r.y).redMul(X), de = re.redMuln(6), pe = re.redMuln(12), se = de.redSub(x).redISub(O), Z = ce.redMuln(6), ee = pe.redSub(P).redIAdd(O), me = pe.redAdd(x).redISub(V);
        return this.cpoint(se, Z, ee, me);
      }
      throw new Error("Not implemented.");
    }
    pointFromMont(r) {
      I(r instanceof p), I(r.curve.p.eq(this.p));
      const x = this.field(r.x), O = this.field(r.y);
      if (this.isIsogenous(r.curve)) {
        if (r.isInfinity())
          return this.point();
        if (r.x.isZero())
          return this.point();
        const K = x.redSqr(), X = K.redMul(x), P = X.redMul(x), V = P.redMul(x), re = O.redSqr(), ce = O.redMuln(4), de = K.redSub(this.one), pe = K.redMuln(2), se = re.redMuln(4), Z = X.redIMuln(2), ee = x.redMul(re).redIMuln(4), me = K.redMul(re).redIMuln(2), Ae = re.redIMuln(2), Oe = ce.redMul(de), ye = P.redISub(pe).redIAdd(se).redIAdd(this.one), _e = V.redSub(Z).redISub(ee).redIAdd(x).redINeg(), ke = V.redISub(me).redISub(Z).redISub(Ae).redIAdd(x);
        return this.cpoint(Oe, ye, _e, ke).divn(4);
      }
      if (this.isIsomorphic(r.curve, !0)) {
        if (r.isInfinity())
          return this.point();
        if (r.x.isZero())
          return this.point(this.zero, this.one.redNeg());
        const X = this._scale(r.curve, !0).redMul(x), P = O, V = x.redAdd(this.one), re = x.redSub(this.one);
        return this.cpoint(X, P, V, re);
      }
      if (this.isIsomorphic(r.curve, !1)) {
        if (r.isInfinity())
          return this.point();
        if (r.x.isZero())
          return this.point(this.zero, this.one.redNeg());
        const X = this._scale(r.curve, !1).redMul(x), P = O, V = x.redSub(this.one), re = x.redAdd(this.one);
        return this.cpoint(X, P, V, re);
      }
      throw new Error("Not implemented.");
    }
    pointFromEdwards(r) {
      I(r instanceof y), I(r.curve.p.eq(this.p));
      const x = this.field(r.curve.a), O = this.field(r.x), K = this.field(r.y), X = this.field(r.z), P = this.field(r.t);
      if (this.isIsogenous(r.curve)) {
        const V = O.redMul(K), re = O.redSqr(), ce = K.redSqr(), de = X.redSqr(), pe = x.redMul(re), se = V.redIMuln(2), Z = ce.redSub(pe), ee = ce.redAdd(pe), me = de.redIMuln(2).redISub(ee), Ae = this.cpoint(se, Z, ee, me);
        return this.twisted ? Ae : Ae.divn(4);
      }
      if (this.isIsomorphic(r.curve)) {
        const V = this._scale(r.curve), re = V.redMul(O), ce = K, de = X, pe = V.redMul(P);
        return this.point(re, ce, de, pe);
      }
      throw new Error("Not implemented.");
    }
    pointFromUniform(r, x = null) {
      I(r instanceof c), I(r.red === this.red), I(x == null || x instanceof i), x || (x = this._alt());
      const O = x.field(r), K = x.pointFromUniform(O);
      return this.pointFromMont(K);
    }
    pointToUniform(r, x, O = null) {
      I(r instanceof y), I(x >>> 0 === x), I(O == null || O instanceof i), O || (O = this._alt());
      const K = (x >> 4 & 15) % this.torsion.length, X = r.add(this.torsion[K]), P = O.pointFromEdwards(X), V = O.pointToUniform(P, x & 15);
      return this.field(V);
    }
    pointFromHash(r, x, O = null) {
      I(O == null || O instanceof i), O || (O = this._alt());
      const K = O.pointFromHash(r, x);
      return this.pointFromMont(K);
    }
    pointToHash(r, x, O, K = null) {
      I(r instanceof y), I(x >>> 0 === x), I(K == null || K instanceof i), K || (K = this._alt());
      const X = x % this.torsion.length, P = r.add(this.torsion[X]), V = K.pointFromEdwards(P);
      return K.pointToHash(V, 0, O);
    }
    decodePoint(r) {
      return y.decode(this, r);
    }
    toShort(r, x, O = null) {
      const [K, X] = this._short(r, x), P = new u({
        red: this.red,
        prime: this.prime,
        p: this.p,
        a: K,
        b: X,
        n: this.n,
        h: this.h
      });
      if (O != null) {
        const [, V] = P._scale(this);
        V.redIsOdd() !== O && V.redINeg();
      }
      this.g.isInfinity() || (P.g = P.pointFromEdwards(this.g));
      for (let V = 0; V < this.h.word(0); V++)
        P.torsion[V] = P.pointFromEdwards(this.torsion[V]);
      return P;
    }
    toMont(r, x, O = null) {
      const [K, X] = this._mont(r, x), P = new i({
        red: this.red,
        prime: this.prime,
        p: this.p,
        a: K,
        b: X,
        n: this.n,
        h: this.h,
        z: this.z
      });
      if (O != null) {
        const V = this._scale(P, x);
        V.redIsOdd() !== O && V.redINeg();
      }
      this.g.isInfinity() || (P.g = P.pointFromEdwards(this.g));
      for (let V = 0; V < this.h.word(0); V++)
        P.torsion[V] = P.pointFromEdwards(this.torsion[V]);
      return P;
    }
    toEdwards(r, x = null) {
      const [O, K] = this._edwards(r), X = new S({
        red: this.red,
        prime: this.prime,
        p: this.p,
        a: O,
        d: K,
        n: this.n,
        h: this.h,
        z: this.z
      });
      if (x != null) {
        const P = X._scale(this);
        P.redIsOdd() !== x && P.redINeg();
      }
      if (this.g.isInfinity() || (X.g = X.pointFromEdwards(this.g), X.g.normalize()), X.isComplete())
        for (let P = 0; P < this.h.word(0); P++)
          X.torsion[P] = X.pointFromEdwards(this.torsion[P]), X.torsion[P].normalize();
      return X;
    }
    pointFromJSON(r) {
      return y.fromJSON(this, r);
    }
    toJSON(r) {
      const x = super.toJSON(r);
      return x.a = this.a.fromRed().toJSON(), x.d = this.d.fromRed().toJSON(), this.s.isZero() || (x.s = this.s.fromRed().toJSON()), x;
    }
  }
  class y extends n {
    constructor(r, x, O, K, X) {
      I(r instanceof S), super(r, l.EXTENDED), this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = !0, x != null && this._init(x, O, K, X);
    }
    _init(r, x, O, K) {
      I(r instanceof c), I(x instanceof c), I(O == null || O instanceof c), I(K == null || K instanceof c), this.x = r, this.y = x, this.z = O || this.curve.one, this.t = K || null, this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z.eq(this.curve.one), this._check(), this.t || (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redDiv(this.z)));
    }
    _check() {
      if (this.z.isZero())
        throw new Error("Invalid point.");
    }
    clone() {
      return this.curve.point(this.x, this.y, this.z, this.t);
    }
    normalize() {
      if (this.zOne)
        return this;
      const r = this.z.redInvert();
      return this.x = this.x.redMul(r), this.y = this.y.redMul(r), this.t = this.t.redMul(r), this.z = this.curve.one, this.zOne = !0, this;
    }
    scale(r) {
      I(r instanceof c);
      const x = this.x.redMul(r), O = this.y.redMul(r), K = this.z.redMul(r), X = this.t.redMul(r);
      return this.curve.point(x, O, K, X);
    }
    neg() {
      const r = this.x.redNeg(), x = this.y, O = this.z, K = this.t.redNeg();
      return this.curve.point(r, x, O, K);
    }
    add(r) {
      return I(r instanceof y), this.isInfinity() ? r : r.isInfinity() ? this : this.zOne ? r._add(this) : this._add(r);
    }
    _add(r) {
      return this.curve.mOneA ? this._addM1(r) : this._addA(r);
    }
    _addM1(r) {
      const x = this.y.redSub(this.x).redMul(r.y.redSub(r.x)), O = this.y.redAdd(this.x).redMul(r.y.redAdd(r.x)), K = this.t.redMul(this.curve.k).redMul(r.t), X = r.zOne ? this.z.redAdd(this.z) : this.z.redMul(r.z).redIMuln(2), P = O.redSub(x), V = X.redSub(K), re = X.redIAdd(K), ce = O.redIAdd(x), de = P.redMul(V), pe = re.redMul(ce), se = P.redMul(ce), Z = V.redMul(re);
      return this.curve.point(de, pe, Z, se);
    }
    _addA(r) {
      const x = this.x.redMul(r.x), O = this.y.redMul(r.y), K = this.curve._mulD(this.t).redMul(r.t), X = r.zOne ? this.z.clone() : this.z.redMul(r.z), V = this.x.redAdd(this.y).redMul(r.x.redAdd(r.y)).redISub(x).redISub(O), re = X.redSub(K), ce = X.redIAdd(K), de = O.redISub(this.curve._mulA(x)), pe = V.redMul(re), se = ce.redMul(de), Z = V.redMul(de), ee = re.redMul(ce);
      return this.curve.point(pe, se, ee, Z);
    }
    dbl() {
      return this.isInfinity() ? this : this._dbl();
    }
    _dbl() {
      const r = this.x.redSqr(), x = this.y.redSqr(), O = this.zOne ? this.curve.two : this.z.redSqr().redIMuln(2), K = this.curve._mulA(r), X = this.x.redAdd(this.y).redSqr().redISub(r).redISub(x), P = K.redAdd(x), V = P.redSub(O), re = K.redISub(x), ce = X.redMul(V), de = P.redMul(re), pe = X.redMul(re), se = V.redMul(P);
      return this.curve.point(ce, de, se, pe);
    }
    getX() {
      return this.normalize(), this.x.fromRed();
    }
    getY() {
      return this.normalize(), this.y.fromRed();
    }
    eq(r) {
      if (I(r instanceof y), I(!this.z.isZero()), I(!r.z.isZero()), this === r)
        return !0;
      if (this.z.eq(r.z))
        return this.x.eq(r.x) && this.y.eq(r.y);
      const x = this.x.redMul(r.z), O = r.x.redMul(this.z);
      if (!x.eq(O))
        return !1;
      const K = this.y.redMul(r.z), X = r.y.redMul(this.z);
      return K.eq(X);
    }
    cmp(r) {
      return I(r instanceof y), this.order().cmp(r.order()) || this.getY().cmp(r.getY()) || this.getX().cmp(r.getX());
    }
    isInfinity() {
      return I(!this.z.isZero()), this.x.isZero() ? this.y.eq(this.z) : !1;
    }
    isOrder2() {
      return this.isInfinity() ? !1 : this.x.isZero();
    }
    isOdd() {
      return this.normalize(), this.x.redIsOdd();
    }
    isEven() {
      return this.normalize(), this.x.redIsEven();
    }
    toP() {
      return this.normalize();
    }
    toJ() {
      return this;
    }
    encode() {
      const r = this.getY();
      return r.setn(this.curve.signBit, this.x.redIsOdd()), this.curve.encodeAdjusted(r);
    }
    static decode(r, x) {
      I(r instanceof S);
      const O = r.decodeAdjusted(x), K = O.testn(r.signBit) !== 0;
      if (O.setn(r.signBit, 0), O.cmp(r.p) >= 0)
        throw new Error("Invalid point.");
      return r.pointFromY(O, K);
    }
    toJSON(r) {
      if (this.isInfinity())
        return [];
      const x = this.getX().toJSON(), O = this.getY().toJSON();
      return r === !0 && this.pre ? [x, O, this.pre.toJSON()] : [x, O];
    }
    toPretty() {
      const r = this.curve.fieldSize * 2, x = M(this.getX(), r), O = M(this.getY(), r);
      return [x, O];
    }
    static fromJSON(r, x) {
      if (I(r instanceof S), I(Array.isArray(x)), I(x.length === 0 || x.length === 2 || x.length === 3), x.length === 0)
        return r.point();
      const O = c.fromJSON(x[0]), K = c.fromJSON(x[1]), X = r.point(O, K);
      return x.length > 2 && x[2] != null && (X.pre = b.fromJSON(X, x[2])), X;
    }
    [e]() {
      return this.isInfinity() ? "<EdwardsPoint: Infinity>" : "<EdwardsPoint: x=" + this.x.fromRed().toString(16, 2) + " y=" + this.y.fromRed().toString(16, 2) + " z=" + this.z.fromRed().toString(16, 2) + ">";
    }
  }
  class b {
    constructor() {
      this.naf = null, this.windows = null, this.doubles = null, this.blinding = null, this.beta = null;
    }
    map(r) {
      I(typeof r == "function");
      const x = new this.constructor();
      return this.naf && (x.naf = this.naf.map(r)), this.doubles && (x.doubles = this.doubles.map(r)), x;
    }
    toJSON() {
      return {
        naf: this.naf ? this.naf.toJSON() : null,
        windows: this.windows ? this.windows.toJSON() : null,
        doubles: this.doubles ? this.doubles.toJSON() : null,
        blinding: this.blinding ? this.blinding.toJSON() : void 0
      };
    }
    fromJSON(r, x) {
      return I(r instanceof n), I(x && typeof x == "object"), x.naf != null && (this.naf = h.fromJSON(r, x.naf)), x.windows != null && (this.windows = a.fromJSON(r, x.windows)), x.doubles != null && (this.doubles = E.fromJSON(r, x.doubles)), x.blinding != null && (this.blinding = H.fromJSON(r, x.blinding)), this;
    }
    static fromJSON(r, x) {
      return new this().fromJSON(r, x);
    }
  }
  class h {
    constructor(r, x) {
      this.width = r, this.points = x;
    }
    map(r) {
      I(typeof r == "function");
      const { width: x } = this, O = [];
      for (const K of this.points)
        O.push(r(K));
      return new this.constructor(x, O);
    }
    toJSON() {
      return {
        width: this.width,
        points: this.points.slice(1).map((r) => r.toJSON())
      };
    }
    static fromJSON(r, x) {
      I(r instanceof n), I(x && typeof x == "object"), I(x.width >>> 0 === x.width), I(Array.isArray(x.points));
      const { curve: O } = r, { width: K } = x, X = [r];
      for (const P of x.points)
        X.push(O.pointFromJSON(P));
      return new this(K, X);
    }
  }
  class a {
    constructor(r, x, O) {
      this.width = r, this.bits = x, this.points = O;
    }
    toJSON() {
      return {
        width: this.width,
        bits: this.bits,
        points: this.points.slice(1).map((r) => r.toJSON())
      };
    }
    static fromJSON(r, x) {
      I(r instanceof n), I(x && typeof x == "object"), I(x.width >>> 0 === x.width), I(x.bits >>> 0 === x.bits), I(Array.isArray(x.points));
      const { curve: O } = r, { width: K, bits: X } = x, P = [r];
      for (const V of x.points)
        P.push(O.pointFromJSON(V));
      return new this(K, X, P);
    }
  }
  class E {
    constructor(r, x) {
      this.step = r, this.points = x;
    }
    map(r) {
      I(typeof r == "function");
      const { step: x } = this, O = [];
      for (const K of this.points)
        O.push(r(K));
      return new this.constructor(x, O);
    }
    toJSON() {
      return {
        step: this.step,
        points: this.points.slice(1).map((r) => r.toJSON())
      };
    }
    static fromJSON(r, x) {
      I(r instanceof n), I(x && typeof x == "object"), I(x.step >>> 0 === x.step), I(Array.isArray(x.points));
      const { curve: O } = r, { step: K } = x, X = [r];
      for (const P of x.points)
        X.push(O.pointFromJSON(P));
      return new this(K, X);
    }
  }
  class H {
    constructor(r, x) {
      this.blind = r, this.unblind = x;
    }
    toJSON() {
      return {
        blind: this.blind.toJSON(),
        unblind: this.unblind.toJSON()
      };
    }
    static fromJSON(r, x) {
      I(r instanceof n), I(x && typeof x == "object");
      const { curve: O } = r, K = c.fromJSON(x.blind), X = O.pointFromJSON(x.unblind);
      return new this(K, X);
    }
  }
  class j {
    constructor(r, x, O, K) {
      this.beta = r, this.lambda = x, this.basis = O, this.pre = K;
    }
    toJSON() {
      return {
        beta: this.beta.fromRed().toJSON(),
        lambda: this.lambda.toJSON(),
        basis: [
          this.basis[0].toJSON(),
          this.basis[1].toJSON()
        ],
        pre: [
          this.pre[0],
          this.pre[1].toJSON(),
          this.pre[2].toJSON()
        ]
      };
    }
    static fromJSON(r, x) {
      I(r instanceof f), I(x && typeof x == "object"), I(Array.isArray(x.basis)), I(Array.isArray(x.pre)), I(x.basis.length === 2), I(x.pre.length === 3), I(x.pre[0] >>> 0 === x.pre[0]);
      const O = c.fromJSON(x.beta).toRed(r.red), K = c.fromJSON(x.lambda), X = [
        G.fromJSON(x.basis[0]),
        G.fromJSON(x.basis[1])
      ], P = [
        x.pre[0],
        c.fromJSON(x.pre[1]),
        c.fromJSON(x.pre[2])
      ];
      return new this(O, K, X, P);
    }
  }
  class G {
    constructor(r, x) {
      this.a = r, this.b = x;
    }
    toJSON() {
      return {
        a: this.a.toJSON(),
        b: this.b.toJSON()
      };
    }
    static fromJSON(r) {
      I(r && typeof r == "object");
      const x = c.fromJSON(r.a), O = c.fromJSON(r.b);
      return new this(x, O);
    }
  }
  class N extends u {
    constructor(r) {
      super({
        id: "P192",
        ossl: "prime192v1",
        type: "short",
        endian: "be",
        hash: "SHA256",
        prime: "p192",
        // 2^192 - 2^64 - 1 (= 3 mod 4)
        p: [
          "ffffffff ffffffff ffffffff fffffffe",
          "ffffffff ffffffff"
        ],
        // -3 mod p
        a: [
          "ffffffff ffffffff ffffffff fffffffe",
          "ffffffff fffffffc"
        ],
        b: [
          "64210519 e59c80e7 0fa7e9ab 72243049",
          "feb8deec c146b9b1"
        ],
        n: [
          "ffffffff ffffffff ffffffff 99def836",
          "146bc9b1 b4d22831"
        ],
        h: "1",
        // Icart
        z: "-5",
        g: [
          [
            "188da80e b03090f6 7cbf20eb 43a18800",
            "f4ff0afd 82ff1012"
          ],
          [
            "07192b95 ffc8da78 631011ed 6b24cdd5",
            "73f977a1 1e794811"
          ],
          r
        ]
      });
    }
  }
  class T extends u {
    constructor(r) {
      super({
        id: "P224",
        ossl: "secp224r1",
        type: "short",
        endian: "be",
        hash: "SHA256",
        prime: "p224",
        // 2^224 - 2^96 + 1 (1 mod 16)
        p: [
          "ffffffff ffffffff ffffffff ffffffff",
          "00000000 00000000 00000001"
        ],
        // -3 mod p
        a: [
          "ffffffff ffffffff ffffffff fffffffe",
          "ffffffff ffffffff fffffffe"
        ],
        b: [
          "b4050a85 0c04b3ab f5413256 5044b0b7",
          "d7bfd8ba 270b3943 2355ffb4"
        ],
        n: [
          "ffffffff ffffffff ffffffff ffff16a2",
          "e0b8f03e 13dd2945 5c5c2a3d"
        ],
        h: "1",
        // SSWU
        z: "1f",
        g: [
          [
            "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3",
            "56c21122 343280d6 115c1d21"
          ],
          [
            "bd376388 b5f723fb 4c22dfe6 cd4375a0",
            "5a074764 44d58199 85007e34"
          ],
          r
        ]
      });
    }
  }
  class A extends u {
    constructor(r) {
      super({
        id: "P256",
        ossl: "prime256v1",
        type: "short",
        endian: "be",
        hash: "SHA256",
        prime: null,
        // 2^256 - 2^224 + 2^192 + 2^96 - 1 (= 3 mod 4)
        p: [
          "ffffffff 00000001 00000000 00000000",
          "00000000 ffffffff ffffffff ffffffff"
        ],
        // -3 mod p
        a: [
          "ffffffff 00000001 00000000 00000000",
          "00000000 ffffffff ffffffff fffffffc"
        ],
        b: [
          "5ac635d8 aa3a93e7 b3ebbd55 769886bc",
          "651d06b0 cc53b0f6 3bce3c3e 27d2604b"
        ],
        n: [
          "ffffffff 00000000 ffffffff ffffffff",
          "bce6faad a7179e84 f3b9cac2 fc632551"
        ],
        h: "1",
        // SSWU
        z: "-a",
        g: [
          [
            "6b17d1f2 e12c4247 f8bce6e5 63a440f2",
            "77037d81 2deb33a0 f4a13945 d898c296"
          ],
          [
            "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16",
            "2bce3357 6b315ece cbb64068 37bf51f5"
          ],
          r
        ]
      });
    }
  }
  class q extends u {
    constructor(r) {
      super({
        id: "P384",
        ossl: "secp384r1",
        type: "short",
        endian: "be",
        hash: "SHA384",
        prime: null,
        // 2^384 - 2^128 - 2^96 + 2^32 - 1 (= 3 mod 4)
        p: [
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff ffffffff fffffffe",
          "ffffffff 00000000 00000000 ffffffff"
        ],
        // -3 mod p
        a: [
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff ffffffff fffffffe",
          "ffffffff 00000000 00000000 fffffffc"
        ],
        b: [
          "b3312fa7 e23ee7e4 988e056b e3f82d19",
          "181d9c6e fe814112 0314088f 5013875a",
          "c656398d 8a2ed19d 2a85c8ed d3ec2aef"
        ],
        n: [
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff c7634d81 f4372ddf",
          "581a0db2 48b0a77a ecec196a ccc52973"
        ],
        h: "1",
        // Icart
        z: "-c",
        g: [
          [
            "aa87ca22 be8b0537 8eb1c71e f320ad74",
            "6e1d3b62 8ba79b98 59f741e0 82542a38",
            "5502f25d bf55296c 3a545e38 72760ab7"
          ],
          [
            "3617de4a 96262c6f 5d9e98bf 9292dc29",
            "f8f41dbd 289a147c e9da3113 b5f0b8c0",
            "0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
          ],
          r
        ]
      });
    }
  }
  class _ extends u {
    constructor(r) {
      super({
        id: "P521",
        ossl: "secp521r1",
        type: "short",
        endian: "be",
        hash: "SHA512",
        prime: "p521",
        // 2^521 - 1 (= 3 mod 4)
        p: [
          "000001ff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff"
        ],
        // -3 mod p
        a: [
          "000001ff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff ffffffff ffffffff",
          "fffffffc"
        ],
        b: [
          "00000051 953eb961 8e1c9a1f 929a21a0",
          "b68540ee a2da725b 99b315f3 b8b48991",
          "8ef109e1 56193951 ec7e937b 1652c0bd",
          "3bb1bf07 3573df88 3d2c34f1 ef451fd4",
          "6b503f00"
        ],
        n: [
          "000001ff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff ffffffff ffffffff",
          "fffffffa 51868783 bf2f966b 7fcc0148",
          "f709a5d0 3bb5c9b8 899c47ae bb6fb71e",
          "91386409"
        ],
        h: "1",
        // SSWU
        z: "-4",
        g: [
          [
            "000000c6 858e06b7 0404e9cd 9e3ecb66",
            "2395b442 9c648139 053fb521 f828af60",
            "6b4d3dba a14b5e77 efe75928 fe1dc127",
            "a2ffa8de 3348b3c1 856a429b f97e7e31",
            "c2e5bd66"
          ],
          [
            "00000118 39296a78 9a3bc004 5c8a5fb4",
            "2c7d1bd9 98f54449 579b4468 17afbd17",
            "273e662c 97ee7299 5ef42640 c550b901",
            "3fad0761 353c7086 a272c240 88be9476",
            "9fd16650"
          ],
          r
        ]
      });
    }
  }
  class F extends u {
    constructor(r) {
      super({
        id: "SECP256K1",
        ossl: "secp256k1",
        type: "short",
        endian: "be",
        hash: "SHA256",
        prime: "k256",
        // 2^256 - 2^32 - 977 (= 3 mod 4)
        p: [
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff fffffffe fffffc2f"
        ],
        a: "0",
        b: "7",
        n: [
          "ffffffff ffffffff ffffffff fffffffe",
          "baaedce6 af48a03b bfd25e8c d0364141"
        ],
        h: "1",
        // SVDW
        z: "1",
        // sqrt(-3)
        c: [
          "0a2d2ba9 3507f1df 233770c2 a797962c",
          "c61f6d15 da14ecd4 7d8d27ae 1cd5f852"
        ],
        g: [
          [
            "79be667e f9dcbbac 55a06295 ce870b07",
            "029bfcdb 2dce28d9 59f2815b 16f81798"
          ],
          [
            "483ada77 26a3c465 5da4fbfc 0e1108a8",
            "fd17b448 a6855419 9c47d08f fb10d4b8"
          ],
          r
        ],
        // Precomputed endomorphism.
        endo: {
          beta: [
            "7ae96a2b 657c0710 6e64479e ac3434e9",
            "9cf04975 12f58995 c1396c28 719501ee"
          ],
          lambda: [
            "5363ad4c c05c30e0 a5261c02 8812645a",
            "122e22ea 20816678 df02967c 1b23bd72"
          ],
          basis: [
            {
              a: "3086d221a7d46bcde86c90e49284eb15",
              b: "-e4437ed6010e88286f547fa90abfe4c3"
            },
            {
              a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
              b: "3086d221a7d46bcde86c90e49284eb15"
            }
          ],
          pre: [
            384,
            [
              "3086d221 a7d46bcd e86c90e4 9284eb15",
              "3daa8a14 71e8ca7f e893209a 45dbb031"
            ],
            [
              "-",
              "e4437ed6 010e8828 6f547fa9 0abfe4c4",
              "221208ac 9df506c6 1571b4ae 8ac47f71"
            ]
          ]
        }
      });
    }
  }
  class R extends u {
    constructor(r) {
      super({
        id: "BRAINPOOLP256",
        ossl: "brainpoolP256r1",
        type: "short",
        endian: "be",
        hash: "SHA256",
        prime: null,
        // (= 3 mod 4)
        p: [
          "a9fb57db a1eea9bc 3e660a90 9d838d72",
          "6e3bf623 d5262028 2013481d 1f6e5377"
        ],
        a: [
          "7d5a0975 fc2c3057 eef67530 417affe7",
          "fb8055c1 26dc5c6c e94a4b44 f330b5d9"
        ],
        b: [
          "26dc5c6c e94a4b44 f330b5d9 bbd77cbf",
          "95841629 5cf7e1ce 6bccdc18 ff8c07b6"
        ],
        n: [
          "a9fb57db a1eea9bc 3e660a90 9d838d71",
          "8c397aa3 b561a6f7 901e0e82 974856a7"
        ],
        h: "1",
        // Icart
        z: "-2",
        g: [
          [
            "8bd2aeb9 cb7e57cb 2c4b482f fc81b7af",
            "b9de27e1 e3bd23c2 3a4453bd 9ace3262"
          ],
          [
            "547ef835 c3dac4fd 97f8461a 14611dc9",
            "c2774513 2ded8e54 5c1d54c7 2f046997"
          ],
          r
        ]
      });
    }
  }
  class L extends u {
    constructor(r) {
      super({
        id: "BRAINPOOLP384",
        ossl: "brainpoolP384r1",
        type: "short",
        endian: "be",
        hash: "SHA384",
        prime: null,
        // (= 3 mod 4)
        p: [
          "8cb91e82 a3386d28 0f5d6f7e 50e641df",
          "152f7109 ed5456b4 12b1da19 7fb71123",
          "acd3a729 901d1a71 87470013 3107ec53"
        ],
        a: [
          "7bc382c6 3d8c150c 3c72080a ce05afa0",
          "c2bea28e 4fb22787 139165ef ba91f90f",
          "8aa5814a 503ad4eb 04a8c7dd 22ce2826"
        ],
        b: [
          "04a8c7dd 22ce2826 8b39b554 16f0447c",
          "2fb77de1 07dcd2a6 2e880ea5 3eeb62d5",
          "7cb43902 95dbc994 3ab78696 fa504c11"
        ],
        n: [
          "8cb91e82 a3386d28 0f5d6f7e 50e641df",
          "152f7109 ed5456b3 1f166e6c ac0425a7",
          "cf3ab6af 6b7fc310 3b883202 e9046565"
        ],
        h: "1",
        // SSWU
        z: "-5",
        g: [
          [
            "1d1c64f0 68cf45ff a2a63a81 b7c13f6b",
            "8847a3e7 7ef14fe3 db7fcafe 0cbd10e8",
            "e826e034 36d646aa ef87b2e2 47d4af1e"
          ],
          [
            "8abe1d75 20f9c2a4 5cb1eb8e 95cfd552",
            "62b70b29 feec5864 e19c054f f9912928",
            "0e464621 77918111 42820341 263c5315"
          ],
          r
        ]
      });
    }
  }
  class fe extends u {
    constructor(r) {
      super({
        id: "BRAINPOOLP512",
        ossl: "brainpoolP512r1",
        type: "short",
        endian: "be",
        hash: "SHA512",
        prime: null,
        // (= 3 mod 4)
        p: [
          "aadd9db8 dbe9c48b 3fd4e6ae 33c9fc07",
          "cb308db3 b3c9d20e d6639cca 70330871",
          "7d4d9b00 9bc66842 aecda12a e6a380e6",
          "2881ff2f 2d82c685 28aa6056 583a48f3"
        ],
        a: [
          "7830a331 8b603b89 e2327145 ac234cc5",
          "94cbdd8d 3df91610 a83441ca ea9863bc",
          "2ded5d5a a8253aa1 0a2ef1c9 8b9ac8b5",
          "7f1117a7 2bf2c7b9 e7c1ac4d 77fc94ca"
        ],
        b: [
          "3df91610 a83441ca ea9863bc 2ded5d5a",
          "a8253aa1 0a2ef1c9 8b9ac8b5 7f1117a7",
          "2bf2c7b9 e7c1ac4d 77fc94ca dc083e67",
          "984050b7 5ebae5dd 2809bd63 8016f723"
        ],
        n: [
          "aadd9db8 dbe9c48b 3fd4e6ae 33c9fc07",
          "cb308db3 b3c9d20e d6639cca 70330870",
          "553e5c41 4ca92619 41866119 7fac1047",
          "1db1d381 085ddadd b5879682 9ca90069"
        ],
        h: "1",
        // Icart
        z: "7",
        g: [
          [
            "81aee4bd d82ed964 5a21322e 9c4c6a93",
            "85ed9f70 b5d916c1 b43b62ee f4d0098e",
            "ff3b1f78 e2d0d48d 50d1687b 93b97d5f",
            "7c6d5047 406a5e68 8b352209 bcb9f822"
          ],
          [
            "7dde385d 566332ec c0eabfa9 cf7822fd",
            "f209f700 24a57b1a a000c55b 881f8111",
            "b2dcde49 4a5f485e 5bca4bd8 8a2763ae",
            "d1ca2b2f a8f05406 78cd1e0f 3ad80892"
          ],
          r
        ]
      });
    }
  }
  class ue extends i {
    constructor() {
      super({
        id: "X25519",
        ossl: "X25519",
        type: "mont",
        endian: "le",
        hash: "SHA512",
        prime: "p25519",
        // 2^255 - 19 (= 5 mod 8)
        p: [
          "7fffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff ffffffff ffffffed"
        ],
        // 486662
        a: "76d06",
        b: "1",
        n: [
          "10000000 00000000 00000000 00000000",
          "14def9de a2f79cd6 5812631a 5cf5d3ed"
        ],
        h: "8",
        // Elligator 2
        z: "2",
        g: [
          [
            "00000000 00000000 00000000 00000000",
            "00000000 00000000 00000000 00000009"
          ],
          // See: https://www.rfc-editor.org/errata/eid4730
          [
            "5f51e65e 475f794b 1fe122d3 88b72eb3",
            "6dc2b281 92839e4d d6163a5d 81312c14"
          ]
        ],
        torsion: [
          [],
          [
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000"
            ],
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000"
            ]
          ],
          [
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000001"
            ],
            [
              "6be4f497 f9a9c2af c21fa77a d7f4a6ef",
              "635a11c7 284a9363 e9a248ef 9c884415"
            ]
          ],
          [
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000001"
            ],
            [
              "141b0b68 06563d50 3de05885 280b5910",
              "9ca5ee38 d7b56c9c 165db710 6377bbd8"
            ]
          ],
          [
            [
              "57119fd0 dd4e22d8 868e1c58 c45c4404",
              "5bef839c 55b1d0b1 248c50a3 bc959c5f"
            ],
            [
              "68c59389 3d458e64 31c6ca00 45fb5015",
              "20a44346 8eaa68dd 0f103842 048065b7"
            ]
          ],
          [
            [
              "57119fd0 dd4e22d8 868e1c58 c45c4404",
              "5bef839c 55b1d0b1 248c50a3 bc959c5f"
            ],
            [
              "173a6c76 c2ba719b ce3935ff ba04afea",
              "df5bbcb9 71559722 f0efc7bd fb7f9a36"
            ]
          ],
          [
            [
              "00b8495f 16056286 fdb1329c eb8d09da",
              "6ac49ff1 fae35616 aeb8413b 7c7aebe0"
            ],
            [
              "3931c129 569e83a5 29482c14 e628b457",
              "933bfc29 ed801b4d 68871483 92507b1a"
            ]
          ],
          [
            [
              "00b8495f 16056286 fdb1329c eb8d09da",
              "6ac49ff1 fae35616 aeb8413b 7c7aebe0"
            ],
            [
              "46ce3ed6 a9617c5a d6b7d3eb 19d74ba8",
              "6cc403d6 127fe4b2 9778eb7c 6daf84d3"
            ]
          ]
        ]
      });
    }
  }
  class ae extends i {
    constructor() {
      super({
        id: "X448",
        ossl: "X448",
        type: "mont",
        endian: "le",
        hash: "SHAKE256",
        prime: "p448",
        // 2^448 - 2^224 - 1 (= 3 mod 4)
        p: [
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff fffffffe ffffffff",
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff"
        ],
        // 156326
        a: "262a6",
        b: "1",
        n: [
          "3fffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff ffffffff 7cca23e9",
          "c44edb49 aed63690 216cc272 8dc58f55",
          "2378c292 ab5844f3"
        ],
        h: "4",
        // Elligator 2
        z: "-1",
        g: [
          [
            "00000000 00000000 00000000 00000000",
            "00000000 00000000 00000000 00000000",
            "00000000 00000000 00000000 00000000",
            "00000000 00000005"
          ],
          [
            "7d235d12 95f5b1f6 6c98ab6e 58326fce",
            "cbae5d34 f55545d0 60f75dc2 8df3f6ed",
            "b8027e23 46430d21 1312c4b1 50677af7",
            "6fd7223d 457b5b1a"
          ]
        ],
        torsion: [
          [],
          [
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000"
            ],
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000"
            ]
          ],
          [
            [
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff ffffffff fffffffe ffffffff",
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff fffffffe"
            ],
            [
              "ba4d3a08 29b6112f 8812e51b a0bb2abe",
              "bc1cb08e b48e5569 36ba50fd d2e7d68a",
              "f8cb3216 0522425b 3f990812 abbe635a",
              "d37a21e1 7551b193"
            ]
          ],
          [
            [
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff ffffffff fffffffe ffffffff",
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff fffffffe"
            ],
            [
              "45b2c5f7 d649eed0 77ed1ae4 5f44d541",
              "43e34f71 4b71aa96 c945af01 2d182975",
              "0734cde9 faddbda4 c066f7ed 54419ca5",
              "2c85de1e 8aae4e6c"
            ]
          ]
        ]
      });
    }
  }
  class D extends i {
    constructor() {
      super({
        id: "MONT448",
        ossl: null,
        type: "mont",
        endian: "le",
        hash: "SHAKE256",
        prime: "p448",
        // 2^448 - 2^224 - 1 (= 3 mod 4)
        p: [
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff fffffffe ffffffff",
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff"
        ],
        // -78160 / -39082 mod p
        a: [
          "b2cf97d2 d43459a9 31ed36b1 fc4e3cb5",
          "5d93f8d2 22746997 60ccffc6 49961ed6",
          "c5b05fca c24864ed 6fb59697 931b78da",
          "84ddecd8 ca2b5cfb"
        ],
        b: "1",
        n: [
          "3fffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff ffffffff 7cca23e9",
          "c44edb49 aed63690 216cc272 8dc58f55",
          "2378c292 ab5844f3"
        ],
        h: "4",
        // Elligator 2
        z: "-1",
        g: [
          [
            "ac0d24cc c6c75cb0 eb71f81e 7a6edf51",
            "48e88aee 009a2a24 e795687e c28e125a",
            "3e6730a6 0d46367b aa7fe99d 152128dc",
            "41321bc7 7817f059"
          ],
          [
            "5a4437f6 80c0d0db 9b061276 d5d0ffcc",
            "e786ff33 b6a53d30 98746425 82e66f09",
            "4433dae7 7244a6e2 6b11e905 7228f483",
            "556c41a5 913f55fe"
          ]
        ],
        torsion: [
          [],
          [
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000"
            ],
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000"
            ]
          ],
          [
            [
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff ffffffff fffffffe ffffffff",
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff fffffffe"
            ],
            [
              "bec92fd0 6da2acf2 b4e261e8 7cef0d34",
              "22e75c18 3c589857 b71924e5 73c2f9ce",
              "e18da5f2 466e2f39 3c2eedf0 f105a60a",
              "b40c717d 4f1e1fd7"
            ]
          ],
          [
            [
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff ffffffff fffffffe ffffffff",
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff fffffffe"
            ],
            [
              "4136d02f 925d530d 4b1d9e17 8310f2cb",
              "dd18a3e7 c3a767a8 48e6db19 8c3d0631",
              "1e725a0d b991d0c6 c3d1120f 0efa59f5",
              "4bf38e82 b0e1e028"
            ]
          ]
        ]
      });
    }
  }
  class Q extends S {
    constructor(r) {
      super({
        id: "ED25519",
        ossl: "ED25519",
        type: "edwards",
        endian: "le",
        hash: "SHA512",
        prefix: "SigEd25519 no Ed25519 collisions",
        context: !1,
        prime: "p25519",
        // 2^255 - 19 (= 5 mod 8)
        p: [
          "7fffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff ffffffff ffffffed"
        ],
        a: "-1",
        // -121665 / 121666 mod p
        d: [
          "52036cee 2b6ffe73 8cc74079 7779e898",
          "00700a4d 4141d8ab 75eb4dca 135978a3"
        ],
        n: [
          "10000000 00000000 00000000 00000000",
          "14def9de a2f79cd6 5812631a 5cf5d3ed"
        ],
        h: "8",
        // Elligator 2
        z: "2",
        g: [
          [
            "216936d3 cd6e53fe c0a4e231 fdd6dc5c",
            "692cc760 9525a7b2 c9562d60 8f25d51a"
          ],
          // 4/5
          [
            "66666666 66666666 66666666 66666666",
            "66666666 66666666 66666666 66666658"
          ],
          r
        ],
        torsion: [
          [
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000"
            ],
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000001"
            ]
          ],
          [
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000"
            ],
            [
              "7fffffff ffffffff ffffffff ffffffff",
              "ffffffff ffffffff ffffffff ffffffec"
            ]
          ],
          [
            [
              "2b832480 4fc1df0b 2b4d0099 3dfbd7a7",
              "2f431806 ad2fe478 c4ee1b27 4a0ea0b0"
            ],
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000"
            ]
          ],
          [
            [
              "547cdb7f b03e20f4 d4b2ff66 c2042858",
              "d0bce7f9 52d01b87 3b11e4d8 b5f15f3d"
            ],
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000"
            ]
          ],
          [
            [
              "1fd5b9a0 06394a28 e9339932 38de4abb",
              "5c193c70 13e5e238 dea14646 c545d14a"
            ],
            [
              "05fc536d 880238b1 3933c6d3 05acdfd5",
              "f098eff2 89f4c345 b027b2c2 8f95e826"
            ]
          ],
          [
            [
              "602a465f f9c6b5d7 16cc66cd c721b544",
              "a3e6c38f ec1a1dc7 215eb9b9 3aba2ea3"
            ],
            [
              "05fc536d 880238b1 3933c6d3 05acdfd5",
              "f098eff2 89f4c345 b027b2c2 8f95e826"
            ]
          ],
          [
            [
              "1fd5b9a0 06394a28 e9339932 38de4abb",
              "5c193c70 13e5e238 dea14646 c545d14a"
            ],
            [
              "7a03ac92 77fdc74e c6cc392c fa53202a",
              "0f67100d 760b3cba 4fd84d3d 706a17c7"
            ]
          ],
          [
            [
              "602a465f f9c6b5d7 16cc66cd c721b544",
              "a3e6c38f ec1a1dc7 215eb9b9 3aba2ea3"
            ],
            [
              "7a03ac92 77fdc74e c6cc392c fa53202a",
              "0f67100d 760b3cba 4fd84d3d 706a17c7"
            ]
          ]
        ]
      });
    }
  }
  class W extends S {
    constructor(r) {
      super({
        id: "ISO448",
        ossl: null,
        type: "edwards",
        endian: "le",
        hash: "SHAKE256",
        prefix: "SigEd448",
        context: !0,
        prime: "p448",
        // 2^448 - 2^224 - 1 (= 3 mod 4)
        p: [
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff fffffffe ffffffff",
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff"
        ],
        a: "1",
        // 39082 / 39081 mod p
        d: [
          "d78b4bdc 7f0daf19 f24f38c2 9373a2cc",
          "ad461572 42a50f37 809b1da3 412a12e7",
          "9ccc9c81 264cfe9a d0809970 58fb61c4",
          "243cc32d baa156b9"
        ],
        n: [
          "3fffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff ffffffff 7cca23e9",
          "c44edb49 aed63690 216cc272 8dc58f55",
          "2378c292 ab5844f3"
        ],
        h: "4",
        // Elligator 2
        z: "-1",
        g: [
          [
            "79a70b2b 70400553 ae7c9df4 16c792c6",
            "1128751a c9296924 0c25a07d 728bdc93",
            "e21f7787 ed697224 9de732f3 8496cd11",
            "69871309 3e9c04fc"
          ],
          // Note: the RFC has this wrong.
          [
            "7fffffff ffffffff ffffffff ffffffff",
            "ffffffff ffffffff ffffffff 80000000",
            "00000000 00000000 00000000 00000000",
            "00000000 00000001"
          ],
          r
        ],
        torsion: [
          [
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000"
            ],
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000001"
            ]
          ],
          [
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000"
            ],
            [
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff ffffffff fffffffe ffffffff",
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff fffffffe"
            ]
          ],
          [
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000001"
            ],
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000"
            ]
          ],
          [
            [
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff ffffffff fffffffe ffffffff",
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff fffffffe"
            ],
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000"
            ]
          ]
        ]
      });
    }
  }
  class oe extends S {
    constructor(r) {
      super({
        id: "ED448",
        ossl: "ED448",
        type: "edwards",
        endian: "le",
        hash: "SHAKE256",
        prefix: "SigEd448",
        context: !0,
        prime: "p448",
        // 2^448 - 2^224 - 1 (= 3 mod 4)
        p: [
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff fffffffe ffffffff",
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff"
        ],
        a: "1",
        // -39081 mod p
        d: [
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff fffffffe ffffffff",
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffff6756"
        ],
        n: [
          "3fffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff ffffffff 7cca23e9",
          "c44edb49 aed63690 216cc272 8dc58f55",
          "2378c292 ab5844f3"
        ],
        h: "4",
        // Elligator 2
        z: "-1",
        g: [
          [
            "4f1970c6 6bed0ded 221d15a6 22bf36da",
            "9e146570 470f1767 ea6de324 a3d3a464",
            "12ae1af7 2ab66511 433b80e1 8b00938e",
            "2626a82b c70cc05e"
          ],
          [
            "693f4671 6eb6bc24 88762037 56c9c762",
            "4bea7373 6ca39840 87789c1e 05a0c2d7",
            "3ad3ff1c e67c39c4 fdbd132c 4ed7c8ad",
            "9808795b f230fa14"
          ],
          r
        ],
        torsion: [
          [
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000"
            ],
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000001"
            ]
          ],
          [
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000"
            ],
            [
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff ffffffff fffffffe ffffffff",
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff fffffffe"
            ]
          ],
          [
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000001"
            ],
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000"
            ]
          ],
          [
            [
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff ffffffff fffffffe ffffffff",
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff fffffffe"
            ],
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000"
            ]
          ]
        ]
      });
    }
  }
  const v = {
    __proto__: null,
    P192: N,
    P224: T,
    P256: A,
    P384: q,
    P521: _,
    SECP256K1: F,
    BRAINPOOLP256: R,
    BRAINPOOLP384: L,
    BRAINPOOLP512: fe,
    X25519: ue,
    X448: ae,
    MONT448: D,
    ED25519: Q,
    ISO448: W,
    ED448: oe
  }, Y = {
    __proto__: null,
    P192: null,
    P224: null,
    P256: null,
    P384: null,
    P521: null,
    SECP256K1: null,
    BRAINPOOLP256: null,
    BRAINPOOLP384: null,
    BRAINPOOLP512: null,
    X25519: null,
    X448: null,
    MONT448: null,
    ED25519: null,
    ISO448: null,
    ED448: null
  };
  function he($, ...r) {
    I(typeof $ == "string");
    const x = $.toUpperCase();
    let O = Y[x];
    if (!O) {
      const K = v[x];
      if (!K)
        throw new Error(`Curve not found: "${$}".`);
      O = new K(...r), Y[x] = O;
    }
    return O;
  }
  function le($, r) {
    I(typeof $ == "string"), I(typeof r == "function");
    const x = $.toUpperCase();
    if (v[x])
      throw new Error(`Curve already registered: "${$}".`);
    v[x] = r, Y[x] = null;
  }
  function ge($, r, x) {
    I($ instanceof c), I(!$.red), I(r >>> 0 === r), I(x >>> 0 === x);
    const O = new Array(x), K = $.bitLength() + 1, X = $.sign() | 1;
    I(K <= x);
    for (let ce = 0; ce < x; ce++)
      O[ce] = 0;
    let P = 0, V = 0, re;
    for (; P < K; ) {
      if ($.bit(P) === V) {
        P += 1;
        continue;
      }
      re = $.bits(P, r) + V, V = re >> r - 1 & 1, re -= V << r, O[P] = X * re, P += r;
    }
    return I(V === 0), O;
  }
  function Ee($, r, x, O) {
    I(O >>> 0 === O);
    const K = ge($, r, x), X = Math.ceil(K.length / O), P = new Array(X);
    let V = 0;
    for (let re = 0; re < K.length; re += O) {
      let ce = 0;
      for (let de = re + O - 1; de >= re; de--)
        ce = (ce << 1) + K[de];
      P[V++] = ce;
    }
    return I(V === X), P;
  }
  function we($, r, x) {
    I($ instanceof c), I(r instanceof c), I(!$.red), I(!r.red), I(x >>> 0 === x);
    const O = [new Array(x), new Array(x)], K = Math.max($.bitLength(), r.bitLength()) + 1, X = $.sign() | 1, P = r.sign() | 1;
    I(K <= x);
    let V = 0, re = 0;
    for (let ce = 0; ce < K; ce++) {
      const de = $.bits(ce, 3), pe = r.bits(ce, 3);
      let se = (de & 3) + V & 3, Z = (pe & 3) + re & 3, ee = 0, me = 0;
      if (se === 3 && (se = -1), Z === 3 && (Z = -1), se & 1) {
        const Ae = (de & 7) + V & 7;
        (Ae === 3 || Ae === 5) && Z === 2 ? ee = -se : ee = se;
      }
      if (Z & 1) {
        const Ae = (pe & 7) + re & 7;
        (Ae === 3 || Ae === 5) && se === 2 ? me = -Z : me = Z;
      }
      O[0][ce] = ee * X, O[1][ce] = me * P, 2 * V === 1 + ee && (V = 1 - V), 2 * re === 1 + me && (re = 1 - re);
    }
    for (let ce = K; ce < x; ce++)
      O[0][ce] = 0, O[1][ce] = 0;
    return O;
  }
  function z($, r, x) {
    const O = we($, r, x), K = new Array(x);
    for (let X = 0; X < x; X++) {
      const P = O[0][X], V = O[1][X];
      K[X] = w[(P + 1) * 3 + (V + 1)];
    }
    return K;
  }
  function I($, r) {
    if (!$) {
      const x = new Error(r || "Assertion failed");
      throw Error.captureStackTrace && Error.captureStackTrace(x, I), x;
    }
  }
  function ne($) {
    I(typeof $ == "function");
    try {
      return $();
    } catch (r) {
      throw r.message === "X is not a square mod P." || r.message === "Not invertible." ? new Error("Invalid point.") : r;
    }
  }
  function t($, r) {
    let x = $ % r;
    return x < 0 && (x += r), x;
  }
  function d($) {
    I($ instanceof c), I($.red);
    const r = $.red.m;
    if (r.cmpn(3) <= 0)
      return $.clone();
    if (r.modrn(3) === 2) {
      const O = r.ushln(1).isubn(1).idivn(3);
      return $.redPow(O);
    }
    const x = r.modrn(9);
    if (x === 4) {
      const O = r.ushln(1).iaddn(1).idivn(9), K = $.redPow(O);
      if (!K.redSqr().redMul(K).eq($))
        throw new Error("X is not a cube mod P.");
      return K;
    }
    if (x === 7) {
      const O = r.addn(2).idivn(9), K = $.redPow(O);
      if (!K.redSqr().redMul(K).eq($))
        throw new Error("X is not a cube mod P.");
      return K;
    }
    throw new Error("Not implemented.");
  }
  function B($) {
    const r = d($);
    if ($.red.m.modrn(3) === 1) {
      const x = new c(2).toRed($.red), O = new c(3).toRed($.red), K = x.redInvert(), X = O.redNeg().redSqrt().redMul(K), P = X.redNeg(), V = X.redSub(K), re = P.redSub(K), ce = r.redMul(V), de = r.redMul(re);
      return [r, ce, de];
    }
    return [r];
  }
  function U($) {
    for (const r of B($))
      if (r.redJacobi() >= 0)
        return r;
    throw new Error("X^(1/3) is not a square mod P.");
  }
  function J($) {
    return c.randomBits($, 32).toNumber();
  }
  function C($, r) {
    const x = /* @__PURE__ */ new WeakMap();
    return function(K, X) {
      const P = X & 1, V = x.get(K);
      if (V && V[P] !== null)
        return V[P];
      const re = $.call(r, K, X);
      return x.has(K) || x.set(K, [null, null]), x.get(K)[P] = re, re;
    };
  }
  function M($, r) {
    I($ instanceof c), I(r >>> 0 === r), r & 7 && (r += 8 - (r & 7));
    const x = $.toString(16, r), O = [], K = [];
    I((x.length & 7) === 0);
    for (let X = 0; X < x.length; X += 8)
      O.push(x.slice(X, X + 8));
    for (let X = 0; X < O.length; X += 4)
      K.push(O.slice(X, X + 4).join(" "));
    return K;
  }
  return er.Curve = f, er.Point = n, er.ShortCurve = u, er.ShortPoint = o, er.JPoint = s, er.MontCurve = i, er.MontPoint = p, er.XPoint = g, er.EdwardsCurve = S, er.EdwardsPoint = y, er.curves = v, er.curve = he, er.register = le, er;
}
/*!
 * ecdsa.js - ECDSA for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/elliptic:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/elliptic
 *
 * References:
 *
 *   [SEC1] SEC 1: Elliptic Curve Cryptography, Version 2.0
 *     Certicom Research
 *     http://www.secg.org/sec1-v2.pdf
 *
 *   [FIPS186] Suite B Implementer's Guide to FIPS 186-3 (ECDSA)
 *     https://tinyurl.com/fips186-guide
 *
 *   [GECC] Guide to Elliptic Curve Cryptography
 *     D. Hankerson, A. Menezes, and S. Vanstone
 *     https://tinyurl.com/guide-to-ecc
 *
 *   [RFC6979] Deterministic Usage of the Digital Signature
 *             Algorithm (DSA) and Elliptic Curve Digital
 *             Signature Algorithm (ECDSA)
 *     T. Pornin
 *     https://tools.ietf.org/html/rfc6979
 */
var Oa, Ud;
function es() {
  if (Ud) return Oa;
  Ud = 1;
  const e = Mt(), c = jr(), l = Hi(), w = E7(), m = _g(), f = A7(), n = Rg();
  class u {
    constructor(s, i, p, g) {
      e(typeof s == "string"), e(i), e(p), this.id = s, this.type = "ecdsa", this.hash = i, this.xof = p, this.native = 0, this._pre = g || null, this._curve = null, this._schnorr = null;
    }
    get curve() {
      return this._curve || (this._curve = n.curve(this.id, this._pre), this._curve.precompute(l), this._pre = null), this._curve;
    }
    get schnorr() {
      return this._schnorr || (this._schnorr = new m(this.curve, this.xof)), this._schnorr;
    }
    get size() {
      return this.curve.fieldSize;
    }
    get bits() {
      return this.curve.fieldBits;
    }
    privateKeyGenerate() {
      const s = this.curve.randomScalar(l);
      return this.curve.encodeScalar(s);
    }
    privateKeyVerify(s) {
      e(k.isBuffer(s));
      let i;
      try {
        i = this.curve.decodeScalar(s);
      } catch {
        return !1;
      }
      return !i.isZero() && i.cmp(this.curve.n) < 0;
    }
    privateKeyExport(s) {
      const i = this.publicKeyCreate(s, !1), { x: p, y: g } = this.publicKeyExport(i);
      return {
        d: k.from(s),
        x: p,
        y: g
      };
    }
    privateKeyImport(s) {
      e(s && typeof s == "object");
      const i = c.decode(s.d, this.curve.endian);
      if (i.isZero() || i.cmp(this.curve.n) >= 0)
        throw new Error("Invalid private key.");
      return this.curve.encodeScalar(i);
    }
    privateKeyTweakAdd(s, i) {
      const p = this.curve.decodeScalar(i);
      if (p.cmp(this.curve.n) >= 0)
        throw new Error("Invalid scalar.");
      const g = this.curve.decodeScalar(s);
      if (g.isZero() || g.cmp(this.curve.n) >= 0)
        throw new Error("Invalid private key.");
      const S = g.add(p).imod(this.curve.n);
      if (S.isZero())
        throw new Error("Invalid private key.");
      return this.curve.encodeScalar(S);
    }
    privateKeyTweakMul(s, i) {
      const p = this.curve.decodeScalar(i);
      if (p.isZero() || p.cmp(this.curve.n) >= 0)
        throw new Error("Invalid scalar.");
      const g = this.curve.decodeScalar(s);
      if (g.isZero() || g.cmp(this.curve.n) >= 0)
        throw new Error("Invalid private key.");
      const S = g.mul(p).imod(this.curve.n);
      if (S.isZero())
        throw new Error("Invalid private key.");
      return this.curve.encodeScalar(S);
    }
    privateKeyNegate(s) {
      const i = this.curve.decodeScalar(s);
      if (i.isZero() || i.cmp(this.curve.n) >= 0)
        throw new Error("Invalid private key.");
      const p = i.neg().imod(this.curve.n);
      return this.curve.encodeScalar(p);
    }
    privateKeyInvert(s) {
      const i = this.curve.decodeScalar(s);
      if (i.isZero() || i.cmp(this.curve.n) >= 0)
        throw new Error("Invalid private key.");
      const p = i.invert(this.curve.n);
      return this.curve.encodeScalar(p);
    }
    publicKeyCreate(s, i) {
      const p = this.curve.decodeScalar(s);
      if (p.isZero() || p.cmp(this.curve.n) >= 0)
        throw new Error("Invalid private key.");
      return this.curve.g.mulBlind(p).encode(i);
    }
    publicKeyConvert(s, i) {
      return this.curve.decodePoint(s).encode(i);
    }
    publicKeyFromUniform(s, i) {
      const p = this.curve.decodeUniform(s);
      return this.curve.pointFromUniform(p).encode(i);
    }
    publicKeyToUniform(s, i = l.randomInt()) {
      const p = this.curve.decodePoint(s), g = this.curve.pointToUniform(p, i);
      return this.curve.encodeUniform(g, i >>> 8);
    }
    publicKeyFromHash(s, i) {
      return this.curve.pointFromHash(s).encode(i);
    }
    publicKeyToHash(s) {
      const i = this.curve.decodePoint(s);
      return this.curve.pointToHash(i, 0, l);
    }
    publicKeyVerify(s) {
      e(k.isBuffer(s));
      try {
        this.curve.decodePoint(s);
      } catch {
        return !1;
      }
      return !0;
    }
    publicKeyExport(s) {
      const { x: i, y: p } = this.curve.decodePoint(s);
      return {
        x: this.curve.encodeField(i.fromRed()),
        y: this.curve.encodeField(p.fromRed())
      };
    }
    publicKeyImport(s, i) {
      e(s && typeof s == "object");
      const p = c.decode(s.x, this.curve.endian);
      if (p.cmp(this.curve.p) >= 0)
        throw new Error("Invalid point.");
      if (s.y != null) {
        const S = c.decode(s.y, this.curve.endian);
        if (S.cmp(this.curve.p) >= 0)
          throw new Error("Invalid point.");
        const y = this.curve.point(p, S);
        if (!y.validate())
          throw new Error("Invalid point.");
        return y.encode(i);
      }
      return this.curve.pointFromX(p, s.sign).encode(i);
    }
    publicKeyTweakAdd(s, i, p) {
      const g = this.curve.decodeScalar(i);
      if (g.cmp(this.curve.n) >= 0)
        throw new Error("Invalid scalar.");
      const S = this.curve.decodePoint(s);
      return this.curve.g.jmul(g).add(S).encode(p);
    }
    publicKeyTweakMul(s, i, p) {
      const g = this.curve.decodeScalar(i);
      if (g.isZero() || g.cmp(this.curve.n) >= 0)
        throw new Error("Invalid scalar.");
      return this.curve.decodePoint(s).mul(g).encode(p);
    }
    publicKeyCombine(s, i) {
      e(Array.isArray(s));
      let p = this.curve.jpoint();
      for (const g of s) {
        const S = this.curve.decodePoint(g);
        p = p.add(S);
      }
      return p.encode(i);
    }
    publicKeyNegate(s, i) {
      return this.curve.decodePoint(s).neg().encode(i);
    }
    signatureNormalize(s) {
      const [i, p] = this._decodeCompact(s);
      return p.cmp(this.curve.nh) > 0 && p.ineg().imod(this.curve.n), this._encodeCompact(i, p);
    }
    signatureNormalizeDER(s) {
      const [i, p] = this._decodeDER(s, !1);
      return p.cmp(this.curve.nh) > 0 && p.ineg().imod(this.curve.n), this._encodeDER(i, p);
    }
    signatureExport(s) {
      const [i, p] = this._decodeCompact(s);
      return this._encodeDER(i, p);
    }
    signatureImport(s) {
      const [i, p] = this._decodeDER(s, !1);
      return this._encodeCompact(i, p);
    }
    isLowS(s) {
      e(k.isBuffer(s));
      let i;
      try {
        [, i] = this._decodeCompact(s);
      } catch {
        return !1;
      }
      return i.cmp(this.curve.nh) <= 0;
    }
    isLowDER(s) {
      e(k.isBuffer(s));
      let i;
      try {
        [, i] = this._decodeDER(s, !1);
      } catch {
        return !1;
      }
      return i.cmp(this.curve.nh) <= 0;
    }
    sign(s, i) {
      const [p, g] = this._sign(s, i);
      return this._encodeCompact(p, g);
    }
    signRecoverable(s, i) {
      const [p, g, S] = this._sign(s, i);
      return [this._encodeCompact(p, g), S];
    }
    signDER(s, i) {
      const [p, g] = this._sign(s, i);
      return this._encodeDER(p, g);
    }
    signRecoverableDER(s, i) {
      const [p, g, S] = this._sign(s, i);
      return [this._encodeDER(p, g), S];
    }
    _sign(s, i) {
      const { n: p, nh: g } = this.curve, S = this.curve.g, y = this.curve.decodeScalar(i);
      if (y.isZero() || y.cmp(p) >= 0)
        throw new Error("Invalid private key.");
      const b = this._reduce(s), h = this.curve.encodeScalar(b), a = new f(this.hash, i, h);
      for (; ; ) {
        const E = a.generate(this.curve.scalarSize), H = this._truncate(E);
        if (H.isZero() || H.cmp(p) >= 0)
          continue;
        const j = S.mulBlind(H);
        if (j.isInfinity())
          continue;
        const G = j.getX(), N = G.mod(p);
        if (N.isZero())
          continue;
        const T = this.curve.randomScalar(l), A = H.mul(T).fermat(p), q = y.mul(T).imod(p), _ = b.mul(T).imod(p), R = N.mul(q).iadd(_).imod(p).mul(A).imod(p);
        if (R.isZero())
          continue;
        let L = j.isOdd() | !G.eq(N) << 1;
        return R.cmp(g) > 0 && (R.ineg().imod(p), L ^= 1), [N, R, L];
      }
    }
    verify(s, i, p) {
      e(k.isBuffer(s)), e(k.isBuffer(i)), e(k.isBuffer(p));
      let g, S;
      try {
        [g, S] = this._decodeCompact(i);
      } catch {
        return !1;
      }
      try {
        return this._verify(s, g, S, p);
      } catch {
        return !1;
      }
    }
    verifyDER(s, i, p) {
      e(k.isBuffer(s)), e(k.isBuffer(i)), e(k.isBuffer(p));
      let g, S;
      try {
        [g, S] = this._decodeDER(i, !1);
      } catch {
        return !1;
      }
      try {
        return this._verify(s, g, S, p);
      } catch {
        return !1;
      }
    }
    _verify(s, i, p, g) {
      const { n: S } = this.curve, y = this.curve.g, b = this._reduce(s), h = this.curve.decodePoint(g);
      if (i.isZero() || i.cmp(S) >= 0 || p.isZero() || p.cmp(S) >= 0)
        return !1;
      const a = p.invert(S), E = b.mul(a).imod(S), H = i.mul(a).imod(S);
      return y.jmulAdd(E, h, H).eqR(i);
    }
    recover(s, i, p, g) {
      e(k.isBuffer(s)), e(k.isBuffer(i)), e(p >>> 0 === p), e((p & 3) === p, "The recovery param is more than two bits.");
      let S, y;
      try {
        [S, y] = this._decodeCompact(i);
      } catch {
        return null;
      }
      let b;
      try {
        b = this._recover(s, S, y, p);
      } catch {
        return null;
      }
      return b.encode(g);
    }
    recoverDER(s, i, p, g) {
      e(k.isBuffer(s)), e(k.isBuffer(i)), e(p >>> 0 === p), e((p & 3) === p, "The recovery param is more than two bits.");
      let S, y;
      try {
        [S, y] = this._decodeDER(i, !1);
      } catch {
        return null;
      }
      let b;
      try {
        b = this._recover(s, S, y, p);
      } catch {
        return null;
      }
      return b.encode(g);
    }
    _recover(s, i, p, g) {
      const { n: S, pmodn: y } = this.curve, b = this.curve.g, h = this._reduce(s);
      if (i.isZero() || i.cmp(S) >= 0)
        throw new Error("Invalid R value.");
      if (p.isZero() || p.cmp(S) >= 0)
        throw new Error("Invalid S value.");
      const a = (g & 1) !== 0, E = g >>> 1;
      let H = i;
      if (E) {
        if (this.curve.highOrder)
          throw new Error("Invalid high bit.");
        if (H.cmp(y) >= 0)
          throw new Error("Invalid R value.");
        H = H.add(S);
      }
      const j = this.curve.pointFromX(H, a), G = i.invert(S), N = h.mul(G).ineg().imod(S), T = p.mul(G).imod(S), A = b.mulAdd(N, j, T);
      if (A.isInfinity())
        throw new Error("Invalid point.");
      return A;
    }
    derive(s, i, p) {
      const g = this.curve.decodePoint(s), S = this.curve.decodeScalar(i);
      if (S.isZero() || S.cmp(this.curve.n) >= 0)
        throw new Error("Invalid private key.");
      if (this.curve.h.cmpn(1) > 0 && g.isSmall())
        throw new Error("Invalid point.");
      return g.mulBlind(S, l).encode(p);
    }
    /*
     * Schnorr
     */
    schnorrSign(s, i) {
      return this.schnorr.sign(s, i);
    }
    schnorrVerify(s, i, p) {
      return this.schnorr.verify(s, i, p);
    }
    schnorrVerifyBatch(s) {
      return this.schnorr.verifyBatch(s);
    }
    /*
     * Helpers
     */
    _encodeCompact(s, i) {
      return k.concat([
        this.curve.encodeScalar(s),
        this.curve.encodeScalar(i)
      ]);
    }
    _decodeCompact(s) {
      e(k.isBuffer(s));
      const { n: i } = this.curve, p = this.curve.scalarSize;
      if (s.length !== p * 2)
        throw new Error("Invalid signature size.");
      const g = s.slice(0, p), S = s.slice(p, p * 2), y = this.curve.decodeScalar(g), b = this.curve.decodeScalar(S);
      if (y.cmp(i) >= 0 || b.cmp(i) >= 0)
        throw new Error("Invalid signature.");
      return [y, b];
    }
    _encodeDER(s, i) {
      const p = w.sizeInt(s) + w.sizeInt(i), g = k.alloc(w.sizeSeq(p));
      let S = 0;
      return S = w.writeSeq(g, S, p), S = w.writeInt(g, S, s), S = w.writeInt(g, S, i), e(S === g.length), g;
    }
    _decodeDER(s, i) {
      e(k.isBuffer(s)), e(typeof i == "boolean");
      const { n: p } = this.curve;
      let g = 0, S, y;
      if (g = w.readSeq(s, g, i), [S, g] = w.readInt(s, g, i), [y, g] = w.readInt(s, g, i), i && g !== s.length)
        throw new Error("Trailing bytes.");
      if (S.cmp(p) >= 0 || y.cmp(p) >= 0)
        throw new Error("Invalid signature.");
      return [S, y];
    }
    _truncate(s) {
      e(k.isBuffer(s));
      const i = this.curve.n.bitLength(), p = i + 7 >>> 3;
      s.length > p && (s = s.slice(0, p));
      const g = c.decode(s, this.curve.endian), S = s.length * 8 - i;
      return S > 0 && g.iushrn(S), g;
    }
    _reduce(s) {
      return this._truncate(s).imod(this.curve.n);
    }
  }
  return Oa = u, Oa;
}
var Pg = {
  width: 9,
  points: [
    [
      "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
      "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
    ],
    [
      "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
      "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
    ],
    [
      "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
      "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
    ],
    [
      "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
      "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
    ],
    [
      "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
      "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
    ],
    [
      "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
      "0ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
    ],
    [
      "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
      "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
    ],
    [
      "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
      "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
    ],
    [
      "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
      "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
    ],
    [
      "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
      "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
    ],
    [
      "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
      "02de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
    ],
    [
      "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
      "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
    ],
    [
      "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
      "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
    ],
    [
      "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
      "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
    ],
    [
      "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
      "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
    ],
    [
      "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
      "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
    ],
    [
      "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
      "02972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
    ],
    [
      "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
      "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
    ],
    [
      "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
      "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
    ],
    [
      "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
      "0d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
    ],
    [
      "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
      "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
    ],
    [
      "049370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
      "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
    ],
    [
      "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
      "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
    ],
    [
      "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
      "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
    ],
    [
      "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
      "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
    ],
    [
      "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
      "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
    ],
    [
      "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
      "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
    ],
    [
      "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
      "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
    ],
    [
      "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
      "091b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
    ],
    [
      "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
      "0673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
    ],
    [
      "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
      "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
    ],
    [
      "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
      "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
    ],
    [
      "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
      "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
    ],
    [
      "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
      "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
    ],
    [
      "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
      "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
    ],
    [
      "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
      "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
    ],
    [
      "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
      "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
    ],
    [
      "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
      "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
    ],
    [
      "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
      "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
    ],
    [
      "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
      "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
    ],
    [
      "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
      "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
    ],
    [
      "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
      "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
    ],
    [
      "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
      "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
    ],
    [
      "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
      "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
    ],
    [
      "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
      "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
    ],
    [
      "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
      "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
    ],
    [
      "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
      "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
    ],
    [
      "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
      "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
    ],
    [
      "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
      "0a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
    ],
    [
      "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
      "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
    ],
    [
      "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
      "09414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
    ],
    [
      "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
      "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
    ],
    [
      "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
      "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
    ],
    [
      "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
      "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
    ],
    [
      "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
      "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
    ],
    [
      "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
      "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
    ],
    [
      "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
      "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
    ],
    [
      "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
      "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
    ],
    [
      "078c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
      "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
    ],
    [
      "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
      "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
    ],
    [
      "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
      "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
    ],
    [
      "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
      "04f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
    ],
    [
      "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
      "073867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
    ],
    [
      "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
      "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
    ],
    [
      "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
      "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
    ],
    [
      "0336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
      "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
    ],
    [
      "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
      "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
    ],
    [
      "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
      "060660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
    ],
    [
      "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
      "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
    ],
    [
      "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
      "0b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
    ],
    [
      "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
      "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
    ],
    [
      "04e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
      "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
    ],
    [
      "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
      "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
    ],
    [
      "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
      "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
    ],
    [
      "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
      "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
    ],
    [
      "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
      "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
    ],
    [
      "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
      "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
    ],
    [
      "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
      "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
    ],
    [
      "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
      "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
    ],
    [
      "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
      "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
    ],
    [
      "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
      "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
    ],
    [
      "0c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
      "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
    ],
    [
      "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
      "021ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
    ],
    [
      "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
      "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
    ],
    [
      "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
      "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
    ],
    [
      "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
      "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
    ],
    [
      "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
      "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
    ],
    [
      "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
      "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
    ],
    [
      "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
      "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
    ],
    [
      "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
      "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
    ],
    [
      "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
      "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
    ],
    [
      "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
      "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
    ],
    [
      "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
      "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
    ],
    [
      "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
      "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
    ],
    [
      "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
      "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
    ],
    [
      "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
      "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
    ],
    [
      "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
      "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
    ],
    [
      "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
      "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
    ],
    [
      "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
      "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
    ],
    [
      "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
      "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
    ],
    [
      "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
      "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
    ],
    [
      "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
      "0c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
    ],
    [
      "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
      "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
    ],
    [
      "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
      "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
    ],
    [
      "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
      "09731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
    ],
    [
      "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
      "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
    ],
    [
      "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
      "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
    ],
    [
      "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
      "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
    ],
    [
      "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
      "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
    ],
    [
      "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
      "0cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
    ],
    [
      "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
      "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
    ],
    [
      "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
      "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
    ],
    [
      "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
      "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
    ],
    [
      "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
      "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
    ],
    [
      "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
      "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
    ],
    [
      "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
      "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
    ],
    [
      "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
      "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
    ],
    [
      "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
      "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
    ],
    [
      "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
      "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
    ],
    [
      "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
      "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
    ],
    [
      "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
      "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
    ],
    [
      "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
      "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
    ],
    [
      "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
      "0712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
    ],
    [
      "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
      "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
    ],
    [
      "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
      "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
    ],
    [
      "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
      "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
    ],
    [
      "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
      "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
    ]
  ]
}, kg = {
  step: 4,
  points: [
    [
      "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
      "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
    ],
    [
      "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
      "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
    ],
    [
      "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
      "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
    ],
    [
      "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
      "04e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
    ],
    [
      "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
      "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
    ],
    [
      "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
      "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
    ],
    [
      "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
      "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
    ],
    [
      "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
      "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
    ],
    [
      "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
      "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
    ],
    [
      "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
      "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
    ],
    [
      "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
      "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
    ],
    [
      "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
      "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
    ],
    [
      "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
      "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
    ],
    [
      "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
      "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
    ],
    [
      "06f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
      "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
    ],
    [
      "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
      "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
    ],
    [
      "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
      "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
    ],
    [
      "0948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
      "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
    ],
    [
      "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
      "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
    ],
    [
      "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
      "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
    ],
    [
      "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
      "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
    ],
    [
      "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
      "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
    ],
    [
      "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
      "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
    ],
    [
      "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
      "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
    ],
    [
      "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
      "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
    ],
    [
      "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
      "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
    ],
    [
      "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
      "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
    ],
    [
      "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
      "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
    ],
    [
      "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
      "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
    ],
    [
      "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
      "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
    ],
    [
      "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
      "0e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
    ],
    [
      "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
      "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
    ],
    [
      "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
      "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
    ],
    [
      "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
      "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
    ],
    [
      "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
      "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
    ],
    [
      "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
      "067c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
    ],
    [
      "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
      "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
    ],
    [
      "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
      "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
    ],
    [
      "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
      "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
    ],
    [
      "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
      "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
    ],
    [
      "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
      "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
    ],
    [
      "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
      "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
    ],
    [
      "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
      "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
    ],
    [
      "0928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
      "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
    ],
    [
      "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
      "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
    ],
    [
      "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
      "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
    ],
    [
      "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
      "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
    ],
    [
      "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
      "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
    ],
    [
      "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
      "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
    ],
    [
      "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
      "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
    ],
    [
      "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
      "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
    ],
    [
      "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
      "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
    ],
    [
      "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
      "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
    ],
    [
      "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
      "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
    ],
    [
      "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
      "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
    ],
    [
      "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
      "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
    ],
    [
      "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
      "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
    ],
    [
      "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
      "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
    ],
    [
      "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
      "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
    ],
    [
      "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
      "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
    ],
    [
      "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
      "0d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
    ],
    [
      "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
      "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
    ],
    [
      "08ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
      "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
    ],
    [
      "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
      "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
    ],
    [
      "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
      "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
    ]
  ]
}, Bg = {
  naf: Pg,
  doubles: kg
};
/*!
 * secp256k1.js - secp256k1 for bcrypto
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var _a, Fd;
function Yr() {
  if (Fd) return _a;
  Fd = 1;
  const e = es(), c = br(), l = Bg;
  return _a = new e("SECP256K1", c, c, l), _a;
}
/*!
 * message.js - message signing utilities.
 * Copyright (c) 2019, The Bcoin Developers (MIT License).
 */
var Hd;
function Mg() {
  return Hd || (Hd = 1, function(e) {
    const c = dt, l = Bt, w = qr(), m = Yr(), f = e;
    f.MAGIC_STRING = `eCash Signed Message:
`, f.magicHash = (n, u = f.MAGIC_STRING) => {
      c(typeof u == "string", "prefix must be a string."), c(typeof n == "string", "message must be a string");
      const o = l.write();
      return o.writeVarString(u), o.writeVarString(n, "utf8"), w.digest(o.render());
    }, f.sign = (n, u, o) => {
      c(u.getPrivateKey(), "Cannot sign without private key.");
      const s = f.magicHash(n, o), i = u.getPublicKey().readInt8(0) !== 4, [
        p,
        g
      ] = m.signRecoverable(s, u.getPrivateKey()), S = l.write();
      return S.writeI8(g + 27 + (i ? 4 : 0)), S.writeBytes(p), S.render();
    }, f.recover = (n, u, o) => {
      c(typeof n == "string", "msg must be a string"), c(k.isBuffer(u), "sig must be a buffer");
      const s = f.magicHash(n, o);
      c.strictEqual(u.length, 65, "Invalid signature length");
      const i = u.readUInt8(0) - 27;
      c(i < 8, "Invalid signature parameter");
      const p = !!(i & 4), g = i & 3;
      return m.recover(s, u.slice(1), g, p);
    }, f.verify = (n, u, o, s) => {
      const i = f.recover(n, u);
      return c(k.isBuffer(o), "publicKey must be a buffer"), k.compare(o, i) !== 0 ? !1 : m.verify(
        f.magicHash(n, s),
        u.slice(1),
        o
      );
    };
  }(ya)), ya;
}
/*!
 * utils/index.js - utils for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var Ld;
function cr() {
  if (Ld) return Ii;
  Ld = 1, Ii.binary = dl(), Ii.fixed = z8(), Ii.util = pr(), Ii.message = Mg();
  const { inspect: { custom: e } } = u7;
  return Ii.inspectSymbol = e || "inspect", Ii;
}
/*!
 * address.js - address object for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var Ra, Kd;
function Li() {
  if (Kd) return Ra;
  Kd = 1;
  const e = dt, c = Bt, { base58: l, cashaddr: w } = Ys, m = Bi, f = wn(), n = qr(), u = Tr(), o = Xt(), { inspectSymbol: s } = cr(), i = k.alloc(20, 0);
  class p {
    /**
     * Create an address.
     * @constructor
     * @param {Object?} options
     */
    constructor(y, b) {
      this.type = p.types.PUBKEYHASH, this.hash = i, y && this.fromOptions(y, b);
    }
    /**
     * Inject properties from options object.
     * @private
     * @param {Object} options
     */
    fromOptions(y, b) {
      if (typeof y == "string")
        return this.fromString(y, b);
      e(y);
      const { hash: h, type: a } = y;
      return this.fromHash(h, a);
    }
    /**
     * Insantiate address from options.
     * @param {Object} options
     * @returns {Address}
     */
    static fromOptions(y, b) {
      return new this().fromOptions(y, b);
    }
    /**
     * Get the address hash.
     * @param {String?} enc - Can be `"hex"` or `null`.
     * @returns {Hash|Buffer}
     */
    getHash(y) {
      return y === "hex" ? this.hash.toString("hex") : this.hash;
    }
    /**
     * Test whether the address is null.
     * @returns {Boolean}
     */
    isNull() {
      if (this.hash.length === 20)
        return this.hash.equals(i);
      if (this.hash.length === 32)
        return this.hash.equals(o.ZERO_HASH);
      for (let y = 0; y < this.hash.length; y++)
        if (this.hash[y] !== 0)
          return !1;
      return !0;
    }
    /**
     * Test equality against another address.
     * @param {Address} addr
     * @returns {Boolean}
     */
    equals(y) {
      return e(y instanceof p), this.type === y.type && this.hash.equals(y.hash);
    }
    /**
     * Get the address type as a string.
     * @returns {String}
     */
    getType() {
      return p.typesByVal[this.type].toLowerCase();
    }
    /**
     * Get a network address prefix for the address.
     * @param {Network?} network
     * @returns {Number}
     */
    getPrefix(y) {
      y = u.get(y);
      const b = y.addressPrefix;
      switch (this.type) {
        case p.types.PUBKEYHASH:
          return b.pubkeyhash;
        case p.types.SCRIPTHASH:
          return b.scripthash;
      }
      return -1;
    }
    /**
     * Calculate size of serialized address.
     * @returns {Number}
     */
    getSize() {
      return 5 + this.hash.length;
    }
    /**
     * Compile the address object to its raw serialization.
     * @param {{NetworkType|Network)?} network
     * @returns {Buffer}
     * @throws Error on bad hash/prefix.
     */
    toRaw(y) {
      const b = this.getSize(), h = c.write(b), a = this.getPrefix(y);
      return e(a !== -1, "Not a valid address prefix."), h.writeU8(a), h.writeBytes(this.hash), h.writeChecksum(n.digest), h.render();
    }
    /**
     * Compile the address object to a base58 address.
     * @param {{NetworkType|Network)?} network
     * @returns {AddressString}
     * @throws Error on bad hash/prefix.
     */
    toBase58(y) {
      return l.encode(this.toRaw(y));
    }
    /**
     * Compile the address object to a cashaddr address.
     * @param {{NetworkType|Network)?} network
     * @returns {String}
     * @throws Error on bad hash/prefix.
     */
    toCashAddr(y) {
      const b = this.type, h = this.hash;
      y = u.get(y);
      const a = y.addressPrefix.cashaddr;
      return w.encode(a, b, h);
    }
    /**
     * Inject properties from string.
     * @private
     * @param {String} addr
     * @param {(Network|NetworkType)?} network
     * @returns {Address}
     */
    fromString(y, b) {
      if (e(typeof y == "string"), e(y.length > 0), e(y.length <= 100), g(y))
        return this.fromBase58(y, b);
      try {
        return this.fromCashAddr(y, b);
      } catch {
        return this.fromBase58(y, b);
      }
    }
    /**
     * Instantiate address from string.
     * @param {String} addr
     * @param {(Network|NetworkType)?} network
     * @returns {Address}
     */
    static fromString(y, b) {
      return new this().fromString(y, b);
    }
    /**
     * Return cashaddr by default
     * @param {(Network|NetworkType)?} network
     * @returns {AddressString}
     */
    toString(y) {
      return this.toCashAddr(y);
    }
    /**
     * Inspect the Address.
     * @returns {Object}
     */
    [s]() {
      return `<Address: type=${this.getType()} str=${this.toString()}>`;
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     * @throws Parse error
     */
    fromRaw(y, b) {
      const h = c.read(y, !0), a = h.readU8();
      b = u.fromAddress(a, b);
      const E = p.getType(a, b);
      if (y.length !== 25)
        throw new Error("Address is too long.");
      const H = h.readBytes(h.left() - 4);
      return h.verifyChecksum(n.digest), this.fromHash(H, E);
    }
    /**
     * Create an address object from a serialized address.
     * @param {Buffer} data
     * @returns {Address}
     * @throws Parse error.
     */
    static fromRaw(y, b) {
      return new this().fromRaw(y, b);
    }
    /**
     * Inject properties from base58 address.
     * @private
     * @param {AddressString} data
     * @param {Network?} network
     * @throws Parse error
     */
    fromBase58(y, b) {
      if (e(typeof y == "string"), y.length > 55)
        throw new Error("Address is too long.");
      return this.fromRaw(l.decode(y), b);
    }
    /**
     * Create an address object from a base58 address.
     * @param {AddressString} data
     * @param {Network?} network
     * @returns {Address}
     * @throws Parse error.
     */
    static fromBase58(y, b) {
      return new this().fromBase58(y, b);
    }
    /**
     * Inject properties from cashaddr address.
     * @private
     * @param {String} data
     * @param {Network?} network
     * @throws Parse error
     */
    fromCashAddr(y, b) {
      e(typeof y == "string"), b = u.get(b), b.addressPrefix.cashaddr;
      const h = m.decode(y);
      return h.type = h.type === "P2PKH" ? "PUBKEYHASH" : "SCRIPTHASH", u.fromCashAddr(h.prefix, b), this.fromHash(k.from(h.hash), h.type);
    }
    /**
     * Create an address object from a cashaddr address.
     * @param {String} data
     * @param {Network?} network
     * @returns {Address}
     * @throws Parse error.
     */
    static fromCashAddr(y, b) {
      return new this().fromCashAddr(y, b);
    }
    /**
     * Inject properties from output script.
     * @private
     * @param {Script} script
     */
    fromScript(y) {
      const b = y.getPubkey();
      if (b)
        return this.hash = f.digest(b), this.type = p.types.PUBKEYHASH, this;
      const h = y.getPubkeyhash();
      if (h)
        return this.hash = h, this.type = p.types.PUBKEYHASH, this;
      const a = y.getScripthash();
      return a ? (this.hash = a, this.type = p.types.SCRIPTHASH, this) : y.isMultisig() ? (this.hash = y.hash160(), this.type = p.types.SCRIPTHASH, this) : null;
    }
    /**
     * Inject properties from input script.
     * @private
     * @param {Script} script
     */
    fromInputScript(y) {
      const [, b] = y.getPubkeyhashInput();
      if (b)
        return this.hash = f.digest(b), this.type = p.types.PUBKEYHASH, this;
      const h = y.getScripthashInput();
      return h ? (this.hash = f.digest(h), this.type = p.types.SCRIPTHASH, this) : null;
    }
    /**
     * Create an Address from an input script.
     * Attempt to extract address
     * properties from an input script.
     * @param {Script}
     * @returns {Address|null}
     */
    static fromInputScript(y) {
      return new this().fromInputScript(y);
    }
    /**
     * Create an Address from an output script.
     * Parse an output script and extract address
     * properties. Converts pubkey and multisig
     * scripts to pubkeyhash and scripthash addresses.
     * @param {Script}
     * @returns {Address|null}
     */
    static fromScript(y) {
      return new this().fromScript(y);
    }
    /**
     * Inject properties from a hash.
     * @private
     * @param {Buffer|Hash} hash
     * @param {AddressPrefix} type
     * @throws on bad hash size
     */
    fromHash(y, b) {
      return typeof b == "string" && (b = p.types[b.toUpperCase()], e(b != null, "Not a valid address type.")), b == null && (b = p.types.PUBKEYHASH), e(k.isBuffer(y)), e(b >>> 0 === b), e(
        b >= p.types.PUBKEYHASH && b <= p.types.SCRIPTHASH,
        "Not a valid address type."
      ), e(y.length === 20, "Hash is the wrong size."), this.hash = y, this.type = b, this;
    }
    /**
     * Create a naked address from hash/type.
     * @param {Hash} hash
     * @param {AddressPrefix} type
     * @returns {Address}
     * @throws on bad hash size
     */
    static fromHash(y, b) {
      return new this().fromHash(y, b);
    }
    /**
     * Inject properties from pubkeyhash.
     * @private
     * @param {Buffer} hash
     * @returns {Address}
     */
    fromPubkeyhash(y) {
      const b = p.types.PUBKEYHASH;
      return e(y.length === 20, "P2PKH must be 20 bytes."), this.fromHash(y, b, -1);
    }
    /**
     * Instantiate address from pubkeyhash.
     * @param {Buffer} hash
     * @returns {Address}
     */
    static fromPubkeyhash(y) {
      return new this().fromPubkeyhash(y);
    }
    /**
     * Inject properties from scripthash.
     * @private
     * @param {Buffer} hash
     * @returns {Address}
     */
    fromScripthash(y) {
      const b = p.types.SCRIPTHASH;
      return e(y && y.length === 20, "P2SH must be 20 bytes."), this.fromHash(y, b, -1);
    }
    /**
     * Instantiate address from scripthash.
     * @param {Buffer} hash
     * @returns {Address}
     */
    static fromScripthash(y) {
      return new this().fromScripthash(y);
    }
    /**
     * Test whether the address is pubkeyhash.
     * @returns {Boolean}
     */
    isPubkeyhash() {
      return this.type === p.types.PUBKEYHASH;
    }
    /**
     * Test whether the address is scripthash.
     * @returns {Boolean}
     */
    isScripthash() {
      return this.type === p.types.SCRIPTHASH;
    }
    /**
     * Get the hash of a base58 address or address-related object.
     * @param {Address|Hash} data
     * @param {String?} enc - Can be `"hex"` or `null`.
     * @returns {Hash}
     */
    static getHash(y, b) {
      if (!y)
        throw new Error("Object is not an address.");
      let h;
      if (k.isBuffer(y)) {
        if (y.length !== 20)
          throw new Error("Object is not an address.");
        h = y;
      } else if (y instanceof p)
        h = y.hash;
      else
        throw new Error("Object is not an address.");
      return b === "hex" ? h.toString("hex") : h;
    }
    /**
     * Get an address type for a specified network address prefix.
     * @param {Number} prefix
     * @param {Network} network
     * @returns {AddressType}
     */
    static getType(y, b) {
      const h = b.addressPrefix;
      switch (y) {
        case h.pubkeyhash:
          return p.types.PUBKEYHASH;
        case h.scripthash:
          return p.types.SCRIPTHASH;
        default:
          throw new Error("Unknown address prefix.");
      }
    }
  }
  p.types = {
    PUBKEYHASH: 0,
    SCRIPTHASH: 1
  }, p.typesByVal = [
    "PUBKEYHASH",
    "SCRIPTHASH"
  ];
  function g(S) {
    let y = !1, b = !1;
    for (let h = 0; h < S.length; h++) {
      const a = S.charCodeAt(h);
      if (!(a >= 48 && a <= 57) && a !== 58 && (a & 32 ? (e(a >= 97 && a <= 122), y = !0) : (e(a >= 65 && a <= 90), b = !0), y && b))
        return !0;
    }
    return !1;
  }
  return Ra = p, Ra;
}
var Pa, Vd;
function O7() {
  if (Vd) return Pa;
  Vd = 1;
  const e = dt, c = Li(), l = Di();
  class w {
    /**
     * Create a bitcoin URI.
     * @alias module:btc.URI
     * @constructor
     * @param {Object|String} options
     */
    constructor(s) {
      this.address = new c(), this.amount = -1, this.label = null, this.message = null, this.request = null, s && this.fromOptions(s);
    }
    /**
     * Inject properties from options object.
     * @private
     * @param {Object|String} options
     * @returns {URI}
     */
    fromOptions(s) {
      return typeof s == "string" ? this.fromString(s) : (s.address && this.address.fromOptions(s.address), s.amount != null && (e(
        Number.isSafeInteger(s.amount) && s.amount >= 0,
        "Amount must be a uint64."
      ), this.amount = s.amount), s.label && (e(typeof s.label == "string", "Label must be a string."), this.label = s.label), s.message && (e(typeof s.message == "string", "Message must be a string."), this.message = s.message), s.request && (e(typeof s.request == "string", "Request must be a string."), this.request = s.request), this);
    }
    /**
     * Instantiate URI from options.
     * @param {Object|String} options
     * @returns {URI}
     */
    static fromOptions(s) {
      return new this().fromOptions(s);
    }
    /**
     * Parse and inject properties from string.
     * @private
     * @param {String} str
     * @param {Network?} network
     * @returns {URI}
     */
    fromString(s, i) {
      e(typeof s == "string"), e(s.length > 8, "Not a bitcoin URI.");
      const p = s.substring(0, 8);
      e(p === "bitcoin:", "Not a bitcoin URI."), s = s.substring(8);
      const g = s.indexOf("?");
      let S, y;
      if (g === -1 ? S = s : (S = s.substring(0, g), y = s.substring(g + 1)), this.address.fromString(S, i), !y)
        return this;
      const b = f(y);
      return b.amount && (e(b.amount.length > 0, "Value is empty."), e(b.amount[0] !== "-", "Value is negative."), this.amount = l.value(b.amount)), b.label && (this.label = b.label), b.message && (this.message = b.message), b.r && (this.request = b.r), this;
    }
    /**
     * Instantiate uri from string.
     * @param {String} str
     * @param {Network?} network
     * @returns {URI}
     */
    static fromString(s, i) {
      return new this().fromString(s, i);
    }
    /**
     * Serialize uri to a string.
     * @returns {String}
     */
    toString() {
      let s = "bitcoin:";
      s += this.address.toString();
      const i = [];
      return this.amount !== -1 && i.push(`amount=${l.btc(this.amount)}`), this.label && i.push(`label=${u(this.label)}`), this.message && i.push(`message=${u(this.message)}`), this.request && i.push(`r=${u(this.request)}`), i.length > 0 && (s += "?" + i.join("&")), s;
    }
    /**
     * Inspect bitcoin uri.
     * @returns {String}
     */
    inspect() {
      return `<URI: ${this.toString()}>`;
    }
  }
  class m {
    constructor() {
      this.amount = null, this.label = null, this.message = null, this.r = null;
    }
  }
  function f(o) {
    const s = o.split("&"), i = new m();
    let p = 0;
    for (const g of s) {
      const S = g.indexOf("=");
      let y, b;
      if (S === -1 ? (y = g, b = "") : (y = g.substring(0, S), b = g.substring(S + 1)), y.length === 0) {
        e(b.length === 0, "Empty key in querystring.");
        continue;
      }
      switch (e(p < 4, "Too many keys in querystring."), y) {
        case "amount":
          e(i.amount == null, "Duplicate key in querystring (amount)."), i.amount = n(b);
          break;
        case "label":
          e(i.label == null, "Duplicate key in querystring (label)."), i.label = n(b);
          break;
        case "message":
          e(i.message == null, "Duplicate key in querystring (message)."), i.message = n(b);
          break;
        case "r":
          e(i.r == null, "Duplicate key in querystring (r)."), i.r = n(b);
          break;
        default:
          e(!1, `Unknown querystring key: ${b}.`);
          break;
      }
      p += 1;
    }
    return i;
  }
  function n(o) {
    try {
      o = decodeURIComponent(o), o = o.replace(/\+/g, " ");
    } catch {
      throw new Error("Malformed URI.");
    }
    if (o.indexOf("\0") !== -1)
      throw new Error("Malformed URI.");
    return o;
  }
  function u(o) {
    return o = encodeURIComponent(o), o = o.replace(/%20/g, "+"), o;
  }
  return Pa = w, Pa;
}
/*!
 * btc/index.js - high-level btc objects for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var $d;
function Ng() {
  return $d || ($d = 1, ms.Amount = Di(), ms.URI = O7()), ms;
}
var Zi = {};
/*!
 * sha1.js - SHA1 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/hash.js:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/hash.js
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/SHA-1
 *   https://tools.ietf.org/html/rfc3174
 *   http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf
 *   https://github.com/indutny/hash.js/blob/master/lib/hash/sha/1.js
 */
var ka, jd;
function _7() {
  if (jd) return ka;
  jd = 1;
  const e = Mt(), c = ni(), l = -1, w = k.alloc(8, 0), m = k.alloc(64, 0);
  m[0] = 128;
  const f = new Uint32Array([
    1518500249,
    1859775393,
    2400959708,
    3395469782
  ]);
  class n {
    constructor() {
      this.state = new Uint32Array(5), this.msg = new Uint32Array(80), this.block = k.alloc(64), this.size = l;
    }
    init() {
      return this.state[0] = 1732584193, this.state[1] = 4023233417, this.state[2] = 2562383102, this.state[3] = 271733878, this.state[4] = 3285377520, this.size = 0, this;
    }
    update(b) {
      return e(k.isBuffer(b)), this._update(b, b.length), this;
    }
    final() {
      return this._final(k.alloc(20));
    }
    _update(b, h) {
      e(this.size !== l, "Context is not initialized.");
      let a = this.size & 63, E = 0;
      if (this.size += h, a > 0) {
        let H = 64 - a;
        if (H > h && (H = h), b.copy(this.block, a, E, E + H), a += H, h -= H, E += H, a < 64)
          return;
        this._transform(this.block, 0);
      }
      for (; h >= 64; )
        this._transform(b, E), E += 64, h -= 64;
      h > 0 && b.copy(this.block, 0, E, E + h);
    }
    _final(b) {
      e(this.size !== l, "Context is not initialized.");
      const h = this.size & 63, a = this.size * 8;
      S(w, a * (1 / 4294967296) >>> 0, 0), S(w, a >>> 0, 4), this._update(m, 1 + (119 - h & 63)), this._update(w, 8);
      for (let E = 0; E < 5; E++)
        S(b, this.state[E], E * 4), this.state[E] = 0;
      for (let E = 0; E < 80; E++)
        this.msg[E] = 0;
      for (let E = 0; E < 64; E++)
        this.block[E] = 0;
      return this.size = l, b;
    }
    _transform(b, h) {
      const a = this.msg;
      let E = this.state[0], H = this.state[1], j = this.state[2], G = this.state[3], N = this.state[4], T = 0;
      for (; T < 16; T++)
        a[T] = g(b, h + T * 4);
      for (; T < 80; T++)
        a[T] = u(a[T - 3] ^ a[T - 8] ^ a[T - 14] ^ a[T - 16], 1);
      for (T = 0; T < 80; T++) {
        const A = T / 20 | 0, q = u(E, 5) + o(A, H, j, G) + N + a[T] + f[A];
        N = G, G = j, j = u(H, 30), H = E, E = q >>> 0;
      }
      this.state[0] += E, this.state[1] += H, this.state[2] += j, this.state[3] += G, this.state[4] += N;
    }
    static hash() {
      return new n();
    }
    static hmac() {
      return new c(n, 64);
    }
    static digest(b) {
      return n.ctx.init().update(b).final();
    }
    static root(b, h) {
      return e(k.isBuffer(b) && b.length === 20), e(k.isBuffer(h) && h.length === 20), n.ctx.init().update(b).update(h).final();
    }
    static multi(b, h, a) {
      const { ctx: E } = n;
      return E.init(), E.update(b), E.update(h), a && E.update(a), E.final();
    }
    static mac(b, h) {
      return n.hmac().init(h).update(b).final();
    }
  }
  n.native = 0, n.id = "SHA1", n.size = 20, n.bits = 160, n.blockSize = 64, n.zero = k.alloc(20, 0), n.ctx = new n();
  function u(y, b) {
    return y << b | y >>> 32 - b;
  }
  function o(y, b, h, a) {
    return y === 0 ? s(b, h, a) : y === 1 || y === 3 ? p(b, h, a) : y === 2 ? i(b, h, a) : 0;
  }
  function s(y, b, h) {
    return y & b ^ ~y & h;
  }
  function i(y, b, h) {
    return y & b ^ y & h ^ b & h;
  }
  function p(y, b, h) {
    return y ^ b ^ h;
  }
  function g(y, b) {
    return y[b++] * 16777216 + y[b++] * 65536 + y[b++] * 256 + y[b];
  }
  function S(y, b, h) {
    return y[h++] = b >>> 24, y[h++] = b >>> 16, y[h++] = b >>> 8, y[h++] = b, h;
  }
  return ka = n, ka;
}
var Ba = {};
/*!
 * policy.js - bitcoin constants for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var Yd;
function yn() {
  return Yd || (Yd = 1, function(e) {
    const c = dt, l = Xt();
    e.MAX_TX_VERSION = l.MAX_TX_VERSION, e.MAX_TX_SIZE = l.MAX_TX_SIZE / 10, e.MAX_TX_SIGOPS = l.MAX_TX_SIGOPS / 5, e.BYTES_PER_SIGOP = 20, e.MIN_RELAY = 1e3, e.BARE_MULTISIG = !0, e.FREE_THRESHOLD = l.COIN * 144 / 250, e.MAX_P2SH_SIGOPS = 15, e.MAX_OP_RETURN_BYTES = 223, e.MAX_OP_RETURN = 220, e.MAX_P2WSH_STACK = 100, e.MAX_P2WSH_PUSH = 80, e.MAX_P2WSH_SIZE = 3600, e.MEMPOOL_MAX_ANCESTORS = 50, e.MEMPOOL_MAX_SIZE = 100 * 1e6, e.MEMPOOL_EXPIRY_TIME = 4320 * 60, e.MEMPOOL_MAX_ORPHANS = 100, e.MIN_BLOCK_SIZE = 0, e.MAX_BLOCK_SIZE = l.MAX_FORK_BLOCK_SIZE, e.BLOCK_PRIORITY_SIZE = 0, e.BLOCK_PRIORITY_THRESHOLD = e.FREE_THRESHOLD, e.getMinFee = function(m, f) {
      if (f == null && (f = e.MIN_RELAY), c(m >= 0), c(f >= 0), m === 0)
        return 0;
      let n = Math.floor(f * m / 1e3);
      return n === 0 && f > 0 && (n = f), n;
    }, e.getRoundFee = function(m, f) {
      if (f == null && (f = e.MIN_RELAY), c(m >= 0), c(f >= 0), m === 0)
        return 0;
      let n = f * Math.ceil(m / 1e3);
      return n === 0 && f > 0 && (n = f), n;
    }, e.getRate = function(m, f) {
      return c(m >= 0), c(f >= 0), m === 0 ? 0 : Math.floor(f * 1e3 / m);
    };
  }(Ba)), Ba;
}
/*!
 * scripterror.js - script error for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var Ma, Xd;
function to() {
  if (Xd) return Ma;
  Xd = 1;
  class e extends Error {
    /**
     * Create an error.
     * @constructor
     * @param {String} code - Error code.
     * @param {Opcode} op - Opcode.
     * @param {Number?} ip - Instruction pointer.
     */
    constructor(l, w, m) {
      super(), this.type = "ScriptError", this.code = l, this.message = l, this.op = -1, this.ip = -1, typeof w == "string" ? this.message = w : w && (this.message = `${l} (op=${w.toSymbol()}, ip=${m})`, this.op = w.value, this.ip = m), Error.captureStackTrace && Error.captureStackTrace(this, e);
    }
  }
  return Ma = e, Ma;
}
/*!
 * scriptnum.js - script number object for bcoin.
 * Copyright (c) 2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var Na, Gd;
function Ki() {
  if (Gd) return Na;
  Gd = 1;
  const e = dt, { I64: c } = q8, l = to(), w = k.alloc(0);
  class m extends c {
    /**
     * Create a script number.
     * @constructor
     * @param {(Number|String|Buffer|Object)?} num
     * @param {(String|Number)?} base
     */
    constructor(n, u) {
      super(n, u);
    }
    /**
     * Cast to int32.
     * @returns {Number}
     */
    getInt() {
      return this.lt(c.INT32_MIN) ? c.LONG_MIN : this.gt(c.INT32_MAX) ? c.LONG_MAX : this.toInt();
    }
    /**
     * Serialize script number.
     * @returns {Buffer}
     */
    toRaw() {
      let n = this;
      if (n.isZero())
        return w;
      let u = !1;
      n.isNeg() && (n = n.neg(), u = !0);
      const o = n.byteLength();
      let s = 0;
      n.testn(o * 8 - 1) && (s = 1);
      const i = k.allocUnsafe(o + s);
      switch (o) {
        case 8:
          i[7] = n.hi >>> 24 & 255;
        case 7:
          i[6] = n.hi >> 16 & 255;
        case 6:
          i[5] = n.hi >> 8 & 255;
        case 5:
          i[4] = n.hi & 255;
        case 4:
          i[3] = n.lo >>> 24 & 255;
        case 3:
          i[2] = n.lo >> 16 & 255;
        case 2:
          i[1] = n.lo >> 8 & 255;
        case 1:
          i[0] = n.lo & 255;
      }
      return i[o - 1] & 128 ? (e(s === 1), e(i.length === o + s), i[o] = u ? 128 : 0) : u ? (e(s === 0), e(i.length === o), i[o - 1] |= 128) : (e(s === 0), e(i.length === o)), i;
    }
    /**
     * Instantiate script number from serialized data.
     * @private
     * @param {Buffer} data
     * @returns {ScriptNum}
     */
    fromRaw(n) {
      if (e(k.isBuffer(n)), n.length === 0)
        return this;
      switch (n.length) {
        case 8:
          this.hi |= n[7] << 24;
        case 7:
          this.hi |= n[6] << 16;
        case 6:
          this.hi |= n[5] << 8;
        case 5:
          this.hi |= n[4];
        case 4:
          this.lo |= n[3] << 24;
        case 3:
          this.lo |= n[2] << 16;
        case 2:
          this.lo |= n[1] << 8;
        case 1:
          this.lo |= n[0];
          break;
        default:
          for (let u = 0; u < n.length; u++)
            this.orb(u, n[u]);
          break;
      }
      return n[n.length - 1] & 128 && (this.setn(n.length * 8 - 1, 0), this.ineg()), this;
    }
    /**
     * Serialize script number.
     * @returns {Buffer}
     */
    encode() {
      return this.toRaw();
    }
    /**
     * Decode and verify script number.
     * @private
     * @param {Buffer} data
     * @param {Boolean?} minimal - Require minimal encoding.
     * @param {Number?} limit - Size limit.
     * @returns {ScriptNum}
     */
    decode(n, u, o) {
      if (e(k.isBuffer(n)), o != null && n.length > o)
        throw new l("UNKNOWN_ERROR", "Script number overflow.");
      if (u && !m.isMinimal(n))
        throw new l("UNKNOWN_ERROR", "Non-minimal script number.");
      return this.fromRaw(n);
    }
    /**
     * Inspect script number.
     * @returns {String}
     */
    inspect() {
      return `<ScriptNum: ${this.toString(10)}>`;
    }
    /**
     * Test wether a serialized script
     * number is in its most minimal form.
     * @param {Buffer} data
     * @returns {Boolean}
     */
    static isMinimal(n) {
      return e(k.isBuffer(n)), n.length === 0 ? !0 : !((n[n.length - 1] & 127) === 0 && (n.length === 1 || (n[n.length - 2] & 128) === 0));
    }
    /**
     * Encode serialized script number in its most minimal form.
     * @param {Buffer} data
     * @returns {Buffer} minimal encoded data
     */
    static toMinimal(n) {
      if (e(k.isBuffer(n)), this.isMinimal(n))
        return n;
      const u = n[n.length - 1];
      for (let o = n.length - 1; o > 0; o--)
        if (n[o - 1] !== 0)
          return n[o - 1] & 128 ? n[o++] = u : n[o - 1] |= u, n = n.slice(0, o), n;
      return n = k.alloc(0), n;
    }
    /**
     * Decode and verify script number.
     * @param {Buffer} data
     * @param {Boolean?} minimal - Require minimal encoding.
     * @param {Number?} limit - Size limit.
     * @returns {ScriptNum}
     */
    static decode(n, u, o) {
      return new this().decode(n, u, o);
    }
    /**
     * Test whether object is a script number.
     * @param {Object} obj
     * @returns {Boolean}
     */
    static isScriptNum(n) {
      return n instanceof m;
    }
  }
  return Na = m, Na;
}
var qa = {};
/*!
 * common.js - common script functions for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var Jd;
function ts() {
  return Jd || (Jd = 1, function(e) {
    const c = dt, l = Yr(), w = Ki();
    e.opcodes = {
      // Push
      OP_0: 0,
      OP_PUSHDATA1: 76,
      OP_PUSHDATA2: 77,
      OP_PUSHDATA4: 78,
      OP_1NEGATE: 79,
      OP_RESERVED: 80,
      OP_1: 81,
      OP_2: 82,
      OP_3: 83,
      OP_4: 84,
      OP_5: 85,
      OP_6: 86,
      OP_7: 87,
      OP_8: 88,
      OP_9: 89,
      OP_10: 90,
      OP_11: 91,
      OP_12: 92,
      OP_13: 93,
      OP_14: 94,
      OP_15: 95,
      OP_16: 96,
      // Control
      OP_NOP: 97,
      OP_VER: 98,
      OP_IF: 99,
      OP_NOTIF: 100,
      OP_VERIF: 101,
      OP_VERNOTIF: 102,
      OP_ELSE: 103,
      OP_ENDIF: 104,
      OP_VERIFY: 105,
      OP_RETURN: 106,
      // Stack
      OP_TOALTSTACK: 107,
      OP_FROMALTSTACK: 108,
      OP_2DROP: 109,
      OP_2DUP: 110,
      OP_3DUP: 111,
      OP_2OVER: 112,
      OP_2ROT: 113,
      OP_2SWAP: 114,
      OP_IFDUP: 115,
      OP_DEPTH: 116,
      OP_DROP: 117,
      OP_DUP: 118,
      OP_NIP: 119,
      OP_OVER: 120,
      OP_PICK: 121,
      OP_ROLL: 122,
      OP_ROT: 123,
      OP_SWAP: 124,
      OP_TUCK: 125,
      // Splice
      OP_CAT: 126,
      OP_SPLIT: 127,
      OP_NUM2BIN: 128,
      OP_BIN2NUM: 129,
      OP_SIZE: 130,
      // Bit
      OP_INVERT: 131,
      OP_AND: 132,
      OP_OR: 133,
      OP_XOR: 134,
      OP_EQUAL: 135,
      OP_EQUALVERIFY: 136,
      OP_RESERVED1: 137,
      OP_RESERVED2: 138,
      // Numeric
      OP_1ADD: 139,
      OP_1SUB: 140,
      OP_2MUL: 141,
      OP_2DIV: 142,
      OP_NEGATE: 143,
      OP_ABS: 144,
      OP_NOT: 145,
      OP_0NOTEQUAL: 146,
      OP_ADD: 147,
      OP_SUB: 148,
      OP_MUL: 149,
      OP_DIV: 150,
      OP_MOD: 151,
      OP_LSHIFT: 152,
      OP_RSHIFT: 153,
      OP_BOOLAND: 154,
      OP_BOOLOR: 155,
      OP_NUMEQUAL: 156,
      OP_NUMEQUALVERIFY: 157,
      OP_NUMNOTEQUAL: 158,
      OP_LESSTHAN: 159,
      OP_GREATERTHAN: 160,
      OP_LESSTHANOREQUAL: 161,
      OP_GREATERTHANOREQUAL: 162,
      OP_MIN: 163,
      OP_MAX: 164,
      OP_WITHIN: 165,
      // Crypto
      OP_RIPEMD160: 166,
      OP_SHA1: 167,
      OP_SHA256: 168,
      OP_HASH160: 169,
      OP_HASH256: 170,
      OP_CODESEPARATOR: 171,
      OP_CHECKSIG: 172,
      OP_CHECKSIGVERIFY: 173,
      OP_CHECKMULTISIG: 174,
      OP_CHECKMULTISIGVERIFY: 175,
      // Expansion
      OP_NOP1: 176,
      OP_CHECKLOCKTIMEVERIFY: 177,
      OP_CHECKSEQUENCEVERIFY: 178,
      OP_NOP4: 179,
      OP_NOP5: 180,
      OP_NOP6: 181,
      OP_NOP7: 182,
      OP_NOP8: 183,
      OP_NOP9: 184,
      OP_NOP10: 185,
      // More Crypto
      OP_CHECKDATASIG: 186,
      OP_CHECKDATASIGVERIFY: 187,
      // additional byte-string operations
      OP_REVERSEBYTES: 188,
      // Custom
      OP_INVALIDOPCODE: 255
    }, e.opcodesByVal = {
      // Push
      0: "OP_0",
      76: "OP_PUSHDATA1",
      77: "OP_PUSHDATA2",
      78: "OP_PUSHDATA4",
      79: "OP_1NEGATE",
      80: "OP_RESERVED",
      81: "OP_1",
      82: "OP_2",
      83: "OP_3",
      84: "OP_4",
      85: "OP_5",
      86: "OP_6",
      87: "OP_7",
      88: "OP_8",
      89: "OP_9",
      90: "OP_10",
      91: "OP_11",
      92: "OP_12",
      93: "OP_13",
      94: "OP_14",
      95: "OP_15",
      96: "OP_16",
      // Control
      97: "OP_NOP",
      98: "OP_VER",
      99: "OP_IF",
      100: "OP_NOTIF",
      101: "OP_VERIF",
      102: "OP_VERNOTIF",
      103: "OP_ELSE",
      104: "OP_ENDIF",
      105: "OP_VERIFY",
      106: "OP_RETURN",
      // Stack
      107: "OP_TOALTSTACK",
      108: "OP_FROMALTSTACK",
      109: "OP_2DROP",
      110: "OP_2DUP",
      111: "OP_3DUP",
      112: "OP_2OVER",
      113: "OP_2ROT",
      114: "OP_2SWAP",
      115: "OP_IFDUP",
      116: "OP_DEPTH",
      117: "OP_DROP",
      118: "OP_DUP",
      119: "OP_NIP",
      120: "OP_OVER",
      121: "OP_PICK",
      122: "OP_ROLL",
      123: "OP_ROT",
      124: "OP_SWAP",
      125: "OP_TUCK",
      // Splice
      126: "OP_CAT",
      127: "OP_SPLIT",
      128: "OP_NUM2BIN",
      129: "OP_BIN2NUM",
      130: "OP_SIZE",
      // Bit
      131: "OP_INVERT",
      132: "OP_AND",
      133: "OP_OR",
      134: "OP_XOR",
      135: "OP_EQUAL",
      136: "OP_EQUALVERIFY",
      137: "OP_RESERVED1",
      138: "OP_RESERVED2",
      // Numeric
      139: "OP_1ADD",
      140: "OP_1SUB",
      141: "OP_2MUL",
      142: "OP_2DIV",
      143: "OP_NEGATE",
      144: "OP_ABS",
      145: "OP_NOT",
      146: "OP_0NOTEQUAL",
      147: "OP_ADD",
      148: "OP_SUB",
      149: "OP_MUL",
      150: "OP_DIV",
      151: "OP_MOD",
      152: "OP_LSHIFT",
      153: "OP_RSHIFT",
      154: "OP_BOOLAND",
      155: "OP_BOOLOR",
      156: "OP_NUMEQUAL",
      157: "OP_NUMEQUALVERIFY",
      158: "OP_NUMNOTEQUAL",
      159: "OP_LESSTHAN",
      160: "OP_GREATERTHAN",
      161: "OP_LESSTHANOREQUAL",
      162: "OP_GREATERTHANOREQUAL",
      163: "OP_MIN",
      164: "OP_MAX",
      165: "OP_WITHIN",
      // Crypto
      166: "OP_RIPEMD160",
      167: "OP_SHA1",
      168: "OP_SHA256",
      169: "OP_HASH160",
      170: "OP_HASH256",
      171: "OP_CODESEPARATOR",
      172: "OP_CHECKSIG",
      173: "OP_CHECKSIGVERIFY",
      174: "OP_CHECKMULTISIG",
      175: "OP_CHECKMULTISIGVERIFY",
      // Expansion
      176: "OP_NOP1",
      177: "OP_CHECKLOCKTIMEVERIFY",
      178: "OP_CHECKSEQUENCEVERIFY",
      179: "OP_NOP4",
      180: "OP_NOP5",
      181: "OP_NOP6",
      182: "OP_NOP7",
      183: "OP_NOP8",
      184: "OP_NOP9",
      185: "OP_NOP10",
      // More Crypto
      186: "OP_CHECKDATASIG",
      187: "OP_CHECKDATASIGVERIFY",
      // Additional byte-string operation
      188: "OP_REVERSEBYTES",
      // Custom
      255: "OP_INVALIDOPCODE"
    }, e.small = [
      k.from([129]),
      k.from([]),
      k.from([1]),
      k.from([2]),
      k.from([3]),
      k.from([4]),
      k.from([5]),
      k.from([6]),
      k.from([7]),
      k.from([8]),
      k.from([9]),
      k.from([10]),
      k.from([11]),
      k.from([12]),
      k.from([13]),
      k.from([14]),
      k.from([15]),
      k.from([16])
    ], e.flags = {
      VERIFY_NONE: 0,
      VERIFY_P2SH: 1,
      VERIFY_STRICTENC: 2,
      VERIFY_DERSIG: 4,
      VERIFY_LOW_S: 8,
      VERIFY_SIGPUSHONLY: 32,
      VERIFY_MINIMALDATA: 64,
      VERIFY_DISCOURAGE_UPGRADABLE_NOPS: 128,
      VERIFY_CLEANSTACK: 256,
      VERIFY_CHECKLOCKTIMEVERIFY: 512,
      VERIFY_CHECKSEQUENCEVERIFY: 1024,
      VERIFY_MINIMALIF: 8192,
      VERIFY_NULLFAIL: 16384,
      VERIFY_COMPRESSED_PUBKEYTYPE: 32768,
      VERIFY_SIGHASH_FORKID: 65536,
      VERIFY_REPLAY_PROTECTION: 1 << 17,
      VERIFY_CHECKDATASIG: 1 << 18,
      VERIFY_SCHNORR: 1 << 19,
      VERIFY_DISALLOW_SEGWIT_RECOVERY: 1 << 20,
      VERIFY_SCHNORR_MULTISIG: 1 << 21,
      VERIFY_INPUT_SIGCHECKS: 1 << 22,
      VERIFY_REVERSEBYTES: 1 << 23,
      VERIFY_ZERO_SIGOPS: 1 << 30,
      REPORT_SIGCHECKS: 1 << 31
    }, e.flags.MANDATORY_VERIFY_FLAGS = e.flags.VERIFY_P2SH, e.flags.STANDARD_VERIFY_FLAGS = 0 | e.flags.MANDATORY_VERIFY_FLAGS | e.flags.VERIFY_DERSIG | e.flags.VERIFY_STRICTENC | e.flags.VERIFY_MINIMALDATA | e.flags.VERIFY_SIGPUSHONLY | e.flags.VERIFY_DISCOURAGE_UPGRADABLE_NOPS | e.flags.VERIFY_CLEANSTACK | e.flags.VERIFY_MINIMALIF | e.flags.VERIFY_NULLFAIL | e.flags.VERIFY_CHECKLOCKTIMEVERIFY | e.flags.VERIFY_CHECKSEQUENCEVERIFY | e.flags.VERIFY_LOW_S | e.flags.VERIFY_SIGHASH_FORKID | e.flags.VERIFY_CHECKDATASIG | e.flags.VERIFY_DISALLOW_SEGWIT_RECOVERY | e.flags.VERIFY_SCHNORR_MULTISIG, e.flags.ONLY_STANDARD_VERIFY_FLAGS = e.flags.STANDARD_VERIFY_FLAGS & ~e.flags.MANDATORY_VERIFY_FLAGS, e.hashType = {
      /*
       * Sign all outputs.
       */
      ALL: 1,
      /*
       * Do not sign outputs (zero sequences).
       */
      NONE: 2,
      /*
       * Sign output at the same index (zero sequences).
       */
      SINGLE: 3,
      /*
       * Sighash fork ID.
       */
      SIGHASH_FORKID: 64,
      /*
       * Sign only the current input (mask).
       */
      ANYONECANPAY: 128
    }, e.hashTypeByVal = {
      1: "ALL",
      2: "NONE",
      3: "SINGLE",
      128: "ANYONECANPAY"
    }, e.types = {
      NONSTANDARD: 0,
      PUBKEY: 1,
      PUBKEYHASH: 2,
      SCRIPTHASH: 3,
      MULTISIG: 4,
      NULLDATA: 5
    }, e.typesByVal = {
      0: "NONSTANDARD",
      1: "PUBKEY",
      2: "PUBKEYHASH",
      3: "SCRIPTHASH",
      4: "MULTISIG",
      5: "NULLDATA"
    }, e.isHashType = function(f) {
      if (c(k.isBuffer(f)), f.length === 0)
        return !1;
      const n = f[f.length - 1] & ~(e.hashType.ANYONECANPAY | e.hashType.SIGHASH_FORKID);
      return !(n < e.hashType.ALL || n > e.hashType.SINGLE);
    }, e.countBits = function(f) {
      return f = f - (f >> 1 & 1431655765), f = (f & 858993459) + (f >> 2 & 858993459), (f + (f >> 4) & 252645135) * 16843009 >> 24;
    }, e.isSchnorr = function(f) {
      return c(k.isBuffer(f)), f.length === 64;
    }, e.isLowDER = function(f) {
      return e.isDERSignatureEncoding(f) ? l.isLowDER(f) : !1;
    }, e.isKeyEncoding = function(f) {
      if (c(k.isBuffer(f)), f.length < 33)
        return !1;
      if (f[0] === 4) {
        if (f.length !== 65)
          return !1;
      } else if (f[0] === 2 || f[0] === 3) {
        if (f.length !== 33)
          return !1;
      } else
        return !1;
      return !0;
    }, e.isCompressedEncoding = function(f) {
      return c(k.isBuffer(f)), !(f.length !== 33 || f[0] !== 2 && f[0] !== 3);
    }, e.isDERSignatureEncoding = function(f) {
      if (c(k.isBuffer(f)), f.length < 8 || f.length > 72 || f[0] !== 48 || f[1] !== f.length - 2)
        return !1;
      const n = f[3];
      if (5 + n >= f.length)
        return !1;
      const u = f[5 + n];
      return !(n + u + 6 !== f.length || f[2] !== 2 || n === 0 || f[4] & 128 || n > 1 && f[4] === 0 && !(f[5] & 128) || f[n + 4] !== 2 || u === 0 || f[n + 6] & 128 || u > 1 && f[n + 6] === 0 && !(f[n + 7] & 128));
    }, e.toASM = function(f, n) {
      if (f.length <= 4)
        return w.decode(f).toString(10);
      if (n && e.isDERSignatureEncoding(f.slice(0, -1))) {
        const u = f[f.length - 1];
        let o = e.hashTypeByVal[u & 31] || "";
        return o && (u & e.hashType.ANYONECANPAY && (o += "|ANYONECANPAY"), o = `[${o}]`), f.slice(0, -1).toString("hex") + o;
      }
      return f.toString("hex");
    }, e.hashTypeWithForkValue = function(f, n) {
      return n << 8 | f & 255;
    }, e.getHashTypeForkValue = function(f) {
      return f >>> 8;
    };
  }(qa)), qa;
}
/*!
 * opcode.js - opcode object for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var Ta, Wd;
function Ml() {
  if (Wd) return Ta;
  Wd = 1;
  const e = dt, c = Bt, l = Ki(), w = ts(), m = w.opcodes, f = [];
  let n = null;
  class u {
    /**
     * Create an opcode.
     * Note: this should not be called directly.
     * @constructor
     * @param {Number} value - Opcode.
     * @param {Buffer?} data - Pushdata buffer.
     */
    constructor(i, p) {
      this.value = i || 0, this.data = p || null;
    }
    /**
     * Test whether a pushdata abides by minimaldata.
     * @returns {Boolean}
     */
    isMinimal() {
      return e(0 <= this.value && this.value <= m.OP_PUSHDATA4), this.data ? this.data.length === 1 && (this.data[0] === 129 || this.data[0] >= 1 && this.data[0] <= 16) ? !1 : this.data.length <= 75 ? this.value === this.data.length : this.data.length <= 255 ? this.value === m.OP_PUSHDATA1 : this.data.length <= 65535 ? this.value === m.OP_PUSHDATA2 : !0 : !0;
    }
    /**
     * Test whether opcode is a disabled opcode.
     * @param {Number?} flags - Script standard flags.
     * @returns {Boolean}
     */
    isDisabled(i) {
      switch (this.value) {
        case m.OP_INVERT:
        case m.OP_2MUL:
        case m.OP_2DIV:
        case m.OP_MUL:
        case m.OP_LSHIFT:
        case m.OP_RSHIFT:
          return !0;
      }
      return !1;
    }
    /**
     * Test whether opcode is a branch (if/else/endif).
     * @returns {Boolean}
     */
    isBranch() {
      return this.value >= m.OP_IF && this.value <= m.OP_ENDIF;
    }
    /**
     * Test opcode equality.
     * @param {Opcode} op
     * @returns {Boolean}
     */
    equals(i) {
      return e(u.isOpcode(i)), this.value !== i.value ? !1 : this.data ? (e(i.data), this.data.equals(i.data)) : (e(!i.data), !0);
    }
    /**
     * Convert Opcode to opcode value.
     * @returns {Number}
     */
    toOp() {
      return this.value;
    }
    /**
     * Covert opcode to data push.
     * @returns {Buffer|null}
     */
    toData() {
      return this.data;
    }
    /**
     * Covert opcode to data length.
     * @returns {Number}
     */
    toLength() {
      return this.data ? this.data.length : -1;
    }
    /**
     * Covert and _cast_ opcode to data push.
     * @returns {Buffer|null}
     */
    toPush() {
      return this.value === m.OP_0 ? w.small[1] : this.value === m.OP_1NEGATE ? w.small[0] : this.value >= m.OP_1 && this.value <= m.OP_16 ? w.small[this.value - 80 + 1] : this.toData();
    }
    /**
     * Get string for opcode.
     * @param {String?} enc
     * @returns {Buffer|null}
     */
    toString(i) {
      const p = this.toPush();
      return p ? p.toString(i || "utf8") : null;
    }
    /**
     * Convert opcode to small integer.
     * @returns {Number}
     */
    toSmall() {
      return this.value === m.OP_0 ? 0 : this.value >= m.OP_1 && this.value <= m.OP_16 ? this.value - 80 : -1;
    }
    /**
     * Convert opcode to script number.
     * @param {Boolean?} minimal
     * @param {Number?} limit
     * @returns {ScriptNum|null}
     */
    toNum(i, p) {
      return this.value === m.OP_0 ? l.fromInt(0) : this.value === m.OP_1NEGATE ? l.fromInt(-1) : this.value >= m.OP_1 && this.value <= m.OP_16 ? l.fromInt(this.value - 80) : this.data ? l.decode(this.data, i, p) : null;
    }
    /**
     * Convert opcode to integer.
     * @param {Boolean?} minimal
     * @param {Number?} limit
     * @returns {Number}
     */
    toInt(i, p) {
      const g = this.toNum(i, p);
      return g ? g.getInt() : -1;
    }
    /**
     * Convert opcode to boolean.
     * @returns {Boolean}
     */
    toBool() {
      const i = this.toSmall();
      return i === -1 ? !1 : i === 1;
    }
    /**
     * Convert opcode to its symbolic representation.
     * @returns {String}
     */
    toSymbol() {
      if (this.value === -1)
        return "OP_INVALIDOPCODE";
      const i = w.opcodesByVal[this.value];
      return i || `0x${o(this.value)}`;
    }
    /**
     * Calculate opcode size.
     * @returns {Number}
     */
    getSize() {
      if (!this.data)
        return 1;
      switch (this.value) {
        case m.OP_PUSHDATA1:
          return 2 + this.data.length;
        case m.OP_PUSHDATA2:
          return 3 + this.data.length;
        case m.OP_PUSHDATA4:
          return 5 + this.data.length;
        default:
          return 1 + this.data.length;
      }
    }
    /**
     * Encode the opcode to a buffer writer.
     * @param {BufferWriter} bw
     */
    toWriter(i) {
      if (this.value === -1)
        throw new Error("Cannot reserialize a parse error.");
      if (!this.data)
        return i.writeU8(this.value), i;
      switch (this.value) {
        case m.OP_PUSHDATA1:
          i.writeU8(this.value), i.writeU8(this.data.length), i.writeBytes(this.data);
          break;
        case m.OP_PUSHDATA2:
          i.writeU8(this.value), i.writeU16(this.data.length), i.writeBytes(this.data);
          break;
        case m.OP_PUSHDATA4:
          i.writeU8(this.value), i.writeU32(this.data.length), i.writeBytes(this.data);
          break;
        default:
          e(this.value === this.data.length), i.writeU8(this.value), i.writeBytes(this.data);
          break;
      }
      return i;
    }
    /**
     * Encode the opcode.
     * @returns {Buffer}
     */
    toRaw() {
      const i = this.getSize();
      return this.toWriter(c.write(i)).render();
    }
    /**
     * Convert the opcode to a bitcoind test string.
     * @returns {String} Human-readable script code.
     */
    toFormat() {
      if (this.value === -1)
        return "0x01";
      if (this.data) {
        if (this.data.length <= 4) {
          const b = this.toNum();
          if (this.equals(u.fromNum(b)))
            return b.toString(10);
        }
        const g = w.opcodesByVal[this.value], S = this.data.toString("hex");
        if (!g)
          return `0x${o(this.value)} 0x${S}`;
        let y = this.data.length.toString(16);
        for (; y.length % 2 !== 0; )
          y = "0" + y;
        return `${g} 0x${y} 0x${S}`;
      }
      const i = w.opcodesByVal[this.value];
      return i || `0x${o(this.value)}`;
    }
    /**
     * Format the opcode as bitcoind asm.
     * @param {Boolean?} decode - Attempt to decode hash types.
     * @returns {String} Human-readable script.
     */
    toASM(i) {
      return this.value === -1 ? "[error]" : this.data ? w.toASM(this.data, i) : w.opcodesByVal[this.value] || "OP_UNKNOWN";
    }
    /**
     * Instantiate an opcode from a number opcode.
     * @param {Number} op
     * @returns {Opcode}
     */
    static fromOp(i) {
      e(typeof i == "number");
      const p = f[i];
      return e(p, "Bad opcode."), p;
    }
    /**
     * Instantiate a pushdata opcode from
     * a buffer (will encode minimaldata).
     * @param {Buffer} data
     * @returns {Opcode}
     */
    static fromData(i) {
      if (e(k.isBuffer(i)), i.length === 1) {
        if (i[0] === 129)
          return this.fromOp(m.OP_1NEGATE);
        if (i[0] >= 1 && i[0] <= 16)
          return this.fromOp(i[0] + 80);
      }
      return this.fromPush(i);
    }
    /**
     * Instantiate a pushdata opcode from a
     * buffer (this differs from fromData in
     * that it will _always_ be a pushdata op).
     * @param {Buffer} data
     * @returns {Opcode}
     */
    static fromPush(i) {
      if (e(k.isBuffer(i)), i.length === 0)
        return this.fromOp(m.OP_0);
      if (i.length <= 75)
        return new this(i.length, i);
      if (i.length <= 255)
        return new this(m.OP_PUSHDATA1, i);
      if (i.length <= 65535)
        return new this(m.OP_PUSHDATA2, i);
      if (i.length <= 4294967295)
        return new this(m.OP_PUSHDATA4, i);
      throw new Error("Pushdata size too large.");
    }
    /**
     * Instantiate a pushdata opcode from a string.
     * @param {String} str
     * @param {String} [enc=utf8]
     * @returns {Opcode}
     */
    static fromString(i, p) {
      e(typeof i == "string");
      const g = k.from(i, p || "utf8");
      return this.fromData(g);
    }
    /**
     * Instantiate an opcode from a small number.
     * @param {Number} num
     * @returns {Opcode}
     */
    static fromSmall(i) {
      return e((i & 255) === i && i >= 0 && i <= 16), this.fromOp(i === 0 ? 0 : i + 80);
    }
    /**
     * Instantiate an opcode from a ScriptNum.
     * @param {ScriptNumber} num
     * @returns {Opcode}
     */
    static fromNum(i) {
      return e(l.isScriptNum(i)), this.fromData(i.encode());
    }
    /**
     * Instantiate an opcode from a Number.
     * @param {Number} num
     * @returns {Opcode}
     */
    static fromInt(i) {
      return e(Number.isSafeInteger(i)), i === 0 ? this.fromOp(m.OP_0) : i === -1 ? this.fromOp(m.OP_1NEGATE) : i >= 1 && i <= 16 ? this.fromOp(i + 80) : this.fromNum(l.fromNumber(i));
    }
    /**
     * Instantiate an opcode from a Number.
     * @param {Boolean} value
     * @returns {Opcode}
     */
    static fromBool(i) {
      return e(typeof i == "boolean"), this.fromSmall(i ? 1 : 0);
    }
    /**
     * Instantiate a pushdata opcode from symbolic name.
     * @example
     *   Opcode.fromSymbol('checksequenceverify')
     * @param {String} name
     * @returns {Opcode}
     */
    static fromSymbol(i) {
      e(typeof i == "string"), e(i.length > 0), i.charCodeAt(0) & 32 && (i = i.toUpperCase()), /^OP_/.test(i) || (i = `OP_${i}`);
      const p = w.opcodes[i];
      if (p != null)
        return this.fromOp(p);
      e(/^OP_0X/.test(i), "Unknown opcode."), e(i.length === 7, "Unknown opcode.");
      const g = parseInt(i.substring(5), 16);
      return e((g & 255) === g, "Unknown opcode."), this.fromOp(g);
    }
    /**
     * Instantiate opcode from buffer reader.
     * @param {BufferReader} br
     * @returns {Opcode}
     */
    static fromReader(i) {
      const p = i.readU8(), g = f[p];
      if (g)
        return g;
      switch (p) {
        case m.OP_PUSHDATA1: {
          if (i.left() < 1)
            return n;
          const S = i.readU8();
          if (i.left() < S)
            return i.seek(i.left()), n;
          const y = i.readBytes(S);
          return new this(p, y);
        }
        case m.OP_PUSHDATA2: {
          if (i.left() < 2)
            return i.seek(i.left()), n;
          const S = i.readU16();
          if (i.left() < S)
            return i.seek(i.left()), n;
          const y = i.readBytes(S);
          return new this(p, y);
        }
        case m.OP_PUSHDATA4: {
          if (i.left() < 4)
            return i.seek(i.left()), n;
          const S = i.readU32();
          if (i.left() < S)
            return i.seek(i.left()), n;
          const y = i.readBytes(S);
          return new this(p, y);
        }
        default: {
          if (i.left() < p)
            return i.seek(i.left()), n;
          const S = i.readBytes(p);
          return new this(p, S);
        }
      }
    }
    /**
     * Instantiate opcode from serialized data.
     * @param {Buffer} data
     * @returns {Opcode}
     */
    static fromRaw(i) {
      return this.fromReader(c.read(i));
    }
    /**
     * Test whether an object an Opcode.
     * @param {Object} obj
     * @returns {Boolean}
     */
    static isOpcode(i) {
      return i instanceof u;
    }
  }
  function o(s) {
    return s <= 15 ? "0" + s.toString(16) : s.toString(16);
  }
  n = Object.freeze(new u(-1));
  for (let s = 0; s <= 255; s++) {
    if (s >= 1 && s <= 78) {
      f.push(null);
      continue;
    }
    const i = new u(s);
    f.push(Object.freeze(i));
  }
  return Ta = u, Ta;
}
/*!
 * stack.js - stack object for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var za, Zd;
function ro() {
  if (Zd) return za;
  Zd = 1;
  const e = dt, c = ts(), l = Ki();
  class w {
    /**
     * Create a stack.
     * @constructor
     * @param {Buffer[]?} items - Stack items.
     */
    constructor(f) {
      this.items = f || [];
    }
    /**
     * Get length.
     * @returns {Number}
     */
    get length() {
      return this.items.length;
    }
    /**
     * Set length.
     * @param {Number} value
     */
    set length(f) {
      this.items.length = f;
    }
    /**
     * Instantiate a value-only iterator.
     * @returns {StackIterator}
     */
    [Symbol.iterator]() {
      return this.items[Symbol.iterator]();
    }
    /**
     * Instantiate a value-only iterator.
     * @returns {StackIterator}
     */
    values() {
      return this.items.values();
    }
    /**
     * Instantiate a key and value iterator.
     * @returns {StackIterator}
     */
    entries() {
      return this.items.entries();
    }
    /**
     * Inspect the stack.
     * @returns {String} Human-readable stack.
     */
    inspect() {
      return `<Stack: ${this.toString()}>`;
    }
    /**
     * Convert the stack to a string.
     * @returns {String} Human-readable stack.
     */
    toString() {
      const f = [];
      for (const n of this.items)
        f.push(n.toString("hex"));
      return f.join(" ");
    }
    /**
     * Format the stack as bitcoind asm.
     * @param {Boolean?} decode - Attempt to decode hash types.
     * @returns {String} Human-readable script.
     */
    toASM(f) {
      const n = [];
      for (const u of this.items)
        n.push(c.toASM(u, f));
      return n.join(" ");
    }
    /**
     * Clone the stack.
     * @returns {Stack} Cloned stack.
     */
    clone() {
      return new this.constructor(this.items.slice());
    }
    /**
     * Clear the stack.
     * @returns {Stack}
     */
    clear() {
      return this.items.length = 0, this;
    }
    /**
     * Get a stack item by index.
     * @param {Number} index
     * @returns {Buffer|null}
     */
    get(f) {
      return f < 0 && (f += this.items.length), f < 0 || f >= this.items.length ? null : this.items[f];
    }
    /**
     * Pop a stack item.
     * @see Array#pop
     * @returns {Buffer|null}
     */
    pop() {
      return this.items.pop() || null;
    }
    /**
     * Shift a stack item.
     * @see Array#shift
     * @returns {Buffer|null}
     */
    shift() {
      return this.items.shift() || null;
    }
    /**
     * Remove an item.
     * @param {Number} index
     * @returns {Buffer}
     */
    remove(f) {
      if (f < 0 && (f += this.items.length), f < 0 || f >= this.items.length)
        return null;
      const n = this.items.splice(f, 1);
      return n.length === 0 ? null : n[0];
    }
    /**
     * Set stack item at index.
     * @param {Number} index
     * @param {Buffer} value
     * @returns {Buffer}
     */
    set(f, n) {
      return f < 0 && (f += this.items.length), e(k.isBuffer(n)), e(f >= 0 && f <= this.items.length), this.items[f] = n, this;
    }
    /**
     * Push item onto stack.
     * @see Array#push
     * @param {Buffer} item
     * @returns {Number} Stack size.
     */
    push(f) {
      return e(k.isBuffer(f)), this.items.push(f), this;
    }
    /**
     * Unshift item from stack.
     * @see Array#unshift
     * @param {Buffer} item
     * @returns {Number}
     */
    unshift(f) {
      return e(k.isBuffer(f)), this.items.unshift(f), this;
    }
    /**
     * Insert an item.
     * @param {Number} index
     * @param {Buffer} item
     * @returns {Buffer}
     */
    insert(f, n) {
      return f < 0 && (f += this.items.length), e(k.isBuffer(n)), e(f >= 0 && f <= this.items.length), this.items.splice(f, 0, n), this;
    }
    /**
     * Erase stack items.
     * @param {Number} start
     * @param {Number} end
     * @returns {Buffer[]}
     */
    erase(f, n) {
      f < 0 && (f = this.items.length + f), n < 0 && (n = this.items.length + n), this.items.splice(f, n - f);
    }
    /**
     * Swap stack values.
     * @param {Number} i1 - Index 1.
     * @param {Number} i2 - Index 2.
     */
    swap(f, n) {
      f < 0 && (f = this.items.length + f), n < 0 && (n = this.items.length + n);
      const u = this.items[f], o = this.items[n];
      this.items[f] = o, this.items[n] = u;
    }
    /*
     * Data
     */
    getData(f) {
      return this.get(f);
    }
    popData() {
      return this.pop();
    }
    shiftData() {
      return this.shift();
    }
    removeData(f) {
      return this.remove(f);
    }
    setData(f, n) {
      return this.set(f, n);
    }
    pushData(f) {
      return this.push(f);
    }
    unshiftData(f) {
      return this.unshift(f);
    }
    insertData(f, n) {
      return this.insert(f, n);
    }
    /*
     * Length
     */
    getLength(f) {
      const n = this.get(f);
      return n ? n.length : -1;
    }
    /*
     * String
     */
    getString(f, n) {
      const u = this.get(f);
      return u ? w.toString(u, n) : null;
    }
    popString(f) {
      const n = this.pop();
      return n ? w.toString(n, f) : null;
    }
    shiftString(f) {
      const n = this.shift();
      return n ? w.toString(n, f) : null;
    }
    removeString(f, n) {
      const u = this.remove(f);
      return u ? w.toString(u, n) : null;
    }
    setString(f, n, u) {
      return this.set(f, w.fromString(n, u));
    }
    pushString(f, n) {
      return this.push(w.fromString(f, n));
    }
    unshiftString(f, n) {
      return this.unshift(w.fromString(f, n));
    }
    insertString(f, n, u) {
      return this.insert(f, w.fromString(n, u));
    }
    /*
     * Num
     */
    getNum(f, n, u) {
      const o = this.get(f);
      return o ? w.toNum(o, n, u) : null;
    }
    popNum(f, n) {
      const u = this.pop();
      return u ? w.toNum(u, f, n) : null;
    }
    shiftNum(f, n) {
      const u = this.shift();
      return u ? w.toNum(u, f, n) : null;
    }
    removeNum(f, n, u) {
      const o = this.remove(f);
      return o ? w.toNum(o, n, u) : null;
    }
    setNum(f, n) {
      return this.set(f, w.fromNum(n));
    }
    pushNum(f) {
      return this.push(w.fromNum(f));
    }
    unshiftNum(f) {
      return this.unshift(w.fromNum(f));
    }
    insertNum(f, n) {
      return this.insert(f, w.fromNum(n));
    }
    /*
     * Int
     */
    getInt(f, n, u) {
      const o = this.get(f);
      return o ? w.toInt(o, n, u) : -1;
    }
    popInt(f, n) {
      const u = this.pop();
      return u ? w.toInt(u, f, n) : -1;
    }
    shiftInt(f, n) {
      const u = this.shift();
      return u ? w.toInt(u, f, n) : -1;
    }
    removeInt(f, n, u) {
      const o = this.remove(f);
      return o ? w.toInt(o, n, u) : -1;
    }
    setInt(f, n) {
      return this.set(f, w.fromInt(n));
    }
    pushInt(f) {
      return this.push(w.fromInt(f));
    }
    unshiftInt(f) {
      return this.unshift(w.fromInt(f));
    }
    insertInt(f, n) {
      return this.insert(f, w.fromInt(n));
    }
    /*
     * Bool
     */
    getBool(f) {
      const n = this.get(f);
      return n ? w.toBool(n) : !1;
    }
    popBool() {
      const f = this.pop();
      return f ? w.toBool(f) : !1;
    }
    shiftBool() {
      const f = this.shift();
      return f ? w.toBool(f) : !1;
    }
    removeBool(f) {
      const n = this.remove(f);
      return n ? w.toBool(n) : !1;
    }
    setBool(f, n) {
      return this.set(f, w.fromBool(n));
    }
    pushBool(f) {
      return this.push(w.fromBool(f));
    }
    unshiftBool(f) {
      return this.unshift(w.fromBool(f));
    }
    insertBool(f, n) {
      return this.insert(f, w.fromBool(n));
    }
    /**
     * Test an object to see if it is a Stack.
     * @param {Object} obj
     * @returns {Boolean}
     */
    static isStack(f) {
      return f instanceof w;
    }
    /*
     * Encoding
     */
    static toString(f, n) {
      return e(k.isBuffer(f)), f.toString(n || "utf8");
    }
    static fromString(f, n) {
      return e(typeof f == "string"), k.from(f, n || "utf8");
    }
    static toNum(f, n, u) {
      return l.decode(f, n, u);
    }
    static fromNum(f) {
      return e(l.isScriptNum(f)), f.encode();
    }
    static toInt(f, n, u) {
      return w.toNum(f, n, u).getInt();
    }
    static fromInt(f) {
      if (e(typeof f == "number"), f >= -1 && f <= 16)
        return c.small[f + 1];
      const n = l.fromNumber(f);
      return w.fromNum(n);
    }
    static toBool(f) {
      e(k.isBuffer(f));
      for (let n = 0; n < f.length; n++)
        if (f[n] !== 0)
          return !(n === f.length - 1 && f[n] === 128);
      return !1;
    }
    static fromBool(f) {
      return e(typeof f == "boolean"), w.fromInt(f ? 1 : 0);
    }
  }
  return za = w, za;
}
var Ca, Qd;
function R7() {
  if (Qd) return Ca;
  Qd = 1;
  class e {
    constructor(l) {
      this.sigchecks = l || 0, this.init();
    }
    init() {
      return this.sigchecks;
    }
  }
  return Ca = e, Ca;
}
/*!
 * script.js - script interpreter for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var Da, e2;
function si() {
  if (e2) return Da;
  e2 = 1;
  const e = dt, c = Bt, l = ll(), w = _7(), m = br(), f = wn(), n = qr(), u = Yr(), o = Xt(), s = yn(), i = Ml(), p = ro(), g = to(), S = Ki(), y = ts(), b = Li(), h = R7(), a = y.opcodes, E = y.types, H = y.countBits, { encoding: j } = c, G = k.alloc(0), N = new h();
  class T {
    /**
     * Create a script.
     * @constructor
     * @param {Buffer|Array|Object} code
     */
    constructor(v) {
      this.raw = G, this.code = [], v && this.fromOptions(v);
    }
    /**
     * Get length.
     * @returns {Number}
     */
    get length() {
      return this.code.length;
    }
    /**
     * Set length.
     * @param {Number} value
     */
    set length(v) {
      this.code.length = v;
    }
    /**
     * Inject properties from options object.
     * @private
     * @param {Object} options
     */
    fromOptions(v) {
      if (e(v, "Script data is required."), k.isBuffer(v))
        return this.fromRaw(v);
      if (Array.isArray(v))
        return this.fromArray(v);
      if (v.raw) {
        if (!v.code)
          return this.fromRaw(v.raw);
        e(k.isBuffer(v.raw), "Raw must be a Buffer."), this.raw = v.raw;
      }
      if (v.code) {
        if (!v.raw)
          return this.fromArray(v.code);
        e(Array.isArray(v.code), "Code must be an array."), this.code = v.code;
      }
      return this;
    }
    /**
     * Insantiate script from options object.
     * @param {Object} options
     * @returns {Script}
     */
    static fromOptions(v) {
      return new this().fromOptions(v);
    }
    /**
     * Instantiate a value-only iterator.
     * @returns {ScriptIterator}
     */
    values() {
      return this.code.values();
    }
    /**
     * Instantiate a key and value iterator.
     * @returns {ScriptIterator}
     */
    entries() {
      return this.code.entries();
    }
    /**
     * Instantiate a value-only iterator.
     * @returns {ScriptIterator}
     */
    [Symbol.iterator]() {
      return this.code[Symbol.iterator]();
    }
    /**
     * Convert the script to an array of
     * Buffers (pushdatas) and Numbers
     * (opcodes).
     * @returns {Array}
     */
    toArray() {
      return this.code.slice();
    }
    /**
     * Inject properties from an array of
     * of buffers and numbers.
     * @private
     * @param {Array} code
     * @returns {Script}
     */
    fromArray(v) {
      e(Array.isArray(v)), this.clear();
      for (const Y of v)
        this.push(Y);
      return this.compile();
    }
    /**
     * Instantiate script from an array
     * of buffers and numbers.
     * @param {Array} code
     * @returns {Script}
     */
    static fromArray(v) {
      return new this().fromArray(v);
    }
    /**
     * Convert script to stack items.
     * @returns {Buffer[]}
     */
    toItems() {
      const v = [];
      for (const Y of this.code) {
        const he = Y.toPush();
        if (!he)
          throw new Error("Non-push opcode in script.");
        v.push(he);
      }
      return v;
    }
    /**
     * Inject data from stack items.
     * @private
     * @param {Buffer[]} items
     * @returns {Script}
     */
    fromItems(v) {
      e(Array.isArray(v)), this.clear();
      for (const Y of v)
        this.pushData(Y);
      return this.compile();
    }
    /**
     * Instantiate script from stack items.
     * @param {Buffer[]} items
     * @returns {Script}
     */
    static fromItems(v) {
      return new this().fromItems(v);
    }
    /**
     * Convert script to stack.
     * @returns {Stack}
     */
    toStack() {
      return new p(this.toItems());
    }
    /**
     * Inject data from stack.
     * @private
     * @param {Stack} stack
     * @returns {Script}
     */
    fromStack(v) {
      return this.fromItems(v.items);
    }
    /**
     * Instantiate script from stack.
     * @param {Stack} stack
     * @returns {Script}
     */
    static fromStack(v) {
      return new this().fromStack(v);
    }
    /**
     * Clone the script.
     * @returns {Script} Cloned script.
     */
    clone() {
      return new this.constructor().inject(this);
    }
    /**
     * Inject properties from script.
     * Used for cloning.
     * @private
     * @param {Script} script
     * @returns {Script}
     */
    inject(v) {
      return this.raw = v.raw, this.code = v.code.slice(), this;
    }
    /**
     * Test equality against script.
     * @param {Script} script
     * @returns {Boolean}
     */
    equals(v) {
      return e(T.isScript(v)), this.raw.equals(v.raw);
    }
    /**
     * Compare against another script.
     * @param {Script} script
     * @returns {Number}
     */
    compare(v) {
      return e(T.isScript(v)), this.raw.compare(v.raw);
    }
    /**
     * Clear the script.
     * @returns {Script}
     */
    clear() {
      return this.raw = G, this.code.length = 0, this;
    }
    /**
     * Inspect the script.
     * @returns {String} Human-readable script code.
     */
    inspect() {
      return `<Script: ${this.toString()}>`;
    }
    /**
     * Convert the script to a bitcoind test string.
     * @returns {String} Human-readable script code.
     */
    toString() {
      const v = [];
      for (const Y of this.code)
        v.push(Y.toFormat());
      return v.join(" ");
    }
    /**
     * Format the script as bitcoind asm.
     * @param {Boolean?} decode - Attempt to decode hash types.
     * @returns {String} Human-readable script.
     */
    toASM(v) {
      this.isNulldata() && (v = !1);
      const Y = [];
      for (const he of this.code)
        Y.push(he.toASM(v));
      return Y.join(" ");
    }
    /**
     * Re-encode the script internally. Useful if you
     * changed something manually in the `code` array.
     * @returns {Script}
     */
    compile() {
      if (this.code.length === 0)
        return this.clear();
      let v = 0;
      for (const he of this.code)
        v += he.getSize();
      const Y = c.write(v);
      for (const he of this.code)
        he.toWriter(Y);
      return this.raw = Y.render(), this;
    }
    /**
     * Write the script to a buffer writer.
     * @param {BufferWriter} bw
     */
    toWriter(v) {
      return v.writeVarBytes(this.raw), v;
    }
    /**
     * Encode the script to a Buffer. See {@link Script#encode}.
     * @param {String} enc - Encoding, either `'hex'` or `null`.
     * @returns {Buffer|String} Serialized script.
     */
    toRaw() {
      return this.raw;
    }
    /**
     * Convert script to a hex string.
     * @returns {String}
     */
    toJSON() {
      return this.toRaw().toString("hex");
    }
    /**
     * Inject properties from json object.
     * @private
     * @param {String} json
     */
    fromJSON(v) {
      return e(typeof v == "string", "Code must be a string."), this.fromRaw(k.from(v, "hex"));
    }
    /**
     * Instantiate script from a hex string.
     * @params {String} json
     * @returns {Script}
     */
    static fromJSON(v) {
      return new this().fromJSON(v);
    }
    /**
     * Get the script's "subscript" starting at a separator.
     * @param {Number} index - The last separator to sign/verify beyond.
     * @returns {Script} Subscript.
     */
    getSubscript(v) {
      if (v === 0)
        return this.clone();
      const Y = new T();
      for (let he = v; he < this.code.length; he++) {
        const le = this.code[he];
        if (le.value === -1)
          break;
        Y.code.push(le);
      }
      return Y.compile();
    }
    /**
     * Get the script's "subscript" starting at a separator.
     * Remove all OP_CODESEPARATORs if present. This bizarre
     * behavior is necessary for signing and verification when
     * code separators are present.
     * @returns {Script} Subscript.
     */
    removeSeparators() {
      let v = !1;
      for (const he of this.code) {
        if (he.value === -1)
          break;
        if (he.value === a.OP_CODESEPARATOR) {
          v = !0;
          break;
        }
      }
      if (!v)
        return this;
      const Y = new T();
      for (const he of this.code) {
        if (he.value === -1)
          break;
        he.value !== a.OP_CODESEPARATOR && Y.code.push(he);
      }
      return Y.compile();
    }
    /**
     * Get the value of the checkBits while calculated as little endian.
     * @param {Buffer} abkam - Stack depth of the dummy element.
     * @param {Number?} nKeysCount - Stack depth of the top pubkeys.
     * @returns {Number}
     */
    bitcalculator(v, Y) {
      let he = 0;
      const le = (Y + 7) / 8;
      for (let ge = 0; ge < le; ge++)
        he |= v[ge] << 8 * ge;
      return he;
    }
    /**
     * Execute and interpret the script.
     * @param {Stack} stack - Script execution stack.
     * @param {Number?} flags - Script standard flags.
     * @param {TX?} tx - Transaction being verified.
     * @param {Number?} index - Index of input being verified.
     * @param {Amount?} value - Previous output value.
     * @param {Number?} sigchecks
     * @throws {ScriptError} Will be thrown on VERIFY failures.
     */
    execute(v, Y, he, le, ge, Ee) {
      if (Y == null && (Y = T.flags.STANDARD_VERIFY_FLAGS), this.getSize() > o.MAX_SCRIPT_SIZE)
        throw new g("SCRIPT_SIZE");
      const we = [], z = [];
      let I = 0, ne = 0, t = 0, d, B = !1;
      Y & T.flags.VERIFY_MINIMALDATA && (B = !0);
      for (let U = 0; U < this.code.length; U++) {
        const J = this.code[U];
        if (J.value === -1)
          throw new g("BAD_OPCODE", J, U);
        if (J.data && J.data.length > o.MAX_SCRIPT_PUSH)
          throw new g("PUSH_SIZE", J, U);
        if (J.value > a.OP_16 && ++ne > o.MAX_SCRIPT_OPS)
          throw new g("OP_COUNT", J, U);
        if (J.isDisabled(Y))
          throw new g("DISABLED_OPCODE", J, U);
        if (t && !J.isBranch()) {
          if (v.length + z.length > o.MAX_SCRIPT_STACK)
            throw new g("STACK_SIZE", J, U);
          continue;
        }
        if (J.data && 0 <= J.value <= a.OP_PUSHDATA4) {
          if (B && !J.isMinimal())
            throw new g("MINIMALDATA", J, U);
          if (v.push(J.data), v.length + z.length > o.MAX_SCRIPT_STACK)
            throw new g("STACK_SIZE", J, U);
          continue;
        }
        switch (J.value) {
          case a.OP_0: {
            v.pushInt(0);
            break;
          }
          case a.OP_1NEGATE: {
            v.pushInt(-1);
            break;
          }
          case a.OP_1:
          case a.OP_2:
          case a.OP_3:
          case a.OP_4:
          case a.OP_5:
          case a.OP_6:
          case a.OP_7:
          case a.OP_8:
          case a.OP_9:
          case a.OP_10:
          case a.OP_11:
          case a.OP_12:
          case a.OP_13:
          case a.OP_14:
          case a.OP_15:
          case a.OP_16: {
            v.pushInt(J.value - 80);
            break;
          }
          case a.OP_NOP:
            break;
          case a.OP_CHECKLOCKTIMEVERIFY: {
            if (!(Y & T.flags.VERIFY_CHECKLOCKTIMEVERIFY)) {
              if (Y & T.flags.VERIFY_DISCOURAGE_UPGRADABLE_NOPS)
                throw new g("DISCOURAGE_UPGRADABLE_NOPS", J, U);
              break;
            }
            if (!he)
              throw new g("UNKNOWN_ERROR", "No TX passed in.");
            if (v.length === 0)
              throw new g("INVALID_STACK_OPERATION", J, U);
            const C = v.getNum(-1, B, 5);
            if (C.isNeg())
              throw new g("NEGATIVE_LOCKTIME", J, U);
            const M = C.toDouble();
            if (!he.verifyLocktime(le, M))
              throw new g("UNSATISFIED_LOCKTIME", J, U);
            break;
          }
          case a.OP_CHECKSEQUENCEVERIFY: {
            if (!(Y & T.flags.VERIFY_CHECKSEQUENCEVERIFY)) {
              if (Y & T.flags.VERIFY_DISCOURAGE_UPGRADABLE_NOPS)
                throw new g("DISCOURAGE_UPGRADABLE_NOPS", J, U);
              break;
            }
            if (!he)
              throw new g("UNKNOWN_ERROR", "No TX passed in.");
            if (v.length === 0)
              throw new g("INVALID_STACK_OPERATION", J, U);
            const C = v.getNum(-1, B, 5);
            if (C.isNeg())
              throw new g("NEGATIVE_LOCKTIME", J, U);
            const M = C.toDouble();
            if (!he.verifySequence(le, M))
              throw new g("UNSATISFIED_LOCKTIME", J, U);
            break;
          }
          case a.OP_NOP1:
          case a.OP_NOP4:
          case a.OP_NOP5:
          case a.OP_NOP6:
          case a.OP_NOP7:
          case a.OP_NOP8:
          case a.OP_NOP9:
          case a.OP_NOP10: {
            if (Y & T.flags.VERIFY_DISCOURAGE_UPGRADABLE_NOPS)
              throw new g("DISCOURAGE_UPGRADABLE_NOPS", J, U);
            break;
          }
          case a.OP_IF:
          case a.OP_NOTIF: {
            let C = !1;
            if (!t) {
              if (v.length < 1)
                throw new g("UNBALANCED_CONDITIONAL", J, U);
              if (Y & T.flags.VERIFY_MINIMALIF) {
                const M = v.get(-1);
                if (M.length > 1)
                  throw new g("MINIMALIF");
                if (M.length === 1 && M[0] !== 1)
                  throw new g("MINIMALIF");
              }
              C = v.getBool(-1), J.value === a.OP_NOTIF && (C = !C), v.pop();
            }
            we.push(C), C || (t += 1);
            break;
          }
          case a.OP_ELSE: {
            if (we.length === 0)
              throw new g("UNBALANCED_CONDITIONAL", J, U);
            we[we.length - 1] = !we[we.length - 1], we[we.length - 1] ? t -= 1 : t += 1;
            break;
          }
          case a.OP_ENDIF: {
            if (we.length === 0)
              throw new g("UNBALANCED_CONDITIONAL", J, U);
            we.pop() || (t -= 1);
            break;
          }
          case a.OP_VERIFY: {
            if (v.length === 0)
              throw new g("INVALID_STACK_OPERATION", J, U);
            if (!v.getBool(-1))
              throw new g("VERIFY", J, U);
            v.pop();
            break;
          }
          case a.OP_RETURN:
            throw new g("OP_RETURN", J, U);
          case a.OP_TOALTSTACK: {
            if (v.length === 0)
              throw new g("INVALID_STACK_OPERATION", J, U);
            z.push(v.pop());
            break;
          }
          case a.OP_FROMALTSTACK: {
            if (z.length === 0)
              throw new g("INVALID_ALTSTACK_OPERATION", J, U);
            v.push(z.pop());
            break;
          }
          case a.OP_2DROP: {
            if (v.length < 2)
              throw new g("INVALID_STACK_OPERATION", J, U);
            v.pop(), v.pop();
            break;
          }
          case a.OP_2DUP: {
            if (v.length < 2)
              throw new g("INVALID_STACK_OPERATION", J, U);
            const C = v.get(-2), M = v.get(-1);
            v.push(C), v.push(M);
            break;
          }
          case a.OP_3DUP: {
            if (v.length < 3)
              throw new g("INVALID_STACK_OPERATION", J, U);
            const C = v.get(-3), M = v.get(-2), $ = v.get(-1);
            v.push(C), v.push(M), v.push($);
            break;
          }
          case a.OP_2OVER: {
            if (v.length < 4)
              throw new g("INVALID_STACK_OPERATION", J, U);
            const C = v.get(-4), M = v.get(-3);
            v.push(C), v.push(M);
            break;
          }
          case a.OP_2ROT: {
            if (v.length < 6)
              throw new g("INVALID_STACK_OPERATION", J, U);
            const C = v.get(-6), M = v.get(-5);
            v.erase(-6, -4), v.push(C), v.push(M);
            break;
          }
          case a.OP_2SWAP: {
            if (v.length < 4)
              throw new g("INVALID_STACK_OPERATION", J, U);
            v.swap(-4, -2), v.swap(-3, -1);
            break;
          }
          case a.OP_IFDUP: {
            if (v.length === 0)
              throw new g("INVALID_STACK_OPERATION", J, U);
            if (v.getBool(-1)) {
              const C = v.get(-1);
              v.push(C);
            }
            break;
          }
          case a.OP_DEPTH: {
            v.pushInt(v.length);
            break;
          }
          case a.OP_DROP: {
            if (v.length === 0)
              throw new g("INVALID_STACK_OPERATION", J, U);
            v.pop();
            break;
          }
          case a.OP_DUP: {
            if (v.length === 0)
              throw new g("INVALID_STACK_OPERATION", J, U);
            v.push(v.get(-1));
            break;
          }
          case a.OP_NIP: {
            if (v.length < 2)
              throw new g("INVALID_STACK_OPERATION", J, U);
            v.remove(-2);
            break;
          }
          case a.OP_OVER: {
            if (v.length < 2)
              throw new g("INVALID_STACK_OPERATION", J, U);
            v.push(v.get(-2));
            break;
          }
          case a.OP_PICK:
          case a.OP_ROLL: {
            if (v.length < 2)
              throw new g("INVALID_STACK_OPERATION", J, U);
            const C = v.getInt(-1, B, 4);
            if (v.pop(), C < 0 || C >= v.length)
              throw new g("INVALID_STACK_OPERATION", J, U);
            const M = v.get(-C - 1);
            J.value === a.OP_ROLL && v.remove(-C - 1), v.push(M);
            break;
          }
          case a.OP_ROT: {
            if (v.length < 3)
              throw new g("INVALID_STACK_OPERATION", J, U);
            v.swap(-3, -2), v.swap(-2, -1);
            break;
          }
          case a.OP_SWAP: {
            if (v.length < 2)
              throw new g("INVALID_STACK_OPERATION", J, U);
            v.swap(-2, -1);
            break;
          }
          case a.OP_TUCK: {
            if (v.length < 2)
              throw new g("INVALID_STACK_OPERATION", J, U);
            v.insert(-2, v.get(-1));
            break;
          }
          case a.OP_SIZE: {
            if (v.length < 1)
              throw new g("INVALID_STACK_OPERATION", J, U);
            v.pushInt(v.get(-1).length);
            break;
          }
          case a.OP_EQUAL:
          case a.OP_EQUALVERIFY: {
            if (v.length < 2)
              throw new g("INVALID_STACK_OPERATION", J, U);
            const C = v.get(-2), M = v.get(-1), $ = C.equals(M);
            if (v.pop(), v.pop(), v.pushBool($), J.value === a.OP_EQUALVERIFY) {
              if (!$)
                throw new g("EQUALVERIFY", J, U);
              v.pop();
            }
            break;
          }
          case a.OP_1ADD:
          case a.OP_1SUB:
          case a.OP_NEGATE:
          case a.OP_ABS:
          case a.OP_NOT:
          case a.OP_0NOTEQUAL: {
            if (v.length < 1)
              throw new g("INVALID_STACK_OPERATION", J, U);
            let C = v.getNum(-1, B, 4), M;
            switch (J.value) {
              case a.OP_1ADD:
                C.iaddn(1);
                break;
              case a.OP_1SUB:
                C.isubn(1);
                break;
              case a.OP_NEGATE:
                C.ineg();
                break;
              case a.OP_ABS:
                C.iabs();
                break;
              case a.OP_NOT:
                M = C.isZero(), C = S.fromBool(M);
                break;
              case a.OP_0NOTEQUAL:
                M = !C.isZero(), C = S.fromBool(M);
                break;
              default:
                e(!1, "Fatal script error.");
                break;
            }
            v.pop(), v.pushNum(C);
            break;
          }
          case a.OP_ADD:
          case a.OP_SUB:
          case a.OP_DIV:
          case a.OP_MOD:
          case a.OP_BOOLAND:
          case a.OP_BOOLOR:
          case a.OP_NUMEQUAL:
          case a.OP_NUMEQUALVERIFY:
          case a.OP_NUMNOTEQUAL:
          case a.OP_LESSTHAN:
          case a.OP_GREATERTHAN:
          case a.OP_LESSTHANOREQUAL:
          case a.OP_GREATERTHANOREQUAL:
          case a.OP_MIN:
          case a.OP_MAX: {
            if (v.length < 2)
              throw new g("INVALID_STACK_OPERATION", J, U);
            const C = v.getNum(-2, B, 4), M = v.getNum(-1, B, 4);
            let $, r;
            switch (J.value) {
              case a.OP_ADD:
                $ = C.iadd(M);
                break;
              case a.OP_SUB:
                $ = C.isub(M);
                break;
              case a.OP_DIV:
                if (M.isZero())
                  throw new g("DIV_BY_ZERO", J, U);
                $ = C.div(M);
                break;
              case a.OP_MOD:
                if (M.isZero())
                  throw new g("MOD_BY_ZERO", J, U);
                $ = C.mod(M);
                break;
              case a.OP_BOOLAND:
                r = C.toBool() && M.toBool(), $ = S.fromBool(r);
                break;
              case a.OP_BOOLOR:
                r = C.toBool() || M.toBool(), $ = S.fromBool(r);
                break;
              case a.OP_NUMEQUAL:
                r = C.eq(M), $ = S.fromBool(r);
                break;
              case a.OP_NUMEQUALVERIFY:
                r = C.eq(M), $ = S.fromBool(r);
                break;
              case a.OP_NUMNOTEQUAL:
                r = !C.eq(M), $ = S.fromBool(r);
                break;
              case a.OP_LESSTHAN:
                r = C.lt(M), $ = S.fromBool(r);
                break;
              case a.OP_GREATERTHAN:
                r = C.gt(M), $ = S.fromBool(r);
                break;
              case a.OP_LESSTHANOREQUAL:
                r = C.lte(M), $ = S.fromBool(r);
                break;
              case a.OP_GREATERTHANOREQUAL:
                r = C.gte(M), $ = S.fromBool(r);
                break;
              case a.OP_MIN:
                $ = S.min(C, M);
                break;
              case a.OP_MAX:
                $ = S.max(C, M);
                break;
              default:
                e(!1, "Fatal script error.");
                break;
            }
            if (v.pop(), v.pop(), v.pushNum($), J.value === a.OP_NUMEQUALVERIFY) {
              if (!v.getBool(-1))
                throw new g("NUMEQUALVERIFY", J, U);
              v.pop();
            }
            break;
          }
          case a.OP_WITHIN: {
            if (v.length < 3)
              throw new g("INVALID_STACK_OPERATION", J, U);
            const C = v.getNum(-3, B, 4), M = v.getNum(-2, B, 4), $ = v.getNum(-1, B, 4), r = M.lte(C) && C.lt($);
            v.pop(), v.pop(), v.pop(), v.pushBool(r);
            break;
          }
          case a.OP_RIPEMD160: {
            if (v.length === 0)
              throw new g("INVALID_STACK_OPERATION", J, U);
            v.push(l.digest(v.pop()));
            break;
          }
          case a.OP_SHA1: {
            if (v.length === 0)
              throw new g("INVALID_STACK_OPERATION", J, U);
            v.push(w.digest(v.pop()));
            break;
          }
          case a.OP_SHA256: {
            if (v.length === 0)
              throw new g("INVALID_STACK_OPERATION", J, U);
            v.push(m.digest(v.pop()));
            break;
          }
          case a.OP_HASH160: {
            if (v.length === 0)
              throw new g("INVALID_STACK_OPERATION", J, U);
            v.push(f.digest(v.pop()));
            break;
          }
          case a.OP_HASH256: {
            if (v.length === 0)
              throw new g("INVALID_STACK_OPERATION", J, U);
            v.push(n.digest(v.pop()));
            break;
          }
          case a.OP_CODESEPARATOR: {
            I = U + 1;
            break;
          }
          case a.OP_CHECKSIG:
          case a.OP_CHECKSIGVERIFY: {
            if (!he)
              throw new g("UNKNOWN_ERROR", "No TX passed in.");
            if (v.length < 2)
              throw new g("INVALID_STACK_OPERATION", J, U);
            const C = v.get(-2), M = v.get(-1), $ = this.getSubscript(I);
            (!(Y & T.flags.VERIFY_SIGHASH_FORKID) || !(C[C.length - 1] & T.hashType.SIGHASH_FORKID)) && $.findAndDelete(C), R(C, Y), q(M, Y);
            let r = !1;
            if (C.length > 0) {
              const x = C[C.length - 1], O = he.signatureHash(
                le,
                $,
                ge,
                x,
                Y
              );
              r = Q(O, C.slice(0, -1), M, Y), N.sigchecks += 1, N.sigchecks;
            }
            if (!r && Y & T.flags.VERIFY_NULLFAIL && C.length !== 0)
              throw new g("NULLFAIL", J, U);
            if (v.pop(), v.pop(), v.pushBool(r), J.value === a.OP_CHECKSIGVERIFY) {
              if (!r)
                throw new g("CHECKSIGVERIFY", J, U);
              v.pop();
            }
            break;
          }
          case a.OP_CHECKDATASIG:
          case a.OP_CHECKDATASIGVERIFY: {
            if (v.length < 3)
              throw new g("INVALID_STACK_OPERATION", J, U);
            const C = v.get(-3), M = v.get(-2), $ = v.get(-1);
            ue(C, Y), q($, Y);
            let r = !1;
            if (C.length > 0) {
              const x = m.digest(M);
              r = Q(x, C, $, Y), N.sigchecks += 1, N.sigchecks;
            }
            if (!r && Y & T.flags.VERIFY_NULLFAIL && C.length !== 0)
              throw new g("NULLFAIL", J, U);
            if (v.pop(), v.pop(), v.pop(), v.pushBool(r), J.value === a.OP_CHECKDATASIGVERIFY) {
              if (!r)
                throw new g("CHECKDATASIGVERIFY", J, U);
              v.pop();
            }
            break;
          }
          case a.OP_CHECKMULTISIG:
          case a.OP_CHECKMULTISIGVERIFY: {
            if (!he)
              throw new g("UNKNOWN_ERROR", "No TX passed in.");
            let C = 1, M = 0, $, r;
            if (v.length < C)
              throw new g("INVALID_STACK_OPERATION", J, U);
            let x = v.getInt(-C, B, 4), O = x + 2, K, X;
            if (x < 0 || x > o.MAX_MULTISIG_PUBKEYS)
              throw new g("PUBKEY_COUNT", J, U);
            if (ne += x, ne > o.MAX_SCRIPT_OPS)
              throw new g("OP_COUNT", J, U);
            if (C += 1, $ = C, M = $ + x, K = C, C += x, v.length < M)
              throw new g("INVALID_STACK_OPERATION", J, U);
            let P = v.getInt(-M, B, 4);
            if (P < 0 || P > x)
              throw new g("SIG_COUNT", J, U);
            r = M + 1;
            const V = r + P;
            if (v.length < V)
              throw new g("INVALID_STACK_OPERATION", J, U);
            C += 1, X = C, C += P;
            const re = this.getSubscript(I);
            let ce = !0;
            if (Y & T.flags.VERIFY_SCHNORR_MULTISIG && v.get(-V).length !== 0) {
              if (e(o.MAX_MULTISIG_PUBKEYS < 32), x > 32)
                throw new g("INVALID_BITFIELD_SIZE", J, U);
              const de = Math.floor((x + 7) / 8), pe = v.get(-V);
              if (pe.length !== de)
                throw new g("BITFIELD_SIZE", J, U);
              d = this.bitcalculator(pe, x);
              const se = (1 << x) - 1, Z = H(d);
              if ((d & se) !== d)
                throw new g("BIT_RANGE", J, U);
              if (Z !== P)
                throw new g("INVALID_BIT_COUNT", J, U);
              const ee = $ + x - 1, me = r + P - 1;
              let Ae = 0;
              for (let Oe = 0; Oe < P; Oe++, Ae++) {
                if (d >> Ae === 0)
                  throw new g("INVALID_BIT_RANGE", J, U);
                for (; (d >> Ae & 1) === 0; )
                  Ae++;
                if (Ae >= x)
                  throw new g("PUBKEY_COUNT", J, U);
                const ye = v.get(-me + Oe), _e = v.get(-ee + Ae);
                if (ye) {
                  if (L(ye, Y), q(_e, Y), ye.length > 0) {
                    const ke = ye[ye.length - 1], Me = he.signatureHash(
                      le,
                      re,
                      ge,
                      ke,
                      Y
                    );
                    ce = Q(Me, ye.slice(0, -1), _e, Y), N.sigchecks += 1, N.sigchecks;
                  }
                  for (; C > 1; ) {
                    if (!ce && Y & T.flags.VERIFY_NULLFAIL && O === 0 && v.get(-1).length !== 0)
                      throw new g("NULLFAIL", J, U);
                    O > 0 && (O -= 1), v.pop(), C -= 1;
                  }
                }
              }
              if (d >> Ae !== 0)
                throw new g("INVALID_BIT_COUNT", J, U);
              v.pop(), v.pushBool(ce);
            } else {
              for (let de = 0; de < P; de++) {
                const pe = v.get(-r - de);
                (!(Y & T.flags.VERIFY_SIGHASH_FORKID) || !(pe[pe.length - 1] & T.hashType.SIGHASH_FORKID)) && re.findAndDelete(pe, Y);
              }
              for (; ce && P > 0; ) {
                const de = v.get(-X), pe = v.get(-K);
                if (fe(de, Y), q(pe, Y), de.length > 0) {
                  const se = de[de.length - 1], Z = he.signatureHash(
                    le,
                    re,
                    ge,
                    se,
                    Y
                  );
                  W(Z, de, pe) && (X += 1, P -= 1);
                }
                K += 1, x -= 1, P > x && (ce = !1);
              }
              for (; C > 1; ) {
                if (!ce && Y & T.flags.VERIFY_NULLFAIL && O === 0 && v.get(-1).length !== 0)
                  throw new g("NULLFAIL", J, U);
                O > 0 && (O -= 1), v.pop(), C -= 1;
              }
              if (v.length < 1)
                throw new g("INVALID_STACK_OPERATION", J, U);
              if (v.pop(), v.pushBool(ce), J.value === a.OP_CHECKMULTISIGVERIFY) {
                if (!ce)
                  throw new g("CHECKMULTISIGVERIFY", J, U);
                v.pop();
              }
            }
            break;
          }
          //
          // Byte string operations
          //
          case a.OP_CAT: {
            if (v.length < 2)
              throw new g("INVALID_STACK_OPERATION", J, U);
            const C = v.get(-2), M = v.get(-1);
            if (C.length + M.length > o.MAX_SCRIPT_PUSH)
              throw new g("PUSH_SIZE", J, U);
            v.pop(), v.pop(), v.push(k.concat([C, M]));
            break;
          }
          case a.OP_SPLIT: {
            if (v.length < 2)
              throw new g("INVALID_STACK_OPERATION", J, U);
            const C = v.get(-2), M = v.getInt(-1, B, 4);
            if (M < 0 || M > C.length)
              throw new g("INVALID_SPLIT_RANGE", J, U);
            const $ = C.slice(0, M), r = C.slice(M);
            v.set(-2, $), v.set(-1, r);
            break;
          }
          case a.OP_REVERSEBYTES: {
            if (v.length < 1)
              throw new g("INVALID_STACK_OPERATION", J, U);
            v.get(-1).reverse();
            break;
          }
          //
          // Bitwise logic
          //
          case a.OP_AND:
          case a.OP_OR:
          case a.OP_XOR: {
            if (v.length < 2)
              throw new g("INVALID_STACK_OPERATION", J, U);
            const C = v.get(-2), M = v.get(-1);
            if (C.length !== M.length)
              throw new g("INVALID_OPERAND_SIZE", J, U);
            const $ = k.alloc(C.length);
            switch (J.value) {
              case a.OP_AND:
                for (let r = 0; r < C.length; r++)
                  $[r] = C[r] & M[r];
                break;
              case a.OP_OR:
                for (let r = 0; r < C.length; r++)
                  $[r] = C[r] | M[r];
                break;
              case a.OP_XOR:
                for (let r = 0; r < C.length; r++)
                  $[r] = C[r] ^ M[r];
                break;
            }
            v.pop(), v.pop(), v.push($);
            break;
          }
          //
          // Conversion operations
          //
          case a.OP_NUM2BIN: {
            if (v.length < 2)
              throw new g("INVALID_STACK_OPERATION", J, U);
            const C = v.getInt(-1, B, 4);
            if (C < 0 || C > o.MAX_SCRIPT_PUSH)
              throw new g("PUSH_SIZE", J, U);
            v.pop();
            const M = v.get(-1), $ = S.toMinimal(k.from(M));
            if ($.length > C)
              throw new g("IMPOSSIBLE_ENCODING", J, U);
            if ($.length === C) {
              v.pop(), v.push($);
              break;
            }
            const r = k.alloc(C);
            $.copy(r);
            let x = 0;
            $.length > 0 && (x = $[$.length - 1] & 128, r[$.length - 1] &= 127), r[C - 1] = x, v.pop(), v.push(r);
            break;
          }
          case a.OP_BIN2NUM: {
            if (v.length < 1)
              throw new g("INVALID_STACK_OPERATION", J, U);
            const C = v.get(-1), M = S.toMinimal(k.from(C));
            if (v.pop(), v.push(M), !S.isMinimal(M) || M.length > 4)
              throw new g("INVALID_NUMBER_RANGE", J, U);
            break;
          }
          default:
            throw new g("BAD_OPCODE", J, U);
        }
      }
      if (v.length + z.length > o.MAX_SCRIPT_STACK)
        throw new g("STACK_SIZE");
      if (we.length !== 0)
        throw new g("UNBALANCED_CONDITIONAL");
    }
    /**
     * Remove all matched data elements from
     * a script's code (used to remove signatures
     * before verification). Note that this
     * compares and removes data on the _byte level_.
     * It also reserializes the data to a single
     * script with minimaldata encoding beforehand.
     * A signature will _not_ be removed if it is
     * not minimaldata.
     * @see https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2014-November/006878.html
     * @see https://test.webbtc.com/tx/19aa42fee0fa57c45d3b16488198b27caaacc4ff5794510d0c17f173f05587ff
     * @param {Buffer} data - Data element to match against.
     * @returns {Number} Total.
     */
    findAndDelete(v) {
      const Y = i.fromPush(v);
      if (this.raw.length < Y.getSize())
        return 0;
      let he = !1;
      for (const Ee of this.code) {
        if (Ee.value === -1)
          break;
        if (Ee.equals(Y)) {
          he = !0;
          break;
        }
      }
      if (!he)
        return 0;
      const le = [];
      let ge = 0;
      for (const Ee of this.code) {
        if (Ee.value === -1)
          break;
        if (Ee.equals(Y)) {
          ge += 1;
          continue;
        }
        le.push(Ee);
      }
      return this.code = le, this.compile(), ge;
    }
    /**
     * Find a data element in a script.
     * @param {Buffer} data - Data element to match against.
     * @returns {Number} Index (`-1` if not present).
     */
    indexOf(v) {
      for (let Y = 0; Y < this.code.length; Y++) {
        const he = this.code[Y];
        if (he.value === -1)
          break;
        if (he.data && he.data.equals(v))
          return Y;
      }
      return -1;
    }
    /**
     * Test a script to see if it is likely
     * to be script code (no weird opcodes).
     * @param {Number?} flags - Script standard flags.
     * @returns {Boolean}
     */
    isCode(v) {
      v == null && (v = T.flags.STANDARD_VERIFY_FLAGS);
      for (const Y of this.code) {
        if (Y.value === -1 || Y.isDisabled(v))
          return !1;
        switch (Y.value) {
          case a.OP_RESERVED:
          case a.OP_NOP:
          case a.OP_VER:
          case a.OP_VERIF:
          case a.OP_VERNOTIF:
          case a.OP_RESERVED1:
          case a.OP_RESERVED2:
          case a.OP_NOP1:
            return !1;
        }
        if (Y.value > a.OP_CHECKSEQUENCEVERIFY)
          return !1;
      }
      return !0;
    }
    /**
     * Inject properties from a pay-to-pubkey script.
     * @private
     * @param {Buffer} key
     */
    fromPubkey(v) {
      return e(k.isBuffer(v) && (v.length === 33 || v.length === 65)), this.raw = k.allocUnsafe(1 + v.length + 1), this.raw[0] = v.length, v.copy(this.raw, 1), this.raw[1 + v.length] = a.OP_CHECKSIG, v = this.raw.slice(1, 1 + v.length), this.code.length = 0, this.code.push(i.fromPush(v)), this.code.push(i.fromOp(a.OP_CHECKSIG)), this;
    }
    /**
     * Create a pay-to-pubkey script.
     * @param {Buffer} key
     * @returns {Script}
     */
    static fromPubkey(v) {
      return new this().fromPubkey(v);
    }
    /**
     * Inject properties from a pay-to-pubkeyhash script.
     * @private
     * @param {Buffer} hash
     */
    fromPubkeyhash(v) {
      return e(k.isBuffer(v) && v.length === 20), this.raw = k.allocUnsafe(25), this.raw[0] = a.OP_DUP, this.raw[1] = a.OP_HASH160, this.raw[2] = 20, v.copy(this.raw, 3), this.raw[23] = a.OP_EQUALVERIFY, this.raw[24] = a.OP_CHECKSIG, v = this.raw.slice(3, 23), this.code.length = 0, this.code.push(i.fromOp(a.OP_DUP)), this.code.push(i.fromOp(a.OP_HASH160)), this.code.push(i.fromPush(v)), this.code.push(i.fromOp(a.OP_EQUALVERIFY)), this.code.push(i.fromOp(a.OP_CHECKSIG)), this;
    }
    /**
     * Create a pay-to-pubkeyhash script.
     * @param {Buffer} hash
     * @returns {Script}
     */
    static fromPubkeyhash(v) {
      return new this().fromPubkeyhash(v);
    }
    /**
     * Inject properties from pay-to-multisig script.
     * @private
     * @param {Number} m
     * @param {Number} n
     * @param {Buffer[]} keys
     */
    fromMultisig(v, Y, he) {
      e((v & 255) === v && (Y & 255) === Y), e(Array.isArray(he)), e(he.length === Y, "`n` keys are required for multisig."), e(v >= 1 && v <= Y), e(Y >= 1 && Y <= 15), this.clear(), this.pushSmall(v);
      for (const le of A(he))
        this.pushData(le);
      return this.pushSmall(Y), this.pushOp(a.OP_CHECKMULTISIG), this.compile();
    }
    /**
     * Create a pay-to-multisig script.
     * @param {Number} m
     * @param {Number} n
     * @param {Buffer[]} keys
     * @returns {Script}
     */
    static fromMultisig(v, Y, he) {
      return new this().fromMultisig(v, Y, he);
    }
    /**
     * Inject properties from a pay-to-scripthash script.
     * @private
     * @param {Buffer} hash
     */
    fromScripthash(v) {
      return e(k.isBuffer(v) && v.length === 20), this.raw = k.allocUnsafe(23), this.raw[0] = a.OP_HASH160, this.raw[1] = 20, v.copy(this.raw, 2), this.raw[22] = a.OP_EQUAL, v = this.raw.slice(2, 22), this.code.length = 0, this.code.push(i.fromOp(a.OP_HASH160)), this.code.push(i.fromPush(v)), this.code.push(i.fromOp(a.OP_EQUAL)), this;
    }
    /**
     * Create a pay-to-scripthash script.
     * @param {Buffer} hash
     * @returns {Script}
     */
    static fromScripthash(v) {
      return new this().fromScripthash(v);
    }
    /**
     * Inject properties from a nulldata/opreturn script.
     * @private
     * @param {Buffer} flags
     */
    fromNulldata(v) {
      return e(k.isBuffer(v)), e(v.length <= s.MAX_OP_RETURN, "Nulldata too large."), this.clear(), this.pushOp(a.OP_RETURN), this.pushData(v), this.compile();
    }
    /**
     * Create a nulldata/opreturn script.
     * @param {Buffer} flags
     * @returns {Script}
     */
    static fromNulldata(v) {
      return new this().fromNulldata(v);
    }
    /**
     * Inject properties from an address.
     * @private
     * @param {Address|AddressString} address
     */
    fromAddress(v) {
      if (typeof v == "string" && (v = b.fromString(v)), e(v instanceof b, "Not an address."), v.isPubkeyhash())
        return this.fromPubkeyhash(v.hash);
      if (v.isScripthash())
        return this.fromScripthash(v.hash);
      throw new Error("Unknown address type.");
    }
    /**
     * Create an output script from an address.
     * @param {Address|AddressString} address
     * @returns {Script}
     */
    static fromAddress(v) {
      return new this().fromAddress(v);
    }
    /**
     * Grab and deserialize the redeem script.
     * @returns {Script|null} Redeem script.
     */
    getRedeem() {
      let v = null;
      for (const Y of this.code) {
        if (Y.value === -1 || Y.value > a.OP_16)
          return null;
        v = Y.data;
      }
      return v ? T.fromRaw(v) : null;
    }
    /**
     * Get the standard script type.
     * @returns {ScriptType}
     */
    getType() {
      return this.isPubkey() ? E.PUBKEY : this.isPubkeyhash() ? E.PUBKEYHASH : this.isScripthash() ? E.SCRIPTHASH : this.isMultisig() ? E.MULTISIG : this.isNulldata() ? E.NULLDATA : E.NONSTANDARD;
    }
    /**
     * Test whether a script is of an unknown/non-standard type.
     * @returns {Boolean}
     */
    isUnknown() {
      return this.getType() === E.NONSTANDARD;
    }
    /**
     * Test whether the script is standard by policy standards.
     * @returns {Boolean}
     */
    isStandard() {
      const [v, Y] = this.getMultisig();
      return v !== -1 ? !(Y < 1 || Y > 3 || v < 1 || v > Y) : this.isNulldata() ? this.raw.length <= s.MAX_OP_RETURN_BYTES : this.getType() !== E.NONSTANDARD;
    }
    /**
     * Calculate the size of the script
     * excluding the varint size bytes.
     * @returns {Number}
     */
    getSize() {
      return this.raw.length;
    }
    /**
     * Calculate the size of the script
     * including the varint size bytes.
     * @returns {Number}
     */
    getVarSize() {
      return j.sizeVarBytes(this.raw);
    }
    /**
     * "Guess" the address of the input script.
     * This method is not 100% reliable.
     * @returns {Address|null}
     */
    getInputAddress() {
      return b.fromInputScript(this);
    }
    /**
     * Get the address of the script if present. Note that
     * pubkey and multisig scripts will be treated as though
     * they are pubkeyhash and scripthashes respectively.
     * @returns {Address|null}
     */
    getAddress() {
      return b.fromScript(this);
    }
    /**
     * Get the hash160 of the raw script.
     * @param {String?} enc
     * @returns {Hash}
     */
    hash160(v) {
      let Y = f.digest(this.toRaw());
      return v === "hex" && (Y = Y.toString("hex")), Y;
    }
    /**
     * Get the sha256 of the raw script.
     * @param {String?} enc
     * @returns {Hash}
     */
    sha256(v) {
      let Y = m.digest(this.toRaw());
      return v === "hex" && (Y = Y.toString("hex")), Y;
    }
    /**
     * Test whether the output script is pay-to-pubkey.
     * @param {Boolean} [minimal=false] - Minimaldata only.
     * @returns {Boolean}
     */
    isPubkey(v) {
      if (v)
        return this.raw.length >= 35 && (this.raw[0] === 33 || this.raw[0] === 65) && this.raw[0] + 2 === this.raw.length && this.raw[this.raw.length - 1] === a.OP_CHECKSIG;
      if (this.code.length !== 2)
        return !1;
      const Y = this.getLength(0);
      return (Y === 33 || Y === 65) && this.getOp(1) === a.OP_CHECKSIG;
    }
    /**
     * Get P2PK key if present.
     * @param {Boolean} [minimal=false] - Minimaldata only.
     * @returns {Buffer|null}
     */
    getPubkey(v) {
      return this.isPubkey(v) ? v ? this.raw.slice(1, 1 + this.raw[0]) : this.getData(0) : null;
    }
    /**
     * Test whether the output script is pay-to-pubkeyhash.
     * @param {Boolean} [minimal=false] - Minimaldata only.
     * @returns {Boolean}
     */
    isPubkeyhash(v) {
      return v || this.raw.length === 25 ? this.raw.length === 25 && this.raw[0] === a.OP_DUP && this.raw[1] === a.OP_HASH160 && this.raw[2] === 20 && this.raw[23] === a.OP_EQUALVERIFY && this.raw[24] === a.OP_CHECKSIG : this.code.length !== 5 ? !1 : this.getOp(0) === a.OP_DUP && this.getOp(1) === a.OP_HASH160 && this.getLength(2) === 20 && this.getOp(3) === a.OP_EQUALVERIFY && this.getOp(4) === a.OP_CHECKSIG;
    }
    /**
     * Get P2PKH hash if present.
     * @param {Boolean} [minimal=false] - Minimaldata only.
     * @returns {Buffer|null}
     */
    getPubkeyhash(v) {
      return this.isPubkeyhash(v) ? v ? this.raw.slice(3, 23) : this.getData(2) : null;
    }
    /**
       * Test whether the output script is pay-to-multisig.
       * @param {Boolean} [minimal=true] - Minimaldata only.
       * @returns {Boolean}
       */
    isMultisig(v) {
      if (this.code.length < 4 || this.code.length > 19 || this.getOp(-1) !== a.OP_CHECKMULTISIG)
        return !1;
      const Y = this.getSmall(0);
      if (Y < 1)
        return !1;
      const he = this.getSmall(-2);
      if (he < 1 || Y > he || this.code.length !== he + 3)
        return !1;
      for (let le = 1; le < he + 1; le++) {
        const ge = this.code[le], Ee = ge.toLength();
        if (Ee !== 33 && Ee !== 65 || v && !ge.isMinimal())
          return !1;
      }
      return !0;
    }
    /**
     * Get multisig m and n values if present.
     * @param {Boolean} [minimal=false] - Minimaldata only.
     * @returns {Array} [m, n]
     */
    getMultisig(v) {
      return this.isMultisig(v) ? [this.getSmall(0), this.getSmall(-2)] : [-1, -1];
    }
    /**
     * Test whether the output script is pay-to-scripthash. Note that
     * bitcoin itself requires scripthashes to be in strict minimaldata
     * encoding. Using `OP_HASH160 OP_PUSHDATA1 [hash] OP_EQUAL` will
     * _not_ be recognized as a scripthash.
     * @returns {Boolean}
     */
    isScripthash() {
      return this.raw.length === 23 && this.raw[0] === a.OP_HASH160 && this.raw[1] === 20 && this.raw[22] === a.OP_EQUAL;
    }
    /**
     * Get P2SH hash if present.
     * @returns {Buffer|null}
     */
    getScripthash() {
      return this.isScripthash() ? this.getData(1) : null;
    }
    /**
     * Test whether the output script is nulldata/opreturn.
     * @param {Boolean} [minimal=false] - Minimaldata only.
     * @returns {Boolean}
     */
    isNulldata(v) {
      if (this.code.length === 0 || this.getOp(0) !== a.OP_RETURN)
        return !1;
      if (this.code.length === 1)
        return !0;
      if (v && this.raw.length > s.MAX_OP_RETURN_BYTES)
        return !1;
      for (let Y = 1; Y < this.code.length; Y++) {
        const he = this.code[Y];
        if (he.value === -1 || he.value > a.OP_16 || v && !he.isMinimal())
          return !1;
      }
      return !0;
    }
    /**
     * Get OP_RETURN data if present.
     * @param {Boolean} [minimal=false] - Minimaldata only.
     * @returns {Buffer|null}
     */
    getNulldata(v) {
      if (!this.isNulldata(v))
        return null;
      for (let Y = 1; Y < this.code.length; Y++) {
        const le = this.code[Y].toPush();
        if (le)
          return le;
      }
      return G;
    }
    /**
     * Test whether the output script is a witness program.
     * Note that this will return true even for malformed
     * witness v0 programs.
     * @returns {Boolean}
     */
    isProgram() {
      return !(this.raw.length < 4 || this.raw.length > 42 || this.raw[0] !== a.OP_0 && (this.raw[0] < a.OP_1 || this.raw[0] > a.OP_16) || this.raw[1] + 2 !== this.raw.length);
    }
    /**
     * Test whether the output script is unspendable.
     * @returns {Boolean}
     */
    isUnspendable() {
      return this.raw.length > o.MAX_SCRIPT_SIZE ? !0 : this.raw.length > 0 && this.raw[0] === a.OP_RETURN;
    }
    /**
     * "Guess" the type of the input script.
     * This method is not 100% reliable.
     * @returns {ScriptType}
     */
    getInputType() {
      return this.isPubkeyInput() ? E.PUBKEY : this.isPubkeyhashInput() ? E.PUBKEYHASH : this.isScripthashInput() ? E.SCRIPTHASH : this.isMultisigInput() ? E.MULTISIG : E.NONSTANDARD;
    }
    /**
     * "Guess" whether the input script is an unknown/non-standard type.
     * This method is not 100% reliable.
     * @returns {Boolean}
     */
    isUnknownInput() {
      return this.getInputType() === E.NONSTANDARD;
    }
    /**
     * "Guess" whether the input script is pay-to-pubkey.
     * This method is not 100% reliable.
     * @returns {Boolean}
     */
    isPubkeyInput() {
      if (this.code.length !== 1)
        return !1;
      const v = this.getLength(0);
      return v >= 9 && v <= 73;
    }
    /**
     * Get P2PK signature if present.
     * @returns {Buffer|null}
     */
    getPubkeyInput() {
      return this.isPubkeyInput() ? this.getData(0) : null;
    }
    /**
     * "Guess" whether the input script is pay-to-pubkeyhash.
     * This method is not 100% reliable.
     * @returns {Boolean}
     */
    isPubkeyhashInput() {
      if (this.code.length !== 2)
        return !1;
      const v = this.getLength(0), Y = this.getLength(1);
      return v >= 9 && v <= 73 && (Y === 33 || Y === 65);
    }
    /**
     * Get P2PKH signature and key if present.
     * @returns {Array} [sig, key]
     */
    getPubkeyhashInput() {
      return this.isPubkeyhashInput() ? [this.getData(0), this.getData(1)] : [null, null];
    }
    /**
     * "Guess" whether the input script is pay-to-multisig.
     * This method is not 100% reliable.
     * @returns {Boolean}
     */
    isMultisigInput() {
      if (this.code.length < 2 || this.getOp(0) !== a.OP_0 || this.getOp(1) > a.OP_PUSHDATA4 || this.isScripthashInput())
        return !1;
      for (let v = 1; v < this.code.length; v++) {
        const Y = this.getLength(v);
        if (Y < 9 || Y > 73)
          return !1;
      }
      return !0;
    }
    /**
     * Get multisig signatures if present.
     * @returns {Buffer[]|null}
     */
    getMultisigInput() {
      if (!this.isMultisigInput())
        return null;
      const v = [];
      for (let Y = 1; Y < this.code.length; Y++)
        v.push(this.getData(Y));
      return v;
    }
    /**
     * "Guess" whether the input script is pay-to-scripthash.
     * This method is not 100% reliable.
     * @returns {Boolean}
     */
    isScripthashInput() {
      if (this.code.length < 1)
        return !1;
      const v = this.getData(-1);
      if (!v || v.length === 0 || y.isDERSignatureEncoding(v.slice(0, -1)) || y.isKeyEncoding(v))
        return !1;
      const Y = T.fromRaw(v);
      return !(!Y.isCode() || Y.isUnspendable() || !this.isPushOnly());
    }
    /**
     * Get P2SH redeem script if present.
     * @returns {Buffer|null}
     */
    getScripthashInput() {
      return this.isScripthashInput() ? this.getData(-1) : null;
    }
    /**
     * Get coinbase height.
     * @returns {Number} `-1` if not present.
     */
    getCoinbaseHeight() {
      return T.getCoinbaseHeight(this.raw);
    }
    /**
     * Get coinbase height.
     * @param {Buffer} raw - Raw script.
     * @returns {Number} `-1` if not present.
     */
    static getCoinbaseHeight(v) {
      if (v.length === 0)
        return -1;
      if (v[0] >= a.OP_1 && v[0] <= a.OP_16)
        return v[0] - 80;
      if (v[0] > 6)
        return -1;
      const Y = i.fromRaw(v), he = Y.toNum();
      return he ? he.isNeg() || !Y.equals(i.fromNum(he)) ? -1 : he.toDouble() : 1;
    }
    /**
     * Test the script against a bloom filter.
     * @param {Bloom} filter
     * @returns {Boolean}
     */
    test(v) {
      for (const Y of this.code) {
        if (Y.value === -1)
          break;
        if (!(!Y.data || Y.data.length === 0) && v.test(Y.data))
          return !0;
      }
      return !1;
    }
    /**
     * Test the script to see if it contains only push ops.
     * Push ops are: OP_1NEGATE, OP_0-OP_16 and all PUSHDATAs.
     * @returns {Boolean}
     */
    isPushOnly() {
      for (const v of this.code)
        if (v.value === -1 || v.value > a.OP_16)
          return !1;
      return !0;
    }
    /**
     * Count the sigops in the script.
     * @param {Boolean} accurate - Whether to enable accurate counting. This will
     * take into account the `n` value for OP_CHECKMULTISIG(VERIFY).
     * @returns {Number} sigop count
     */
    getSigops(v, Y) {
      if (Y & T.flags.VERIFY_ZERO_SIGOPS)
        return 0;
      let he = 0, le = -1;
      for (const ge of this.code) {
        if (ge.value === -1)
          break;
        switch (ge.value) {
          case a.OP_CHECKSIG:
          case a.OP_CHECKSIGVERIFY:
            he += 1;
            break;
          case a.OP_CHECKSDATAIG:
          case a.OP_CHECKDATASIGVERIFY:
            Y & T.flags.VERIFY_CHECKDATASIG && (he += 1);
            break;
          case a.OP_CHECKMULTISIG:
          case a.OP_CHECKMULTISIGVERIFY:
            v && le >= a.OP_1 && le <= a.OP_16 ? he += le - 80 : he += o.MAX_MULTISIG_PUBKEYS;
            break;
        }
        le = ge.value;
      }
      return he;
    }
    /**
     * Count the sigops in the script, taking into account redeem scripts.
     * @param {Script} input - Input script, needed for access to redeem script.
     * @param {VerifyFlags} flags
     * @returns {Number} sigop count
     */
    getScripthashSigops(v, Y) {
      if (!this.isScripthash())
        return this.getSigops(!0, Y);
      const he = v.getRedeem();
      return he ? he.getSigops(!0, Y) : 0;
    }
    /*
     * Mutation
     */
    get(v) {
      return v < 0 && (v += this.code.length), v < 0 || v >= this.code.length ? null : this.code[v];
    }
    pop() {
      return this.code.pop() || null;
    }
    shift() {
      return this.code.shift() || null;
    }
    remove(v) {
      if (v < 0 && (v += this.code.length), v < 0 || v >= this.code.length)
        return null;
      const Y = this.code.splice(v, 1);
      return Y.length === 0 ? null : Y[0];
    }
    set(v, Y) {
      return v < 0 && (v += this.code.length), e(i.isOpcode(Y)), e(v >= 0 && v <= this.code.length), this.code[v] = Y, this;
    }
    push(v) {
      return e(i.isOpcode(v)), this.code.push(v), this;
    }
    unshift(v) {
      return e(i.isOpcode(v)), this.code.unshift(v), this;
    }
    insert(v, Y) {
      return v < 0 && (v += this.code.length), e(i.isOpcode(Y)), e(v >= 0 && v <= this.code.length), this.code.splice(v, 0, Y), this;
    }
    /*
     * Op
     */
    getOp(v) {
      const Y = this.get(v);
      return Y ? Y.value : -1;
    }
    popOp() {
      const v = this.pop();
      return v ? v.value : -1;
    }
    shiftOp() {
      const v = this.shift();
      return v ? v.value : -1;
    }
    removeOp(v) {
      const Y = this.remove(v);
      return Y ? Y.value : -1;
    }
    setOp(v, Y) {
      return this.set(v, i.fromOp(Y));
    }
    pushOp(v) {
      return this.push(i.fromOp(v));
    }
    unshiftOp(v) {
      return this.unshift(i.fromOp(v));
    }
    insertOp(v, Y) {
      return this.insert(v, i.fromOp(Y));
    }
    /*
     * Data
     */
    getData(v) {
      const Y = this.get(v);
      return Y ? Y.data : null;
    }
    popData() {
      const v = this.pop();
      return v ? v.data : null;
    }
    shiftData() {
      const v = this.shift();
      return v ? v.data : null;
    }
    removeData(v) {
      const Y = this.remove(v);
      return Y ? Y.data : null;
    }
    setData(v, Y) {
      return this.set(v, i.fromData(Y));
    }
    pushData(v) {
      return this.push(i.fromData(v));
    }
    unshiftData(v) {
      return this.unshift(i.fromData(v));
    }
    insertData(v, Y) {
      return this.insert(v, i.fromData(Y));
    }
    /*
     * Length
     */
    getLength(v) {
      const Y = this.get(v);
      return Y ? Y.toLength() : -1;
    }
    /*
     * Push
     */
    getPush(v) {
      const Y = this.get(v);
      return Y ? Y.toPush() : null;
    }
    popPush() {
      const v = this.pop();
      return v ? v.toPush() : null;
    }
    shiftPush() {
      const v = this.shift();
      return v ? v.toPush() : null;
    }
    removePush(v) {
      const Y = this.remove(v);
      return Y ? Y.toPush() : null;
    }
    setPush(v, Y) {
      return this.set(v, i.fromPush(Y));
    }
    pushPush(v) {
      return this.push(i.fromPush(v));
    }
    unshiftPush(v) {
      return this.unshift(i.fromPush(v));
    }
    insertPush(v, Y) {
      return this.insert(v, i.fromPush(Y));
    }
    /*
     * String
     */
    getString(v, Y) {
      const he = this.get(v);
      return he ? he.toString(Y) : null;
    }
    popString(v) {
      const Y = this.pop();
      return Y ? Y.toString(v) : null;
    }
    shiftString(v) {
      const Y = this.shift();
      return Y ? Y.toString(v) : null;
    }
    removeString(v, Y) {
      const he = this.remove(v);
      return he ? he.toString(Y) : null;
    }
    setString(v, Y, he) {
      return this.set(v, i.fromString(Y, he));
    }
    pushString(v, Y) {
      return this.push(i.fromString(v, Y));
    }
    unshiftString(v, Y) {
      return this.unshift(i.fromString(v, Y));
    }
    insertString(v, Y, he) {
      return this.insert(v, i.fromString(Y, he));
    }
    /*
     * Small
     */
    getSmall(v) {
      const Y = this.get(v);
      return Y ? Y.toSmall() : -1;
    }
    popSmall() {
      const v = this.pop();
      return v ? v.toSmall() : -1;
    }
    shiftSmall() {
      const v = this.shift();
      return v ? v.toSmall() : -1;
    }
    removeSmall(v) {
      const Y = this.remove(v);
      return Y ? Y.toSmall() : -1;
    }
    setSmall(v, Y) {
      return this.set(v, i.fromSmall(Y));
    }
    pushSmall(v) {
      return this.push(i.fromSmall(v));
    }
    unshiftSmall(v) {
      return this.unshift(i.fromSmall(v));
    }
    insertSmall(v, Y) {
      return this.insert(v, i.fromSmall(Y));
    }
    /*
     * Num
     */
    getNum(v, Y, he) {
      const le = this.get(v);
      return le ? le.toNum(Y, he) : null;
    }
    popNum(v, Y) {
      const he = this.pop();
      return he ? he.toNum(v, Y) : null;
    }
    shiftNum(v, Y) {
      const he = this.shift();
      return he ? he.toNum(v, Y) : null;
    }
    removeNum(v, Y, he) {
      const le = this.remove(v);
      return le ? le.toNum(Y, he) : null;
    }
    setNum(v, Y) {
      return this.set(v, i.fromNum(Y));
    }
    pushNum(v) {
      return this.push(i.fromNum(v));
    }
    unshiftNum(v) {
      return this.unshift(i.fromNum(v));
    }
    insertNum(v, Y) {
      return this.insert(v, i.fromNum(Y));
    }
    /*
     * Int
     */
    getInt(v, Y, he) {
      const le = this.get(v);
      return le ? le.toInt(Y, he) : -1;
    }
    popInt(v, Y) {
      const he = this.pop();
      return he ? he.toInt(v, Y) : -1;
    }
    shiftInt(v, Y) {
      const he = this.shift();
      return he ? he.toInt(v, Y) : -1;
    }
    removeInt(v, Y, he) {
      const le = this.remove(v);
      return le ? le.toInt(Y, he) : -1;
    }
    setInt(v, Y) {
      return this.set(v, i.fromInt(Y));
    }
    pushInt(v) {
      return this.push(i.fromInt(v));
    }
    unshiftInt(v) {
      return this.unshift(i.fromInt(v));
    }
    insertInt(v, Y) {
      return this.insert(v, i.fromInt(Y));
    }
    /*
     * Bool
     */
    getBool(v) {
      const Y = this.get(v);
      return Y ? Y.toBool() : !1;
    }
    popBool() {
      const v = this.pop();
      return v ? v.toBool() : !1;
    }
    shiftBool() {
      const v = this.shift();
      return v ? v.toBool() : !1;
    }
    removeBool(v) {
      const Y = this.remove(v);
      return Y ? Y.toBool() : !1;
    }
    setBool(v, Y) {
      return this.set(v, i.fromBool(Y));
    }
    pushBool(v) {
      return this.push(i.fromBool(v));
    }
    unshiftBool(v) {
      return this.unshift(i.fromBool(v));
    }
    insertBool(v, Y) {
      return this.insert(v, i.fromBool(Y));
    }
    /*
     * Symbol
     */
    getSym(v) {
      const Y = this.get(v);
      return Y ? Y.toSymbol() : null;
    }
    popSym() {
      const v = this.pop();
      return v ? v.toSymbol() : null;
    }
    shiftSym() {
      const v = this.shift();
      return v ? v.toSymbol() : null;
    }
    removeSym(v) {
      const Y = this.remove(v);
      return Y ? Y.toSymbol() : null;
    }
    setSym(v, Y) {
      return this.set(v, i.fromSymbol(Y));
    }
    pushSym(v) {
      return this.push(i.fromSymbol(v));
    }
    unshiftSym(v) {
      return this.unshift(i.fromSymbol(v));
    }
    insertSym(v, Y) {
      return this.insert(v, i.fromSymbol(Y));
    }
    /**
     * Inject properties from bitcoind test string.
     * @private
     * @param {String} items - Script string.
     * @throws Parse error.
     */
    fromString(v) {
      if (e(typeof v == "string"), v = v.trim(), v.length === 0)
        return this;
      const Y = v.split(/\s+/), he = c.write();
      for (const le of Y) {
        let ge = le;
        ge.charCodeAt(0) & 32 && (ge = ge.toUpperCase()), /^OP_/.test(ge) || (ge = `OP_${ge}`);
        const Ee = a[ge];
        if (Ee == null) {
          if (le[0] === "'") {
            e(le[le.length - 1] === "'", "Invalid string.");
            const I = le.slice(1, -1), ne = i.fromString(I);
            he.writeBytes(ne.toRaw());
            continue;
          }
          if (/^-?\d+$/.test(le)) {
            const I = S.fromString(le, 10), ne = i.fromNum(I);
            he.writeBytes(ne.toRaw());
            continue;
          }
          e(le.indexOf("0x") === 0, "Unknown opcode.");
          const we = le.substring(2), z = k.from(we, "hex");
          e(z.length === we.length / 2, "Invalid hex string."), he.writeBytes(z);
          continue;
        }
        he.writeU8(Ee);
      }
      return this.fromRaw(he.render());
    }
    /**
     * Parse a bitcoind test script
     * string into a script object.
     * @param {String} items - Script string.
     * @returns {Script}
     * @throws Parse error.
     */
    static fromString(v) {
      return new this().fromString(v);
    }
    /**
     * Verify an input and output script, and a witness if present.
     * @param {Script} input
     * @param {Null} witness
     * @param {Script} output
     * @param {TX} tx
     * @param {Number} index
     * @param {Amount} value
     * @param {VerifyFlags} flags
     * @param {Number?} sigchecks
     * @throws {ScriptError}
     */
    static verify(v, Y, he, le, ge, Ee, we, z) {
      if (we == null && (we = T.flags.STANDARD_VERIFY_FLAGS), we & T.flags.VERIFY_SIGPUSHONLY && !v.isPushOnly())
        throw new g("SIG_PUSHONLY");
      we & T.flags.VERIFY_SIGHASH_FORKID && (we |= T.flags.VERIFY_STRICTENC);
      let I = new p();
      v.execute(I, we, le, ge, Ee, N.sigchecks);
      let ne;
      if (we & T.flags.VERIFY_P2SH && (ne = I.clone()), he.execute(I, we, le, ge, Ee, N.sigchecks), I.length === 0 || !I.getBool(-1))
        throw new g("EVAL_FALSE");
      if (we & T.flags.VERIFY_P2SH && he.isScripthash()) {
        if (!v.isPushOnly())
          throw new g("SIG_PUSHONLY");
        if (I = ne, I.length === 0)
          throw new g("EVAL_FALSE");
        const t = I.pop(), d = T.fromRaw(t);
        if ((we & T.flags.VERIFY_DISALLOW_SEGWIT_RECOVERY) === 0 && I.length === 0 && d.isProgram()) {
          we & T.flags.REPORT_SIGCHECKS || (N.sigchecks = 0);
          return;
        }
        if (d.execute(I, we, le, ge, Ee, 0, N.sigchecks), I.length === 0 || !I.getBool(-1))
          throw new g("EVAL_FALSE");
      }
      if (we & T.flags.VERIFY_CLEANSTACK && (e((we & T.flags.VERIFY_P2SH) !== 0), I.length !== 1))
        throw new g("CLEANSTACK");
      if (we & T.flags.VERIFY_INPUT_SIGCHECKS && v.getSize() < N.sigchecks * 43 - 60)
        throw new g("INPUT_SIGCHECKS");
      we & T.flags.REPORT_SIGCHECKS || (N.sigchecks = 0);
    }
    /**
     * Inject properties from buffer reader.
     * @private
     * @param {BufferReader} br
     */
    fromReader(v) {
      return this.fromRaw(v.readVarBytes());
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer}
     */
    fromRaw(v) {
      const Y = c.read(v);
      for (this.raw = v; Y.left(); )
        this.code.push(i.fromReader(Y));
      return this;
    }
    /**
     * Create a script from buffer reader.
     * @param {BufferReader} br
     * @param {String?} enc - Either `"hex"` or `null`.
     * @returns {Script}
     */
    static fromReader(v) {
      return new this().fromReader(v);
    }
    /**
     * Create a script from a serialized buffer.
     * @param {Buffer|String} data - Serialized script.
     * @param {String?} enc - Either `"hex"` or `null`.
     * @returns {Script}
     */
    static fromRaw(v, Y) {
      return typeof v == "string" && (v = k.from(v, Y)), new this().fromRaw(v);
    }
    /**
     * Test whether an object a Script.
     * @param {Object} obj
     * @returns {Boolean}
     */
    static isScript(v) {
      return v instanceof T;
    }
  }
  T.opcodes = y.opcodes, T.opcodesByVal = y.opcodesByVal, T.flags = y.flags, T.hashType = y.hashType, T.hashTypeByVal = y.hashTypeByVal, T.types = y.types, T.typesByVal = y.typesByVal;
  function A(oe) {
    return oe.slice().sort((v, Y) => v.compare(Y));
  }
  function q(oe, v) {
    if (e(k.isBuffer(oe)), e(typeof v == "number"), v & T.flags.VERIFY_STRICTENC && !y.isKeyEncoding(oe))
      throw new g("PUBKEYTYPE");
    if (v & T.flags.VERIFY_COMPRESSED_PUBKEYTYPE && !y.isCompressedEncoding(oe))
      throw new g("NONCOMPRESSED_PUBKEY");
    return !0;
  }
  function _(oe, v) {
    if (e(k.isBuffer(oe)), e(typeof v == "number"), y.isSchnorr(oe))
      throw new g("SIG_BADLENGTH");
    if ((v & T.flags.VERIFY_DERSIG || v & T.flags.VERIFY_LOW_S || v & T.flags.VERIFY_STRICTENC) && !y.isDERSignatureEncoding(oe))
      throw new g("SIG_DER");
    if (v & T.flags.VERIFY_LOW_S && !y.isLowDER(oe))
      throw new g("SIG_HIGH_S");
    return !0;
  }
  function F(oe, v) {
    if (e(k.isBuffer(oe)), e(typeof v == "number"), v & T.flags.VERIFY_STRICTENC) {
      if (!y.isHashType(oe))
        throw new g("SIG_HASHTYPE");
      const Y = oe[oe.length - 1] & T.hashType.SIGHASH_FORKID, he = v & T.flags.VERIFY_SIGHASH_FORKID;
      if (!he && Y)
        throw new g("ILLEGAL_FORKID");
      if (he && !Y)
        throw new g("MUST_USE_FORKID");
    }
    return !0;
  }
  function R(oe, v) {
    return e(k.isBuffer(oe)), e(typeof v == "number"), oe.length === 0 ? !0 : (ae(oe.slice(0, -1), v), F(oe, v));
  }
  function L(oe, v) {
    return e(k.isBuffer(oe)), e(typeof v == "number"), oe.length === 0 ? !0 : D(oe.slice(0, -1), v) ? F(oe, v) : _(oe.slice(0, -1), v);
  }
  function fe(oe, v) {
    return e(k.isBuffer(oe)), e(typeof v == "number"), oe.length === 0 ? !0 : (_(oe.slice(0, -1), v), F(oe, v));
  }
  function ue(oe, v) {
    return e(k.isBuffer(oe)), e(typeof v == "number"), oe.length === 0 ? !0 : ae(oe.slice(0, oe.length), v);
  }
  function ae(oe, v) {
    return e(k.isBuffer(oe)), e(typeof v == "number"), y.isSchnorr(oe) ? !0 : _(oe, v);
  }
  function D(oe, v) {
    if (e(k.isBuffer(oe)), e(typeof v == "number"), y.isSchnorr(oe))
      return !0;
    throw new g("SIG_NONSCHNORR");
  }
  function Q(oe, v, Y, he) {
    e(k.isBuffer(oe)), e(k.isBuffer(v)), e(k.isBuffer(Y)), e(typeof he == "number");
    let le = !1;
    return v.length === 64 ? le = u.schnorrVerify(oe, v, Y, he) : le = u.verifyDER(oe, v, Y, he), le;
  }
  function W(oe, v, Y) {
    return u.verifyDER(oe, v.slice(0, -1), Y);
  }
  return Da = T, Da;
}
/*!
 * slp.js - simple ledger protocol script for bcash
 * Copyright (c) 2021, Vin Armani (MIT License).
 * https://github.com/badger-cash/bcash
 */
var Ua, t2;
function io() {
  if (t2) return Ua;
  t2 = 1;
  const e = dt, c = Bt, { U64: l } = q8;
  Xt();
  const w = si();
  Ki();
  const m = {
    GENESIS: 0,
    MINT: 1,
    SEND: 2,
    BATON: 3,
    BURN: 4
  };
  class f {
    /**
     * Create a record of SLP data for a given coin.
     * @param {Buffer?} hash the output hash of the coin
     * @param {Number?} vout the output index of the coin
     * @param {Buffer?} tokenId 32 byte txid
     * @param {Buffer?} tokenIndex 4 byte unsigned integer (index of tx hash in db)
     * @param {Buffer} value big endian value of token base units
     * @param {String} type GENESIS | MINT | SEND | BURN | BATON
     * @param {Number?} version token type
     * @constructor
     */
    constructor(s = {}) {
      this.hash = s.hash, this.vout = s.vout, this.tokenId = s.tokenId, this.tokenIndex = s.tokenIndex, this.value = s.value, this.type = s.type, this.version = s.version;
    }
    /**
     * Get the value as 64 bit big-endian buffer
     * @private
     * @returns {Buffer}
     */
    getValueUInt64BE() {
      e(this.value.length <= 8, "value buffer must be 8 bytes or less");
      const s = k.alloc(8 - this.value.length);
      return k.concat([s, this.value]);
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     */
    fromDbData(s) {
      const i = c.read(s);
      this.tokenIndex = i.readBytes(4);
      const p = i.readVarBytes(), g = k.alloc(8 - p.length);
      this.value = k.concat([g, p]), this.type = Object.keys(m)[i.readU8()];
      try {
        this.version = i.readU8();
      } catch (S) {
        if (S.code === "ERR_ENCODING")
          this.version = 1;
        else throw S;
      }
      return e(this.version >= 1 && this.version <= 2), e(Object.keys(m).includes(this.type)), this;
    }
    /**
     * Instantiate SLP record from serialized data.
     * @param {Buffer} data
     * @returns {SlpCoinRecord}
     */
    static fromDbData(s) {
      return new this().fromDbData(s);
    }
    /**
     * Serialize the SLP record.
     * @returns {Buffer}
     */
    toDbData() {
      e(this.tokenIndex, "Missing tokenIndex"), e(this.tokenIndex.length == 4, "tokenId must be a sha256 hash"), e(this.value.byteLength, "Token amount must be a buffer"), e(Object.keys(m).includes(this.type), "Type must be GENESIS | MINT | SEND | BATON | BURN");
      for (let i = 0; i < this.value.length; i++)
        if (this.value[i] != 0) {
          this.value = this.value.slice(i);
          break;
        }
      const s = c.write();
      return s.writeBytes(this.tokenIndex), s.writeVarBytes(this.value), s.writeU8(m[this.type]), s.writeU8(this.version || 1), s.render();
    }
    /**
     * Convert object to JSON.
     * @returns {Object}
     */
    getJSON() {
      return e(this.tokenId, "tokenId must be defined"), {
        hash: this.hash ? k.from(this.hash).reverse().toString("hex") : void 0,
        vout: this.vout,
        tokenId: this.tokenId.toString("hex"),
        value: l.fromBE(this.value).toString(10),
        type: this.type,
        version: this.version || 1
      };
    }
    /**
     * Convert from JSON to Object.
     * @param {Object} json
     * @returns {SlpCoinRecord}
     */
    fromJSON(s) {
      return this.hash = k.from(s.hash, "hex").reverse(), this.vout = s.vout, this.tokenId = k.from(s.tokenId, "hex"), this.value = l.fromString(s.value).toBE(k), this.type = s.type, this.version = s.version || 1, this;
    }
    /**
     * Convert from JSON to Object.
     * @param {Object} json
     * @returns {TokenRecord}
     */
    static fromJSON(s) {
      return new this().fromJSON(s);
    }
  }
  class n {
    /**
     * Create a token record.
     * @constructor
     * @param {Buffer?} tokenId
     * @param {Buffer?} tokenIndex
     * @param {String?} ticker
     * @param {String?} name
     * @param {String?} uri
     * @param {String?} hash
     * @param {Number} decimals
     * @param {Number?} version
     * @param {Buffer?} vaultScriptHash
     */
    constructor(s = {}) {
      this.tokenId = s.tokenId, this.tokenIndex = s.tokenIndex, this.ticker = s.ticker || "", this.name = s.name || "", this.uri = s.uri || "", this.hash = s.hash || "", this.decimals = s.decimals, this.version = s.version, this.version === 2 && (this.vaultScriptHash = s.vaultScriptHash);
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     */
    fromDbData(s) {
      const i = c.read(s);
      this.tokenId = i.readHash(), this.ticker = i.readVarString("utf8"), this.name = i.readVarString("utf8"), this.uri = i.readVarString("utf8"), this.hash = i.readVarString("hex"), this.decimals = i.readU8();
      try {
        this.version = i.readU8();
      } catch (p) {
        if (p.code === "ERR_ENCODING")
          this.version = 1;
        else throw p;
      }
      return this.version === 2 && (this.vaultScriptHash = i.readBytes(20)), e(this.version >= 1 && this.version <= 2), this;
    }
    /**
     * Instantiate token record from serialized data.
     * @param {Buffer} data
     * @returns {TokenRecord}
     */
    static fromDbData(s) {
      return new this().fromDbData(s);
    }
    /**
     * Serialize the token record.
     * @returns {Buffer}
     */
    toDbData() {
      const s = c.write(), i = c.encoding;
      return s.writeHash(this.tokenId), s.writeVarString(this.ticker, "utf8"), this.ticker.length === 0 && (s.offset += i.sizeVarint(0)), s.writeVarString(this.name, "utf8"), this.name.length === 0 && (s.offset += i.sizeVarint(0)), s.writeVarString(this.uri, "utf8"), this.uri.length === 0 && (s.offset += i.sizeVarint(0)), s.writeVarString(this.hash, "hex"), this.hash.length === 0 && (s.offset += i.sizeVarint(0)), s.writeU8(this.decimals), s.writeU8(this.version || 1), this.version === 2 && s.writeBytes(this.vaultScriptHash), s.render();
    }
    /**
     * Convert object to JSON.
     * @returns {Object}
     */
    getJSON() {
      e(this.tokenId, "tokenId must be defined");
      const s = {
        tokenId: this.tokenId.toString("hex"),
        ticker: this.ticker,
        name: this.name,
        uri: this.uri,
        hash: this.hash,
        decimals: this.decimals,
        version: this.version || 1
      };
      return s.version === 2 && this.vaultScriptHash && (s.vaultScriptHash = this.vaultScriptHash.toString("hex")), s;
    }
    /**
     * Convert from JSON to Object.
     * @param {Object} json
     * @returns {SlpCoinRecord}
     */
    fromJSON(s) {
      return this.tokenId = k.from(s.tokenId, "hex"), this.ticker = s.ticker, this.name = s.name, this.uri = s.uri, this.hash = s.hash, this.decimals = s.decimals, this.version = s.version, s.version === 2 && s.vaultScriptHash && (this.vaultScriptHash = k.from(s.vaultScriptHash, "hex")), this;
    }
    /**
     * Convert from JSON to Object.
     * @param {Object} json
     * @returns {TokenRecord}
     */
    static fromJSON(s) {
      return new this().fromJSON(s);
    }
  }
  class u extends w {
    /**
     * Create an SLP script.
     * @constructor
     * @param {Buffer|Array|Object} code
     */
    constructor(s) {
      super(s), this.valid = null;
    }
    /**
     * Is SLP script is of valid construction?
     * Use this as opposed to calling property this.isValid
     * @private
     * @returns {Boolean}
     */
    isValidSlp() {
      return this.valid === null && (this.valid = this.verifySlp()), this.valid;
    }
    /**
     * Test whether SLP script is of valid construction
     * (Does not test if transaction is valid SLP transaction)
     * @private
     * @param {Script?} script
     * @returns {Boolean}
     */
    verifySlp(s) {
      if (s == null && (s = this), s.getSym(0) != "OP_RETURN" || s.getString(1, "hex") != "534c5000")
        return !1;
      const i = s.getString(2, "hex");
      if (i != "01" && i != "02")
        return !1;
      switch (s.getType()) {
        case "GENESIS": {
          if (s.code.length != 11 || !s.getData(7) || s.getData(7).length != 0 && s.getData(7).length != 32 || !s.getData(8) || s.getData(8).length != 1 || s.getInt(8) > 9)
            return !1;
          if (i == "01") {
            if (!s.getData(9) || s.getData(9).length > 1 || s.getData(9).length == 1 && s.getInt(9) < 2)
              return !1;
          } else if (i == "02" && (!s.getData(9) || s.getData(9).length != 20))
            return !1;
          if (s.getData(10).length != 8)
            return !1;
          break;
        }
        case "MINT": {
          if (i == "01" && s.code.length != 7 || i == "02" && s.code.length < 6 || s.getData(4).length != 32)
            return !1;
          if (i == "01") {
            if (!s.getData(5) || s.getData(5).length > 1 || s.getData(5).length == 1 && s.getInt(5) < 2 || s.getData(6).length != 8)
              return !1;
          } else if (i == "02") {
            const g = s.code.slice(5);
            for (let S = 0; S < g.length; S++)
              if (g[S].data.length != 8)
                return !1;
          }
          break;
        }
        case "SEND": {
          if (s.code.length < 6 || s.getData(4).length != 32)
            return !1;
          const g = s.code.slice(5);
          for (let S = 0; S < g.length; S++)
            if (g[S].data.length != 8)
              return !1;
          break;
        }
        case "BURN": {
          if (s.code.length != 6 || s.getData(4).length != 32 || s.getData(5).length != 8)
            return !1;
          break;
        }
        default:
          return !1;
      }
      return !0;
    }
    /**
     * Test whether script is of valid construction
     * (Does not test if transaction is valid SLP transaction)
     * @param {Script?} script
     * @returns {Boolean}
     */
    static verifySlp(s) {
      return new this().verifySlp(s);
    }
    /**
     * Inject properties from a script
     * @private
     * @param {Script} code
     * @returns {SLP}
     */
    fromScript(s) {
      return this.inject(s), this;
    }
    /**
     * Inject properties from a script
     * @param {Script} code
     * @returns {SLP}
     */
    static fromScript(s) {
      return new this().fromScript(s);
    }
    /**
     * Get token ID for this script
     * @private
     * @returns {Hash}
     */
    getTokenId() {
      e(this.verifySlp(), "This is not a valid SLP script");
      const s = this.getType();
      return e(s != "GENESIS", "Cannot derive the tokenID from GENESIS script"), this.getData(4);
    }
    /**
     * Get records for a this script
     * @private
     * @param {Buffer?} txId The txid of the transaction containing this script
     * @returns {(SlpCoinRecord | TokenRecord)[]}
     */
    getRecords(s) {
      e(this.isValidSlp(), "Must be a valid SLP Script");
      const i = this.getType();
      switch (e(Object.keys(m).includes(i) && i != "BATON", "Type must be GENESIS | MINT | SEND | BURN"), e(s.byteLength, "tokenId must be a buffer"), e(s.length == 32, "tokenId must be a sha256 hash"), i) {
        case "GENESIS":
          return this.getGenesisRecords(s);
        case "MINT":
          return this.getMintRecords(s);
        case "SEND":
          return this.getSendRecords(s);
        case "BURN":
          return this.getBurnRecords(s);
        default:
          return null;
      }
    }
    /**
     * Get records for a GENESIS script
     * @private
     * @param {Buffer} tokenId The tokenId of the transaction containing this script
     * @returns {(SlpCoinRecord | TokenRecord)[]}
     */
    getGenesisRecords(s) {
      e(s.byteLength, "tokenId must be a buffer"), e(s.byteLength == 32, "tokenId must be a sha256 hash");
      const i = this.getType();
      e(i == "GENESIS", "This is not a GENESIS transaction");
      const p = this.getInt(2), g = [];
      if (g.push(this.constructor.TokenRecord({
        tokenId: s,
        version: p,
        ticker: this.getString(4, "utf-8"),
        name: this.getString(5, "utf-8"),
        uri: this.getString(6, "utf-8"),
        hash: this.getString(7, "hex"),
        decimals: this.getInt(8),
        vaultScriptHash: p === 2 ? this.getData(9) : void 0
      })), g.push(this.constructor.SlpCoinRecord({
        hash: k.from(s).reverse(),
        vout: 1,
        tokenId: s,
        value: this.getData(10),
        type: i,
        version: this.getInt(2)
      })), p === 1 && this.getInt(9) >= 2) {
        const S = k.alloc(1);
        S.writeInt8(1), g.push(this.constructor.SlpCoinRecord({
          hash: k.from(s).reverse(),
          vout: this.getInt(9),
          tokenId: s,
          value: S,
          type: "BATON",
          version: this.getInt(2)
        }));
      }
      return g;
    }
    /**
     * Get records for a MINT script
     * @private
     * @param {Buffer} txId The txHash of the transaction containing this script
     * @returns {SlpCoinRecord[]}
     */
    getMintRecords(s) {
      e(s.byteLength, "txId must be a buffer"), e(s.byteLength == 32, "txId must be a sha256 hash");
      const i = this.getType();
      e(i == "MINT", "This is not a MINT transaction");
      const p = this.getInt(2), g = [];
      if (p === 1) {
        if (g.push(this.constructor.SlpCoinRecord({
          hash: k.from(s).reverse(),
          vout: 1,
          tokenId: this.getData(4),
          value: this.getData(6),
          type: i,
          version: p
        })), this.getInt(5) >= 2) {
          const S = l.fromInt(1).toBE(k);
          g.push(this.constructor.SlpCoinRecord({
            hash: k.from(s).reverse(),
            vout: this.getInt(5),
            tokenId: this.getData(4),
            value: S,
            type: "BATON",
            version: p
          }));
        }
      } else if (p === 2) {
        const S = this.code.slice(5);
        for (let y = 0; y < S.length; y++) {
          const b = S[y].toData(), h = y + 1;
          g.push(this.constructor.SlpCoinRecord({
            hash: k.from(s).reverse(),
            vout: h,
            tokenId: this.getData(4),
            value: b,
            type: i,
            version: this.getInt(2)
          }));
        }
      }
      return g;
    }
    /**
     * Get records for a SEND script
     * @private
     * @param {Buffer} txId The txHash of the transaction containing this script
     * @param {Boolean} nonStandardOuts OP_RETURN is located at an index other than 0
     * @returns {SlpCoinRecord[]}
     */
    getSendRecords(s, i = !1) {
      e(s.byteLength, "txId must be a buffer"), e(s.byteLength == 32, "txId must be a sha256 hash");
      const p = this.getType();
      e(p == "SEND", "This is not a SEND transaction");
      const g = [], S = this.code.slice(5);
      for (let y = 0; y < S.length; y++) {
        const b = S[y].toData(), h = i ? y : y + 1;
        g.push(this.constructor.SlpCoinRecord({
          hash: k.from(s).reverse(),
          vout: h,
          tokenId: this.getData(4),
          value: b,
          type: p,
          version: this.getInt(2)
        }));
      }
      return g;
    }
    getBurnRecords(s, i = !1) {
      e(s.byteLength, "txId must be a buffer"), e(s.byteLength == 32, "txId must be a sha256 hash");
      const p = this.getType();
      e(p == "BURN", "This is not a BURN transaction");
      const g = [], S = this.code[5].toData();
      return g.push(this.constructor.SlpCoinRecord({
        hash: k.from(s).reverse(),
        vout: 0,
        tokenId: this.getData(4),
        value: S,
        type: p,
        version: this.getInt(2)
      })), g;
    }
    /**
     * Re-encode the script internally. Useful if you
     * changed something manually in the `code` array.
     * @returns {Script}
     */
    compile() {
      super.compile(), this.valid = null, this.isValidSlp();
    }
    /**
     * Inspect the script.
     * @returns {String} Human-readable script code.
     */
    inspect() {
      return `<SLP: ${this.toString()}>`;
    }
    getType() {
      return this.getString(3);
    }
    /**
     * Create a new TokenRecord
     * @param {Buffer?} tokenId
     * @param {Buffer?} tokenIndex
     * @param {String?} ticker
     * @param {String?} name
     * @param {String?} uri
     * @param {String?} hash
     * @param {Number} decimals
     * @param {Number?} version
     * @returns {TokenRecord}
     */
    static TokenRecord(s = {}) {
      return new n(s);
    }
    /**
     * Create a new SlpCoinRecord
     * @param {Buffer?} hash the output hash of the coin
     * @param {Number?} vout the output index of the coin
     * @param {Buffer?} tokenId 32 byte txid
     * @param {Buffer?} tokenIndex 4 byte unsigned integer (index of tx hash in db)
     * @param {Number} value
     * @param {String} type GENESIS | MINT | SEND | BATON
     * @param {Number?} version
     * @returns {SlpCoinRecord}
     */
    static SlpCoinRecord(s = {}) {
      return new f(s);
    }
  }
  return Ua = u, Ua;
}
/*!
 * output.js - output object for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var Fa, r2;
function Vi() {
  if (r2) return Fa;
  r2 = 1;
  const e = dt, c = Bt, l = Di(), w = Tr(), m = Li(), f = si(), n = io(), u = yn(), { inspectSymbol: o } = cr();
  class s {
    /**
     * Create an output.
     * @constructor
     * @param {Object?} options
     */
    constructor(p) {
      this.value = 0, this.script = new f(), p && this.fromOptions(p);
    }
    /**
     * Inject properties from options object.
     * @private
     * @param {Object} options
     */
    fromOptions(p) {
      return e(p, "Output data is required."), p.value && (e(
        Number.isSafeInteger(p.value) && p.value >= 0,
        "Value must be a uint64."
      ), this.value = p.value), p.script && this.script.fromOptions(p.script), p.address && this.script.fromAddress(p.address), p.slp && p.slp.constructor === n.SlpCoinRecord().constructor && (this.slp = p.slp), this;
    }
    /**
     * Instantiate output from options object.
     * @param {Object} options
     * @returns {Output}
     */
    static fromOptions(p) {
      return new this().fromOptions(p);
    }
    /**
     * Inject properties from script/value pair.
     * @private
     * @param {Script|Address} script
     * @param {Amount} value
     * @returns {Output}
     */
    fromScript(p, g) {
      return typeof p == "string" && (p = m.fromString(p)), p instanceof m && (p = f.fromAddress(p)), e(p instanceof f, "Script must be a Script."), e(
        Number.isSafeInteger(g) && g >= 0,
        "Value must be a uint64."
      ), this.script = p, this.value = g, this;
    }
    /**
     * Instantiate output from script/value pair.
     * @param {Script|Address} script
     * @param {Amount} value
     * @returns {Output}
     */
    static fromScript(p, g) {
      return new this().fromScript(p, g);
    }
    /**
     * Clone the output.
     * @returns {Output}
     */
    clone() {
      const p = new this.constructor();
      return p.value = this.value, p.script.inject(this.script), p;
    }
    /**
     * Test equality against another output.
     * @param {Output} output
     * @returns {Boolean}
     */
    equals(p) {
      return e(s.isOutput(p)), this.value === p.value && this.script.equals(p.script);
    }
    /**
     * Compare against another output (BIP69).
     * @param {Output} output
     * @returns {Number}
     */
    compare(p) {
      e(s.isOutput(p));
      const g = this.value - p.value;
      return g !== 0 ? g : this.script.compare(p.script);
    }
    /**
     * Get the script type as a string.
     * @returns {ScriptType} type
     */
    getType() {
      return f.typesByVal[this.script.getType()].toLowerCase();
    }
    /**
     * Get the address.
     * @returns {Address} address
     */
    getAddress() {
      return this.script.getAddress();
    }
    /**
     * Get the address hash.
     * @param {String?} enc
     * @returns {Hash} hash
     */
    getHash(p) {
      const g = this.getAddress();
      return g ? g.getHash(p) : null;
    }
    /**
     * Convert the input to a more user-friendly object.
     * @returns {Object}
     */
    [o]() {
      const p = {
        type: this.getType(),
        value: l.btc(this.value),
        script: this.script,
        address: this.getAddress()
      };
      return this.slp ? {
        ...p,
        slp: this.slp
      } : p;
    }
    /**
     * Convert the output to an object suitable
     * for JSON serialization.
     * @returns {Object}
     */
    toJSON() {
      return this.getJSON();
    }
    /**
     * Convert the output to an object suitable
     * for JSON serialization.
     * @param {Network} network
     * @returns {Object}
     */
    getJSON(p) {
      let g = this.getAddress();
      p = w.get(p), g && (g = g.toString(p));
      const S = {
        value: this.value,
        script: this.script.toJSON(),
        address: g
      };
      return this.slp ? {
        ...S,
        slp: this.slp.getJSON()
      } : S;
    }
    /**
     * Calculate the dust threshold for this
     * output, based on serialize size and rate.
     * @param {Rate?} rate
     * @returns {Amount}
     */
    getDustThreshold(p) {
      if (this.script.isUnspendable())
        return 0;
      let g = this.getSize();
      return g += 148, 3 * u.getMinFee(g, p);
    }
    /**
     * Calculate size of serialized output.
     * @returns {Number}
     */
    getSize() {
      return 8 + this.script.getVarSize();
    }
    /**
     * Test whether the output should be considered dust.
     * @param {Rate?} rate
     * @returns {Boolean}
     */
    isDust(p) {
      return this.value < this.getDustThreshold(p);
    }
    /**
     * Inject properties from a JSON object.
     * @private
     * @param {Object} json
     */
    fromJSON(p) {
      return e(p, "Output data is required."), e(
        Number.isSafeInteger(p.value) && p.value >= 0,
        "Value must be a uint64."
      ), this.value = p.value, this.script.fromJSON(p.script), p.slp && (this.slp = n.SlpCoinRecord().fromJSON(p.slp)), this;
    }
    /**
     * Instantiate an Output from a jsonified output object.
     * @param {Object} json - The jsonified output object.
     * @returns {Output}
     */
    static fromJSON(p) {
      return new this().fromJSON(p);
    }
    /**
     * Write the output to a buffer writer.
     * @param {BufferWriter} bw
     */
    toWriter(p) {
      return p.writeI64(this.value), p.writeVarBytes(this.script.toRaw()), p;
    }
    /**
     * Serialize the output.
     * @param {String?} enc - Encoding, can be `'hex'` or null.
     * @returns {Buffer|String}
     */
    toRaw() {
      const p = this.getSize();
      return this.toWriter(c.write(p)).render();
    }
    /**
     * Inject properties from buffer reader.
     * @private
     * @param {BufferReader} br
     */
    fromReader(p) {
      return this.value = p.readI64(), this.script.fromRaw(p.readVarBytes()), this;
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     */
    fromRaw(p) {
      return this.fromReader(c.read(p));
    }
    /**
     * Instantiate an output from a buffer reader.
     * @param {BufferReader} br
     * @returns {Output}
     */
    static fromReader(p) {
      return new this().fromReader(p);
    }
    /**
     * Instantiate an output from a serialized Buffer.
     * @param {Buffer} data
     * @param {String?} enc - Encoding, can be `'hex'` or null.
     * @returns {Output}
     */
    static fromRaw(p, g) {
      return typeof p == "string" && (p = k.from(p, g)), new this().fromRaw(p);
    }
    /**
     * Test an object to see if it is an Output.
     * @param {Object} obj
     * @returns {Boolean}
     */
    static isOutput(p) {
      return p instanceof s;
    }
  }
  return Fa = s, Fa;
}
/*!
 * outpoint.js - outpoint object for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var Ha, i2;
function vn() {
  if (i2) return Ha;
  i2 = 1;
  const e = dt, c = Bt, l = pr(), w = Xt(), { inspectSymbol: m } = cr();
  class f {
    /**
     * Create an outpoint.
     * @constructor
     * @param {Hash?} hash
     * @param {Number?} index
     */
    constructor(o, s) {
      this.hash = w.ZERO_HASH, this.index = 4294967295, o != null && (e(k.isBuffer(o)), e(s >>> 0 === s, "Index must be a uint32."), this.hash = o, this.index = s);
    }
    /**
     * Inject properties from options object.
     * @private
     * @param {Object} options
     */
    fromOptions(o) {
      return e(o, "Outpoint data is required."), e(k.isBuffer(o.hash)), e(o.index >>> 0 === o.index, "Index must be a uint32."), this.hash = o.hash, this.index = o.index, this;
    }
    /**
     * Instantate outpoint from options object.
     * @param {Object} options
     * @returns {Outpoint}
     */
    static fromOptions(o) {
      return new this().fromOptions(o);
    }
    /**
     * Clone the outpoint.
     * @returns {Outpoint}
     */
    clone() {
      const o = new this.constructor();
      return o.hash = this.hash, o.index = this.index, o;
    }
    /**
     * Test equality against another outpoint.
     * @param {Outpoint} prevout
     * @returns {Boolean}
     */
    equals(o) {
      return e(f.isOutpoint(o)), this.hash.equals(o.hash) && this.index === o.index;
    }
    /**
     * Compare against another outpoint (BIP69).
     * @param {Outpoint} prevout
     * @returns {Number}
     */
    compare(o) {
      e(f.isOutpoint(o));
      const s = n(this.txid(), o.txid());
      return s !== 0 ? s : this.index - o.index;
    }
    /**
     * Test whether the outpoint is null (hash of zeroes
     * with max-u32 index). Used to detect coinbases.
     * @returns {Boolean}
     */
    isNull() {
      return this.index === 4294967295 && this.hash.equals(w.ZERO_HASH);
    }
    /**
     * Get little-endian hash.
     * @returns {Hash}
     */
    rhash() {
      return l.revHex(this.hash);
    }
    /**
     * Get little-endian hash.
     * @returns {Hash}
     */
    txid() {
      return this.rhash();
    }
    /**
     * Serialize outpoint to a key
     * suitable for a hash table.
     * @returns {String}
     */
    toKey() {
      return this.toRaw();
    }
    /**
     * Inject properties from hash table key.
     * @private
     * @param {String} key
     * @returns {Outpoint}
     */
    fromKey(o) {
      return this.hash = o.slice(0, 32), this.index = c.readU32(o, 32), this;
    }
    /**
     * Instantiate outpoint from hash table key.
     * @param {String} key
     * @returns {Outpoint}
     */
    static fromKey(o) {
      return new this().fromKey(o);
    }
    /**
     * Write outpoint to a buffer writer.
     * @param {BufferWriter} bw
     */
    toWriter(o) {
      return o.writeHash(this.hash), o.writeU32(this.index), o;
    }
    /**
     * Calculate size of outpoint.
     * @returns {Number}
     */
    getSize() {
      return 36;
    }
    /**
     * Serialize outpoint.
     * @returns {Buffer}
     */
    toRaw() {
      return this.toWriter(c.write(36)).render();
    }
    /**
     * Inject properties from buffer reader.
     * @private
     * @param {BufferReader} br
     */
    fromReader(o) {
      return this.hash = o.readHash(), this.index = o.readU32(), this;
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     */
    fromRaw(o) {
      return this.fromReader(c.read(o));
    }
    /**
     * Instantiate outpoint from a buffer reader.
     * @param {BufferReader} br
     * @returns {Outpoint}
     */
    static fromReader(o) {
      return new this().fromReader(o);
    }
    /**
     * Instantiate outpoint from serialized data.
     * @param {Buffer} data
     * @returns {Outpoint}
     */
    static fromRaw(o) {
      return new this().fromRaw(o);
    }
    /**
     * Inject properties from json object.
     * @private
     * @params {Object} json
     */
    fromJSON(o) {
      return e(o, "Outpoint data is required."), e(typeof o.hash == "string", "Hash must be a string."), e(o.index >>> 0 === o.index, "Index must be a uint32."), this.hash = l.fromRev(o.hash), this.index = o.index, this;
    }
    /**
     * Convert the outpoint to an object suitable
     * for JSON serialization. Note that the hash
     * will be reversed to abide by bitcoind's legacy
     * of little-endian uint256s.
     * @returns {Object}
     */
    toJSON() {
      return {
        hash: l.revHex(this.hash),
        index: this.index
      };
    }
    /**
     * Instantiate outpoint from json object.
     * @param {Object} json
     * @returns {Outpoint}
     */
    static fromJSON(o) {
      return new this().fromJSON(o);
    }
    /**
     * Inject properties from tx.
     * @private
     * @param {TX} tx
     * @param {Number} index
     */
    fromTX(o, s) {
      return e(o), e(typeof s == "number"), e(s >= 0), this.hash = o.hash(), this.index = s, this;
    }
    /**
     * Instantiate outpoint from tx.
     * @param {TX} tx
     * @param {Number} index
     * @returns {Outpoint}
     */
    static fromTX(o, s) {
      return new this().fromTX(o, s);
    }
    /**
     * Serialize outpoint to a key
     * suitable for a hash table.
     * @param {Hash} hash
     * @param {Number} index
     * @returns {String}
     */
    static toKey(o, s) {
      return new f(o, s).toKey();
    }
    /**
     * Convert the outpoint to a user-friendly string.
     * @returns {String}
     */
    [m]() {
      return `<Outpoint: ${this.rhash()}/${this.index}>`;
    }
    /**
     * Test an object to see if it is an outpoint.
     * @param {Object} obj
     * @returns {Boolean}
     */
    static isOutpoint(o) {
      return o instanceof f;
    }
  }
  function n(u, o) {
    const s = Math.min(u.length, o.length);
    for (let i = 0; i < s; i++) {
      if (u[i] < o[i])
        return -1;
      if (u[i] > o[i])
        return 1;
    }
    return u.length < o.length ? -1 : u.length > o.length ? 1 : 0;
  }
  return Ha = f, Ha;
}
/*!
 * coin.js - coin object for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var La, n2;
function no() {
  if (n2) return La;
  n2 = 1;
  const e = dt, c = Bt, l = pr(), w = Di(), m = Vi(), f = Tr(), n = Xt(), u = vn(), o = io(), { inspectSymbol: s } = cr();
  class i extends m {
    /**
     * Create a coin.
     * @constructor
     * @param {Object} options
     */
    constructor(g) {
      super(), this.version = 1, this.height = -1, this.coinbase = !1, this.hash = n.ZERO_HASH, this.index = 0, g && this.fromOptions(g);
    }
    /**
     * Inject options into coin.
     * @private
     * @param {Object} options
     */
    fromOptions(g) {
      return e(g, "Coin data is required."), g.version != null && (e(
        g.version >>> 0 === g.version,
        "Version must be a uint32."
      ), this.version = g.version), g.height != null && (g.height !== -1 ? (e(
        g.height >>> 0 === g.height,
        "Height must be a uint32."
      ), this.height = g.height) : this.height = -1), g.value != null && (e(
        Number.isSafeInteger(g.value) && g.value >= 0,
        "Value must be a uint64."
      ), this.value = g.value), g.script && this.script.fromOptions(g.script), g.coinbase != null && (e(
        typeof g.coinbase == "boolean",
        "Coinbase must be a boolean."
      ), this.coinbase = g.coinbase), g.hash != null && (e(k.isBuffer(g.hash)), this.hash = g.hash), g.index != null && (e(
        g.index >>> 0 === g.index,
        "Index must be a uint32."
      ), this.index = g.index), this;
    }
    /**
     * Instantiate Coin from options object.
     * @private
     * @param {Object} options
     */
    static fromOptions(g) {
      return new this().fromOptions(g);
    }
    /**
     * Clone the coin.
     * @private
     * @returns {Coin}
     */
    clone() {
      e(!1, "Coins are not cloneable.");
    }
    /**
     * Calculate number of confirmations since coin was created.
     * @param {Number?} height - Current chain height. Network
     * height is used if not passed in.
     * @return {Number}
     */
    getDepth(g) {
      return e(typeof g == "number", "Must pass a height."), this.height === -1 || g === -1 || g < this.height ? 0 : g - this.height + 1;
    }
    /**
     * Serialize coin to a key
     * suitable for a hash table.
     * @returns {String}
     */
    toKey() {
      return u.toKey(this.hash, this.index);
    }
    /**
     * Inject properties from hash table key.
     * @private
     * @param {String} key
     * @returns {Coin}
     */
    fromKey(g) {
      const { hash: S, index: y } = u.fromKey(g);
      return this.hash = S, this.index = y, this;
    }
    /**
     * Instantiate coin from hash table key.
     * @param {String} key
     * @returns {Coin}
     */
    static fromKey(g) {
      return new this().fromKey(g);
    }
    /**
     * Get little-endian hash.
     * @returns {Hash}
     */
    rhash() {
      return l.revHex(this.hash);
    }
    /**
     * Get little-endian hash.
     * @returns {Hash}
     */
    txid() {
      return this.rhash();
    }
    /**
     * Convert the coin to a more user-friendly object.
     * @returns {Object}
     */
    [s]() {
      const g = {
        type: this.getType(),
        version: this.version,
        height: this.height,
        value: w.btc(this.value),
        script: this.script,
        coinbase: this.coinbase,
        hash: this.hash ? l.revHex(this.hash) : null,
        index: this.index,
        address: this.getAddress()
      };
      return this.slp ? {
        ...g,
        slp: this.slp
      } : g;
    }
    /**
     * Convert the coin to an object suitable
     * for JSON serialization.
     * @returns {Object}
     */
    toJSON() {
      return this.getJSON();
    }
    /**
     * Convert the coin to an object suitable
     * for JSON serialization. Note that the hash
     * will be reversed to abide by bitcoind's legacy
     * of little-endian uint256s.
     * @param {Network} network
     * @param {Boolean} minimal
     * @returns {Object}
     */
    getJSON(g, S) {
      let y = this.getAddress();
      g = f.get(g), y && (y = y.toString(g));
      const b = {
        version: this.version,
        height: this.height,
        value: this.value,
        script: this.script.toJSON(),
        address: y,
        coinbase: this.coinbase,
        hash: S ? void 0 : this.rhash(),
        index: S ? void 0 : this.index
      };
      return this.slp ? {
        ...b,
        slp: this.slp.getJSON()
      } : b;
    }
    /**
     * Inject JSON properties into coin.
     * @private
     * @param {Object} json
     */
    fromJSON(g) {
      return e(g, "Coin data required."), e(g.version >>> 0 === g.version, "Version must be a uint32."), e(
        g.height === -1 || g.height >>> 0 === g.height,
        "Height must be a uint32."
      ), e(
        Number.isSafeInteger(g.value) && g.value >= 0,
        "Value must be a uint64."
      ), e(typeof g.coinbase == "boolean", "Coinbase must be a boolean."), this.version = g.version, this.height = g.height, this.value = g.value, this.script.fromJSON(g.script), this.coinbase = g.coinbase, g.hash != null && (e(typeof g.hash == "string", "Hash must be a string."), e(g.hash.length === 64, "Hash must be a string."), e(g.index >>> 0 === g.index, "Index must be a uint32."), this.hash = l.fromRev(g.hash), this.index = g.index), g.slp && (g.slp.hash = g.hash, this.slp = o.SlpCoinRecord().fromJSON(g.slp)), this;
    }
    /**
     * Instantiate an Coin from a jsonified coin object.
     * @param {Object} json - The jsonified coin object.
     * @returns {Coin}
     */
    static fromJSON(g) {
      return new this().fromJSON(g);
    }
    /**
     * Calculate size of coin.
     * @returns {Number}
     */
    getSize() {
      return 17 + this.script.getVarSize();
    }
    /**
     * Write the coin to a buffer writer.
     * @param {BufferWriter} bw
     */
    toWriter(g) {
      let S = this.height;
      return S === -1 && (S = 2147483647), g.writeU32(this.version), g.writeU32(S), g.writeI64(this.value), g.writeVarBytes(this.script.toRaw()), g.writeU8(this.coinbase ? 1 : 0), g;
    }
    /**
     * Serialize the coin.
     * @returns {Buffer|String}
     */
    toRaw() {
      const g = this.getSize();
      return this.toWriter(c.write(g)).render();
    }
    /**
     * Inject properties from serialized buffer writer.
     * @private
     * @param {BufferReader} br
     */
    fromReader(g) {
      return this.version = g.readU32(), this.height = g.readU32(), this.value = g.readI64(), this.script.fromRaw(g.readVarBytes()), this.coinbase = g.readU8() === 1, this.height === 2147483647 && (this.height = -1), this;
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     */
    fromRaw(g) {
      return this.fromReader(c.read(g));
    }
    /**
     * Instantiate a coin from a buffer reader.
     * @param {BufferReader} br
     * @returns {Coin}
     */
    static fromReader(g) {
      return new this().fromReader(g);
    }
    /**
     * Instantiate a coin from a serialized Buffer.
     * @param {Buffer} data
     * @param {String?} enc - Encoding, can be `'hex'` or null.
     * @returns {Coin}
     */
    static fromRaw(g, S) {
      return typeof g == "string" && (g = k.from(g, S)), new this().fromRaw(g);
    }
    /**
     * Inject properties from TX.
     * @param {TX} tx
     * @param {Number} index
     */
    fromTX(g, S, y) {
      return e(typeof S == "number"), e(typeof y == "number"), e(S >= 0 && S < g.outputs.length), this.version = g.version, this.height = y, this.value = g.outputs[S].value, this.script = g.outputs[S].script, this.coinbase = g.isCoinbase(), this.hash = g.hash(), this.index = S, this;
    }
    /**
     * Instantiate a coin from a TX
     * @param {TX} tx
     * @param {Number} index - Output index.
     * @returns {Coin}
     */
    static fromTX(g, S, y) {
      return new this().fromTX(g, S, y);
    }
    /**
     * Test an object to see if it is a Coin.
     * @param {Object} obj
     * @returns {Boolean}
     */
    static isCoin(g) {
      return g instanceof i;
    }
  }
  return La = i, La;
}
var Nn = {};
/*!
 * compress.js - coin compressor for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var s2;
function P7() {
  if (s2) return Nn;
  s2 = 1;
  const e = dt, { encoding: c } = Bt, l = Yr(), w = Xt(), m = 6, f = k.alloc(0);
  function n(b, h) {
    const a = b.getPubkeyhash(!0);
    if (a)
      return h.writeU8(0), h.writeBytes(a), h;
    const E = b.getScripthash();
    if (E)
      return h.writeU8(1), h.writeBytes(E), h;
    const H = b.getPubkey(!0);
    if (H && g(H)) {
      const j = S(H);
      return h.writeBytes(j), h;
    }
    return h.writeVarint(b.raw.length + m), h.writeBytes(b.raw), h;
  }
  function u(b, h) {
    switch (h.readU8()) {
      case 0: {
        const a = h.readBytes(20, !0);
        b.fromPubkeyhash(a);
        break;
      }
      case 1: {
        const a = h.readBytes(20, !0);
        b.fromScripthash(a);
        break;
      }
      case 2:
      case 3:
      case 4:
      case 5: {
        h.offset -= 1;
        const a = h.readBytes(33, !0), E = y(a);
        b.fromPubkey(E);
        break;
      }
      default: {
        h.offset -= 1;
        const a = h.readVarint() - m;
        if (a > w.MAX_SCRIPT_SIZE)
          b.fromNulldata(f), h.seek(a);
        else {
          const E = h.readBytes(a);
          b.fromRaw(E);
        }
        break;
      }
    }
    return b;
  }
  function o(b) {
    if (b.isPubkeyhash(!0) || b.isScripthash())
      return 21;
    const h = b.getPubkey(!0);
    if (h && g(h))
      return 33;
    let a = 0;
    return a += c.sizeVarint(b.raw.length + m), a += b.raw.length, a;
  }
  function s(b, h) {
    return h.writeVarint(b.value), n(b.script, h), h;
  }
  function i(b, h) {
    return b.value = h.readVarint(), u(b.script, h), b;
  }
  function p(b) {
    let h = 0;
    return h += c.sizeVarint(b.value), h += o(b.script), h;
  }
  function g(b) {
    if (b.length === 0)
      return !1;
    switch (b[0]) {
      case 2:
      case 3:
        return b.length === 33;
      case 4:
        return b.length !== 65 ? !1 : l.publicKeyVerify(b);
      default:
        return !1;
    }
  }
  function S(b) {
    let h;
    switch (b[0]) {
      case 2:
      case 3:
        h = b;
        break;
      case 4:
        h = l.publicKeyConvert(b, !0), h[0] = 4 | b[64] & 1;
        break;
      default:
        throw new Error("Bad point format.");
    }
    return e(h.length === 33), h;
  }
  function y(b) {
    const h = b[0];
    switch (e(b.length === 33), h) {
      case 2:
      case 3:
        return b;
      case 4:
        b[0] = 2;
        break;
      case 5:
        b[0] = 3;
        break;
      default:
        throw new Error("Bad point format.");
    }
    const a = l.publicKeyConvert(b, !1);
    return b[0] = h, a;
  }
  return Nn.pack = s, Nn.unpack = i, Nn.size = p, Nn;
}
/*!
 * coinentry.js - coin entry object for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var Ka, o2;
function so() {
  if (o2) return Ka;
  o2 = 1;
  const e = dt, c = Bt, l = no(), w = Vi(), m = P7(), { encoding: f } = c, n = 1, u = (1 << 32 - n >>> 0) - 1;
  class o {
    /**
     * Create a coin entry.
     * @constructor
     */
    constructor() {
      this.version = 1, this.height = -1, this.coinbase = !1, this.output = new w(), this.spent = !1, this.raw = null;
    }
    /**
     * Convert coin entry to an output.
     * @returns {Output}
     */
    toOutput() {
      return this.output;
    }
    /**
     * Convert coin entry to a coin.
     * @param {Outpoint} prevout
     * @returns {Coin}
     */
    toCoin(i) {
      const p = new l();
      return p.version = this.version, p.height = this.height, p.coinbase = this.coinbase, p.script = this.output.script, p.value = this.output.value, p.hash = i.hash, p.index = i.index, p;
    }
    /**
     * Inject properties from TX.
     * @param {TX} tx
     * @param {Number} index
     */
    fromOutput(i) {
      return this.output = i, this;
    }
    /**
     * Instantiate a coin from a TX
     * @param {TX} tx
     * @param {Number} index - Output index.
     * @returns {CoinEntry}
     */
    static fromOutput(i) {
      return new this().fromOutput(i);
    }
    /**
     * Inject properties from TX.
     * @param {TX} tx
     * @param {Number} index
     */
    fromCoin(i) {
      return this.version = i.version, this.height = i.height, this.coinbase = i.coinbase, this.output.script = i.script, this.output.value = i.value, this;
    }
    /**
     * Instantiate a coin from a TX
     * @param {TX} tx
     * @param {Number} index - Output index.
     * @returns {CoinEntry}
     */
    static fromCoin(i) {
      return new this().fromCoin(i);
    }
    /**
     * Inject properties from TX.
     * @param {TX} tx
     * @param {Number} index
     */
    fromTX(i, p, g) {
      return e(typeof p == "number"), e(typeof g == "number"), e(p >= 0 && p < i.outputs.length), this.version = i.version, this.height = g, this.coinbase = i.isCoinbase(), this.output = i.outputs[p], this;
    }
    /**
     * Instantiate a coin from a TX
     * @param {TX} tx
     * @param {Number} index - Output index.
     * @returns {CoinEntry}
     */
    static fromTX(i, p, g) {
      return new this().fromTX(i, p, g);
    }
    /**
     * Calculate size of coin.
     * @returns {Number}
     */
    getSize() {
      if (this.raw)
        return this.raw.length;
      let i = 0;
      return i += f.sizeVarint(this.version), i += 4, i += m.size(this.output), i;
    }
    /**
     * Write the coin to a buffer writer.
     * @param {BufferWriter} bw
     */
    toWriter(i) {
      if (this.raw)
        return i.writeBytes(this.raw), i;
      let p = this.height, g = 0;
      return this.coinbase && (g |= 1), p === -1 && (p = u), g |= p << n, i.writeVarint(this.version), i.writeU32(g), m.pack(this.output, i), i;
    }
    /**
     * Serialize the coin.
     * @returns {Buffer}
     */
    toRaw() {
      if (this.raw)
        return this.raw;
      const i = this.getSize(), p = c.write(i);
      return this.toWriter(p), this.raw = p.render(), this.raw;
    }
    /**
     * Inject properties from serialized buffer writer.
     * @private
     * @param {BufferReader} br
     */
    fromReader(i) {
      const p = i.readVarint(), g = i.readU32();
      let S = g >>> n;
      return S === u && (S = -1), this.version = p, this.coinbase = (g & 1) !== 0, this.height = S, m.unpack(this.output, i), this;
    }
    /**
     * Instantiate a coin from a serialized Buffer.
     * @param {Buffer} data
     * @returns {CoinEntry}
     */
    static fromReader(i) {
      return new this().fromReader(i);
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     */
    fromRaw(i) {
      return this.fromReader(c.read(i)), this.raw = i, this;
    }
    /**
     * Instantiate a coin from a serialized Buffer.
     * @param {Buffer} data
     * @returns {CoinEntry}
     */
    static fromRaw(i) {
      return new this().fromRaw(i);
    }
  }
  return Ka = o, Ka;
}
/*!
 * coins.js - coins object for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var Va, a2;
function Nl() {
  if (a2) return Va;
  a2 = 1;
  const e = dt, c = so();
  class l {
    /**
     * Create coins.
     * @constructor
     */
    constructor() {
      this.outputs = /* @__PURE__ */ new Map();
    }
    /**
     * Add a single entry to the collection.
     * @param {Number} index
     * @param {CoinEntry} coin
     * @returns {CoinEntry}
     */
    add(m, f) {
      return e(m >>> 0 === m), e(f), this.outputs.set(m, f), f;
    }
    /**
     * Add a single output to the collection.
     * @param {Number} index
     * @param {Output} output
     * @returns {CoinEntry}
     */
    addOutput(m, f) {
      return this.add(m, c.fromOutput(f));
    }
    /**
     * Add an output to the collection by output index.
     * @param {TX} tx
     * @param {Number} index
     * @param {Number} height
     * @returns {CoinEntry}
     */
    addIndex(m, f, n) {
      return this.add(f, c.fromTX(m, f, n));
    }
    /**
     * Add a single coin to the collection.
     * @param {Coin} coin
     * @returns {CoinEntry}
     */
    addCoin(m) {
      return this.add(m.index, c.fromCoin(m));
    }
    /**
     * Test whether the collection has a coin.
     * @param {Number} index
     * @returns {Boolean}
     */
    has(m) {
      return this.outputs.has(m);
    }
    /**
     * Test whether the collection has an unspent coin.
     * @param {Number} index
     * @returns {Boolean}
     */
    isUnspent(m) {
      const f = this.outputs.get(m);
      return !(!f || f.spent);
    }
    /**
     * Get a coin entry.
     * @param {Number} index
     * @returns {CoinEntry|null}
     */
    get(m) {
      return this.outputs.get(m) || null;
    }
    /**
     * Get an output.
     * @param {Number} index
     * @returns {Output|null}
     */
    getOutput(m) {
      const f = this.outputs.get(m);
      return f ? f.output : null;
    }
    /**
     * Get a coin.
     * @param {Outpoint} prevout
     * @returns {Coin|null}
     */
    getCoin(m) {
      const f = this.outputs.get(m.index);
      return f ? f.toCoin(m) : null;
    }
    /**
     * Spend a coin entry and return it.
     * @param {Number} index
     * @returns {CoinEntry|null}
     */
    spend(m) {
      const f = this.get(m);
      return !f || f.spent ? null : (f.spent = !0, f);
    }
    /**
     * Remove a coin entry and return it.
     * @param {Number} index
     * @returns {CoinEntry|null}
     */
    remove(m) {
      const f = this.get(m);
      return f ? (this.outputs.delete(m), f) : null;
    }
    /**
     * Test whether the coins are fully spent.
     * @returns {Boolean}
     */
    isEmpty() {
      return this.outputs.size === 0;
    }
    /**
     * Inject properties from tx.
     * @private
     * @param {TX} tx
     * @param {Number} height
     * @returns {Coins}
     */
    fromTX(m, f) {
      e(typeof f == "number");
      for (let n = 0; n < m.outputs.length; n++) {
        if (m.outputs[n].script.isUnspendable())
          continue;
        const o = c.fromTX(m, n, f);
        this.outputs.set(n, o);
      }
      return this;
    }
    /**
     * Instantiate a coins object from a transaction.
     * @param {TX} tx
     * @param {Number} height
     * @returns {Coins}
     */
    static fromTX(m, f) {
      return new this().fromTX(m, f);
    }
  }
  return Va = l, Va;
}
/*!
 * undocoins.js - undocoins object for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var $a, f2;
function k7() {
  if (f2) return $a;
  f2 = 1;
  const e = dt, c = Bt, l = so();
  class w {
    /**
     * Create undo coins.
     * @constructor
     */
    constructor() {
      this.items = [];
    }
    /**
     * Push coin entry onto undo coin array.
     * @param {CoinEntry}
     * @returns {Number}
     */
    push(f) {
      return this.items.push(f);
    }
    /**
     * Calculate undo coins size.
     * @returns {Number}
     */
    getSize() {
      let f = 0;
      f += 4;
      for (const n of this.items)
        f += n.getSize();
      return f;
    }
    /**
     * Serialize all undo coins.
     * @returns {Buffer}
     */
    toRaw() {
      const f = this.getSize(), n = c.write(f);
      n.writeU32(this.items.length);
      for (const u of this.items)
        u.toWriter(n);
      return n.render();
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     * @returns {UndoCoins}
     */
    fromRaw(f) {
      const n = c.read(f), u = n.readU32();
      for (let o = 0; o < u; o++)
        this.items.push(l.fromReader(n));
      return this;
    }
    /**
     * Instantiate undo coins from serialized data.
     * @param {Buffer} data
     * @returns {UndoCoins}
     */
    static fromRaw(f) {
      return new this().fromRaw(f);
    }
    /**
     * Test whether the undo coins have any members.
     * @returns {Boolean}
     */
    isEmpty() {
      return this.items.length === 0;
    }
    /**
     * Render the undo coins.
     * @returns {Buffer}
     */
    commit() {
      const f = this.toRaw();
      return this.items.length = 0, f;
    }
    /**
     * Re-apply undo coins to a view, effectively unspending them.
     * @param {CoinView} view
     * @param {Outpoint} prevout
     */
    apply(f, n) {
      const u = this.items.pop();
      e(u), f.addEntry(n, u);
    }
  }
  return $a = w, $a;
}
/*!
 * coinview.js - coin viewpoint object for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var ja, c2;
function ql() {
  if (c2) return ja;
  c2 = 1;
  const { BufferMap: e } = xn, c = Nl(), l = k7(), w = so();
  class m {
    /**
     * Create a coin view.
     * @constructor
     */
    constructor() {
      this.map = new e(), this.undo = new l();
    }
    /**
     * Get coins.
     * @param {Hash} hash
     * @returns {Coins} coins
     */
    get(n) {
      return this.map.get(n);
    }
    /**
     * Test whether the view has an entry.
     * @param {Hash} hash
     * @returns {Boolean}
     */
    has(n) {
      return this.map.has(n);
    }
    /**
     * Add coins to the collection.
     * @param {Hash} hash
     * @param {Coins} coins
     * @returns {Coins}
     */
    add(n, u) {
      return this.map.set(n, u), u;
    }
    /**
     * Ensure existence of coins object in the collection.
     * @param {Hash} hash
     * @returns {Coins}
     */
    ensure(n) {
      const u = this.map.get(n);
      return u || this.add(n, new c());
    }
    /**
     * Remove coins from the collection.
     * @param {Coins} coins
     * @returns {Coins|null}
     */
    remove(n) {
      const u = this.map.get(n);
      return u ? (this.map.delete(n), u) : null;
    }
    /**
     * Add a tx to the collection.
     * @param {TX} tx
     * @param {Number} height
     * @returns {Coins}
     */
    addTX(n, u) {
      const o = n.hash(), s = c.fromTX(n, u);
      return this.add(o, s);
    }
    /**
     * Remove a tx from the collection.
     * @param {TX} tx
     * @param {Number} height
     * @returns {Coins}
     */
    removeTX(n, u) {
      const o = n.hash(), s = c.fromTX(n, u);
      for (const i of s.outputs.values())
        i.spent = !0;
      return this.add(o, s);
    }
    /**
     * Add an entry to the collection.
     * @param {Outpoint} prevout
     * @param {CoinEntry} coin
     * @returns {CoinEntry|null}
     */
    addEntry(n, u) {
      const { hash: o, index: s } = n;
      return this.ensure(o).add(s, u);
    }
    /**
     * Add a coin to the collection.
     * @param {Coin} coin
     * @returns {CoinEntry|null}
     */
    addCoin(n) {
      return this.ensure(n.hash).addCoin(n);
    }
    /**
     * Add an output to the collection.
     * @param {Outpoint} prevout
     * @param {Output} output
     * @returns {CoinEntry|null}
     */
    addOutput(n, u) {
      const { hash: o, index: s } = n;
      return this.ensure(o).addOutput(s, u);
    }
    /**
     * Add an output to the collection by output index.
     * @param {TX} tx
     * @param {Number} index
     * @param {Number} height
     * @returns {CoinEntry|null}
     */
    addIndex(n, u, o) {
      const s = n.hash();
      return this.ensure(s).addIndex(n, u, o);
    }
    /**
     * Spend an output.
     * @param {Outpoint} prevout
     * @returns {CoinEntry|null}
     */
    spendEntry(n) {
      const { hash: u, index: o } = n, s = this.get(u);
      if (!s)
        return null;
      const i = s.spend(o);
      return i ? (this.undo.push(i), i) : null;
    }
    /**
     * Remove an output.
     * @param {Outpoint} prevout
     * @returns {CoinEntry|null}
     */
    removeEntry(n) {
      const { hash: u, index: o } = n, s = this.get(u);
      return s ? s.remove(o) : null;
    }
    /**
     * Test whether the view has an entry by prevout.
     * @param {Outpoint} prevout
     * @returns {Boolean}
     */
    hasEntry(n) {
      const { hash: u, index: o } = n, s = this.get(u);
      return s ? s.has(o) : !1;
    }
    /**
     * Get a single entry by prevout.
     * @param {Outpoint} prevout
     * @returns {CoinEntry|null}
     */
    getEntry(n) {
      const { hash: u, index: o } = n, s = this.get(u);
      return s ? s.get(o) : null;
    }
    /**
     * Test whether an entry has been spent by prevout.
     * @param {Outpoint} prevout
     * @returns {Boolean}
     */
    isUnspent(n) {
      const { hash: u, index: o } = n, s = this.get(u);
      return s ? s.isUnspent(o) : !1;
    }
    /**
     * Get a single coin by prevout.
     * @param {Outpoint} prevout
     * @returns {Coin|null}
     */
    getCoin(n) {
      const u = this.get(n.hash);
      return u ? u.getCoin(n) : null;
    }
    /**
     * Get a single output by prevout.
     * @param {Outpoint} prevout
     * @returns {Output|null}
     */
    getOutput(n) {
      const { hash: u, index: o } = n, s = this.get(u);
      return s ? s.getOutput(o) : null;
    }
    /**
     * Get coins height by prevout.
     * @param {Outpoint} prevout
     * @returns {Number}
     */
    getHeight(n) {
      const u = this.getEntry(n);
      return u ? u.height : -1;
    }
    /**
     * Get coins coinbase flag by prevout.
     * @param {Outpoint} prevout
     * @returns {Boolean}
     */
    isCoinbase(n) {
      const u = this.getEntry(n);
      return u ? u.coinbase : !1;
    }
    /**
     * Test whether the view has an entry by input.
     * @param {Input} input
     * @returns {Boolean}
     */
    hasEntryFor(n) {
      return this.hasEntry(n.prevout);
    }
    /**
     * Get a single entry by input.
     * @param {Input} input
     * @returns {CoinEntry|null}
     */
    getEntryFor(n) {
      return this.getEntry(n.prevout);
    }
    /**
     * Test whether an entry has been spent by input.
     * @param {Input} input
     * @returns {Boolean}
     */
    isUnspentFor(n) {
      return this.isUnspent(n.prevout);
    }
    /**
     * Get a single coin by input.
     * @param {Input} input
     * @returns {Coin|null}
     */
    getCoinFor(n) {
      return this.getCoin(n.prevout);
    }
    /**
     * Get a single output by input.
     * @param {Input} input
     * @returns {Output|null}
     */
    getOutputFor(n) {
      return this.getOutput(n.prevout);
    }
    /**
     * Get coins height by input.
     * @param {Input} input
     * @returns {Number}
     */
    getHeightFor(n) {
      return this.getHeight(n.prevout);
    }
    /**
     * Get coins coinbase flag by input.
     * @param {Input} input
     * @returns {Boolean}
     */
    isCoinbaseFor(n) {
      return this.isCoinbase(n.prevout);
    }
    /**
     * Retrieve coins from database.
     * @method
     * @param {ChainDB} db
     * @param {Outpoint} prevout
     * @returns {Promise} - Returns {@link CoinEntry}.
     */
    async readCoin(n, u) {
      const o = this.getEntry(u);
      if (o)
        return o;
      const s = await n.readCoin(u);
      return s ? this.addEntry(u, s) : null;
    }
    /**
     * Read all input coins into unspent map.
     * @method
     * @param {ChainDB} db
     * @param {TX} tx
     * @returns {Promise} - Returns {Boolean}.
     */
    async readInputs(n, u) {
      let o = !0;
      for (const { prevout: s } of u.inputs)
        await this.readCoin(n, s) || (o = !1);
      return o;
    }
    /**
     * Spend coins for transaction.
     * @method
     * @param {ChainDB} db
     * @param {TX} tx
     * @returns {Promise} - Returns {Boolean}.
     */
    async spendInputs(n, u) {
      let o = 0;
      for (; o < u.inputs.length; ) {
        const s = Math.min(o + 4, u.inputs.length), i = [];
        for (; o < s; o++) {
          const { prevout: g } = u.inputs[o];
          i.push(this.readCoin(n, g));
        }
        const p = await Promise.all(i);
        for (const g of p) {
          if (!g || g.spent)
            return !1;
          g.spent = !0, this.undo.push(g);
        }
      }
      return !0;
    }
    /**
     * Calculate serialization size.
     * @returns {Number}
     */
    getSize(n) {
      let u = 0;
      u += n.inputs.length;
      for (const { prevout: o } of n.inputs) {
        const s = this.getEntry(o);
        s && (u += s.getSize());
      }
      return u;
    }
    /**
     * Write coin data to buffer writer
     * as it pertains to a transaction.
     * @param {BufferWriter} bw
     * @param {TX} tx
     */
    toWriter(n, u) {
      for (const { prevout: o } of u.inputs) {
        const s = this.getEntry(o);
        if (!s) {
          n.writeU8(0);
          continue;
        }
        n.writeU8(1), s.toWriter(n);
      }
      return n;
    }
    /**
     * Read serialized view data from a buffer
     * reader as it pertains to a transaction.
     * @private
     * @param {BufferReader} br
     * @param {TX} tx
     */
    fromReader(n, u) {
      for (const { prevout: o } of u.inputs) {
        if (n.readU8() === 0)
          continue;
        const s = w.fromReader(n);
        this.addEntry(o, s);
      }
      return this;
    }
    /**
     * Read serialized view data from a buffer
     * reader as it pertains to a transaction.
     * @param {BufferReader} br
     * @param {TX} tx
     * @returns {CoinView}
     */
    static fromReader(n, u) {
      return new this().fromReader(n, u);
    }
  }
  return ja = m, ja;
}
/*!
 * coins/index.js - utxo management for bcoin
 * Copyright (c) 2016-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var u2;
function qg() {
  return u2 || (u2 = 1, Zi.Coins = Nl(), Zi.CoinView = ql(), Zi.compress = P7(), Zi.UndoCoins = k7()), Zi;
}
var Ya = {}, Xa = {};
/*!
 * common.js - common functions for hd
 * Copyright (c) 2015-2016, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var h2;
function oo() {
  return h2 || (h2 = 1, function(e) {
    const c = dt, l = Lm, w = e;
    w.HARDENED = 2147483648, w.MIN_ENTROPY = 128, w.MAX_ENTROPY = 512, w.cache = new l(500), w.parsePath = function(f, n) {
      c(typeof f == "string"), c(typeof n == "boolean"), c(f.length >= 1), c(f.length <= 3062);
      const u = f.split("/"), o = u[0];
      if (o !== "m" && o !== "M" && o !== "m'" && o !== "M'")
        throw new Error("Invalid path root.");
      const s = [];
      for (let i = 1; i < u.length; i++) {
        let p = u[i];
        const g = p[p.length - 1] === "'";
        if (g && (p = p.slice(0, -1)), p.length > 10)
          throw new Error("Path index too large.");
        if (!/^\d+$/.test(p))
          throw new Error("Path index is non-numeric.");
        let S = parseInt(p, 10);
        if (S >>> 0 !== S)
          throw new Error("Path index out of range.");
        if (g && (S |= w.HARDENED, S >>>= 0), !n && S & w.HARDENED)
          throw new Error("Path index cannot be hardened.");
        s.push(S);
      }
      return s;
    }, w.isMaster = function(f) {
      return f.depth === 0 && f.childIndex === 0 && f.parentFingerPrint === 0;
    }, w.isAccount = function(f, n) {
      if (n != null) {
        const u = (w.HARDENED | n) >>> 0;
        if (f.childIndex !== u)
          return !1;
      }
      return f.depth === 3 && (f.childIndex & w.HARDENED) !== 0;
    }, w.ZERO_KEY = k.alloc(33, 0);
  }(Xa)), Xa;
}
/*!
 * cleanse.js - memzero for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var Ga, l2;
function ao() {
  if (l2) return Ga;
  l2 = 1;
  const e = Mt(), c = Hi();
  function l(w) {
    e(k.isBuffer(w)), c.randomFill(w, 0, w.length);
  }
  return l.native = 0, Ga = l, Ga;
}
var qn = {};
/*!
 * pbkdf2.js - pbkdf2 for bcrypto
 * Copyright (c) 2014-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/PBKDF2
 *   https://tools.ietf.org/html/rfc2898
 *   https://tools.ietf.org/html/rfc2898#section-5.2
 *   https://tools.ietf.org/html/rfc6070
 *   https://www.emc.com/collateral/white-papers/h11302-pkcs5v2-1-password-based-cryptography-standard-wp.pdf
 *   http://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-132.pdf
 */
var d2;
function Tl() {
  if (d2) return qn;
  d2 = 1;
  const e = Mt(), l = (dn.crypto || dn.msCrypto || {}).subtle || {};
  function w(n, u, o, s, i) {
    typeof u == "string" && (u = k.from(u, "utf8")), typeof o == "string" && (o = k.from(o, "utf8")), o == null && (o = k.alloc(0)), e(n && typeof n.id == "string"), e(k.isBuffer(u)), e(k.isBuffer(o)), e(s >>> 0 === s), e(i >>> 0 === i);
    const p = n.size, g = Math.ceil(i / p), S = k.alloc(g * p), y = k.alloc(o.length + 4);
    o.copy(y, 0), u.length > n.blockSize && (u = n.digest(u), e(u.length <= n.blockSize));
    for (let b = 0; b < g; b++) {
      const h = b + 1;
      y[o.length + 0] = h >>> 24, y[o.length + 1] = h >>> 16, y[o.length + 2] = h >>> 8, y[o.length + 3] = h;
      const a = n.mac(y, u);
      let E = a;
      for (let H = 1; H < s; H++) {
        E = n.mac(E, u);
        for (let j = 0; j < p; j++)
          a[j] ^= E[j];
      }
      a.copy(S, b * p);
    }
    return S.slice(0, i);
  }
  async function m(n, u, o, s, i) {
    typeof u == "string" && (u = k.from(u, "utf8")), typeof o == "string" && (o = k.from(o, "utf8")), o == null && (o = k.alloc(0)), e(n && typeof n.id == "string"), e(k.isBuffer(u)), e(k.isBuffer(o)), e(s >>> 0 === s), e(i >>> 0 === i);
    const p = f(n);
    if (!l.importKey || !l.deriveBits || !p)
      return w(n, u, o, s, i);
    const g = { name: "PBKDF2" }, S = ["deriveBits"], y = {
      name: "PBKDF2",
      salt: o,
      iterations: s,
      hash: p
    }, b = await l.importKey("raw", u, g, !1, S), h = await l.deriveBits(y, b, i * 8);
    return k.from(h);
  }
  function f(n) {
    switch (n.id) {
      case "SHA1":
        return "SHA-1";
      case "SHA256":
        return "SHA-256";
      case "SHA384":
        return "SHA-384";
      case "SHA512":
        return "SHA-512";
      default:
        return null;
    }
  }
  return qn.native = 0, qn.derive = w, qn.deriveAsync = m, qn;
}
/*!
 * sha512.js - SHA512 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/hash.js:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/hash.js
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/SHA-2
 *   https://tools.ietf.org/html/rfc4634
 *   https://github.com/indutny/hash.js/blob/master/lib/hash/sha/512.js
 */
var Ja, b2;
function $i() {
  if (b2) return Ja;
  b2 = 1;
  const e = Mt(), c = ni(), l = -1, w = k.alloc(16, 0), m = k.alloc(128, 0);
  m[0] = 128;
  const f = new Uint32Array([
    1116352408,
    3609767458,
    1899447441,
    602891725,
    3049323471,
    3964484399,
    3921009573,
    2173295548,
    961987163,
    4081628472,
    1508970993,
    3053834265,
    2453635748,
    2937671579,
    2870763221,
    3664609560,
    3624381080,
    2734883394,
    310598401,
    1164996542,
    607225278,
    1323610764,
    1426881987,
    3590304994,
    1925078388,
    4068182383,
    2162078206,
    991336113,
    2614888103,
    633803317,
    3248222580,
    3479774868,
    3835390401,
    2666613458,
    4022224774,
    944711139,
    264347078,
    2341262773,
    604807628,
    2007800933,
    770255983,
    1495990901,
    1249150122,
    1856431235,
    1555081692,
    3175218132,
    1996064986,
    2198950837,
    2554220882,
    3999719339,
    2821834349,
    766784016,
    2952996808,
    2566594879,
    3210313671,
    3203337956,
    3336571891,
    1034457026,
    3584528711,
    2466948901,
    113926993,
    3758326383,
    338241895,
    168717936,
    666307205,
    1188179964,
    773529912,
    1546045734,
    1294757372,
    1522805485,
    1396182291,
    2643833823,
    1695183700,
    2343527390,
    1986661051,
    1014477480,
    2177026350,
    1206759142,
    2456956037,
    344077627,
    2730485921,
    1290863460,
    2820302411,
    3158454273,
    3259730800,
    3505952657,
    3345764771,
    106217008,
    3516065817,
    3606008344,
    3600352804,
    1432725776,
    4094571909,
    1467031594,
    275423344,
    851169720,
    430227734,
    3100823752,
    506948616,
    1363258195,
    659060556,
    3750685593,
    883997877,
    3785050280,
    958139571,
    3318307427,
    1322822218,
    3812723403,
    1537002063,
    2003034995,
    1747873779,
    3602036899,
    1955562222,
    1575990012,
    2024104815,
    1125592928,
    2227730452,
    2716904306,
    2361852424,
    442776044,
    2428436474,
    593698344,
    2756734187,
    3733110249,
    3204031479,
    2999351573,
    3329325298,
    3815920427,
    3391569614,
    3928383900,
    3515267271,
    566280711,
    3940187606,
    3454069534,
    4118630271,
    4000239992,
    116418474,
    1914138554,
    174292421,
    2731055270,
    289380356,
    3203993006,
    460393269,
    320620315,
    685471733,
    587496836,
    852142971,
    1086792851,
    1017036298,
    365543100,
    1126000580,
    2618297676,
    1288033470,
    3409855158,
    1501505948,
    4234509866,
    1607167915,
    987167468,
    1816402316,
    1246189591
  ]);
  class n {
    constructor() {
      this.state = new Uint32Array(16), this.msg = new Uint32Array(160), this.block = k.alloc(128), this.size = l;
    }
    init() {
      return this.state[0] = 1779033703, this.state[1] = 4089235720, this.state[2] = 3144134277, this.state[3] = 2227873595, this.state[4] = 1013904242, this.state[5] = 4271175723, this.state[6] = 2773480762, this.state[7] = 1595750129, this.state[8] = 1359893119, this.state[9] = 2917565137, this.state[10] = 2600822924, this.state[11] = 725511199, this.state[12] = 528734635, this.state[13] = 4215389547, this.state[14] = 1541459225, this.state[15] = 327033209, this.size = 0, this;
    }
    update(D) {
      return e(k.isBuffer(D)), this._update(D, D.length), this;
    }
    final() {
      return this._final(k.alloc(64));
    }
    _update(D, Q) {
      e(this.size !== l, "Context is not initialized.");
      let W = this.size & 127, oe = 0;
      if (this.size += Q, W > 0) {
        let v = 128 - W;
        if (v > Q && (v = Q), D.copy(this.block, W, oe, oe + v), W += v, Q -= v, oe += v, W < 128)
          return;
        this._transform(this.block, 0);
      }
      for (; Q >= 128; )
        this._transform(D, oe), oe += 128, Q -= 128;
      Q > 0 && D.copy(this.block, 0, oe, oe + Q);
    }
    /**
     * Finalize SHA512 context.
     * @private
     * @param {Buffer} out
     * @returns {Buffer}
     */
    _final(D) {
      e(this.size !== l, "Context is not initialized.");
      const Q = this.size & 127, W = this.size * 8;
      ue(w, W * (1 / 4294967296) >>> 0, 8), ue(w, W >>> 0, 12), this._update(m, 1 + (239 - Q & 127)), this._update(w, 16);
      for (let oe = 0; oe < 16; oe++)
        ue(D, this.state[oe], oe * 4), this.state[oe] = 0;
      for (let oe = 0; oe < 160; oe++)
        this.msg[oe] = 0;
      for (let oe = 0; oe < 128; oe++)
        this.block[oe] = 0;
      return this.size = l, D;
    }
    _prepare(D, Q) {
      const W = this.msg;
      let oe = 0;
      for (; oe < 32; oe++)
        W[oe] = fe(D, Q + oe * 4);
      for (; oe < 160; oe += 2) {
        const v = R(W[oe - 4], W[oe - 3]), Y = L(W[oe - 4], W[oe - 3]), he = W[oe - 14], le = W[oe - 13], ge = _(W[oe - 30], W[oe - 29]), Ee = F(W[oe - 30], W[oe - 29]), we = W[oe - 32], z = W[oe - 31];
        W[oe + 0] = i(
          v,
          Y,
          he,
          le,
          ge,
          Ee,
          we,
          z
        ), W[oe + 1] = p(
          v,
          Y,
          he,
          le,
          ge,
          Ee,
          we,
          z
        );
      }
    }
    _transform(D, Q) {
      const W = this.msg;
      this._prepare(D, Q);
      let oe = this.state[0], v = this.state[1], Y = this.state[2], he = this.state[3], le = this.state[4], ge = this.state[5], Ee = this.state[6], we = this.state[7], z = this.state[8], I = this.state[9], ne = this.state[10], t = this.state[11], d = this.state[12], B = this.state[13], U = this.state[14], J = this.state[15];
      for (let C = 0; C < W.length; C += 2) {
        let M = U, $ = J, r = A(z, I), x = q(z, I);
        const O = E(z, I, ne, t, d), K = H(z, I, ne, t, d, B), X = f[C + 0], P = f[C + 1], V = W[C + 0], re = W[C + 1], ce = g(
          M,
          $,
          r,
          x,
          O,
          K,
          X,
          P,
          V,
          re
        ), de = S(
          M,
          $,
          r,
          x,
          O,
          K,
          X,
          P,
          V,
          re
        );
        M = N(oe, v), $ = T(oe, v), r = j(oe, v, Y, he, le), x = G(oe, v, Y, he, le, ge);
        const pe = o(M, $, r, x), se = s(M, $, r, x);
        U = d, J = B, d = ne, B = t, ne = z, t = I, z = o(Ee, we, ce, de), I = s(we, we, ce, de), Ee = le, we = ge, le = Y, ge = he, Y = oe, he = v, oe = o(ce, de, pe, se), v = s(ce, de, pe, se);
      }
      u(this.state, 0, oe, v), u(this.state, 2, Y, he), u(this.state, 4, le, ge), u(this.state, 6, Ee, we), u(this.state, 8, z, I), u(this.state, 10, ne, t), u(this.state, 12, d, B), u(this.state, 14, U, J);
    }
    static hash() {
      return new n();
    }
    static hmac() {
      return new c(n, 128);
    }
    static digest(D) {
      return n.ctx.init().update(D).final();
    }
    static root(D, Q) {
      return e(k.isBuffer(D) && D.length === 64), e(k.isBuffer(Q) && Q.length === 64), n.ctx.init().update(D).update(Q).final();
    }
    static multi(D, Q, W) {
      const { ctx: oe } = n;
      return oe.init(), oe.update(D), oe.update(Q), W && oe.update(W), oe.final();
    }
    static mac(D, Q) {
      return n.hmac().init(Q).update(D).final();
    }
  }
  n.native = 0, n.id = "SHA512", n.size = 64, n.bits = 512, n.blockSize = 128, n.zero = k.alloc(64, 0), n.ctx = new n();
  function u(ae, D, Q, W) {
    const oe = ae[D + 0], v = ae[D + 1], Y = W + v >>> 0, he = (Y < W) + Q + oe;
    ae[D + 0] = he >>> 0, ae[D + 1] = Y;
  }
  function o(ae, D, Q, W) {
    return (D + W >>> 0 < D) + ae + Q >>> 0;
  }
  function s(ae, D, Q, W) {
    return D + W >>> 0;
  }
  function i(ae, D, Q, W, oe, v, Y, he) {
    let le = 0, ge = D;
    return ge = ge + W >>> 0, le += ge < D, ge = ge + v >>> 0, le += ge < v, ge = ge + he >>> 0, le += ge < he, ae + Q + oe + Y + le >>> 0;
  }
  function p(ae, D, Q, W, oe, v, Y, he) {
    return D + W + v + he >>> 0;
  }
  function g(ae, D, Q, W, oe, v, Y, he, le, ge) {
    let Ee = 0, we = D;
    return we = we + W >>> 0, Ee += we < D, we = we + v >>> 0, Ee += we < v, we = we + he >>> 0, Ee += we < he, we = we + ge >>> 0, Ee += we < ge, ae + Q + oe + Y + le + Ee >>> 0;
  }
  function S(ae, D, Q, W, oe, v, Y, he, le, ge) {
    return D + W + v + he + ge >>> 0;
  }
  function y(ae, D, Q) {
    return (D << 32 - Q | ae >>> Q) >>> 0;
  }
  function b(ae, D, Q) {
    return (ae << 32 - Q | D >>> Q) >>> 0;
  }
  function h(ae, D, Q) {
    return ae >>> Q;
  }
  function a(ae, D, Q) {
    return (ae << 32 - Q | D >>> Q) >>> 0;
  }
  function E(ae, D, Q, W, oe, v) {
    return (ae & Q ^ ~ae & oe) >>> 0;
  }
  function H(ae, D, Q, W, oe, v) {
    return (D & W ^ ~D & v) >>> 0;
  }
  function j(ae, D, Q, W, oe, v) {
    return (ae & Q ^ ae & oe ^ Q & oe) >>> 0;
  }
  function G(ae, D, Q, W, oe, v) {
    return (D & W ^ D & v ^ W & v) >>> 0;
  }
  function N(ae, D) {
    const Q = y(ae, D, 28), W = y(D, ae, 2), oe = y(D, ae, 7);
    return (Q ^ W ^ oe) >>> 0;
  }
  function T(ae, D) {
    const Q = b(ae, D, 28), W = b(D, ae, 2), oe = b(D, ae, 7);
    return (Q ^ W ^ oe) >>> 0;
  }
  function A(ae, D) {
    const Q = y(ae, D, 14), W = y(ae, D, 18), oe = y(D, ae, 9);
    return (Q ^ W ^ oe) >>> 0;
  }
  function q(ae, D) {
    const Q = b(ae, D, 14), W = b(ae, D, 18), oe = b(D, ae, 9);
    return (Q ^ W ^ oe) >>> 0;
  }
  function _(ae, D) {
    const Q = y(ae, D, 1), W = y(ae, D, 8), oe = h(ae, D, 7);
    return (Q ^ W ^ oe) >>> 0;
  }
  function F(ae, D) {
    const Q = b(ae, D, 1), W = b(ae, D, 8), oe = a(ae, D, 7);
    return (Q ^ W ^ oe) >>> 0;
  }
  function R(ae, D) {
    const Q = y(ae, D, 19), W = y(D, ae, 29), oe = h(ae, D, 6);
    return (Q ^ W ^ oe) >>> 0;
  }
  function L(ae, D) {
    const Q = b(ae, D, 19), W = b(D, ae, 29), oe = a(ae, D, 6);
    return (Q ^ W ^ oe) >>> 0;
  }
  function fe(ae, D) {
    return ae[D++] * 16777216 + ae[D++] * 65536 + ae[D++] * 256 + ae[D];
  }
  function ue(ae, D, Q) {
    return ae[Q++] = D >>> 24, ae[Q++] = D >>> 16, ae[Q++] = D >>> 8, ae[Q++] = D, Q;
  }
  return Ja = n, Ja;
}
var Wa = {}, Za, p2;
function Tg() {
  return p2 || (p2 = 1, Za = [
    "的",
    "一",
    "是",
    "在",
    "不",
    "了",
    "有",
    "和",
    "人",
    "这",
    "中",
    "大",
    "为",
    "上",
    "个",
    "国",
    "我",
    "以",
    "要",
    "他",
    "时",
    "来",
    "用",
    "们",
    "生",
    "到",
    "作",
    "地",
    "于",
    "出",
    "就",
    "分",
    "对",
    "成",
    "会",
    "可",
    "主",
    "发",
    "年",
    "动",
    "同",
    "工",
    "也",
    "能",
    "下",
    "过",
    "子",
    "说",
    "产",
    "种",
    "面",
    "而",
    "方",
    "后",
    "多",
    "定",
    "行",
    "学",
    "法",
    "所",
    "民",
    "得",
    "经",
    "十",
    "三",
    "之",
    "进",
    "着",
    "等",
    "部",
    "度",
    "家",
    "电",
    "力",
    "里",
    "如",
    "水",
    "化",
    "高",
    "自",
    "二",
    "理",
    "起",
    "小",
    "物",
    "现",
    "实",
    "加",
    "量",
    "都",
    "两",
    "体",
    "制",
    "机",
    "当",
    "使",
    "点",
    "从",
    "业",
    "本",
    "去",
    "把",
    "性",
    "好",
    "应",
    "开",
    "它",
    "合",
    "还",
    "因",
    "由",
    "其",
    "些",
    "然",
    "前",
    "外",
    "天",
    "政",
    "四",
    "日",
    "那",
    "社",
    "义",
    "事",
    "平",
    "形",
    "相",
    "全",
    "表",
    "间",
    "样",
    "与",
    "关",
    "各",
    "重",
    "新",
    "线",
    "内",
    "数",
    "正",
    "心",
    "反",
    "你",
    "明",
    "看",
    "原",
    "又",
    "么",
    "利",
    "比",
    "或",
    "但",
    "质",
    "气",
    "第",
    "向",
    "道",
    "命",
    "此",
    "变",
    "条",
    "只",
    "没",
    "结",
    "解",
    "问",
    "意",
    "建",
    "月",
    "公",
    "无",
    "系",
    "军",
    "很",
    "情",
    "者",
    "最",
    "立",
    "代",
    "想",
    "已",
    "通",
    "并",
    "提",
    "直",
    "题",
    "党",
    "程",
    "展",
    "五",
    "果",
    "料",
    "象",
    "员",
    "革",
    "位",
    "入",
    "常",
    "文",
    "总",
    "次",
    "品",
    "式",
    "活",
    "设",
    "及",
    "管",
    "特",
    "件",
    "长",
    "求",
    "老",
    "头",
    "基",
    "资",
    "边",
    "流",
    "路",
    "级",
    "少",
    "图",
    "山",
    "统",
    "接",
    "知",
    "较",
    "将",
    "组",
    "见",
    "计",
    "别",
    "她",
    "手",
    "角",
    "期",
    "根",
    "论",
    "运",
    "农",
    "指",
    "几",
    "九",
    "区",
    "强",
    "放",
    "决",
    "西",
    "被",
    "干",
    "做",
    "必",
    "战",
    "先",
    "回",
    "则",
    "任",
    "取",
    "据",
    "处",
    "队",
    "南",
    "给",
    "色",
    "光",
    "门",
    "即",
    "保",
    "治",
    "北",
    "造",
    "百",
    "规",
    "热",
    "领",
    "七",
    "海",
    "口",
    "东",
    "导",
    "器",
    "压",
    "志",
    "世",
    "金",
    "增",
    "争",
    "济",
    "阶",
    "油",
    "思",
    "术",
    "极",
    "交",
    "受",
    "联",
    "什",
    "认",
    "六",
    "共",
    "权",
    "收",
    "证",
    "改",
    "清",
    "美",
    "再",
    "采",
    "转",
    "更",
    "单",
    "风",
    "切",
    "打",
    "白",
    "教",
    "速",
    "花",
    "带",
    "安",
    "场",
    "身",
    "车",
    "例",
    "真",
    "务",
    "具",
    "万",
    "每",
    "目",
    "至",
    "达",
    "走",
    "积",
    "示",
    "议",
    "声",
    "报",
    "斗",
    "完",
    "类",
    "八",
    "离",
    "华",
    "名",
    "确",
    "才",
    "科",
    "张",
    "信",
    "马",
    "节",
    "话",
    "米",
    "整",
    "空",
    "元",
    "况",
    "今",
    "集",
    "温",
    "传",
    "土",
    "许",
    "步",
    "群",
    "广",
    "石",
    "记",
    "需",
    "段",
    "研",
    "界",
    "拉",
    "林",
    "律",
    "叫",
    "且",
    "究",
    "观",
    "越",
    "织",
    "装",
    "影",
    "算",
    "低",
    "持",
    "音",
    "众",
    "书",
    "布",
    "复",
    "容",
    "儿",
    "须",
    "际",
    "商",
    "非",
    "验",
    "连",
    "断",
    "深",
    "难",
    "近",
    "矿",
    "千",
    "周",
    "委",
    "素",
    "技",
    "备",
    "半",
    "办",
    "青",
    "省",
    "列",
    "习",
    "响",
    "约",
    "支",
    "般",
    "史",
    "感",
    "劳",
    "便",
    "团",
    "往",
    "酸",
    "历",
    "市",
    "克",
    "何",
    "除",
    "消",
    "构",
    "府",
    "称",
    "太",
    "准",
    "精",
    "值",
    "号",
    "率",
    "族",
    "维",
    "划",
    "选",
    "标",
    "写",
    "存",
    "候",
    "毛",
    "亲",
    "快",
    "效",
    "斯",
    "院",
    "查",
    "江",
    "型",
    "眼",
    "王",
    "按",
    "格",
    "养",
    "易",
    "置",
    "派",
    "层",
    "片",
    "始",
    "却",
    "专",
    "状",
    "育",
    "厂",
    "京",
    "识",
    "适",
    "属",
    "圆",
    "包",
    "火",
    "住",
    "调",
    "满",
    "县",
    "局",
    "照",
    "参",
    "红",
    "细",
    "引",
    "听",
    "该",
    "铁",
    "价",
    "严",
    "首",
    "底",
    "液",
    "官",
    "德",
    "随",
    "病",
    "苏",
    "失",
    "尔",
    "死",
    "讲",
    "配",
    "女",
    "黄",
    "推",
    "显",
    "谈",
    "罪",
    "神",
    "艺",
    "呢",
    "席",
    "含",
    "企",
    "望",
    "密",
    "批",
    "营",
    "项",
    "防",
    "举",
    "球",
    "英",
    "氧",
    "势",
    "告",
    "李",
    "台",
    "落",
    "木",
    "帮",
    "轮",
    "破",
    "亚",
    "师",
    "围",
    "注",
    "远",
    "字",
    "材",
    "排",
    "供",
    "河",
    "态",
    "封",
    "另",
    "施",
    "减",
    "树",
    "溶",
    "怎",
    "止",
    "案",
    "言",
    "士",
    "均",
    "武",
    "固",
    "叶",
    "鱼",
    "波",
    "视",
    "仅",
    "费",
    "紧",
    "爱",
    "左",
    "章",
    "早",
    "朝",
    "害",
    "续",
    "轻",
    "服",
    "试",
    "食",
    "充",
    "兵",
    "源",
    "判",
    "护",
    "司",
    "足",
    "某",
    "练",
    "差",
    "致",
    "板",
    "田",
    "降",
    "黑",
    "犯",
    "负",
    "击",
    "范",
    "继",
    "兴",
    "似",
    "余",
    "坚",
    "曲",
    "输",
    "修",
    "故",
    "城",
    "夫",
    "够",
    "送",
    "笔",
    "船",
    "占",
    "右",
    "财",
    "吃",
    "富",
    "春",
    "职",
    "觉",
    "汉",
    "画",
    "功",
    "巴",
    "跟",
    "虽",
    "杂",
    "飞",
    "检",
    "吸",
    "助",
    "升",
    "阳",
    "互",
    "初",
    "创",
    "抗",
    "考",
    "投",
    "坏",
    "策",
    "古",
    "径",
    "换",
    "未",
    "跑",
    "留",
    "钢",
    "曾",
    "端",
    "责",
    "站",
    "简",
    "述",
    "钱",
    "副",
    "尽",
    "帝",
    "射",
    "草",
    "冲",
    "承",
    "独",
    "令",
    "限",
    "阿",
    "宣",
    "环",
    "双",
    "请",
    "超",
    "微",
    "让",
    "控",
    "州",
    "良",
    "轴",
    "找",
    "否",
    "纪",
    "益",
    "依",
    "优",
    "顶",
    "础",
    "载",
    "倒",
    "房",
    "突",
    "坐",
    "粉",
    "敌",
    "略",
    "客",
    "袁",
    "冷",
    "胜",
    "绝",
    "析",
    "块",
    "剂",
    "测",
    "丝",
    "协",
    "诉",
    "念",
    "陈",
    "仍",
    "罗",
    "盐",
    "友",
    "洋",
    "错",
    "苦",
    "夜",
    "刑",
    "移",
    "频",
    "逐",
    "靠",
    "混",
    "母",
    "短",
    "皮",
    "终",
    "聚",
    "汽",
    "村",
    "云",
    "哪",
    "既",
    "距",
    "卫",
    "停",
    "烈",
    "央",
    "察",
    "烧",
    "迅",
    "境",
    "若",
    "印",
    "洲",
    "刻",
    "括",
    "激",
    "孔",
    "搞",
    "甚",
    "室",
    "待",
    "核",
    "校",
    "散",
    "侵",
    "吧",
    "甲",
    "游",
    "久",
    "菜",
    "味",
    "旧",
    "模",
    "湖",
    "货",
    "损",
    "预",
    "阻",
    "毫",
    "普",
    "稳",
    "乙",
    "妈",
    "植",
    "息",
    "扩",
    "银",
    "语",
    "挥",
    "酒",
    "守",
    "拿",
    "序",
    "纸",
    "医",
    "缺",
    "雨",
    "吗",
    "针",
    "刘",
    "啊",
    "急",
    "唱",
    "误",
    "训",
    "愿",
    "审",
    "附",
    "获",
    "茶",
    "鲜",
    "粮",
    "斤",
    "孩",
    "脱",
    "硫",
    "肥",
    "善",
    "龙",
    "演",
    "父",
    "渐",
    "血",
    "欢",
    "械",
    "掌",
    "歌",
    "沙",
    "刚",
    "攻",
    "谓",
    "盾",
    "讨",
    "晚",
    "粒",
    "乱",
    "燃",
    "矛",
    "乎",
    "杀",
    "药",
    "宁",
    "鲁",
    "贵",
    "钟",
    "煤",
    "读",
    "班",
    "伯",
    "香",
    "介",
    "迫",
    "句",
    "丰",
    "培",
    "握",
    "兰",
    "担",
    "弦",
    "蛋",
    "沉",
    "假",
    "穿",
    "执",
    "答",
    "乐",
    "谁",
    "顺",
    "烟",
    "缩",
    "征",
    "脸",
    "喜",
    "松",
    "脚",
    "困",
    "异",
    "免",
    "背",
    "星",
    "福",
    "买",
    "染",
    "井",
    "概",
    "慢",
    "怕",
    "磁",
    "倍",
    "祖",
    "皇",
    "促",
    "静",
    "补",
    "评",
    "翻",
    "肉",
    "践",
    "尼",
    "衣",
    "宽",
    "扬",
    "棉",
    "希",
    "伤",
    "操",
    "垂",
    "秋",
    "宜",
    "氢",
    "套",
    "督",
    "振",
    "架",
    "亮",
    "末",
    "宪",
    "庆",
    "编",
    "牛",
    "触",
    "映",
    "雷",
    "销",
    "诗",
    "座",
    "居",
    "抓",
    "裂",
    "胞",
    "呼",
    "娘",
    "景",
    "威",
    "绿",
    "晶",
    "厚",
    "盟",
    "衡",
    "鸡",
    "孙",
    "延",
    "危",
    "胶",
    "屋",
    "乡",
    "临",
    "陆",
    "顾",
    "掉",
    "呀",
    "灯",
    "岁",
    "措",
    "束",
    "耐",
    "剧",
    "玉",
    "赵",
    "跳",
    "哥",
    "季",
    "课",
    "凯",
    "胡",
    "额",
    "款",
    "绍",
    "卷",
    "齐",
    "伟",
    "蒸",
    "殖",
    "永",
    "宗",
    "苗",
    "川",
    "炉",
    "岩",
    "弱",
    "零",
    "杨",
    "奏",
    "沿",
    "露",
    "杆",
    "探",
    "滑",
    "镇",
    "饭",
    "浓",
    "航",
    "怀",
    "赶",
    "库",
    "夺",
    "伊",
    "灵",
    "税",
    "途",
    "灭",
    "赛",
    "归",
    "召",
    "鼓",
    "播",
    "盘",
    "裁",
    "险",
    "康",
    "唯",
    "录",
    "菌",
    "纯",
    "借",
    "糖",
    "盖",
    "横",
    "符",
    "私",
    "努",
    "堂",
    "域",
    "枪",
    "润",
    "幅",
    "哈",
    "竟",
    "熟",
    "虫",
    "泽",
    "脑",
    "壤",
    "碳",
    "欧",
    "遍",
    "侧",
    "寨",
    "敢",
    "彻",
    "虑",
    "斜",
    "薄",
    "庭",
    "纳",
    "弹",
    "饲",
    "伸",
    "折",
    "麦",
    "湿",
    "暗",
    "荷",
    "瓦",
    "塞",
    "床",
    "筑",
    "恶",
    "户",
    "访",
    "塔",
    "奇",
    "透",
    "梁",
    "刀",
    "旋",
    "迹",
    "卡",
    "氯",
    "遇",
    "份",
    "毒",
    "泥",
    "退",
    "洗",
    "摆",
    "灰",
    "彩",
    "卖",
    "耗",
    "夏",
    "择",
    "忙",
    "铜",
    "献",
    "硬",
    "予",
    "繁",
    "圈",
    "雪",
    "函",
    "亦",
    "抽",
    "篇",
    "阵",
    "阴",
    "丁",
    "尺",
    "追",
    "堆",
    "雄",
    "迎",
    "泛",
    "爸",
    "楼",
    "避",
    "谋",
    "吨",
    "野",
    "猪",
    "旗",
    "累",
    "偏",
    "典",
    "馆",
    "索",
    "秦",
    "脂",
    "潮",
    "爷",
    "豆",
    "忽",
    "托",
    "惊",
    "塑",
    "遗",
    "愈",
    "朱",
    "替",
    "纤",
    "粗",
    "倾",
    "尚",
    "痛",
    "楚",
    "谢",
    "奋",
    "购",
    "磨",
    "君",
    "池",
    "旁",
    "碎",
    "骨",
    "监",
    "捕",
    "弟",
    "暴",
    "割",
    "贯",
    "殊",
    "释",
    "词",
    "亡",
    "壁",
    "顿",
    "宝",
    "午",
    "尘",
    "闻",
    "揭",
    "炮",
    "残",
    "冬",
    "桥",
    "妇",
    "警",
    "综",
    "招",
    "吴",
    "付",
    "浮",
    "遭",
    "徐",
    "您",
    "摇",
    "谷",
    "赞",
    "箱",
    "隔",
    "订",
    "男",
    "吹",
    "园",
    "纷",
    "唐",
    "败",
    "宋",
    "玻",
    "巨",
    "耕",
    "坦",
    "荣",
    "闭",
    "湾",
    "键",
    "凡",
    "驻",
    "锅",
    "救",
    "恩",
    "剥",
    "凝",
    "碱",
    "齿",
    "截",
    "炼",
    "麻",
    "纺",
    "禁",
    "废",
    "盛",
    "版",
    "缓",
    "净",
    "睛",
    "昌",
    "婚",
    "涉",
    "筒",
    "嘴",
    "插",
    "岸",
    "朗",
    "庄",
    "街",
    "藏",
    "姑",
    "贸",
    "腐",
    "奴",
    "啦",
    "惯",
    "乘",
    "伙",
    "恢",
    "匀",
    "纱",
    "扎",
    "辩",
    "耳",
    "彪",
    "臣",
    "亿",
    "璃",
    "抵",
    "脉",
    "秀",
    "萨",
    "俄",
    "网",
    "舞",
    "店",
    "喷",
    "纵",
    "寸",
    "汗",
    "挂",
    "洪",
    "贺",
    "闪",
    "柬",
    "爆",
    "烯",
    "津",
    "稻",
    "墙",
    "软",
    "勇",
    "像",
    "滚",
    "厘",
    "蒙",
    "芳",
    "肯",
    "坡",
    "柱",
    "荡",
    "腿",
    "仪",
    "旅",
    "尾",
    "轧",
    "冰",
    "贡",
    "登",
    "黎",
    "削",
    "钻",
    "勒",
    "逃",
    "障",
    "氨",
    "郭",
    "峰",
    "币",
    "港",
    "伏",
    "轨",
    "亩",
    "毕",
    "擦",
    "莫",
    "刺",
    "浪",
    "秘",
    "援",
    "株",
    "健",
    "售",
    "股",
    "岛",
    "甘",
    "泡",
    "睡",
    "童",
    "铸",
    "汤",
    "阀",
    "休",
    "汇",
    "舍",
    "牧",
    "绕",
    "炸",
    "哲",
    "磷",
    "绩",
    "朋",
    "淡",
    "尖",
    "启",
    "陷",
    "柴",
    "呈",
    "徒",
    "颜",
    "泪",
    "稍",
    "忘",
    "泵",
    "蓝",
    "拖",
    "洞",
    "授",
    "镜",
    "辛",
    "壮",
    "锋",
    "贫",
    "虚",
    "弯",
    "摩",
    "泰",
    "幼",
    "廷",
    "尊",
    "窗",
    "纲",
    "弄",
    "隶",
    "疑",
    "氏",
    "宫",
    "姐",
    "震",
    "瑞",
    "怪",
    "尤",
    "琴",
    "循",
    "描",
    "膜",
    "违",
    "夹",
    "腰",
    "缘",
    "珠",
    "穷",
    "森",
    "枝",
    "竹",
    "沟",
    "催",
    "绳",
    "忆",
    "邦",
    "剩",
    "幸",
    "浆",
    "栏",
    "拥",
    "牙",
    "贮",
    "礼",
    "滤",
    "钠",
    "纹",
    "罢",
    "拍",
    "咱",
    "喊",
    "袖",
    "埃",
    "勤",
    "罚",
    "焦",
    "潜",
    "伍",
    "墨",
    "欲",
    "缝",
    "姓",
    "刊",
    "饱",
    "仿",
    "奖",
    "铝",
    "鬼",
    "丽",
    "跨",
    "默",
    "挖",
    "链",
    "扫",
    "喝",
    "袋",
    "炭",
    "污",
    "幕",
    "诸",
    "弧",
    "励",
    "梅",
    "奶",
    "洁",
    "灾",
    "舟",
    "鉴",
    "苯",
    "讼",
    "抱",
    "毁",
    "懂",
    "寒",
    "智",
    "埔",
    "寄",
    "届",
    "跃",
    "渡",
    "挑",
    "丹",
    "艰",
    "贝",
    "碰",
    "拔",
    "爹",
    "戴",
    "码",
    "梦",
    "芽",
    "熔",
    "赤",
    "渔",
    "哭",
    "敬",
    "颗",
    "奔",
    "铅",
    "仲",
    "虎",
    "稀",
    "妹",
    "乏",
    "珍",
    "申",
    "桌",
    "遵",
    "允",
    "隆",
    "螺",
    "仓",
    "魏",
    "锐",
    "晓",
    "氮",
    "兼",
    "隐",
    "碍",
    "赫",
    "拨",
    "忠",
    "肃",
    "缸",
    "牵",
    "抢",
    "博",
    "巧",
    "壳",
    "兄",
    "杜",
    "讯",
    "诚",
    "碧",
    "祥",
    "柯",
    "页",
    "巡",
    "矩",
    "悲",
    "灌",
    "龄",
    "伦",
    "票",
    "寻",
    "桂",
    "铺",
    "圣",
    "恐",
    "恰",
    "郑",
    "趣",
    "抬",
    "荒",
    "腾",
    "贴",
    "柔",
    "滴",
    "猛",
    "阔",
    "辆",
    "妻",
    "填",
    "撤",
    "储",
    "签",
    "闹",
    "扰",
    "紫",
    "砂",
    "递",
    "戏",
    "吊",
    "陶",
    "伐",
    "喂",
    "疗",
    "瓶",
    "婆",
    "抚",
    "臂",
    "摸",
    "忍",
    "虾",
    "蜡",
    "邻",
    "胸",
    "巩",
    "挤",
    "偶",
    "弃",
    "槽",
    "劲",
    "乳",
    "邓",
    "吉",
    "仁",
    "烂",
    "砖",
    "租",
    "乌",
    "舰",
    "伴",
    "瓜",
    "浅",
    "丙",
    "暂",
    "燥",
    "橡",
    "柳",
    "迷",
    "暖",
    "牌",
    "秧",
    "胆",
    "详",
    "簧",
    "踏",
    "瓷",
    "谱",
    "呆",
    "宾",
    "糊",
    "洛",
    "辉",
    "愤",
    "竞",
    "隙",
    "怒",
    "粘",
    "乃",
    "绪",
    "肩",
    "籍",
    "敏",
    "涂",
    "熙",
    "皆",
    "侦",
    "悬",
    "掘",
    "享",
    "纠",
    "醒",
    "狂",
    "锁",
    "淀",
    "恨",
    "牲",
    "霸",
    "爬",
    "赏",
    "逆",
    "玩",
    "陵",
    "祝",
    "秒",
    "浙",
    "貌",
    "役",
    "彼",
    "悉",
    "鸭",
    "趋",
    "凤",
    "晨",
    "畜",
    "辈",
    "秩",
    "卵",
    "署",
    "梯",
    "炎",
    "滩",
    "棋",
    "驱",
    "筛",
    "峡",
    "冒",
    "啥",
    "寿",
    "译",
    "浸",
    "泉",
    "帽",
    "迟",
    "硅",
    "疆",
    "贷",
    "漏",
    "稿",
    "冠",
    "嫩",
    "胁",
    "芯",
    "牢",
    "叛",
    "蚀",
    "奥",
    "鸣",
    "岭",
    "羊",
    "凭",
    "串",
    "塘",
    "绘",
    "酵",
    "融",
    "盆",
    "锡",
    "庙",
    "筹",
    "冻",
    "辅",
    "摄",
    "袭",
    "筋",
    "拒",
    "僚",
    "旱",
    "钾",
    "鸟",
    "漆",
    "沈",
    "眉",
    "疏",
    "添",
    "棒",
    "穗",
    "硝",
    "韩",
    "逼",
    "扭",
    "侨",
    "凉",
    "挺",
    "碗",
    "栽",
    "炒",
    "杯",
    "患",
    "馏",
    "劝",
    "豪",
    "辽",
    "勃",
    "鸿",
    "旦",
    "吏",
    "拜",
    "狗",
    "埋",
    "辊",
    "掩",
    "饮",
    "搬",
    "骂",
    "辞",
    "勾",
    "扣",
    "估",
    "蒋",
    "绒",
    "雾",
    "丈",
    "朵",
    "姆",
    "拟",
    "宇",
    "辑",
    "陕",
    "雕",
    "偿",
    "蓄",
    "崇",
    "剪",
    "倡",
    "厅",
    "咬",
    "驶",
    "薯",
    "刷",
    "斥",
    "番",
    "赋",
    "奉",
    "佛",
    "浇",
    "漫",
    "曼",
    "扇",
    "钙",
    "桃",
    "扶",
    "仔",
    "返",
    "俗",
    "亏",
    "腔",
    "鞋",
    "棱",
    "覆",
    "框",
    "悄",
    "叔",
    "撞",
    "骗",
    "勘",
    "旺",
    "沸",
    "孤",
    "吐",
    "孟",
    "渠",
    "屈",
    "疾",
    "妙",
    "惜",
    "仰",
    "狠",
    "胀",
    "谐",
    "抛",
    "霉",
    "桑",
    "岗",
    "嘛",
    "衰",
    "盗",
    "渗",
    "脏",
    "赖",
    "涌",
    "甜",
    "曹",
    "阅",
    "肌",
    "哩",
    "厉",
    "烃",
    "纬",
    "毅",
    "昨",
    "伪",
    "症",
    "煮",
    "叹",
    "钉",
    "搭",
    "茎",
    "笼",
    "酷",
    "偷",
    "弓",
    "锥",
    "恒",
    "杰",
    "坑",
    "鼻",
    "翼",
    "纶",
    "叙",
    "狱",
    "逮",
    "罐",
    "络",
    "棚",
    "抑",
    "膨",
    "蔬",
    "寺",
    "骤",
    "穆",
    "冶",
    "枯",
    "册",
    "尸",
    "凸",
    "绅",
    "坯",
    "牺",
    "焰",
    "轰",
    "欣",
    "晋",
    "瘦",
    "御",
    "锭",
    "锦",
    "丧",
    "旬",
    "锻",
    "垄",
    "搜",
    "扑",
    "邀",
    "亭",
    "酯",
    "迈",
    "舒",
    "脆",
    "酶",
    "闲",
    "忧",
    "酚",
    "顽",
    "羽",
    "涨",
    "卸",
    "仗",
    "陪",
    "辟",
    "惩",
    "杭",
    "姚",
    "肚",
    "捉",
    "飘",
    "漂",
    "昆",
    "欺",
    "吾",
    "郎",
    "烷",
    "汁",
    "呵",
    "饰",
    "萧",
    "雅",
    "邮",
    "迁",
    "燕",
    "撒",
    "姻",
    "赴",
    "宴",
    "烦",
    "债",
    "帐",
    "斑",
    "铃",
    "旨",
    "醇",
    "董",
    "饼",
    "雏",
    "姿",
    "拌",
    "傅",
    "腹",
    "妥",
    "揉",
    "贤",
    "拆",
    "歪",
    "葡",
    "胺",
    "丢",
    "浩",
    "徽",
    "昂",
    "垫",
    "挡",
    "览",
    "贪",
    "慰",
    "缴",
    "汪",
    "慌",
    "冯",
    "诺",
    "姜",
    "谊",
    "凶",
    "劣",
    "诬",
    "耀",
    "昏",
    "躺",
    "盈",
    "骑",
    "乔",
    "溪",
    "丛",
    "卢",
    "抹",
    "闷",
    "咨",
    "刮",
    "驾",
    "缆",
    "悟",
    "摘",
    "铒",
    "掷",
    "颇",
    "幻",
    "柄",
    "惠",
    "惨",
    "佳",
    "仇",
    "腊",
    "窝",
    "涤",
    "剑",
    "瞧",
    "堡",
    "泼",
    "葱",
    "罩",
    "霍",
    "捞",
    "胎",
    "苍",
    "滨",
    "俩",
    "捅",
    "湘",
    "砍",
    "霞",
    "邵",
    "萄",
    "疯",
    "淮",
    "遂",
    "熊",
    "粪",
    "烘",
    "宿",
    "档",
    "戈",
    "驳",
    "嫂",
    "裕",
    "徙",
    "箭",
    "捐",
    "肠",
    "撑",
    "晒",
    "辨",
    "殿",
    "莲",
    "摊",
    "搅",
    "酱",
    "屏",
    "疫",
    "哀",
    "蔡",
    "堵",
    "沫",
    "皱",
    "畅",
    "叠",
    "阁",
    "莱",
    "敲",
    "辖",
    "钩",
    "痕",
    "坝",
    "巷",
    "饿",
    "祸",
    "丘",
    "玄",
    "溜",
    "曰",
    "逻",
    "彭",
    "尝",
    "卿",
    "妨",
    "艇",
    "吞",
    "韦",
    "怨",
    "矮",
    "歇"
  ]), Za;
}
var Qa, m2;
function zg() {
  return m2 || (m2 = 1, Qa = [
    "的",
    "一",
    "是",
    "在",
    "不",
    "了",
    "有",
    "和",
    "人",
    "這",
    "中",
    "大",
    "為",
    "上",
    "個",
    "國",
    "我",
    "以",
    "要",
    "他",
    "時",
    "來",
    "用",
    "們",
    "生",
    "到",
    "作",
    "地",
    "於",
    "出",
    "就",
    "分",
    "對",
    "成",
    "會",
    "可",
    "主",
    "發",
    "年",
    "動",
    "同",
    "工",
    "也",
    "能",
    "下",
    "過",
    "子",
    "說",
    "產",
    "種",
    "面",
    "而",
    "方",
    "後",
    "多",
    "定",
    "行",
    "學",
    "法",
    "所",
    "民",
    "得",
    "經",
    "十",
    "三",
    "之",
    "進",
    "著",
    "等",
    "部",
    "度",
    "家",
    "電",
    "力",
    "裡",
    "如",
    "水",
    "化",
    "高",
    "自",
    "二",
    "理",
    "起",
    "小",
    "物",
    "現",
    "實",
    "加",
    "量",
    "都",
    "兩",
    "體",
    "制",
    "機",
    "當",
    "使",
    "點",
    "從",
    "業",
    "本",
    "去",
    "把",
    "性",
    "好",
    "應",
    "開",
    "它",
    "合",
    "還",
    "因",
    "由",
    "其",
    "些",
    "然",
    "前",
    "外",
    "天",
    "政",
    "四",
    "日",
    "那",
    "社",
    "義",
    "事",
    "平",
    "形",
    "相",
    "全",
    "表",
    "間",
    "樣",
    "與",
    "關",
    "各",
    "重",
    "新",
    "線",
    "內",
    "數",
    "正",
    "心",
    "反",
    "你",
    "明",
    "看",
    "原",
    "又",
    "麼",
    "利",
    "比",
    "或",
    "但",
    "質",
    "氣",
    "第",
    "向",
    "道",
    "命",
    "此",
    "變",
    "條",
    "只",
    "沒",
    "結",
    "解",
    "問",
    "意",
    "建",
    "月",
    "公",
    "無",
    "系",
    "軍",
    "很",
    "情",
    "者",
    "最",
    "立",
    "代",
    "想",
    "已",
    "通",
    "並",
    "提",
    "直",
    "題",
    "黨",
    "程",
    "展",
    "五",
    "果",
    "料",
    "象",
    "員",
    "革",
    "位",
    "入",
    "常",
    "文",
    "總",
    "次",
    "品",
    "式",
    "活",
    "設",
    "及",
    "管",
    "特",
    "件",
    "長",
    "求",
    "老",
    "頭",
    "基",
    "資",
    "邊",
    "流",
    "路",
    "級",
    "少",
    "圖",
    "山",
    "統",
    "接",
    "知",
    "較",
    "將",
    "組",
    "見",
    "計",
    "別",
    "她",
    "手",
    "角",
    "期",
    "根",
    "論",
    "運",
    "農",
    "指",
    "幾",
    "九",
    "區",
    "強",
    "放",
    "決",
    "西",
    "被",
    "幹",
    "做",
    "必",
    "戰",
    "先",
    "回",
    "則",
    "任",
    "取",
    "據",
    "處",
    "隊",
    "南",
    "給",
    "色",
    "光",
    "門",
    "即",
    "保",
    "治",
    "北",
    "造",
    "百",
    "規",
    "熱",
    "領",
    "七",
    "海",
    "口",
    "東",
    "導",
    "器",
    "壓",
    "志",
    "世",
    "金",
    "增",
    "爭",
    "濟",
    "階",
    "油",
    "思",
    "術",
    "極",
    "交",
    "受",
    "聯",
    "什",
    "認",
    "六",
    "共",
    "權",
    "收",
    "證",
    "改",
    "清",
    "美",
    "再",
    "採",
    "轉",
    "更",
    "單",
    "風",
    "切",
    "打",
    "白",
    "教",
    "速",
    "花",
    "帶",
    "安",
    "場",
    "身",
    "車",
    "例",
    "真",
    "務",
    "具",
    "萬",
    "每",
    "目",
    "至",
    "達",
    "走",
    "積",
    "示",
    "議",
    "聲",
    "報",
    "鬥",
    "完",
    "類",
    "八",
    "離",
    "華",
    "名",
    "確",
    "才",
    "科",
    "張",
    "信",
    "馬",
    "節",
    "話",
    "米",
    "整",
    "空",
    "元",
    "況",
    "今",
    "集",
    "溫",
    "傳",
    "土",
    "許",
    "步",
    "群",
    "廣",
    "石",
    "記",
    "需",
    "段",
    "研",
    "界",
    "拉",
    "林",
    "律",
    "叫",
    "且",
    "究",
    "觀",
    "越",
    "織",
    "裝",
    "影",
    "算",
    "低",
    "持",
    "音",
    "眾",
    "書",
    "布",
    "复",
    "容",
    "兒",
    "須",
    "際",
    "商",
    "非",
    "驗",
    "連",
    "斷",
    "深",
    "難",
    "近",
    "礦",
    "千",
    "週",
    "委",
    "素",
    "技",
    "備",
    "半",
    "辦",
    "青",
    "省",
    "列",
    "習",
    "響",
    "約",
    "支",
    "般",
    "史",
    "感",
    "勞",
    "便",
    "團",
    "往",
    "酸",
    "歷",
    "市",
    "克",
    "何",
    "除",
    "消",
    "構",
    "府",
    "稱",
    "太",
    "準",
    "精",
    "值",
    "號",
    "率",
    "族",
    "維",
    "劃",
    "選",
    "標",
    "寫",
    "存",
    "候",
    "毛",
    "親",
    "快",
    "效",
    "斯",
    "院",
    "查",
    "江",
    "型",
    "眼",
    "王",
    "按",
    "格",
    "養",
    "易",
    "置",
    "派",
    "層",
    "片",
    "始",
    "卻",
    "專",
    "狀",
    "育",
    "廠",
    "京",
    "識",
    "適",
    "屬",
    "圓",
    "包",
    "火",
    "住",
    "調",
    "滿",
    "縣",
    "局",
    "照",
    "參",
    "紅",
    "細",
    "引",
    "聽",
    "該",
    "鐵",
    "價",
    "嚴",
    "首",
    "底",
    "液",
    "官",
    "德",
    "隨",
    "病",
    "蘇",
    "失",
    "爾",
    "死",
    "講",
    "配",
    "女",
    "黃",
    "推",
    "顯",
    "談",
    "罪",
    "神",
    "藝",
    "呢",
    "席",
    "含",
    "企",
    "望",
    "密",
    "批",
    "營",
    "項",
    "防",
    "舉",
    "球",
    "英",
    "氧",
    "勢",
    "告",
    "李",
    "台",
    "落",
    "木",
    "幫",
    "輪",
    "破",
    "亞",
    "師",
    "圍",
    "注",
    "遠",
    "字",
    "材",
    "排",
    "供",
    "河",
    "態",
    "封",
    "另",
    "施",
    "減",
    "樹",
    "溶",
    "怎",
    "止",
    "案",
    "言",
    "士",
    "均",
    "武",
    "固",
    "葉",
    "魚",
    "波",
    "視",
    "僅",
    "費",
    "緊",
    "愛",
    "左",
    "章",
    "早",
    "朝",
    "害",
    "續",
    "輕",
    "服",
    "試",
    "食",
    "充",
    "兵",
    "源",
    "判",
    "護",
    "司",
    "足",
    "某",
    "練",
    "差",
    "致",
    "板",
    "田",
    "降",
    "黑",
    "犯",
    "負",
    "擊",
    "范",
    "繼",
    "興",
    "似",
    "餘",
    "堅",
    "曲",
    "輸",
    "修",
    "故",
    "城",
    "夫",
    "夠",
    "送",
    "筆",
    "船",
    "佔",
    "右",
    "財",
    "吃",
    "富",
    "春",
    "職",
    "覺",
    "漢",
    "畫",
    "功",
    "巴",
    "跟",
    "雖",
    "雜",
    "飛",
    "檢",
    "吸",
    "助",
    "昇",
    "陽",
    "互",
    "初",
    "創",
    "抗",
    "考",
    "投",
    "壞",
    "策",
    "古",
    "徑",
    "換",
    "未",
    "跑",
    "留",
    "鋼",
    "曾",
    "端",
    "責",
    "站",
    "簡",
    "述",
    "錢",
    "副",
    "盡",
    "帝",
    "射",
    "草",
    "衝",
    "承",
    "獨",
    "令",
    "限",
    "阿",
    "宣",
    "環",
    "雙",
    "請",
    "超",
    "微",
    "讓",
    "控",
    "州",
    "良",
    "軸",
    "找",
    "否",
    "紀",
    "益",
    "依",
    "優",
    "頂",
    "礎",
    "載",
    "倒",
    "房",
    "突",
    "坐",
    "粉",
    "敵",
    "略",
    "客",
    "袁",
    "冷",
    "勝",
    "絕",
    "析",
    "塊",
    "劑",
    "測",
    "絲",
    "協",
    "訴",
    "念",
    "陳",
    "仍",
    "羅",
    "鹽",
    "友",
    "洋",
    "錯",
    "苦",
    "夜",
    "刑",
    "移",
    "頻",
    "逐",
    "靠",
    "混",
    "母",
    "短",
    "皮",
    "終",
    "聚",
    "汽",
    "村",
    "雲",
    "哪",
    "既",
    "距",
    "衛",
    "停",
    "烈",
    "央",
    "察",
    "燒",
    "迅",
    "境",
    "若",
    "印",
    "洲",
    "刻",
    "括",
    "激",
    "孔",
    "搞",
    "甚",
    "室",
    "待",
    "核",
    "校",
    "散",
    "侵",
    "吧",
    "甲",
    "遊",
    "久",
    "菜",
    "味",
    "舊",
    "模",
    "湖",
    "貨",
    "損",
    "預",
    "阻",
    "毫",
    "普",
    "穩",
    "乙",
    "媽",
    "植",
    "息",
    "擴",
    "銀",
    "語",
    "揮",
    "酒",
    "守",
    "拿",
    "序",
    "紙",
    "醫",
    "缺",
    "雨",
    "嗎",
    "針",
    "劉",
    "啊",
    "急",
    "唱",
    "誤",
    "訓",
    "願",
    "審",
    "附",
    "獲",
    "茶",
    "鮮",
    "糧",
    "斤",
    "孩",
    "脫",
    "硫",
    "肥",
    "善",
    "龍",
    "演",
    "父",
    "漸",
    "血",
    "歡",
    "械",
    "掌",
    "歌",
    "沙",
    "剛",
    "攻",
    "謂",
    "盾",
    "討",
    "晚",
    "粒",
    "亂",
    "燃",
    "矛",
    "乎",
    "殺",
    "藥",
    "寧",
    "魯",
    "貴",
    "鐘",
    "煤",
    "讀",
    "班",
    "伯",
    "香",
    "介",
    "迫",
    "句",
    "豐",
    "培",
    "握",
    "蘭",
    "擔",
    "弦",
    "蛋",
    "沉",
    "假",
    "穿",
    "執",
    "答",
    "樂",
    "誰",
    "順",
    "煙",
    "縮",
    "徵",
    "臉",
    "喜",
    "松",
    "腳",
    "困",
    "異",
    "免",
    "背",
    "星",
    "福",
    "買",
    "染",
    "井",
    "概",
    "慢",
    "怕",
    "磁",
    "倍",
    "祖",
    "皇",
    "促",
    "靜",
    "補",
    "評",
    "翻",
    "肉",
    "踐",
    "尼",
    "衣",
    "寬",
    "揚",
    "棉",
    "希",
    "傷",
    "操",
    "垂",
    "秋",
    "宜",
    "氫",
    "套",
    "督",
    "振",
    "架",
    "亮",
    "末",
    "憲",
    "慶",
    "編",
    "牛",
    "觸",
    "映",
    "雷",
    "銷",
    "詩",
    "座",
    "居",
    "抓",
    "裂",
    "胞",
    "呼",
    "娘",
    "景",
    "威",
    "綠",
    "晶",
    "厚",
    "盟",
    "衡",
    "雞",
    "孫",
    "延",
    "危",
    "膠",
    "屋",
    "鄉",
    "臨",
    "陸",
    "顧",
    "掉",
    "呀",
    "燈",
    "歲",
    "措",
    "束",
    "耐",
    "劇",
    "玉",
    "趙",
    "跳",
    "哥",
    "季",
    "課",
    "凱",
    "胡",
    "額",
    "款",
    "紹",
    "卷",
    "齊",
    "偉",
    "蒸",
    "殖",
    "永",
    "宗",
    "苗",
    "川",
    "爐",
    "岩",
    "弱",
    "零",
    "楊",
    "奏",
    "沿",
    "露",
    "桿",
    "探",
    "滑",
    "鎮",
    "飯",
    "濃",
    "航",
    "懷",
    "趕",
    "庫",
    "奪",
    "伊",
    "靈",
    "稅",
    "途",
    "滅",
    "賽",
    "歸",
    "召",
    "鼓",
    "播",
    "盤",
    "裁",
    "險",
    "康",
    "唯",
    "錄",
    "菌",
    "純",
    "借",
    "糖",
    "蓋",
    "橫",
    "符",
    "私",
    "努",
    "堂",
    "域",
    "槍",
    "潤",
    "幅",
    "哈",
    "竟",
    "熟",
    "蟲",
    "澤",
    "腦",
    "壤",
    "碳",
    "歐",
    "遍",
    "側",
    "寨",
    "敢",
    "徹",
    "慮",
    "斜",
    "薄",
    "庭",
    "納",
    "彈",
    "飼",
    "伸",
    "折",
    "麥",
    "濕",
    "暗",
    "荷",
    "瓦",
    "塞",
    "床",
    "築",
    "惡",
    "戶",
    "訪",
    "塔",
    "奇",
    "透",
    "梁",
    "刀",
    "旋",
    "跡",
    "卡",
    "氯",
    "遇",
    "份",
    "毒",
    "泥",
    "退",
    "洗",
    "擺",
    "灰",
    "彩",
    "賣",
    "耗",
    "夏",
    "擇",
    "忙",
    "銅",
    "獻",
    "硬",
    "予",
    "繁",
    "圈",
    "雪",
    "函",
    "亦",
    "抽",
    "篇",
    "陣",
    "陰",
    "丁",
    "尺",
    "追",
    "堆",
    "雄",
    "迎",
    "泛",
    "爸",
    "樓",
    "避",
    "謀",
    "噸",
    "野",
    "豬",
    "旗",
    "累",
    "偏",
    "典",
    "館",
    "索",
    "秦",
    "脂",
    "潮",
    "爺",
    "豆",
    "忽",
    "托",
    "驚",
    "塑",
    "遺",
    "愈",
    "朱",
    "替",
    "纖",
    "粗",
    "傾",
    "尚",
    "痛",
    "楚",
    "謝",
    "奮",
    "購",
    "磨",
    "君",
    "池",
    "旁",
    "碎",
    "骨",
    "監",
    "捕",
    "弟",
    "暴",
    "割",
    "貫",
    "殊",
    "釋",
    "詞",
    "亡",
    "壁",
    "頓",
    "寶",
    "午",
    "塵",
    "聞",
    "揭",
    "炮",
    "殘",
    "冬",
    "橋",
    "婦",
    "警",
    "綜",
    "招",
    "吳",
    "付",
    "浮",
    "遭",
    "徐",
    "您",
    "搖",
    "谷",
    "贊",
    "箱",
    "隔",
    "訂",
    "男",
    "吹",
    "園",
    "紛",
    "唐",
    "敗",
    "宋",
    "玻",
    "巨",
    "耕",
    "坦",
    "榮",
    "閉",
    "灣",
    "鍵",
    "凡",
    "駐",
    "鍋",
    "救",
    "恩",
    "剝",
    "凝",
    "鹼",
    "齒",
    "截",
    "煉",
    "麻",
    "紡",
    "禁",
    "廢",
    "盛",
    "版",
    "緩",
    "淨",
    "睛",
    "昌",
    "婚",
    "涉",
    "筒",
    "嘴",
    "插",
    "岸",
    "朗",
    "莊",
    "街",
    "藏",
    "姑",
    "貿",
    "腐",
    "奴",
    "啦",
    "慣",
    "乘",
    "夥",
    "恢",
    "勻",
    "紗",
    "扎",
    "辯",
    "耳",
    "彪",
    "臣",
    "億",
    "璃",
    "抵",
    "脈",
    "秀",
    "薩",
    "俄",
    "網",
    "舞",
    "店",
    "噴",
    "縱",
    "寸",
    "汗",
    "掛",
    "洪",
    "賀",
    "閃",
    "柬",
    "爆",
    "烯",
    "津",
    "稻",
    "牆",
    "軟",
    "勇",
    "像",
    "滾",
    "厘",
    "蒙",
    "芳",
    "肯",
    "坡",
    "柱",
    "盪",
    "腿",
    "儀",
    "旅",
    "尾",
    "軋",
    "冰",
    "貢",
    "登",
    "黎",
    "削",
    "鑽",
    "勒",
    "逃",
    "障",
    "氨",
    "郭",
    "峰",
    "幣",
    "港",
    "伏",
    "軌",
    "畝",
    "畢",
    "擦",
    "莫",
    "刺",
    "浪",
    "秘",
    "援",
    "株",
    "健",
    "售",
    "股",
    "島",
    "甘",
    "泡",
    "睡",
    "童",
    "鑄",
    "湯",
    "閥",
    "休",
    "匯",
    "舍",
    "牧",
    "繞",
    "炸",
    "哲",
    "磷",
    "績",
    "朋",
    "淡",
    "尖",
    "啟",
    "陷",
    "柴",
    "呈",
    "徒",
    "顏",
    "淚",
    "稍",
    "忘",
    "泵",
    "藍",
    "拖",
    "洞",
    "授",
    "鏡",
    "辛",
    "壯",
    "鋒",
    "貧",
    "虛",
    "彎",
    "摩",
    "泰",
    "幼",
    "廷",
    "尊",
    "窗",
    "綱",
    "弄",
    "隸",
    "疑",
    "氏",
    "宮",
    "姐",
    "震",
    "瑞",
    "怪",
    "尤",
    "琴",
    "循",
    "描",
    "膜",
    "違",
    "夾",
    "腰",
    "緣",
    "珠",
    "窮",
    "森",
    "枝",
    "竹",
    "溝",
    "催",
    "繩",
    "憶",
    "邦",
    "剩",
    "幸",
    "漿",
    "欄",
    "擁",
    "牙",
    "貯",
    "禮",
    "濾",
    "鈉",
    "紋",
    "罷",
    "拍",
    "咱",
    "喊",
    "袖",
    "埃",
    "勤",
    "罰",
    "焦",
    "潛",
    "伍",
    "墨",
    "欲",
    "縫",
    "姓",
    "刊",
    "飽",
    "仿",
    "獎",
    "鋁",
    "鬼",
    "麗",
    "跨",
    "默",
    "挖",
    "鏈",
    "掃",
    "喝",
    "袋",
    "炭",
    "污",
    "幕",
    "諸",
    "弧",
    "勵",
    "梅",
    "奶",
    "潔",
    "災",
    "舟",
    "鑑",
    "苯",
    "訟",
    "抱",
    "毀",
    "懂",
    "寒",
    "智",
    "埔",
    "寄",
    "屆",
    "躍",
    "渡",
    "挑",
    "丹",
    "艱",
    "貝",
    "碰",
    "拔",
    "爹",
    "戴",
    "碼",
    "夢",
    "芽",
    "熔",
    "赤",
    "漁",
    "哭",
    "敬",
    "顆",
    "奔",
    "鉛",
    "仲",
    "虎",
    "稀",
    "妹",
    "乏",
    "珍",
    "申",
    "桌",
    "遵",
    "允",
    "隆",
    "螺",
    "倉",
    "魏",
    "銳",
    "曉",
    "氮",
    "兼",
    "隱",
    "礙",
    "赫",
    "撥",
    "忠",
    "肅",
    "缸",
    "牽",
    "搶",
    "博",
    "巧",
    "殼",
    "兄",
    "杜",
    "訊",
    "誠",
    "碧",
    "祥",
    "柯",
    "頁",
    "巡",
    "矩",
    "悲",
    "灌",
    "齡",
    "倫",
    "票",
    "尋",
    "桂",
    "鋪",
    "聖",
    "恐",
    "恰",
    "鄭",
    "趣",
    "抬",
    "荒",
    "騰",
    "貼",
    "柔",
    "滴",
    "猛",
    "闊",
    "輛",
    "妻",
    "填",
    "撤",
    "儲",
    "簽",
    "鬧",
    "擾",
    "紫",
    "砂",
    "遞",
    "戲",
    "吊",
    "陶",
    "伐",
    "餵",
    "療",
    "瓶",
    "婆",
    "撫",
    "臂",
    "摸",
    "忍",
    "蝦",
    "蠟",
    "鄰",
    "胸",
    "鞏",
    "擠",
    "偶",
    "棄",
    "槽",
    "勁",
    "乳",
    "鄧",
    "吉",
    "仁",
    "爛",
    "磚",
    "租",
    "烏",
    "艦",
    "伴",
    "瓜",
    "淺",
    "丙",
    "暫",
    "燥",
    "橡",
    "柳",
    "迷",
    "暖",
    "牌",
    "秧",
    "膽",
    "詳",
    "簧",
    "踏",
    "瓷",
    "譜",
    "呆",
    "賓",
    "糊",
    "洛",
    "輝",
    "憤",
    "競",
    "隙",
    "怒",
    "粘",
    "乃",
    "緒",
    "肩",
    "籍",
    "敏",
    "塗",
    "熙",
    "皆",
    "偵",
    "懸",
    "掘",
    "享",
    "糾",
    "醒",
    "狂",
    "鎖",
    "淀",
    "恨",
    "牲",
    "霸",
    "爬",
    "賞",
    "逆",
    "玩",
    "陵",
    "祝",
    "秒",
    "浙",
    "貌",
    "役",
    "彼",
    "悉",
    "鴨",
    "趨",
    "鳳",
    "晨",
    "畜",
    "輩",
    "秩",
    "卵",
    "署",
    "梯",
    "炎",
    "灘",
    "棋",
    "驅",
    "篩",
    "峽",
    "冒",
    "啥",
    "壽",
    "譯",
    "浸",
    "泉",
    "帽",
    "遲",
    "矽",
    "疆",
    "貸",
    "漏",
    "稿",
    "冠",
    "嫩",
    "脅",
    "芯",
    "牢",
    "叛",
    "蝕",
    "奧",
    "鳴",
    "嶺",
    "羊",
    "憑",
    "串",
    "塘",
    "繪",
    "酵",
    "融",
    "盆",
    "錫",
    "廟",
    "籌",
    "凍",
    "輔",
    "攝",
    "襲",
    "筋",
    "拒",
    "僚",
    "旱",
    "鉀",
    "鳥",
    "漆",
    "沈",
    "眉",
    "疏",
    "添",
    "棒",
    "穗",
    "硝",
    "韓",
    "逼",
    "扭",
    "僑",
    "涼",
    "挺",
    "碗",
    "栽",
    "炒",
    "杯",
    "患",
    "餾",
    "勸",
    "豪",
    "遼",
    "勃",
    "鴻",
    "旦",
    "吏",
    "拜",
    "狗",
    "埋",
    "輥",
    "掩",
    "飲",
    "搬",
    "罵",
    "辭",
    "勾",
    "扣",
    "估",
    "蔣",
    "絨",
    "霧",
    "丈",
    "朵",
    "姆",
    "擬",
    "宇",
    "輯",
    "陝",
    "雕",
    "償",
    "蓄",
    "崇",
    "剪",
    "倡",
    "廳",
    "咬",
    "駛",
    "薯",
    "刷",
    "斥",
    "番",
    "賦",
    "奉",
    "佛",
    "澆",
    "漫",
    "曼",
    "扇",
    "鈣",
    "桃",
    "扶",
    "仔",
    "返",
    "俗",
    "虧",
    "腔",
    "鞋",
    "棱",
    "覆",
    "框",
    "悄",
    "叔",
    "撞",
    "騙",
    "勘",
    "旺",
    "沸",
    "孤",
    "吐",
    "孟",
    "渠",
    "屈",
    "疾",
    "妙",
    "惜",
    "仰",
    "狠",
    "脹",
    "諧",
    "拋",
    "黴",
    "桑",
    "崗",
    "嘛",
    "衰",
    "盜",
    "滲",
    "臟",
    "賴",
    "湧",
    "甜",
    "曹",
    "閱",
    "肌",
    "哩",
    "厲",
    "烴",
    "緯",
    "毅",
    "昨",
    "偽",
    "症",
    "煮",
    "嘆",
    "釘",
    "搭",
    "莖",
    "籠",
    "酷",
    "偷",
    "弓",
    "錐",
    "恆",
    "傑",
    "坑",
    "鼻",
    "翼",
    "綸",
    "敘",
    "獄",
    "逮",
    "罐",
    "絡",
    "棚",
    "抑",
    "膨",
    "蔬",
    "寺",
    "驟",
    "穆",
    "冶",
    "枯",
    "冊",
    "屍",
    "凸",
    "紳",
    "坯",
    "犧",
    "焰",
    "轟",
    "欣",
    "晉",
    "瘦",
    "禦",
    "錠",
    "錦",
    "喪",
    "旬",
    "鍛",
    "壟",
    "搜",
    "撲",
    "邀",
    "亭",
    "酯",
    "邁",
    "舒",
    "脆",
    "酶",
    "閒",
    "憂",
    "酚",
    "頑",
    "羽",
    "漲",
    "卸",
    "仗",
    "陪",
    "闢",
    "懲",
    "杭",
    "姚",
    "肚",
    "捉",
    "飄",
    "漂",
    "昆",
    "欺",
    "吾",
    "郎",
    "烷",
    "汁",
    "呵",
    "飾",
    "蕭",
    "雅",
    "郵",
    "遷",
    "燕",
    "撒",
    "姻",
    "赴",
    "宴",
    "煩",
    "債",
    "帳",
    "斑",
    "鈴",
    "旨",
    "醇",
    "董",
    "餅",
    "雛",
    "姿",
    "拌",
    "傅",
    "腹",
    "妥",
    "揉",
    "賢",
    "拆",
    "歪",
    "葡",
    "胺",
    "丟",
    "浩",
    "徽",
    "昂",
    "墊",
    "擋",
    "覽",
    "貪",
    "慰",
    "繳",
    "汪",
    "慌",
    "馮",
    "諾",
    "姜",
    "誼",
    "兇",
    "劣",
    "誣",
    "耀",
    "昏",
    "躺",
    "盈",
    "騎",
    "喬",
    "溪",
    "叢",
    "盧",
    "抹",
    "悶",
    "諮",
    "刮",
    "駕",
    "纜",
    "悟",
    "摘",
    "鉺",
    "擲",
    "頗",
    "幻",
    "柄",
    "惠",
    "慘",
    "佳",
    "仇",
    "臘",
    "窩",
    "滌",
    "劍",
    "瞧",
    "堡",
    "潑",
    "蔥",
    "罩",
    "霍",
    "撈",
    "胎",
    "蒼",
    "濱",
    "倆",
    "捅",
    "湘",
    "砍",
    "霞",
    "邵",
    "萄",
    "瘋",
    "淮",
    "遂",
    "熊",
    "糞",
    "烘",
    "宿",
    "檔",
    "戈",
    "駁",
    "嫂",
    "裕",
    "徙",
    "箭",
    "捐",
    "腸",
    "撐",
    "曬",
    "辨",
    "殿",
    "蓮",
    "攤",
    "攪",
    "醬",
    "屏",
    "疫",
    "哀",
    "蔡",
    "堵",
    "沫",
    "皺",
    "暢",
    "疊",
    "閣",
    "萊",
    "敲",
    "轄",
    "鉤",
    "痕",
    "壩",
    "巷",
    "餓",
    "禍",
    "丘",
    "玄",
    "溜",
    "曰",
    "邏",
    "彭",
    "嘗",
    "卿",
    "妨",
    "艇",
    "吞",
    "韋",
    "怨",
    "矮",
    "歇"
  ]), Qa;
}
var e0, g2;
function Cg() {
  return g2 || (g2 = 1, e0 = [
    "abandon",
    "ability",
    "able",
    "about",
    "above",
    "absent",
    "absorb",
    "abstract",
    "absurd",
    "abuse",
    "access",
    "accident",
    "account",
    "accuse",
    "achieve",
    "acid",
    "acoustic",
    "acquire",
    "across",
    "act",
    "action",
    "actor",
    "actress",
    "actual",
    "adapt",
    "add",
    "addict",
    "address",
    "adjust",
    "admit",
    "adult",
    "advance",
    "advice",
    "aerobic",
    "affair",
    "afford",
    "afraid",
    "again",
    "age",
    "agent",
    "agree",
    "ahead",
    "aim",
    "air",
    "airport",
    "aisle",
    "alarm",
    "album",
    "alcohol",
    "alert",
    "alien",
    "all",
    "alley",
    "allow",
    "almost",
    "alone",
    "alpha",
    "already",
    "also",
    "alter",
    "always",
    "amateur",
    "amazing",
    "among",
    "amount",
    "amused",
    "analyst",
    "anchor",
    "ancient",
    "anger",
    "angle",
    "angry",
    "animal",
    "ankle",
    "announce",
    "annual",
    "another",
    "answer",
    "antenna",
    "antique",
    "anxiety",
    "any",
    "apart",
    "apology",
    "appear",
    "apple",
    "approve",
    "april",
    "arch",
    "arctic",
    "area",
    "arena",
    "argue",
    "arm",
    "armed",
    "armor",
    "army",
    "around",
    "arrange",
    "arrest",
    "arrive",
    "arrow",
    "art",
    "artefact",
    "artist",
    "artwork",
    "ask",
    "aspect",
    "assault",
    "asset",
    "assist",
    "assume",
    "asthma",
    "athlete",
    "atom",
    "attack",
    "attend",
    "attitude",
    "attract",
    "auction",
    "audit",
    "august",
    "aunt",
    "author",
    "auto",
    "autumn",
    "average",
    "avocado",
    "avoid",
    "awake",
    "aware",
    "away",
    "awesome",
    "awful",
    "awkward",
    "axis",
    "baby",
    "bachelor",
    "bacon",
    "badge",
    "bag",
    "balance",
    "balcony",
    "ball",
    "bamboo",
    "banana",
    "banner",
    "bar",
    "barely",
    "bargain",
    "barrel",
    "base",
    "basic",
    "basket",
    "battle",
    "beach",
    "bean",
    "beauty",
    "because",
    "become",
    "beef",
    "before",
    "begin",
    "behave",
    "behind",
    "believe",
    "below",
    "belt",
    "bench",
    "benefit",
    "best",
    "betray",
    "better",
    "between",
    "beyond",
    "bicycle",
    "bid",
    "bike",
    "bind",
    "biology",
    "bird",
    "birth",
    "bitter",
    "black",
    "blade",
    "blame",
    "blanket",
    "blast",
    "bleak",
    "bless",
    "blind",
    "blood",
    "blossom",
    "blouse",
    "blue",
    "blur",
    "blush",
    "board",
    "boat",
    "body",
    "boil",
    "bomb",
    "bone",
    "bonus",
    "book",
    "boost",
    "border",
    "boring",
    "borrow",
    "boss",
    "bottom",
    "bounce",
    "box",
    "boy",
    "bracket",
    "brain",
    "brand",
    "brass",
    "brave",
    "bread",
    "breeze",
    "brick",
    "bridge",
    "brief",
    "bright",
    "bring",
    "brisk",
    "broccoli",
    "broken",
    "bronze",
    "broom",
    "brother",
    "brown",
    "brush",
    "bubble",
    "buddy",
    "budget",
    "buffalo",
    "build",
    "bulb",
    "bulk",
    "bullet",
    "bundle",
    "bunker",
    "burden",
    "burger",
    "burst",
    "bus",
    "business",
    "busy",
    "butter",
    "buyer",
    "buzz",
    "cabbage",
    "cabin",
    "cable",
    "cactus",
    "cage",
    "cake",
    "call",
    "calm",
    "camera",
    "camp",
    "can",
    "canal",
    "cancel",
    "candy",
    "cannon",
    "canoe",
    "canvas",
    "canyon",
    "capable",
    "capital",
    "captain",
    "car",
    "carbon",
    "card",
    "cargo",
    "carpet",
    "carry",
    "cart",
    "case",
    "cash",
    "casino",
    "castle",
    "casual",
    "cat",
    "catalog",
    "catch",
    "category",
    "cattle",
    "caught",
    "cause",
    "caution",
    "cave",
    "ceiling",
    "celery",
    "cement",
    "census",
    "century",
    "cereal",
    "certain",
    "chair",
    "chalk",
    "champion",
    "change",
    "chaos",
    "chapter",
    "charge",
    "chase",
    "chat",
    "cheap",
    "check",
    "cheese",
    "chef",
    "cherry",
    "chest",
    "chicken",
    "chief",
    "child",
    "chimney",
    "choice",
    "choose",
    "chronic",
    "chuckle",
    "chunk",
    "churn",
    "cigar",
    "cinnamon",
    "circle",
    "citizen",
    "city",
    "civil",
    "claim",
    "clap",
    "clarify",
    "claw",
    "clay",
    "clean",
    "clerk",
    "clever",
    "click",
    "client",
    "cliff",
    "climb",
    "clinic",
    "clip",
    "clock",
    "clog",
    "close",
    "cloth",
    "cloud",
    "clown",
    "club",
    "clump",
    "cluster",
    "clutch",
    "coach",
    "coast",
    "coconut",
    "code",
    "coffee",
    "coil",
    "coin",
    "collect",
    "color",
    "column",
    "combine",
    "come",
    "comfort",
    "comic",
    "common",
    "company",
    "concert",
    "conduct",
    "confirm",
    "congress",
    "connect",
    "consider",
    "control",
    "convince",
    "cook",
    "cool",
    "copper",
    "copy",
    "coral",
    "core",
    "corn",
    "correct",
    "cost",
    "cotton",
    "couch",
    "country",
    "couple",
    "course",
    "cousin",
    "cover",
    "coyote",
    "crack",
    "cradle",
    "craft",
    "cram",
    "crane",
    "crash",
    "crater",
    "crawl",
    "crazy",
    "cream",
    "credit",
    "creek",
    "crew",
    "cricket",
    "crime",
    "crisp",
    "critic",
    "crop",
    "cross",
    "crouch",
    "crowd",
    "crucial",
    "cruel",
    "cruise",
    "crumble",
    "crunch",
    "crush",
    "cry",
    "crystal",
    "cube",
    "culture",
    "cup",
    "cupboard",
    "curious",
    "current",
    "curtain",
    "curve",
    "cushion",
    "custom",
    "cute",
    "cycle",
    "dad",
    "damage",
    "damp",
    "dance",
    "danger",
    "daring",
    "dash",
    "daughter",
    "dawn",
    "day",
    "deal",
    "debate",
    "debris",
    "decade",
    "december",
    "decide",
    "decline",
    "decorate",
    "decrease",
    "deer",
    "defense",
    "define",
    "defy",
    "degree",
    "delay",
    "deliver",
    "demand",
    "demise",
    "denial",
    "dentist",
    "deny",
    "depart",
    "depend",
    "deposit",
    "depth",
    "deputy",
    "derive",
    "describe",
    "desert",
    "design",
    "desk",
    "despair",
    "destroy",
    "detail",
    "detect",
    "develop",
    "device",
    "devote",
    "diagram",
    "dial",
    "diamond",
    "diary",
    "dice",
    "diesel",
    "diet",
    "differ",
    "digital",
    "dignity",
    "dilemma",
    "dinner",
    "dinosaur",
    "direct",
    "dirt",
    "disagree",
    "discover",
    "disease",
    "dish",
    "dismiss",
    "disorder",
    "display",
    "distance",
    "divert",
    "divide",
    "divorce",
    "dizzy",
    "doctor",
    "document",
    "dog",
    "doll",
    "dolphin",
    "domain",
    "donate",
    "donkey",
    "donor",
    "door",
    "dose",
    "double",
    "dove",
    "draft",
    "dragon",
    "drama",
    "drastic",
    "draw",
    "dream",
    "dress",
    "drift",
    "drill",
    "drink",
    "drip",
    "drive",
    "drop",
    "drum",
    "dry",
    "duck",
    "dumb",
    "dune",
    "during",
    "dust",
    "dutch",
    "duty",
    "dwarf",
    "dynamic",
    "eager",
    "eagle",
    "early",
    "earn",
    "earth",
    "easily",
    "east",
    "easy",
    "echo",
    "ecology",
    "economy",
    "edge",
    "edit",
    "educate",
    "effort",
    "egg",
    "eight",
    "either",
    "elbow",
    "elder",
    "electric",
    "elegant",
    "element",
    "elephant",
    "elevator",
    "elite",
    "else",
    "embark",
    "embody",
    "embrace",
    "emerge",
    "emotion",
    "employ",
    "empower",
    "empty",
    "enable",
    "enact",
    "end",
    "endless",
    "endorse",
    "enemy",
    "energy",
    "enforce",
    "engage",
    "engine",
    "enhance",
    "enjoy",
    "enlist",
    "enough",
    "enrich",
    "enroll",
    "ensure",
    "enter",
    "entire",
    "entry",
    "envelope",
    "episode",
    "equal",
    "equip",
    "era",
    "erase",
    "erode",
    "erosion",
    "error",
    "erupt",
    "escape",
    "essay",
    "essence",
    "estate",
    "eternal",
    "ethics",
    "evidence",
    "evil",
    "evoke",
    "evolve",
    "exact",
    "example",
    "excess",
    "exchange",
    "excite",
    "exclude",
    "excuse",
    "execute",
    "exercise",
    "exhaust",
    "exhibit",
    "exile",
    "exist",
    "exit",
    "exotic",
    "expand",
    "expect",
    "expire",
    "explain",
    "expose",
    "express",
    "extend",
    "extra",
    "eye",
    "eyebrow",
    "fabric",
    "face",
    "faculty",
    "fade",
    "faint",
    "faith",
    "fall",
    "false",
    "fame",
    "family",
    "famous",
    "fan",
    "fancy",
    "fantasy",
    "farm",
    "fashion",
    "fat",
    "fatal",
    "father",
    "fatigue",
    "fault",
    "favorite",
    "feature",
    "february",
    "federal",
    "fee",
    "feed",
    "feel",
    "female",
    "fence",
    "festival",
    "fetch",
    "fever",
    "few",
    "fiber",
    "fiction",
    "field",
    "figure",
    "file",
    "film",
    "filter",
    "final",
    "find",
    "fine",
    "finger",
    "finish",
    "fire",
    "firm",
    "first",
    "fiscal",
    "fish",
    "fit",
    "fitness",
    "fix",
    "flag",
    "flame",
    "flash",
    "flat",
    "flavor",
    "flee",
    "flight",
    "flip",
    "float",
    "flock",
    "floor",
    "flower",
    "fluid",
    "flush",
    "fly",
    "foam",
    "focus",
    "fog",
    "foil",
    "fold",
    "follow",
    "food",
    "foot",
    "force",
    "forest",
    "forget",
    "fork",
    "fortune",
    "forum",
    "forward",
    "fossil",
    "foster",
    "found",
    "fox",
    "fragile",
    "frame",
    "frequent",
    "fresh",
    "friend",
    "fringe",
    "frog",
    "front",
    "frost",
    "frown",
    "frozen",
    "fruit",
    "fuel",
    "fun",
    "funny",
    "furnace",
    "fury",
    "future",
    "gadget",
    "gain",
    "galaxy",
    "gallery",
    "game",
    "gap",
    "garage",
    "garbage",
    "garden",
    "garlic",
    "garment",
    "gas",
    "gasp",
    "gate",
    "gather",
    "gauge",
    "gaze",
    "general",
    "genius",
    "genre",
    "gentle",
    "genuine",
    "gesture",
    "ghost",
    "giant",
    "gift",
    "giggle",
    "ginger",
    "giraffe",
    "girl",
    "give",
    "glad",
    "glance",
    "glare",
    "glass",
    "glide",
    "glimpse",
    "globe",
    "gloom",
    "glory",
    "glove",
    "glow",
    "glue",
    "goat",
    "goddess",
    "gold",
    "good",
    "goose",
    "gorilla",
    "gospel",
    "gossip",
    "govern",
    "gown",
    "grab",
    "grace",
    "grain",
    "grant",
    "grape",
    "grass",
    "gravity",
    "great",
    "green",
    "grid",
    "grief",
    "grit",
    "grocery",
    "group",
    "grow",
    "grunt",
    "guard",
    "guess",
    "guide",
    "guilt",
    "guitar",
    "gun",
    "gym",
    "habit",
    "hair",
    "half",
    "hammer",
    "hamster",
    "hand",
    "happy",
    "harbor",
    "hard",
    "harsh",
    "harvest",
    "hat",
    "have",
    "hawk",
    "hazard",
    "head",
    "health",
    "heart",
    "heavy",
    "hedgehog",
    "height",
    "hello",
    "helmet",
    "help",
    "hen",
    "hero",
    "hidden",
    "high",
    "hill",
    "hint",
    "hip",
    "hire",
    "history",
    "hobby",
    "hockey",
    "hold",
    "hole",
    "holiday",
    "hollow",
    "home",
    "honey",
    "hood",
    "hope",
    "horn",
    "horror",
    "horse",
    "hospital",
    "host",
    "hotel",
    "hour",
    "hover",
    "hub",
    "huge",
    "human",
    "humble",
    "humor",
    "hundred",
    "hungry",
    "hunt",
    "hurdle",
    "hurry",
    "hurt",
    "husband",
    "hybrid",
    "ice",
    "icon",
    "idea",
    "identify",
    "idle",
    "ignore",
    "ill",
    "illegal",
    "illness",
    "image",
    "imitate",
    "immense",
    "immune",
    "impact",
    "impose",
    "improve",
    "impulse",
    "inch",
    "include",
    "income",
    "increase",
    "index",
    "indicate",
    "indoor",
    "industry",
    "infant",
    "inflict",
    "inform",
    "inhale",
    "inherit",
    "initial",
    "inject",
    "injury",
    "inmate",
    "inner",
    "innocent",
    "input",
    "inquiry",
    "insane",
    "insect",
    "inside",
    "inspire",
    "install",
    "intact",
    "interest",
    "into",
    "invest",
    "invite",
    "involve",
    "iron",
    "island",
    "isolate",
    "issue",
    "item",
    "ivory",
    "jacket",
    "jaguar",
    "jar",
    "jazz",
    "jealous",
    "jeans",
    "jelly",
    "jewel",
    "job",
    "join",
    "joke",
    "journey",
    "joy",
    "judge",
    "juice",
    "jump",
    "jungle",
    "junior",
    "junk",
    "just",
    "kangaroo",
    "keen",
    "keep",
    "ketchup",
    "key",
    "kick",
    "kid",
    "kidney",
    "kind",
    "kingdom",
    "kiss",
    "kit",
    "kitchen",
    "kite",
    "kitten",
    "kiwi",
    "knee",
    "knife",
    "knock",
    "know",
    "lab",
    "label",
    "labor",
    "ladder",
    "lady",
    "lake",
    "lamp",
    "language",
    "laptop",
    "large",
    "later",
    "latin",
    "laugh",
    "laundry",
    "lava",
    "law",
    "lawn",
    "lawsuit",
    "layer",
    "lazy",
    "leader",
    "leaf",
    "learn",
    "leave",
    "lecture",
    "left",
    "leg",
    "legal",
    "legend",
    "leisure",
    "lemon",
    "lend",
    "length",
    "lens",
    "leopard",
    "lesson",
    "letter",
    "level",
    "liar",
    "liberty",
    "library",
    "license",
    "life",
    "lift",
    "light",
    "like",
    "limb",
    "limit",
    "link",
    "lion",
    "liquid",
    "list",
    "little",
    "live",
    "lizard",
    "load",
    "loan",
    "lobster",
    "local",
    "lock",
    "logic",
    "lonely",
    "long",
    "loop",
    "lottery",
    "loud",
    "lounge",
    "love",
    "loyal",
    "lucky",
    "luggage",
    "lumber",
    "lunar",
    "lunch",
    "luxury",
    "lyrics",
    "machine",
    "mad",
    "magic",
    "magnet",
    "maid",
    "mail",
    "main",
    "major",
    "make",
    "mammal",
    "man",
    "manage",
    "mandate",
    "mango",
    "mansion",
    "manual",
    "maple",
    "marble",
    "march",
    "margin",
    "marine",
    "market",
    "marriage",
    "mask",
    "mass",
    "master",
    "match",
    "material",
    "math",
    "matrix",
    "matter",
    "maximum",
    "maze",
    "meadow",
    "mean",
    "measure",
    "meat",
    "mechanic",
    "medal",
    "media",
    "melody",
    "melt",
    "member",
    "memory",
    "mention",
    "menu",
    "mercy",
    "merge",
    "merit",
    "merry",
    "mesh",
    "message",
    "metal",
    "method",
    "middle",
    "midnight",
    "milk",
    "million",
    "mimic",
    "mind",
    "minimum",
    "minor",
    "minute",
    "miracle",
    "mirror",
    "misery",
    "miss",
    "mistake",
    "mix",
    "mixed",
    "mixture",
    "mobile",
    "model",
    "modify",
    "mom",
    "moment",
    "monitor",
    "monkey",
    "monster",
    "month",
    "moon",
    "moral",
    "more",
    "morning",
    "mosquito",
    "mother",
    "motion",
    "motor",
    "mountain",
    "mouse",
    "move",
    "movie",
    "much",
    "muffin",
    "mule",
    "multiply",
    "muscle",
    "museum",
    "mushroom",
    "music",
    "must",
    "mutual",
    "myself",
    "mystery",
    "myth",
    "naive",
    "name",
    "napkin",
    "narrow",
    "nasty",
    "nation",
    "nature",
    "near",
    "neck",
    "need",
    "negative",
    "neglect",
    "neither",
    "nephew",
    "nerve",
    "nest",
    "net",
    "network",
    "neutral",
    "never",
    "news",
    "next",
    "nice",
    "night",
    "noble",
    "noise",
    "nominee",
    "noodle",
    "normal",
    "north",
    "nose",
    "notable",
    "note",
    "nothing",
    "notice",
    "novel",
    "now",
    "nuclear",
    "number",
    "nurse",
    "nut",
    "oak",
    "obey",
    "object",
    "oblige",
    "obscure",
    "observe",
    "obtain",
    "obvious",
    "occur",
    "ocean",
    "october",
    "odor",
    "off",
    "offer",
    "office",
    "often",
    "oil",
    "okay",
    "old",
    "olive",
    "olympic",
    "omit",
    "once",
    "one",
    "onion",
    "online",
    "only",
    "open",
    "opera",
    "opinion",
    "oppose",
    "option",
    "orange",
    "orbit",
    "orchard",
    "order",
    "ordinary",
    "organ",
    "orient",
    "original",
    "orphan",
    "ostrich",
    "other",
    "outdoor",
    "outer",
    "output",
    "outside",
    "oval",
    "oven",
    "over",
    "own",
    "owner",
    "oxygen",
    "oyster",
    "ozone",
    "pact",
    "paddle",
    "page",
    "pair",
    "palace",
    "palm",
    "panda",
    "panel",
    "panic",
    "panther",
    "paper",
    "parade",
    "parent",
    "park",
    "parrot",
    "party",
    "pass",
    "patch",
    "path",
    "patient",
    "patrol",
    "pattern",
    "pause",
    "pave",
    "payment",
    "peace",
    "peanut",
    "pear",
    "peasant",
    "pelican",
    "pen",
    "penalty",
    "pencil",
    "people",
    "pepper",
    "perfect",
    "permit",
    "person",
    "pet",
    "phone",
    "photo",
    "phrase",
    "physical",
    "piano",
    "picnic",
    "picture",
    "piece",
    "pig",
    "pigeon",
    "pill",
    "pilot",
    "pink",
    "pioneer",
    "pipe",
    "pistol",
    "pitch",
    "pizza",
    "place",
    "planet",
    "plastic",
    "plate",
    "play",
    "please",
    "pledge",
    "pluck",
    "plug",
    "plunge",
    "poem",
    "poet",
    "point",
    "polar",
    "pole",
    "police",
    "pond",
    "pony",
    "pool",
    "popular",
    "portion",
    "position",
    "possible",
    "post",
    "potato",
    "pottery",
    "poverty",
    "powder",
    "power",
    "practice",
    "praise",
    "predict",
    "prefer",
    "prepare",
    "present",
    "pretty",
    "prevent",
    "price",
    "pride",
    "primary",
    "print",
    "priority",
    "prison",
    "private",
    "prize",
    "problem",
    "process",
    "produce",
    "profit",
    "program",
    "project",
    "promote",
    "proof",
    "property",
    "prosper",
    "protect",
    "proud",
    "provide",
    "public",
    "pudding",
    "pull",
    "pulp",
    "pulse",
    "pumpkin",
    "punch",
    "pupil",
    "puppy",
    "purchase",
    "purity",
    "purpose",
    "purse",
    "push",
    "put",
    "puzzle",
    "pyramid",
    "quality",
    "quantum",
    "quarter",
    "question",
    "quick",
    "quit",
    "quiz",
    "quote",
    "rabbit",
    "raccoon",
    "race",
    "rack",
    "radar",
    "radio",
    "rail",
    "rain",
    "raise",
    "rally",
    "ramp",
    "ranch",
    "random",
    "range",
    "rapid",
    "rare",
    "rate",
    "rather",
    "raven",
    "raw",
    "razor",
    "ready",
    "real",
    "reason",
    "rebel",
    "rebuild",
    "recall",
    "receive",
    "recipe",
    "record",
    "recycle",
    "reduce",
    "reflect",
    "reform",
    "refuse",
    "region",
    "regret",
    "regular",
    "reject",
    "relax",
    "release",
    "relief",
    "rely",
    "remain",
    "remember",
    "remind",
    "remove",
    "render",
    "renew",
    "rent",
    "reopen",
    "repair",
    "repeat",
    "replace",
    "report",
    "require",
    "rescue",
    "resemble",
    "resist",
    "resource",
    "response",
    "result",
    "retire",
    "retreat",
    "return",
    "reunion",
    "reveal",
    "review",
    "reward",
    "rhythm",
    "rib",
    "ribbon",
    "rice",
    "rich",
    "ride",
    "ridge",
    "rifle",
    "right",
    "rigid",
    "ring",
    "riot",
    "ripple",
    "risk",
    "ritual",
    "rival",
    "river",
    "road",
    "roast",
    "robot",
    "robust",
    "rocket",
    "romance",
    "roof",
    "rookie",
    "room",
    "rose",
    "rotate",
    "rough",
    "round",
    "route",
    "royal",
    "rubber",
    "rude",
    "rug",
    "rule",
    "run",
    "runway",
    "rural",
    "sad",
    "saddle",
    "sadness",
    "safe",
    "sail",
    "salad",
    "salmon",
    "salon",
    "salt",
    "salute",
    "same",
    "sample",
    "sand",
    "satisfy",
    "satoshi",
    "sauce",
    "sausage",
    "save",
    "say",
    "scale",
    "scan",
    "scare",
    "scatter",
    "scene",
    "scheme",
    "school",
    "science",
    "scissors",
    "scorpion",
    "scout",
    "scrap",
    "screen",
    "script",
    "scrub",
    "sea",
    "search",
    "season",
    "seat",
    "second",
    "secret",
    "section",
    "security",
    "seed",
    "seek",
    "segment",
    "select",
    "sell",
    "seminar",
    "senior",
    "sense",
    "sentence",
    "series",
    "service",
    "session",
    "settle",
    "setup",
    "seven",
    "shadow",
    "shaft",
    "shallow",
    "share",
    "shed",
    "shell",
    "sheriff",
    "shield",
    "shift",
    "shine",
    "ship",
    "shiver",
    "shock",
    "shoe",
    "shoot",
    "shop",
    "short",
    "shoulder",
    "shove",
    "shrimp",
    "shrug",
    "shuffle",
    "shy",
    "sibling",
    "sick",
    "side",
    "siege",
    "sight",
    "sign",
    "silent",
    "silk",
    "silly",
    "silver",
    "similar",
    "simple",
    "since",
    "sing",
    "siren",
    "sister",
    "situate",
    "six",
    "size",
    "skate",
    "sketch",
    "ski",
    "skill",
    "skin",
    "skirt",
    "skull",
    "slab",
    "slam",
    "sleep",
    "slender",
    "slice",
    "slide",
    "slight",
    "slim",
    "slogan",
    "slot",
    "slow",
    "slush",
    "small",
    "smart",
    "smile",
    "smoke",
    "smooth",
    "snack",
    "snake",
    "snap",
    "sniff",
    "snow",
    "soap",
    "soccer",
    "social",
    "sock",
    "soda",
    "soft",
    "solar",
    "soldier",
    "solid",
    "solution",
    "solve",
    "someone",
    "song",
    "soon",
    "sorry",
    "sort",
    "soul",
    "sound",
    "soup",
    "source",
    "south",
    "space",
    "spare",
    "spatial",
    "spawn",
    "speak",
    "special",
    "speed",
    "spell",
    "spend",
    "sphere",
    "spice",
    "spider",
    "spike",
    "spin",
    "spirit",
    "split",
    "spoil",
    "sponsor",
    "spoon",
    "sport",
    "spot",
    "spray",
    "spread",
    "spring",
    "spy",
    "square",
    "squeeze",
    "squirrel",
    "stable",
    "stadium",
    "staff",
    "stage",
    "stairs",
    "stamp",
    "stand",
    "start",
    "state",
    "stay",
    "steak",
    "steel",
    "stem",
    "step",
    "stereo",
    "stick",
    "still",
    "sting",
    "stock",
    "stomach",
    "stone",
    "stool",
    "story",
    "stove",
    "strategy",
    "street",
    "strike",
    "strong",
    "struggle",
    "student",
    "stuff",
    "stumble",
    "style",
    "subject",
    "submit",
    "subway",
    "success",
    "such",
    "sudden",
    "suffer",
    "sugar",
    "suggest",
    "suit",
    "summer",
    "sun",
    "sunny",
    "sunset",
    "super",
    "supply",
    "supreme",
    "sure",
    "surface",
    "surge",
    "surprise",
    "surround",
    "survey",
    "suspect",
    "sustain",
    "swallow",
    "swamp",
    "swap",
    "swarm",
    "swear",
    "sweet",
    "swift",
    "swim",
    "swing",
    "switch",
    "sword",
    "symbol",
    "symptom",
    "syrup",
    "system",
    "table",
    "tackle",
    "tag",
    "tail",
    "talent",
    "talk",
    "tank",
    "tape",
    "target",
    "task",
    "taste",
    "tattoo",
    "taxi",
    "teach",
    "team",
    "tell",
    "ten",
    "tenant",
    "tennis",
    "tent",
    "term",
    "test",
    "text",
    "thank",
    "that",
    "theme",
    "then",
    "theory",
    "there",
    "they",
    "thing",
    "this",
    "thought",
    "three",
    "thrive",
    "throw",
    "thumb",
    "thunder",
    "ticket",
    "tide",
    "tiger",
    "tilt",
    "timber",
    "time",
    "tiny",
    "tip",
    "tired",
    "tissue",
    "title",
    "toast",
    "tobacco",
    "today",
    "toddler",
    "toe",
    "together",
    "toilet",
    "token",
    "tomato",
    "tomorrow",
    "tone",
    "tongue",
    "tonight",
    "tool",
    "tooth",
    "top",
    "topic",
    "topple",
    "torch",
    "tornado",
    "tortoise",
    "toss",
    "total",
    "tourist",
    "toward",
    "tower",
    "town",
    "toy",
    "track",
    "trade",
    "traffic",
    "tragic",
    "train",
    "transfer",
    "trap",
    "trash",
    "travel",
    "tray",
    "treat",
    "tree",
    "trend",
    "trial",
    "tribe",
    "trick",
    "trigger",
    "trim",
    "trip",
    "trophy",
    "trouble",
    "truck",
    "true",
    "truly",
    "trumpet",
    "trust",
    "truth",
    "try",
    "tube",
    "tuition",
    "tumble",
    "tuna",
    "tunnel",
    "turkey",
    "turn",
    "turtle",
    "twelve",
    "twenty",
    "twice",
    "twin",
    "twist",
    "two",
    "type",
    "typical",
    "ugly",
    "umbrella",
    "unable",
    "unaware",
    "uncle",
    "uncover",
    "under",
    "undo",
    "unfair",
    "unfold",
    "unhappy",
    "uniform",
    "unique",
    "unit",
    "universe",
    "unknown",
    "unlock",
    "until",
    "unusual",
    "unveil",
    "update",
    "upgrade",
    "uphold",
    "upon",
    "upper",
    "upset",
    "urban",
    "urge",
    "usage",
    "use",
    "used",
    "useful",
    "useless",
    "usual",
    "utility",
    "vacant",
    "vacuum",
    "vague",
    "valid",
    "valley",
    "valve",
    "van",
    "vanish",
    "vapor",
    "various",
    "vast",
    "vault",
    "vehicle",
    "velvet",
    "vendor",
    "venture",
    "venue",
    "verb",
    "verify",
    "version",
    "very",
    "vessel",
    "veteran",
    "viable",
    "vibrant",
    "vicious",
    "victory",
    "video",
    "view",
    "village",
    "vintage",
    "violin",
    "virtual",
    "virus",
    "visa",
    "visit",
    "visual",
    "vital",
    "vivid",
    "vocal",
    "voice",
    "void",
    "volcano",
    "volume",
    "vote",
    "voyage",
    "wage",
    "wagon",
    "wait",
    "walk",
    "wall",
    "walnut",
    "want",
    "warfare",
    "warm",
    "warrior",
    "wash",
    "wasp",
    "waste",
    "water",
    "wave",
    "way",
    "wealth",
    "weapon",
    "wear",
    "weasel",
    "weather",
    "web",
    "wedding",
    "weekend",
    "weird",
    "welcome",
    "west",
    "wet",
    "whale",
    "what",
    "wheat",
    "wheel",
    "when",
    "where",
    "whip",
    "whisper",
    "wide",
    "width",
    "wife",
    "wild",
    "will",
    "win",
    "window",
    "wine",
    "wing",
    "wink",
    "winner",
    "winter",
    "wire",
    "wisdom",
    "wise",
    "wish",
    "witness",
    "wolf",
    "woman",
    "wonder",
    "wood",
    "wool",
    "word",
    "work",
    "world",
    "worry",
    "worth",
    "wrap",
    "wreck",
    "wrestle",
    "wrist",
    "write",
    "wrong",
    "yard",
    "year",
    "yellow",
    "you",
    "young",
    "youth",
    "zebra",
    "zero",
    "zone",
    "zoo"
  ]), e0;
}
var t0, x2;
function Dg() {
  return x2 || (x2 = 1, t0 = [
    "abaisser",
    "abandon",
    "abdiquer",
    "abeille",
    "abolir",
    "aborder",
    "aboutir",
    "aboyer",
    "abrasif",
    "abreuver",
    "abriter",
    "abroger",
    "abrupt",
    "absence",
    "absolu",
    "absurde",
    "abusif",
    "abyssal",
    "académie",
    "acajou",
    "acarien",
    "accabler",
    "accepter",
    "acclamer",
    "accolade",
    "accroche",
    "accuser",
    "acerbe",
    "achat",
    "acheter",
    "aciduler",
    "acier",
    "acompte",
    "acquérir",
    "acronyme",
    "acteur",
    "actif",
    "actuel",
    "adepte",
    "adéquat",
    "adhésif",
    "adjectif",
    "adjuger",
    "admettre",
    "admirer",
    "adopter",
    "adorer",
    "adoucir",
    "adresse",
    "adroit",
    "adulte",
    "adverbe",
    "aérer",
    "aéronef",
    "affaire",
    "affecter",
    "affiche",
    "affreux",
    "affubler",
    "agacer",
    "agencer",
    "agile",
    "agiter",
    "agrafer",
    "agréable",
    "agrume",
    "aider",
    "aiguille",
    "ailier",
    "aimable",
    "aisance",
    "ajouter",
    "ajuster",
    "alarmer",
    "alchimie",
    "alerte",
    "algèbre",
    "algue",
    "aliéner",
    "aliment",
    "alléger",
    "alliage",
    "allouer",
    "allumer",
    "alourdir",
    "alpaga",
    "altesse",
    "alvéole",
    "amateur",
    "ambigu",
    "ambre",
    "aménager",
    "amertume",
    "amidon",
    "amiral",
    "amorcer",
    "amour",
    "amovible",
    "amphibie",
    "ampleur",
    "amusant",
    "analyse",
    "anaphore",
    "anarchie",
    "anatomie",
    "ancien",
    "anéantir",
    "angle",
    "angoisse",
    "anguleux",
    "animal",
    "annexer",
    "annonce",
    "annuel",
    "anodin",
    "anomalie",
    "anonyme",
    "anormal",
    "antenne",
    "antidote",
    "anxieux",
    "apaiser",
    "apéritif",
    "aplanir",
    "apologie",
    "appareil",
    "appeler",
    "apporter",
    "appuyer",
    "aquarium",
    "aqueduc",
    "arbitre",
    "arbuste",
    "ardeur",
    "ardoise",
    "argent",
    "arlequin",
    "armature",
    "armement",
    "armoire",
    "armure",
    "arpenter",
    "arracher",
    "arriver",
    "arroser",
    "arsenic",
    "artériel",
    "article",
    "aspect",
    "asphalte",
    "aspirer",
    "assaut",
    "asservir",
    "assiette",
    "associer",
    "assurer",
    "asticot",
    "astre",
    "astuce",
    "atelier",
    "atome",
    "atrium",
    "atroce",
    "attaque",
    "attentif",
    "attirer",
    "attraper",
    "aubaine",
    "auberge",
    "audace",
    "audible",
    "augurer",
    "aurore",
    "automne",
    "autruche",
    "avaler",
    "avancer",
    "avarice",
    "avenir",
    "averse",
    "aveugle",
    "aviateur",
    "avide",
    "avion",
    "aviser",
    "avoine",
    "avouer",
    "avril",
    "axial",
    "axiome",
    "badge",
    "bafouer",
    "bagage",
    "baguette",
    "baignade",
    "balancer",
    "balcon",
    "baleine",
    "balisage",
    "bambin",
    "bancaire",
    "bandage",
    "banlieue",
    "bannière",
    "banquier",
    "barbier",
    "baril",
    "baron",
    "barque",
    "barrage",
    "bassin",
    "bastion",
    "bataille",
    "bateau",
    "batterie",
    "baudrier",
    "bavarder",
    "belette",
    "bélier",
    "belote",
    "bénéfice",
    "berceau",
    "berger",
    "berline",
    "bermuda",
    "besace",
    "besogne",
    "bétail",
    "beurre",
    "biberon",
    "bicycle",
    "bidule",
    "bijou",
    "bilan",
    "bilingue",
    "billard",
    "binaire",
    "biologie",
    "biopsie",
    "biotype",
    "biscuit",
    "bison",
    "bistouri",
    "bitume",
    "bizarre",
    "blafard",
    "blague",
    "blanchir",
    "blessant",
    "blinder",
    "blond",
    "bloquer",
    "blouson",
    "bobard",
    "bobine",
    "boire",
    "boiser",
    "bolide",
    "bonbon",
    "bondir",
    "bonheur",
    "bonifier",
    "bonus",
    "bordure",
    "borne",
    "botte",
    "boucle",
    "boueux",
    "bougie",
    "boulon",
    "bouquin",
    "bourse",
    "boussole",
    "boutique",
    "boxeur",
    "branche",
    "brasier",
    "brave",
    "brebis",
    "brèche",
    "breuvage",
    "bricoler",
    "brigade",
    "brillant",
    "brioche",
    "brique",
    "brochure",
    "broder",
    "bronzer",
    "brousse",
    "broyeur",
    "brume",
    "brusque",
    "brutal",
    "bruyant",
    "buffle",
    "buisson",
    "bulletin",
    "bureau",
    "burin",
    "bustier",
    "butiner",
    "butoir",
    "buvable",
    "buvette",
    "cabanon",
    "cabine",
    "cachette",
    "cadeau",
    "cadre",
    "caféine",
    "caillou",
    "caisson",
    "calculer",
    "calepin",
    "calibre",
    "calmer",
    "calomnie",
    "calvaire",
    "camarade",
    "caméra",
    "camion",
    "campagne",
    "canal",
    "caneton",
    "canon",
    "cantine",
    "canular",
    "capable",
    "caporal",
    "caprice",
    "capsule",
    "capter",
    "capuche",
    "carabine",
    "carbone",
    "caresser",
    "caribou",
    "carnage",
    "carotte",
    "carreau",
    "carton",
    "cascade",
    "casier",
    "casque",
    "cassure",
    "causer",
    "caution",
    "cavalier",
    "caverne",
    "caviar",
    "cédille",
    "ceinture",
    "céleste",
    "cellule",
    "cendrier",
    "censurer",
    "central",
    "cercle",
    "cérébral",
    "cerise",
    "cerner",
    "cerveau",
    "cesser",
    "chagrin",
    "chaise",
    "chaleur",
    "chambre",
    "chance",
    "chapitre",
    "charbon",
    "chasseur",
    "chaton",
    "chausson",
    "chavirer",
    "chemise",
    "chenille",
    "chéquier",
    "chercher",
    "cheval",
    "chien",
    "chiffre",
    "chignon",
    "chimère",
    "chiot",
    "chlorure",
    "chocolat",
    "choisir",
    "chose",
    "chouette",
    "chrome",
    "chute",
    "cigare",
    "cigogne",
    "cimenter",
    "cinéma",
    "cintrer",
    "circuler",
    "cirer",
    "cirque",
    "citerne",
    "citoyen",
    "citron",
    "civil",
    "clairon",
    "clameur",
    "claquer",
    "classe",
    "clavier",
    "client",
    "cligner",
    "climat",
    "clivage",
    "cloche",
    "clonage",
    "cloporte",
    "cobalt",
    "cobra",
    "cocasse",
    "cocotier",
    "coder",
    "codifier",
    "coffre",
    "cogner",
    "cohésion",
    "coiffer",
    "coincer",
    "colère",
    "colibri",
    "colline",
    "colmater",
    "colonel",
    "combat",
    "comédie",
    "commande",
    "compact",
    "concert",
    "conduire",
    "confier",
    "congeler",
    "connoter",
    "consonne",
    "contact",
    "convexe",
    "copain",
    "copie",
    "corail",
    "corbeau",
    "cordage",
    "corniche",
    "corpus",
    "correct",
    "cortège",
    "cosmique",
    "costume",
    "coton",
    "coude",
    "coupure",
    "courage",
    "couteau",
    "couvrir",
    "coyote",
    "crabe",
    "crainte",
    "cravate",
    "crayon",
    "créature",
    "créditer",
    "crémeux",
    "creuser",
    "crevette",
    "cribler",
    "crier",
    "cristal",
    "critère",
    "croire",
    "croquer",
    "crotale",
    "crucial",
    "cruel",
    "crypter",
    "cubique",
    "cueillir",
    "cuillère",
    "cuisine",
    "cuivre",
    "culminer",
    "cultiver",
    "cumuler",
    "cupide",
    "curatif",
    "curseur",
    "cyanure",
    "cycle",
    "cylindre",
    "cynique",
    "daigner",
    "damier",
    "danger",
    "danseur",
    "dauphin",
    "débattre",
    "débiter",
    "déborder",
    "débrider",
    "débutant",
    "décaler",
    "décembre",
    "déchirer",
    "décider",
    "déclarer",
    "décorer",
    "décrire",
    "décupler",
    "dédale",
    "déductif",
    "déesse",
    "défensif",
    "défiler",
    "défrayer",
    "dégager",
    "dégivrer",
    "déglutir",
    "dégrafer",
    "déjeuner",
    "délice",
    "déloger",
    "demander",
    "demeurer",
    "démolir",
    "dénicher",
    "dénouer",
    "dentelle",
    "dénuder",
    "départ",
    "dépenser",
    "déphaser",
    "déplacer",
    "déposer",
    "déranger",
    "dérober",
    "désastre",
    "descente",
    "désert",
    "désigner",
    "désobéir",
    "dessiner",
    "destrier",
    "détacher",
    "détester",
    "détourer",
    "détresse",
    "devancer",
    "devenir",
    "deviner",
    "devoir",
    "diable",
    "dialogue",
    "diamant",
    "dicter",
    "différer",
    "digérer",
    "digital",
    "digne",
    "diluer",
    "dimanche",
    "diminuer",
    "dioxyde",
    "directif",
    "diriger",
    "discuter",
    "disposer",
    "dissiper",
    "distance",
    "divertir",
    "diviser",
    "docile",
    "docteur",
    "dogme",
    "doigt",
    "domaine",
    "domicile",
    "dompter",
    "donateur",
    "donjon",
    "donner",
    "dopamine",
    "dortoir",
    "dorure",
    "dosage",
    "doseur",
    "dossier",
    "dotation",
    "douanier",
    "double",
    "douceur",
    "douter",
    "doyen",
    "dragon",
    "draper",
    "dresser",
    "dribbler",
    "droiture",
    "duperie",
    "duplexe",
    "durable",
    "durcir",
    "dynastie",
    "éblouir",
    "écarter",
    "écharpe",
    "échelle",
    "éclairer",
    "éclipse",
    "éclore",
    "écluse",
    "école",
    "économie",
    "écorce",
    "écouter",
    "écraser",
    "écrémer",
    "écrivain",
    "écrou",
    "écume",
    "écureuil",
    "édifier",
    "éduquer",
    "effacer",
    "effectif",
    "effigie",
    "effort",
    "effrayer",
    "effusion",
    "égaliser",
    "égarer",
    "éjecter",
    "élaborer",
    "élargir",
    "électron",
    "élégant",
    "éléphant",
    "élève",
    "éligible",
    "élitisme",
    "éloge",
    "élucider",
    "éluder",
    "emballer",
    "embellir",
    "embryon",
    "émeraude",
    "émission",
    "emmener",
    "émotion",
    "émouvoir",
    "empereur",
    "employer",
    "emporter",
    "emprise",
    "émulsion",
    "encadrer",
    "enchère",
    "enclave",
    "encoche",
    "endiguer",
    "endosser",
    "endroit",
    "enduire",
    "énergie",
    "enfance",
    "enfermer",
    "enfouir",
    "engager",
    "engin",
    "englober",
    "énigme",
    "enjamber",
    "enjeu",
    "enlever",
    "ennemi",
    "ennuyeux",
    "enrichir",
    "enrobage",
    "enseigne",
    "entasser",
    "entendre",
    "entier",
    "entourer",
    "entraver",
    "énumérer",
    "envahir",
    "enviable",
    "envoyer",
    "enzyme",
    "éolien",
    "épaissir",
    "épargne",
    "épatant",
    "épaule",
    "épicerie",
    "épidémie",
    "épier",
    "épilogue",
    "épine",
    "épisode",
    "épitaphe",
    "époque",
    "épreuve",
    "éprouver",
    "épuisant",
    "équerre",
    "équipe",
    "ériger",
    "érosion",
    "erreur",
    "éruption",
    "escalier",
    "espadon",
    "espèce",
    "espiègle",
    "espoir",
    "esprit",
    "esquiver",
    "essayer",
    "essence",
    "essieu",
    "essorer",
    "estime",
    "estomac",
    "estrade",
    "étagère",
    "étaler",
    "étanche",
    "étatique",
    "éteindre",
    "étendoir",
    "éternel",
    "éthanol",
    "éthique",
    "ethnie",
    "étirer",
    "étoffer",
    "étoile",
    "étonnant",
    "étourdir",
    "étrange",
    "étroit",
    "étude",
    "euphorie",
    "évaluer",
    "évasion",
    "éventail",
    "évidence",
    "éviter",
    "évolutif",
    "évoquer",
    "exact",
    "exagérer",
    "exaucer",
    "exceller",
    "excitant",
    "exclusif",
    "excuse",
    "exécuter",
    "exemple",
    "exercer",
    "exhaler",
    "exhorter",
    "exigence",
    "exiler",
    "exister",
    "exotique",
    "expédier",
    "explorer",
    "exposer",
    "exprimer",
    "exquis",
    "extensif",
    "extraire",
    "exulter",
    "fable",
    "fabuleux",
    "facette",
    "facile",
    "facture",
    "faiblir",
    "falaise",
    "fameux",
    "famille",
    "farceur",
    "farfelu",
    "farine",
    "farouche",
    "fasciner",
    "fatal",
    "fatigue",
    "faucon",
    "fautif",
    "faveur",
    "favori",
    "fébrile",
    "féconder",
    "fédérer",
    "félin",
    "femme",
    "fémur",
    "fendoir",
    "féodal",
    "fermer",
    "féroce",
    "ferveur",
    "festival",
    "feuille",
    "feutre",
    "février",
    "fiasco",
    "ficeler",
    "fictif",
    "fidèle",
    "figure",
    "filature",
    "filetage",
    "filière",
    "filleul",
    "filmer",
    "filou",
    "filtrer",
    "financer",
    "finir",
    "fiole",
    "firme",
    "fissure",
    "fixer",
    "flairer",
    "flamme",
    "flasque",
    "flatteur",
    "fléau",
    "flèche",
    "fleur",
    "flexion",
    "flocon",
    "flore",
    "fluctuer",
    "fluide",
    "fluvial",
    "folie",
    "fonderie",
    "fongible",
    "fontaine",
    "forcer",
    "forgeron",
    "formuler",
    "fortune",
    "fossile",
    "foudre",
    "fougère",
    "fouiller",
    "foulure",
    "fourmi",
    "fragile",
    "fraise",
    "franchir",
    "frapper",
    "frayeur",
    "frégate",
    "freiner",
    "frelon",
    "frémir",
    "frénésie",
    "frère",
    "friable",
    "friction",
    "frisson",
    "frivole",
    "froid",
    "fromage",
    "frontal",
    "frotter",
    "fruit",
    "fugitif",
    "fuite",
    "fureur",
    "furieux",
    "furtif",
    "fusion",
    "futur",
    "gagner",
    "galaxie",
    "galerie",
    "gambader",
    "garantir",
    "gardien",
    "garnir",
    "garrigue",
    "gazelle",
    "gazon",
    "géant",
    "gélatine",
    "gélule",
    "gendarme",
    "général",
    "génie",
    "genou",
    "gentil",
    "géologie",
    "géomètre",
    "géranium",
    "germe",
    "gestuel",
    "geyser",
    "gibier",
    "gicler",
    "girafe",
    "givre",
    "glace",
    "glaive",
    "glisser",
    "globe",
    "gloire",
    "glorieux",
    "golfeur",
    "gomme",
    "gonfler",
    "gorge",
    "gorille",
    "goudron",
    "gouffre",
    "goulot",
    "goupille",
    "gourmand",
    "goutte",
    "graduel",
    "graffiti",
    "graine",
    "grand",
    "grappin",
    "gratuit",
    "gravir",
    "grenat",
    "griffure",
    "griller",
    "grimper",
    "grogner",
    "gronder",
    "grotte",
    "groupe",
    "gruger",
    "grutier",
    "gruyère",
    "guépard",
    "guerrier",
    "guide",
    "guimauve",
    "guitare",
    "gustatif",
    "gymnaste",
    "gyrostat",
    "habitude",
    "hachoir",
    "halte",
    "hameau",
    "hangar",
    "hanneton",
    "haricot",
    "harmonie",
    "harpon",
    "hasard",
    "hélium",
    "hématome",
    "herbe",
    "hérisson",
    "hermine",
    "héron",
    "hésiter",
    "heureux",
    "hiberner",
    "hibou",
    "hilarant",
    "histoire",
    "hiver",
    "homard",
    "hommage",
    "homogène",
    "honneur",
    "honorer",
    "honteux",
    "horde",
    "horizon",
    "horloge",
    "hormone",
    "horrible",
    "houleux",
    "housse",
    "hublot",
    "huileux",
    "humain",
    "humble",
    "humide",
    "humour",
    "hurler",
    "hydromel",
    "hygiène",
    "hymne",
    "hypnose",
    "idylle",
    "ignorer",
    "iguane",
    "illicite",
    "illusion",
    "image",
    "imbiber",
    "imiter",
    "immense",
    "immobile",
    "immuable",
    "impact",
    "impérial",
    "implorer",
    "imposer",
    "imprimer",
    "imputer",
    "incarner",
    "incendie",
    "incident",
    "incliner",
    "incolore",
    "indexer",
    "indice",
    "inductif",
    "inédit",
    "ineptie",
    "inexact",
    "infini",
    "infliger",
    "informer",
    "infusion",
    "ingérer",
    "inhaler",
    "inhiber",
    "injecter",
    "injure",
    "innocent",
    "inoculer",
    "inonder",
    "inscrire",
    "insecte",
    "insigne",
    "insolite",
    "inspirer",
    "instinct",
    "insulter",
    "intact",
    "intense",
    "intime",
    "intrigue",
    "intuitif",
    "inutile",
    "invasion",
    "inventer",
    "inviter",
    "invoquer",
    "ironique",
    "irradier",
    "irréel",
    "irriter",
    "isoler",
    "ivoire",
    "ivresse",
    "jaguar",
    "jaillir",
    "jambe",
    "janvier",
    "jardin",
    "jauger",
    "jaune",
    "javelot",
    "jetable",
    "jeton",
    "jeudi",
    "jeunesse",
    "joindre",
    "joncher",
    "jongler",
    "joueur",
    "jouissif",
    "journal",
    "jovial",
    "joyau",
    "joyeux",
    "jubiler",
    "jugement",
    "junior",
    "jupon",
    "juriste",
    "justice",
    "juteux",
    "juvénile",
    "kayak",
    "kimono",
    "kiosque",
    "label",
    "labial",
    "labourer",
    "lacérer",
    "lactose",
    "lagune",
    "laine",
    "laisser",
    "laitier",
    "lambeau",
    "lamelle",
    "lampe",
    "lanceur",
    "langage",
    "lanterne",
    "lapin",
    "largeur",
    "larme",
    "laurier",
    "lavabo",
    "lavoir",
    "lecture",
    "légal",
    "léger",
    "légume",
    "lessive",
    "lettre",
    "levier",
    "lexique",
    "lézard",
    "liasse",
    "libérer",
    "libre",
    "licence",
    "licorne",
    "liège",
    "lièvre",
    "ligature",
    "ligoter",
    "ligue",
    "limer",
    "limite",
    "limonade",
    "limpide",
    "linéaire",
    "lingot",
    "lionceau",
    "liquide",
    "lisière",
    "lister",
    "lithium",
    "litige",
    "littoral",
    "livreur",
    "logique",
    "lointain",
    "loisir",
    "lombric",
    "loterie",
    "louer",
    "lourd",
    "loutre",
    "louve",
    "loyal",
    "lubie",
    "lucide",
    "lucratif",
    "lueur",
    "lugubre",
    "luisant",
    "lumière",
    "lunaire",
    "lundi",
    "luron",
    "lutter",
    "luxueux",
    "machine",
    "magasin",
    "magenta",
    "magique",
    "maigre",
    "maillon",
    "maintien",
    "mairie",
    "maison",
    "majorer",
    "malaxer",
    "maléfice",
    "malheur",
    "malice",
    "mallette",
    "mammouth",
    "mandater",
    "maniable",
    "manquant",
    "manteau",
    "manuel",
    "marathon",
    "marbre",
    "marchand",
    "mardi",
    "maritime",
    "marqueur",
    "marron",
    "marteler",
    "mascotte",
    "massif",
    "matériel",
    "matière",
    "matraque",
    "maudire",
    "maussade",
    "mauve",
    "maximal",
    "méchant",
    "méconnu",
    "médaille",
    "médecin",
    "méditer",
    "méduse",
    "meilleur",
    "mélange",
    "mélodie",
    "membre",
    "mémoire",
    "menacer",
    "mener",
    "menhir",
    "mensonge",
    "mentor",
    "mercredi",
    "mérite",
    "merle",
    "messager",
    "mesure",
    "métal",
    "météore",
    "méthode",
    "métier",
    "meuble",
    "miauler",
    "microbe",
    "miette",
    "mignon",
    "migrer",
    "milieu",
    "million",
    "mimique",
    "mince",
    "minéral",
    "minimal",
    "minorer",
    "minute",
    "miracle",
    "miroiter",
    "missile",
    "mixte",
    "mobile",
    "moderne",
    "moelleux",
    "mondial",
    "moniteur",
    "monnaie",
    "monotone",
    "monstre",
    "montagne",
    "monument",
    "moqueur",
    "morceau",
    "morsure",
    "mortier",
    "moteur",
    "motif",
    "mouche",
    "moufle",
    "moulin",
    "mousson",
    "mouton",
    "mouvant",
    "multiple",
    "munition",
    "muraille",
    "murène",
    "murmure",
    "muscle",
    "muséum",
    "musicien",
    "mutation",
    "muter",
    "mutuel",
    "myriade",
    "myrtille",
    "mystère",
    "mythique",
    "nageur",
    "nappe",
    "narquois",
    "narrer",
    "natation",
    "nation",
    "nature",
    "naufrage",
    "nautique",
    "navire",
    "nébuleux",
    "nectar",
    "néfaste",
    "négation",
    "négliger",
    "négocier",
    "neige",
    "nerveux",
    "nettoyer",
    "neurone",
    "neutron",
    "neveu",
    "niche",
    "nickel",
    "nitrate",
    "niveau",
    "noble",
    "nocif",
    "nocturne",
    "noirceur",
    "noisette",
    "nomade",
    "nombreux",
    "nommer",
    "normatif",
    "notable",
    "notifier",
    "notoire",
    "nourrir",
    "nouveau",
    "novateur",
    "novembre",
    "novice",
    "nuage",
    "nuancer",
    "nuire",
    "nuisible",
    "numéro",
    "nuptial",
    "nuque",
    "nutritif",
    "obéir",
    "objectif",
    "obliger",
    "obscur",
    "observer",
    "obstacle",
    "obtenir",
    "obturer",
    "occasion",
    "occuper",
    "océan",
    "octobre",
    "octroyer",
    "octupler",
    "oculaire",
    "odeur",
    "odorant",
    "offenser",
    "officier",
    "offrir",
    "ogive",
    "oiseau",
    "oisillon",
    "olfactif",
    "olivier",
    "ombrage",
    "omettre",
    "onctueux",
    "onduler",
    "onéreux",
    "onirique",
    "opale",
    "opaque",
    "opérer",
    "opinion",
    "opportun",
    "opprimer",
    "opter",
    "optique",
    "orageux",
    "orange",
    "orbite",
    "ordonner",
    "oreille",
    "organe",
    "orgueil",
    "orifice",
    "ornement",
    "orque",
    "ortie",
    "osciller",
    "osmose",
    "ossature",
    "otarie",
    "ouragan",
    "ourson",
    "outil",
    "outrager",
    "ouvrage",
    "ovation",
    "oxyde",
    "oxygène",
    "ozone",
    "paisible",
    "palace",
    "palmarès",
    "palourde",
    "palper",
    "panache",
    "panda",
    "pangolin",
    "paniquer",
    "panneau",
    "panorama",
    "pantalon",
    "papaye",
    "papier",
    "papoter",
    "papyrus",
    "paradoxe",
    "parcelle",
    "paresse",
    "parfumer",
    "parler",
    "parole",
    "parrain",
    "parsemer",
    "partager",
    "parure",
    "parvenir",
    "passion",
    "pastèque",
    "paternel",
    "patience",
    "patron",
    "pavillon",
    "pavoiser",
    "payer",
    "paysage",
    "peigne",
    "peintre",
    "pelage",
    "pélican",
    "pelle",
    "pelouse",
    "peluche",
    "pendule",
    "pénétrer",
    "pénible",
    "pensif",
    "pénurie",
    "pépite",
    "péplum",
    "perdrix",
    "perforer",
    "période",
    "permuter",
    "perplexe",
    "persil",
    "perte",
    "peser",
    "pétale",
    "petit",
    "pétrir",
    "peuple",
    "pharaon",
    "phobie",
    "phoque",
    "photon",
    "phrase",
    "physique",
    "piano",
    "pictural",
    "pièce",
    "pierre",
    "pieuvre",
    "pilote",
    "pinceau",
    "pipette",
    "piquer",
    "pirogue",
    "piscine",
    "piston",
    "pivoter",
    "pixel",
    "pizza",
    "placard",
    "plafond",
    "plaisir",
    "planer",
    "plaque",
    "plastron",
    "plateau",
    "pleurer",
    "plexus",
    "pliage",
    "plomb",
    "plonger",
    "pluie",
    "plumage",
    "pochette",
    "poésie",
    "poète",
    "pointe",
    "poirier",
    "poisson",
    "poivre",
    "polaire",
    "policier",
    "pollen",
    "polygone",
    "pommade",
    "pompier",
    "ponctuel",
    "pondérer",
    "poney",
    "portique",
    "position",
    "posséder",
    "posture",
    "potager",
    "poteau",
    "potion",
    "pouce",
    "poulain",
    "poumon",
    "pourpre",
    "poussin",
    "pouvoir",
    "prairie",
    "pratique",
    "précieux",
    "prédire",
    "préfixe",
    "prélude",
    "prénom",
    "présence",
    "prétexte",
    "prévoir",
    "primitif",
    "prince",
    "prison",
    "priver",
    "problème",
    "procéder",
    "prodige",
    "profond",
    "progrès",
    "proie",
    "projeter",
    "prologue",
    "promener",
    "propre",
    "prospère",
    "protéger",
    "prouesse",
    "proverbe",
    "prudence",
    "pruneau",
    "psychose",
    "public",
    "puceron",
    "puiser",
    "pulpe",
    "pulsar",
    "punaise",
    "punitif",
    "pupitre",
    "purifier",
    "puzzle",
    "pyramide",
    "quasar",
    "querelle",
    "question",
    "quiétude",
    "quitter",
    "quotient",
    "racine",
    "raconter",
    "radieux",
    "ragondin",
    "raideur",
    "raisin",
    "ralentir",
    "rallonge",
    "ramasser",
    "rapide",
    "rasage",
    "ratisser",
    "ravager",
    "ravin",
    "rayonner",
    "réactif",
    "réagir",
    "réaliser",
    "réanimer",
    "recevoir",
    "réciter",
    "réclamer",
    "récolter",
    "recruter",
    "reculer",
    "recycler",
    "rédiger",
    "redouter",
    "refaire",
    "réflexe",
    "réformer",
    "refrain",
    "refuge",
    "régalien",
    "région",
    "réglage",
    "régulier",
    "réitérer",
    "rejeter",
    "rejouer",
    "relatif",
    "relever",
    "relief",
    "remarque",
    "remède",
    "remise",
    "remonter",
    "remplir",
    "remuer",
    "renard",
    "renfort",
    "renifler",
    "renoncer",
    "rentrer",
    "renvoi",
    "replier",
    "reporter",
    "reprise",
    "reptile",
    "requin",
    "réserve",
    "résineux",
    "résoudre",
    "respect",
    "rester",
    "résultat",
    "rétablir",
    "retenir",
    "réticule",
    "retomber",
    "retracer",
    "réunion",
    "réussir",
    "revanche",
    "revivre",
    "révolte",
    "révulsif",
    "richesse",
    "rideau",
    "rieur",
    "rigide",
    "rigoler",
    "rincer",
    "riposter",
    "risible",
    "risque",
    "rituel",
    "rival",
    "rivière",
    "rocheux",
    "romance",
    "rompre",
    "ronce",
    "rondin",
    "roseau",
    "rosier",
    "rotatif",
    "rotor",
    "rotule",
    "rouge",
    "rouille",
    "rouleau",
    "routine",
    "royaume",
    "ruban",
    "rubis",
    "ruche",
    "ruelle",
    "rugueux",
    "ruiner",
    "ruisseau",
    "ruser",
    "rustique",
    "rythme",
    "sabler",
    "saboter",
    "sabre",
    "sacoche",
    "safari",
    "sagesse",
    "saisir",
    "salade",
    "salive",
    "salon",
    "saluer",
    "samedi",
    "sanction",
    "sanglier",
    "sarcasme",
    "sardine",
    "saturer",
    "saugrenu",
    "saumon",
    "sauter",
    "sauvage",
    "savant",
    "savonner",
    "scalpel",
    "scandale",
    "scélérat",
    "scénario",
    "sceptre",
    "schéma",
    "science",
    "scinder",
    "score",
    "scrutin",
    "sculpter",
    "séance",
    "sécable",
    "sécher",
    "secouer",
    "sécréter",
    "sédatif",
    "séduire",
    "seigneur",
    "séjour",
    "sélectif",
    "semaine",
    "sembler",
    "semence",
    "séminal",
    "sénateur",
    "sensible",
    "sentence",
    "séparer",
    "séquence",
    "serein",
    "sergent",
    "sérieux",
    "serrure",
    "sérum",
    "service",
    "sésame",
    "sévir",
    "sevrage",
    "sextuple",
    "sidéral",
    "siècle",
    "siéger",
    "siffler",
    "sigle",
    "signal",
    "silence",
    "silicium",
    "simple",
    "sincère",
    "sinistre",
    "siphon",
    "sirop",
    "sismique",
    "situer",
    "skier",
    "social",
    "socle",
    "sodium",
    "soigneux",
    "soldat",
    "soleil",
    "solitude",
    "soluble",
    "sombre",
    "sommeil",
    "somnoler",
    "sonde",
    "songeur",
    "sonnette",
    "sonore",
    "sorcier",
    "sortir",
    "sosie",
    "sottise",
    "soucieux",
    "soudure",
    "souffle",
    "soulever",
    "soupape",
    "source",
    "soutirer",
    "souvenir",
    "spacieux",
    "spatial",
    "spécial",
    "sphère",
    "spiral",
    "stable",
    "station",
    "sternum",
    "stimulus",
    "stipuler",
    "strict",
    "studieux",
    "stupeur",
    "styliste",
    "sublime",
    "substrat",
    "subtil",
    "subvenir",
    "succès",
    "sucre",
    "suffixe",
    "suggérer",
    "suiveur",
    "sulfate",
    "superbe",
    "supplier",
    "surface",
    "suricate",
    "surmener",
    "surprise",
    "sursaut",
    "survie",
    "suspect",
    "syllabe",
    "symbole",
    "symétrie",
    "synapse",
    "syntaxe",
    "système",
    "tabac",
    "tablier",
    "tactile",
    "tailler",
    "talent",
    "talisman",
    "talonner",
    "tambour",
    "tamiser",
    "tangible",
    "tapis",
    "taquiner",
    "tarder",
    "tarif",
    "tartine",
    "tasse",
    "tatami",
    "tatouage",
    "taupe",
    "taureau",
    "taxer",
    "témoin",
    "temporel",
    "tenaille",
    "tendre",
    "teneur",
    "tenir",
    "tension",
    "terminer",
    "terne",
    "terrible",
    "tétine",
    "texte",
    "thème",
    "théorie",
    "thérapie",
    "thorax",
    "tibia",
    "tiède",
    "timide",
    "tirelire",
    "tiroir",
    "tissu",
    "titane",
    "titre",
    "tituber",
    "toboggan",
    "tolérant",
    "tomate",
    "tonique",
    "tonneau",
    "toponyme",
    "torche",
    "tordre",
    "tornade",
    "torpille",
    "torrent",
    "torse",
    "tortue",
    "totem",
    "toucher",
    "tournage",
    "tousser",
    "toxine",
    "traction",
    "trafic",
    "tragique",
    "trahir",
    "train",
    "trancher",
    "travail",
    "trèfle",
    "tremper",
    "trésor",
    "treuil",
    "triage",
    "tribunal",
    "tricoter",
    "trilogie",
    "triomphe",
    "tripler",
    "triturer",
    "trivial",
    "trombone",
    "tronc",
    "tropical",
    "troupeau",
    "tuile",
    "tulipe",
    "tumulte",
    "tunnel",
    "turbine",
    "tuteur",
    "tutoyer",
    "tuyau",
    "tympan",
    "typhon",
    "typique",
    "tyran",
    "ubuesque",
    "ultime",
    "ultrason",
    "unanime",
    "unifier",
    "union",
    "unique",
    "unitaire",
    "univers",
    "uranium",
    "urbain",
    "urticant",
    "usage",
    "usine",
    "usuel",
    "usure",
    "utile",
    "utopie",
    "vacarme",
    "vaccin",
    "vagabond",
    "vague",
    "vaillant",
    "vaincre",
    "vaisseau",
    "valable",
    "valise",
    "vallon",
    "valve",
    "vampire",
    "vanille",
    "vapeur",
    "varier",
    "vaseux",
    "vassal",
    "vaste",
    "vecteur",
    "vedette",
    "végétal",
    "véhicule",
    "veinard",
    "véloce",
    "vendredi",
    "vénérer",
    "venger",
    "venimeux",
    "ventouse",
    "verdure",
    "vérin",
    "vernir",
    "verrou",
    "verser",
    "vertu",
    "veston",
    "vétéran",
    "vétuste",
    "vexant",
    "vexer",
    "viaduc",
    "viande",
    "victoire",
    "vidange",
    "vidéo",
    "vignette",
    "vigueur",
    "vilain",
    "village",
    "vinaigre",
    "violon",
    "vipère",
    "virement",
    "virtuose",
    "virus",
    "visage",
    "viseur",
    "vision",
    "visqueux",
    "visuel",
    "vital",
    "vitesse",
    "viticole",
    "vitrine",
    "vivace",
    "vivipare",
    "vocation",
    "voguer",
    "voile",
    "voisin",
    "voiture",
    "volaille",
    "volcan",
    "voltiger",
    "volume",
    "vorace",
    "vortex",
    "voter",
    "vouloir",
    "voyage",
    "voyelle",
    "wagon",
    "xénon",
    "yacht",
    "zèbre",
    "zénith",
    "zeste",
    "zoologie"
  ]), t0;
}
var r0, w2;
function Ug() {
  return w2 || (w2 = 1, r0 = [
    "abaco",
    "abbaglio",
    "abbinato",
    "abete",
    "abisso",
    "abolire",
    "abrasivo",
    "abrogato",
    "accadere",
    "accenno",
    "accusato",
    "acetone",
    "achille",
    "acido",
    "acqua",
    "acre",
    "acrilico",
    "acrobata",
    "acuto",
    "adagio",
    "addebito",
    "addome",
    "adeguato",
    "aderire",
    "adipe",
    "adottare",
    "adulare",
    "affabile",
    "affetto",
    "affisso",
    "affranto",
    "aforisma",
    "afoso",
    "africano",
    "agave",
    "agente",
    "agevole",
    "aggancio",
    "agire",
    "agitare",
    "agonismo",
    "agricolo",
    "agrumeto",
    "aguzzo",
    "alabarda",
    "alato",
    "albatro",
    "alberato",
    "albo",
    "albume",
    "alce",
    "alcolico",
    "alettone",
    "alfa",
    "algebra",
    "aliante",
    "alibi",
    "alimento",
    "allagato",
    "allegro",
    "allievo",
    "allodola",
    "allusivo",
    "almeno",
    "alogeno",
    "alpaca",
    "alpestre",
    "altalena",
    "alterno",
    "alticcio",
    "altrove",
    "alunno",
    "alveolo",
    "alzare",
    "amalgama",
    "amanita",
    "amarena",
    "ambito",
    "ambrato",
    "ameba",
    "america",
    "ametista",
    "amico",
    "ammasso",
    "ammenda",
    "ammirare",
    "ammonito",
    "amore",
    "ampio",
    "ampliare",
    "amuleto",
    "anacardo",
    "anagrafe",
    "analista",
    "anarchia",
    "anatra",
    "anca",
    "ancella",
    "ancora",
    "andare",
    "andrea",
    "anello",
    "angelo",
    "angolare",
    "angusto",
    "anima",
    "annegare",
    "annidato",
    "anno",
    "annuncio",
    "anonimo",
    "anticipo",
    "anzi",
    "apatico",
    "apertura",
    "apode",
    "apparire",
    "appetito",
    "appoggio",
    "approdo",
    "appunto",
    "aprile",
    "arabica",
    "arachide",
    "aragosta",
    "araldica",
    "arancio",
    "aratura",
    "arazzo",
    "arbitro",
    "archivio",
    "ardito",
    "arenile",
    "argento",
    "argine",
    "arguto",
    "aria",
    "armonia",
    "arnese",
    "arredato",
    "arringa",
    "arrosto",
    "arsenico",
    "arso",
    "artefice",
    "arzillo",
    "asciutto",
    "ascolto",
    "asepsi",
    "asettico",
    "asfalto",
    "asino",
    "asola",
    "aspirato",
    "aspro",
    "assaggio",
    "asse",
    "assoluto",
    "assurdo",
    "asta",
    "astenuto",
    "astice",
    "astratto",
    "atavico",
    "ateismo",
    "atomico",
    "atono",
    "attesa",
    "attivare",
    "attorno",
    "attrito",
    "attuale",
    "ausilio",
    "austria",
    "autista",
    "autonomo",
    "autunno",
    "avanzato",
    "avere",
    "avvenire",
    "avviso",
    "avvolgere",
    "azione",
    "azoto",
    "azzimo",
    "azzurro",
    "babele",
    "baccano",
    "bacino",
    "baco",
    "badessa",
    "badilata",
    "bagnato",
    "baita",
    "balcone",
    "baldo",
    "balena",
    "ballata",
    "balzano",
    "bambino",
    "bandire",
    "baraonda",
    "barbaro",
    "barca",
    "baritono",
    "barlume",
    "barocco",
    "basilico",
    "basso",
    "batosta",
    "battuto",
    "baule",
    "bava",
    "bavosa",
    "becco",
    "beffa",
    "belgio",
    "belva",
    "benda",
    "benevole",
    "benigno",
    "benzina",
    "bere",
    "berlina",
    "beta",
    "bibita",
    "bici",
    "bidone",
    "bifido",
    "biga",
    "bilancia",
    "bimbo",
    "binocolo",
    "biologo",
    "bipede",
    "bipolare",
    "birbante",
    "birra",
    "biscotto",
    "bisesto",
    "bisnonno",
    "bisonte",
    "bisturi",
    "bizzarro",
    "blando",
    "blatta",
    "bollito",
    "bonifico",
    "bordo",
    "bosco",
    "botanico",
    "bottino",
    "bozzolo",
    "braccio",
    "bradipo",
    "brama",
    "branca",
    "bravura",
    "bretella",
    "brevetto",
    "brezza",
    "briglia",
    "brillante",
    "brindare",
    "broccolo",
    "brodo",
    "bronzina",
    "brullo",
    "bruno",
    "bubbone",
    "buca",
    "budino",
    "buffone",
    "buio",
    "bulbo",
    "buono",
    "burlone",
    "burrasca",
    "bussola",
    "busta",
    "cadetto",
    "caduco",
    "calamaro",
    "calcolo",
    "calesse",
    "calibro",
    "calmo",
    "caloria",
    "cambusa",
    "camerata",
    "camicia",
    "cammino",
    "camola",
    "campale",
    "canapa",
    "candela",
    "cane",
    "canino",
    "canotto",
    "cantina",
    "capace",
    "capello",
    "capitolo",
    "capogiro",
    "cappero",
    "capra",
    "capsula",
    "carapace",
    "carcassa",
    "cardo",
    "carisma",
    "carovana",
    "carretto",
    "cartolina",
    "casaccio",
    "cascata",
    "caserma",
    "caso",
    "cassone",
    "castello",
    "casuale",
    "catasta",
    "catena",
    "catrame",
    "cauto",
    "cavillo",
    "cedibile",
    "cedrata",
    "cefalo",
    "celebre",
    "cellulare",
    "cena",
    "cenone",
    "centesimo",
    "ceramica",
    "cercare",
    "certo",
    "cerume",
    "cervello",
    "cesoia",
    "cespo",
    "ceto",
    "chela",
    "chiaro",
    "chicca",
    "chiedere",
    "chimera",
    "china",
    "chirurgo",
    "chitarra",
    "ciao",
    "ciclismo",
    "cifrare",
    "cigno",
    "cilindro",
    "ciottolo",
    "circa",
    "cirrosi",
    "citrico",
    "cittadino",
    "ciuffo",
    "civetta",
    "civile",
    "classico",
    "clinica",
    "cloro",
    "cocco",
    "codardo",
    "codice",
    "coerente",
    "cognome",
    "collare",
    "colmato",
    "colore",
    "colposo",
    "coltivato",
    "colza",
    "coma",
    "cometa",
    "commando",
    "comodo",
    "computer",
    "comune",
    "conciso",
    "condurre",
    "conferma",
    "congelare",
    "coniuge",
    "connesso",
    "conoscere",
    "consumo",
    "continuo",
    "convegno",
    "coperto",
    "copione",
    "coppia",
    "copricapo",
    "corazza",
    "cordata",
    "coricato",
    "cornice",
    "corolla",
    "corpo",
    "corredo",
    "corsia",
    "cortese",
    "cosmico",
    "costante",
    "cottura",
    "covato",
    "cratere",
    "cravatta",
    "creato",
    "credere",
    "cremoso",
    "crescita",
    "creta",
    "criceto",
    "crinale",
    "crisi",
    "critico",
    "croce",
    "cronaca",
    "crostata",
    "cruciale",
    "crusca",
    "cucire",
    "cuculo",
    "cugino",
    "cullato",
    "cupola",
    "curatore",
    "cursore",
    "curvo",
    "cuscino",
    "custode",
    "dado",
    "daino",
    "dalmata",
    "damerino",
    "daniela",
    "dannoso",
    "danzare",
    "datato",
    "davanti",
    "davvero",
    "debutto",
    "decennio",
    "deciso",
    "declino",
    "decollo",
    "decreto",
    "dedicato",
    "definito",
    "deforme",
    "degno",
    "delegare",
    "delfino",
    "delirio",
    "delta",
    "demenza",
    "denotato",
    "dentro",
    "deposito",
    "derapata",
    "derivare",
    "deroga",
    "descritto",
    "deserto",
    "desiderio",
    "desumere",
    "detersivo",
    "devoto",
    "diametro",
    "dicembre",
    "diedro",
    "difeso",
    "diffuso",
    "digerire",
    "digitale",
    "diluvio",
    "dinamico",
    "dinnanzi",
    "dipinto",
    "diploma",
    "dipolo",
    "diradare",
    "dire",
    "dirotto",
    "dirupo",
    "disagio",
    "discreto",
    "disfare",
    "disgelo",
    "disposto",
    "distanza",
    "disumano",
    "dito",
    "divano",
    "divelto",
    "dividere",
    "divorato",
    "doblone",
    "docente",
    "doganale",
    "dogma",
    "dolce",
    "domato",
    "domenica",
    "dominare",
    "dondolo",
    "dono",
    "dormire",
    "dote",
    "dottore",
    "dovuto",
    "dozzina",
    "drago",
    "druido",
    "dubbio",
    "dubitare",
    "ducale",
    "duna",
    "duomo",
    "duplice",
    "duraturo",
    "ebano",
    "eccesso",
    "ecco",
    "eclissi",
    "economia",
    "edera",
    "edicola",
    "edile",
    "editoria",
    "educare",
    "egemonia",
    "egli",
    "egoismo",
    "egregio",
    "elaborato",
    "elargire",
    "elegante",
    "elencato",
    "eletto",
    "elevare",
    "elfico",
    "elica",
    "elmo",
    "elsa",
    "eluso",
    "emanato",
    "emblema",
    "emesso",
    "emiro",
    "emotivo",
    "emozione",
    "empirico",
    "emulo",
    "endemico",
    "enduro",
    "energia",
    "enfasi",
    "enoteca",
    "entrare",
    "enzima",
    "epatite",
    "epilogo",
    "episodio",
    "epocale",
    "eppure",
    "equatore",
    "erario",
    "erba",
    "erboso",
    "erede",
    "eremita",
    "erigere",
    "ermetico",
    "eroe",
    "erosivo",
    "errante",
    "esagono",
    "esame",
    "esanime",
    "esaudire",
    "esca",
    "esempio",
    "esercito",
    "esibito",
    "esigente",
    "esistere",
    "esito",
    "esofago",
    "esortato",
    "esoso",
    "espanso",
    "espresso",
    "essenza",
    "esso",
    "esteso",
    "estimare",
    "estonia",
    "estroso",
    "esultare",
    "etilico",
    "etnico",
    "etrusco",
    "etto",
    "euclideo",
    "europa",
    "evaso",
    "evidenza",
    "evitato",
    "evoluto",
    "evviva",
    "fabbrica",
    "faccenda",
    "fachiro",
    "falco",
    "famiglia",
    "fanale",
    "fanfara",
    "fango",
    "fantasma",
    "fare",
    "farfalla",
    "farinoso",
    "farmaco",
    "fascia",
    "fastoso",
    "fasullo",
    "faticare",
    "fato",
    "favoloso",
    "febbre",
    "fecola",
    "fede",
    "fegato",
    "felpa",
    "feltro",
    "femmina",
    "fendere",
    "fenomeno",
    "fermento",
    "ferro",
    "fertile",
    "fessura",
    "festivo",
    "fetta",
    "feudo",
    "fiaba",
    "fiducia",
    "fifa",
    "figurato",
    "filo",
    "finanza",
    "finestra",
    "finire",
    "fiore",
    "fiscale",
    "fisico",
    "fiume",
    "flacone",
    "flamenco",
    "flebo",
    "flemma",
    "florido",
    "fluente",
    "fluoro",
    "fobico",
    "focaccia",
    "focoso",
    "foderato",
    "foglio",
    "folata",
    "folclore",
    "folgore",
    "fondente",
    "fonetico",
    "fonia",
    "fontana",
    "forbito",
    "forchetta",
    "foresta",
    "formica",
    "fornaio",
    "foro",
    "fortezza",
    "forzare",
    "fosfato",
    "fosso",
    "fracasso",
    "frana",
    "frassino",
    "fratello",
    "freccetta",
    "frenata",
    "fresco",
    "frigo",
    "frollino",
    "fronde",
    "frugale",
    "frutta",
    "fucilata",
    "fucsia",
    "fuggente",
    "fulmine",
    "fulvo",
    "fumante",
    "fumetto",
    "fumoso",
    "fune",
    "funzione",
    "fuoco",
    "furbo",
    "furgone",
    "furore",
    "fuso",
    "futile",
    "gabbiano",
    "gaffe",
    "galateo",
    "gallina",
    "galoppo",
    "gambero",
    "gamma",
    "garanzia",
    "garbo",
    "garofano",
    "garzone",
    "gasdotto",
    "gasolio",
    "gastrico",
    "gatto",
    "gaudio",
    "gazebo",
    "gazzella",
    "geco",
    "gelatina",
    "gelso",
    "gemello",
    "gemmato",
    "gene",
    "genitore",
    "gennaio",
    "genotipo",
    "gergo",
    "ghepardo",
    "ghiaccio",
    "ghisa",
    "giallo",
    "gilda",
    "ginepro",
    "giocare",
    "gioiello",
    "giorno",
    "giove",
    "girato",
    "girone",
    "gittata",
    "giudizio",
    "giurato",
    "giusto",
    "globulo",
    "glutine",
    "gnomo",
    "gobba",
    "golf",
    "gomito",
    "gommone",
    "gonfio",
    "gonna",
    "governo",
    "gracile",
    "grado",
    "grafico",
    "grammo",
    "grande",
    "grattare",
    "gravoso",
    "grazia",
    "greca",
    "gregge",
    "grifone",
    "grigio",
    "grinza",
    "grotta",
    "gruppo",
    "guadagno",
    "guaio",
    "guanto",
    "guardare",
    "gufo",
    "guidare",
    "ibernato",
    "icona",
    "identico",
    "idillio",
    "idolo",
    "idra",
    "idrico",
    "idrogeno",
    "igiene",
    "ignaro",
    "ignorato",
    "ilare",
    "illeso",
    "illogico",
    "illudere",
    "imballo",
    "imbevuto",
    "imbocco",
    "imbuto",
    "immane",
    "immerso",
    "immolato",
    "impacco",
    "impeto",
    "impiego",
    "importo",
    "impronta",
    "inalare",
    "inarcare",
    "inattivo",
    "incanto",
    "incendio",
    "inchino",
    "incisivo",
    "incluso",
    "incontro",
    "incrocio",
    "incubo",
    "indagine",
    "india",
    "indole",
    "inedito",
    "infatti",
    "infilare",
    "inflitto",
    "ingaggio",
    "ingegno",
    "inglese",
    "ingordo",
    "ingrosso",
    "innesco",
    "inodore",
    "inoltrare",
    "inondato",
    "insano",
    "insetto",
    "insieme",
    "insonnia",
    "insulina",
    "intasato",
    "intero",
    "intonaco",
    "intuito",
    "inumidire",
    "invalido",
    "invece",
    "invito",
    "iperbole",
    "ipnotico",
    "ipotesi",
    "ippica",
    "iride",
    "irlanda",
    "ironico",
    "irrigato",
    "irrorare",
    "isolato",
    "isotopo",
    "isterico",
    "istituto",
    "istrice",
    "italia",
    "iterare",
    "labbro",
    "labirinto",
    "lacca",
    "lacerato",
    "lacrima",
    "lacuna",
    "laddove",
    "lago",
    "lampo",
    "lancetta",
    "lanterna",
    "lardoso",
    "larga",
    "laringe",
    "lastra",
    "latenza",
    "latino",
    "lattuga",
    "lavagna",
    "lavoro",
    "legale",
    "leggero",
    "lembo",
    "lentezza",
    "lenza",
    "leone",
    "lepre",
    "lesivo",
    "lessato",
    "lesto",
    "letterale",
    "leva",
    "levigato",
    "libero",
    "lido",
    "lievito",
    "lilla",
    "limatura",
    "limitare",
    "limpido",
    "lineare",
    "lingua",
    "liquido",
    "lira",
    "lirica",
    "lisca",
    "lite",
    "litigio",
    "livrea",
    "locanda",
    "lode",
    "logica",
    "lombare",
    "londra",
    "longevo",
    "loquace",
    "lorenzo",
    "loto",
    "lotteria",
    "luce",
    "lucidato",
    "lumaca",
    "luminoso",
    "lungo",
    "lupo",
    "luppolo",
    "lusinga",
    "lusso",
    "lutto",
    "macabro",
    "macchina",
    "macero",
    "macinato",
    "madama",
    "magico",
    "maglia",
    "magnete",
    "magro",
    "maiolica",
    "malafede",
    "malgrado",
    "malinteso",
    "malsano",
    "malto",
    "malumore",
    "mana",
    "mancia",
    "mandorla",
    "mangiare",
    "manifesto",
    "mannaro",
    "manovra",
    "mansarda",
    "mantide",
    "manubrio",
    "mappa",
    "maratona",
    "marcire",
    "maretta",
    "marmo",
    "marsupio",
    "maschera",
    "massaia",
    "mastino",
    "materasso",
    "matricola",
    "mattone",
    "maturo",
    "mazurca",
    "meandro",
    "meccanico",
    "mecenate",
    "medesimo",
    "meditare",
    "mega",
    "melassa",
    "melis",
    "melodia",
    "meninge",
    "meno",
    "mensola",
    "mercurio",
    "merenda",
    "merlo",
    "meschino",
    "mese",
    "messere",
    "mestolo",
    "metallo",
    "metodo",
    "mettere",
    "miagolare",
    "mica",
    "micelio",
    "michele",
    "microbo",
    "midollo",
    "miele",
    "migliore",
    "milano",
    "milite",
    "mimosa",
    "minerale",
    "mini",
    "minore",
    "mirino",
    "mirtillo",
    "miscela",
    "missiva",
    "misto",
    "misurare",
    "mitezza",
    "mitigare",
    "mitra",
    "mittente",
    "mnemonico",
    "modello",
    "modifica",
    "modulo",
    "mogano",
    "mogio",
    "mole",
    "molosso",
    "monastero",
    "monco",
    "mondina",
    "monetario",
    "monile",
    "monotono",
    "monsone",
    "montato",
    "monviso",
    "mora",
    "mordere",
    "morsicato",
    "mostro",
    "motivato",
    "motosega",
    "motto",
    "movenza",
    "movimento",
    "mozzo",
    "mucca",
    "mucosa",
    "muffa",
    "mughetto",
    "mugnaio",
    "mulatto",
    "mulinello",
    "multiplo",
    "mummia",
    "munto",
    "muovere",
    "murale",
    "musa",
    "muscolo",
    "musica",
    "mutevole",
    "muto",
    "nababbo",
    "nafta",
    "nanometro",
    "narciso",
    "narice",
    "narrato",
    "nascere",
    "nastrare",
    "naturale",
    "nautica",
    "naviglio",
    "nebulosa",
    "necrosi",
    "negativo",
    "negozio",
    "nemmeno",
    "neofita",
    "neretto",
    "nervo",
    "nessuno",
    "nettuno",
    "neutrale",
    "neve",
    "nevrotico",
    "nicchia",
    "ninfa",
    "nitido",
    "nobile",
    "nocivo",
    "nodo",
    "nome",
    "nomina",
    "nordico",
    "normale",
    "norvegese",
    "nostrano",
    "notare",
    "notizia",
    "notturno",
    "novella",
    "nucleo",
    "nulla",
    "numero",
    "nuovo",
    "nutrire",
    "nuvola",
    "nuziale",
    "oasi",
    "obbedire",
    "obbligo",
    "obelisco",
    "oblio",
    "obolo",
    "obsoleto",
    "occasione",
    "occhio",
    "occidente",
    "occorrere",
    "occultare",
    "ocra",
    "oculato",
    "odierno",
    "odorare",
    "offerta",
    "offrire",
    "offuscato",
    "oggetto",
    "oggi",
    "ognuno",
    "olandese",
    "olfatto",
    "oliato",
    "oliva",
    "ologramma",
    "oltre",
    "omaggio",
    "ombelico",
    "ombra",
    "omega",
    "omissione",
    "ondoso",
    "onere",
    "onice",
    "onnivoro",
    "onorevole",
    "onta",
    "operato",
    "opinione",
    "opposto",
    "oracolo",
    "orafo",
    "ordine",
    "orecchino",
    "orefice",
    "orfano",
    "organico",
    "origine",
    "orizzonte",
    "orma",
    "ormeggio",
    "ornativo",
    "orologio",
    "orrendo",
    "orribile",
    "ortensia",
    "ortica",
    "orzata",
    "orzo",
    "osare",
    "oscurare",
    "osmosi",
    "ospedale",
    "ospite",
    "ossa",
    "ossidare",
    "ostacolo",
    "oste",
    "otite",
    "otre",
    "ottagono",
    "ottimo",
    "ottobre",
    "ovale",
    "ovest",
    "ovino",
    "oviparo",
    "ovocito",
    "ovunque",
    "ovviare",
    "ozio",
    "pacchetto",
    "pace",
    "pacifico",
    "padella",
    "padrone",
    "paese",
    "paga",
    "pagina",
    "palazzina",
    "palesare",
    "pallido",
    "palo",
    "palude",
    "pandoro",
    "pannello",
    "paolo",
    "paonazzo",
    "paprica",
    "parabola",
    "parcella",
    "parere",
    "pargolo",
    "pari",
    "parlato",
    "parola",
    "partire",
    "parvenza",
    "parziale",
    "passivo",
    "pasticca",
    "patacca",
    "patologia",
    "pattume",
    "pavone",
    "peccato",
    "pedalare",
    "pedonale",
    "peggio",
    "peloso",
    "penare",
    "pendice",
    "penisola",
    "pennuto",
    "penombra",
    "pensare",
    "pentola",
    "pepe",
    "pepita",
    "perbene",
    "percorso",
    "perdonato",
    "perforare",
    "pergamena",
    "periodo",
    "permesso",
    "perno",
    "perplesso",
    "persuaso",
    "pertugio",
    "pervaso",
    "pesatore",
    "pesista",
    "peso",
    "pestifero",
    "petalo",
    "pettine",
    "petulante",
    "pezzo",
    "piacere",
    "pianta",
    "piattino",
    "piccino",
    "picozza",
    "piega",
    "pietra",
    "piffero",
    "pigiama",
    "pigolio",
    "pigro",
    "pila",
    "pilifero",
    "pillola",
    "pilota",
    "pimpante",
    "pineta",
    "pinna",
    "pinolo",
    "pioggia",
    "piombo",
    "piramide",
    "piretico",
    "pirite",
    "pirolisi",
    "pitone",
    "pizzico",
    "placebo",
    "planare",
    "plasma",
    "platano",
    "plenario",
    "pochezza",
    "poderoso",
    "podismo",
    "poesia",
    "poggiare",
    "polenta",
    "poligono",
    "pollice",
    "polmonite",
    "polpetta",
    "polso",
    "poltrona",
    "polvere",
    "pomice",
    "pomodoro",
    "ponte",
    "popoloso",
    "porfido",
    "poroso",
    "porpora",
    "porre",
    "portata",
    "posa",
    "positivo",
    "possesso",
    "postulato",
    "potassio",
    "potere",
    "pranzo",
    "prassi",
    "pratica",
    "precluso",
    "predica",
    "prefisso",
    "pregiato",
    "prelievo",
    "premere",
    "prenotare",
    "preparato",
    "presenza",
    "pretesto",
    "prevalso",
    "prima",
    "principe",
    "privato",
    "problema",
    "procura",
    "produrre",
    "profumo",
    "progetto",
    "prolunga",
    "promessa",
    "pronome",
    "proposta",
    "proroga",
    "proteso",
    "prova",
    "prudente",
    "prugna",
    "prurito",
    "psiche",
    "pubblico",
    "pudica",
    "pugilato",
    "pugno",
    "pulce",
    "pulito",
    "pulsante",
    "puntare",
    "pupazzo",
    "pupilla",
    "puro",
    "quadro",
    "qualcosa",
    "quasi",
    "querela",
    "quota",
    "raccolto",
    "raddoppio",
    "radicale",
    "radunato",
    "raffica",
    "ragazzo",
    "ragione",
    "ragno",
    "ramarro",
    "ramingo",
    "ramo",
    "randagio",
    "rantolare",
    "rapato",
    "rapina",
    "rappreso",
    "rasatura",
    "raschiato",
    "rasente",
    "rassegna",
    "rastrello",
    "rata",
    "ravveduto",
    "reale",
    "recepire",
    "recinto",
    "recluta",
    "recondito",
    "recupero",
    "reddito",
    "redimere",
    "regalato",
    "registro",
    "regola",
    "regresso",
    "relazione",
    "remare",
    "remoto",
    "renna",
    "replica",
    "reprimere",
    "reputare",
    "resa",
    "residente",
    "responso",
    "restauro",
    "rete",
    "retina",
    "retorica",
    "rettifica",
    "revocato",
    "riassunto",
    "ribadire",
    "ribelle",
    "ribrezzo",
    "ricarica",
    "ricco",
    "ricevere",
    "riciclato",
    "ricordo",
    "ricreduto",
    "ridicolo",
    "ridurre",
    "rifasare",
    "riflesso",
    "riforma",
    "rifugio",
    "rigare",
    "rigettato",
    "righello",
    "rilassato",
    "rilevato",
    "rimanere",
    "rimbalzo",
    "rimedio",
    "rimorchio",
    "rinascita",
    "rincaro",
    "rinforzo",
    "rinnovo",
    "rinomato",
    "rinsavito",
    "rintocco",
    "rinuncia",
    "rinvenire",
    "riparato",
    "ripetuto",
    "ripieno",
    "riportare",
    "ripresa",
    "ripulire",
    "risata",
    "rischio",
    "riserva",
    "risibile",
    "riso",
    "rispetto",
    "ristoro",
    "risultato",
    "risvolto",
    "ritardo",
    "ritegno",
    "ritmico",
    "ritrovo",
    "riunione",
    "riva",
    "riverso",
    "rivincita",
    "rivolto",
    "rizoma",
    "roba",
    "robotico",
    "robusto",
    "roccia",
    "roco",
    "rodaggio",
    "rodere",
    "roditore",
    "rogito",
    "rollio",
    "romantico",
    "rompere",
    "ronzio",
    "rosolare",
    "rospo",
    "rotante",
    "rotondo",
    "rotula",
    "rovescio",
    "rubizzo",
    "rubrica",
    "ruga",
    "rullino",
    "rumine",
    "rumoroso",
    "ruolo",
    "rupe",
    "russare",
    "rustico",
    "sabato",
    "sabbiare",
    "sabotato",
    "sagoma",
    "salasso",
    "saldatura",
    "salgemma",
    "salivare",
    "salmone",
    "salone",
    "saltare",
    "saluto",
    "salvo",
    "sapere",
    "sapido",
    "saporito",
    "saraceno",
    "sarcasmo",
    "sarto",
    "sassoso",
    "satellite",
    "satira",
    "satollo",
    "saturno",
    "savana",
    "savio",
    "saziato",
    "sbadiglio",
    "sbalzo",
    "sbancato",
    "sbarra",
    "sbattere",
    "sbavare",
    "sbendare",
    "sbirciare",
    "sbloccato",
    "sbocciato",
    "sbrinare",
    "sbruffone",
    "sbuffare",
    "scabroso",
    "scadenza",
    "scala",
    "scambiare",
    "scandalo",
    "scapola",
    "scarso",
    "scatenare",
    "scavato",
    "scelto",
    "scenico",
    "scettro",
    "scheda",
    "schiena",
    "sciarpa",
    "scienza",
    "scindere",
    "scippo",
    "sciroppo",
    "scivolo",
    "sclerare",
    "scodella",
    "scolpito",
    "scomparto",
    "sconforto",
    "scoprire",
    "scorta",
    "scossone",
    "scozzese",
    "scriba",
    "scrollare",
    "scrutinio",
    "scuderia",
    "scultore",
    "scuola",
    "scuro",
    "scusare",
    "sdebitare",
    "sdoganare",
    "seccatura",
    "secondo",
    "sedano",
    "seggiola",
    "segnalato",
    "segregato",
    "seguito",
    "selciato",
    "selettivo",
    "sella",
    "selvaggio",
    "semaforo",
    "sembrare",
    "seme",
    "seminato",
    "sempre",
    "senso",
    "sentire",
    "sepolto",
    "sequenza",
    "serata",
    "serbato",
    "sereno",
    "serio",
    "serpente",
    "serraglio",
    "servire",
    "sestina",
    "setola",
    "settimana",
    "sfacelo",
    "sfaldare",
    "sfamato",
    "sfarzoso",
    "sfaticato",
    "sfera",
    "sfida",
    "sfilato",
    "sfinge",
    "sfocato",
    "sfoderare",
    "sfogo",
    "sfoltire",
    "sforzato",
    "sfratto",
    "sfruttato",
    "sfuggito",
    "sfumare",
    "sfuso",
    "sgabello",
    "sgarbato",
    "sgonfiare",
    "sgorbio",
    "sgrassato",
    "sguardo",
    "sibilo",
    "siccome",
    "sierra",
    "sigla",
    "signore",
    "silenzio",
    "sillaba",
    "simbolo",
    "simpatico",
    "simulato",
    "sinfonia",
    "singolo",
    "sinistro",
    "sino",
    "sintesi",
    "sinusoide",
    "sipario",
    "sisma",
    "sistole",
    "situato",
    "slitta",
    "slogatura",
    "sloveno",
    "smarrito",
    "smemorato",
    "smentito",
    "smeraldo",
    "smilzo",
    "smontare",
    "smottato",
    "smussato",
    "snellire",
    "snervato",
    "snodo",
    "sobbalzo",
    "sobrio",
    "soccorso",
    "sociale",
    "sodale",
    "soffitto",
    "sogno",
    "soldato",
    "solenne",
    "solido",
    "sollazzo",
    "solo",
    "solubile",
    "solvente",
    "somatico",
    "somma",
    "sonda",
    "sonetto",
    "sonnifero",
    "sopire",
    "soppeso",
    "sopra",
    "sorgere",
    "sorpasso",
    "sorriso",
    "sorso",
    "sorteggio",
    "sorvolato",
    "sospiro",
    "sosta",
    "sottile",
    "spada",
    "spalla",
    "spargere",
    "spatola",
    "spavento",
    "spazzola",
    "specie",
    "spedire",
    "spegnere",
    "spelatura",
    "speranza",
    "spessore",
    "spettrale",
    "spezzato",
    "spia",
    "spigoloso",
    "spillato",
    "spinoso",
    "spirale",
    "splendido",
    "sportivo",
    "sposo",
    "spranga",
    "sprecare",
    "spronato",
    "spruzzo",
    "spuntino",
    "squillo",
    "sradicare",
    "srotolato",
    "stabile",
    "stacco",
    "staffa",
    "stagnare",
    "stampato",
    "stantio",
    "starnuto",
    "stasera",
    "statuto",
    "stelo",
    "steppa",
    "sterzo",
    "stiletto",
    "stima",
    "stirpe",
    "stivale",
    "stizzoso",
    "stonato",
    "storico",
    "strappo",
    "stregato",
    "stridulo",
    "strozzare",
    "strutto",
    "stuccare",
    "stufo",
    "stupendo",
    "subentro",
    "succoso",
    "sudore",
    "suggerito",
    "sugo",
    "sultano",
    "suonare",
    "superbo",
    "supporto",
    "surgelato",
    "surrogato",
    "sussurro",
    "sutura",
    "svagare",
    "svedese",
    "sveglio",
    "svelare",
    "svenuto",
    "svezia",
    "sviluppo",
    "svista",
    "svizzera",
    "svolta",
    "svuotare",
    "tabacco",
    "tabulato",
    "tacciare",
    "taciturno",
    "tale",
    "talismano",
    "tampone",
    "tannino",
    "tara",
    "tardivo",
    "targato",
    "tariffa",
    "tarpare",
    "tartaruga",
    "tasto",
    "tattico",
    "taverna",
    "tavolata",
    "tazza",
    "teca",
    "tecnico",
    "telefono",
    "temerario",
    "tempo",
    "temuto",
    "tendone",
    "tenero",
    "tensione",
    "tentacolo",
    "teorema",
    "terme",
    "terrazzo",
    "terzetto",
    "tesi",
    "tesserato",
    "testato",
    "tetro",
    "tettoia",
    "tifare",
    "tigella",
    "timbro",
    "tinto",
    "tipico",
    "tipografo",
    "tiraggio",
    "tiro",
    "titanio",
    "titolo",
    "titubante",
    "tizio",
    "tizzone",
    "toccare",
    "tollerare",
    "tolto",
    "tombola",
    "tomo",
    "tonfo",
    "tonsilla",
    "topazio",
    "topologia",
    "toppa",
    "torba",
    "tornare",
    "torrone",
    "tortora",
    "toscano",
    "tossire",
    "tostatura",
    "totano",
    "trabocco",
    "trachea",
    "trafila",
    "tragedia",
    "tralcio",
    "tramonto",
    "transito",
    "trapano",
    "trarre",
    "trasloco",
    "trattato",
    "trave",
    "treccia",
    "tremolio",
    "trespolo",
    "tributo",
    "tricheco",
    "trifoglio",
    "trillo",
    "trincea",
    "trio",
    "tristezza",
    "triturato",
    "trivella",
    "tromba",
    "trono",
    "troppo",
    "trottola",
    "trovare",
    "truccato",
    "tubatura",
    "tuffato",
    "tulipano",
    "tumulto",
    "tunisia",
    "turbare",
    "turchino",
    "tuta",
    "tutela",
    "ubicato",
    "uccello",
    "uccisore",
    "udire",
    "uditivo",
    "uffa",
    "ufficio",
    "uguale",
    "ulisse",
    "ultimato",
    "umano",
    "umile",
    "umorismo",
    "uncinetto",
    "ungere",
    "ungherese",
    "unicorno",
    "unificato",
    "unisono",
    "unitario",
    "unte",
    "uovo",
    "upupa",
    "uragano",
    "urgenza",
    "urlo",
    "usanza",
    "usato",
    "uscito",
    "usignolo",
    "usuraio",
    "utensile",
    "utilizzo",
    "utopia",
    "vacante",
    "vaccinato",
    "vagabondo",
    "vagliato",
    "valanga",
    "valgo",
    "valico",
    "valletta",
    "valoroso",
    "valutare",
    "valvola",
    "vampata",
    "vangare",
    "vanitoso",
    "vano",
    "vantaggio",
    "vanvera",
    "vapore",
    "varano",
    "varcato",
    "variante",
    "vasca",
    "vedetta",
    "vedova",
    "veduto",
    "vegetale",
    "veicolo",
    "velcro",
    "velina",
    "velluto",
    "veloce",
    "venato",
    "vendemmia",
    "vento",
    "verace",
    "verbale",
    "vergogna",
    "verifica",
    "vero",
    "verruca",
    "verticale",
    "vescica",
    "vessillo",
    "vestale",
    "veterano",
    "vetrina",
    "vetusto",
    "viandante",
    "vibrante",
    "vicenda",
    "vichingo",
    "vicinanza",
    "vidimare",
    "vigilia",
    "vigneto",
    "vigore",
    "vile",
    "villano",
    "vimini",
    "vincitore",
    "viola",
    "vipera",
    "virgola",
    "virologo",
    "virulento",
    "viscoso",
    "visione",
    "vispo",
    "vissuto",
    "visura",
    "vita",
    "vitello",
    "vittima",
    "vivanda",
    "vivido",
    "viziare",
    "voce",
    "voga",
    "volatile",
    "volere",
    "volpe",
    "voragine",
    "vulcano",
    "zampogna",
    "zanna",
    "zappato",
    "zattera",
    "zavorra",
    "zefiro",
    "zelante",
    "zelo",
    "zenzero",
    "zerbino",
    "zibetto",
    "zinco",
    "zircone",
    "zitto",
    "zolla",
    "zotico",
    "zucchero",
    "zufolo",
    "zulu",
    "zuppa"
  ]), r0;
}
var i0, y2;
function Fg() {
  return y2 || (y2 = 1, i0 = [
    "あいこくしん",
    "あいさつ",
    "あいだ",
    "あおぞら",
    "あかちゃん",
    "あきる",
    "あけがた",
    "あける",
    "あこがれる",
    "あさい",
    "あさひ",
    "あしあと",
    "あじわう",
    "あずかる",
    "あずき",
    "あそぶ",
    "あたえる",
    "あたためる",
    "あたりまえ",
    "あたる",
    "あつい",
    "あつかう",
    "あっしゅく",
    "あつまり",
    "あつめる",
    "あてな",
    "あてはまる",
    "あひる",
    "あぶら",
    "あぶる",
    "あふれる",
    "あまい",
    "あまど",
    "あまやかす",
    "あまり",
    "あみもの",
    "あめりか",
    "あやまる",
    "あゆむ",
    "あらいぐま",
    "あらし",
    "あらすじ",
    "あらためる",
    "あらゆる",
    "あらわす",
    "ありがとう",
    "あわせる",
    "あわてる",
    "あんい",
    "あんがい",
    "あんこ",
    "あんぜん",
    "あんてい",
    "あんない",
    "あんまり",
    "いいだす",
    "いおん",
    "いがい",
    "いがく",
    "いきおい",
    "いきなり",
    "いきもの",
    "いきる",
    "いくじ",
    "いくぶん",
    "いけばな",
    "いけん",
    "いこう",
    "いこく",
    "いこつ",
    "いさましい",
    "いさん",
    "いしき",
    "いじゅう",
    "いじょう",
    "いじわる",
    "いずみ",
    "いずれ",
    "いせい",
    "いせえび",
    "いせかい",
    "いせき",
    "いぜん",
    "いそうろう",
    "いそがしい",
    "いだい",
    "いだく",
    "いたずら",
    "いたみ",
    "いたりあ",
    "いちおう",
    "いちじ",
    "いちど",
    "いちば",
    "いちぶ",
    "いちりゅう",
    "いつか",
    "いっしゅん",
    "いっせい",
    "いっそう",
    "いったん",
    "いっち",
    "いってい",
    "いっぽう",
    "いてざ",
    "いてん",
    "いどう",
    "いとこ",
    "いない",
    "いなか",
    "いねむり",
    "いのち",
    "いのる",
    "いはつ",
    "いばる",
    "いはん",
    "いびき",
    "いひん",
    "いふく",
    "いへん",
    "いほう",
    "いみん",
    "いもうと",
    "いもたれ",
    "いもり",
    "いやがる",
    "いやす",
    "いよかん",
    "いよく",
    "いらい",
    "いらすと",
    "いりぐち",
    "いりょう",
    "いれい",
    "いれもの",
    "いれる",
    "いろえんぴつ",
    "いわい",
    "いわう",
    "いわかん",
    "いわば",
    "いわゆる",
    "いんげんまめ",
    "いんさつ",
    "いんしょう",
    "いんよう",
    "うえき",
    "うえる",
    "うおざ",
    "うがい",
    "うかぶ",
    "うかべる",
    "うきわ",
    "うくらいな",
    "うくれれ",
    "うけたまわる",
    "うけつけ",
    "うけとる",
    "うけもつ",
    "うける",
    "うごかす",
    "うごく",
    "うこん",
    "うさぎ",
    "うしなう",
    "うしろがみ",
    "うすい",
    "うすぎ",
    "うすぐらい",
    "うすめる",
    "うせつ",
    "うちあわせ",
    "うちがわ",
    "うちき",
    "うちゅう",
    "うっかり",
    "うつくしい",
    "うったえる",
    "うつる",
    "うどん",
    "うなぎ",
    "うなじ",
    "うなずく",
    "うなる",
    "うねる",
    "うのう",
    "うぶげ",
    "うぶごえ",
    "うまれる",
    "うめる",
    "うもう",
    "うやまう",
    "うよく",
    "うらがえす",
    "うらぐち",
    "うらない",
    "うりあげ",
    "うりきれ",
    "うるさい",
    "うれしい",
    "うれゆき",
    "うれる",
    "うろこ",
    "うわき",
    "うわさ",
    "うんこう",
    "うんちん",
    "うんてん",
    "うんどう",
    "えいえん",
    "えいが",
    "えいきょう",
    "えいご",
    "えいせい",
    "えいぶん",
    "えいよう",
    "えいわ",
    "えおり",
    "えがお",
    "えがく",
    "えきたい",
    "えくせる",
    "えしゃく",
    "えすて",
    "えつらん",
    "えのぐ",
    "えほうまき",
    "えほん",
    "えまき",
    "えもじ",
    "えもの",
    "えらい",
    "えらぶ",
    "えりあ",
    "えんえん",
    "えんかい",
    "えんぎ",
    "えんげき",
    "えんしゅう",
    "えんぜつ",
    "えんそく",
    "えんちょう",
    "えんとつ",
    "おいかける",
    "おいこす",
    "おいしい",
    "おいつく",
    "おうえん",
    "おうさま",
    "おうじ",
    "おうせつ",
    "おうたい",
    "おうふく",
    "おうべい",
    "おうよう",
    "おえる",
    "おおい",
    "おおう",
    "おおどおり",
    "おおや",
    "おおよそ",
    "おかえり",
    "おかず",
    "おがむ",
    "おかわり",
    "おぎなう",
    "おきる",
    "おくさま",
    "おくじょう",
    "おくりがな",
    "おくる",
    "おくれる",
    "おこす",
    "おこなう",
    "おこる",
    "おさえる",
    "おさない",
    "おさめる",
    "おしいれ",
    "おしえる",
    "おじぎ",
    "おじさん",
    "おしゃれ",
    "おそらく",
    "おそわる",
    "おたがい",
    "おたく",
    "おだやか",
    "おちつく",
    "おっと",
    "おつり",
    "おでかけ",
    "おとしもの",
    "おとなしい",
    "おどり",
    "おどろかす",
    "おばさん",
    "おまいり",
    "おめでとう",
    "おもいで",
    "おもう",
    "おもたい",
    "おもちゃ",
    "おやつ",
    "おやゆび",
    "およぼす",
    "おらんだ",
    "おろす",
    "おんがく",
    "おんけい",
    "おんしゃ",
    "おんせん",
    "おんだん",
    "おんちゅう",
    "おんどけい",
    "かあつ",
    "かいが",
    "がいき",
    "がいけん",
    "がいこう",
    "かいさつ",
    "かいしゃ",
    "かいすいよく",
    "かいぜん",
    "かいぞうど",
    "かいつう",
    "かいてん",
    "かいとう",
    "かいふく",
    "がいへき",
    "かいほう",
    "かいよう",
    "がいらい",
    "かいわ",
    "かえる",
    "かおり",
    "かかえる",
    "かがく",
    "かがし",
    "かがみ",
    "かくご",
    "かくとく",
    "かざる",
    "がぞう",
    "かたい",
    "かたち",
    "がちょう",
    "がっきゅう",
    "がっこう",
    "がっさん",
    "がっしょう",
    "かなざわし",
    "かのう",
    "がはく",
    "かぶか",
    "かほう",
    "かほご",
    "かまう",
    "かまぼこ",
    "かめれおん",
    "かゆい",
    "かようび",
    "からい",
    "かるい",
    "かろう",
    "かわく",
    "かわら",
    "がんか",
    "かんけい",
    "かんこう",
    "かんしゃ",
    "かんそう",
    "かんたん",
    "かんち",
    "がんばる",
    "きあい",
    "きあつ",
    "きいろ",
    "ぎいん",
    "きうい",
    "きうん",
    "きえる",
    "きおう",
    "きおく",
    "きおち",
    "きおん",
    "きかい",
    "きかく",
    "きかんしゃ",
    "ききて",
    "きくばり",
    "きくらげ",
    "きけんせい",
    "きこう",
    "きこえる",
    "きこく",
    "きさい",
    "きさく",
    "きさま",
    "きさらぎ",
    "ぎじかがく",
    "ぎしき",
    "ぎじたいけん",
    "ぎじにってい",
    "ぎじゅつしゃ",
    "きすう",
    "きせい",
    "きせき",
    "きせつ",
    "きそう",
    "きぞく",
    "きぞん",
    "きたえる",
    "きちょう",
    "きつえん",
    "ぎっちり",
    "きつつき",
    "きつね",
    "きてい",
    "きどう",
    "きどく",
    "きない",
    "きなが",
    "きなこ",
    "きぬごし",
    "きねん",
    "きのう",
    "きのした",
    "きはく",
    "きびしい",
    "きひん",
    "きふく",
    "きぶん",
    "きぼう",
    "きほん",
    "きまる",
    "きみつ",
    "きむずかしい",
    "きめる",
    "きもだめし",
    "きもち",
    "きもの",
    "きゃく",
    "きやく",
    "ぎゅうにく",
    "きよう",
    "きょうりゅう",
    "きらい",
    "きらく",
    "きりん",
    "きれい",
    "きれつ",
    "きろく",
    "ぎろん",
    "きわめる",
    "ぎんいろ",
    "きんかくじ",
    "きんじょ",
    "きんようび",
    "ぐあい",
    "くいず",
    "くうかん",
    "くうき",
    "くうぐん",
    "くうこう",
    "ぐうせい",
    "くうそう",
    "ぐうたら",
    "くうふく",
    "くうぼ",
    "くかん",
    "くきょう",
    "くげん",
    "ぐこう",
    "くさい",
    "くさき",
    "くさばな",
    "くさる",
    "くしゃみ",
    "くしょう",
    "くすのき",
    "くすりゆび",
    "くせげ",
    "くせん",
    "ぐたいてき",
    "くださる",
    "くたびれる",
    "くちこみ",
    "くちさき",
    "くつした",
    "ぐっすり",
    "くつろぐ",
    "くとうてん",
    "くどく",
    "くなん",
    "くねくね",
    "くのう",
    "くふう",
    "くみあわせ",
    "くみたてる",
    "くめる",
    "くやくしょ",
    "くらす",
    "くらべる",
    "くるま",
    "くれる",
    "くろう",
    "くわしい",
    "ぐんかん",
    "ぐんしょく",
    "ぐんたい",
    "ぐんて",
    "けあな",
    "けいかく",
    "けいけん",
    "けいこ",
    "けいさつ",
    "げいじゅつ",
    "けいたい",
    "げいのうじん",
    "けいれき",
    "けいろ",
    "けおとす",
    "けおりもの",
    "げきか",
    "げきげん",
    "げきだん",
    "げきちん",
    "げきとつ",
    "げきは",
    "げきやく",
    "げこう",
    "げこくじょう",
    "げざい",
    "けさき",
    "げざん",
    "けしき",
    "けしごむ",
    "けしょう",
    "げすと",
    "けたば",
    "けちゃっぷ",
    "けちらす",
    "けつあつ",
    "けつい",
    "けつえき",
    "けっこん",
    "けつじょ",
    "けっせき",
    "けってい",
    "けつまつ",
    "げつようび",
    "げつれい",
    "けつろん",
    "げどく",
    "けとばす",
    "けとる",
    "けなげ",
    "けなす",
    "けなみ",
    "けぬき",
    "げねつ",
    "けねん",
    "けはい",
    "げひん",
    "けぶかい",
    "げぼく",
    "けまり",
    "けみかる",
    "けむし",
    "けむり",
    "けもの",
    "けらい",
    "けろけろ",
    "けわしい",
    "けんい",
    "けんえつ",
    "けんお",
    "けんか",
    "げんき",
    "けんげん",
    "けんこう",
    "けんさく",
    "けんしゅう",
    "けんすう",
    "げんそう",
    "けんちく",
    "けんてい",
    "けんとう",
    "けんない",
    "けんにん",
    "げんぶつ",
    "けんま",
    "けんみん",
    "けんめい",
    "けんらん",
    "けんり",
    "こあくま",
    "こいぬ",
    "こいびと",
    "ごうい",
    "こうえん",
    "こうおん",
    "こうかん",
    "ごうきゅう",
    "ごうけい",
    "こうこう",
    "こうさい",
    "こうじ",
    "こうすい",
    "ごうせい",
    "こうそく",
    "こうたい",
    "こうちゃ",
    "こうつう",
    "こうてい",
    "こうどう",
    "こうない",
    "こうはい",
    "ごうほう",
    "ごうまん",
    "こうもく",
    "こうりつ",
    "こえる",
    "こおり",
    "ごかい",
    "ごがつ",
    "ごかん",
    "こくご",
    "こくさい",
    "こくとう",
    "こくない",
    "こくはく",
    "こぐま",
    "こけい",
    "こける",
    "ここのか",
    "こころ",
    "こさめ",
    "こしつ",
    "こすう",
    "こせい",
    "こせき",
    "こぜん",
    "こそだて",
    "こたい",
    "こたえる",
    "こたつ",
    "こちょう",
    "こっか",
    "こつこつ",
    "こつばん",
    "こつぶ",
    "こてい",
    "こてん",
    "ことがら",
    "ことし",
    "ことば",
    "ことり",
    "こなごな",
    "こねこね",
    "このまま",
    "このみ",
    "このよ",
    "ごはん",
    "こひつじ",
    "こふう",
    "こふん",
    "こぼれる",
    "ごまあぶら",
    "こまかい",
    "ごますり",
    "こまつな",
    "こまる",
    "こむぎこ",
    "こもじ",
    "こもち",
    "こもの",
    "こもん",
    "こやく",
    "こやま",
    "こゆう",
    "こゆび",
    "こよい",
    "こよう",
    "こりる",
    "これくしょん",
    "ころっけ",
    "こわもて",
    "こわれる",
    "こんいん",
    "こんかい",
    "こんき",
    "こんしゅう",
    "こんすい",
    "こんだて",
    "こんとん",
    "こんなん",
    "こんびに",
    "こんぽん",
    "こんまけ",
    "こんや",
    "こんれい",
    "こんわく",
    "ざいえき",
    "さいかい",
    "さいきん",
    "ざいげん",
    "ざいこ",
    "さいしょ",
    "さいせい",
    "ざいたく",
    "ざいちゅう",
    "さいてき",
    "ざいりょう",
    "さうな",
    "さかいし",
    "さがす",
    "さかな",
    "さかみち",
    "さがる",
    "さぎょう",
    "さくし",
    "さくひん",
    "さくら",
    "さこく",
    "さこつ",
    "さずかる",
    "ざせき",
    "さたん",
    "さつえい",
    "ざつおん",
    "ざっか",
    "ざつがく",
    "さっきょく",
    "ざっし",
    "さつじん",
    "ざっそう",
    "さつたば",
    "さつまいも",
    "さてい",
    "さといも",
    "さとう",
    "さとおや",
    "さとし",
    "さとる",
    "さのう",
    "さばく",
    "さびしい",
    "さべつ",
    "さほう",
    "さほど",
    "さます",
    "さみしい",
    "さみだれ",
    "さむけ",
    "さめる",
    "さやえんどう",
    "さゆう",
    "さよう",
    "さよく",
    "さらだ",
    "ざるそば",
    "さわやか",
    "さわる",
    "さんいん",
    "さんか",
    "さんきゃく",
    "さんこう",
    "さんさい",
    "ざんしょ",
    "さんすう",
    "さんせい",
    "さんそ",
    "さんち",
    "さんま",
    "さんみ",
    "さんらん",
    "しあい",
    "しあげ",
    "しあさって",
    "しあわせ",
    "しいく",
    "しいん",
    "しうち",
    "しえい",
    "しおけ",
    "しかい",
    "しかく",
    "じかん",
    "しごと",
    "しすう",
    "じだい",
    "したうけ",
    "したぎ",
    "したて",
    "したみ",
    "しちょう",
    "しちりん",
    "しっかり",
    "しつじ",
    "しつもん",
    "してい",
    "してき",
    "してつ",
    "じてん",
    "じどう",
    "しなぎれ",
    "しなもの",
    "しなん",
    "しねま",
    "しねん",
    "しのぐ",
    "しのぶ",
    "しはい",
    "しばかり",
    "しはつ",
    "しはらい",
    "しはん",
    "しひょう",
    "しふく",
    "じぶん",
    "しへい",
    "しほう",
    "しほん",
    "しまう",
    "しまる",
    "しみん",
    "しむける",
    "じむしょ",
    "しめい",
    "しめる",
    "しもん",
    "しゃいん",
    "しゃうん",
    "しゃおん",
    "じゃがいも",
    "しやくしょ",
    "しゃくほう",
    "しゃけん",
    "しゃこ",
    "しゃざい",
    "しゃしん",
    "しゃせん",
    "しゃそう",
    "しゃたい",
    "しゃちょう",
    "しゃっきん",
    "じゃま",
    "しゃりん",
    "しゃれい",
    "じゆう",
    "じゅうしょ",
    "しゅくはく",
    "じゅしん",
    "しゅっせき",
    "しゅみ",
    "しゅらば",
    "じゅんばん",
    "しょうかい",
    "しょくたく",
    "しょっけん",
    "しょどう",
    "しょもつ",
    "しらせる",
    "しらべる",
    "しんか",
    "しんこう",
    "じんじゃ",
    "しんせいじ",
    "しんちく",
    "しんりん",
    "すあげ",
    "すあし",
    "すあな",
    "ずあん",
    "すいえい",
    "すいか",
    "すいとう",
    "ずいぶん",
    "すいようび",
    "すうがく",
    "すうじつ",
    "すうせん",
    "すおどり",
    "すきま",
    "すくう",
    "すくない",
    "すける",
    "すごい",
    "すこし",
    "ずさん",
    "すずしい",
    "すすむ",
    "すすめる",
    "すっかり",
    "ずっしり",
    "ずっと",
    "すてき",
    "すてる",
    "すねる",
    "すのこ",
    "すはだ",
    "すばらしい",
    "ずひょう",
    "ずぶぬれ",
    "すぶり",
    "すふれ",
    "すべて",
    "すべる",
    "ずほう",
    "すぼん",
    "すまい",
    "すめし",
    "すもう",
    "すやき",
    "すらすら",
    "するめ",
    "すれちがう",
    "すろっと",
    "すわる",
    "すんぜん",
    "すんぽう",
    "せあぶら",
    "せいかつ",
    "せいげん",
    "せいじ",
    "せいよう",
    "せおう",
    "せかいかん",
    "せきにん",
    "せきむ",
    "せきゆ",
    "せきらんうん",
    "せけん",
    "せこう",
    "せすじ",
    "せたい",
    "せたけ",
    "せっかく",
    "せっきゃく",
    "ぜっく",
    "せっけん",
    "せっこつ",
    "せっさたくま",
    "せつぞく",
    "せつだん",
    "せつでん",
    "せっぱん",
    "せつび",
    "せつぶん",
    "せつめい",
    "せつりつ",
    "せなか",
    "せのび",
    "せはば",
    "せびろ",
    "せぼね",
    "せまい",
    "せまる",
    "せめる",
    "せもたれ",
    "せりふ",
    "ぜんあく",
    "せんい",
    "せんえい",
    "せんか",
    "せんきょ",
    "せんく",
    "せんげん",
    "ぜんご",
    "せんさい",
    "せんしゅ",
    "せんすい",
    "せんせい",
    "せんぞ",
    "せんたく",
    "せんちょう",
    "せんてい",
    "せんとう",
    "せんぬき",
    "せんねん",
    "せんぱい",
    "ぜんぶ",
    "ぜんぽう",
    "せんむ",
    "せんめんじょ",
    "せんもん",
    "せんやく",
    "せんゆう",
    "せんよう",
    "ぜんら",
    "ぜんりゃく",
    "せんれい",
    "せんろ",
    "そあく",
    "そいとげる",
    "そいね",
    "そうがんきょう",
    "そうき",
    "そうご",
    "そうしん",
    "そうだん",
    "そうなん",
    "そうび",
    "そうめん",
    "そうり",
    "そえもの",
    "そえん",
    "そがい",
    "そげき",
    "そこう",
    "そこそこ",
    "そざい",
    "そしな",
    "そせい",
    "そせん",
    "そそぐ",
    "そだてる",
    "そつう",
    "そつえん",
    "そっかん",
    "そつぎょう",
    "そっけつ",
    "そっこう",
    "そっせん",
    "そっと",
    "そとがわ",
    "そとづら",
    "そなえる",
    "そなた",
    "そふぼ",
    "そぼく",
    "そぼろ",
    "そまつ",
    "そまる",
    "そむく",
    "そむりえ",
    "そめる",
    "そもそも",
    "そよかぜ",
    "そらまめ",
    "そろう",
    "そんかい",
    "そんけい",
    "そんざい",
    "そんしつ",
    "そんぞく",
    "そんちょう",
    "ぞんび",
    "ぞんぶん",
    "そんみん",
    "たあい",
    "たいいん",
    "たいうん",
    "たいえき",
    "たいおう",
    "だいがく",
    "たいき",
    "たいぐう",
    "たいけん",
    "たいこ",
    "たいざい",
    "だいじょうぶ",
    "だいすき",
    "たいせつ",
    "たいそう",
    "だいたい",
    "たいちょう",
    "たいてい",
    "だいどころ",
    "たいない",
    "たいねつ",
    "たいのう",
    "たいはん",
    "だいひょう",
    "たいふう",
    "たいへん",
    "たいほ",
    "たいまつばな",
    "たいみんぐ",
    "たいむ",
    "たいめん",
    "たいやき",
    "たいよう",
    "たいら",
    "たいりょく",
    "たいる",
    "たいわん",
    "たうえ",
    "たえる",
    "たおす",
    "たおる",
    "たおれる",
    "たかい",
    "たかね",
    "たきび",
    "たくさん",
    "たこく",
    "たこやき",
    "たさい",
    "たしざん",
    "だじゃれ",
    "たすける",
    "たずさわる",
    "たそがれ",
    "たたかう",
    "たたく",
    "ただしい",
    "たたみ",
    "たちばな",
    "だっかい",
    "だっきゃく",
    "だっこ",
    "だっしゅつ",
    "だったい",
    "たてる",
    "たとえる",
    "たなばた",
    "たにん",
    "たぬき",
    "たのしみ",
    "たはつ",
    "たぶん",
    "たべる",
    "たぼう",
    "たまご",
    "たまる",
    "だむる",
    "ためいき",
    "ためす",
    "ためる",
    "たもつ",
    "たやすい",
    "たよる",
    "たらす",
    "たりきほんがん",
    "たりょう",
    "たりる",
    "たると",
    "たれる",
    "たれんと",
    "たろっと",
    "たわむれる",
    "だんあつ",
    "たんい",
    "たんおん",
    "たんか",
    "たんき",
    "たんけん",
    "たんご",
    "たんさん",
    "たんじょうび",
    "だんせい",
    "たんそく",
    "たんたい",
    "だんち",
    "たんてい",
    "たんとう",
    "だんな",
    "たんにん",
    "だんねつ",
    "たんのう",
    "たんぴん",
    "だんぼう",
    "たんまつ",
    "たんめい",
    "だんれつ",
    "だんろ",
    "だんわ",
    "ちあい",
    "ちあん",
    "ちいき",
    "ちいさい",
    "ちえん",
    "ちかい",
    "ちから",
    "ちきゅう",
    "ちきん",
    "ちけいず",
    "ちけん",
    "ちこく",
    "ちさい",
    "ちしき",
    "ちしりょう",
    "ちせい",
    "ちそう",
    "ちたい",
    "ちたん",
    "ちちおや",
    "ちつじょ",
    "ちてき",
    "ちてん",
    "ちぬき",
    "ちぬり",
    "ちのう",
    "ちひょう",
    "ちへいせん",
    "ちほう",
    "ちまた",
    "ちみつ",
    "ちみどろ",
    "ちめいど",
    "ちゃんこなべ",
    "ちゅうい",
    "ちゆりょく",
    "ちょうし",
    "ちょさくけん",
    "ちらし",
    "ちらみ",
    "ちりがみ",
    "ちりょう",
    "ちるど",
    "ちわわ",
    "ちんたい",
    "ちんもく",
    "ついか",
    "ついたち",
    "つうか",
    "つうじょう",
    "つうはん",
    "つうわ",
    "つかう",
    "つかれる",
    "つくね",
    "つくる",
    "つけね",
    "つける",
    "つごう",
    "つたえる",
    "つづく",
    "つつじ",
    "つつむ",
    "つとめる",
    "つながる",
    "つなみ",
    "つねづね",
    "つのる",
    "つぶす",
    "つまらない",
    "つまる",
    "つみき",
    "つめたい",
    "つもり",
    "つもる",
    "つよい",
    "つるぼ",
    "つるみく",
    "つわもの",
    "つわり",
    "てあし",
    "てあて",
    "てあみ",
    "ていおん",
    "ていか",
    "ていき",
    "ていけい",
    "ていこく",
    "ていさつ",
    "ていし",
    "ていせい",
    "ていたい",
    "ていど",
    "ていねい",
    "ていひょう",
    "ていへん",
    "ていぼう",
    "てうち",
    "ておくれ",
    "てきとう",
    "てくび",
    "でこぼこ",
    "てさぎょう",
    "てさげ",
    "てすり",
    "てそう",
    "てちがい",
    "てちょう",
    "てつがく",
    "てつづき",
    "でっぱ",
    "てつぼう",
    "てつや",
    "でぬかえ",
    "てぬき",
    "てぬぐい",
    "てのひら",
    "てはい",
    "てぶくろ",
    "てふだ",
    "てほどき",
    "てほん",
    "てまえ",
    "てまきずし",
    "てみじか",
    "てみやげ",
    "てらす",
    "てれび",
    "てわけ",
    "てわたし",
    "でんあつ",
    "てんいん",
    "てんかい",
    "てんき",
    "てんぐ",
    "てんけん",
    "てんごく",
    "てんさい",
    "てんし",
    "てんすう",
    "でんち",
    "てんてき",
    "てんとう",
    "てんない",
    "てんぷら",
    "てんぼうだい",
    "てんめつ",
    "てんらんかい",
    "でんりょく",
    "でんわ",
    "どあい",
    "といれ",
    "どうかん",
    "とうきゅう",
    "どうぐ",
    "とうし",
    "とうむぎ",
    "とおい",
    "とおか",
    "とおく",
    "とおす",
    "とおる",
    "とかい",
    "とかす",
    "ときおり",
    "ときどき",
    "とくい",
    "とくしゅう",
    "とくてん",
    "とくに",
    "とくべつ",
    "とけい",
    "とける",
    "とこや",
    "とさか",
    "としょかん",
    "とそう",
    "とたん",
    "とちゅう",
    "とっきゅう",
    "とっくん",
    "とつぜん",
    "とつにゅう",
    "とどける",
    "ととのえる",
    "とない",
    "となえる",
    "となり",
    "とのさま",
    "とばす",
    "どぶがわ",
    "とほう",
    "とまる",
    "とめる",
    "ともだち",
    "ともる",
    "どようび",
    "とらえる",
    "とんかつ",
    "どんぶり",
    "ないかく",
    "ないこう",
    "ないしょ",
    "ないす",
    "ないせん",
    "ないそう",
    "なおす",
    "ながい",
    "なくす",
    "なげる",
    "なこうど",
    "なさけ",
    "なたでここ",
    "なっとう",
    "なつやすみ",
    "ななおし",
    "なにごと",
    "なにもの",
    "なにわ",
    "なのか",
    "なふだ",
    "なまいき",
    "なまえ",
    "なまみ",
    "なみだ",
    "なめらか",
    "なめる",
    "なやむ",
    "ならう",
    "ならび",
    "ならぶ",
    "なれる",
    "なわとび",
    "なわばり",
    "にあう",
    "にいがた",
    "にうけ",
    "におい",
    "にかい",
    "にがて",
    "にきび",
    "にくしみ",
    "にくまん",
    "にげる",
    "にさんかたんそ",
    "にしき",
    "にせもの",
    "にちじょう",
    "にちようび",
    "にっか",
    "にっき",
    "にっけい",
    "にっこう",
    "にっさん",
    "にっしょく",
    "にっすう",
    "にっせき",
    "にってい",
    "になう",
    "にほん",
    "にまめ",
    "にもつ",
    "にやり",
    "にゅういん",
    "にりんしゃ",
    "にわとり",
    "にんい",
    "にんか",
    "にんき",
    "にんげん",
    "にんしき",
    "にんずう",
    "にんそう",
    "にんたい",
    "にんち",
    "にんてい",
    "にんにく",
    "にんぷ",
    "にんまり",
    "にんむ",
    "にんめい",
    "にんよう",
    "ぬいくぎ",
    "ぬかす",
    "ぬぐいとる",
    "ぬぐう",
    "ぬくもり",
    "ぬすむ",
    "ぬまえび",
    "ぬめり",
    "ぬらす",
    "ぬんちゃく",
    "ねあげ",
    "ねいき",
    "ねいる",
    "ねいろ",
    "ねぐせ",
    "ねくたい",
    "ねくら",
    "ねこぜ",
    "ねこむ",
    "ねさげ",
    "ねすごす",
    "ねそべる",
    "ねだん",
    "ねつい",
    "ねっしん",
    "ねつぞう",
    "ねったいぎょ",
    "ねぶそく",
    "ねふだ",
    "ねぼう",
    "ねほりはほり",
    "ねまき",
    "ねまわし",
    "ねみみ",
    "ねむい",
    "ねむたい",
    "ねもと",
    "ねらう",
    "ねわざ",
    "ねんいり",
    "ねんおし",
    "ねんかん",
    "ねんきん",
    "ねんぐ",
    "ねんざ",
    "ねんし",
    "ねんちゃく",
    "ねんど",
    "ねんぴ",
    "ねんぶつ",
    "ねんまつ",
    "ねんりょう",
    "ねんれい",
    "のいず",
    "のおづま",
    "のがす",
    "のきなみ",
    "のこぎり",
    "のこす",
    "のこる",
    "のせる",
    "のぞく",
    "のぞむ",
    "のたまう",
    "のちほど",
    "のっく",
    "のばす",
    "のはら",
    "のべる",
    "のぼる",
    "のみもの",
    "のやま",
    "のらいぬ",
    "のらねこ",
    "のりもの",
    "のりゆき",
    "のれん",
    "のんき",
    "ばあい",
    "はあく",
    "ばあさん",
    "ばいか",
    "ばいく",
    "はいけん",
    "はいご",
    "はいしん",
    "はいすい",
    "はいせん",
    "はいそう",
    "はいち",
    "ばいばい",
    "はいれつ",
    "はえる",
    "はおる",
    "はかい",
    "ばかり",
    "はかる",
    "はくしゅ",
    "はけん",
    "はこぶ",
    "はさみ",
    "はさん",
    "はしご",
    "ばしょ",
    "はしる",
    "はせる",
    "ぱそこん",
    "はそん",
    "はたん",
    "はちみつ",
    "はつおん",
    "はっかく",
    "はづき",
    "はっきり",
    "はっくつ",
    "はっけん",
    "はっこう",
    "はっさん",
    "はっしん",
    "はったつ",
    "はっちゅう",
    "はってん",
    "はっぴょう",
    "はっぽう",
    "はなす",
    "はなび",
    "はにかむ",
    "はぶらし",
    "はみがき",
    "はむかう",
    "はめつ",
    "はやい",
    "はやし",
    "はらう",
    "はろうぃん",
    "はわい",
    "はんい",
    "はんえい",
    "はんおん",
    "はんかく",
    "はんきょう",
    "ばんぐみ",
    "はんこ",
    "はんしゃ",
    "はんすう",
    "はんだん",
    "ぱんち",
    "ぱんつ",
    "はんてい",
    "はんとし",
    "はんのう",
    "はんぱ",
    "はんぶん",
    "はんぺん",
    "はんぼうき",
    "はんめい",
    "はんらん",
    "はんろん",
    "ひいき",
    "ひうん",
    "ひえる",
    "ひかく",
    "ひかり",
    "ひかる",
    "ひかん",
    "ひくい",
    "ひけつ",
    "ひこうき",
    "ひこく",
    "ひさい",
    "ひさしぶり",
    "ひさん",
    "びじゅつかん",
    "ひしょ",
    "ひそか",
    "ひそむ",
    "ひたむき",
    "ひだり",
    "ひたる",
    "ひつぎ",
    "ひっこし",
    "ひっし",
    "ひつじゅひん",
    "ひっす",
    "ひつぜん",
    "ぴったり",
    "ぴっちり",
    "ひつよう",
    "ひてい",
    "ひとごみ",
    "ひなまつり",
    "ひなん",
    "ひねる",
    "ひはん",
    "ひびく",
    "ひひょう",
    "ひほう",
    "ひまわり",
    "ひまん",
    "ひみつ",
    "ひめい",
    "ひめじし",
    "ひやけ",
    "ひやす",
    "ひよう",
    "びょうき",
    "ひらがな",
    "ひらく",
    "ひりつ",
    "ひりょう",
    "ひるま",
    "ひるやすみ",
    "ひれい",
    "ひろい",
    "ひろう",
    "ひろき",
    "ひろゆき",
    "ひんかく",
    "ひんけつ",
    "ひんこん",
    "ひんしゅ",
    "ひんそう",
    "ぴんち",
    "ひんぱん",
    "びんぼう",
    "ふあん",
    "ふいうち",
    "ふうけい",
    "ふうせん",
    "ぷうたろう",
    "ふうとう",
    "ふうふ",
    "ふえる",
    "ふおん",
    "ふかい",
    "ふきん",
    "ふくざつ",
    "ふくぶくろ",
    "ふこう",
    "ふさい",
    "ふしぎ",
    "ふじみ",
    "ふすま",
    "ふせい",
    "ふせぐ",
    "ふそく",
    "ぶたにく",
    "ふたん",
    "ふちょう",
    "ふつう",
    "ふつか",
    "ふっかつ",
    "ふっき",
    "ふっこく",
    "ぶどう",
    "ふとる",
    "ふとん",
    "ふのう",
    "ふはい",
    "ふひょう",
    "ふへん",
    "ふまん",
    "ふみん",
    "ふめつ",
    "ふめん",
    "ふよう",
    "ふりこ",
    "ふりる",
    "ふるい",
    "ふんいき",
    "ぶんがく",
    "ぶんぐ",
    "ふんしつ",
    "ぶんせき",
    "ふんそう",
    "ぶんぽう",
    "へいあん",
    "へいおん",
    "へいがい",
    "へいき",
    "へいげん",
    "へいこう",
    "へいさ",
    "へいしゃ",
    "へいせつ",
    "へいそ",
    "へいたく",
    "へいてん",
    "へいねつ",
    "へいわ",
    "へきが",
    "へこむ",
    "べにいろ",
    "べにしょうが",
    "へらす",
    "へんかん",
    "べんきょう",
    "べんごし",
    "へんさい",
    "へんたい",
    "べんり",
    "ほあん",
    "ほいく",
    "ぼうぎょ",
    "ほうこく",
    "ほうそう",
    "ほうほう",
    "ほうもん",
    "ほうりつ",
    "ほえる",
    "ほおん",
    "ほかん",
    "ほきょう",
    "ぼきん",
    "ほくろ",
    "ほけつ",
    "ほけん",
    "ほこう",
    "ほこる",
    "ほしい",
    "ほしつ",
    "ほしゅ",
    "ほしょう",
    "ほせい",
    "ほそい",
    "ほそく",
    "ほたて",
    "ほたる",
    "ぽちぶくろ",
    "ほっきょく",
    "ほっさ",
    "ほったん",
    "ほとんど",
    "ほめる",
    "ほんい",
    "ほんき",
    "ほんけ",
    "ほんしつ",
    "ほんやく",
    "まいにち",
    "まかい",
    "まかせる",
    "まがる",
    "まける",
    "まこと",
    "まさつ",
    "まじめ",
    "ますく",
    "まぜる",
    "まつり",
    "まとめ",
    "まなぶ",
    "まぬけ",
    "まねく",
    "まほう",
    "まもる",
    "まゆげ",
    "まよう",
    "まろやか",
    "まわす",
    "まわり",
    "まわる",
    "まんが",
    "まんきつ",
    "まんぞく",
    "まんなか",
    "みいら",
    "みうち",
    "みえる",
    "みがく",
    "みかた",
    "みかん",
    "みけん",
    "みこん",
    "みじかい",
    "みすい",
    "みすえる",
    "みせる",
    "みっか",
    "みつかる",
    "みつける",
    "みてい",
    "みとめる",
    "みなと",
    "みなみかさい",
    "みねらる",
    "みのう",
    "みのがす",
    "みほん",
    "みもと",
    "みやげ",
    "みらい",
    "みりょく",
    "みわく",
    "みんか",
    "みんぞく",
    "むいか",
    "むえき",
    "むえん",
    "むかい",
    "むかう",
    "むかえ",
    "むかし",
    "むぎちゃ",
    "むける",
    "むげん",
    "むさぼる",
    "むしあつい",
    "むしば",
    "むじゅん",
    "むしろ",
    "むすう",
    "むすこ",
    "むすぶ",
    "むすめ",
    "むせる",
    "むせん",
    "むちゅう",
    "むなしい",
    "むのう",
    "むやみ",
    "むよう",
    "むらさき",
    "むりょう",
    "むろん",
    "めいあん",
    "めいうん",
    "めいえん",
    "めいかく",
    "めいきょく",
    "めいさい",
    "めいし",
    "めいそう",
    "めいぶつ",
    "めいれい",
    "めいわく",
    "めぐまれる",
    "めざす",
    "めした",
    "めずらしい",
    "めだつ",
    "めまい",
    "めやす",
    "めんきょ",
    "めんせき",
    "めんどう",
    "もうしあげる",
    "もうどうけん",
    "もえる",
    "もくし",
    "もくてき",
    "もくようび",
    "もちろん",
    "もどる",
    "もらう",
    "もんく",
    "もんだい",
    "やおや",
    "やける",
    "やさい",
    "やさしい",
    "やすい",
    "やすたろう",
    "やすみ",
    "やせる",
    "やそう",
    "やたい",
    "やちん",
    "やっと",
    "やっぱり",
    "やぶる",
    "やめる",
    "ややこしい",
    "やよい",
    "やわらかい",
    "ゆうき",
    "ゆうびんきょく",
    "ゆうべ",
    "ゆうめい",
    "ゆけつ",
    "ゆしゅつ",
    "ゆせん",
    "ゆそう",
    "ゆたか",
    "ゆちゃく",
    "ゆでる",
    "ゆにゅう",
    "ゆびわ",
    "ゆらい",
    "ゆれる",
    "ようい",
    "ようか",
    "ようきゅう",
    "ようじ",
    "ようす",
    "ようちえん",
    "よかぜ",
    "よかん",
    "よきん",
    "よくせい",
    "よくぼう",
    "よけい",
    "よごれる",
    "よさん",
    "よしゅう",
    "よそう",
    "よそく",
    "よっか",
    "よてい",
    "よどがわく",
    "よねつ",
    "よやく",
    "よゆう",
    "よろこぶ",
    "よろしい",
    "らいう",
    "らくがき",
    "らくご",
    "らくさつ",
    "らくだ",
    "らしんばん",
    "らせん",
    "らぞく",
    "らたい",
    "らっか",
    "られつ",
    "りえき",
    "りかい",
    "りきさく",
    "りきせつ",
    "りくぐん",
    "りくつ",
    "りけん",
    "りこう",
    "りせい",
    "りそう",
    "りそく",
    "りてん",
    "りねん",
    "りゆう",
    "りゅうがく",
    "りよう",
    "りょうり",
    "りょかん",
    "りょくちゃ",
    "りょこう",
    "りりく",
    "りれき",
    "りろん",
    "りんご",
    "るいけい",
    "るいさい",
    "るいじ",
    "るいせき",
    "るすばん",
    "るりがわら",
    "れいかん",
    "れいぎ",
    "れいせい",
    "れいぞうこ",
    "れいとう",
    "れいぼう",
    "れきし",
    "れきだい",
    "れんあい",
    "れんけい",
    "れんこん",
    "れんさい",
    "れんしゅう",
    "れんぞく",
    "れんらく",
    "ろうか",
    "ろうご",
    "ろうじん",
    "ろうそく",
    "ろくが",
    "ろこつ",
    "ろじうら",
    "ろしゅつ",
    "ろせん",
    "ろてん",
    "ろめん",
    "ろれつ",
    "ろんぎ",
    "ろんぱ",
    "ろんぶん",
    "ろんり",
    "わかす",
    "わかめ",
    "わかやま",
    "わかれる",
    "わしつ",
    "わじまし",
    "わすれもの",
    "わらう",
    "われる"
  ]), i0;
}
var n0, v2;
function Hg() {
  return v2 || (v2 = 1, n0 = [
    "ábaco",
    "abdomen",
    "abeja",
    "abierto",
    "abogado",
    "abono",
    "aborto",
    "abrazo",
    "abrir",
    "abuelo",
    "abuso",
    "acabar",
    "academia",
    "acceso",
    "acción",
    "aceite",
    "acelga",
    "acento",
    "aceptar",
    "ácido",
    "aclarar",
    "acné",
    "acoger",
    "acoso",
    "activo",
    "acto",
    "actriz",
    "actuar",
    "acudir",
    "acuerdo",
    "acusar",
    "adicto",
    "admitir",
    "adoptar",
    "adorno",
    "aduana",
    "adulto",
    "aéreo",
    "afectar",
    "afición",
    "afinar",
    "afirmar",
    "ágil",
    "agitar",
    "agonía",
    "agosto",
    "agotar",
    "agregar",
    "agrio",
    "agua",
    "agudo",
    "águila",
    "aguja",
    "ahogo",
    "ahorro",
    "aire",
    "aislar",
    "ajedrez",
    "ajeno",
    "ajuste",
    "alacrán",
    "alambre",
    "alarma",
    "alba",
    "álbum",
    "alcalde",
    "aldea",
    "alegre",
    "alejar",
    "alerta",
    "aleta",
    "alfiler",
    "alga",
    "algodón",
    "aliado",
    "aliento",
    "alivio",
    "alma",
    "almeja",
    "almíbar",
    "altar",
    "alteza",
    "altivo",
    "alto",
    "altura",
    "alumno",
    "alzar",
    "amable",
    "amante",
    "amapola",
    "amargo",
    "amasar",
    "ámbar",
    "ámbito",
    "ameno",
    "amigo",
    "amistad",
    "amor",
    "amparo",
    "amplio",
    "ancho",
    "anciano",
    "ancla",
    "andar",
    "andén",
    "anemia",
    "ángulo",
    "anillo",
    "ánimo",
    "anís",
    "anotar",
    "antena",
    "antiguo",
    "antojo",
    "anual",
    "anular",
    "anuncio",
    "añadir",
    "añejo",
    "año",
    "apagar",
    "aparato",
    "apetito",
    "apio",
    "aplicar",
    "apodo",
    "aporte",
    "apoyo",
    "aprender",
    "aprobar",
    "apuesta",
    "apuro",
    "arado",
    "araña",
    "arar",
    "árbitro",
    "árbol",
    "arbusto",
    "archivo",
    "arco",
    "arder",
    "ardilla",
    "arduo",
    "área",
    "árido",
    "aries",
    "armonía",
    "arnés",
    "aroma",
    "arpa",
    "arpón",
    "arreglo",
    "arroz",
    "arruga",
    "arte",
    "artista",
    "asa",
    "asado",
    "asalto",
    "ascenso",
    "asegurar",
    "aseo",
    "asesor",
    "asiento",
    "asilo",
    "asistir",
    "asno",
    "asombro",
    "áspero",
    "astilla",
    "astro",
    "astuto",
    "asumir",
    "asunto",
    "atajo",
    "ataque",
    "atar",
    "atento",
    "ateo",
    "ático",
    "atleta",
    "átomo",
    "atraer",
    "atroz",
    "atún",
    "audaz",
    "audio",
    "auge",
    "aula",
    "aumento",
    "ausente",
    "autor",
    "aval",
    "avance",
    "avaro",
    "ave",
    "avellana",
    "avena",
    "avestruz",
    "avión",
    "aviso",
    "ayer",
    "ayuda",
    "ayuno",
    "azafrán",
    "azar",
    "azote",
    "azúcar",
    "azufre",
    "azul",
    "baba",
    "babor",
    "bache",
    "bahía",
    "baile",
    "bajar",
    "balanza",
    "balcón",
    "balde",
    "bambú",
    "banco",
    "banda",
    "baño",
    "barba",
    "barco",
    "barniz",
    "barro",
    "báscula",
    "bastón",
    "basura",
    "batalla",
    "batería",
    "batir",
    "batuta",
    "baúl",
    "bazar",
    "bebé",
    "bebida",
    "bello",
    "besar",
    "beso",
    "bestia",
    "bicho",
    "bien",
    "bingo",
    "blanco",
    "bloque",
    "blusa",
    "boa",
    "bobina",
    "bobo",
    "boca",
    "bocina",
    "boda",
    "bodega",
    "boina",
    "bola",
    "bolero",
    "bolsa",
    "bomba",
    "bondad",
    "bonito",
    "bono",
    "bonsái",
    "borde",
    "borrar",
    "bosque",
    "bote",
    "botín",
    "bóveda",
    "bozal",
    "bravo",
    "brazo",
    "brecha",
    "breve",
    "brillo",
    "brinco",
    "brisa",
    "broca",
    "broma",
    "bronce",
    "brote",
    "bruja",
    "brusco",
    "bruto",
    "buceo",
    "bucle",
    "bueno",
    "buey",
    "bufanda",
    "bufón",
    "búho",
    "buitre",
    "bulto",
    "burbuja",
    "burla",
    "burro",
    "buscar",
    "butaca",
    "buzón",
    "caballo",
    "cabeza",
    "cabina",
    "cabra",
    "cacao",
    "cadáver",
    "cadena",
    "caer",
    "café",
    "caída",
    "caimán",
    "caja",
    "cajón",
    "cal",
    "calamar",
    "calcio",
    "caldo",
    "calidad",
    "calle",
    "calma",
    "calor",
    "calvo",
    "cama",
    "cambio",
    "camello",
    "camino",
    "campo",
    "cáncer",
    "candil",
    "canela",
    "canguro",
    "canica",
    "canto",
    "caña",
    "cañón",
    "caoba",
    "caos",
    "capaz",
    "capitán",
    "capote",
    "captar",
    "capucha",
    "cara",
    "carbón",
    "cárcel",
    "careta",
    "carga",
    "cariño",
    "carne",
    "carpeta",
    "carro",
    "carta",
    "casa",
    "casco",
    "casero",
    "caspa",
    "castor",
    "catorce",
    "catre",
    "caudal",
    "causa",
    "cazo",
    "cebolla",
    "ceder",
    "cedro",
    "celda",
    "célebre",
    "celoso",
    "célula",
    "cemento",
    "ceniza",
    "centro",
    "cerca",
    "cerdo",
    "cereza",
    "cero",
    "cerrar",
    "certeza",
    "césped",
    "cetro",
    "chacal",
    "chaleco",
    "champú",
    "chancla",
    "chapa",
    "charla",
    "chico",
    "chiste",
    "chivo",
    "choque",
    "choza",
    "chuleta",
    "chupar",
    "ciclón",
    "ciego",
    "cielo",
    "cien",
    "cierto",
    "cifra",
    "cigarro",
    "cima",
    "cinco",
    "cine",
    "cinta",
    "ciprés",
    "circo",
    "ciruela",
    "cisne",
    "cita",
    "ciudad",
    "clamor",
    "clan",
    "claro",
    "clase",
    "clave",
    "cliente",
    "clima",
    "clínica",
    "cobre",
    "cocción",
    "cochino",
    "cocina",
    "coco",
    "código",
    "codo",
    "cofre",
    "coger",
    "cohete",
    "cojín",
    "cojo",
    "cola",
    "colcha",
    "colegio",
    "colgar",
    "colina",
    "collar",
    "colmo",
    "columna",
    "combate",
    "comer",
    "comida",
    "cómodo",
    "compra",
    "conde",
    "conejo",
    "conga",
    "conocer",
    "consejo",
    "contar",
    "copa",
    "copia",
    "corazón",
    "corbata",
    "corcho",
    "cordón",
    "corona",
    "correr",
    "coser",
    "cosmos",
    "costa",
    "cráneo",
    "cráter",
    "crear",
    "crecer",
    "creído",
    "crema",
    "cría",
    "crimen",
    "cripta",
    "crisis",
    "cromo",
    "crónica",
    "croqueta",
    "crudo",
    "cruz",
    "cuadro",
    "cuarto",
    "cuatro",
    "cubo",
    "cubrir",
    "cuchara",
    "cuello",
    "cuento",
    "cuerda",
    "cuesta",
    "cueva",
    "cuidar",
    "culebra",
    "culpa",
    "culto",
    "cumbre",
    "cumplir",
    "cuna",
    "cuneta",
    "cuota",
    "cupón",
    "cúpula",
    "curar",
    "curioso",
    "curso",
    "curva",
    "cutis",
    "dama",
    "danza",
    "dar",
    "dardo",
    "dátil",
    "deber",
    "débil",
    "década",
    "decir",
    "dedo",
    "defensa",
    "definir",
    "dejar",
    "delfín",
    "delgado",
    "delito",
    "demora",
    "denso",
    "dental",
    "deporte",
    "derecho",
    "derrota",
    "desayuno",
    "deseo",
    "desfile",
    "desnudo",
    "destino",
    "desvío",
    "detalle",
    "detener",
    "deuda",
    "día",
    "diablo",
    "diadema",
    "diamante",
    "diana",
    "diario",
    "dibujo",
    "dictar",
    "diente",
    "dieta",
    "diez",
    "difícil",
    "digno",
    "dilema",
    "diluir",
    "dinero",
    "directo",
    "dirigir",
    "disco",
    "diseño",
    "disfraz",
    "diva",
    "divino",
    "doble",
    "doce",
    "dolor",
    "domingo",
    "don",
    "donar",
    "dorado",
    "dormir",
    "dorso",
    "dos",
    "dosis",
    "dragón",
    "droga",
    "ducha",
    "duda",
    "duelo",
    "dueño",
    "dulce",
    "dúo",
    "duque",
    "durar",
    "dureza",
    "duro",
    "ébano",
    "ebrio",
    "echar",
    "eco",
    "ecuador",
    "edad",
    "edición",
    "edificio",
    "editor",
    "educar",
    "efecto",
    "eficaz",
    "eje",
    "ejemplo",
    "elefante",
    "elegir",
    "elemento",
    "elevar",
    "elipse",
    "élite",
    "elixir",
    "elogio",
    "eludir",
    "embudo",
    "emitir",
    "emoción",
    "empate",
    "empeño",
    "empleo",
    "empresa",
    "enano",
    "encargo",
    "enchufe",
    "encía",
    "enemigo",
    "enero",
    "enfado",
    "enfermo",
    "engaño",
    "enigma",
    "enlace",
    "enorme",
    "enredo",
    "ensayo",
    "enseñar",
    "entero",
    "entrar",
    "envase",
    "envío",
    "época",
    "equipo",
    "erizo",
    "escala",
    "escena",
    "escolar",
    "escribir",
    "escudo",
    "esencia",
    "esfera",
    "esfuerzo",
    "espada",
    "espejo",
    "espía",
    "esposa",
    "espuma",
    "esquí",
    "estar",
    "este",
    "estilo",
    "estufa",
    "etapa",
    "eterno",
    "ética",
    "etnia",
    "evadir",
    "evaluar",
    "evento",
    "evitar",
    "exacto",
    "examen",
    "exceso",
    "excusa",
    "exento",
    "exigir",
    "exilio",
    "existir",
    "éxito",
    "experto",
    "explicar",
    "exponer",
    "extremo",
    "fábrica",
    "fábula",
    "fachada",
    "fácil",
    "factor",
    "faena",
    "faja",
    "falda",
    "fallo",
    "falso",
    "faltar",
    "fama",
    "familia",
    "famoso",
    "faraón",
    "farmacia",
    "farol",
    "farsa",
    "fase",
    "fatiga",
    "fauna",
    "favor",
    "fax",
    "febrero",
    "fecha",
    "feliz",
    "feo",
    "feria",
    "feroz",
    "fértil",
    "fervor",
    "festín",
    "fiable",
    "fianza",
    "fiar",
    "fibra",
    "ficción",
    "ficha",
    "fideo",
    "fiebre",
    "fiel",
    "fiera",
    "fiesta",
    "figura",
    "fijar",
    "fijo",
    "fila",
    "filete",
    "filial",
    "filtro",
    "fin",
    "finca",
    "fingir",
    "finito",
    "firma",
    "flaco",
    "flauta",
    "flecha",
    "flor",
    "flota",
    "fluir",
    "flujo",
    "flúor",
    "fobia",
    "foca",
    "fogata",
    "fogón",
    "folio",
    "folleto",
    "fondo",
    "forma",
    "forro",
    "fortuna",
    "forzar",
    "fosa",
    "foto",
    "fracaso",
    "frágil",
    "franja",
    "frase",
    "fraude",
    "freír",
    "freno",
    "fresa",
    "frío",
    "frito",
    "fruta",
    "fuego",
    "fuente",
    "fuerza",
    "fuga",
    "fumar",
    "función",
    "funda",
    "furgón",
    "furia",
    "fusil",
    "fútbol",
    "futuro",
    "gacela",
    "gafas",
    "gaita",
    "gajo",
    "gala",
    "galería",
    "gallo",
    "gamba",
    "ganar",
    "gancho",
    "ganga",
    "ganso",
    "garaje",
    "garza",
    "gasolina",
    "gastar",
    "gato",
    "gavilán",
    "gemelo",
    "gemir",
    "gen",
    "género",
    "genio",
    "gente",
    "geranio",
    "gerente",
    "germen",
    "gesto",
    "gigante",
    "gimnasio",
    "girar",
    "giro",
    "glaciar",
    "globo",
    "gloria",
    "gol",
    "golfo",
    "goloso",
    "golpe",
    "goma",
    "gordo",
    "gorila",
    "gorra",
    "gota",
    "goteo",
    "gozar",
    "grada",
    "gráfico",
    "grano",
    "grasa",
    "gratis",
    "grave",
    "grieta",
    "grillo",
    "gripe",
    "gris",
    "grito",
    "grosor",
    "grúa",
    "grueso",
    "grumo",
    "grupo",
    "guante",
    "guapo",
    "guardia",
    "guerra",
    "guía",
    "guiño",
    "guion",
    "guiso",
    "guitarra",
    "gusano",
    "gustar",
    "haber",
    "hábil",
    "hablar",
    "hacer",
    "hacha",
    "hada",
    "hallar",
    "hamaca",
    "harina",
    "haz",
    "hazaña",
    "hebilla",
    "hebra",
    "hecho",
    "helado",
    "helio",
    "hembra",
    "herir",
    "hermano",
    "héroe",
    "hervir",
    "hielo",
    "hierro",
    "hígado",
    "higiene",
    "hijo",
    "himno",
    "historia",
    "hocico",
    "hogar",
    "hoguera",
    "hoja",
    "hombre",
    "hongo",
    "honor",
    "honra",
    "hora",
    "hormiga",
    "horno",
    "hostil",
    "hoyo",
    "hueco",
    "huelga",
    "huerta",
    "hueso",
    "huevo",
    "huida",
    "huir",
    "humano",
    "húmedo",
    "humilde",
    "humo",
    "hundir",
    "huracán",
    "hurto",
    "icono",
    "ideal",
    "idioma",
    "ídolo",
    "iglesia",
    "iglú",
    "igual",
    "ilegal",
    "ilusión",
    "imagen",
    "imán",
    "imitar",
    "impar",
    "imperio",
    "imponer",
    "impulso",
    "incapaz",
    "índice",
    "inerte",
    "infiel",
    "informe",
    "ingenio",
    "inicio",
    "inmenso",
    "inmune",
    "innato",
    "insecto",
    "instante",
    "interés",
    "íntimo",
    "intuir",
    "inútil",
    "invierno",
    "ira",
    "iris",
    "ironía",
    "isla",
    "islote",
    "jabalí",
    "jabón",
    "jamón",
    "jarabe",
    "jardín",
    "jarra",
    "jaula",
    "jazmín",
    "jefe",
    "jeringa",
    "jinete",
    "jornada",
    "joroba",
    "joven",
    "joya",
    "juerga",
    "jueves",
    "juez",
    "jugador",
    "jugo",
    "juguete",
    "juicio",
    "junco",
    "jungla",
    "junio",
    "juntar",
    "júpiter",
    "jurar",
    "justo",
    "juvenil",
    "juzgar",
    "kilo",
    "koala",
    "labio",
    "lacio",
    "lacra",
    "lado",
    "ladrón",
    "lagarto",
    "lágrima",
    "laguna",
    "laico",
    "lamer",
    "lámina",
    "lámpara",
    "lana",
    "lancha",
    "langosta",
    "lanza",
    "lápiz",
    "largo",
    "larva",
    "lástima",
    "lata",
    "látex",
    "latir",
    "laurel",
    "lavar",
    "lazo",
    "leal",
    "lección",
    "leche",
    "lector",
    "leer",
    "legión",
    "legumbre",
    "lejano",
    "lengua",
    "lento",
    "leña",
    "león",
    "leopardo",
    "lesión",
    "letal",
    "letra",
    "leve",
    "leyenda",
    "libertad",
    "libro",
    "licor",
    "líder",
    "lidiar",
    "lienzo",
    "liga",
    "ligero",
    "lima",
    "límite",
    "limón",
    "limpio",
    "lince",
    "lindo",
    "línea",
    "lingote",
    "lino",
    "linterna",
    "líquido",
    "liso",
    "lista",
    "litera",
    "litio",
    "litro",
    "llaga",
    "llama",
    "llanto",
    "llave",
    "llegar",
    "llenar",
    "llevar",
    "llorar",
    "llover",
    "lluvia",
    "lobo",
    "loción",
    "loco",
    "locura",
    "lógica",
    "logro",
    "lombriz",
    "lomo",
    "lonja",
    "lote",
    "lucha",
    "lucir",
    "lugar",
    "lujo",
    "luna",
    "lunes",
    "lupa",
    "lustro",
    "luto",
    "luz",
    "maceta",
    "macho",
    "madera",
    "madre",
    "maduro",
    "maestro",
    "mafia",
    "magia",
    "mago",
    "maíz",
    "maldad",
    "maleta",
    "malla",
    "malo",
    "mamá",
    "mambo",
    "mamut",
    "manco",
    "mando",
    "manejar",
    "manga",
    "maniquí",
    "manjar",
    "mano",
    "manso",
    "manta",
    "mañana",
    "mapa",
    "máquina",
    "mar",
    "marco",
    "marea",
    "marfil",
    "margen",
    "marido",
    "mármol",
    "marrón",
    "martes",
    "marzo",
    "masa",
    "máscara",
    "masivo",
    "matar",
    "materia",
    "matiz",
    "matriz",
    "máximo",
    "mayor",
    "mazorca",
    "mecha",
    "medalla",
    "medio",
    "médula",
    "mejilla",
    "mejor",
    "melena",
    "melón",
    "memoria",
    "menor",
    "mensaje",
    "mente",
    "menú",
    "mercado",
    "merengue",
    "mérito",
    "mes",
    "mesón",
    "meta",
    "meter",
    "método",
    "metro",
    "mezcla",
    "miedo",
    "miel",
    "miembro",
    "miga",
    "mil",
    "milagro",
    "militar",
    "millón",
    "mimo",
    "mina",
    "minero",
    "mínimo",
    "minuto",
    "miope",
    "mirar",
    "misa",
    "miseria",
    "misil",
    "mismo",
    "mitad",
    "mito",
    "mochila",
    "moción",
    "moda",
    "modelo",
    "moho",
    "mojar",
    "molde",
    "moler",
    "molino",
    "momento",
    "momia",
    "monarca",
    "moneda",
    "monja",
    "monto",
    "moño",
    "morada",
    "morder",
    "moreno",
    "morir",
    "morro",
    "morsa",
    "mortal",
    "mosca",
    "mostrar",
    "motivo",
    "mover",
    "móvil",
    "mozo",
    "mucho",
    "mudar",
    "mueble",
    "muela",
    "muerte",
    "muestra",
    "mugre",
    "mujer",
    "mula",
    "muleta",
    "multa",
    "mundo",
    "muñeca",
    "mural",
    "muro",
    "músculo",
    "museo",
    "musgo",
    "música",
    "muslo",
    "nácar",
    "nación",
    "nadar",
    "naipe",
    "naranja",
    "nariz",
    "narrar",
    "nasal",
    "natal",
    "nativo",
    "natural",
    "náusea",
    "naval",
    "nave",
    "navidad",
    "necio",
    "néctar",
    "negar",
    "negocio",
    "negro",
    "neón",
    "nervio",
    "neto",
    "neutro",
    "nevar",
    "nevera",
    "nicho",
    "nido",
    "niebla",
    "nieto",
    "niñez",
    "niño",
    "nítido",
    "nivel",
    "nobleza",
    "noche",
    "nómina",
    "noria",
    "norma",
    "norte",
    "nota",
    "noticia",
    "novato",
    "novela",
    "novio",
    "nube",
    "nuca",
    "núcleo",
    "nudillo",
    "nudo",
    "nuera",
    "nueve",
    "nuez",
    "nulo",
    "número",
    "nutria",
    "oasis",
    "obeso",
    "obispo",
    "objeto",
    "obra",
    "obrero",
    "observar",
    "obtener",
    "obvio",
    "oca",
    "ocaso",
    "océano",
    "ochenta",
    "ocho",
    "ocio",
    "ocre",
    "octavo",
    "octubre",
    "oculto",
    "ocupar",
    "ocurrir",
    "odiar",
    "odio",
    "odisea",
    "oeste",
    "ofensa",
    "oferta",
    "oficio",
    "ofrecer",
    "ogro",
    "oído",
    "oír",
    "ojo",
    "ola",
    "oleada",
    "olfato",
    "olivo",
    "olla",
    "olmo",
    "olor",
    "olvido",
    "ombligo",
    "onda",
    "onza",
    "opaco",
    "opción",
    "ópera",
    "opinar",
    "oponer",
    "optar",
    "óptica",
    "opuesto",
    "oración",
    "orador",
    "oral",
    "órbita",
    "orca",
    "orden",
    "oreja",
    "órgano",
    "orgía",
    "orgullo",
    "oriente",
    "origen",
    "orilla",
    "oro",
    "orquesta",
    "oruga",
    "osadía",
    "oscuro",
    "osezno",
    "oso",
    "ostra",
    "otoño",
    "otro",
    "oveja",
    "óvulo",
    "óxido",
    "oxígeno",
    "oyente",
    "ozono",
    "pacto",
    "padre",
    "paella",
    "página",
    "pago",
    "país",
    "pájaro",
    "palabra",
    "palco",
    "paleta",
    "pálido",
    "palma",
    "paloma",
    "palpar",
    "pan",
    "panal",
    "pánico",
    "pantera",
    "pañuelo",
    "papá",
    "papel",
    "papilla",
    "paquete",
    "parar",
    "parcela",
    "pared",
    "parir",
    "paro",
    "párpado",
    "parque",
    "párrafo",
    "parte",
    "pasar",
    "paseo",
    "pasión",
    "paso",
    "pasta",
    "pata",
    "patio",
    "patria",
    "pausa",
    "pauta",
    "pavo",
    "payaso",
    "peatón",
    "pecado",
    "pecera",
    "pecho",
    "pedal",
    "pedir",
    "pegar",
    "peine",
    "pelar",
    "peldaño",
    "pelea",
    "peligro",
    "pellejo",
    "pelo",
    "peluca",
    "pena",
    "pensar",
    "peñón",
    "peón",
    "peor",
    "pepino",
    "pequeño",
    "pera",
    "percha",
    "perder",
    "pereza",
    "perfil",
    "perico",
    "perla",
    "permiso",
    "perro",
    "persona",
    "pesa",
    "pesca",
    "pésimo",
    "pestaña",
    "pétalo",
    "petróleo",
    "pez",
    "pezuña",
    "picar",
    "pichón",
    "pie",
    "piedra",
    "pierna",
    "pieza",
    "pijama",
    "pilar",
    "piloto",
    "pimienta",
    "pino",
    "pintor",
    "pinza",
    "piña",
    "piojo",
    "pipa",
    "pirata",
    "pisar",
    "piscina",
    "piso",
    "pista",
    "pitón",
    "pizca",
    "placa",
    "plan",
    "plata",
    "playa",
    "plaza",
    "pleito",
    "pleno",
    "plomo",
    "pluma",
    "plural",
    "pobre",
    "poco",
    "poder",
    "podio",
    "poema",
    "poesía",
    "poeta",
    "polen",
    "policía",
    "pollo",
    "polvo",
    "pomada",
    "pomelo",
    "pomo",
    "pompa",
    "poner",
    "porción",
    "portal",
    "posada",
    "poseer",
    "posible",
    "poste",
    "potencia",
    "potro",
    "pozo",
    "prado",
    "precoz",
    "pregunta",
    "premio",
    "prensa",
    "preso",
    "previo",
    "primo",
    "príncipe",
    "prisión",
    "privar",
    "proa",
    "probar",
    "proceso",
    "producto",
    "proeza",
    "profesor",
    "programa",
    "prole",
    "promesa",
    "pronto",
    "propio",
    "próximo",
    "prueba",
    "público",
    "puchero",
    "pudor",
    "pueblo",
    "puerta",
    "puesto",
    "pulga",
    "pulir",
    "pulmón",
    "pulpo",
    "pulso",
    "puma",
    "punto",
    "puñal",
    "puño",
    "pupa",
    "pupila",
    "puré",
    "quedar",
    "queja",
    "quemar",
    "querer",
    "queso",
    "quieto",
    "química",
    "quince",
    "quitar",
    "rábano",
    "rabia",
    "rabo",
    "ración",
    "radical",
    "raíz",
    "rama",
    "rampa",
    "rancho",
    "rango",
    "rapaz",
    "rápido",
    "rapto",
    "rasgo",
    "raspa",
    "rato",
    "rayo",
    "raza",
    "razón",
    "reacción",
    "realidad",
    "rebaño",
    "rebote",
    "recaer",
    "receta",
    "rechazo",
    "recoger",
    "recreo",
    "recto",
    "recurso",
    "red",
    "redondo",
    "reducir",
    "reflejo",
    "reforma",
    "refrán",
    "refugio",
    "regalo",
    "regir",
    "regla",
    "regreso",
    "rehén",
    "reino",
    "reír",
    "reja",
    "relato",
    "relevo",
    "relieve",
    "relleno",
    "reloj",
    "remar",
    "remedio",
    "remo",
    "rencor",
    "rendir",
    "renta",
    "reparto",
    "repetir",
    "reposo",
    "reptil",
    "res",
    "rescate",
    "resina",
    "respeto",
    "resto",
    "resumen",
    "retiro",
    "retorno",
    "retrato",
    "reunir",
    "revés",
    "revista",
    "rey",
    "rezar",
    "rico",
    "riego",
    "rienda",
    "riesgo",
    "rifa",
    "rígido",
    "rigor",
    "rincón",
    "riñón",
    "río",
    "riqueza",
    "risa",
    "ritmo",
    "rito",
    "rizo",
    "roble",
    "roce",
    "rociar",
    "rodar",
    "rodeo",
    "rodilla",
    "roer",
    "rojizo",
    "rojo",
    "romero",
    "romper",
    "ron",
    "ronco",
    "ronda",
    "ropa",
    "ropero",
    "rosa",
    "rosca",
    "rostro",
    "rotar",
    "rubí",
    "rubor",
    "rudo",
    "rueda",
    "rugir",
    "ruido",
    "ruina",
    "ruleta",
    "rulo",
    "rumbo",
    "rumor",
    "ruptura",
    "ruta",
    "rutina",
    "sábado",
    "saber",
    "sabio",
    "sable",
    "sacar",
    "sagaz",
    "sagrado",
    "sala",
    "saldo",
    "salero",
    "salir",
    "salmón",
    "salón",
    "salsa",
    "salto",
    "salud",
    "salvar",
    "samba",
    "sanción",
    "sandía",
    "sanear",
    "sangre",
    "sanidad",
    "sano",
    "santo",
    "sapo",
    "saque",
    "sardina",
    "sartén",
    "sastre",
    "satán",
    "sauna",
    "saxofón",
    "sección",
    "seco",
    "secreto",
    "secta",
    "sed",
    "seguir",
    "seis",
    "sello",
    "selva",
    "semana",
    "semilla",
    "senda",
    "sensor",
    "señal",
    "señor",
    "separar",
    "sepia",
    "sequía",
    "ser",
    "serie",
    "sermón",
    "servir",
    "sesenta",
    "sesión",
    "seta",
    "setenta",
    "severo",
    "sexo",
    "sexto",
    "sidra",
    "siesta",
    "siete",
    "siglo",
    "signo",
    "sílaba",
    "silbar",
    "silencio",
    "silla",
    "símbolo",
    "simio",
    "sirena",
    "sistema",
    "sitio",
    "situar",
    "sobre",
    "socio",
    "sodio",
    "sol",
    "solapa",
    "soldado",
    "soledad",
    "sólido",
    "soltar",
    "solución",
    "sombra",
    "sondeo",
    "sonido",
    "sonoro",
    "sonrisa",
    "sopa",
    "soplar",
    "soporte",
    "sordo",
    "sorpresa",
    "sorteo",
    "sostén",
    "sótano",
    "suave",
    "subir",
    "suceso",
    "sudor",
    "suegra",
    "suelo",
    "sueño",
    "suerte",
    "sufrir",
    "sujeto",
    "sultán",
    "sumar",
    "superar",
    "suplir",
    "suponer",
    "supremo",
    "sur",
    "surco",
    "sureño",
    "surgir",
    "susto",
    "sutil",
    "tabaco",
    "tabique",
    "tabla",
    "tabú",
    "taco",
    "tacto",
    "tajo",
    "talar",
    "talco",
    "talento",
    "talla",
    "talón",
    "tamaño",
    "tambor",
    "tango",
    "tanque",
    "tapa",
    "tapete",
    "tapia",
    "tapón",
    "taquilla",
    "tarde",
    "tarea",
    "tarifa",
    "tarjeta",
    "tarot",
    "tarro",
    "tarta",
    "tatuaje",
    "tauro",
    "taza",
    "tazón",
    "teatro",
    "techo",
    "tecla",
    "técnica",
    "tejado",
    "tejer",
    "tejido",
    "tela",
    "teléfono",
    "tema",
    "temor",
    "templo",
    "tenaz",
    "tender",
    "tener",
    "tenis",
    "tenso",
    "teoría",
    "terapia",
    "terco",
    "término",
    "ternura",
    "terror",
    "tesis",
    "tesoro",
    "testigo",
    "tetera",
    "texto",
    "tez",
    "tibio",
    "tiburón",
    "tiempo",
    "tienda",
    "tierra",
    "tieso",
    "tigre",
    "tijera",
    "tilde",
    "timbre",
    "tímido",
    "timo",
    "tinta",
    "tío",
    "típico",
    "tipo",
    "tira",
    "tirón",
    "titán",
    "títere",
    "título",
    "tiza",
    "toalla",
    "tobillo",
    "tocar",
    "tocino",
    "todo",
    "toga",
    "toldo",
    "tomar",
    "tono",
    "tonto",
    "topar",
    "tope",
    "toque",
    "tórax",
    "torero",
    "tormenta",
    "torneo",
    "toro",
    "torpedo",
    "torre",
    "torso",
    "tortuga",
    "tos",
    "tosco",
    "toser",
    "tóxico",
    "trabajo",
    "tractor",
    "traer",
    "tráfico",
    "trago",
    "traje",
    "tramo",
    "trance",
    "trato",
    "trauma",
    "trazar",
    "trébol",
    "tregua",
    "treinta",
    "tren",
    "trepar",
    "tres",
    "tribu",
    "trigo",
    "tripa",
    "triste",
    "triunfo",
    "trofeo",
    "trompa",
    "tronco",
    "tropa",
    "trote",
    "trozo",
    "truco",
    "trueno",
    "trufa",
    "tubería",
    "tubo",
    "tuerto",
    "tumba",
    "tumor",
    "túnel",
    "túnica",
    "turbina",
    "turismo",
    "turno",
    "tutor",
    "ubicar",
    "úlcera",
    "umbral",
    "unidad",
    "unir",
    "universo",
    "uno",
    "untar",
    "uña",
    "urbano",
    "urbe",
    "urgente",
    "urna",
    "usar",
    "usuario",
    "útil",
    "utopía",
    "uva",
    "vaca",
    "vacío",
    "vacuna",
    "vagar",
    "vago",
    "vaina",
    "vajilla",
    "vale",
    "válido",
    "valle",
    "valor",
    "válvula",
    "vampiro",
    "vara",
    "variar",
    "varón",
    "vaso",
    "vecino",
    "vector",
    "vehículo",
    "veinte",
    "vejez",
    "vela",
    "velero",
    "veloz",
    "vena",
    "vencer",
    "venda",
    "veneno",
    "vengar",
    "venir",
    "venta",
    "venus",
    "ver",
    "verano",
    "verbo",
    "verde",
    "vereda",
    "verja",
    "verso",
    "verter",
    "vía",
    "viaje",
    "vibrar",
    "vicio",
    "víctima",
    "vida",
    "vídeo",
    "vidrio",
    "viejo",
    "viernes",
    "vigor",
    "vil",
    "villa",
    "vinagre",
    "vino",
    "viñedo",
    "violín",
    "viral",
    "virgo",
    "virtud",
    "visor",
    "víspera",
    "vista",
    "vitamina",
    "viudo",
    "vivaz",
    "vivero",
    "vivir",
    "vivo",
    "volcán",
    "volumen",
    "volver",
    "voraz",
    "votar",
    "voto",
    "voz",
    "vuelo",
    "vulgar",
    "yacer",
    "yate",
    "yegua",
    "yema",
    "yerno",
    "yeso",
    "yodo",
    "yoga",
    "yogur",
    "zafiro",
    "zanja",
    "zapato",
    "zarza",
    "zona",
    "zorro",
    "zumo",
    "zurdo"
  ]), n0;
}
/*!
 * wordlist.js - wordlists for bcoin
 * Copyright (c) 2015-2016, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var S2;
function B7() {
  return S2 || (S2 = 1, Wa.get = function(c) {
    switch (c) {
      case "simplified chinese":
        return Tg();
      case "traditional chinese":
        return zg();
      case "english":
        return Cg();
      case "french":
        return Dg();
      case "italian":
        return Ug();
      case "japanese":
        return Fg();
      case "spanish":
        return Hg();
      default:
        throw new Error(`Unknown language: ${c}.`);
    }
  }), Wa;
}
/*!
 * nfkd.js - unicode normalization for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var s0, E2;
function Lg() {
  if (E2) return s0;
  E2 = 1;
  function e(c) {
    return c.normalize("NFKD");
  }
  return s0 = e, s0;
}
/*!
 * mnemonic.js - hd mnemonics for bcoin
 * Copyright (c) 2015-2016, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var o0, I2;
function zl() {
  if (I2) return o0;
  I2 = 1;
  const e = dt, c = Bt, l = br(), w = ao(), m = Hi(), f = Tl(), n = $i(), u = B7(), o = oo(), s = Lg(), { inspectSymbol: i } = cr(), p = /* @__PURE__ */ Object.create(null);
  class g {
    /**
     * Create a mnemonic.
     * @constructor
     * @param {Object} options
     * @param {Number?} options.bit - Bits of entropy (Must
     * be a multiple of 8) (default=128).
     * @param {Buffer?} options.entropy - Entropy bytes. Will
     * be generated with `options.bits` bits of entropy
     * if not present.
     * @param {String?} options.phrase - Mnemonic phrase (will
     * be generated if not present).
     * @param {String?} options.language - Language.
     */
    constructor(b) {
      this.bits = o.MIN_ENTROPY, this.language = "english", this.entropy = null, this.phrase = null, b && this.fromOptions(b);
    }
    /**
     * Inject properties from options object.
     * @private
     * @param {Object} options
     */
    fromOptions(b) {
      return typeof b == "string" && (b = { phrase: b }), b.bits != null && (e((b.bits & 65535) === b.bits), e(b.bits >= o.MIN_ENTROPY), e(b.bits <= o.MAX_ENTROPY), e(b.bits % 32 === 0), this.bits = b.bits), b.language && (e(typeof b.language == "string"), e(g.languages.indexOf(b.language) !== -1), this.language = b.language), b.phrase ? (this.fromPhrase(b.phrase), this) : b.entropy ? (this.fromEntropy(b.entropy), this) : this;
    }
    /**
     * Instantiate mnemonic from options.
     * @param {Object} options
     * @returns {Mnemonic}
     */
    static fromOptions(b) {
      return new this().fromOptions(b);
    }
    /**
     * Destroy the mnemonic (zeroes entropy).
     */
    destroy() {
      this.bits = o.MIN_ENTROPY, this.language = "english", this.entropy && (w(this.entropy), this.entropy = null), this.phrase = null;
    }
    /**
     * Generate the seed.
     * @param {String?} passphrase
     * @returns {Buffer} pbkdf2 seed.
     */
    toSeed(b) {
      b || (b = "");
      const h = s(this.getPhrase()), a = s(`mnemonic${b}`);
      return f.derive(
        n,
        k.from(h, "utf8"),
        k.from(a, "utf8"),
        2048,
        64
      );
    }
    /**
     * Get or generate entropy.
     * @returns {Buffer}
     */
    getEntropy() {
      return this.entropy || (this.entropy = m.randomBytes(this.bits / 8)), e(this.bits / 8 === this.entropy.length), this.entropy;
    }
    /**
     * Generate a mnemonic phrase from chosen language.
     * @returns {String}
     */
    getPhrase() {
      if (this.phrase)
        return this.phrase;
      const b = this.bits + this.bits / 32, h = this.getEntropy(), a = l.digest(h), E = Math.ceil(b / 8), H = k.allocUnsafe(E);
      h.copy(H, 0), a.copy(H, h.length);
      const j = g.getWordlist(this.language);
      let G = [];
      for (let N = 0; N < b / 11; N++) {
        let T = 0;
        for (let A = 0; A < 11; A++) {
          const q = N * 11 + A, _ = q % 8, F = (q - _) / 8;
          T <<= 1, T |= H[F] >>> 7 - _ & 1;
        }
        G.push(j.words[T]);
      }
      return this.language === "japanese" ? G = G.join("　") : G = G.join(" "), this.phrase = G, G;
    }
    /**
     * Inject properties from phrase.
     * @private
     * @param {String} phrase
     */
    fromPhrase(b) {
      e(typeof b == "string"), e(b.length <= 1e3);
      const h = b.trim().split(/[\s\u3000]+/), a = h.length * 11, E = a % 32;
      e(E !== 0, "Invalid checksum.");
      const H = a - E;
      e(H >= o.MIN_ENTROPY), e(H <= o.MAX_ENTROPY), e(H % 32 === 0);
      const j = Math.ceil(a / 8), G = k.allocUnsafe(j);
      G.fill(0);
      const N = g.getLanguage(h[0]), T = g.getWordlist(N);
      for (let R = 0; R < h.length; R++) {
        const L = h[R], fe = T.map[L];
        if (fe == null)
          throw new Error("Could not find word.");
        for (let ue = 0; ue < 11; ue++) {
          const ae = R * 11 + ue, D = ae % 8, Q = (ae - D) / 8, W = fe >>> 10 - ue & 1;
          G[Q] |= W << 7 - D;
        }
      }
      const A = Math.ceil(E / 8), q = G.slice(0, G.length - A), _ = G.slice(G.length - A), F = l.digest(q);
      for (let R = 0; R < E; R++) {
        const L = R % 8, fe = (R - L) / 8, ue = _[fe] >>> 7 - L & 1, ae = F[fe] >>> 7 - L & 1;
        if (ue !== ae)
          throw new Error("Invalid checksum.");
      }
      return e(H / 8 === q.length), this.bits = H, this.language = N, this.entropy = q, this.phrase = b, this;
    }
    /**
     * Instantiate mnemonic from a phrase (validates checksum).
     * @param {String} phrase
     * @returns {Mnemonic}
     * @throws on bad checksum
     */
    static fromPhrase(b) {
      return new this().fromPhrase(b);
    }
    /**
     * Inject properties from entropy.
     * @private
     * @param {Buffer} entropy
     * @param {String?} lang
     */
    fromEntropy(b, h) {
      return e(k.isBuffer(b)), e(b.length * 8 >= o.MIN_ENTROPY), e(b.length * 8 <= o.MAX_ENTROPY), e(b.length * 8 % 32 === 0), e(!h || g.languages.indexOf(h) !== -1), this.entropy = b, this.bits = b.length * 8, h && (this.language = h), this;
    }
    /**
     * Instantiate mnemonic from entropy.
     * @param {Buffer} entropy
     * @param {String?} lang
     * @returns {Mnemonic}
     */
    static fromEntropy(b, h) {
      return new this().fromEntropy(b, h);
    }
    /**
     * Determine a single word's language.
     * @param {String} word
     * @returns {String} Language.
     * @throws on not found.
     */
    static getLanguage(b) {
      for (const h of g.languages)
        if (g.getWordlist(h).map[b] != null)
          return h;
      throw new Error("Could not determine language.");
    }
    /**
     * Retrieve the wordlist for a language.
     * @param {String} lang
     * @returns {Object}
     */
    static getWordlist(b) {
      const h = p[b];
      if (h)
        return h;
      const a = u.get(b), E = new S(a);
      return p[b] = E, E;
    }
    /**
     * Convert mnemonic to a json-friendly object.
     * @returns {Object}
     */
    toJSON() {
      return {
        bits: this.bits,
        language: this.language,
        entropy: this.getEntropy().toString("hex"),
        phrase: this.getPhrase()
      };
    }
    /**
     * Inject properties from json object.
     * @private
     * @param {Object} json
     */
    fromJSON(b) {
      return e(b), e((b.bits & 65535) === b.bits), e(typeof b.language == "string"), e(typeof b.entropy == "string"), e(typeof b.phrase == "string"), e(b.bits >= o.MIN_ENTROPY), e(b.bits <= o.MAX_ENTROPY), e(b.bits % 32 === 0), e(b.bits / 8 === b.entropy.length / 2), this.bits = b.bits, this.language = b.language, this.entropy = k.from(b.entropy, "hex"), this.phrase = b.phrase, this;
    }
    /**
     * Instantiate mnemonic from json object.
     * @param {Object} json
     * @returns {Mnemonic}
     */
    static fromJSON(b) {
      return new this().fromJSON(b);
    }
    /**
     * Calculate serialization size.
     * @returns {Number}
     */
    getSize() {
      let b = 0;
      return b += 3, b += this.getEntropy().length, b;
    }
    /**
     * Write the mnemonic to a buffer writer.
     * @params {BufferWriter} bw
     */
    toWriter(b) {
      const h = g.languages.indexOf(this.language);
      return e(h !== -1), b.writeU16(this.bits), b.writeU8(h), b.writeBytes(this.getEntropy()), b;
    }
    /**
     * Serialize mnemonic.
     * @returns {Buffer}
     */
    toRaw(b) {
      const h = this.getSize();
      return this.toWriter(c.write(h)).render();
    }
    /**
     * Inject properties from buffer reader.
     * @private
     * @param {BufferReader} br
     */
    fromReader(b) {
      const h = b.readU16();
      e(h >= o.MIN_ENTROPY), e(h <= o.MAX_ENTROPY), e(h % 32 === 0);
      const a = g.languages[b.readU8()];
      return e(a), this.bits = h, this.language = a, this.entropy = b.readBytes(h / 8), this;
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     */
    fromRaw(b) {
      return this.fromReader(c.read(b));
    }
    /**
     * Instantiate mnemonic from buffer reader.
     * @param {BufferReader} br
     * @returns {Mnemonic}
     */
    static fromReader(b) {
      return new this().fromReader(b);
    }
    /**
     * Instantiate mnemonic from serialized data.
     * @param {Buffer} data
     * @returns {Mnemonic}
     */
    static fromRaw(b) {
      return new this().fromRaw(b);
    }
    /**
     * Convert the mnemonic to a string.
     * @returns {String}
     */
    toString() {
      return this.getPhrase();
    }
    /**
     * Inspect the mnemonic.
     * @returns {String}
     */
    [i]() {
      return `<Mnemonic: ${this.getPhrase()}>`;
    }
    /**
     * Test whether an object is a Mnemonic.
     * @param {Object} obj
     * @returns {Boolean}
     */
    static isMnemonic(b) {
      return b instanceof g;
    }
  }
  g.languages = [
    "simplified chinese",
    "traditional chinese",
    "english",
    "french",
    "italian",
    "japanese",
    "spanish"
  ];
  class S {
    /**
     * Create word list.
     * @constructor
     * @ignore
     * @param {Array} words
     */
    constructor(b) {
      this.words = b, this.map = /* @__PURE__ */ Object.create(null);
      for (let h = 0; h < b.length; h++) {
        const a = b[h];
        this.map[a] = h;
      }
    }
  }
  return o0 = g, o0;
}
/*!
 * public.js - hd public keys for bcoin
 * Copyright (c) 2015-2016, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var a0, A2;
function Cl() {
  if (A2) return a0;
  A2 = 1;
  const e = dt, c = Bt, { base58: l } = Ys, w = $i(), m = wn(), f = qr(), n = ao(), u = Yr(), o = Tr(), s = Xt(), i = oo();
  class p {
    /**
     * Create an HD public key.
     * @constructor
     * @param {Object|Base58String} options
     * @param {Base58String?} options.xkey - Serialized base58 key.
     * @param {Number?} options.depth
     * @param {Number?} options.parentFingerPrint
     * @param {Number?} options.childIndex
     * @param {Buffer?} options.chainCode
     * @param {Buffer?} options.publicKey
     */
    constructor(S) {
      this.depth = 0, this.parentFingerPrint = 0, this.childIndex = 0, this.chainCode = s.ZERO_HASH, this.publicKey = i.ZERO_KEY, this.fingerPrint = -1, S && this.fromOptions(S);
    }
    /**
     * Inject properties from options object.
     * @private
     * @param {Object} options
     */
    fromOptions(S) {
      return e(S, "No options for HDPublicKey"), e((S.depth & 255) === S.depth), e(S.parentFingerPrint >>> 0 === S.parentFingerPrint), e(S.childIndex >>> 0 === S.childIndex), e(k.isBuffer(S.chainCode)), e(k.isBuffer(S.publicKey)), this.depth = S.depth, this.parentFingerPrint = S.parentFingerPrint, this.childIndex = S.childIndex, this.chainCode = S.chainCode, this.publicKey = S.publicKey, this;
    }
    /**
     * Instantiate HD public key from options object.
     * @param {Object} options
     * @returns {HDPublicKey}
     */
    static fromOptions(S) {
      return new this().fromOptions(S);
    }
    /**
     * Get HD public key (self).
     * @returns {HDPublicKey}
     */
    toPublic() {
      return this;
    }
    /**
     * Get cached base58 xprivkey (always null here).
     * @returns {null}
     */
    xprivkey(S) {
      return null;
    }
    /**
     * Get cached base58 xpubkey.
     * @returns {Base58String}
     */
    xpubkey(S) {
      return this.toBase58(S);
    }
    /**
     * Destroy the key (zeroes chain code and pubkey).
     */
    destroy() {
      this.depth = 0, this.childIndex = 0, this.parentFingerPrint = 0, n(this.chainCode), n(this.publicKey), this.fingerPrint = -1;
    }
    /**
     * Derive a child key.
     * @param {Number} index - Derivation index.
     * @param {Boolean?} hardened - Whether the derivation
     * should be hardened (throws if true).
     * @returns {HDPrivateKey}
     * @throws on `hardened`
     */
    derive(S, y) {
      if (e(typeof S == "number"), S >>> 0 !== S)
        throw new Error("Index out of range.");
      if (S & i.HARDENED || y)
        throw new Error("Cannot derive hardened.");
      if (this.depth >= 255)
        throw new Error("Depth too high.");
      const b = this.getID(S), h = i.cache.get(b);
      if (h)
        return h;
      const a = c.pool(37);
      a.writeBytes(this.publicKey), a.writeU32BE(S);
      const E = a.render(), H = w.mac(E, this.chainCode), j = H.slice(0, 32), G = H.slice(32, 64);
      let N;
      try {
        N = u.publicKeyTweakAdd(this.publicKey, j, !0);
      } catch {
        return this.derive(S + 1);
      }
      if (this.fingerPrint === -1) {
        const A = m.digest(this.publicKey);
        this.fingerPrint = A.readUInt32BE(0, !0);
      }
      const T = new this.constructor();
      return T.depth = this.depth + 1, T.parentFingerPrint = this.fingerPrint, T.childIndex = S, T.chainCode = G, T.publicKey = N, i.cache.set(b, T), T;
    }
    /**
     * Unique HD key ID.
     * @private
     * @param {Number} index
     * @returns {String}
     */
    getID(S) {
      return "b" + this.publicKey.toString("hex") + S;
    }
    /**
     * Derive a BIP44 account key (does not derive, only ensures account key).
     * @method
     * @param {Number} purpose
     * @param {Number} type
     * @param {Number} account
     * @returns {HDPublicKey}
     * @throws Error if key is not already an account key.
     */
    deriveAccount(S, y, b) {
      return e(S >>> 0 === S), e(y >>> 0 === y), e(b >>> 0 === b), e(this.isAccount(b), "Cannot derive account index."), this;
    }
    /**
     * Test whether the key is a master key.
     * @method
     * @returns {Boolean}
     */
    isMaster() {
      return i.isMaster(this);
    }
    /**
     * Test whether the key is (most likely) a BIP44 account key.
     * @method
     * @param {Number?} account
     * @returns {Boolean}
     */
    isAccount(S) {
      return i.isAccount(this, S);
    }
    /**
     * Test whether a string is a valid path.
     * @param {String} path
     * @param {Boolean?} hardened
     * @returns {Boolean}
     */
    static isValidPath(S) {
      try {
        return i.parsePath(S, !1), !0;
      } catch {
        return !1;
      }
    }
    /**
     * Derive a key from a derivation path.
     * @param {String} path
     * @returns {HDPublicKey}
     * @throws Error if `path` is not a valid path.
     * @throws Error if hardened.
     */
    derivePath(S) {
      const y = i.parsePath(S, !1);
      let b = this;
      for (const h of y)
        b = b.derive(h);
      return b;
    }
    /**
     * Compare a key against an object.
     * @param {Object} obj
     * @returns {Boolean}
     */
    equals(S) {
      return e(p.isHDPublicKey(S)), this.depth === S.depth && this.parentFingerPrint === S.parentFingerPrint && this.childIndex === S.childIndex && this.chainCode.equals(S.chainCode) && this.publicKey.equals(S.publicKey);
    }
    /**
     * Compare a key against an object.
     * @param {Object} obj
     * @returns {Boolean}
     */
    compare(S) {
      e(p.isHDPublicKey(S));
      let y = this.depth - S.depth;
      return y !== 0 || (y = this.parentFingerPrint - S.parentFingerPrint, y !== 0) || (y = this.childIndex - S.childIndex, y !== 0) || (y = this.chainCode.compare(S.chainCode), y !== 0) || (y = this.publicKey.compare(S.publicKey), y !== 0) ? y : 0;
    }
    /**
     * Convert key to a more json-friendly object.
     * @returns {Object}
     */
    toJSON(S) {
      return {
        xpubkey: this.xpubkey(S)
      };
    }
    /**
     * Inject properties from json object.
     * @private
     * @param {Object} json
     * @param {Network?} network
     */
    fromJSON(S, y) {
      return e(S.xpubkey, "Could not handle HD key JSON."), this.fromBase58(S.xpubkey, y), this;
    }
    /**
     * Instantiate an HDPublicKey from a jsonified key object.
     * @param {Object} json - The jsonified transaction object.
     * @param {Network?} network
     * @returns {HDPrivateKey}
     */
    static fromJSON(S, y) {
      return new this().fromJSON(S, y);
    }
    /**
     * Test whether an object is in the form of a base58 xpubkey.
     * @param {String} data
     * @param {(Network|NetworkType)?} network
     * @returns {Boolean}
     */
    static isBase58(S, y) {
      if (typeof S != "string" || S.length < 4)
        return !1;
      const b = S.substring(0, 4);
      try {
        return o.fromPublic58(b, y), !0;
      } catch {
        return !1;
      }
    }
    /**
     * Test whether a buffer has a valid network prefix.
     * @param {Buffer} data
     * @param {(Network|NetworkType)?} network
     * @returns {NetworkType}
     */
    static isRaw(S, y) {
      if (!k.isBuffer(S) || S.length < 4)
        return !1;
      const b = S.readUInt32BE(0, !0);
      try {
        return o.fromPublic(b, y), !0;
      } catch {
        return !1;
      }
    }
    /**
     * Inject properties from a base58 key.
     * @private
     * @param {Base58String} xkey
     * @param {Network?} network
     */
    fromBase58(S, y) {
      return e(typeof S == "string"), this.fromRaw(l.decode(S), y);
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {BufferReader} br
     * @param {(Network|NetworkType)?} network
     */
    fromReader(S, y) {
      const b = S.readU32BE();
      return o.fromPublic(b, y), this.depth = S.readU8(), this.parentFingerPrint = S.readU32BE(), this.childIndex = S.readU32BE(), this.chainCode = S.readBytes(32), this.publicKey = S.readBytes(33), S.verifyChecksum(f.digest), this;
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     * @param {(Network|NetworkType)?} network
     */
    fromRaw(S, y) {
      return this.fromReader(c.read(S), y);
    }
    /**
     * Serialize key data to base58 extended key.
     * @param {(Network|NetworkType)?} network
     * @returns {Base58String}
     */
    toBase58(S) {
      return l.encode(this.toRaw(S));
    }
    /**
     * Write the key to a buffer writer.
     * @param {BufferWriter} bw
     * @param {(Network|NetworkType)?} network
     */
    toWriter(S, y) {
      return y = o.get(y), S.writeU32BE(y.keyPrefix.xpubkey), S.writeU8(this.depth), S.writeU32BE(this.parentFingerPrint), S.writeU32BE(this.childIndex), S.writeBytes(this.chainCode), S.writeBytes(this.publicKey), S.writeChecksum(f.digest), S;
    }
    /**
     * Calculate serialization size.
     * @returns {Number}
     */
    getSize() {
      return 82;
    }
    /**
     * Serialize the key.
     * @param {(Network|NetworkType)?} network
     * @returns {Buffer}
     */
    toRaw(S) {
      return this.toWriter(c.write(82), S).render();
    }
    /**
     * Instantiate an HD public key from a base58 string.
     * @param {Base58String} xkey
     * @param {Network?} network
     * @returns {HDPublicKey}
     */
    static fromBase58(S, y) {
      return new this().fromBase58(S, y);
    }
    /**
     * Instantiate key from serialized data.
     * @param {BufferReader} br
     * @param {(Network|NetworkType)?} network
     * @returns {HDPublicKey}
     */
    static fromReader(S, y) {
      return new this().fromReader(S, y);
    }
    /**
     * Instantiate key from serialized data.
     * @param {Buffer} data
     * @param {(Network|NetworkType)?} network
     * @returns {HDPublicKey}
     */
    static fromRaw(S, y) {
      return new this().fromRaw(S, y);
    }
    /**
     * Test whether an object is a HDPublicKey.
     * @param {Object} obj
     * @returns {Boolean}
     */
    static isHDPublicKey(S) {
      return S instanceof p;
    }
  }
  return a0 = p, a0;
}
/*!
 * private.js - hd private keys for bcoin
 * Copyright (c) 2015-2016, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var f0, O2;
function M7() {
  if (O2) return f0;
  O2 = 1;
  const e = dt, c = Bt, { base58: l } = Ys, w = $i(), m = wn(), f = qr(), n = ao(), u = Hi(), o = Yr(), s = Tr(), i = Xt(), p = oo(), g = zl(), S = Cl(), y = k.from("Bitcoin seed", "ascii");
  class b {
    /**
     * Create an hd private key.
     * @constructor
     * @param {Object|String} options
     * @param {Number?} options.depth
     * @param {Number?} options.parentFingerPrint
     * @param {Number?} options.childIndex
     * @param {Buffer?} options.chainCode
     * @param {Buffer?} options.privateKey
     */
    constructor(a) {
      this.depth = 0, this.parentFingerPrint = 0, this.childIndex = 0, this.chainCode = i.ZERO_HASH, this.privateKey = i.ZERO_HASH, this.publicKey = p.ZERO_KEY, this.fingerPrint = -1, this._hdPublicKey = null, a && this.fromOptions(a);
    }
    /**
     * Inject properties from options object.
     * @private
     * @param {Object} options
     */
    fromOptions(a) {
      return e(a, "No options for HD private key."), e((a.depth & 255) === a.depth), e(a.parentFingerPrint >>> 0 === a.parentFingerPrint), e(a.childIndex >>> 0 === a.childIndex), e(k.isBuffer(a.chainCode)), e(k.isBuffer(a.privateKey)), this.depth = a.depth, this.parentFingerPrint = a.parentFingerPrint, this.childIndex = a.childIndex, this.chainCode = a.chainCode, this.privateKey = a.privateKey, this.publicKey = o.publicKeyCreate(a.privateKey, !0), this;
    }
    /**
     * Instantiate HD private key from options object.
     * @param {Object} options
     * @returns {HDPrivateKey}
     */
    static fromOptions(a) {
      return new this().fromOptions(a);
    }
    /**
     * Get HD public key.
     * @returns {HDPublicKey}
     */
    toPublic() {
      let a = this._hdPublicKey;
      return a || (a = new S(), a.depth = this.depth, a.parentFingerPrint = this.parentFingerPrint, a.childIndex = this.childIndex, a.chainCode = this.chainCode, a.publicKey = this.publicKey, this._hdPublicKey = a), a;
    }
    /**
     * Get cached base58 xprivkey.
     * @returns {Base58String}
     */
    xprivkey(a) {
      return this.toBase58(a);
    }
    /**
     * Get cached base58 xpubkey.
     * @returns {Base58String}
     */
    xpubkey(a) {
      return this.toPublic().xpubkey(a);
    }
    /**
     * Destroy the key (zeroes chain code, privkey, and pubkey).
     * @param {Boolean} pub - Destroy hd public key as well.
     */
    destroy(a) {
      this.depth = 0, this.childIndex = 0, this.parentFingerPrint = 0, n(this.chainCode), n(this.privateKey), n(this.publicKey), this.fingerPrint = -1, this._hdPublicKey && (a && this._hdPublicKey.destroy(), this._hdPublicKey = null);
    }
    /**
     * Derive a child key.
     * @param {Number} index - Derivation index.
     * @param {Boolean?} hardened - Whether the derivation should be hardened.
     * @returns {HDPrivateKey}
     */
    derive(a, E) {
      if (e(typeof a == "number"), a >>> 0 !== a)
        throw new Error("Index out of range.");
      if (this.depth >= 255)
        throw new Error("Depth too high.");
      E && (a |= p.HARDENED, a >>>= 0);
      const H = this.getID(a), j = p.cache.get(H);
      if (j)
        return j;
      const G = c.pool(37);
      a & p.HARDENED ? (G.writeU8(0), G.writeBytes(this.privateKey), G.writeU32BE(a)) : (G.writeBytes(this.publicKey), G.writeU32BE(a));
      const N = G.render(), T = w.mac(N, this.chainCode), A = T.slice(0, 32), q = T.slice(32, 64);
      let _;
      try {
        _ = o.privateKeyTweakAdd(this.privateKey, A);
      } catch {
        return this.derive(a + 1);
      }
      if (this.fingerPrint === -1) {
        const R = m.digest(this.publicKey);
        this.fingerPrint = R.readUInt32BE(0, !0);
      }
      const F = new this.constructor();
      return F.depth = this.depth + 1, F.parentFingerPrint = this.fingerPrint, F.childIndex = a, F.chainCode = q, F.privateKey = _, F.publicKey = o.publicKeyCreate(_, !0), p.cache.set(H, F), F;
    }
    /**
     * Unique HD key ID.
     * @private
     * @param {Number} index
     * @returns {String}
     */
    getID(a) {
      return "v" + this.publicKey.toString("hex") + a;
    }
    /**
     * Derive a BIP44 account key.
     * @param {Number} purpose
     * @param {Number} type
     * @param {Number} account
     * @returns {HDPrivateKey}
     * @throws Error if key is not a master key.
     */
    deriveAccount(a, E, H) {
      return e(a >>> 0 === a, "Purpose must be a number."), e(E >>> 0 === E, "Account index must be a number."), e(H >>> 0 === H, "Account index must be a number."), e(this.isMaster(), "Cannot derive account index."), this.derive(a, !0).derive(E, !0).derive(H, !0);
    }
    /**
     * Test whether the key is a master key.
     * @returns {Boolean}
     */
    isMaster() {
      return p.isMaster(this);
    }
    /**
     * Test whether the key is (most likely) a BIP44 account key.
     * @param {Number?} account
     * @returns {Boolean}
     */
    isAccount(a) {
      return p.isAccount(this, a);
    }
    /**
     * Test whether an object is in the form of a base58 xprivkey.
     * @param {String} data
     * @param {Network?} network
     * @returns {Boolean}
     */
    static isBase58(a, E) {
      if (typeof a != "string" || a.length < 4)
        return !1;
      const H = a.substring(0, 4);
      try {
        return s.fromPrivate58(H, E), !0;
      } catch {
        return !1;
      }
    }
    /**
     * Test whether a buffer has a valid network prefix.
     * @param {Buffer} data
     * @param {Network?} network
     * @returns {Boolean}
     */
    static isRaw(a, E) {
      if (!k.isBuffer(a) || a.length < 4)
        return !1;
      const H = a.readUInt32BE(0, !0);
      try {
        return s.fromPrivate(H, E), !0;
      } catch {
        return !1;
      }
    }
    /**
     * Test whether a string is a valid path.
     * @param {String} path
     * @returns {Boolean}
     */
    static isValidPath(a) {
      try {
        return p.parsePath(a, !0), !0;
      } catch {
        return !1;
      }
    }
    /**
     * Derive a key from a derivation path.
     * @param {String} path
     * @returns {HDPrivateKey}
     * @throws Error if `path` is not a valid path.
     */
    derivePath(a) {
      const E = p.parsePath(a, !0);
      let H = this;
      for (const j of E)
        H = H.derive(j);
      return H;
    }
    /**
     * Compare a key against an object.
     * @param {Object} obj
     * @returns {Boolean}
     */
    equals(a) {
      return e(b.isHDPrivateKey(a)), this.depth === a.depth && this.parentFingerPrint === a.parentFingerPrint && this.childIndex === a.childIndex && this.chainCode.equals(a.chainCode) && this.privateKey.equals(a.privateKey);
    }
    /**
     * Compare a key against an object.
     * @param {Object} obj
     * @returns {Boolean}
     */
    compare(a) {
      e(b.isHDPrivateKey(a));
      let E = this.depth - a.depth;
      return E !== 0 || (E = this.parentFingerPrint - a.parentFingerPrint, E !== 0) || (E = this.childIndex - a.childIndex, E !== 0) || (E = this.chainCode.compare(a.chainCode), E !== 0) || (E = this.privateKey.compare(a.privateKey), E !== 0) ? E : 0;
    }
    /**
     * Inject properties from seed.
     * @private
     * @param {Buffer} seed
     */
    fromSeed(a) {
      if (e(k.isBuffer(a)), a.length * 8 < p.MIN_ENTROPY || a.length * 8 > p.MAX_ENTROPY)
        throw new Error("Entropy not in range.");
      const E = w.mac(a, y), H = E.slice(0, 32), j = E.slice(32, 64);
      if (!o.privateKeyVerify(H))
        throw new Error("Master private key is invalid.");
      return this.depth = 0, this.parentFingerPrint = 0, this.childIndex = 0, this.chainCode = j, this.privateKey = H, this.publicKey = o.publicKeyCreate(H, !0), this;
    }
    /**
     * Instantiate an hd private key from a 512 bit seed.
     * @param {Buffer} seed
     * @returns {HDPrivateKey}
     */
    static fromSeed(a) {
      return new this().fromSeed(a);
    }
    /**
     * Inject properties from a mnemonic.
     * @private
     * @param {Mnemonic} mnemonic
     * @param {String?} passphrase
     */
    fromMnemonic(a, E) {
      return e(a instanceof g), this.fromSeed(a.toSeed(E));
    }
    /**
     * Instantiate an hd private key from a mnemonic.
     * @param {Mnemonic} mnemonic
     * @param {String?} passphrase
     * @returns {HDPrivateKey}
     */
    static fromMnemonic(a, E) {
      return new this().fromMnemonic(a, E);
    }
    /**
     * Inject properties from a mnemonic.
     * @private
     * @param {String} mnemonic
     */
    fromPhrase(a) {
      const E = g.fromPhrase(a);
      return this.fromMnemonic(E), this;
    }
    /**
     * Instantiate an hd private key from a phrase.
     * @param {String} phrase
     * @returns {HDPrivateKey}
     */
    static fromPhrase(a) {
      return new this().fromPhrase(a);
    }
    /**
     * Inject properties from privateKey and entropy.
     * @private
     * @param {Buffer} key
     * @param {Buffer} entropy
     */
    fromKey(a, E) {
      return e(k.isBuffer(a) && a.length === 32), e(k.isBuffer(E) && E.length === 32), this.depth = 0, this.parentFingerPrint = 0, this.childIndex = 0, this.chainCode = E, this.privateKey = a, this.publicKey = o.publicKeyCreate(a, !0), this;
    }
    /**
     * Create an hd private key from a key and entropy bytes.
     * @param {Buffer} key
     * @param {Buffer} entropy
     * @returns {HDPrivateKey}
     */
    static fromKey(a, E) {
      return new this().fromKey(a, E);
    }
    /**
     * Generate an hd private key.
     * @returns {HDPrivateKey}
     */
    static generate() {
      const a = o.privateKeyGenerate(), E = u.randomBytes(32);
      return b.fromKey(a, E);
    }
    /**
     * Inject properties from base58 key.
     * @private
     * @param {Base58String} xkey
     * @param {Network?} network
     */
    fromBase58(a, E) {
      return e(typeof a == "string"), this.fromRaw(l.decode(a), E);
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {BufferReader} br
     * @param {(Network|NetworkType)?} network
     */
    fromReader(a, E) {
      const H = a.readU32BE();
      return s.fromPrivate(H, E), this.depth = a.readU8(), this.parentFingerPrint = a.readU32BE(), this.childIndex = a.readU32BE(), this.chainCode = a.readBytes(32), e(a.readU8() === 0), this.privateKey = a.readBytes(32), this.publicKey = o.publicKeyCreate(this.privateKey, !0), a.verifyChecksum(f.digest), this;
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     * @param {(Network|NetworkType)?} network
     */
    fromRaw(a, E) {
      return this.fromReader(c.read(a), E);
    }
    /**
     * Serialize key to a base58 string.
     * @param {(Network|NetworkType)?} network
     * @returns {Base58String}
     */
    toBase58(a) {
      return l.encode(this.toRaw(a));
    }
    /**
     * Calculate serialization size.
     * @returns {Number}
     */
    getSize() {
      return 82;
    }
    /**
     * Write the key to a buffer writer.
     * @param {BufferWriter} bw
     * @param {(Network|NetworkType)?} network
     */
    toWriter(a, E) {
      return E = s.get(E), a.writeU32BE(E.keyPrefix.xprivkey), a.writeU8(this.depth), a.writeU32BE(this.parentFingerPrint), a.writeU32BE(this.childIndex), a.writeBytes(this.chainCode), a.writeU8(0), a.writeBytes(this.privateKey), a.writeChecksum(f.digest), a;
    }
    /**
     * Serialize the key.
     * @param {(Network|NetworkType)?} network
     * @returns {Buffer}
     */
    toRaw(a) {
      return this.toWriter(c.write(82), a).render();
    }
    /**
     * Instantiate an HD private key from a base58 string.
     * @param {Base58String} xkey
     * @param {Network?} network
     * @returns {HDPrivateKey}
     */
    static fromBase58(a, E) {
      return new this().fromBase58(a, E);
    }
    /**
     * Instantiate key from buffer reader.
     * @param {BufferReader} br
     * @param {(Network|NetworkType)?} network
     * @returns {HDPrivateKey}
     */
    static fromReader(a, E) {
      return new this().fromReader(a, E);
    }
    /**
     * Instantiate key from serialized data.
     * @param {Buffer} data
     * @param {(Network|NetworkType)?} network
     * @returns {HDPrivateKey}
     */
    static fromRaw(a, E) {
      return new this().fromRaw(a, E);
    }
    /**
     * Convert key to a more json-friendly object.
     * @returns {Object}
     */
    toJSON(a) {
      return {
        xprivkey: this.xprivkey(a)
      };
    }
    /**
     * Inject properties from json object.
     * @private
     * @param {Object} json
     * @param {Network?} network
     */
    fromJSON(a, E) {
      return e(a.xprivkey, "Could not handle key JSON."), this.fromBase58(a.xprivkey, E), this;
    }
    /**
     * Instantiate an HDPrivateKey from a jsonified key object.
     * @param {Object} json - The jsonified key object.
     * @param {Network?} network
     * @returns {HDPrivateKey}
     */
    static fromJSON(a, E) {
      return new this().fromJSON(a, E);
    }
    /**
     * Test whether an object is an HDPrivateKey.
     * @param {Object} obj
     * @returns {Boolean}
     */
    static isHDPrivateKey(a) {
      return a instanceof b;
    }
  }
  return f0 = b, f0;
}
/*!
 * hd.js - hd keys for bcoin
 * Copyright (c) 2015-2016, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var _2;
function Kg() {
  return _2 || (_2 = 1, function(e) {
    const c = dt, l = oo(), w = zl(), m = M7(), f = Cl(), n = B7(), u = e;
    u.fromBase58 = function(s, i) {
      return m.isBase58(s) ? m.fromBase58(s, i) : f.fromBase58(s, i);
    }, u.generate = function() {
      return m.generate();
    }, u.fromSeed = function(s) {
      return m.fromSeed(s);
    }, u.fromMnemonic = function(s) {
      return m.fromMnemonic(s);
    }, u.fromJSON = function(s, i) {
      return s.xprivkey ? m.fromJSON(s, i) : f.fromJSON(s, i);
    }, u.fromRaw = function(s, i) {
      return m.isRaw(s, i) ? m.fromRaw(s, i) : f.fromRaw(s, i);
    }, u.from = function(s, i) {
      if (c(s, "Options required."), u.isHD(s))
        return s;
      if (u.isBase58(s, i))
        return u.fromBase58(s, i);
      if (u.isRaw(s, i))
        return u.fromRaw(s, i);
      if (s && typeof s == "object")
        return u.fromMnemonic(s);
      throw new Error("Cannot create HD key from bad options.");
    }, u.isBase58 = function(s, i) {
      return m.isBase58(s, i) || f.isBase58(s, i);
    }, u.isRaw = function(s, i) {
      return m.isRaw(s, i) || f.isRaw(s, i);
    }, u.isHD = function(s) {
      return m.isHDPrivateKey(s) || f.isHDPublicKey(s);
    }, u.isPrivate = function(s) {
      return m.isHDPrivateKey(s);
    }, u.isPublic = function(s) {
      return f.isHDPublicKey(s);
    }, u.common = l, u.HD = u, u.Mnemonic = w, u.PrivateKey = m, u.PublicKey = f, u.HDPrivateKey = m, u.HDPublicKey = f, u.wordlist = n;
  }(Ya)), Ya;
}
/*!
 * hd/index.js - hd keys for bcoin
 * Copyright (c) 2014-2016, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var c0, R2;
function Vg() {
  return R2 || (R2 = 1, c0 = Kg()), c0;
}
var jt = {};
/*!
 * invitem.js - inv item object for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var u0, P2;
function fo() {
  if (P2) return u0;
  P2 = 1;
  const e = Bt, c = pr();
  class l {
    /**
     * Create an inv item.
     * @constructor
     * @param {Number} type
     * @param {Hash} hash
     */
    constructor(m, f) {
      this.type = m, this.hash = f;
    }
    /**
     * Write inv item to buffer writer.
     * @param {BufferWriter} bw
     */
    getSize() {
      return 36;
    }
    /**
     * Write inv item to buffer writer.
     * @param {BufferWriter} bw
     */
    toWriter(m) {
      return m.writeU32(this.type), m.writeHash(this.hash), m;
    }
    /**
     * Serialize inv item.
     * @returns {Buffer}
     */
    toRaw() {
      return this.toWriter(e.write(36)).render();
    }
    /**
     * Inject properties from buffer reader.
     * @private
     * @param {BufferReader} br
     */
    fromReader(m) {
      return this.type = m.readU32(), this.hash = m.readHash(), this;
    }
    /**
     * Inject properties from serialized data.
     * @param {Buffer} data
     */
    fromRaw(m) {
      return this.fromReader(e.read(m));
    }
    /**
     * Instantiate inv item from buffer reader.
     * @param {BufferReader} br
     * @returns {InvItem}
     */
    static fromReader(m) {
      return new this().fromReader(m);
    }
    /**
     * Instantiate inv item from serialized data.
     * @param {Buffer} data
     * @param {String?} enc
     * @returns {InvItem}
     */
    static fromRaw(m, f) {
      return typeof m == "string" && (m = k.from(m, f)), new this().fromRaw(m);
    }
    /**
     * Test whether the inv item is a block.
     * @returns {Boolean}
     */
    isBlock() {
      switch (this.type) {
        case l.types.BLOCK:
        case l.types.FILTERED_BLOCK:
        case l.types.CMPCT_BLOCK:
          return !0;
        default:
          return !1;
      }
    }
    /**
     * Test whether the inv item is a tx.
     * @returns {Boolean}
     */
    isTX() {
      switch (this.type) {
        case l.types.TX:
          return !0;
        default:
          return !1;
      }
    }
    /**
     * Get little-endian hash.
     * @returns {Hash}
     */
    rhash() {
      return c.revHex(this.hash);
    }
  }
  return l.types = {
    TX: 1,
    BLOCK: 2,
    FILTERED_BLOCK: 3,
    CMPCT_BLOCK: 4
  }, l.typesByVal = {
    1: "TX",
    2: "BLOCK",
    3: "FILTERED_BLOCK",
    4: "CMPCT_BLOCK"
  }, u0 = l, u0;
}
/*!
 * abstractblock.js - abstract block object for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var h0, k2;
function rs() {
  if (k2) return h0;
  k2 = 1;
  const e = dt, c = qr(), l = Bt, w = pr(), m = fo(), f = Xt();
  class n {
    /**
     * Create an abstract block.
     * @constructor
     */
    constructor() {
      this.version = 1, this.prevBlock = f.ZERO_HASH, this.merkleRoot = f.ZERO_HASH, this.time = 0, this.bits = 0, this.nonce = 0, this.mutable = !1, this._hash = null, this._hhash = null;
    }
    /**
     * Inject properties from options object.
     * @private
     * @param {Object} options
     */
    parseOptions(o) {
      return e(o, "Block data is required."), e(o.version >>> 0 === o.version), e(k.isBuffer(o.prevBlock)), e(k.isBuffer(o.merkleRoot)), e(o.time >>> 0 === o.time), e(o.bits >>> 0 === o.bits), e(o.nonce >>> 0 === o.nonce), this.version = o.version, this.prevBlock = o.prevBlock, this.merkleRoot = o.merkleRoot, this.time = o.time, this.bits = o.bits, this.nonce = o.nonce, o.mutable != null && (e(typeof o.mutable == "boolean"), this.mutable = o.mutable), this;
    }
    /**
     * Inject properties from json object.
     * @private
     * @param {Object} json
     */
    parseJSON(o) {
      return e(o, "Block data is required."), e(o.version >>> 0 === o.version), e(typeof o.prevBlock == "string"), e(typeof o.merkleRoot == "string"), e(o.time >>> 0 === o.time), e(o.bits >>> 0 === o.bits), e(o.nonce >>> 0 === o.nonce), this.version = o.version, this.prevBlock = w.fromRev(o.prevBlock), this.merkleRoot = w.fromRev(o.merkleRoot), this.time = o.time, this.bits = o.bits, this.nonce = o.nonce, this;
    }
    /**
     * Test whether the block is a memblock.
     * @returns {Boolean}
     */
    isMemory() {
      return !1;
    }
    /**
     * Clear any cached values (abstract).
     */
    _refresh() {
      this._hash = null, this._hhash = null;
    }
    /**
     * Clear any cached values.
     */
    refresh() {
      return this._refresh();
    }
    /**
     * Hash the block headers.
     * @param {String?} enc - Can be `'hex'` or `null`.
     * @returns {Hash|Buffer} hash
     */
    hash(o) {
      let s = this._hash;
      if (s || (s = c.digest(this.toHead()), this.mutable || (this._hash = s)), o === "hex") {
        let i = this._hhash;
        i || (i = s.toString("hex"), this.mutable || (this._hhash = i)), s = i;
      }
      return s;
    }
    /**
     * Serialize the block headers.
     * @returns {Buffer}
     */
    toHead() {
      return this.writeHead(l.write(80)).render();
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     */
    fromHead(o) {
      return this.readHead(l.read(o));
    }
    /**
     * Serialize the block headers.
     * @param {BufferWriter} bw
     */
    writeHead(o) {
      return o.writeU32(this.version), o.writeHash(this.prevBlock), o.writeHash(this.merkleRoot), o.writeU32(this.time), o.writeU32(this.bits), o.writeU32(this.nonce), o;
    }
    /**
     * Parse the block headers.
     * @param {BufferReader} br
     */
    readHead(o) {
      return this.version = o.readU32(), this.prevBlock = o.readHash(), this.merkleRoot = o.readHash(), this.time = o.readU32(), this.bits = o.readU32(), this.nonce = o.readU32(), this;
    }
    /**
     * Verify the block.
     * @returns {Boolean}
     */
    verify() {
      return !(!this.verifyPOW() || !this.verifyBody());
    }
    /**
     * Verify proof-of-work.
     * @returns {Boolean}
     */
    verifyPOW() {
      return f.verifyPOW(this.hash(), this.bits);
    }
    /**
     * Verify the block.
     * @returns {Boolean}
     */
    verifyBody() {
      throw new Error("Abstract method.");
    }
    /**
     * Get little-endian block hash.
     * @returns {Hash}
     */
    rhash() {
      return w.revHex(this.hash());
    }
    /**
     * Convert the block to an inv item.
     * @returns {InvItem}
     */
    toInv() {
      return new m(m.types.BLOCK, this.hash());
    }
  }
  return h0 = n, h0;
}
var Qi = {};
/*!
 * merkle.js - merkle trees for bcrypto
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on bitcoin/bitcoin:
 *   Copyright (c) 2009-2019, The Bitcoin Core Developers (MIT License).
 *   Copyright (c) 2009-2019, The Bitcoin Developers (MIT License).
 *   https://github.com/bitcoin/bitcoin
 */
var B2;
function N7() {
  if (B2) return Qi;
  B2 = 1;
  const e = Mt();
  function c(f, n) {
    e(f && typeof f.root == "function"), e(Array.isArray(n));
    const u = new Array(n.length);
    for (let p = 0; p < n.length; p++)
      u[p] = n[p];
    let o = u.length, s = !1, i = 0;
    if (o === 0)
      return u.push(f.zero), [u, s];
    for (; o > 1; ) {
      for (let p = 0; p < o; p += 2) {
        const g = Math.min(p + 1, o - 1), S = u[i + p], y = u[i + g];
        g === p + 1 && g + 1 === o && S.equals(y) && (s = !0);
        const b = f.root(S, y);
        u.push(b);
      }
      i += o, o = o + 1 >>> 1;
    }
    return [u, s];
  }
  function l(f, n) {
    e(f && typeof f.root == "function"), e(Array.isArray(n));
    const [u, o] = c(f, n);
    return [u[u.length - 1], o];
  }
  function w(f, n, u) {
    e(f && typeof f.root == "function"), e(n >>> 0 === n), e(Array.isArray(u)), e(n < u.length);
    let o = u.length;
    const [s] = c(f, u), i = [];
    let p = 0;
    for (; o > 1; ) {
      const g = Math.min(n ^ 1, o - 1);
      i.push(s[p + g]), n >>>= 1, p += o, o = o + 1 >>> 1;
    }
    return i;
  }
  function m(f, n, u, o) {
    e(f && typeof f.root == "function"), e(k.isBuffer(n)), e(Array.isArray(u)), e(o >>> 0 === o);
    let s = n;
    for (const i of u) {
      if (o & 1 && i.equals(s))
        return f.zero;
      o & 1 ? s = f.root(i, s) : s = f.root(s, i), o >>>= 1;
    }
    return s;
  }
  return Qi.createTree = c, Qi.createRoot = l, Qi.createBranch = w, Qi.deriveRoot = m, Qi;
}
/*!
 * input.js - input object for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var l0, M2;
function co() {
  if (M2) return l0;
  M2 = 1;
  const e = dt, c = Bt, l = Tr(), w = si(), m = vn(), { inspectSymbol: f } = cr();
  class n {
    /**
     * Create transaction input.
     * @constructor
     * @param {Object} options
     */
    constructor(o) {
      this.prevout = new m(), this.script = new w(), this.sequence = 4294967295, o && this.fromOptions(o);
    }
    /**
     * Inject properties from options object.
     * @private
     * @param {Object} options
     */
    fromOptions(o) {
      return e(o, "Input data is required."), this.prevout.fromOptions(o.prevout), o.script && this.script.fromOptions(o.script), o.sequence != null && (e(
        o.sequence >>> 0 === o.sequence,
        "Sequence must be a uint32."
      ), this.sequence = o.sequence), this;
    }
    /**
     * Instantiate an Input from options object.
     * @param {Object} options
     * @returns {Input}
     */
    static fromOptions(o) {
      return new this().fromOptions(o);
    }
    /**
     * Clone the input.
     * @returns {Input}
     */
    clone() {
      const o = new this.constructor();
      return o.prevout = this.prevout, o.script.inject(this.script), o.sequence = this.sequence, o;
    }
    /**
     * Test equality against another input.
     * @param {Input} input
     * @returns {Boolean}
     */
    equals(o) {
      return e(n.isInput(o)), this.prevout.equals(o.prevout);
    }
    /**
     * Compare against another input (BIP69).
     * @param {Input} input
     * @returns {Number}
     */
    compare(o) {
      return e(n.isInput(o)), this.prevout.compare(o.prevout);
    }
    /**
     * Get the previous output script type as a string.
     * Will "guess" based on the input script and/or
     * witness if coin is not available.
     * @param {Coin?} coin
     * @returns {ScriptType} type
     */
    getType(o) {
      if (this.isCoinbase())
        return "coinbase";
      if (o)
        return o.getType();
      const s = this.script.getInputType();
      return w.typesByVal[s].toLowerCase();
    }
    /**
     * Get the redeem script.
     * @param {Coin?} coin
     * @returns {Script?} Redeem script.
     */
    getRedeem(o) {
      if (this.isCoinbase())
        return null;
      if (!o)
        return this.script.isScripthashInput() ? this.script.getRedeem() : null;
      let s = o.script, i = null;
      return s.isScripthash() && (s = this.script.getRedeem(), i = s), i;
    }
    /**
     * Get the redeem script type.
     * @param {Coin?} coin
     * @returns {String} subtype
     */
    getSubtype(o) {
      if (this.isCoinbase())
        return null;
      const s = this.getRedeem(o);
      if (!s)
        return null;
      const i = s.getType();
      return w.typesByVal[i].toLowerCase();
    }
    /**
     * Get the previous output script's address. Will "guess"
     * based on the input script and/or witness if coin
     * is not available.
     * @param {Coin?} coin
     * @returns {Address?} addr
     */
    getAddress(o) {
      return this.isCoinbase() ? null : o ? o.getAddress() : this.script.code.length > 0 ? this.script.getInputAddress() : null;
    }
    /**
     * Get the address hash.
     * @param {Coin?} coin
     * @param {String?} enc
     * @returns {Hash} hash
     */
    getHash(o, s) {
      const i = this.getAddress(o);
      return i ? i.getHash(s) : null;
    }
    /**
     * Test to see if nSequence is equal to uint32max.
     * @returns {Boolean}
     */
    isFinal() {
      return this.sequence === 4294967295;
    }
    /**
     * Test to see if nSequence is less than 0xfffffffe.
     * @returns {Boolean}
     */
    isRBF() {
      return this.sequence < 4294967294;
    }
    /**
     * Test to see if outpoint is null.
     * @returns {Boolean}
     */
    isCoinbase() {
      return this.prevout.isNull();
    }
    /**
     * Convert the input to a more user-friendly object.
     * @returns {Object}
     */
    [f]() {
      return this.format();
    }
    /**
     * Convert the input to a more user-friendly object.
     * @param {Coin?} coin
     * @returns {Object}
     */
    format(o) {
      return {
        type: this.getType(o),
        subtype: this.getSubtype(o),
        address: this.getAddress(o),
        script: this.script,
        redeem: this.getRedeem(o),
        sequence: this.sequence,
        prevout: this.prevout,
        coin: o || null
      };
    }
    /**
     * Convert the input to an object suitable
     * for JSON serialization.
     * @returns {Object}
     */
    toJSON(o, s) {
      return this.getJSON();
    }
    /**
     * Convert the input to an object suitable
     * for JSON serialization. Note that the hashes
     * will be reversed to abide by bitcoind's legacy
     * of little-endian uint256s.
     * @param {Network} network
     * @param {Coin} coin
     * @returns {Object}
     */
    getJSON(o, s) {
      o = l.get(o);
      let i;
      return s || (i = this.getAddress(), i && (i = i.toString(o))), {
        prevout: this.prevout.toJSON(),
        script: this.script.toJSON(),
        sequence: this.sequence,
        address: i,
        coin: s ? s.getJSON(o, !0) : void 0
      };
    }
    /**
     * Inject properties from a JSON object.
     * @private
     * @param {Object} json
     */
    fromJSON(o) {
      return e(o, "Input data is required."), e(
        o.sequence >>> 0 === o.sequence,
        "Sequence must be a uint32."
      ), this.prevout.fromJSON(o.prevout), this.script.fromJSON(o.script), this.sequence = o.sequence, this;
    }
    /**
     * Instantiate an Input from a jsonified input object.
     * @param {Object} json - The jsonified input object.
     * @returns {Input}
     */
    static fromJSON(o) {
      return new this().fromJSON(o);
    }
    /**
     * Calculate size of serialized input.
     * @returns {Number}
     */
    getSize() {
      return 40 + this.script.getVarSize();
    }
    /**
     * Serialize the input.
     * @param {String?} enc - Encoding, can be `'hex'` or null.
     * @returns {Buffer|String}
     */
    toRaw() {
      const o = this.getSize();
      return this.toWriter(c.write(o)).render();
    }
    /**
     * Write the input to a buffer writer.
     * @param {BufferWriter} bw
     */
    toWriter(o) {
      return this.prevout.toWriter(o), o.writeVarBytes(this.script.toRaw()), o.writeU32(this.sequence), o;
    }
    /**
     * Inject properties from buffer reader.
     * @private
     * @param {BufferReader} br
     */
    fromReader(o) {
      return this.prevout.fromReader(o), this.script.fromRaw(o.readVarBytes()), this.sequence = o.readU32(), this;
    }
    /**
     * Inject properties from serialized data.
     * @param {Buffer} data
     */
    fromRaw(o) {
      return this.fromReader(c.read(o));
    }
    /**
     * Instantiate an input from a buffer reader.
     * @param {BufferReader} br
     * @returns {Input}
     */
    static fromReader(o) {
      return new this().fromReader(o);
    }
    /**
     * Instantiate an input from a serialized Buffer.
     * @param {Buffer} data
     * @param {String?} enc - Encoding, can be `'hex'` or null.
     * @returns {Input}
     */
    static fromRaw(o, s) {
      return typeof o == "string" && (o = k.from(o, s)), new this().fromRaw(o);
    }
    /**
     * Inject properties from outpoint.
     * @private
     * @param {Outpoint} outpoint
     */
    fromOutpoint(o) {
      return e(k.isBuffer(o.hash)), e(typeof o.index == "number"), this.prevout.hash = o.hash, this.prevout.index = o.index, this;
    }
    /**
     * Instantiate input from outpoint.
     * @param {Outpoint}
     * @returns {Input}
     */
    static fromOutpoint(o) {
      return new this().fromOutpoint(o);
    }
    /**
     * Inject properties from coin.
     * @private
     * @param {Coin} coin
     */
    fromCoin(o) {
      return e(k.isBuffer(o.hash)), e(typeof o.index == "number"), this.prevout.hash = o.hash, this.prevout.index = o.index, this;
    }
    /**
     * Instantiate input from coin.
     * @param {Coin}
     * @returns {Input}
     */
    static fromCoin(o) {
      return new this().fromCoin(o);
    }
    /**
     * Inject properties from transaction.
     * @private
     * @param {TX} tx
     * @param {Number} index
     */
    fromTX(o, s) {
      return e(o), e(typeof s == "number"), e(s >= 0 && s < o.outputs.length), this.prevout.hash = o.hash(), this.prevout.index = s, this;
    }
    /**
     * Instantiate input from tx.
     * @param {TX} tx
     * @param {Number} index
     * @returns {Input}
     */
    static fromTX(o, s) {
      return new this().fromTX(o, s);
    }
    /**
     * Test an object to see if it is an Input.
     * @param {Object} obj
     * @returns {Boolean}
     */
    static isInput(o) {
      return o instanceof n;
    }
  }
  return l0 = n, l0;
}
/*!
 * tx.js - transaction object for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var d0, N2;
function is() {
  if (N2) return d0;
  N2 = 1;
  const e = dt, c = Bt, l = qr(), w = Yr(), { BufferSet: m } = xn, f = pr(), n = Di(), u = Tr(), o = si(), s = io(), i = co(), p = Vi(), g = vn(), S = fo(), y = Xt(), b = yn(), h = to(), { encoding: a } = c, { hashType: E } = o, H = ts(), { inspectSymbol: j } = cr();
  class G {
    /**
     * Create a transaction.
     * @constructor
     * @param {Object?} options
     */
    constructor(A) {
      this.version = 1, this.inputs = [], this.outputs = [], this.locktime = 0, this.mutable = !1, this._hash = null, this._hhash = null, this._raw = null, this._offset = -1, this._block = !1, this._size = -1, this._sigops = -1, this._hashPrevouts = null, this._hashSequence = null, this._hashOutputs = null, A && this.fromOptions(A);
    }
    /**
     * Inject properties from options object.
     * @private
     * @param {Object} options
     */
    fromOptions(A) {
      if (e(A, "TX data is required."), A.version != null && (e(
        A.version >>> 0 === A.version,
        "Version must be a uint32."
      ), this.version = A.version), A.inputs) {
        e(Array.isArray(A.inputs), "Inputs must be an array.");
        for (const q of A.inputs)
          this.inputs.push(new i(q));
      }
      if (A.outputs) {
        e(Array.isArray(A.outputs), "Outputs must be an array.");
        for (const q of A.outputs)
          this.outputs.push(new p(q));
      }
      return A.locktime != null && (e(
        A.locktime >>> 0 === A.locktime,
        "Locktime must be a uint32."
      ), this.locktime = A.locktime), A.slpToken && A.slpToken.constructor === s.TokenRecord().constructor && (this.slpToken = A.slpToken), this;
    }
    /**
     * Instantiate TX from options object.
     * @param {Object} options
     * @returns {TX}
     */
    static fromOptions(A) {
      return new this().fromOptions(A);
    }
    /**
     * Clone the transaction.
     * @returns {TX}
     */
    clone() {
      return new this.constructor().inject(this);
    }
    /**
     * Inject properties from tx.
     * Used for cloning.
     * @private
     * @param {TX} tx
     * @returns {TX}
     */
    inject(A) {
      this.version = A.version;
      for (const q of A.inputs)
        this.inputs.push(q.clone());
      for (const q of A.outputs)
        this.outputs.push(q.clone());
      return this.locktime = A.locktime, this;
    }
    /**
     * Clear any cached values.
     */
    refresh() {
      this._hash = null, this._hhash = null, this._raw = null, this._size = -1, this._offset = -1, this._block = !1, this._sigops = -1, this._hashPrevouts = null, this._hashSequence = null, this._hashOutputs = null;
    }
    /**
     * Hash the transaction with the non-witness serialization.
     * @param {String?} enc - Can be `'hex'` or `null`.
     * @returns {Hash|Buffer} hash
     */
    hash(A) {
      let q = this._hash;
      if (q || (q = l.digest(this.toRaw()), this.mutable || (this._hash = q)), A === "hex") {
        let _ = this._hhash;
        _ || (_ = q.toString("hex"), this.mutable || (this._hhash = _)), q = _;
      }
      return q;
    }
    /**
     * Serialize the transaction. Note
     * that this is cached.
     * @returns {Buffer} Serialized transaction.
     */
    toRaw() {
      return this.frame().data;
    }
    /**
     * Write the transaction to a buffer writer.
     * @param {BufferWriter} bw
     * @param {Boolean} block
     */
    toWriter(A, q) {
      return this.mutable ? this.writeNormal(A) : (q && (this._offset = A.offset, this._block = !0), A.writeBytes(this.toRaw()), A);
    }
    /**
     * Serialize the transaction. Note
     * that this is cached.
     * @private
     * @returns {RawTX}
     */
    frame() {
      if (this.mutable)
        return e(!this._raw), this.frameNormal();
      if (this._raw) {
        e(this._size >= 0);
        const q = new N(this._size);
        return q.data = this._raw, q;
      }
      const A = this.frameNormal();
      return this._raw = A.data, this._size = A.size, A;
    }
    /**
     * Return the offset and size of the transaction. Useful
     * when the transaction is deserialized within a block.
     * @returns {Object} contains `size` and `offset`.
     */
    getPosition() {
      return this._block && this._offset > 80 || console.log(this), e(this._block && this._offset > 80, "Position not available."), {
        offset: this._offset,
        size: this._size
      };
    }
    /**
     * Calculate the real size of the transaction.
     * @returns {Number} size
     */
    getSize() {
      return this.mutable ? this.getNormalSizes().size : this.frame().size;
    }
    /**
     * Get the signature hash of the transaction for signing verifying.
     * @param {Number} index - Index of input being signed/verified.
     * @param {Script} prev - Previous output script or redeem script.
     * @param {Amount} value - Previous output value.
     * @param {SighashType} type - Sighash type.
     * @param {Number} flags - Script flags.
     * @returns {Buffer} Signature hash.
     */
    signatureHash(A, q, _, F, R) {
      if (e(A >= 0 && A < this.inputs.length), e(q instanceof o), e(typeof _ == "number"), e(typeof F == "number"), R == null && (R = o.flags.STANDARD_VERIFY_FLAGS), R & o.flags.VERIFY_REPLAY_PROTECTION) {
        const L = H.getHashTypeForkValue(F) ^ 57005;
        F = H.hashTypeWithForkValue(F, L | 16711680);
      }
      return F & o.hashType.SIGHASH_FORKID && R & o.flags.VERIFY_SIGHASH_FORKID ? this.signatureHashV1(A, q, _, F) : this.signatureHashV0(A, q, F);
    }
    /**
     * Legacy sighashing -- O(n^2).
     * @private
     * @param {Number} index
     * @param {Script} prev
     * @param {SighashType} type
     * @returns {Buffer}
     */
    signatureHashV0(A, q, _) {
      if ((_ & 31) === E.SINGLE && A >= this.outputs.length) {
        const L = k.alloc(32, 0);
        return L[0] = 1, L;
      }
      q = q.removeSeparators();
      const F = this.hashSize(A, q, _), R = c.pool(F);
      if (R.writeU32(this.version), _ & E.ANYONECANPAY) {
        const L = this.inputs[A];
        R.writeVarint(1), L.prevout.toWriter(R), R.writeVarBytes(q.toRaw()), R.writeU32(L.sequence);
      } else {
        R.writeVarint(this.inputs.length);
        for (let L = 0; L < this.inputs.length; L++) {
          const fe = this.inputs[L];
          if (fe.prevout.toWriter(R), L === A) {
            R.writeVarBytes(q.toRaw()), R.writeU32(fe.sequence);
            continue;
          }
          switch (R.writeVarint(0), _ & 31) {
            case E.NONE:
            case E.SINGLE:
              R.writeU32(0);
              break;
            default:
              R.writeU32(fe.sequence);
              break;
          }
        }
      }
      switch (_ & 31) {
        case E.NONE: {
          R.writeVarint(0);
          break;
        }
        case E.SINGLE: {
          const L = this.outputs[A];
          R.writeVarint(A + 1);
          for (let fe = 0; fe < A; fe++)
            R.writeI64(-1), R.writeVarint(0);
          L.toWriter(R);
          break;
        }
        default: {
          R.writeVarint(this.outputs.length);
          for (const L of this.outputs)
            L.toWriter(R);
          break;
        }
      }
      return R.writeU32(this.locktime), R.writeU32(_), l.digest(R.render());
    }
    /**
     * Calculate sighash size.
     * @private
     * @param {Number} index
     * @param {Script} prev
     * @param {Number} type
     * @returns {Number}
     */
    hashSize(A, q, _) {
      let F = 0;
      switch (F += 4, _ & E.ANYONECANPAY ? (F += 1, F += 36, F += q.getVarSize(), F += 4) : (F += a.sizeVarint(this.inputs.length), F += 41 * (this.inputs.length - 1), F += 36, F += q.getVarSize(), F += 4), _ & 31) {
        case E.NONE:
          F += 1;
          break;
        case E.SINGLE:
          F += a.sizeVarint(A + 1), F += 9 * A, F += this.outputs[A].getSize();
          break;
        default:
          F += a.sizeVarint(this.outputs.length);
          for (const R of this.outputs)
            F += R.getSize();
          break;
      }
      return F += 8, F;
    }
    /**
     * Witness sighashing -- O(n).
     * @private
     * @param {Number} index
     * @param {Script} prev
     * @param {Amount} value
     * @param {SighashType} type
     * @returns {Buffer}
     */
    signatureHashV1(A, q, _, F) {
      const R = this.inputs[A];
      let L = y.ZERO_HASH, fe = y.ZERO_HASH, ue = y.ZERO_HASH;
      if (!(F & E.ANYONECANPAY))
        if (this._hashPrevouts)
          L = this._hashPrevouts;
        else {
          const Q = c.pool(this.inputs.length * 36);
          for (const W of this.inputs)
            W.prevout.toWriter(Q);
          L = l.digest(Q.render()), this.mutable || (this._hashPrevouts = L);
        }
      if (!(F & E.ANYONECANPAY) && (F & 31) !== E.SINGLE && (F & 31) !== E.NONE)
        if (this._hashSequence)
          fe = this._hashSequence;
        else {
          const Q = c.pool(this.inputs.length * 4);
          for (const W of this.inputs)
            Q.writeU32(W.sequence);
          fe = l.digest(Q.render()), this.mutable || (this._hashSequence = fe);
        }
      if ((F & 31) !== E.SINGLE && (F & 31) !== E.NONE)
        if (this._hashOutputs)
          ue = this._hashOutputs;
        else {
          let Q = 0;
          for (const oe of this.outputs)
            Q += oe.getSize();
          const W = c.pool(Q);
          for (const oe of this.outputs)
            oe.toWriter(W);
          ue = l.digest(W.render()), this.mutable || (this._hashOutputs = ue);
        }
      else if ((F & 31) === E.SINGLE && A < this.outputs.length) {
        const Q = this.outputs[A];
        ue = l.digest(Q.toRaw());
      }
      const ae = 156 + q.getVarSize(), D = c.pool(ae);
      return D.writeU32(this.version), D.writeBytes(L), D.writeBytes(fe), D.writeHash(R.prevout.hash), D.writeU32(R.prevout.index), D.writeVarBytes(q.toRaw()), D.writeI64(_), D.writeU32(R.sequence), D.writeBytes(ue), D.writeU32(this.locktime), D.writeU32(F), l.digest(D.render());
    }
    /**
     * Verify signature.
     * @param {Number} index
     * @param {Script} prev
     * @param {Amount} value
     * @param {Buffer} sig
     * @param {Buffer} key
     * @param {Number} flags
     * @returns {Boolean}
     */
    checksig(A, q, _, F, R, L) {
      if (F.length === 0)
        return !1;
      const fe = F[F.length - 1], ue = this.signatureHash(A, q, _, fe, L);
      let ae;
      return H.isSchnorr(F) ? ae = w.schnorrVerify(ue, F.slice(0, -1), R) : ae = w.verifyDER(ue, F.slice(0, -1), R), ae;
    }
    /**
     * Create a signature suitable for inserting into scriptSigs.
     * @param {Number} index - Index of input being signed.
     * @param {Script} prev - Previous output script or redeem script.
     * @param {Amount} value - Previous output value.
     * @param {Buffer} key
     * @param {SighashType} type
     * @param {Number} flags - Script flags.
     * @returns {Buffer} Signature in SCHNORR / DER format.
     */
    signature(A, q, _, F, R, L) {
      let fe;
      R == null && (R = E.ALL), L == null && (L = o.flags.VERIFY_SIGHASH_FORKID);
      const ue = this.signatureHash(A, q, _, R, L), ae = w.signDER(ue, F), D = w.schnorrSign(ue, F);
      H.isSchnorr(D) ? fe = D : fe = ae;
      const Q = c.write(fe.length + 1);
      return Q.writeBytes(fe), Q.writeU8(R), Q.render();
    }
    /**
     * Create a signature suitable for inserting into scriptSigs.
     * @param {Number} index - Index of input being signed.
     * @param {Script} prev - Previous output script or redeem script.
     * @param {Amount} value - Previous output value.
     * @param {Buffer} key
     * @param {SighashType} type
     * @param {Number} flags - Script flags.
     * @returns {Buffer} Signature in Schnorr format.
     */
    schnorrSignature(A, q, _, F, R, L) {
      R == null && (R = E.ALL), L == null && (L = o.flags.VERIFY_SIGHASH_FORKID);
      const fe = this.signatureHash(A, q, _, R, L), ue = w.schnorrSign(fe, F), ae = c.write(ue.length + 1);
      return ae.writeBytes(ue), ae.writeU8(R), ae.render();
    }
    /**
     * Verify all transaction inputs.
     * @param {CoinView} view
     * @param {VerifyFlags?} [flags=STANDARD_VERIFY_FLAGS]
     * @throws {ScriptError} on invalid inputs
     */
    check(A, q) {
      if (this.inputs.length === 0)
        throw new h("UNKNOWN_ERROR", "No inputs.");
      if (!this.isCoinbase())
        for (let _ = 0; _ < this.inputs.length; _++) {
          const { prevout: F } = this.inputs[_], R = A.getOutput(F);
          if (!R)
            throw new h("UNKNOWN_ERROR", "No coin available.");
          this.checkInput(_, R, q);
        }
    }
    /**
     * Verify a transaction input.
     * @param {Number} index - Index of output being
     * verified.
     * @param {Coin|Output} coin - Previous output.
     * @param {VerifyFlags} [flags=STANDARD_VERIFY_FLAGS]
     * @throws {ScriptError} on invalid input
     */
    checkInput(A, q, _) {
      const F = this.inputs[A];
      e(F, "Input does not exist."), e(q, "No coin passed."), o.verify(
        F.script,
        null,
        q.script,
        this,
        A,
        q.value,
        _
      );
    }
    /**
     * Verify the transaction inputs on the worker pool
     * (if workers are enabled).
     * @param {CoinView} view
     * @param {VerifyFlags?} [flags=STANDARD_VERIFY_FLAGS]
     * @param {WorkerPool?} pool
     * @returns {Promise}
     */
    async checkAsync(A, q, _) {
      if (this.inputs.length === 0)
        throw new h("UNKNOWN_ERROR", "No inputs.");
      if (!this.isCoinbase()) {
        if (!_) {
          this.check(A, q);
          return;
        }
        await _.check(this, A, q);
      }
    }
    /**
     * Verify a transaction input asynchronously.
     * @param {Number} index - Index of output being
     * verified.
     * @param {Coin|Output} coin - Previous output.
     * @param {VerifyFlags} [flags=STANDARD_VERIFY_FLAGS]
     * @param {WorkerPool?} pool
     * @returns {Promise}
     */
    async checkInputAsync(A, q, _, F) {
      const R = this.inputs[A];
      if (e(R, "Input does not exist."), e(q, "No coin passed."), !F) {
        this.checkInput(A, q, _);
        return;
      }
      await F.checkInput(this, A, q, _);
    }
    /**
     * Verify all transaction inputs.
     * @param {CoinView} view
     * @param {VerifyFlags?} [flags=STANDARD_VERIFY_FLAGS]
     * @returns {Boolean} Whether the inputs are valid.
     */
    verify(A, q) {
      try {
        this.check(A, q);
      } catch (_) {
        if (_.type === "ScriptError")
          return !1;
        throw _;
      }
      return !0;
    }
    /**
     * Verify a transaction input.
     * @param {Number} index - Index of output being
     * verified.
     * @param {Coin|Output} coin - Previous output.
     * @param {VerifyFlags} [flags=STANDARD_VERIFY_FLAGS]
     * @returns {Boolean} Whether the input is valid.
     */
    verifyInput(A, q, _) {
      try {
        this.checkInput(A, q, _);
      } catch (F) {
        if (F.type === "ScriptError")
          return !1;
        throw F;
      }
      return !0;
    }
    /**
     * Verify the transaction inputs on the worker pool
     * (if workers are enabled).
     * @param {CoinView} view
     * @param {VerifyFlags?} [flags=STANDARD_VERIFY_FLAGS]
     * @param {WorkerPool?} pool
     * @returns {Promise}
     */
    async verifyAsync(A, q, _) {
      try {
        await this.checkAsync(A, q, _);
      } catch (F) {
        if (F.type === "ScriptError")
          return !1;
        throw F;
      }
      return !0;
    }
    /**
     * Verify a transaction input asynchronously.
     * @param {Number} index - Index of output being
     * verified.
     * @param {Coin|Output} coin - Previous output.
     * @param {VerifyFlags} [flags=STANDARD_VERIFY_FLAGS]
     * @param {WorkerPool?} pool
     * @returns {Promise}
     */
    async verifyInputAsync(A, q, _, F) {
      try {
        await this.checkInput(A, q, _, F);
      } catch (R) {
        if (R.type === "ScriptError")
          return !1;
        throw R;
      }
      return !0;
    }
    /**
     * Test whether the transaction is a coinbase
     * by examining the inputs.
     * @returns {Boolean}
     */
    isCoinbase() {
      return this.inputs.length === 1 && this.inputs[0].prevout.isNull();
    }
    /**
     * Test whether the transaction is replaceable.
     * @returns {Boolean}
     */
    isRBF() {
      if (this.version === 2)
        return !1;
      for (const A of this.inputs)
        if (A.isRBF())
          return !0;
      return !1;
    }
    /**
     * Calculate the fee for the transaction.
     * @param {CoinView} view
     * @returns {Amount} fee (zero if not all coins are available).
     */
    getFee(A) {
      return this.hasCoins(A) ? this.getInputValue(A) - this.getOutputValue() : 0;
    }
    /**
     * Calculate the total input value.
     * @param {CoinView} view
     * @returns {Amount} value
     */
    getInputValue(A) {
      let q = 0;
      for (const { prevout: _ } of this.inputs) {
        const F = A.getOutput(_);
        if (!F)
          return 0;
        q += F.value;
      }
      return q;
    }
    /**
     * Calculate the total output value.
     * @returns {Amount} value
     */
    getOutputValue() {
      let A = 0;
      for (const q of this.outputs)
        A += q.value;
      return A;
    }
    /**
     * Get all input addresses.
     * @private
     * @param {CoinView} view
     * @returns {Array} [addrs, table]
     */
    _getInputAddresses(A) {
      const q = new m(), _ = [];
      if (this.isCoinbase())
        return [_, q];
      for (const F of this.inputs) {
        const R = A ? A.getOutputFor(F) : null, L = F.getAddress(R);
        if (!L)
          continue;
        const fe = L.getHash();
        q.has(fe) || (q.add(fe), _.push(L));
      }
      return [_, q];
    }
    /**
     * Get all output addresses.
     * @private
     * @returns {Array} [addrs, table]
     */
    _getOutputAddresses() {
      const A = new m(), q = [];
      for (const _ of this.outputs) {
        const F = _.getAddress();
        if (!F)
          continue;
        const R = F.getHash();
        A.has(R) || (A.add(R), q.push(F));
      }
      return [q, A];
    }
    /**
     * Get all addresses.
     * @private
     * @param {CoinView} view
     * @returns {Array} [addrs, table]
     */
    _getAddresses(A) {
      const [q, _] = this._getInputAddresses(A), F = this.getOutputAddresses();
      for (const R of F) {
        const L = R.getHash();
        _.has(L) || (_.add(L), q.push(R));
      }
      return [q, _];
    }
    /**
     * Get all input addresses.
     * @param {CoinView|null} view
     * @returns {Address[]} addresses
     */
    getInputAddresses(A) {
      const [q] = this._getInputAddresses(A);
      return q;
    }
    /**
     * Get all output addresses.
     * @returns {Address[]} addresses
     */
    getOutputAddresses() {
      const [A] = this._getOutputAddresses();
      return A;
    }
    /**
     * Get all addresses.
     * @param {CoinView|null} view
     * @returns {Address[]} addresses
     */
    getAddresses(A) {
      const [q] = this._getAddresses(A);
      return q;
    }
    /**
     * Get all input address hashes.
     * @param {CoinView|null} view
     * @returns {Hash[]} hashes
     */
    getInputHashes(A, q) {
      const [, _] = this._getInputAddresses(A);
      return q !== "hex" ? _.toArray() : _.toArray().map((F) => F.toString("hex"));
    }
    /**
     * Get all output address hashes.
     * @returns {Hash[]} hashes
     */
    getOutputHashes(A) {
      const [, q] = this._getOutputAddresses();
      return A !== "hex" ? q.toArray() : q.toArray().map((_) => _.toString("hex"));
    }
    /**
     * Get all address hashes.
     * @param {CoinView|null} view
     * @returns {Hash[]} hashes
     */
    getHashes(A, q) {
      const [, _] = this._getAddresses(A);
      return q !== "hex" ? _.toArray() : _.toArray().map((F) => F.toString("hex"));
    }
    /**
     * Test whether the transaction has
     * all coins available.
     * @param {CoinView} view
     * @returns {Boolean}
     */
    hasCoins(A) {
      if (this.inputs.length === 0)
        return !1;
      for (const { prevout: q } of this.inputs)
        if (!A.hasEntry(q))
          return !1;
      return !0;
    }
    /**
     * Check finality of transaction by examining
     * nLocktime and nSequence values.
     * @example
     * tx.isFinal(chain.height + 1, network.now());
     * @param {Number} height - Height at which to test. This
     * is usually the chain height, or the chain height + 1
     * when the transaction entered the mempool.
     * @param {Number} time - Time at which to test. This is
     * usually the chain tip's parent's median time, or the
     * time at which the transaction entered the mempool. If
     * MEDIAN_TIME_PAST is enabled this will be the median
     * time of the chain tip's previous entry's median time.
     * @returns {Boolean}
     */
    isFinal(A, q) {
      const _ = y.LOCKTIME_THRESHOLD;
      if (this.locktime === 0 || this.locktime < (this.locktime < _ ? A : q))
        return !0;
      for (const F of this.inputs)
        if (F.sequence !== 4294967295)
          return !1;
      return !0;
    }
    /**
     * Verify the absolute locktime of a transaction.
     * Called by OP_CHECKLOCKTIMEVERIFY.
     * @param {Number} index - Index of input being verified.
     * @param {Number} predicate - Locktime to verify against.
     * @returns {Boolean}
     */
    verifyLocktime(A, q) {
      const _ = y.LOCKTIME_THRESHOLD, F = this.inputs[A];
      return e(F, "Input does not exist."), e(q >= 0, "Locktime must be non-negative."), !(this.locktime < _ != q < _ || q > this.locktime || F.sequence === 4294967295);
    }
    /**
     * Verify the relative locktime of an input.
     * Called by OP_CHECKSEQUENCEVERIFY.
     * @param {Number} index - Index of input being verified.
     * @param {Number} predicate - Relative locktime to verify against.
     * @returns {Boolean}
     */
    verifySequence(A, q) {
      const _ = y.SEQUENCE_DISABLE_FLAG, F = y.SEQUENCE_TYPE_FLAG, R = y.SEQUENCE_MASK, L = this.inputs[A];
      return e(L, "Input does not exist."), e(q >= 0, "Locktime must be non-negative."), q & _ ? !0 : !(this.version < 2 || L.sequence & _ || (L.sequence & F) !== (q & F) || (q & R) > (L.sequence & R));
    }
    /**
     * Calculate legacy (inaccurate) sigop count.
     * @returns {Number} sigop count
     */
    getLegacySigops() {
      if (this._sigops !== -1)
        return this._sigops;
      let A = 0;
      for (const q of this.inputs)
        A += q.script.getSigops(!1);
      for (const q of this.outputs)
        A += q.script.getSigops(!1);
      return this.mutable || (this._sigops = A), A;
    }
    /**
     * Calculate accurate sigop count, taking into account redeem scripts.
     * @param {CoinView} view
     * @param {VerifyFlags} flags
     * @returns {Number} sigop count
     */
    getScripthashSigops(A, q) {
      if (this.isCoinbase())
        return 0;
      let _ = 0;
      for (const F of this.inputs) {
        const R = A.getOutputFor(F);
        R && R.script.isScripthash() && (_ += R.script.getScripthashSigops(F.script, q));
      }
      return _;
    }
    /**
     * Calculate sigops count.
     * @param {CoinView} view
     * @param {VerifyFlags?} flags
     * @returns {Number} sigop count
     */
    getSigopsCount(A, q) {
      q === null && (q = o.flags.STANDARD_VERIFY_FLAGS);
      let _ = this.getLegacySigops();
      return q & o.flags.VERIFY_P2SH && (_ += this.getScripthashSigops(A, q)), _;
    }
    /**
     * Calculate sigop count.
     * @param {CoinView} view
     * @param {VerifyFlags?} flags
     * @returns {Number} sigop count
     */
    getSigops(A, q) {
      return this.getSigopsCount(A, q);
    }
    /**
     * Non-contextual sanity checks for the transaction.
     * Will mostly verify coin and output values.
     * @see CheckTransaction()
     * @returns {Array} [result, reason, score]
     */
    isSane() {
      const [A] = this.checkSanity();
      return A;
    }
    /**
     * Non-contextual sanity checks for the transaction.
     * Will mostly verify coin and output values.
     * @see CheckTransaction()
     * @returns {Array} [valid, reason, score]
     */
    checkSanity() {
      if (this.inputs.length === 0)
        return [!1, "bad-txns-vin-empty", 100];
      if (this.outputs.length === 0)
        return [!1, "bad-txns-vout-empty", 100];
      if (this.getSize() > y.MAX_TX_SIZE)
        return [!1, "bad-txns-oversize", 100];
      let A = 0;
      for (const _ of this.outputs) {
        if (_.value < 0)
          return [!1, "bad-txns-vout-negative", 100];
        if (_.value > y.MAX_MONEY)
          return [!1, "bad-txns-vout-toolarge", 100];
        if (A += _.value, A < 0 || A > y.MAX_MONEY)
          return [!1, "bad-txns-txouttotal-toolarge", 100];
      }
      const q = new m();
      for (const _ of this.inputs) {
        const F = _.prevout.toKey();
        if (q.has(F))
          return [!1, "bad-txns-inputs-duplicate", 100];
        q.add(F);
      }
      if (this.isCoinbase()) {
        const _ = this.inputs[0].script.getSize();
        if (_ < 2 || _ > y.MAX_COINBASE_SCRIPTSIG_SIZE)
          return [!1, "bad-cb-length", 100];
      } else
        for (const _ of this.inputs)
          if (_.prevout.isNull())
            return [!1, "bad-txns-prevout-null", 10];
      return [!0, "valid", 0];
    }
    /**
     * Non-contextual checks to determine whether the
     * transaction has all standard output script
     * types and standard input script size with only
     * pushdatas in the code.
     * Will mostly verify coin and output values.
     * @see IsStandardTx()
     * @returns {Array} [valid, reason, score]
     */
    isStandard() {
      const [A] = this.checkStandard();
      return A;
    }
    /**
     * Non-contextual checks to determine whether the
     * transaction has all standard output script
     * types and standard input script size with only
     * pushdatas in the code.
     * Will mostly verify coin and output values.
     * @see IsStandardTx()
     * @returns {Array} [valid, reason, score]
     */
    checkStandard() {
      if (this.version < 1 || this.version > b.MAX_TX_VERSION)
        return [!1, "version", 0];
      if (this.getSize() >= b.MAX_TX_SIZE)
        return [!1, "tx-size", 0];
      for (const q of this.inputs) {
        if (q.script.getSize() > 1650)
          return [!1, "scriptsig-size", 0];
        if (!q.script.isPushOnly())
          return [!1, "scriptsig-not-pushonly", 0];
      }
      let A = 0;
      for (const q of this.outputs) {
        if (!q.script.isStandard())
          return [!1, "scriptpubkey", 0];
        if (q.script.isNulldata()) {
          A++;
          continue;
        }
        if (q.script.isMultisig() && !b.BARE_MULTISIG)
          return [!1, "bare-multisig", 0];
        if (q.isDust(b.MIN_RELAY))
          return [!1, "dust", 0];
      }
      return A > 1 ? [!1, "multi-op-return", 0] : [!0, "valid", 0];
    }
    /**
     * Perform contextual checks to verify coin and input
     * script standardness (including the redeem script).
     * @see AreInputsStandard()
     * @param {CoinView} view
     * @param {VerifyFlags?} flags
     * @returns {Boolean}
     */
    hasStandardInputs(A) {
      if (this.isCoinbase())
        return !0;
      for (const q of this.inputs) {
        const _ = A.getOutputFor(q);
        if (!_)
          return !1;
        if (!_.script.isPubkeyhash()) {
          if (_.script.isScripthash()) {
            const F = q.script.getRedeem();
            if (!F || F.getSigops(!0) > b.MAX_P2SH_SIGOPS)
              return !1;
            continue;
          }
          if (_.script.isUnknown())
            return !1;
        }
      }
      return !0;
    }
    /**
     * Perform contextual checks to verify input, output,
     * and fee values, as well as coinbase spend maturity
     * (coinbases can only be spent 100 blocks or more
     * after they're created). Note that this function is
     * consensus critical.
     * @param {CoinView} view
     * @param {Number} height - Height at which the
     * transaction is being spent. In the mempool this is
     * the chain height plus one at the time it entered the pool.
     * @returns {Boolean}
     */
    verifyInputs(A, q) {
      const [_] = this.checkInputs(A, q);
      return _ !== -1;
    }
    /**
     * Perform contextual checks to verify input, output,
     * and fee values, as well as coinbase spend maturity
     * (coinbases can only be spent 100 blocks or more
     * after they're created). Note that this function is
     * consensus critical.
     * @param {CoinView} view
     * @param {Number} height - Height at which the
     * transaction is being spent. In the mempool this is
     * the chain height plus one at the time it entered the pool.
     * @returns {Array} [fee, reason, score]
     */
    checkInputs(A, q) {
      e(typeof q == "number");
      let _ = 0;
      for (const { prevout: L } of this.inputs) {
        const fe = A.getEntry(L);
        if (!fe)
          return [-1, "bad-txns-inputs-missingorspent", 0];
        if (fe.coinbase && q - fe.height < y.COINBASE_MATURITY)
          return [-1, "bad-txns-premature-spend-of-coinbase", 0];
        const ue = A.getOutput(L);
        if (e(ue), ue.value < 0 || ue.value > y.MAX_MONEY)
          return [-1, "bad-txns-inputvalues-outofrange", 100];
        if (_ += ue.value, _ < 0 || _ > y.MAX_MONEY)
          return [-1, "bad-txns-inputvalues-outofrange", 100];
      }
      const F = this.getOutputValue();
      if (_ < F)
        return [-1, "bad-txns-in-belowout", 100];
      const R = _ - F;
      return R < 0 ? [-1, "bad-txns-fee-negative", 100] : R > y.MAX_MONEY ? [-1, "bad-txns-fee-outofrange", 100] : [R, "valid", 0];
    }
    /**
     * Calculate the modified size of the transaction. This
     * is used in the mempool for calculating priority.
     * @param {Number?} size - The size to modify. If not present,
     * virtual size will be used.
     * @returns {Number} Modified size.
     */
    getModifiedSize(A) {
      A == null && (A = this.getSize());
      for (const q of this.inputs) {
        const _ = 41 + Math.min(110, q.script.getSize());
        A > _ && (A -= _);
      }
      return A;
    }
    /**
     * Calculate the transaction priority.
     * @param {CoinView} view
     * @param {Number} height
     * @param {Number?} size - Size to calculate priority
     * based on. If not present, virtual size will be used.
     * @returns {Number}
     */
    getPriority(A, q, _) {
      if (e(typeof q == "number", "Must pass in height."), this.isCoinbase())
        return 0;
      _ == null && (_ = this.getSize());
      let F = 0;
      for (const { prevout: R } of this.inputs) {
        const L = A.getOutput(R);
        if (!L)
          continue;
        const fe = A.getHeight(R);
        if (fe !== -1 && fe <= q) {
          const ue = q - fe;
          F += L.value * ue;
        }
      }
      return Math.floor(F / _);
    }
    /**
     * Calculate the transaction's on-chain value.
     * @param {CoinView} view
     * @returns {Number}
     */
    getChainValue(A) {
      if (this.isCoinbase())
        return 0;
      let q = 0;
      for (const { prevout: _ } of this.inputs) {
        const F = A.getOutput(_);
        !F || A.getHeight(_) === -1 || (q += F.value);
      }
      return q;
    }
    /**
     * Determine whether the transaction is above the
     * free threshold in priority. A transaction which
     * passed this test is most likely relayable
     * without a fee.
     * @param {CoinView} view
     * @param {Number?} height - If not present, tx
     * height or network height will be used.
     * @param {Number?} size - If not present, modified
     * size will be calculated and used.
     * @returns {Boolean}
     */
    isFree(A, q, _) {
      return this.getPriority(A, q, _) > b.FREE_THRESHOLD;
    }
    /**
     * Calculate minimum fee in order for the transaction
     * to be relayable (not the constant min relay fee).
     * @param {Number?} size - If not present, max size
     * estimation will be calculated and used.
     * @param {Rate?} rate - Rate of satoshi per kB.
     * @returns {Amount} fee
     */
    getMinFee(A, q) {
      return A == null && (A = this.getSize()), b.getMinFee(A, q);
    }
    /**
     * Calculate the minimum fee in order for the transaction
     * to be relayable, but _round to the nearest kilobyte
     * when taking into account size.
     * @param {Number?} size - If not present, max size
     * estimation will be calculated and used.
     * @param {Rate?} rate - Rate of satoshi per kB.
     * @returns {Amount} fee
     */
    getRoundFee(A, q) {
      return A == null && (A = this.getSize()), b.getRoundFee(A, q);
    }
    /**
     * Calculate the transaction's rate based on size
     * and fees. Size will be calculated if not present.
     * @param {CoinView} view
     * @param {Number?} size
     * @returns {Rate}
     */
    getRate(A, q) {
      const _ = this.getFee(A);
      return _ < 0 ? 0 : (q == null && (q = this.getSize()), b.getRate(q, _));
    }
    /**
     * Get all unique outpoint hashes.
     * @returns {Hash[]} Outpoint hashes.
     */
    getPrevout() {
      if (this.isCoinbase())
        return [];
      const A = new m();
      for (const q of this.inputs)
        A.add(q.prevout.hash);
      return A.toArray();
    }
    /**
     * Test a transaction against a bloom filter using
     * the BIP37 matching algorithm. Note that this may
     * update the filter depending on what the `update`
     * value is.
     * @see "Filter matching algorithm":
     * @see https://github.com/bitcoin/bips/blob/master/bip-0037.mediawiki
     * @param {BloomFilter} filter
     * @returns {Boolean} True if the transaction matched.
     */
    isWatched(A) {
      let q = !1;
      A.test(this.hash()) && (q = !0);
      for (let _ = 0; _ < this.outputs.length; _++) {
        const F = this.outputs[_];
        if (F.script.test(A)) {
          if (A.update === 1) {
            const R = g.fromTX(this, _);
            A.add(R.toRaw());
          } else if (A.update === 2 && (F.script.isPubkey() || F.script.isMultisig())) {
            const R = g.fromTX(this, _);
            A.add(R.toRaw());
          }
          q = !0;
        }
      }
      if (q)
        return q;
      for (const _ of this.inputs) {
        const F = _.prevout;
        if (A.test(F.toRaw()) || _.script.test(A))
          return !0;
      }
      return !1;
    }
    /**
     * Get little-endian tx hash.
     * @returns {Hash}
     */
    rhash() {
      return f.revHex(this.hash());
    }
    /**
     * Get little-endian tx hash.
     * @returns {Hash}
     */
    txid() {
      return this.rhash();
    }
    /**
     * Convert the tx to an inv item.
     * @returns {InvItem}
     */
    toInv() {
      return new S(S.types.TX, this.hash());
    }
    /**
     * Inspect the transaction and return a more
     * user-friendly representation of the data.
     * @returns {Object}
     */
    [j]() {
      return this.format();
    }
    /**
     * Inspect the transaction and return a more
     * user-friendly representation of the data.
     * @param {CoinView} view
     * @param {ChainEntry} entry
     * @param {Number} index
     * @returns {Object}
     */
    format(A, q, _) {
      let F = 0, R = 0, L = -1, fe = null, ue = 0, ae = null;
      A && (R = this.getFee(A), F = this.getRate(A), Number.isSafeInteger(F) || (F = 0)), q && (L = q.height, fe = f.revHex(q.hash), ue = q.time, ae = f.date(ue)), _ == null && (_ = -1);
      const D = {
        hash: this.txid(),
        size: this.getSize(),
        value: n.btc(this.getOutputValue()),
        fee: n.btc(R),
        rate: n.btc(F),
        minFee: n.btc(this.getMinFee()),
        height: L,
        block: fe,
        time: ue,
        date: ae,
        index: _,
        version: this.version,
        inputs: this.inputs.map((Q) => {
          const W = A ? A.getOutputFor(Q) : null;
          return Q.format(W);
        }),
        outputs: this.outputs,
        locktime: this.locktime
      };
      return this.slpToken ? {
        ...D,
        slpToken: this.slpToken
      } : D;
    }
    /**
     * Convert the transaction to an object suitable
     * for JSON serialization.
     * @returns {Object}
     */
    toJSON() {
      return this.getJSON();
    }
    /**
     * Convert the transaction to an object suitable
     * for JSON serialization. Note that the hashes
     * will be reversed to abide by bitcoind's legacy
     * of little-endian uint256s.
     * @param {Network} network
     * @param {CoinView} view
     * @param {ChainEntry} entry
     * @param {Number} index
     * @returns {Object}
     */
    getJSON(A, q, _, F) {
      let R, L, fe, ue, ae, D;
      q && (L = this.getFee(q), R = this.getRate(q), Number.isSafeInteger(R) || (R = 0)), _ && (fe = _.height, ue = f.revHex(_.hash), ae = _.time, D = f.date(ae)), A = u.get(A);
      const Q = {
        hash: this.txid(),
        fee: L,
        rate: R,
        mtime: f.now(),
        height: fe,
        block: ue,
        time: ae,
        date: D,
        index: F,
        version: this.version,
        inputs: this.inputs.map((W) => {
          const oe = q ? q.getCoinFor(W) : null;
          return W.getJSON(A, oe);
        }),
        outputs: this.outputs.map((W) => W.getJSON(A)),
        locktime: this.locktime,
        hex: this.toRaw().toString("hex")
      };
      return this.slpToken ? {
        ...Q,
        slpToken: this.slpToken.getJSON()
      } : Q;
    }
    /**
     * Inject properties from a json object.
     * @private
     * @param {Object} json
     */
    fromJSON(A) {
      e(A, "TX data is required."), e(A.version >>> 0 === A.version, "Version must be a uint32."), e(Array.isArray(A.inputs), "Inputs must be an array."), e(Array.isArray(A.outputs), "Outputs must be an array."), e(
        A.locktime >>> 0 === A.locktime,
        "Locktime must be a uint32."
      ), this.version = A.version;
      for (const q of A.inputs)
        this.inputs.push(i.fromJSON(q));
      for (const q of A.outputs)
        this.outputs.push(p.fromJSON(q));
      return this.locktime = A.locktime, A.slpToken && (this.slpToken = s.TokenRecord().fromJSON(A.slpToken)), this;
    }
    /**
     * Instantiate a transaction from a
     * jsonified transaction object.
     * @param {Object} json - The jsonified transaction object.
     * @returns {TX}
     */
    static fromJSON(A) {
      return new this().fromJSON(A);
    }
    /**
     * Instantiate a transaction from a serialized Buffer.
     * @param {Buffer} data
     * @param {String?} enc - Encoding, can be `'hex'` or null.
     * @returns {TX}
     */
    static fromRaw(A, q) {
      return typeof A == "string" && (A = k.from(A, q)), new this().fromRaw(A);
    }
    /**
     * Instantiate a transaction from a buffer reader.
     * @param {BufferReader} br
     * @param {Boolean} block
     * @returns {TX}
     */
    static fromReader(A, q) {
      return new this().fromReader(A, q);
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     */
    fromRaw(A) {
      return this.fromReader(c.read(A));
    }
    /**
     * Inject properties from buffer reader.
     * @private
     * @param {BufferReader} br
     * @param {Boolean} block
     */
    fromReader(A, q) {
      const _ = A.start();
      this.version = A.readU32();
      const F = A.readVarint();
      for (let L = 0; L < F; L++)
        this.inputs.push(i.fromReader(A));
      const R = A.readVarint();
      for (let L = 0; L < R; L++)
        this.outputs.push(p.fromReader(A));
      return this.locktime = A.readU32(), q && (this._offset = _, this._block = !0), this.mutable ? A.end() : (this._raw = A.endData(), this._size = this._raw.length), this;
    }
    /**
     * Serialize transaction without witness.
     * @private
     * @returns {RawTX}
     */
    frameNormal() {
      const A = this.getNormalSizes(), q = c.write(A.size);
      return this.writeNormal(q), A.data = q.render(), A;
    }
    /**
     * Serialize transaction without witness.
     * @private
     * @param {BufferWriter} bw
     * @returns {RawTX}
     */
    writeNormal(A) {
      if (this.inputs.length === 0 && this.outputs.length !== 0)
        throw new Error("Cannot serialize zero-input tx.");
      A.writeU32(this.version), A.writeVarint(this.inputs.length);
      for (const q of this.inputs)
        q.toWriter(A);
      A.writeVarint(this.outputs.length);
      for (const q of this.outputs)
        q.toWriter(A);
      return A.writeU32(this.locktime), A;
    }
    /**
     * Calculate the real size of the transaction
     * without the witness vector.
     * @returns {RawTX}
     */
    getNormalSizes() {
      let A = 0;
      A += 4, A += a.sizeVarint(this.inputs.length);
      for (const q of this.inputs)
        A += q.getSize();
      A += a.sizeVarint(this.outputs.length);
      for (const q of this.outputs)
        A += q.getSize();
      return A += 4, new N(A, 0);
    }
    /**
     * Test whether an object is a TX.
     * @param {Object} obj
     * @returns {Boolean}
     */
    static isTX(A) {
      return A instanceof G;
    }
  }
  class N {
    constructor(A) {
      this.data = null, this.size = A;
    }
  }
  return d0 = G, d0;
}
/*!
 * headers.js - headers object for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var b0, q2;
function ns() {
  if (q2) return b0;
  q2 = 1;
  const e = Bt, c = pr(), l = rs(), { inspectSymbol: w } = cr();
  class m extends l {
    /**
     * Create headers.
     * @constructor
     * @param {Object} options
     */
    constructor(n) {
      super(), n && this.parseOptions(n);
    }
    /**
     * Perform non-contextual
     * verification on the headers.
     * @returns {Boolean}
     */
    verifyBody() {
      return !0;
    }
    /**
     * Get size of the headers.
     * @returns {Number}
     */
    getSize() {
      return 81;
    }
    /**
     * Serialize the headers to a buffer writer.
     * @param {BufferWriter} bw
     */
    toWriter(n) {
      return this.writeHead(n), n.writeVarint(0), n;
    }
    /**
     * Serialize the headers.
     * @returns {Buffer|String}
     */
    toRaw() {
      const n = this.getSize();
      return this.toWriter(e.write(n)).render();
    }
    /**
     * Inject properties from buffer reader.
     * @private
     * @param {Buffer} data
     */
    fromReader(n) {
      return this.readHead(n), n.readVarint(), this;
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     */
    fromRaw(n) {
      return this.fromReader(e.read(n));
    }
    /**
     * Instantiate headers from buffer reader.
     * @param {BufferReader} br
     * @returns {Headers}
     */
    static fromReader(n) {
      return new this().fromReader(n);
    }
    /**
     * Instantiate headers from serialized data.
     * @param {Buffer} data
     * @param {String?} enc - Encoding, can be `'hex'` or null.
     * @returns {Headers}
     */
    static fromRaw(n, u) {
      return typeof n == "string" && (n = k.from(n, u)), new this().fromRaw(n);
    }
    /**
     * Instantiate headers from serialized data.
     * @param {Buffer} data
     * @param {String?} enc - Encoding, can be `'hex'` or null.
     * @returns {Headers}
     */
    static fromHead(n, u) {
      return typeof n == "string" && (n = k.from(n, u)), new this().fromHead(n);
    }
    /**
     * Instantiate headers from a chain entry.
     * @param {ChainEntry} entry
     * @returns {Headers}
     */
    static fromEntry(n) {
      const u = new this();
      return u.version = n.version, u.prevBlock = n.prevBlock, u.merkleRoot = n.merkleRoot, u.time = n.time, u.bits = n.bits, u.nonce = n.nonce, u._hash = n.hash, u._hhash = n.hash, u;
    }
    /**
     * Convert the block to a headers object.
     * @returns {Headers}
     */
    toHeaders() {
      return this;
    }
    /**
     * Convert the block to a headers object.
     * @param {Block|MerkleBlock} block
     * @returns {Headers}
     */
    static fromBlock(n) {
      const u = new this(n);
      return u._hash = n._hash, u._hhash = n._hhash, u;
    }
    /**
     * Convert the block to an object suitable
     * for JSON serialization.
     * @returns {Object}
     */
    toJSON() {
      return this.getJSON();
    }
    /**
     * Convert the block to an object suitable
     * for JSON serialization. Note that the hashes
     * will be reversed to abide by bitcoind's legacy
     * of little-endian uint256s.
     * @param {Network} network
     * @param {CoinView} view
     * @param {Number} height
     * @returns {Object}
     */
    getJSON(n, u, o) {
      return {
        hash: this.rhash(),
        height: o,
        version: this.version,
        prevBlock: c.revHex(this.prevBlock),
        merkleRoot: c.revHex(this.merkleRoot),
        time: this.time,
        bits: this.bits,
        nonce: this.nonce
      };
    }
    /**
     * Inject properties from json object.
     * @private
     * @param {Object} json
     */
    fromJSON(n) {
      return this.parseJSON(n), this;
    }
    /**
     * Instantiate a merkle block from a jsonified block object.
     * @param {Object} json - The jsonified block object.
     * @returns {Headers}
     */
    static fromJSON(n) {
      return new this().fromJSON(n);
    }
    /**
     * Inspect the headers and return a more
     * user-friendly representation of the data.
     * @returns {Object}
     */
    [w]() {
      return this.format();
    }
    /**
     * Inspect the headers and return a more
     * user-friendly representation of the data.
     * @param {CoinView} view
     * @param {Number} height
     * @returns {Object}
     */
    format(n, u) {
      return {
        hash: this.rhash(),
        height: u ?? -1,
        date: c.date(this.time),
        version: this.version.toString(16),
        prevBlock: c.revHex(this.prevBlock),
        merkleRoot: c.revHex(this.merkleRoot),
        time: this.time,
        bits: this.bits,
        nonce: this.nonce
      };
    }
    /**
     * Test an object to see if it is a Headers object.
     * @param {Object} obj
     * @returns {Boolean}
     */
    static isHeaders(n) {
      return n instanceof m;
    }
  }
  return b0 = m, b0;
}
/*!
 * merkleblock.js - merkleblock object for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var p0, T2;
function Dl() {
  if (T2) return p0;
  T2 = 1;
  const e = dt, c = Bt, { BufferMap: l, BufferSet: w } = xn, m = pr(), f = qr(), n = Xt(), u = rs(), o = ns(), s = k.from([0]), { encoding: i } = c, { inspectSymbol: p } = cr();
  class g extends u {
    /**
     * Create a merkle block.
     * @constructor
     * @param {Object} options
     */
    constructor(b) {
      super(), this.txs = [], this.hashes = [], this.flags = s, this.totalTX = 0, this._tree = null, b && this.fromOptions(b);
    }
    /**
     * Inject properties from options object.
     * @private
     * @param {Object} options
     */
    fromOptions(b) {
      if (this.parseOptions(b), e(b, "MerkleBlock data is required."), e(Array.isArray(b.hashes)), e(k.isBuffer(b.flags)), e(b.totalTX >>> 0 === b.totalTX), b.hashes)
        for (const h of b.hashes)
          e(k.isBuffer(h)), this.hashes.push(h);
      return b.flags && (e(k.isBuffer(b.flags)), this.flags = b.flags), b.totalTX != null && (e(b.totalTX >>> 0 === b.totalTX), this.totalTX = b.totalTX), this;
    }
    /**
     * Instantiate merkle block from options object.
     * @param {Object} options
     * @returns {MerkleBlock}
     */
    static fromOptions(b) {
      return new this().fromOptions(b);
    }
    /**
     * Clear any cached values.
     * @param {Boolean?} all - Clear transactions.
     */
    refresh(b) {
      if (this._refresh(), this._tree = null, !!b)
        for (const h of this.txs)
          h.refresh();
    }
    /**
     * Test the block's _matched_ transaction vector against a hash.
     * @param {Hash} hash
     * @returns {Boolean}
     */
    hasTX(b) {
      return this.indexOf(b) !== -1;
    }
    /**
     * Test the block's _matched_ transaction vector against a hash.
     * @param {Hash} hash
     * @returns {Number} Index.
     */
    indexOf(b) {
      const a = this.getTree().map.get(b);
      return a ?? -1;
    }
    /**
     * Verify the partial merkletree.
     * @private
     * @returns {Boolean}
     */
    verifyBody() {
      const [b] = this.checkBody();
      return b;
    }
    /**
     * Verify the partial merkletree.
     * @private
     * @returns {Array} [valid, reason, score]
     */
    checkBody() {
      return this.getTree().root.equals(this.merkleRoot) ? [!0, "valid", 0] : [!1, "bad-txnmrklroot", 100];
    }
    /**
     * Extract the matches from partial merkle
     * tree and calculate merkle root.
     * @returns {Object}
     */
    getTree() {
      if (!this._tree)
        try {
          this._tree = this.extractTree();
        } catch {
          this._tree = new S();
        }
      return this._tree;
    }
    /**
     * Extract the matches from partial merkle
     * tree and calculate merkle root.
     * @private
     * @returns {Object}
     */
    extractTree() {
      const b = [], h = [], a = new l(), E = this.hashes, H = this.flags, j = this.totalTX;
      let G = 0, N = 0, T = !1, A = 0;
      const q = (R) => j + (1 << R) - 1 >>> R, _ = (R, L) => {
        if (G >= H.length * 8)
          return T = !0, n.ZERO_HASH;
        const fe = H[G / 8 | 0] >>> G % 8 & 1;
        if (G += 1, R === 0 || !fe) {
          if (N >= E.length)
            return T = !0, n.ZERO_HASH;
          const D = E[N];
          return N += 1, R === 0 && fe && (b.push(D), h.push(L), a.set(D, L)), D;
        }
        const ue = _(R - 1, L * 2);
        let ae;
        return L * 2 + 1 < q(R - 1) ? (ae = _(R - 1, L * 2 + 1), ae.equals(ue) && (T = !0)) : ae = ue, f.root(ue, ae);
      };
      if (j === 0)
        throw new Error("Zero transactions.");
      if (E.length > j)
        throw new Error("Too many hashes.");
      if (H.length * 8 < E.length)
        throw new Error("Flags too small.");
      for (; q(A) > 1; )
        A += 1;
      const F = _(A, 0);
      if (T)
        throw new Error("Mutated merkle tree.");
      if (((G + 7) / 8 | 0) !== H.length)
        throw new Error("Too many flag bits.");
      if (N !== E.length)
        throw new Error("Incorrect number of hashes.");
      return new S(F, b, h, a);
    }
    /**
     * Extract the coinbase height (always -1).
     * @returns {Number}
     */
    getCoinbaseHeight() {
      return -1;
    }
    /**
     * Inspect the block and return a more
     * user-friendly representation of the data.
     * @returns {Object}
     */
    [p]() {
      return this.format();
    }
    /**
     * Inspect the block and return a more
     * user-friendly representation of the data.
     * @param {CoinView} view
     * @param {Number} height
     * @returns {Object}
     */
    format(b, h) {
      return {
        hash: this.rhash(),
        height: h ?? -1,
        date: m.date(this.time),
        version: this.version.toString(16),
        prevBlock: m.revHex(this.prevBlock),
        merkleRoot: m.revHex(this.merkleRoot),
        time: this.time,
        bits: this.bits,
        nonce: this.nonce,
        totalTX: this.totalTX,
        hashes: this.hashes.map((a) => a.toString("hex")),
        flags: this.flags,
        map: this.getTree().map,
        txs: this.txs.length
      };
    }
    /**
     * Get merkleblock size.
     * @returns {Number} Size.
     */
    getSize() {
      let b = 0;
      return b += 80, b += 4, b += i.sizeVarint(this.hashes.length), b += this.hashes.length * 32, b += i.sizeVarint(this.flags.length), b += this.flags.length, b;
    }
    /**
     * Write the merkleblock to a buffer writer.
     * @param {BufferWriter} bw
     */
    toWriter(b) {
      this.writeHead(b), b.writeU32(this.totalTX), b.writeVarint(this.hashes.length);
      for (const h of this.hashes)
        b.writeHash(h);
      return b.writeVarBytes(this.flags), b;
    }
    /**
     * Serialize the merkleblock.
     * @param {String?} enc - Encoding, can be `'hex'` or null.
     * @returns {Buffer|String}
     */
    toRaw() {
      const b = this.getSize();
      return this.toWriter(c.write(b)).render();
    }
    /**
     * Inject properties from buffer reader.
     * @private
     * @param {BufferReader} br
     */
    fromReader(b) {
      this.readHead(b), this.totalTX = b.readU32();
      const h = b.readVarint();
      for (let a = 0; a < h; a++)
        this.hashes.push(b.readHash());
      return this.flags = b.readVarBytes(), this;
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     */
    fromRaw(b) {
      return this.fromReader(c.read(b));
    }
    /**
     * Instantiate a merkleblock from a buffer reader.
     * @param {BufferReader} br
     * @returns {MerkleBlock}
     */
    static fromReader(b) {
      return new this().fromReader(b);
    }
    /**
     * Instantiate a merkleblock from a serialized data.
     * @param {Buffer} data
     * @param {String?} enc - Encoding, can be `'hex'` or null.
     * @returns {MerkleBlock}
     */
    static fromRaw(b, h) {
      return typeof b == "string" && (b = k.from(b, h)), new this().fromRaw(b);
    }
    /**
     * Convert the block to an object suitable
     * for JSON serialization.
     * @returns {Object}
     */
    toJSON() {
      return this.getJSON();
    }
    /**
     * Convert the block to an object suitable
     * for JSON serialization. Note that the hashes
     * will be reversed to abide by bitcoind's legacy
     * of little-endian uint256s.
     * @param {Network} network
     * @param {CoinView} view
     * @param {Number} height
     * @returns {Object}
     */
    getJSON(b, h, a) {
      return {
        hash: this.rhash(),
        height: a,
        version: this.version,
        prevBlock: m.revHex(this.prevBlock),
        merkleRoot: m.revHex(this.merkleRoot),
        time: this.time,
        bits: this.bits,
        nonce: this.nonce,
        totalTX: this.totalTX,
        hashes: this.hashes.map((E) => m.revHex(E)),
        flags: this.flags.toString("hex")
      };
    }
    /**
     * Inject properties from json object.
     * @private
     * @param {Object} json
     */
    fromJSON(b) {
      e(b, "MerkleBlock data is required."), e(Array.isArray(b.hashes)), e(typeof b.flags == "string"), e(b.totalTX >>> 0 === b.totalTX), this.parseJSON(b);
      for (const h of b.hashes)
        this.hashes.push(m.fromRev(h));
      return this.flags = k.from(b.flags, "hex"), this.totalTX = b.totalTX, this;
    }
    /**
     * Instantiate a merkle block from a jsonified block object.
     * @param {Object} json - The jsonified block object.
     * @returns {MerkleBlock}
     */
    static fromJSON(b) {
      return new this().fromJSON(b);
    }
    /**
     * Create a merkleblock from a {@link Block} object, passing
     * it through a filter first. This will build the partial
     * merkle tree.
     * @param {Block} block
     * @param {Bloom} filter
     * @returns {MerkleBlock}
     */
    static fromBlock(b, h) {
      const a = [];
      for (const E of b.txs)
        a.push(E.isWatched(h) ? 1 : 0);
      return this.fromMatches(b, a);
    }
    /**
     * Create a merkleblock from an array of txids.
     * This will build the partial merkle tree.
     * @param {Block} block
     * @param {Hash[]} hashes
     * @returns {MerkleBlock}
     */
    static fromHashes(b, h) {
      const a = new w();
      for (const H of h)
        a.add(H);
      const E = [];
      for (const H of b.txs) {
        const j = H.hash();
        E.push(a.has(j) ? 1 : 0);
      }
      return this.fromMatches(b, E);
    }
    /**
     * Create a merkleblock from an array of matches.
     * This will build the partial merkle tree.
     * @param {Block} block
     * @param {Number[]} matches
     * @returns {MerkleBlock}
     */
    static fromMatches(b, h) {
      const a = [], E = [], H = [], j = [], G = b.txs.length;
      let N = 0;
      const T = (R) => G + (1 << R) - 1 >>> R, A = (R, L, fe) => {
        if (R === 0)
          return fe[L];
        const ue = A(R - 1, L * 2, fe);
        let ae;
        return L * 2 + 1 < T(R - 1) ? ae = A(R - 1, L * 2 + 1, fe) : ae = ue, f.root(ue, ae);
      }, q = (R, L, fe, ue) => {
        let ae = 0;
        for (let D = L << R; D < L + 1 << R && D < G; D++)
          ae |= ue[D];
        if (H.push(ae), R === 0 || !ae) {
          j.push(A(R, L, fe));
          return;
        }
        q(R - 1, L * 2, fe, ue), L * 2 + 1 < T(R - 1) && q(R - 1, L * 2 + 1, fe, ue);
      };
      for (let R = 0; R < b.txs.length; R++) {
        const L = b.txs[R];
        h[R] && a.push(L), E.push(L.hash());
      }
      for (; T(N) > 1; )
        N += 1;
      q(N, 0, E, h);
      const _ = k.allocUnsafe((H.length + 7) / 8 | 0);
      _.fill(0);
      for (let R = 0; R < H.length; R++)
        _[R / 8 | 0] |= H[R] << R % 8;
      const F = new this();
      return F._hash = b._hash, F._hhash = b._hhash, F.version = b.version, F.prevBlock = b.prevBlock, F.merkleRoot = b.merkleRoot, F.time = b.time, F.bits = b.bits, F.nonce = b.nonce, F.totalTX = G, F.hashes = j, F.flags = _, F.txs = a, F;
    }
    /**
     * Test whether an object is a MerkleBlock.
     * @param {Object} obj
     * @returns {Boolean}
     */
    static isMerkleBlock(b) {
      return b instanceof g;
    }
    /**
     * Convert the block to a headers object.
     * @returns {Headers}
     */
    toHeaders() {
      return o.fromBlock(this);
    }
  }
  class S {
    constructor(b, h, a, E) {
      this.root = b || n.ZERO_HASH, this.matches = h || [], this.indexes = a || [], this.map = E || new l();
    }
  }
  return p0 = g, p0;
}
/*!
 * block.js - block object for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var m0, z2;
function Ul() {
  if (z2) return m0;
  z2 = 1;
  const e = dt, c = Bt, { BufferSet: l } = xn, w = qr(), m = N7(), f = Xt(), n = rs(), u = is(), o = Dl(), s = ns(), i = Tr(), p = pr(), { encoding: g } = c, { inspectSymbol: S } = cr();
  class y extends n {
    /**
     * Create a block.
     * @constructor
     * @param {Object} options
     */
    constructor(a) {
      super(), this.txs = [], this._raw = null, this._size = -1, a && this.fromOptions(a);
    }
    /**
     * Inject properties from options object.
     * @private
     * @param {Object} options
     */
    fromOptions(a) {
      if (this.parseOptions(a), a.txs) {
        e(Array.isArray(a.txs));
        for (const E of a.txs)
          e(E instanceof u), this.txs.push(E);
      }
      return this;
    }
    /**
     * Instantiate block from options.
     * @param {Object} options
     * @returns {Block}
     */
    static fromOptions(a) {
      return new this().fromOptions(a);
    }
    /**
     * Clear any cached values.
     * @param {Boolean?} all - Clear transactions.
     */
    refresh(a) {
      if (this._refresh(), this._raw = null, this._size = -1, !a)
        return this;
      for (const E of this.txs)
        E.refresh();
      return this;
    }
    /**
     * Serialize the block.
     * @returns {Buffer}
     */
    toRaw() {
      return this.frame().data;
    }
    /**
     * Check if block has been serialized.
     * @returns {Buffer}
     */
    hasRaw() {
      return !!this._raw;
    }
    /**
     * Serialize the block.
     * @returns {Buffer}
     */
    toNormal() {
      return this.toRaw();
    }
    /**
     * Serialize the block.
     * @param {BufferWriter} bw
     */
    toWriter(a) {
      if (this.mutable)
        return this.writeNormal(a);
      const E = this.frame();
      return a.writeBytes(E.data), a;
    }
    /**
     * Serialize the block.
     * @param {BufferWriter} bw
     */
    toNormalWriter(a) {
      return this.toWriter(a);
    }
    /**
     * Get the raw block serialization.
     * @private
     * @returns {RawBlock}
     */
    frame() {
      if (this.mutable)
        return e(!this._raw), this.frameNormal();
      if (this._raw) {
        e(this._size >= 0);
        const E = new b(this._size);
        return E.data = this._raw, E;
      }
      const a = this.frameNormal();
      return this._raw = a.data, this._size = a.size, a;
    }
    /**
     * Calculate real block size.
     * @returns {Object} Contains `size`
     */
    getSize() {
      return this.mutable ? this.getNormalSizes().size : this.frame().size;
    }
    /**
     * Test the block's transaction vector against a hash.
     * @param {Hash} hash
     * @returns {Boolean}
     */
    hasTX(a) {
      return this.indexOf(a) !== -1;
    }
    /**
     * Find the index of a transaction in the block.
     * @param {Hash} hash
     * @returns {Number} index (-1 if not present).
     */
    indexOf(a) {
      for (let E = 0; E < this.txs.length; E++)
        if (this.txs[E].hash().equals(a))
          return E;
      return -1;
    }
    /**
     * Calculate merkle root. Returns null
     * if merkle tree has been malleated.
     * @param {String?} enc - Encoding, can be `'hex'` or null.
     * @returns {Hash|null}
     */
    createMerkleRoot(a) {
      const E = [];
      for (const G of this.txs)
        E.push(G.hash());
      const [H, j] = m.createRoot(w, E);
      return j ? null : a === "hex" ? H.toString("hex") : H;
    }
    /**
     * Retrieve the merkle root from the block header.
     * @param {String?} enc
     * @returns {Hash}
     */
    getMerkleRoot(a) {
      return a === "hex" ? this.merkleRoot.toString("hex") : this.merkleRoot;
    }
    /**
     * Do non-contextual verification on the block. Including checking the block
     * size, the coinbase and the merkle root. This is consensus-critical.
     * @returns {Boolean}
     */
    verifyBody() {
      const [a] = this.checkBody();
      return a;
    }
    /**
     * Do non-contextual verification on the block. Including checking the block
     * size, the coinbase and the merkle root. This is consensus-critical.
     * @param {Boolean?} skipSigops
     * @returns {Array} [valid, reason, score]
     */
    checkBody(a) {
      if (this.txs.length === 0 || this.txs.length > f.MAX_FORK_BLOCK_SIZE / 10 || this.getSize() > f.MAX_FORK_BLOCK_SIZE)
        return [!1, "bad-blk-length", 100];
      if (this.txs.length === 0 || !this.txs[0].isCoinbase())
        return [!1, "bad-cb-missing", 100];
      const E = this.createMerkleRoot();
      if (!E)
        return [!1, "bad-txns-duplicate", 100];
      if (!this.merkleRoot.equals(E))
        return [!1, "bad-txnmrklroot", 100];
      const H = this.getSize();
      let j = 0;
      for (let G = 0; G < this.txs.length; G++) {
        const N = this.txs[G];
        if (G > 0 && N.isCoinbase())
          return [!1, "bad-cb-multiple", 100];
        const [T, A, q] = N.checkSanity();
        if (!T)
          return [T, A, q];
        if (j += N.getLegacySigops(), !a && j > f.maxBlockSigops(H))
          return [!1, "bad-blk-sigops", 100];
      }
      return [!0, "valid", 0];
    }
    /**
     * Retrieve the coinbase height from the coinbase input script.
     * @returns {Number} height (-1 if not present).
     */
    getCoinbaseHeight() {
      if (this.version < 2 || this.txs.length === 0)
        return -1;
      const a = this.txs[0];
      return a.inputs.length === 0 ? -1 : a.inputs[0].script.getCoinbaseHeight();
    }
    /**
     * Get the "claimed" reward by the coinbase.
     * @returns {Amount} claimed
     */
    getClaimed() {
      return e(this.txs.length > 0), e(this.txs[0].isCoinbase()), this.txs[0].getOutputValue();
    }
    /**
     * Get all unique outpoint hashes in the
     * block. Coinbases are ignored.
     * @returns {Hash[]} Outpoint hashes.
     */
    getPrevout() {
      const a = new l();
      for (let E = 1; E < this.txs.length; E++) {
        const H = this.txs[E];
        for (const j of H.inputs)
          a.add(j.prevout.hash);
      }
      return a.toArray();
    }
    /**
     * Inspect the block and return a more
     * user-friendly representation of the data.
     * @returns {Object}
     */
    [S]() {
      return this.format();
    }
    /**
     * Inspect the block and return a more
     * user-friendly representation of the data.
     * @param {CoinView} view
     * @param {Number} height
     * @returns {Object}
     */
    format(a, E) {
      return {
        hash: this.rhash(),
        height: E ?? -1,
        size: this.getSize(),
        date: p.date(this.time),
        version: this.version.toString(16),
        prevBlock: p.revHex(this.prevBlock),
        merkleRoot: p.revHex(this.merkleRoot),
        time: this.time,
        bits: this.bits,
        nonce: this.nonce,
        txs: this.txs.map((H, j) => H.format(a, null, j))
      };
    }
    /**
     * Convert the block to an object suitable
     * for JSON serialization.
     * @returns {Object}
     */
    toJSON() {
      return this.getJSON();
    }
    /**
     * Convert the block to an object suitable
     * for JSON serialization. Note that the hashes
     * will be reversed to abide by bitcoind's legacy
     * of little-endian uint256s.
     * @param {Network} network
     * @param {CoinView} view
     * @param {Number} height
     * @param {Number} depth
     * @returns {Object}
     */
    getJSON(a, E, H, j) {
      return a = i.get(a), {
        hash: this.rhash(),
        height: H,
        depth: j,
        version: this.version,
        prevBlock: p.revHex(this.prevBlock),
        merkleRoot: p.revHex(this.merkleRoot),
        time: this.time,
        bits: this.bits,
        nonce: this.nonce,
        txs: this.txs.map((G, N) => G.getJSON(a, E, null, N))
      };
    }
    /**
     * Inject properties from json object.
     * @private
     * @param {Object} json
     */
    fromJSON(a) {
      e(a, "Block data is required."), e(Array.isArray(a.txs)), this.parseJSON(a);
      for (const E of a.txs)
        this.txs.push(u.fromJSON(E));
      return this;
    }
    /**
     * Instantiate a block from a jsonified block object.
     * @param {Object} json - The jsonified block object.
     * @returns {Block}
     */
    static fromJSON(a) {
      return new this().fromJSON(a);
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     */
    fromReader(a) {
      a.start(), this.readHead(a);
      const E = a.readVarint();
      for (let H = 0; H < E; H++) {
        const j = u.fromReader(a, !0);
        this.txs.push(j);
      }
      return this.mutable || (this._raw = a.endData(), this._size = this._raw.length), this;
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     */
    fromRaw(a) {
      return this.fromReader(c.read(a));
    }
    /**
     * Instantiate a block from a serialized Buffer.
     * @param {Buffer} data
     * @param {String?} enc - Encoding, can be `'hex'` or null.
     * @returns {Block}
     */
    static fromReader(a) {
      return new this().fromReader(a);
    }
    /**
     * Instantiate a block from a serialized Buffer.
     * @param {Buffer} data
     * @param {String?} enc - Encoding, can be `'hex'` or null.
     * @returns {Block}
     */
    static fromRaw(a, E) {
      return typeof a == "string" && (a = k.from(a, E)), new this().fromRaw(a);
    }
    /**
     * Convert the Block to a MerkleBlock.
     * @param {Bloom} filter - Bloom filter for transactions
     * to match. The merkle block will contain only the
     * matched transactions.
     * @returns {MerkleBlock}
     */
    toMerkle(a) {
      return o.fromBlock(this, a);
    }
    /**
     * Serialze block data.
     * @private
     * @param {BufferWriter?} writer
     * @returns {Buffer}
     */
    writeNormal(a) {
      this.writeHead(a), a.writeVarint(this.txs.length);
      for (const E of this.txs)
        E.toWriter(a);
      return a;
    }
    /**
     * Serialze block data.
     * @private
     * @param {BufferWriter?} writer
     * @returns {Buffer}
     */
    frameNormal() {
      const a = this.getNormalSizes(), E = c.write(a.size);
      return this.writeNormal(E), a.data = E.render(), a;
    }
    /**
     * Convert the block to a headers object.
     * @returns {Headers}
     */
    toHeaders() {
      return s.fromBlock(this);
    }
    /**
     * Get real block size.
     * @returns {RawBlock}
     */
    getNormalSizes() {
      let a = 0;
      a += 80, a += g.sizeVarint(this.txs.length);
      for (const E of this.txs)
        a += E.getSize();
      return new b(a, 0);
    }
    /**
     * Test whether an object is a Block.
     * @param {Object} obj
     * @returns {Boolean}
     */
    static isBlock(a) {
      return a instanceof y;
    }
  }
  class b {
    constructor(a) {
      this.data = null, this.size = a;
    }
  }
  return m0 = y, m0;
}
/*!
 * keyring.js - keyring object for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var g0, C2;
function q7() {
  if (C2) return g0;
  C2 = 1;
  const e = dt, { base58: c } = Ys, l = Bt, w = wn(), m = qr(), f = Tr(), n = si(), u = Li(), o = Vi(), s = Yr(), { encoding: i } = l, { inspectSymbol: p } = cr(), g = k.alloc(33, 0);
  class S {
    /**
     * Create a key ring.
     * @constructor
     * @param {Object} options
     */
    constructor(h) {
      this.nested = !1, this.publicKey = g, this.privateKey = null, this.script = null, this._keyHash = null, this._keyAddress = null, this._scriptHash160 = null, this._scriptAddress = null, h && this.fromOptions(h);
    }
    /**
     * Inject properties from options object.
     * @private
     * @param {Object} options
     */
    fromOptions(h) {
      let a = y(h);
      if (k.isBuffer(a))
        return this.fromKey(a);
      a = y(h.key), h.publicKey && (a = y(h.publicKey)), h.privateKey && (a = y(h.privateKey));
      const E = h.script, H = h.compressed;
      return E ? this.fromScript(a, E, H) : this.fromKey(a, H);
    }
    /**
     * Instantiate key ring from options.
     * @param {Object} options
     * @returns {KeyRing}
     */
    static fromOptions(h) {
      return new this().fromOptions(h);
    }
    /**
     * Clear cached key/script hashes.
     */
    refresh() {
      this._keyHash = null, this._keyAddress = null, this._scriptHash160 = null, this._scriptAddress = null;
    }
    /**
     * Inject data from private key.
     * @private
     * @param {Buffer} key
     * @param {Boolean?} compress
     */
    fromPrivate(h, a) {
      return e(k.isBuffer(h), "Private key must be a buffer."), e(s.privateKeyVerify(h), "Not a valid private key."), this.privateKey = h, this.publicKey = s.publicKeyCreate(h, a !== !1), this;
    }
    /**
     * Instantiate keyring from a private key.
     * @param {Buffer} key
     * @param {Boolean?} compress
     * @returns {KeyRing}
     */
    static fromPrivate(h, a) {
      return new this().fromPrivate(h, a);
    }
    /**
     * Inject data from public key.
     * @private
     * @param {Buffer} key
     */
    fromPublic(h) {
      return e(k.isBuffer(h), "Public key must be a buffer."), e(s.publicKeyVerify(h), "Not a valid public key."), this.publicKey = h, this;
    }
    /**
     * Generate a keyring.
     * @private
     * @param {Boolean?} compress
     * @returns {KeyRing}
     */
    generate(h) {
      const a = s.privateKeyGenerate();
      return this.fromKey(a, h);
    }
    /**
     * Generate a keyring.
     * @param {Boolean?} compress
     * @returns {KeyRing}
     */
    static generate(h) {
      return new this().generate(h);
    }
    /**
     * Instantiate keyring from a public key.
     * @param {Buffer} publicKey
     * @returns {KeyRing}
     */
    static fromPublic(h) {
      return new this().fromPublic(h);
    }
    /**
     * Inject data from public key.
     * @private
     * @param {Buffer} privateKey
     * @param {Boolean?} compress
     */
    fromKey(h, a) {
      return e(k.isBuffer(h), "Key must be a buffer."), h.length === 32 ? this.fromPrivate(h, a !== !1) : this.fromPublic(h);
    }
    /**
     * Instantiate keyring from a public key.
     * @param {Buffer} publicKey
     * @param {Boolean?} compress
     * @returns {KeyRing}
     */
    static fromKey(h, a) {
      return new this().fromKey(h, a);
    }
    /**
     * Inject data from script.
     * @private
     * @param {Buffer} key
     * @param {Script} script
     * @param {Boolean?} compress
     */
    fromScript(h, a, E) {
      return e(a instanceof n, "Non-script passed into KeyRing."), this.fromKey(h, E), this.script = a, this;
    }
    /**
     * Instantiate keyring from script.
     * @param {Buffer} key
     * @param {Script} script
     * @param {Boolean?} compress
     * @returns {KeyRing}
     */
    static fromScript(h, a, E) {
      return new this().fromScript(h, a, E);
    }
    /**
     * Get ith public key from multisig script.
     * @private
     * @param {Script} script
     * @param {Number} i
     * @returns {KeyRing}
     */
    fromMultisigScript(h, a) {
      e(h instanceof n, "Non-script passed."), e(h.isMultisig(), "Script must be multisig");
      const E = h.getSmall(-2);
      return e(a >= 1 && a <= E, "Requested `i`th key, `n` available"), this.fromKey(h.code[a].toData()), this;
    }
    /**
     * Instantiate keyring from ith key in multisig script.
     * @param {Script} script
     * @param {Number} i
     * @returns {KeyRing}
     */
    static fromMultisigScript(h, a) {
      return new this().fromMultisigScript(h, a);
    }
    /**
     * Calculate WIF serialization size.
     * @returns {Number}
     */
    getSecretSize() {
      let h = 0;
      return h += 1, h += this.privateKey.length, this.publicKey.length === 33 && (h += 1), h += 4, h;
    }
    /**
     * Convert key to a CBitcoinSecret.
     * @param {(Network|NetworkType)?} network
     * @returns {Base58String}
     */
    toSecret(h) {
      const a = this.getSecretSize(), E = l.write(a);
      return e(this.privateKey, "Cannot serialize without private key."), h = f.get(h), E.writeU8(h.keyPrefix.privkey), E.writeBytes(this.privateKey), this.publicKey.length === 33 && E.writeU8(1), E.writeChecksum(m.digest), c.encode(E.render());
    }
    /**
     * Inject properties from serialized CBitcoinSecret.
     * @private
     * @param {Base58String} secret
     * @param {(Network|NetworkType)?} network
     */
    fromSecret(h, a) {
      const E = l.read(c.decode(h), !0), H = E.readU8();
      f.fromWIF(H, a);
      const j = E.readBytes(32);
      let G = !1;
      return E.left() > 4 && (e(E.readU8() === 1, "Bad compression flag."), G = !0), E.verifyChecksum(m.digest), this.fromPrivate(j, G);
    }
    /**
     * Instantiate a keyring from a serialized CBitcoinSecret.
     * @param {Base58String} secret
     * @param {(Network|NetworkType)?} network
     * @returns {KeyRing}
     */
    static fromSecret(h, a) {
      return new this().fromSecret(h, a);
    }
    /**
     * Get private key.
     * @param {String?} enc - Can be `"hex"`, `"base58"`, or `null`.
     * @returns {Buffer} Private key.
     */
    getPrivateKey(h, a) {
      return this.privateKey ? h === "base58" ? this.toSecret(a) : h === "hex" ? this.privateKey.toString("hex") : this.privateKey : null;
    }
    /**
     * Get public key.
     * @param {String?} enc - `"hex"` or `null`.
     * @returns {Buffer}
     */
    getPublicKey(h) {
      return h === "base58" ? c.encode(this.publicKey) : h === "hex" ? this.publicKey.toString("hex") : this.publicKey;
    }
    /**
     * Get redeem script.
     * @returns {Script}
     */
    getScript() {
      return this.script;
    }
    /**
     * Get scripthash.
     * @param {String?} enc - `"hex"` or `null`.
     * @returns {Buffer}
     */
    getScriptHash(h) {
      return this.getScriptHash160(h);
    }
    /**
     * Get ripemd160 scripthash.
     * @param {String?} enc - `"hex"` or `null`.
     * @returns {Buffer}
     */
    getScriptHash160(h) {
      return this.script ? (this._scriptHash160 || (this._scriptHash160 = this.script.hash160()), h === "hex" ? this._scriptHash160.toString("hex") : this._scriptHash160) : null;
    }
    /**
     * Get scripthash address.
     * @param {String?} enc - `"base58"` or `null`.
     * @returns {Address|AddressString}
     */
    getScriptAddress(h, a) {
      if (!this.script)
        return null;
      if (!this._scriptAddress) {
        const E = this.getScriptHash160(), H = u.fromScripthash(E);
        this._scriptAddress = H;
      }
      return h === "base58" ? this._scriptAddress.toBase58(a) : h === "string" ? this._scriptAddress.toString(a) : this._scriptAddress;
    }
    /**
     * Get public key hash.
     * @param {String?} enc - `"hex"` or `null`.
     * @returns {Buffer}
     */
    getKeyHash(h) {
      return this._keyHash || (this._keyHash = w.digest(this.publicKey)), h === "hex" ? this._keyHash.toString("hex") : this._keyHash;
    }
    /**
     * Get pubkeyhash address.
     * @param {String?} enc - `"base58"` or `null`.
     * @returns {Address|AddressString}
     */
    getKeyAddress(h, a) {
      if (!this._keyAddress) {
        const E = this.getKeyHash(), H = u.fromPubkeyhash(E);
        this._keyAddress = H;
      }
      return h === "base58" ? this._keyAddress.toBase58(a) : h === "string" ? this._keyAddress.toString(a) : this._keyAddress;
    }
    /**
     * Get hash.
     * @param {String?} enc - `"hex"` or `null`.
     * @returns {Buffer}
     */
    getHash(h) {
      return this.script ? this.getScriptHash(h) : this.getKeyHash(h);
    }
    /**
     * Get base58 address.
     * @param {String?} enc - `"base58"` or `null`.
     * @returns {Address|AddressString}
     */
    getAddress(h, a) {
      return this.script ? this.getScriptAddress(h, a) : this.getKeyAddress(h, a);
    }
    /**
     * Test an address hash against hash.
     * @param {Buffer} hash
     * @returns {Boolean}
     */
    ownHash(h) {
      return h ? !!(h.equals(this.getKeyHash()) || this.script && h.equals(this.getScriptHash())) : !1;
    }
    /**
     * Check whether transaction output belongs to this address.
     * @param {TX|Output} tx - Transaction or Output.
     * @param {Number?} index - Output index.
     * @returns {Boolean}
     */
    ownOutput(h, a) {
      let E;
      return h instanceof o ? E = h : (E = h.outputs[a], e(E, "Output does not exist.")), this.ownHash(E.getHash());
    }
    /**
     * Test a hash against script hashes to
     * find the correct redeem script, if any.
     * @param {Buffer} hash
     * @returns {Script|null}
     */
    getRedeem(h) {
      return this.script && h.equals(this.getScriptHash160()) ? this.script : null;
    }
    /**
     * Sign a message.
     * @param {Buffer} msg
     * @returns {Buffer} Signature in DER format.
     */
    sign(h) {
      return e(this.privateKey, "Cannot sign without private key."), s.signDER(h, this.privateKey);
    }
    /**
     * Sign a message.
     * @param {Buffer} msg
     * @returns {Buffer} Signature in Schnorr format.
     */
    signSchnorr(h) {
      return e(this.privateKey, "Cannot sign without private key."), s.schnorrSign(h, this.privateKey);
    }
    /**
     * Verify a message.
     * @param {Buffer} msg
     * @param {Buffer} sig - Signature in DER format.
     * @returns {Boolean}
     */
    verify(h, a) {
      return s.verifyDER(h, a, this.publicKey);
    }
    /**
     * Verify a message.
     * @param {Buffer} msg
     * @param {Buffer} sig - Signature in Schnorr format.
     * @returns {Boolean}
     */
    verifySchnorr(h, a) {
      return s.schnorrVerify(h, a, this.publicKey);
    }
    /**
     * Get witness program version.
     * @returns {Number}
     */
    getVersion() {
      return -1;
    }
    /**
     * Get address type.
     * @returns {ScriptType}
     */
    getType() {
      return this.script ? u.types.SCRIPTHASH : u.types.PUBKEYHASH;
    }
    /**
     * Inspect keyring.
     * @returns {Object}
     */
    [p]() {
      return this.toJSON();
    }
    /**
     * Convert an KeyRing to a more json-friendly object.
     * @returns {Object}
     */
    toJSON(h) {
      return {
        publicKey: this.publicKey.toString("hex"),
        script: this.script ? this.script.toRaw().toString("hex") : null,
        type: u.typesByVal[this.getType()].toLowerCase(),
        address: this.getAddress("string", h)
      };
    }
    /**
     * Inject properties from json object.
     * @private
     * @param {Object} json
     */
    fromJSON(h) {
      return e(h), e(typeof h.publicKey == "string"), e(!h.script || typeof h.script == "string"), this.publicKey = k.from(h.publicKey, "hex"), h.script && (this.script = k.from(h.script, "hex")), this;
    }
    /**
     * Instantiate an KeyRing from a jsonified transaction object.
     * @param {Object} json - The jsonified transaction object.
     * @returns {KeyRing}
     */
    static fromJSON(h) {
      return new this().fromJSON(h);
    }
    /**
     * Calculate serialization size.
     * @returns {Number}
     */
    getSize() {
      let h = 0;
      return h += 1, this.privateKey ? (h += i.sizeVarBytes(this.privateKey), h += 1) : h += i.sizeVarBytes(this.publicKey), h += this.script ? this.script.getVarSize() : 1, h;
    }
    /**
     * Write the keyring to a buffer writer.
     * @param {BufferWriter} bw
     */
    toWriter(h) {
      return h.writeU8(0), this.privateKey ? (h.writeVarBytes(this.privateKey), h.writeU8(this.publicKey.length === 33 ? 1 : 0)) : h.writeVarBytes(this.publicKey), this.script ? h.writeVarBytes(this.script.toRaw()) : h.writeVarint(0), h;
    }
    /**
     * Serialize the keyring.
     * @returns {Buffer}
     */
    toRaw() {
      const h = this.getSize();
      return this.toWriter(l.write(h)).render();
    }
    /**
     * Inject properties from buffer reader.
     * @private
     * @param {BufferReader} br
     */
    fromReader(h) {
      h.readU8();
      const a = h.readVarBytes();
      if (a.length === 32) {
        const H = h.readU8() === 1;
        this.privateKey = a, this.publicKey = s.publicKeyCreate(a, H);
      } else
        this.publicKey = a, e(s.publicKeyVerify(a), "Invalid public key.");
      const E = h.readVarBytes();
      return E.length > 0 && (this.script = n.fromRaw(E)), this;
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     */
    fromRaw(h) {
      return this.fromReader(l.read(h));
    }
    /**
     * Instantiate a keyring from buffer reader.
     * @param {BufferReader} br
     * @returns {KeyRing}
     */
    static fromReader(h) {
      return new this().fromReader(h);
    }
    /**
     * Instantiate a keyring from serialized data.
     * @param {Buffer} data
     * @returns {KeyRing}
     */
    static fromRaw(h) {
      return new this().fromRaw(h);
    }
    /**
     * Test whether an object is a KeyRing.
     * @param {Object} obj
     * @returns {Boolean}
     */
    static isKeyRing(h) {
      return h instanceof S;
    }
  }
  function y(b) {
    return b && (b.privateKey ? b.privateKey : b.publicKey ? b.publicKey : b);
  }
  return g0 = S, g0;
}
/*!
 * memblock.js - memblock block object for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var x0, D2;
function $g() {
  if (D2) return x0;
  D2 = 1;
  const e = Bt, c = rs(), l = Ul(), w = ns(), m = si(), f = k.alloc(0);
  class n extends c {
    /**
     * Create a mem block.
     * @constructor
     */
    constructor() {
      super(), this._raw = f;
    }
    /**
     * Test whether the block is a memblock.
     * @returns {Boolean}
     */
    isMemory() {
      return !0;
    }
    /**
     * Serialize the block headers.
     * @returns {Buffer}
     */
    toHead() {
      return this._raw.slice(0, 80);
    }
    /**
     * Get the full block size.
     * @returns {Number}
     */
    getSize() {
      return this._raw.length;
    }
    /**
     * Verify the block.
     * @returns {Boolean}
     */
    verifyBody() {
      return !0;
    }
    /**
     * Retrieve the coinbase height
     * from the coinbase input script.
     * @returns {Number} height (-1 if not present).
     */
    getCoinbaseHeight() {
      if (this.version < 2)
        return -1;
      try {
        return this.parseCoinbaseHeight();
      } catch {
        return -1;
      }
    }
    /**
     * Parse the coinbase height
     * from the coinbase input script.
     * @private
     * @returns {Number} height (-1 if not present).
     */
    parseCoinbaseHeight() {
      const o = e.read(this._raw, !0);
      if (o.seek(80), o.readVarint() === 0)
        return -1;
      o.seek(4);
      let i = o.readVarint();
      if (i === 0 && o.readU8() !== 0 && (i = o.readVarint()), i === 0)
        return -1;
      o.seek(36);
      const p = o.readVarBytes();
      return m.getCoinbaseHeight(p);
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     */
    fromRaw(o) {
      const s = e.read(o, !0);
      return this.readHead(s), this._raw = s.data, this;
    }
    /**
     * Insantiate a memblock from serialized data.
     * @param {Buffer} data
     * @returns {MemBlock}
     */
    static fromRaw(o) {
      return new this().fromRaw(o);
    }
    /**
     * Return serialized block data.
     * @returns {Buffer}
     */
    toRaw() {
      return this._raw;
    }
    /**
     * Parse the serialized block data
     * and create an actual {@link Block}.
     * @returns {Block}
     * @throws Parse error
     */
    toBlock() {
      const o = l.fromRaw(this._raw);
      return o._hash = this._hash, o._hhash = this._hhash, o;
    }
    /**
     * Convert the block to a headers object.
     * @returns {Headers}
     */
    toHeaders() {
      return w.fromBlock(this);
    }
    /**
     * Test whether an object is a MemBlock.
     * @param {Object} obj
     * @returns {Boolean}
     */
    static isMemBlock(o) {
      return o instanceof n;
    }
  }
  return x0 = n, x0;
}
var xs = { exports: {} };
/*!
 * mtx.js - mutable transaction object for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var U2;
function T7() {
  return U2 || (U2 = 1, function(e, c) {
    const l = dt, { encoding: w } = Bt, { BufferMap: m } = xn, f = si(), n = is(), u = co(), o = Vi(), s = no(), i = vn(), p = ql(), g = Li(), S = Xt(), y = yn(), b = Di(), h = ro(), a = pr(), { inspectSymbol: E } = cr();
    class H extends n {
      /**
       * Create a mutable transaction.
       * @alias module:primitives.MTX
       * @constructor
       * @param {Object} options
       */
      constructor(R) {
        super(), this.mutable = !0, this.changeIndex = -1, this.view = new p(), R && this.fromOptions(R);
      }
      /**
       * Inject properties from options object.
       * @private
       * @param {Object} options
       */
      fromOptions(R) {
        if (R.version != null && (l(
          R.version >>> 0 === R.version,
          "Version must a be uint32."
        ), this.version = R.version), R.inputs) {
          l(Array.isArray(R.inputs), "Inputs must be an array.");
          for (const L of R.inputs)
            this.addInput(L);
        }
        if (R.outputs) {
          l(Array.isArray(R.outputs), "Outputs must be an array.");
          for (const L of R.outputs)
            this.addOutput(L);
        }
        return R.locktime != null && (l(
          R.locktime >>> 0 === R.locktime,
          "Locktime must be a uint32."
        ), this.locktime = R.locktime), R.changeIndex != null && (R.changeIndex !== -1 ? (l(
          R.changeIndex >>> 0 === R.changeIndex,
          "Change index must be a uint32."
        ), this.changeIndex = R.changeIndex) : this.changeIndex = -1), this;
      }
      /**
       * Instantiate MTX from options.
       * @param {Object} options
       * @returns {MTX}
       */
      static fromOptions(R) {
        return new this().fromOptions(R);
      }
      /**
       * Clone the transaction. Note that
       * this will not carry over the view.
       * @returns {MTX}
       */
      clone() {
        const R = new this.constructor();
        return R.inject(this), R.changeIndex = this.changeIndex, R;
      }
      /**
       * Add an input to the transaction.
       * @param {Input|Object} options
       * @returns {Input}
       *
       * @example
       * mtx.addInput({ prevout: { hash: ... }, script: ... });
       * mtx.addInput(new Input());
       */
      addInput(R) {
        const L = u.fromOptions(R);
        return this.inputs.push(L), L;
      }
      /**
       * Add an outpoint as an input.
       * @param {Outpoint|Object} outpoint
       * @returns {Input}
       *
       * @example
       * mtx.addOutpoint({ hash: ..., index: 0 });
       * mtx.addOutpoint(new Outpoint(hash, index));
       */
      addOutpoint(R) {
        const L = i.fromOptions(R), fe = u.fromOutpoint(L);
        return this.inputs.push(fe), fe;
      }
      /**
       * Add a coin as an input. Note that this will
       * add the coin to the internal coin viewpoint.
       * @param {Coin} coin
       * @returns {Input}
       *
       * @example
       * mtx.addCoin(Coin.fromTX(tx, 0, -1));
       */
      addCoin(R) {
        l(R instanceof s, "Cannot add non-coin.");
        const L = u.fromCoin(R);
        return this.inputs.push(L), this.view.addCoin(R), L;
      }
      /**
       * Add a transaction as an input. Note that
       * this will add the coin to the internal
       * coin viewpoint.
       * @param {TX} tx
       * @param {Number} index
       * @param {Number?} height
       * @returns {Input}
       *
       * @example
       * mtx.addTX(tx, 0);
       */
      addTX(R, L, fe) {
        l(R instanceof n, "Cannot add non-transaction."), fe == null && (fe = -1);
        const ue = u.fromTX(R, L);
        return this.inputs.push(ue), this.view.addIndex(R, L, fe), ue;
      }
      /**
       * Add an output.
       * @param {Address|Script|Output|Object} script - Script or output options.
       * @param {Amount?} value
       * @returns {Output}
       *
       * @example
       * mtx.addOutput(new Output());
       * mtx.addOutput({ address: ..., value: 100000 });
       * mtx.addOutput(address, 100000);
       * mtx.addOutput(script, 100000);
       */
      addOutput(R, L) {
        let fe;
        return L != null ? fe = o.fromScript(R, L) : fe = o.fromOptions(R), this.outputs.push(fe), fe;
      }
      /**
       * Verify all transaction inputs.
       * @param {VerifyFlags} [flags=STANDARD_VERIFY_FLAGS]
       * @returns {Boolean} Whether the inputs are valid.
       * @throws {ScriptError} on invalid inputs
       */
      check(R) {
        return super.check(this.view, R);
      }
      /**
       * Verify the transaction inputs on the worker pool
       * (if workers are enabled).
       * @param {VerifyFlags?} [flags=STANDARD_VERIFY_FLAGS]
       * @param {WorkerPool?} pool
       * @returns {Promise}
       */
      checkAsync(R, L) {
        return super.checkAsync(this.view, R, L);
      }
      /**
       * Verify all transaction inputs.
       * @param {VerifyFlags} [flags=STANDARD_VERIFY_FLAGS]
       * @returns {Boolean} Whether the inputs are valid.
       */
      verify(R) {
        try {
          this.check(R);
        } catch (L) {
          if (L.type === "ScriptError")
            return !1;
          throw L;
        }
        return !0;
      }
      /**
       * Verify the transaction inputs on the worker pool
       * (if workers are enabled).
       * @param {VerifyFlags?} [flags=STANDARD_VERIFY_FLAGS]
       * @param {WorkerPool?} pool
       * @returns {Promise}
       */
      async verifyAsync(R, L) {
        try {
          await this.checkAsync(R, L);
        } catch (fe) {
          if (fe.type === "ScriptError")
            return !1;
          throw fe;
        }
        return !0;
      }
      /**
       * Calculate the fee for the transaction.
       * @returns {Amount} fee (zero if not all coins are available).
       */
      getFee() {
        return super.getFee(this.view);
      }
      /**
       * Calculate the total input value.
       * @returns {Amount} value
       */
      getInputValue() {
        return super.getInputValue(this.view);
      }
      /**
       * Get all input addresses.
       * @returns {Address[]} addresses
       */
      getInputAddresses() {
        return super.getInputAddresses(this.view);
      }
      /**
       * Get all addresses.
       * @returns {Address[]} addresses
       */
      getAddresses() {
        return super.getAddresses(this.view);
      }
      /**
       * Get all input address hashes.
       * @returns {Hash[]} hashes
       */
      getInputHashes(R) {
        return super.getInputHashes(this.view, R);
      }
      /**
       * Get all address hashes.
       * @returns {Hash[]} hashes
       */
      getHashes(R) {
        return super.getHashes(this.view, R);
      }
      /**
       * Test whether the transaction has
       * all coins available/filled.
       * @returns {Boolean}
       */
      hasCoins() {
        return super.hasCoins(this.view);
      }
      /**
       * Calculate virtual sigop count.
       * @param {VerifyFlags?} flags
       * @returns {Number} sigop count
       */
      getSigops(R) {
        return super.getSigops(this.view, R);
      }
      /**
       *  Calculate sigops count.
       *  @param {CoinView} view
       *  @param {VerifyFlags?} flags
       *  @returns {Number} sigop count
       */
      getSigopsCount(R) {
        return super.getSigopsCount(this.view, R);
      }
      /**
       * Perform contextual checks to verify input, output,
       * and fee values, as well as coinbase spend maturity
       * (coinbases can only be spent 100 blocks or more
       * after they're created). Note that this function is
       * consensus critical.
       * @param {Number} height - Height at which the
       * transaction is being spent. In the mempool this is
       * the chain height plus one at the time it entered the pool.
       * @returns {Boolean}
       */
      verifyInputs(R) {
        const [L] = this.checkInputs(R);
        return L !== -1;
      }
      /**
       * Perform contextual checks to verify input, output,
       * and fee values, as well as coinbase spend maturity
       * (coinbases can only be spent 100 blocks or more
       * after they're created). Note that this function is
       * consensus critical.
       * @param {Number} height - Height at which the
       * transaction is being spent. In the mempool this is
       * the chain height plus one at the time it entered the pool.
       * @returns {Array} [fee, reason, score]
       */
      checkInputs(R) {
        return super.checkInputs(this.view, R);
      }
      /**
       * Build input script (or witness) templates (with
       * OP_0 in place of signatures).
       * @param {Number} index - Input index.
       * @param {Coin|Output} coin
       * @param {KeyRing} ring
       * @returns {Boolean} Whether the script was able to be built.
       */
      scriptInput(R, L, fe) {
        const ue = this.inputs[R];
        if (l(ue, "Input does not exist."), l(L, "No coin passed."), ue.script.raw.length !== 0)
          return !0;
        const ae = L.script, D = ae.getScripthash();
        if (D) {
          const W = fe.getRedeem(D);
          if (!W)
            return !1;
          const oe = this.scriptVector(W, fe);
          return oe ? (oe.push(W.toRaw()), ue.script.fromStack(oe), !0) : !1;
        }
        const Q = this.scriptVector(ae, fe);
        return Q ? (ue.script.fromStack(Q), !0) : !1;
      }
      /**
       * Build script for a single vector
       * based on a previous script.
       * @param {Script} prev
       * @param {Buffer} ring
       * @return {Stack}
       */
      scriptVector(R, L) {
        const fe = R.getPubkey();
        if (fe) {
          if (!fe.equals(L.publicKey))
            return null;
          const D = new h();
          return D.pushInt(0), D;
        }
        const ue = R.getPubkeyhash();
        if (ue) {
          if (!ue.equals(L.getKeyHash()))
            return null;
          const D = new h();
          return D.pushInt(0), D.pushData(L.publicKey), D;
        }
        const [, ae] = R.getMultisig();
        if (ae !== -1) {
          if (R.indexOf(L.publicKey) === -1)
            return null;
          const D = new h();
          D.pushInt(0);
          for (let Q = 0; Q < ae; Q++)
            D.pushInt(0);
          return D;
        }
        return null;
      }
      /**
       * Sign a transaction input on the worker pool
       * (if workers are enabled).
       * @param {Number} index
       * @param {Coin|Output} coin
       * @param {KeyRing} ring
       * @param {SighashType?} type
       * @param {WorkerPool?} pool
       * @returns {Promise}
       */
      async signInputAsync(R, L, fe, ue, ae) {
        return ae ? await ae.signInput(this, R, L, fe, ue, ae) : this.signInput(R, L, fe, ue);
      }
      /**
       * Sign an input.
       * @param {Number} index - Index of input being signed.
       * @param {Coin|Output} coin
       * @param {KeyRing} ring - Private key.
       * @param {SighashType} type
       * @returns {Boolean} Whether the input was able to be signed.
       */
      signInput(R, L, fe, ue) {
        const ae = this.inputs[R], D = fe.privateKey;
        l(ae, "Input does not exist."), l(L, "No coin passed.");
        const Q = L.value;
        let W = L.script;
        const oe = ae.script;
        let v = !1;
        ue == null && (ue = f.hashType.ALL), ue |= f.hashType.SIGHASH_FORKID;
        const Y = f.flags.VERIFY_SIGHASH_FORKID;
        if (W.isScripthash()) {
          if (W = ae.script.getRedeem(), !W)
            throw new Error("Input has not been templated.");
          v = !0;
        }
        const he = this.signature(R, W, Q, D, ue, Y);
        if (v) {
          const Ee = oe.toStack(), we = Ee.pop(), z = this.signVector(W, Ee, he, fe);
          return z ? (z.push(we), oe.fromStack(z), !0) : !1;
        }
        const le = oe.toStack(), ge = this.signVector(W, le, he, fe);
        return ge ? (oe.fromStack(ge), !0) : !1;
      }
      /**
       * Add a signature to a vector
       * based on a previous script.
       * @param {Script} prev
       * @param {Stack} vector
       * @param {Buffer} sig
       * @param {KeyRing} ring
       * @return {Boolean}
       */
      signVector(R, L, fe, ue) {
        const ae = R.getPubkey();
        if (ae) {
          if (!ue.publicKey.equals(ae))
            return null;
          if (L.length === 0)
            throw new Error("Input has not been templated.");
          return L.get(0).length > 0 || L.set(0, fe), L;
        }
        const D = R.getPubkeyhash();
        if (D) {
          if (!ue.getKeyHash().equals(D))
            return null;
          if (L.length !== 2)
            throw new Error("Input has not been templated.");
          if (L.get(1).length === 0)
            throw new Error("Input has not been templated.");
          return L.get(0).length > 0 || L.set(0, fe), L;
        }
        const [Q, W] = R.getMultisig();
        if (Q !== -1) {
          if (L.length < 2)
            throw new Error("Input has not been templated.");
          if (L.get(0).length !== 0)
            throw new Error("Input has not been templated.");
          if (L.length - 1 > W)
            throw new Error("Input has not been templated.");
          let oe = 0;
          for (let he = 1; he < L.length; he++)
            L.get(he).length > 0 && (oe += 1);
          if (oe === Q && L.length - 1 === Q)
            return L;
          for (; L.length - 1 < W; )
            L.pushInt(0);
          const v = [];
          for (const he of R.code)
            he.data && v.push(he.data);
          let Y = -1;
          for (let he = 0; he < v.length; he++)
            if (v[he].equals(ue.publicKey)) {
              Y = he;
              break;
            }
          if (Y === -1)
            return null;
          if (Y += 1, Y < L.length && oe < Q && L.get(Y).length === 0 && (L.set(Y, fe), oe += 1), oe >= Q) {
            for (let he = L.length - 1; he >= 1; he--)
              L.get(he).length === 0 && L.remove(he);
            for (; oe > Q; )
              L.pop(), oe -= 1;
            l(oe === Q), l(L.length - 1 === Q);
          }
          return L;
        }
        return null;
      }
      /**
       * Test whether the transaction is fully-signed.
       * @returns {Boolean}
       */
      isSigned() {
        for (let R = 0; R < this.inputs.length; R++) {
          const { prevout: L } = this.inputs[R], fe = this.view.getOutput(L);
          if (!fe || !this.isInputSigned(R, fe))
            return !1;
        }
        return !0;
      }
      /**
       * Test whether an input is fully-signed.
       * @param {Number} index
       * @param {Coin|Output} coin
       * @returns {Boolean}
       */
      isInputSigned(R, L) {
        const fe = this.inputs[R];
        l(fe, "Input does not exist."), l(L, "No coin passed.");
        const ue = fe.script;
        let ae = L.script, D = !1;
        if (ae.isScripthash()) {
          if (ae = fe.script.getRedeem(), !ae)
            return !1;
          D = !0;
        }
        const Q = ue.toStack();
        return D && Q.pop(), this.isVectorSigned(ae, Q);
      }
      /**
       * Test whether a vector is fully-signed.
       * @param {Script} prev
       * @param {Stack} vector
       * @returns {Boolean}
       */
      isVectorSigned(R, L) {
        if (R.isPubkey())
          return !(L.length !== 1 || L.get(0).length === 0);
        if (R.isPubkeyhash())
          return !(L.length !== 2 || L.get(0).length === 0 || L.get(1).length === 0);
        const [fe] = R.getMultisig();
        if (fe !== -1) {
          if (L.length - 1 !== fe)
            return !1;
          for (let ue = 1; ue < L.length; ue++)
            if (L.get(ue).length === 0)
              return !1;
          return !0;
        }
        return !1;
      }
      /**
       * Build input scripts (or witnesses).
       * @param {KeyRing} ring - Address used to sign. The address
       * must be able to redeem the coin.
       * @returns {Number} Number of inputs templated.
       */
      template(R) {
        if (Array.isArray(R)) {
          let fe = 0;
          for (const ue of R)
            fe += this.template(ue);
          return fe;
        }
        let L = 0;
        for (let fe = 0; fe < this.inputs.length; fe++) {
          const { prevout: ue } = this.inputs[fe], ae = this.view.getOutput(ue);
          ae && R.ownOutput(ae) && this.scriptInput(fe, ae, R) && (L += 1);
        }
        return L;
      }
      /**
       * Built input scripts (or witnesses) and sign the inputs.
       * @param {KeyRing} ring - Address used to sign. The address
       * must be able to redeem the coin.
       * @param {SighashType} type
       * @returns {Number} Number of inputs signed.
       */
      sign(R, L) {
        if (Array.isArray(R)) {
          let ue = 0;
          for (const ae of R)
            ue += this.sign(ae, L);
          return ue;
        }
        l(R.privateKey, "No private key available.");
        let fe = 0;
        for (let ue = 0; ue < this.inputs.length; ue++) {
          const { prevout: ae } = this.inputs[ue], D = this.view.getOutput(ae);
          D && R.ownOutput(D) && this.scriptInput(ue, D, R) && this.signInput(ue, D, R, L) && (fe += 1);
        }
        return fe;
      }
      /**
       * Sign the transaction inputs on the worker pool
       * (if workers are enabled).
       * @param {KeyRing} ring
       * @param {SighashType?} type
       * @param {WorkerPool?} pool
       * @returns {Promise}
       */
      async signAsync(R, L, fe) {
        return fe ? await fe.sign(this, R, L) : this.sign(R, L);
      }
      /**
       * Estimate maximum possible size.
       * @param {Function?} estimate - Input script size estimator.
       * @returns {Number}
       */
      async estimateSize(R) {
        let L = 0;
        L += 4, L += w.sizeVarint(this.inputs.length), L += this.inputs.length * 40, L += w.sizeVarint(this.outputs.length);
        for (const fe of this.outputs)
          L += fe.getSize();
        L += 4;
        for (const { prevout: fe } of this.inputs) {
          const ue = this.view.getOutput(fe);
          if (!ue) {
            L += 110;
            continue;
          }
          const ae = ue.script;
          if (ae.isPubkey()) {
            L += 1, L += 74;
            continue;
          }
          if (ae.isPubkeyhash()) {
            L += 1, L += 74, L += 34;
            continue;
          }
          const [D] = ae.getMultisig();
          if (D !== -1) {
            let Q = 0;
            Q += 1, Q += 74 * D, Q += w.sizeVarint(Q), L += Q;
            continue;
          }
          if (R) {
            const Q = await R(ae);
            if (Q !== -1) {
              L += Q;
              continue;
            }
          }
          if (ae.isScripthash()) {
            L += 1, L += 149;
            continue;
          }
          L += 110;
        }
        return L;
      }
      /**
       * Select necessary coins based on total output value.
       * @param {Coin[]} coins
       * @param {Object?} options
       * @returns {CoinSelection}
       * @throws on not enough funds available.
       */
      selectCoins(R, L) {
        return new j(this, L).select(R);
      }
      /**
       * Attempt to subtract a fee from a single output.
       * @param {Number} index
       * @param {Amount} fee
       */
      subtractIndex(R, L) {
        l(typeof R == "number"), l(typeof L == "number");
        const fe = this.outputs[R];
        if (!fe)
          throw new Error("Subtraction index does not exist.");
        if (fe.value < L + fe.getDustThreshold())
          throw new Error("Could not subtract fee.");
        fe.value -= L;
      }
      /**
       * Attempt to subtract a fee from all outputs evenly.
       * @param {Amount} fee
       */
      subtractFee(R) {
        l(typeof R == "number");
        let L = 0;
        for (const ae of this.outputs)
          ae.script.isUnspendable() || (L += 1);
        if (L === 0)
          throw new Error("Could not subtract fee.");
        const fe = R % L, ue = (R - fe) / L;
        for (const ae of this.outputs)
          if (!ae.script.isUnspendable()) {
            if (ae.value < ue + ae.getDustThreshold())
              throw new Error("Could not subtract fee.");
            ae.value -= ue;
          }
        for (const ae of this.outputs)
          if (!ae.script.isUnspendable() && ae.value >= fe + ae.getDustThreshold()) {
            ae.value -= fe;
            return;
          }
        throw new Error("Could not subtract fee.");
      }
      /**
       * Select coins and fill the inputs.
       * @param {Coin[]} coins
       * @param {Object} options - See {@link MTX#selectCoins} options.
       * @returns {CoinSelector}
       */
      async fund(R, L) {
        l(L, "Options are required."), l(L.changeAddress, "Change address is required."), l(this.inputs.length === 0, "TX is already funded.");
        const fe = await this.selectCoins(R, L);
        for (const ae of fe.chosen)
          this.addCoin(ae);
        if (fe.subtractFee) {
          const ae = fe.subtractIndex;
          ae !== -1 ? this.subtractIndex(ae, fe.fee) : this.subtractFee(fe.fee);
        }
        const ue = new o();
        return ue.value = fe.change, ue.script.fromAddress(fe.changeAddress), ue.isDust(y.MIN_RELAY) ? (this.changeIndex = -1, l.strictEqual(this.getFee(), fe.fee + fe.change)) : (this.outputs.push(ue), this.changeIndex = this.outputs.length - 1, l.strictEqual(this.getFee(), fe.fee)), fe;
      }
      /**
       * Sort inputs and outputs according to BIP69.
       * @see https://github.com/bitcoin/bips/blob/master/bip-0069.mediawiki
       */
      sortMembers() {
        let R = null;
        this.changeIndex !== -1 && (R = this.outputs[this.changeIndex], l(R)), this.inputs.sort(q), this.outputs.sort(_), this.changeIndex !== -1 && (this.changeIndex = this.outputs.indexOf(R), l(this.changeIndex !== -1));
      }
      /**
       * Avoid fee sniping.
       * @param {Number} - Current chain height.
       * @see bitcoin/src/wallet/wallet.cpp
       */
      avoidFeeSniping(R) {
        l(typeof R == "number", "Must pass in height."), (Math.random() * 10 | 0) === 0 && (R -= Math.random() * 100 | 0, R < 0 && (R = 0)), this.setLocktime(R);
      }
      /**
       * Set locktime and sequences appropriately.
       * @param {Number} locktime
       */
      setLocktime(R) {
        l(R >>> 0 === R, "Locktime must be a uint32."), l(this.inputs.length > 0, "Cannot set sequence with no inputs.");
        for (const L of this.inputs)
          L.sequence === 4294967295 && (L.sequence = 4294967294);
        this.locktime = R;
      }
      /**
       * Set sequence locktime.
       * @param {Number} index - Input index.
       * @param {Number} locktime
       * @param {Boolean?} seconds
       */
      setSequence(R, L, fe) {
        const ue = this.inputs[R];
        l(ue, "Input does not exist."), l(L >>> 0 === L, "Locktime must be a uint32."), this.version = 2, fe ? (L >>>= S.SEQUENCE_GRANULARITY, L &= S.SEQUENCE_MASK, L |= S.SEQUENCE_TYPE_FLAG) : L &= S.SEQUENCE_MASK, ue.sequence = L;
      }
      /**
       * Inspect the transaction.
       * @returns {Object}
       */
      [E]() {
        return this.format();
      }
      /**
       * Inspect the transaction.
       * @returns {Object}
       */
      format() {
        return super.format(this.view);
      }
      /**
       * Convert transaction to JSON.
       * @returns {Object}
       */
      toJSON() {
        return super.toJSON(null, this.view);
      }
      /**
       * Convert transaction to JSON.
       * @param {Network} network
       * @returns {Object}
       */
      getJSON(R) {
        return super.getJSON(R, this.view);
      }
      /**
       * Inject properties from a json object
       * @param {Object} json
       */
      fromJSON(R) {
        super.fromJSON(R);
        for (let L = 0; L < R.inputs.length; L++) {
          const fe = R.inputs[L], { prevout: ue } = fe;
          if (!fe.coin)
            continue;
          const ae = s.fromJSON(fe.coin);
          ae.hash = a.fromRev(ue.hash), ae.index = ue.index, this.view.addCoin(ae);
        }
        return this;
      }
      /**
       * Instantiate a transaction from a
       * jsonified transaction object.
       * @param {Object} json - The jsonified transaction object.
       * @returns {MTX}
       */
      static fromJSON(R) {
        return new this().fromJSON(R);
      }
      /**
       * Instantiate a transaction from a buffer reader.
       * @param {BufferReader} br
       * @returns {MTX}
       */
      static fromReader(R) {
        return new this().fromReader(R);
      }
      /**
       * Instantiate a transaction from a serialized Buffer.
       * @param {Buffer} data
       * @param {String?} enc - Encoding, can be `'hex'` or null.
       * @returns {MTX}
       */
      static fromRaw(R, L) {
        return typeof R == "string" && (R = k.from(R, L)), new this().fromRaw(R);
      }
      /**
       * Convert the MTX to a TX.
       * @returns {TX}
       */
      toTX() {
        return new n().inject(this);
      }
      /**
       * Convert the MTX to a TX.
       * @returns {Array} [tx, view]
       */
      commit() {
        return [this.toTX(), this.view];
      }
      /**
       * Instantiate MTX from TX.
       * @param {TX} tx
       * @returns {MTX}
       */
      static fromTX(R) {
        return new this().inject(R);
      }
      /**
       * Test whether an object is an MTX.
       * @param {Object} obj
       * @returns {Boolean}
       */
      static isMTX(R) {
        return R instanceof H;
      }
    }
    class j {
      /**
       * Create a coin selector.
       * @constructor
       * @param {TX} tx
       * @param {Object?} options
       */
      constructor(R, L) {
        this.tx = R.clone(), this.coins = [], this.outputValue = 0, this.index = 0, this.chosen = [], this.change = 0, this.fee = j.MIN_FEE, this.selection = "value", this.subtractFee = !1, this.subtractIndex = -1, this.height = -1, this.depth = -1, this.hardFee = -1, this.rate = j.FEE_RATE, this.maxFee = -1, this.round = !1, this.changeAddress = null, this.inputs = new m(), this.estimate = null, this.injectInputs(), L && this.fromOptions(L);
      }
      /**
       * Initialize selector options.
       * @param {Object} options
       * @private
       */
      fromOptions(R) {
        if (R.selection && (l(typeof R.selection == "string"), this.selection = R.selection), R.subtractFee != null && (typeof R.subtractFee == "number" ? (l(Number.isSafeInteger(R.subtractFee)), l(R.subtractFee >= -1), this.subtractIndex = R.subtractFee, this.subtractFee = this.subtractIndex !== -1) : (l(typeof R.subtractFee == "boolean"), this.subtractFee = R.subtractFee)), R.subtractIndex != null && (l(Number.isSafeInteger(R.subtractIndex)), l(R.subtractIndex >= -1), this.subtractIndex = R.subtractIndex, this.subtractFee = this.subtractIndex !== -1), R.height != null && (l(Number.isSafeInteger(R.height)), l(R.height >= -1), this.height = R.height), R.confirmations != null && (l(Number.isSafeInteger(R.confirmations)), l(R.confirmations >= -1), this.depth = R.confirmations), R.depth != null && (l(Number.isSafeInteger(R.depth)), l(R.depth >= -1), this.depth = R.depth), R.hardFee != null && (l(Number.isSafeInteger(R.hardFee)), l(R.hardFee >= -1), this.hardFee = R.hardFee), R.rate != null && (l(Number.isSafeInteger(R.rate)), l(R.rate >= 0), this.rate = R.rate), R.maxFee != null && (l(Number.isSafeInteger(R.maxFee)), l(R.maxFee >= -1), this.maxFee = R.maxFee), R.round != null && (l(typeof R.round == "boolean"), this.round = R.round), R.changeAddress) {
          const L = R.changeAddress;
          typeof L == "string" ? this.changeAddress = g.fromString(L) : (l(L instanceof g), this.changeAddress = L);
        }
        if (R.estimate && (l(typeof R.estimate == "function"), this.estimate = R.estimate), R.inputs) {
          l(Array.isArray(R.inputs));
          for (let L = 0; L < R.inputs.length; L++) {
            const fe = R.inputs[L];
            l(fe && typeof fe == "object");
            const { hash: ue, index: ae } = fe;
            l(k.isBuffer(ue)), l(typeof ae == "number"), this.inputs.set(i.toKey(ue, ae), L);
          }
        }
        return this;
      }
      /**
       * Attempt to inject existing inputs.
       * @private
       */
      injectInputs() {
        if (this.tx.inputs.length > 0)
          for (let R = 0; R < this.tx.inputs.length; R++) {
            const { prevout: L } = this.tx.inputs[R];
            this.inputs.set(L.toKey(), R);
          }
      }
      /**
       * Initialize the selector with coins to select from.
       * @param {Coin[]} coins
       */
      init(R) {
        switch (this.coins = R.slice(), this.outputValue = this.tx.getOutputValue(), this.index = 0, this.chosen = [], this.change = 0, this.fee = j.MIN_FEE, this.tx.inputs.length = 0, this.selection) {
          case "all":
          case "random":
            this.coins.sort(T);
            break;
          case "age":
            this.coins.sort(N);
            break;
          case "value":
            this.coins.sort(A);
            break;
          default:
            throw new G(`Bad selection type: ${this.selection}.`);
        }
      }
      /**
       * Calculate total value required.
       * @returns {Amount}
       */
      total() {
        return this.subtractFee ? this.outputValue : this.outputValue + this.fee;
      }
      /**
       * Test whether the selector has
       * completely funded the transaction.
       * @returns {Boolean}
       */
      isFull() {
        return this.tx.getInputValue() >= this.total();
      }
      /**
       * Test whether a coin is spendable
       * with regards to the options.
       * @param {Coin} coin
       * @returns {Boolean}
       */
      isSpendable(R) {
        return this.tx.view.hasEntry(R) ? !1 : this.height === -1 ? !0 : R.coinbase ? !(R.height === -1 || this.height + 1 < R.height + S.COINBASE_MATURITY) : this.depth === -1 ? !0 : !(R.getDepth(this.height) < this.depth);
      }
      /**
       * Get the current fee based on a size.
       * @param {Number} size
       * @returns {Amount}
       */
      getFee(R) {
        if (this.round) {
          const fe = y.getRoundFee(R, this.rate);
          return Math.min(fe, j.MAX_FEE);
        }
        const L = y.getMinFee(R, this.rate);
        return Math.min(L, j.MAX_FEE);
      }
      /**
       * Fund the transaction with more
       * coins if the `output value + fee`
       * total was updated.
       */
      fund() {
        if (this.inputs.size > 0) {
          const R = [];
          for (let L = 0; L < this.inputs.size; L++)
            R.push(null);
          for (const L of this.coins) {
            const { hash: fe, index: ue } = L, ae = i.toKey(fe, ue), D = this.inputs.get(ae);
            D != null && (R[D] = L, this.inputs.delete(ae));
          }
          if (this.inputs.size > 0)
            throw new Error("Could not resolve preferred inputs.");
          for (const L of R)
            this.tx.addCoin(L), this.chosen.push(L);
        }
        for (; this.index < this.coins.length; ) {
          const R = this.coins[this.index++];
          if (this.isSpendable(R) && (this.tx.addCoin(R), this.chosen.push(R), this.selection !== "all" && this.isFull()))
            break;
        }
      }
      /**
       * Initiate selection from `coins`.
       * @param {Coin[]} coins
       * @returns {CoinSelector}
       */
      async select(R) {
        if (this.init(R), this.hardFee !== -1 ? this.selectHard() : await this.selectEstimate(), !this.isFull())
          throw new G(
            "Not enough funds.",
            this.tx.getInputValue(),
            this.total()
          );
        return this.change = this.tx.getInputValue() - this.total(), this;
      }
      /**
       * Initialize selection based on size estimate.
       */
      async selectEstimate() {
        this.fee = j.MIN_FEE, this.fund();
        const R = new o();
        this.changeAddress ? R.script.fromAddress(this.changeAddress) : R.script.fromPubkeyhash(k.allocUnsafe(20)), this.tx.outputs.push(R);
        do {
          const L = await this.tx.estimateSize(this.estimate);
          if (this.fee = this.getFee(L), this.maxFee > 0 && this.fee > this.maxFee)
            throw new G("Fee is too high.");
          this.isFull() || this.fund();
        } while (!this.isFull() && this.index < this.coins.length);
      }
      /**
       * Initiate selection based on a hard fee.
       */
      selectHard() {
        this.fee = Math.min(this.hardFee, j.MAX_FEE), this.fund();
      }
    }
    j.FEE_RATE = 1e4, j.MIN_FEE = 1e4, j.MAX_FEE = S.COIN / 10;
    class G extends Error {
      /**
       * Create a funding error.
       * @constructor
       * @param {String} msg
       * @param {Amount} available
       * @param {Amount} required
       */
      constructor(R, L, fe) {
        super(), this.type = "FundingError", this.message = R, this.availableFunds = -1, this.requiredFunds = -1, L != null && (this.message += ` (available=${b.btc(L)},`, this.message += ` required=${b.btc(fe)})`, this.availableFunds = L, this.requiredFunds = fe), Error.captureStackTrace && Error.captureStackTrace(this, G);
      }
    }
    function N(F, R) {
      return F = F.height === -1 ? 2147483647 : F.height, R = R.height === -1 ? 2147483647 : R.height, F - R;
    }
    function T(F, R) {
      return Math.random() > 0.5 ? 1 : -1;
    }
    function A(F, R) {
      return F.height === -1 && R.height !== -1 ? 1 : F.height !== -1 && R.height === -1 ? -1 : R.value - F.value;
    }
    function q(F, R) {
      return F.compare(R);
    }
    function _(F, R) {
      return F.compare(R);
    }
    c = H, c.MTX = H, c.Selector = j, c.FundingError = G, e.exports = c;
  }(xs, xs.exports)), xs.exports;
}
/*!
 * txmeta.js - extended transaction object for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var w0, F2;
function jg() {
  if (F2) return w0;
  F2 = 1;
  const e = dt, c = Bt, l = pr(), w = is(), { inspectSymbol: m } = cr();
  class f {
    /**
     * Create an extended transaction.
     * @constructor
     * @param {Object?} options
     */
    constructor(u) {
      this.tx = new w(), this.mtime = l.now(), this.height = -1, this.block = null, this.time = 0, this.index = -1, u && this.fromOptions(u);
    }
    /**
     * Inject properties from options object.
     * @private
     * @param {Object} options
     */
    fromOptions(u) {
      return u.tx && (e(u.tx instanceof w), this.tx = u.tx), u.mtime != null && (e(u.mtime >>> 0 === u.mtime), this.mtime = u.mtime), u.height != null && (e(Number.isSafeInteger(u.height)), this.height = u.height), u.block !== void 0 && (e(u.block == null || k.isBuffer(u.block)), this.block = u.block), u.time != null && (e(u.time >>> 0 === u.time), this.time = u.time), u.index != null && (e(Number.isSafeInteger(u.index)), this.index = u.index), this;
    }
    /**
     * Instantiate TXMeta from options.
     * @param {Object} options
     * @returns {TXMeta}
     */
    static fromOptions(u) {
      return new this().fromOptions(u);
    }
    /**
     * Inject properties from options object.
     * @private
     * @param {Object} options
     */
    fromTX(u, o, s) {
      return this.tx = u, o && (this.height = o.height, this.block = o.hash, this.time = o.time, this.index = s), this;
    }
    /**
     * Instantiate TXMeta from options.
     * @param {Object} options
     * @returns {TXMeta}
     */
    static fromTX(u, o, s) {
      return new this().fromTX(u, o, s);
    }
    /**
     * Inspect the transaction.
     * @returns {Object}
     */
    [m]() {
      return this.format();
    }
    /**
     * Inspect the transaction.
     * @returns {Object}
     */
    format(u) {
      const o = this.tx.format(u, null, this.index);
      return o.mtime = this.mtime, o.height = this.height, o.block = this.block ? l.revHex(this.block) : null, o.time = this.time, o;
    }
    /**
     * Convert transaction to JSON.
     * @returns {Object}
     */
    toJSON() {
      return this.getJSON();
    }
    /**
     * Convert the transaction to an object suitable
     * for JSON serialization.
     * @param {Network} network
     * @param {CoinView} view
     * @returns {Object}
     */
    getJSON(u, o, s) {
      const i = this.tx.getJSON(u, o, null, this.index);
      return i.mtime = this.mtime, i.height = this.height, i.block = this.block ? l.revHex(this.block) : null, i.time = this.time, i.confirmations = 0, s != null && this.height !== -1 && (i.confirmations = s - this.height + 1), i;
    }
    /**
     * Inject properties from a json object.
     * @private
     * @param {Object} json
     */
    fromJSON(u) {
      return this.tx.fromJSON(u), e(u.mtime >>> 0 === u.mtime), e(Number.isSafeInteger(u.height)), e(!u.block || typeof u.block == "string"), e(u.time >>> 0 === u.time), e(Number.isSafeInteger(u.index)), this.mtime = u.mtime, this.height = u.height, this.block = l.fromRev(u.block), this.index = u.index, this;
    }
    /**
     * Instantiate a transaction from a
     * jsonified transaction object.
     * @param {Object} json - The jsonified transaction object.
     * @returns {TX}
     */
    static fromJSON(u) {
      return new this().fromJSON(u);
    }
    /**
     * Calculate serialization size.
     * @returns {Number}
     */
    getSize() {
      let u = 0;
      return u += this.tx.getSize(), u += 4, this.block ? (u += 1, u += 32, u += 12) : u += 1, u;
    }
    /**
     * Serialize a transaction to "extended format".
     * This is the serialization format bcoin uses internally
     * to store transactions in the database. The extended
     * serialization includes the height, block hash, index,
     * timestamp, and pending-since time.
     * @returns {Buffer}
     */
    toRaw() {
      const u = this.getSize(), o = c.write(u);
      return this.tx.toWriter(o), o.writeU32(this.mtime), this.block ? (o.writeU8(1), o.writeHash(this.block), o.writeU32(this.height), o.writeU32(this.time), o.writeU32(this.index)) : o.writeU8(0), o.render();
    }
    /**
     * Inject properties from "extended" serialization format.
     * @private
     * @param {Buffer} data
     */
    fromRaw(u) {
      const o = c.read(u);
      return this.tx.fromReader(o), this.mtime = o.readU32(), o.readU8() === 1 && (this.block = o.readHash(), this.height = o.readU32(), this.time = o.readU32(), this.index = o.readU32(), this.index === 2147483647 && (this.index = -1)), this;
    }
    /**
     * Instantiate a transaction from a Buffer
     * in "extended" serialization format.
     * @param {Buffer} data
     * @param {String?} enc - One of `"hex"` or `null`.
     * @returns {TX}
     */
    static fromRaw(u, o) {
      return typeof u == "string" && (u = k.from(u, o)), new this().fromRaw(u);
    }
    /**
     * Test whether an object is an TXMeta.
     * @param {Object} obj
     * @returns {Boolean}
     */
    static isTXMeta(u) {
      return u instanceof f;
    }
  }
  return w0 = f, w0;
}
/*!
 * primitives/index.js - bitcoin primitives for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var H2;
function Yg() {
  return H2 || (H2 = 1, jt.AbstractBlock = rs(), jt.Address = Li(), jt.Block = Ul(), jt.Coin = no(), jt.Headers = ns(), jt.Input = co(), jt.InvItem = fo(), jt.KeyRing = q7(), jt.MemBlock = $g(), jt.MerkleBlock = Dl(), jt.MTX = T7(), jt.Outpoint = vn(), jt.Output = Vi(), jt.TX = is(), jt.TXMeta = jg()), jt;
}
var ci = {}, y0 = {};
/*!
 * errors.js - error objects for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var L2;
function Xg() {
  if (L2) return y0;
  L2 = 1;
  const e = dt;
  class c extends Error {
    /**
     * Create a verify error.
     * @constructor
     * @param {Block|TX} msg
     * @param {String} code - Reject packet code.
     * @param {String} reason - Reject packet reason.
     * @param {Number} score - Ban score increase
     * (can be -1 for no reject packet).
     * @param {Boolean} malleated
     */
    constructor(w, m, f, n, u) {
      super(), e(typeof m == "string"), e(typeof f == "string"), e(n >= 0), this.type = "VerifyError", this.message = "", this.code = m, this.reason = f, this.score = n, this.hash = w.hash(), this.malleated = u || !1, this.message = `Verification failure: ${f} (code=${m} score=${n} hash=${w.rhash()})`, Error.captureStackTrace && Error.captureStackTrace(this, c);
    }
  }
  return y0.VerifyError = c, y0;
}
/*!
 * protocol/index.js - protocol constants for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var K2;
function Gg() {
  return K2 || (K2 = 1, ci.consensus = Xt(), ci.errors = Xg(), ci.Network = Tr(), ci.networks = El(), ci.policy = yn(), ci.timedata = m7()), ci;
}
var Pr = {};
/*!
 * sigcache.js - signature cache for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var v0, V2;
function z7() {
  if (V2) return v0;
  V2 = 1;
  const e = dt, { BufferMap: c } = xn, l = Yr();
  class w {
    /**
     * Create a signature cache.
     * @constructor
     * @param {Number} [size=10000]
     */
    constructor(n) {
      n == null && (n = 1e4), e(n >>> 0 === n), this.size = n, this.keys = [], this.valid = new c();
    }
    /**
     * Resize the sigcache.
     * @param {Number} size
     */
    resize(n) {
      e(n >>> 0 === n), this.size = n, this.keys.length = 0, this.valid.clear();
    }
    /**
     * Add item to the sigcache.
     * Potentially evict a random member.
     * @param {Hash} msg - Sig hash.
     * @param {Buffer} sig
     * @param {Buffer} key
     */
    add(n, u, o) {
      if (this.size !== 0)
        if (this.valid.set(n, new m(u, o)), this.keys.length >= this.size) {
          const s = Math.floor(Math.random() * this.keys.length), i = this.keys[s];
          this.valid.delete(i), this.keys[s] = n;
        } else
          this.keys.push(n);
    }
    /**
     * Test whether the sig exists.
     * @param {Hash} msg - Sig hash.
     * @param {Buffer} sig
     * @param {Buffer} key
     * @returns {Boolean}
     */
    has(n, u, o) {
      const s = this.valid.get(n);
      return s ? s.equals(u, o) : !1;
    }
    /**
     * Verify a signature, testing
     * it against the cache first.
     * @param {Buffer} msg
     * @param {Buffer} sig
     * @param {Buffer} key
     * @returns {Boolean}
     */
    verify(n, u, o) {
      return this.size === 0 ? l.verifyDER(n, u, o) : this.has(n, u, o) ? !0 : l.verifyDER(n, u, o) ? (this.add(n, u, o), !0) : !1;
    }
    /**
     * Verify a schnorr signature, testing
     * it against the cache first.
     * @param {Buffer} msg
     * @param {Buffer} sig
     * @param {Buffer} key
     * @returns {Boolean}
     */
    verifySchnorr(n, u, o) {
      return this.size === 0 ? l.schnorrVerify(n, u, o) : this.has(n, u, o) ? !0 : l.schnorrVerify(n, u, o) ? (this.add(n, u, o), !0) : !1;
    }
  }
  class m {
    /**
     * Create a cache entry.
     * @constructor
     * @param {Buffer} sig
     * @param {Buffer} key
     */
    constructor(n, u) {
      this.sig = k.from(n), this.key = k.from(u);
    }
    /**
     * Compare an entry to a sig and key.
     * @param {Buffer} sig
     * @param {Buffer} key
     * @returns {Boolean}
     */
    equals(n, u) {
      return this.sig.equals(n) && this.key.equals(u);
    }
  }
  return v0 = w, v0;
}
/*!
 * script/index.js - bitcoin scripting for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var $2;
function Jg() {
  return $2 || ($2 = 1, Pr.common = ts(), Pr.Opcode = Ml(), Pr.Script = si(), Pr.ScriptError = to(), Pr.ScriptNum = Ki(), Pr.sigcache = z7(), Pr.Stack = ro(), Pr.Metrics = R7(), Pr.SLP = io()), Pr;
}
var S0 = {}, Tn = {};
/*!
 * aes.js - aes128/192/256 for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on openssl/openssl:
 *   Based on code entered into the public domain by Vincent Rijmen.
 *   https://github.com/openssl/openssl/blob/master/crypto/aes/aes_core.c
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/Advanced_Encryption_Standard
 *   http://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.197.pdf
 *   https://github.com/openssl/openssl/blob/master/crypto/aes/aes_core.c
 */
var E0, j2;
function Wg() {
  if (j2) return E0;
  j2 = 1;
  const e = Mt(), c = new Uint32Array([
    3328402341,
    4168907908,
    4000806809,
    4135287693,
    4294111757,
    3597364157,
    3731845041,
    2445657428,
    1613770832,
    33620227,
    3462883241,
    1445669757,
    3892248089,
    3050821474,
    1303096294,
    3967186586,
    2412431941,
    528646813,
    2311702848,
    4202528135,
    4026202645,
    2992200171,
    2387036105,
    4226871307,
    1101901292,
    3017069671,
    1604494077,
    1169141738,
    597466303,
    1403299063,
    3832705686,
    2613100635,
    1974974402,
    3791519004,
    1033081774,
    1277568618,
    1815492186,
    2118074177,
    4126668546,
    2211236943,
    1748251740,
    1369810420,
    3521504564,
    4193382664,
    3799085459,
    2883115123,
    1647391059,
    706024767,
    134480908,
    2512897874,
    1176707941,
    2646852446,
    806885416,
    932615841,
    168101135,
    798661301,
    235341577,
    605164086,
    461406363,
    3756188221,
    3454790438,
    1311188841,
    2142417613,
    3933566367,
    302582043,
    495158174,
    1479289972,
    874125870,
    907746093,
    3698224818,
    3025820398,
    1537253627,
    2756858614,
    1983593293,
    3084310113,
    2108928974,
    1378429307,
    3722699582,
    1580150641,
    327451799,
    2790478837,
    3117535592,
    0,
    3253595436,
    1075847264,
    3825007647,
    2041688520,
    3059440621,
    3563743934,
    2378943302,
    1740553945,
    1916352843,
    2487896798,
    2555137236,
    2958579944,
    2244988746,
    3151024235,
    3320835882,
    1336584933,
    3992714006,
    2252555205,
    2588757463,
    1714631509,
    293963156,
    2319795663,
    3925473552,
    67240454,
    4269768577,
    2689618160,
    2017213508,
    631218106,
    1269344483,
    2723238387,
    1571005438,
    2151694528,
    93294474,
    1066570413,
    563977660,
    1882732616,
    4059428100,
    1673313503,
    2008463041,
    2950355573,
    1109467491,
    537923632,
    3858759450,
    4260623118,
    3218264685,
    2177748300,
    403442708,
    638784309,
    3287084079,
    3193921505,
    899127202,
    2286175436,
    773265209,
    2479146071,
    1437050866,
    4236148354,
    2050833735,
    3362022572,
    3126681063,
    840505643,
    3866325909,
    3227541664,
    427917720,
    2655997905,
    2749160575,
    1143087718,
    1412049534,
    999329963,
    193497219,
    2353415882,
    3354324521,
    1807268051,
    672404540,
    2816401017,
    3160301282,
    369822493,
    2916866934,
    3688947771,
    1681011286,
    1949973070,
    336202270,
    2454276571,
    201721354,
    1210328172,
    3093060836,
    2680341085,
    3184776046,
    1135389935,
    3294782118,
    965841320,
    831886756,
    3554993207,
    4068047243,
    3588745010,
    2345191491,
    1849112409,
    3664604599,
    26054028,
    2983581028,
    2622377682,
    1235855840,
    3630984372,
    2891339514,
    4092916743,
    3488279077,
    3395642799,
    4101667470,
    1202630377,
    268961816,
    1874508501,
    4034427016,
    1243948399,
    1546530418,
    941366308,
    1470539505,
    1941222599,
    2546386513,
    3421038627,
    2715671932,
    3899946140,
    1042226977,
    2521517021,
    1639824860,
    227249030,
    260737669,
    3765465232,
    2084453954,
    1907733956,
    3429263018,
    2420656344,
    100860677,
    4160157185,
    470683154,
    3261161891,
    1781871967,
    2924959737,
    1773779408,
    394692241,
    2579611992,
    974986535,
    664706745,
    3655459128,
    3958962195,
    731420851,
    571543859,
    3530123707,
    2849626480,
    126783113,
    865375399,
    765172662,
    1008606754,
    361203602,
    3387549984,
    2278477385,
    2857719295,
    1344809080,
    2782912378,
    59542671,
    1503764984,
    160008576,
    437062935,
    1707065306,
    3622233649,
    2218934982,
    3496503480,
    2185314755,
    697932208,
    1512910199,
    504303377,
    2075177163,
    2824099068,
    1841019862,
    739644986
  ]), l = new Uint32Array([
    2781242211,
    2230877308,
    2582542199,
    2381740923,
    234877682,
    3184946027,
    2984144751,
    1418839493,
    1348481072,
    50462977,
    2848876391,
    2102799147,
    434634494,
    1656084439,
    3863849899,
    2599188086,
    1167051466,
    2636087938,
    1082771913,
    2281340285,
    368048890,
    3954334041,
    3381544775,
    201060592,
    3963727277,
    1739838676,
    4250903202,
    3930435503,
    3206782108,
    4149453988,
    2531553906,
    1536934080,
    3262494647,
    484572669,
    2923271059,
    1783375398,
    1517041206,
    1098792767,
    49674231,
    1334037708,
    1550332980,
    4098991525,
    886171109,
    150598129,
    2481090929,
    1940642008,
    1398944049,
    1059722517,
    201851908,
    1385547719,
    1699095331,
    1587397571,
    674240536,
    2704774806,
    252314885,
    3039795866,
    151914247,
    908333586,
    2602270848,
    1038082786,
    651029483,
    1766729511,
    3447698098,
    2682942837,
    454166793,
    2652734339,
    1951935532,
    775166490,
    758520603,
    3000790638,
    4004797018,
    4217086112,
    4137964114,
    1299594043,
    1639438038,
    3464344499,
    2068982057,
    1054729187,
    1901997871,
    2534638724,
    4121318227,
    1757008337,
    0,
    750906861,
    1614815264,
    535035132,
    3363418545,
    3988151131,
    3201591914,
    1183697867,
    3647454910,
    1265776953,
    3734260298,
    3566750796,
    3903871064,
    1250283471,
    1807470800,
    717615087,
    3847203498,
    384695291,
    3313910595,
    3617213773,
    1432761139,
    2484176261,
    3481945413,
    283769337,
    100925954,
    2180939647,
    4037038160,
    1148730428,
    3123027871,
    3813386408,
    4087501137,
    4267549603,
    3229630528,
    2315620239,
    2906624658,
    3156319645,
    1215313976,
    82966005,
    3747855548,
    3245848246,
    1974459098,
    1665278241,
    807407632,
    451280895,
    251524083,
    1841287890,
    1283575245,
    337120268,
    891687699,
    801369324,
    3787349855,
    2721421207,
    3431482436,
    959321879,
    1469301956,
    4065699751,
    2197585534,
    1199193405,
    2898814052,
    3887750493,
    724703513,
    2514908019,
    2696962144,
    2551808385,
    3516813135,
    2141445340,
    1715741218,
    2119445034,
    2872807568,
    2198571144,
    3398190662,
    700968686,
    3547052216,
    1009259540,
    2041044702,
    3803995742,
    487983883,
    1991105499,
    1004265696,
    1449407026,
    1316239930,
    504629770,
    3683797321,
    168560134,
    1816667172,
    3837287516,
    1570751170,
    1857934291,
    4014189740,
    2797888098,
    2822345105,
    2754712981,
    936633572,
    2347923833,
    852879335,
    1133234376,
    1500395319,
    3084545389,
    2348912013,
    1689376213,
    3533459022,
    3762923945,
    3034082412,
    4205598294,
    133428468,
    634383082,
    2949277029,
    2398386810,
    3913789102,
    403703816,
    3580869306,
    2297460856,
    1867130149,
    1918643758,
    607656988,
    4049053350,
    3346248884,
    1368901318,
    600565992,
    2090982877,
    2632479860,
    557719327,
    3717614411,
    3697393085,
    2249034635,
    2232388234,
    2430627952,
    1115438654,
    3295786421,
    2865522278,
    3633334344,
    84280067,
    33027830,
    303828494,
    2747425121,
    1600795957,
    4188952407,
    3496589753,
    2434238086,
    1486471617,
    658119965,
    3106381470,
    953803233,
    334231800,
    3005978776,
    857870609,
    3151128937,
    1890179545,
    2298973838,
    2805175444,
    3056442267,
    574365214,
    2450884487,
    550103529,
    1233637070,
    4289353045,
    2018519080,
    2057691103,
    2399374476,
    4166623649,
    2148108681,
    387583245,
    3664101311,
    836232934,
    3330556482,
    3100665960,
    3280093505,
    2955516313,
    2002398509,
    287182607,
    3413881008,
    4238890068,
    3597515707,
    975967766
  ]), w = new Uint32Array([
    1671808611,
    2089089148,
    2006576759,
    2072901243,
    4061003762,
    1807603307,
    1873927791,
    3310653893,
    810573872,
    16974337,
    1739181671,
    729634347,
    4263110654,
    3613570519,
    2883997099,
    1989864566,
    3393556426,
    2191335298,
    3376449993,
    2106063485,
    4195741690,
    1508618841,
    1204391495,
    4027317232,
    2917941677,
    3563566036,
    2734514082,
    2951366063,
    2629772188,
    2767672228,
    1922491506,
    3227229120,
    3082974647,
    4246528509,
    2477669779,
    644500518,
    911895606,
    1061256767,
    4144166391,
    3427763148,
    878471220,
    2784252325,
    3845444069,
    4043897329,
    1905517169,
    3631459288,
    827548209,
    356461077,
    67897348,
    3344078279,
    593839651,
    3277757891,
    405286936,
    2527147926,
    84871685,
    2595565466,
    118033927,
    305538066,
    2157648768,
    3795705826,
    3945188843,
    661212711,
    2999812018,
    1973414517,
    152769033,
    2208177539,
    745822252,
    439235610,
    455947803,
    1857215598,
    1525593178,
    2700827552,
    1391895634,
    994932283,
    3596728278,
    3016654259,
    695947817,
    3812548067,
    795958831,
    2224493444,
    1408607827,
    3513301457,
    0,
    3979133421,
    543178784,
    4229948412,
    2982705585,
    1542305371,
    1790891114,
    3410398667,
    3201918910,
    961245753,
    1256100938,
    1289001036,
    1491644504,
    3477767631,
    3496721360,
    4012557807,
    2867154858,
    4212583931,
    1137018435,
    1305975373,
    861234739,
    2241073541,
    1171229253,
    4178635257,
    33948674,
    2139225727,
    1357946960,
    1011120188,
    2679776671,
    2833468328,
    1374921297,
    2751356323,
    1086357568,
    2408187279,
    2460827538,
    2646352285,
    944271416,
    4110742005,
    3168756668,
    3066132406,
    3665145818,
    560153121,
    271589392,
    4279952895,
    4077846003,
    3530407890,
    3444343245,
    202643468,
    322250259,
    3962553324,
    1608629855,
    2543990167,
    1154254916,
    389623319,
    3294073796,
    2817676711,
    2122513534,
    1028094525,
    1689045092,
    1575467613,
    422261273,
    1939203699,
    1621147744,
    2174228865,
    1339137615,
    3699352540,
    577127458,
    712922154,
    2427141008,
    2290289544,
    1187679302,
    3995715566,
    3100863416,
    339486740,
    3732514782,
    1591917662,
    186455563,
    3681988059,
    3762019296,
    844522546,
    978220090,
    169743370,
    1239126601,
    101321734,
    611076132,
    1558493276,
    3260915650,
    3547250131,
    2901361580,
    1655096418,
    2443721105,
    2510565781,
    3828863972,
    2039214713,
    3878868455,
    3359869896,
    928607799,
    1840765549,
    2374762893,
    3580146133,
    1322425422,
    2850048425,
    1823791212,
    1459268694,
    4094161908,
    3928346602,
    1706019429,
    2056189050,
    2934523822,
    135794696,
    3134549946,
    2022240376,
    628050469,
    779246638,
    472135708,
    2800834470,
    3032970164,
    3327236038,
    3894660072,
    3715932637,
    1956440180,
    522272287,
    1272813131,
    3185336765,
    2340818315,
    2323976074,
    1888542832,
    1044544574,
    3049550261,
    1722469478,
    1222152264,
    50660867,
    4127324150,
    236067854,
    1638122081,
    895445557,
    1475980887,
    3117443513,
    2257655686,
    3243809217,
    489110045,
    2662934430,
    3778599393,
    4162055160,
    2561878936,
    288563729,
    1773916777,
    3648039385,
    2391345038,
    2493985684,
    2612407707,
    505560094,
    2274497927,
    3911240169,
    3460925390,
    1442818645,
    678973480,
    3749357023,
    2358182796,
    2717407649,
    2306869641,
    219617805,
    3218761151,
    3862026214,
    1120306242,
    1756942440,
    1103331905,
    2578459033,
    762796589,
    252780047,
    2966125488,
    1425844308,
    3151392187,
    372911126
  ]), m = new Uint32Array([
    1667474886,
    2088535288,
    2004326894,
    2071694838,
    4075949567,
    1802223062,
    1869591006,
    3318043793,
    808472672,
    16843522,
    1734846926,
    724270422,
    4278065639,
    3621216949,
    2880169549,
    1987484396,
    3402253711,
    2189597983,
    3385409673,
    2105378810,
    4210693615,
    1499065266,
    1195886990,
    4042263547,
    2913856577,
    3570689971,
    2728590687,
    2947541573,
    2627518243,
    2762274643,
    1920112356,
    3233831835,
    3082273397,
    4261223649,
    2475929149,
    640051788,
    909531756,
    1061110142,
    4160160501,
    3435941763,
    875846760,
    2779116625,
    3857003729,
    4059105529,
    1903268834,
    3638064043,
    825316194,
    353713962,
    67374088,
    3351728789,
    589522246,
    3284360861,
    404236336,
    2526454071,
    84217610,
    2593830191,
    117901582,
    303183396,
    2155911963,
    3806477791,
    3958056653,
    656894286,
    2998062463,
    1970642922,
    151591698,
    2206440989,
    741110872,
    437923380,
    454765878,
    1852748508,
    1515908788,
    2694904667,
    1381168804,
    993742198,
    3604373943,
    3014905469,
    690584402,
    3823320797,
    791638366,
    2223281939,
    1398011302,
    3520161977,
    0,
    3991743681,
    538992704,
    4244381667,
    2981218425,
    1532751286,
    1785380564,
    3419096717,
    3200178535,
    960056178,
    1246420628,
    1280103576,
    1482221744,
    3486468741,
    3503319995,
    4025428677,
    2863326543,
    4227536621,
    1128514950,
    1296947098,
    859002214,
    2240123921,
    1162203018,
    4193849577,
    33687044,
    2139062782,
    1347481760,
    1010582648,
    2678045221,
    2829640523,
    1364325282,
    2745433693,
    1077985408,
    2408548869,
    2459086143,
    2644360225,
    943212656,
    4126475505,
    3166494563,
    3065430391,
    3671750063,
    555836226,
    269496352,
    4294908645,
    4092792573,
    3537006015,
    3452783745,
    202118168,
    320025894,
    3974901699,
    1600119230,
    2543297077,
    1145359496,
    387397934,
    3301201811,
    2812801621,
    2122220284,
    1027426170,
    1684319432,
    1566435258,
    421079858,
    1936954854,
    1616945344,
    2172753945,
    1330631070,
    3705438115,
    572679748,
    707427924,
    2425400123,
    2290647819,
    1179044492,
    4008585671,
    3099120491,
    336870440,
    3739122087,
    1583276732,
    185277718,
    3688593069,
    3772791771,
    842159716,
    976899700,
    168435220,
    1229577106,
    101059084,
    606366792,
    1549591736,
    3267517855,
    3553849021,
    2897014595,
    1650632388,
    2442242105,
    2509612081,
    3840161747,
    2038008818,
    3890688725,
    3368567691,
    926374254,
    1835907034,
    2374863873,
    3587531953,
    1313788572,
    2846482505,
    1819063512,
    1448540844,
    4109633523,
    3941213647,
    1701162954,
    2054852340,
    2930698567,
    134748176,
    3132806511,
    2021165296,
    623210314,
    774795868,
    471606328,
    2795958615,
    3031746419,
    3334885783,
    3907527627,
    3722280097,
    1953799400,
    522133822,
    1263263126,
    3183336545,
    2341176845,
    2324333839,
    1886425312,
    1044267644,
    3048588401,
    1718004428,
    1212733584,
    50529542,
    4143317495,
    235803164,
    1633788866,
    892690282,
    1465383342,
    3115962473,
    2256965911,
    3250673817,
    488449850,
    2661202215,
    3789633753,
    4177007595,
    2560144171,
    286339874,
    1768537042,
    3654906025,
    2391705863,
    2492770099,
    2610673197,
    505291324,
    2273808917,
    3924369609,
    3469625735,
    1431699370,
    673740880,
    3755965093,
    2358021891,
    2711746649,
    2307489801,
    218961690,
    3217021541,
    3873845719,
    1111672452,
    1751693520,
    1094828930,
    2576986153,
    757954394,
    252645662,
    2964376443,
    1414855848,
    3149649517,
    370555436
  ]), f = new Uint32Array([
    1374988112,
    2118214995,
    437757123,
    975658646,
    1001089995,
    530400753,
    2902087851,
    1273168787,
    540080725,
    2910219766,
    2295101073,
    4110568485,
    1340463100,
    3307916247,
    641025152,
    3043140495,
    3736164937,
    632953703,
    1172967064,
    1576976609,
    3274667266,
    2169303058,
    2370213795,
    1809054150,
    59727847,
    361929877,
    3211623147,
    2505202138,
    3569255213,
    1484005843,
    1239443753,
    2395588676,
    1975683434,
    4102977912,
    2572697195,
    666464733,
    3202437046,
    4035489047,
    3374361702,
    2110667444,
    1675577880,
    3843699074,
    2538681184,
    1649639237,
    2976151520,
    3144396420,
    4269907996,
    4178062228,
    1883793496,
    2403728665,
    2497604743,
    1383856311,
    2876494627,
    1917518562,
    3810496343,
    1716890410,
    3001755655,
    800440835,
    2261089178,
    3543599269,
    807962610,
    599762354,
    33778362,
    3977675356,
    2328828971,
    2809771154,
    4077384432,
    1315562145,
    1708848333,
    101039829,
    3509871135,
    3299278474,
    875451293,
    2733856160,
    92987698,
    2767645557,
    193195065,
    1080094634,
    1584504582,
    3178106961,
    1042385657,
    2531067453,
    3711829422,
    1306967366,
    2438237621,
    1908694277,
    67556463,
    1615861247,
    429456164,
    3602770327,
    2302690252,
    1742315127,
    2968011453,
    126454664,
    3877198648,
    2043211483,
    2709260871,
    2084704233,
    4169408201,
    0,
    159417987,
    841739592,
    504459436,
    1817866830,
    4245618683,
    260388950,
    1034867998,
    908933415,
    168810852,
    1750902305,
    2606453969,
    607530554,
    202008497,
    2472011535,
    3035535058,
    463180190,
    2160117071,
    1641816226,
    1517767529,
    470948374,
    3801332234,
    3231722213,
    1008918595,
    303765277,
    235474187,
    4069246893,
    766945465,
    337553864,
    1475418501,
    2943682380,
    4003061179,
    2743034109,
    4144047775,
    1551037884,
    1147550661,
    1543208500,
    2336434550,
    3408119516,
    3069049960,
    3102011747,
    3610369226,
    1113818384,
    328671808,
    2227573024,
    2236228733,
    3535486456,
    2935566865,
    3341394285,
    496906059,
    3702665459,
    226906860,
    2009195472,
    733156972,
    2842737049,
    294930682,
    1206477858,
    2835123396,
    2700099354,
    1451044056,
    573804783,
    2269728455,
    3644379585,
    2362090238,
    2564033334,
    2801107407,
    2776292904,
    3669462566,
    1068351396,
    742039012,
    1350078989,
    1784663195,
    1417561698,
    4136440770,
    2430122216,
    775550814,
    2193862645,
    2673705150,
    1775276924,
    1876241833,
    3475313331,
    3366754619,
    270040487,
    3902563182,
    3678124923,
    3441850377,
    1851332852,
    3969562369,
    2203032232,
    3868552805,
    2868897406,
    566021896,
    4011190502,
    3135740889,
    1248802510,
    3936291284,
    699432150,
    832877231,
    708780849,
    3332740144,
    899835584,
    1951317047,
    4236429990,
    3767586992,
    866637845,
    4043610186,
    1106041591,
    2144161806,
    395441711,
    1984812685,
    1139781709,
    3433712980,
    3835036895,
    2664543715,
    1282050075,
    3240894392,
    1181045119,
    2640243204,
    25965917,
    4203181171,
    4211818798,
    3009879386,
    2463879762,
    3910161971,
    1842759443,
    2597806476,
    933301370,
    1509430414,
    3943906441,
    3467192302,
    3076639029,
    3776767469,
    2051518780,
    2631065433,
    1441952575,
    404016761,
    1942435775,
    1408749034,
    1610459739,
    3745345300,
    2017778566,
    3400528769,
    3110650942,
    941896748,
    3265478751,
    371049330,
    3168937228,
    675039627,
    4279080257,
    967311729,
    135050206,
    3635733660,
    1683407248,
    2076935265,
    3576870512,
    1215061108,
    3501741890
  ]), n = new Uint32Array([
    1347548327,
    1400783205,
    3273267108,
    2520393566,
    3409685355,
    4045380933,
    2880240216,
    2471224067,
    1428173050,
    4138563181,
    2441661558,
    636813900,
    4233094615,
    3620022987,
    2149987652,
    2411029155,
    1239331162,
    1730525723,
    2554718734,
    3781033664,
    46346101,
    310463728,
    2743944855,
    3328955385,
    3875770207,
    2501218972,
    3955191162,
    3667219033,
    768917123,
    3545789473,
    692707433,
    1150208456,
    1786102409,
    2029293177,
    1805211710,
    3710368113,
    3065962831,
    401639597,
    1724457132,
    3028143674,
    409198410,
    2196052529,
    1620529459,
    1164071807,
    3769721975,
    2226875310,
    486441376,
    2499348523,
    1483753576,
    428819965,
    2274680428,
    3075636216,
    598438867,
    3799141122,
    1474502543,
    711349675,
    129166120,
    53458370,
    2592523643,
    2782082824,
    4063242375,
    2988687269,
    3120694122,
    1559041666,
    730517276,
    2460449204,
    4042459122,
    2706270690,
    3446004468,
    3573941694,
    533804130,
    2328143614,
    2637442643,
    2695033685,
    839224033,
    1973745387,
    957055980,
    2856345839,
    106852767,
    1371368976,
    4181598602,
    1033297158,
    2933734917,
    1179510461,
    3046200461,
    91341917,
    1862534868,
    4284502037,
    605657339,
    2547432937,
    3431546947,
    2003294622,
    3182487618,
    2282195339,
    954669403,
    3682191598,
    1201765386,
    3917234703,
    3388507166,
    0,
    2198438022,
    1211247597,
    2887651696,
    1315723890,
    4227665663,
    1443857720,
    507358933,
    657861945,
    1678381017,
    560487590,
    3516619604,
    975451694,
    2970356327,
    261314535,
    3535072918,
    2652609425,
    1333838021,
    2724322336,
    1767536459,
    370938394,
    182621114,
    3854606378,
    1128014560,
    487725847,
    185469197,
    2918353863,
    3106780840,
    3356761769,
    2237133081,
    1286567175,
    3152976349,
    4255350624,
    2683765030,
    3160175349,
    3309594171,
    878443390,
    1988838185,
    3704300486,
    1756818940,
    1673061617,
    3403100636,
    272786309,
    1075025698,
    545572369,
    2105887268,
    4174560061,
    296679730,
    1841768865,
    1260232239,
    4091327024,
    3960309330,
    3497509347,
    1814803222,
    2578018489,
    4195456072,
    575138148,
    3299409036,
    446754879,
    3629546796,
    4011996048,
    3347532110,
    3252238545,
    4270639778,
    915985419,
    3483825537,
    681933534,
    651868046,
    2755636671,
    3828103837,
    223377554,
    2607439820,
    1649704518,
    3270937875,
    3901806776,
    1580087799,
    4118987695,
    3198115200,
    2087309459,
    2842678573,
    3016697106,
    1003007129,
    2802849917,
    1860738147,
    2077965243,
    164439672,
    4100872472,
    32283319,
    2827177882,
    1709610350,
    2125135846,
    136428751,
    3874428392,
    3652904859,
    3460984630,
    3572145929,
    3593056380,
    2939266226,
    824852259,
    818324884,
    3224740454,
    930369212,
    2801566410,
    2967507152,
    355706840,
    1257309336,
    4148292826,
    243256656,
    790073846,
    2373340630,
    1296297904,
    1422699085,
    3756299780,
    3818836405,
    457992840,
    3099667487,
    2135319889,
    77422314,
    1560382517,
    1945798516,
    788204353,
    1521706781,
    1385356242,
    870912086,
    325965383,
    2358957921,
    2050466060,
    2388260884,
    2313884476,
    4006521127,
    901210569,
    3990953189,
    1014646705,
    1503449823,
    1062597235,
    2031621326,
    3212035895,
    3931371469,
    1533017514,
    350174575,
    2256028891,
    2177544179,
    1052338372,
    741876788,
    1606591296,
    1914052035,
    213705253,
    2334669897,
    1107234197,
    1899603969,
    3725069491,
    2631447780,
    2422494913,
    1635502980,
    1893020342,
    1950903388,
    1120974935
  ]), u = new Uint32Array([
    2807058932,
    1699970625,
    2764249623,
    1586903591,
    1808481195,
    1173430173,
    1487645946,
    59984867,
    4199882800,
    1844882806,
    1989249228,
    1277555970,
    3623636965,
    3419915562,
    1149249077,
    2744104290,
    1514790577,
    459744698,
    244860394,
    3235995134,
    1963115311,
    4027744588,
    2544078150,
    4190530515,
    1608975247,
    2627016082,
    2062270317,
    1507497298,
    2200818878,
    567498868,
    1764313568,
    3359936201,
    2305455554,
    2037970062,
    1047239e3,
    1910319033,
    1337376481,
    2904027272,
    2892417312,
    984907214,
    1243112415,
    830661914,
    861968209,
    2135253587,
    2011214180,
    2927934315,
    2686254721,
    731183368,
    1750626376,
    4246310725,
    1820824798,
    4172763771,
    3542330227,
    48394827,
    2404901663,
    2871682645,
    671593195,
    3254988725,
    2073724613,
    145085239,
    2280796200,
    2779915199,
    1790575107,
    2187128086,
    472615631,
    3029510009,
    4075877127,
    3802222185,
    4107101658,
    3201631749,
    1646252340,
    4270507174,
    1402811438,
    1436590835,
    3778151818,
    3950355702,
    3963161475,
    4020912224,
    2667994737,
    273792366,
    2331590177,
    104699613,
    95345982,
    3175501286,
    2377486676,
    1560637892,
    3564045318,
    369057872,
    4213447064,
    3919042237,
    1137477952,
    2658625497,
    1119727848,
    2340947849,
    1530455833,
    4007360968,
    172466556,
    266959938,
    516552836,
    0,
    2256734592,
    3980931627,
    1890328081,
    1917742170,
    4294704398,
    945164165,
    3575528878,
    958871085,
    3647212047,
    2787207260,
    1423022939,
    775562294,
    1739656202,
    3876557655,
    2530391278,
    2443058075,
    3310321856,
    547512796,
    1265195639,
    437656594,
    3121275539,
    719700128,
    3762502690,
    387781147,
    218828297,
    3350065803,
    2830708150,
    2848461854,
    428169201,
    122466165,
    3720081049,
    1627235199,
    648017665,
    4122762354,
    1002783846,
    2117360635,
    695634755,
    3336358691,
    4234721005,
    4049844452,
    3704280881,
    2232435299,
    574624663,
    287343814,
    612205898,
    1039717051,
    840019705,
    2708326185,
    793451934,
    821288114,
    1391201670,
    3822090177,
    376187827,
    3113855344,
    1224348052,
    1679968233,
    2361698556,
    1058709744,
    752375421,
    2431590963,
    1321699145,
    3519142200,
    2734591178,
    188127444,
    2177869557,
    3727205754,
    2384911031,
    3215212461,
    2648976442,
    2450346104,
    3432737375,
    1180849278,
    331544205,
    3102249176,
    4150144569,
    2952102595,
    2159976285,
    2474404304,
    766078933,
    313773861,
    2570832044,
    2108100632,
    1668212892,
    3145456443,
    2013908262,
    418672217,
    3070356634,
    2594734927,
    1852171925,
    3867060991,
    3473416636,
    3907448597,
    2614737639,
    919489135,
    164948639,
    2094410160,
    2997825956,
    590424639,
    2486224549,
    1723872674,
    3157750862,
    3399941250,
    3501252752,
    3625268135,
    2555048196,
    3673637356,
    1343127501,
    4130281361,
    3599595085,
    2957853679,
    1297403050,
    81781910,
    3051593425,
    2283490410,
    532201772,
    1367295589,
    3926170974,
    895287692,
    1953757831,
    1093597963,
    492483431,
    3528626907,
    1446242576,
    1192455638,
    1636604631,
    209336225,
    344873464,
    1015671571,
    669961897,
    3375740769,
    3857572124,
    2973530695,
    3747192018,
    1933530610,
    3464042516,
    935293895,
    3454686199,
    2858115069,
    1863638845,
    3683022916,
    4085369519,
    3292445032,
    875313188,
    1080017571,
    3279033885,
    621591778,
    1233856572,
    2504130317,
    24197544,
    3017672716,
    3835484340,
    3247465558,
    2220981195,
    3060847922,
    1551124588,
    1463996600
  ]), o = new Uint32Array([
    4104605777,
    1097159550,
    396673818,
    660510266,
    2875968315,
    2638606623,
    4200115116,
    3808662347,
    821712160,
    1986918061,
    3430322568,
    38544885,
    3856137295,
    718002117,
    893681702,
    1654886325,
    2975484382,
    3122358053,
    3926825029,
    4274053469,
    796197571,
    1290801793,
    1184342925,
    3556361835,
    2405426947,
    2459735317,
    1836772287,
    1381620373,
    3196267988,
    1948373848,
    3764988233,
    3385345166,
    3263785589,
    2390325492,
    1480485785,
    3111247143,
    3780097726,
    2293045232,
    548169417,
    3459953789,
    3746175075,
    439452389,
    1362321559,
    1400849762,
    1685577905,
    1806599355,
    2174754046,
    137073913,
    1214797936,
    1174215055,
    3731654548,
    2079897426,
    1943217067,
    1258480242,
    529487843,
    1437280870,
    3945269170,
    3049390895,
    3313212038,
    923313619,
    679998e3,
    3215307299,
    57326082,
    377642221,
    3474729866,
    2041877159,
    133361907,
    1776460110,
    3673476453,
    96392454,
    878845905,
    2801699524,
    777231668,
    4082475170,
    2330014213,
    4142626212,
    2213296395,
    1626319424,
    1906247262,
    1846563261,
    562755902,
    3708173718,
    1040559837,
    3871163981,
    1418573201,
    3294430577,
    114585348,
    1343618912,
    2566595609,
    3186202582,
    1078185097,
    3651041127,
    3896688048,
    2307622919,
    425408743,
    3371096953,
    2081048481,
    1108339068,
    2216610296,
    0,
    2156299017,
    736970802,
    292596766,
    1517440620,
    251657213,
    2235061775,
    2933202493,
    758720310,
    265905162,
    1554391400,
    1532285339,
    908999204,
    174567692,
    1474760595,
    4002861748,
    2610011675,
    3234156416,
    3693126241,
    2001430874,
    303699484,
    2478443234,
    2687165888,
    585122620,
    454499602,
    151849742,
    2345119218,
    3064510765,
    514443284,
    4044981591,
    1963412655,
    2581445614,
    2137062819,
    19308535,
    1928707164,
    1715193156,
    4219352155,
    1126790795,
    600235211,
    3992742070,
    3841024952,
    836553431,
    1669664834,
    2535604243,
    3323011204,
    1243905413,
    3141400786,
    4180808110,
    698445255,
    2653899549,
    2989552604,
    2253581325,
    3252932727,
    3004591147,
    1891211689,
    2487810577,
    3915653703,
    4237083816,
    4030667424,
    2100090966,
    865136418,
    1229899655,
    953270745,
    3399679628,
    3557504664,
    4118925222,
    2061379749,
    3079546586,
    2915017791,
    983426092,
    2022837584,
    1607244650,
    2118541908,
    2366882550,
    3635996816,
    972512814,
    3283088770,
    1568718495,
    3499326569,
    3576539503,
    621982671,
    2895723464,
    410887952,
    2623762152,
    1002142683,
    645401037,
    1494807662,
    2595684844,
    1335535747,
    2507040230,
    4293295786,
    3167684641,
    367585007,
    3885750714,
    1865862730,
    2668221674,
    2960971305,
    2763173681,
    1059270954,
    2777952454,
    2724642869,
    1320957812,
    2194319100,
    2429595872,
    2815956275,
    77089521,
    3973773121,
    3444575871,
    2448830231,
    1305906550,
    4021308739,
    2857194700,
    2516901860,
    3518358430,
    1787304780,
    740276417,
    1699839814,
    1592394909,
    2352307457,
    2272556026,
    188821243,
    1729977011,
    3687994002,
    274084841,
    3594982253,
    3613494426,
    2701949495,
    4162096729,
    322734571,
    2837966542,
    1640576439,
    484830689,
    1202797690,
    3537852828,
    4067639125,
    349075736,
    3342319475,
    4157467219,
    4255800159,
    1030690015,
    1155237496,
    2951971274,
    1757691577,
    607398968,
    2738905026,
    499347990,
    3794078908,
    1011452712,
    227885567,
    2818666809,
    213114376,
    3034881240,
    1455525988,
    3414450555,
    850817237,
    1817998408,
    3092726480
  ]), s = new Uint8Array([
    82,
    9,
    106,
    213,
    48,
    54,
    165,
    56,
    191,
    64,
    163,
    158,
    129,
    243,
    215,
    251,
    124,
    227,
    57,
    130,
    155,
    47,
    255,
    135,
    52,
    142,
    67,
    68,
    196,
    222,
    233,
    203,
    84,
    123,
    148,
    50,
    166,
    194,
    35,
    61,
    238,
    76,
    149,
    11,
    66,
    250,
    195,
    78,
    8,
    46,
    161,
    102,
    40,
    217,
    36,
    178,
    118,
    91,
    162,
    73,
    109,
    139,
    209,
    37,
    114,
    248,
    246,
    100,
    134,
    104,
    152,
    22,
    212,
    164,
    92,
    204,
    93,
    101,
    182,
    146,
    108,
    112,
    72,
    80,
    253,
    237,
    185,
    218,
    94,
    21,
    70,
    87,
    167,
    141,
    157,
    132,
    144,
    216,
    171,
    0,
    140,
    188,
    211,
    10,
    247,
    228,
    88,
    5,
    184,
    179,
    69,
    6,
    208,
    44,
    30,
    143,
    202,
    63,
    15,
    2,
    193,
    175,
    189,
    3,
    1,
    19,
    138,
    107,
    58,
    145,
    17,
    65,
    79,
    103,
    220,
    234,
    151,
    242,
    207,
    206,
    240,
    180,
    230,
    115,
    150,
    172,
    116,
    34,
    231,
    173,
    53,
    133,
    226,
    249,
    55,
    232,
    28,
    117,
    223,
    110,
    71,
    241,
    26,
    113,
    29,
    41,
    197,
    137,
    111,
    183,
    98,
    14,
    170,
    24,
    190,
    27,
    252,
    86,
    62,
    75,
    198,
    210,
    121,
    32,
    154,
    219,
    192,
    254,
    120,
    205,
    90,
    244,
    31,
    221,
    168,
    51,
    136,
    7,
    199,
    49,
    177,
    18,
    16,
    89,
    39,
    128,
    236,
    95,
    96,
    81,
    127,
    169,
    25,
    181,
    74,
    13,
    45,
    229,
    122,
    159,
    147,
    201,
    156,
    239,
    160,
    224,
    59,
    77,
    174,
    42,
    245,
    176,
    200,
    235,
    187,
    60,
    131,
    83,
    153,
    97,
    23,
    43,
    4,
    126,
    186,
    119,
    214,
    38,
    225,
    105,
    20,
    99,
    85,
    33,
    12,
    125
  ]), i = new Uint32Array([
    16777216,
    33554432,
    67108864,
    134217728,
    268435456,
    536870912,
    1073741824,
    2147483648,
    452984832,
    905969664
  ]);
  class p {
    constructor(h = 256) {
      e(h >>> 0 === h), this.bits = h, this.rounds = g(h), this.key = null, this.encKey = null, this.decKey = null;
    }
    get blockSize() {
      return 16;
    }
    init(h) {
      if (e(k.isBuffer(h)), h.length !== this.bits >>> 3)
        throw new Error("Invalid key size.");
      return this.destroy(), this.key = k.from(h), this.encKey = null, this.decKey = null, this;
    }
    createEncryptKey() {
      if (!this.key)
        throw new Error("Cipher is not initialized.");
      const h = this.key;
      if (h.length !== this.bits >>> 3)
        throw new Error("Invalid key size.");
      const a = new Uint32Array(60);
      a[0] = S(h, 0), a[1] = S(h, 4), a[2] = S(h, 8), a[3] = S(h, 12);
      let E = 0, H = 0;
      if (this.bits === 128) {
        for (; ; ) {
          const j = a[E + 3];
          if (a[E + 4] = a[E] ^ w[j >>> 16 & 255] & 4278190080 ^ m[j >>> 8 & 255] & 16711680 ^ c[j >>> 0 & 255] & 65280 ^ l[j >>> 24 & 255] & 255 ^ i[H], a[E + 5] = a[E + 1] ^ a[E + 4], a[E + 6] = a[E + 2] ^ a[E + 5], a[E + 7] = a[E + 3] ^ a[E + 6], H += 1, H === 10)
            break;
          E += 4;
        }
        return a;
      }
      if (a[E + 4] = S(h, 16), a[E + 5] = S(h, 20), this.bits === 192) {
        for (; ; ) {
          const j = a[E + 5];
          if (a[E + 6] = a[E] ^ w[j >>> 16 & 255] & 4278190080 ^ m[j >>> 8 & 255] & 16711680 ^ c[j >>> 0 & 255] & 65280 ^ l[j >>> 24 & 255] & 255 ^ i[H], a[E + 7] = a[E + 1] ^ a[E + 6], a[E + 8] = a[E + 2] ^ a[E + 7], a[E + 9] = a[E + 3] ^ a[E + 8], H += 1, H === 8)
            break;
          a[E + 10] = a[E + 4] ^ a[E + 9], a[E + 11] = a[E + 5] ^ a[E + 10], E += 6;
        }
        return a;
      }
      if (a[E + 6] = S(h, 24), a[E + 7] = S(h, 28), this.bits === 256) {
        for (; ; ) {
          let j = a[E + 7];
          if (a[E + 8] = a[E] ^ w[j >>> 16 & 255] & 4278190080 ^ m[j >>> 8 & 255] & 16711680 ^ c[j >>> 0 & 255] & 65280 ^ l[j >>> 24 & 255] & 255 ^ i[H], a[E + 9] = a[E + 1] ^ a[E + 8], a[E + 10] = a[E + 2] ^ a[E + 9], a[E + 11] = a[E + 3] ^ a[E + 10], H += 1, H === 7)
            break;
          j = a[E + 11], a[E + 12] = a[E + 4] ^ w[j >>> 24 & 255] & 4278190080 ^ m[j >>> 16 & 255] & 16711680 ^ c[j >>> 8 & 255] & 65280 ^ l[j >>> 0 & 255] & 255, a[E + 13] = a[E + 5] ^ a[E + 12], a[E + 14] = a[E + 6] ^ a[E + 13], a[E + 15] = a[E + 7] ^ a[E + 14], E += 8;
        }
        return a;
      }
      throw new Error("Bad key size.");
    }
    createDecryptKey() {
      const h = this.createEncryptKey();
      let a = 0;
      for (let E = 0, H = 4 * this.rounds; E < H; E += 4, H -= 4) {
        let j = h[a + E + 0];
        h[a + E + 0] = h[a + H + 0], h[a + H + 0] = j, j = h[a + E + 1], h[a + E + 1] = h[a + H + 1], h[a + H + 1] = j, j = h[a + E + 2], h[a + E + 2] = h[a + H + 2], h[a + H + 2] = j, j = h[a + E + 3], h[a + E + 3] = h[a + H + 3], h[a + H + 3] = j;
      }
      for (let E = 1; E < this.rounds; E++)
        a += 4, h[a + 0] = f[l[h[a + 0] >>> 24 & 255] & 255] ^ n[l[h[a + 0] >>> 16 & 255] & 255] ^ u[l[h[a + 0] >>> 8 & 255] & 255] ^ o[l[h[a + 0] >>> 0 & 255] & 255], h[a + 1] = f[l[h[a + 1] >>> 24 & 255] & 255] ^ n[l[h[a + 1] >>> 16 & 255] & 255] ^ u[l[h[a + 1] >>> 8 & 255] & 255] ^ o[l[h[a + 1] >>> 0 & 255] & 255], h[a + 2] = f[l[h[a + 2] >>> 24 & 255] & 255] ^ n[l[h[a + 2] >>> 16 & 255] & 255] ^ u[l[h[a + 2] >>> 8 & 255] & 255] ^ o[l[h[a + 2] >>> 0 & 255] & 255], h[a + 3] = f[l[h[a + 3] >>> 24 & 255] & 255] ^ n[l[h[a + 3] >>> 16 & 255] & 255] ^ u[l[h[a + 3] >>> 8 & 255] & 255] ^ o[l[h[a + 3] >>> 0 & 255] & 255];
      return h;
    }
    getEncryptKey() {
      return this.encKey || (this.encKey = this.createEncryptKey()), this.encKey;
    }
    getDecryptKey() {
      return this.decKey || (this.decKey = this.createDecryptKey()), this.decKey;
    }
    encrypt(h, a, E, H) {
      const j = this.getEncryptKey();
      let G = S(E, H + 0) ^ j[0], N = S(E, H + 4) ^ j[1], T = S(E, H + 8) ^ j[2], A = S(E, H + 12) ^ j[3], q = this.rounds >>> 1, _ = 0, F, R, L, fe;
      for (; F = c[G >>> 24 & 255] ^ l[N >>> 16 & 255] ^ w[T >>> 8 & 255] ^ m[A >>> 0 & 255] ^ j[_ + 4], R = c[N >>> 24 & 255] ^ l[T >>> 16 & 255] ^ w[A >>> 8 & 255] ^ m[G >>> 0 & 255] ^ j[_ + 5], L = c[T >>> 24 & 255] ^ l[A >>> 16 & 255] ^ w[G >>> 8 & 255] ^ m[N >>> 0 & 255] ^ j[_ + 6], fe = c[A >>> 24 & 255] ^ l[G >>> 16 & 255] ^ w[N >>> 8 & 255] ^ m[T >>> 0 & 255] ^ j[_ + 7], _ += 8, q -= 1, q !== 0; )
        G = c[F >>> 24 & 255] ^ l[R >>> 16 & 255] ^ w[L >>> 8 & 255] ^ m[fe >>> 0 & 255] ^ j[_ + 0], N = c[R >>> 24 & 255] ^ l[L >>> 16 & 255] ^ w[fe >>> 8 & 255] ^ m[F >>> 0 & 255] ^ j[_ + 1], T = c[L >>> 24 & 255] ^ l[fe >>> 16 & 255] ^ w[F >>> 8 & 255] ^ m[R >>> 0 & 255] ^ j[_ + 2], A = c[fe >>> 24 & 255] ^ l[F >>> 16 & 255] ^ w[R >>> 8 & 255] ^ m[L >>> 0 & 255] ^ j[_ + 3];
      return G = w[F >>> 24 & 255] & 4278190080 ^ m[R >>> 16 & 255] & 16711680 ^ c[L >>> 8 & 255] & 65280 ^ l[fe >>> 0 & 255] & 255 ^ j[_ + 0], N = w[R >>> 24 & 255] & 4278190080 ^ m[L >>> 16 & 255] & 16711680 ^ c[fe >>> 8 & 255] & 65280 ^ l[F >>> 0 & 255] & 255 ^ j[_ + 1], T = w[L >>> 24 & 255] & 4278190080 ^ m[fe >>> 16 & 255] & 16711680 ^ c[F >>> 8 & 255] & 65280 ^ l[R >>> 0 & 255] & 255 ^ j[_ + 2], A = w[fe >>> 24 & 255] & 4278190080 ^ m[F >>> 16 & 255] & 16711680 ^ c[R >>> 8 & 255] & 65280 ^ l[L >>> 0 & 255] & 255 ^ j[_ + 3], y(h, G, a + 0), y(h, N, a + 4), y(h, T, a + 8), y(h, A, a + 12), this;
    }
    decrypt(h, a, E, H) {
      const j = this.getDecryptKey();
      let G = S(E, H + 0) ^ j[0], N = S(E, H + 4) ^ j[1], T = S(E, H + 8) ^ j[2], A = S(E, H + 12) ^ j[3], q = this.rounds >>> 1, _ = 0, F, R, L, fe;
      for (; F = f[G >>> 24 & 255] ^ n[A >>> 16 & 255] ^ u[T >>> 8 & 255] ^ o[N >>> 0 & 255] ^ j[_ + 4], R = f[N >>> 24 & 255] ^ n[G >>> 16 & 255] ^ u[A >>> 8 & 255] ^ o[T >>> 0 & 255] ^ j[_ + 5], L = f[T >>> 24 & 255] ^ n[N >>> 16 & 255] ^ u[G >>> 8 & 255] ^ o[A >>> 0 & 255] ^ j[_ + 6], fe = f[A >>> 24 & 255] ^ n[T >>> 16 & 255] ^ u[N >>> 8 & 255] ^ o[G >>> 0 & 255] ^ j[_ + 7], _ += 8, q -= 1, q !== 0; )
        G = f[F >>> 24 & 255] ^ n[fe >>> 16 & 255] ^ u[L >>> 8 & 255] ^ o[R >>> 0 & 255] ^ j[_ + 0], N = f[R >>> 24 & 255] ^ n[F >>> 16 & 255] ^ u[fe >>> 8 & 255] ^ o[L >>> 0 & 255] ^ j[_ + 1], T = f[L >>> 24 & 255] ^ n[R >>> 16 & 255] ^ u[F >>> 8 & 255] ^ o[fe >>> 0 & 255] ^ j[_ + 2], A = f[fe >>> 24 & 255] ^ n[L >>> 16 & 255] ^ u[R >>> 8 & 255] ^ o[F >>> 0 & 255] ^ j[_ + 3];
      return G = s[F >>> 24 & 255] << 24 ^ s[fe >>> 16 & 255] << 16 ^ s[L >>> 8 & 255] << 8 ^ s[R >>> 0 & 255] << 0 ^ j[_ + 0], N = s[R >>> 24 & 255] << 24 ^ s[F >>> 16 & 255] << 16 ^ s[fe >>> 8 & 255] << 8 ^ s[L >>> 0 & 255] << 0 ^ j[_ + 1], T = s[L >>> 24 & 255] << 24 ^ s[R >>> 16 & 255] << 16 ^ s[F >>> 8 & 255] << 8 ^ s[fe >>> 0 & 255] << 0 ^ j[_ + 2], A = s[fe >>> 24 & 255] << 24 ^ s[L >>> 16 & 255] << 16 ^ s[R >>> 8 & 255] << 8 ^ s[F >>> 0 & 255] << 0 ^ j[_ + 3], y(h, G, a + 0), y(h, N, a + 4), y(h, T, a + 8), y(h, A, a + 12), this;
    }
    destroy() {
      if (this.key)
        for (let h = 0; h < this.key.length; h++)
          this.key[h] = 0;
      if (this.encKey)
        for (let h = 0; h < 60; h++)
          this.encKey[h] = 0;
      if (this.decKey)
        for (let h = 0; h < 60; h++)
          this.decKey[h] = 0;
      return this.key = null, this.encKey = null, this.decKey = null, this;
    }
  }
  function g(b) {
    switch (b) {
      case 128:
        return 10;
      case 192:
        return 12;
      case 256:
        return 14;
      default:
        throw new Error("Bad key size.");
    }
  }
  function S(b, h) {
    return b[h++] * 16777216 + b[h++] * 65536 + b[h++] * 256 + b[h];
  }
  function y(b, h, a) {
    return b[a++] = h >>> 24, b[a++] = h >>> 16, b[a++] = h >>> 8, b[a++] = h, a;
  }
  return E0 = p, E0;
}
var yt = {};
/*!
 * ghash.js - ghash for javascript
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on golang/go:
 *   Copyright (c) 2009, The Go Authors. All rights reserved.
 *   https://github.com/golang/go
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/Galois/Counter_Mode
 *   https://dx.doi.org/10.6028/NIST.SP.800-38D
 *   https://github.com/golang/go/blob/master/src/crypto/cipher/gcm.go
 *   https://github.com/golang/go/blob/master/src/crypto/cipher/gcm_test.go
 *   https://github.com/DaGenix/rust-crypto/blob/master/src/ghash.rs
 */
var I0, Y2;
function Zg() {
  if (Y2) return I0;
  Y2 = 1;
  const e = Mt(), c = k.alloc(16, 0), l = -1, w = new Uint16Array([
    0,
    7200,
    14400,
    9312,
    28800,
    27808,
    18624,
    21728,
    57600,
    64800,
    55616,
    50528,
    37248,
    36256,
    43456,
    46560
  ]);
  class m {
    constructor() {
      this.state = new Uint32Array(4), this.block = k.alloc(16), this.size = l, this.adLen = 0, this.ctLen = 0, this.table = new Array(16);
      for (let p = 0; p < 16; p++)
        this.table[p] = new Uint32Array(4);
    }
    init(p) {
      e(k.isBuffer(p)), e(p.length === 16);
      for (let S = 0; S < 4; S++)
        this.state[S] = 0;
      this.size = 0, this.adLen = 0, this.ctLen = 0;
      for (let S = 0; S < 16; S++)
        for (let y = 0; y < 4; y++)
          this.table[S][y] = 0;
      const g = new Uint32Array(4);
      g[1] = o(p, 0), g[0] = o(p, 4), g[3] = o(p, 8), g[2] = o(p, 12), this.table[u(1)] = g;
      for (let S = 2; S < 16; S += 2)
        this.table[u(S)] = this.double(this.table[u(S >>> 1)]), this.table[u(S + 1)] = this.add(this.table[u(S)], g);
      return this;
    }
    absorb(p) {
      return this._absorb(p, p.length), this;
    }
    _absorb(p, g) {
      e(this.size !== l, "Context is not initialized.");
      let S = this.size & 15, y = 0;
      if (this.size += g, S > 0) {
        let b = 16 - S;
        if (b > g && (b = g), p.copy(this.block, S, y, y + b), S += b, g -= b, y += b, S < 16)
          return;
        this.transform(this.block, 0);
      }
      for (; g >= 16; )
        this.transform(p, y), y += 16, g -= 16;
      g > 0 && p.copy(this.block, 0, y, y + g);
    }
    transform(p, g) {
      this.state[1] ^= o(p, g + 0), this.state[0] ^= o(p, g + 4), this.state[3] ^= o(p, g + 8), this.state[2] ^= o(p, g + 12), this.mul(this.state);
    }
    pad() {
      const p = this.size & 15;
      p !== 0 && this._absorb(c, 16 - p);
    }
    aad(p) {
      return e(k.isBuffer(p)), e(this.ctLen === 0), this.adLen += p.length, this.absorb(p);
    }
    update(p) {
      return e(k.isBuffer(p)), p.length === 0 ? this : (this.ctLen === 0 && this.pad(), this.ctLen += p.length, this.absorb(p));
    }
    final() {
      const p = k.alloc(16);
      this.pad();
      const g = this.adLen * 8, S = this.ctLen * 8;
      this.state[1] ^= f(g), this.state[0] ^= n(g), this.state[3] ^= f(S), this.state[2] ^= n(S), this.mul(this.state), s(p, this.state[1], 0), s(p, this.state[0], 4), s(p, this.state[3], 8), s(p, this.state[2], 12);
      for (let y = 0; y < 4; y++)
        this.state[y] = 0;
      for (let y = 0; y < 16; y++)
        this.block[y] = 0;
      this.size = l, this.adLen = 0, this.ctLen = 0;
      for (let y = 0; y < 16; y++)
        for (let b = 0; b < 4; b++)
          this.table[y][b] = 0;
      return p;
    }
    destroy() {
      for (let p = 0; p < 4; p++)
        this.state[p] = 0;
      for (let p = 0; p < 16; p++)
        this.block[p] = 0;
      this.size = l, this.adLen = 0, this.ctLen = 0;
      for (let p = 0; p < 16; p++)
        for (let g = 0; g < 4; g++)
          this.table[p][g] = 0;
    }
    add(p, g) {
      e(p instanceof Uint32Array), e(p.length === 4), e(g instanceof Uint32Array), e(g.length === 4);
      const S = new Uint32Array(4);
      return S[0] = p[0] ^ g[0], S[1] = p[1] ^ g[1], S[2] = p[2] ^ g[2], S[3] = p[3] ^ g[3], S;
    }
    double(p) {
      e(p instanceof Uint32Array), e(p.length === 4);
      const g = new Uint32Array(4), S = (p[2] & 1) === 1;
      let y;
      return g[3] = p[3], g[2] = p[2], y = g[3] & 1, g[3] >>>= 1, g[2] >>>= 1, g[2] |= y << 31, g[3] |= (p[0] & 1) << 31, g[1] = p[1], g[0] = p[0], y = g[1] & 1, g[1] >>>= 1, g[0] >>>= 1, g[0] |= y << 31, S && (g[1] ^= 3774873600, g[0] ^= 0), g;
    }
    mul(p) {
      e(p instanceof Uint32Array), e(p.length === 4);
      const g = new Uint32Array(4), S = new Uint32Array(2);
      let y, b;
      for (let h = 0; h < 2; h++) {
        S[0] = p[2], S[1] = p[3], h === 1 && (S[0] = p[0], S[1] = p[1]);
        for (let a = 0; a < 64; a += 4) {
          const E = g[2] & 15;
          y = g[3] & 15, g[3] >>>= 4, g[2] >>>= 4, g[2] |= y << 28, g[3] |= g[0] << 28, y = g[1] & 15, g[1] >>>= 4, g[0] >>>= 4, g[0] |= y << 28, g[1] ^= w[E] << 16, b = this.table[S[0] & 15], g[0] ^= b[0], g[1] ^= b[1], g[2] ^= b[2], g[3] ^= b[3], y = S[1] & 15, S[1] >>>= 4, S[0] >>>= 4, S[0] |= y << 28;
        }
      }
      p[0] = g[0], p[1] = g[1], p[2] = g[2], p[3] = g[3];
    }
  }
  function f(i) {
    return i * (1 / 4294967296) >>> 0;
  }
  function n(i) {
    return i >>> 0;
  }
  function u(i) {
    return i = i << 2 & 12 | i >>> 2 & 3, i = i << 1 & 10 | i >>> 1 & 5, i;
  }
  function o(i, p) {
    return i[p++] * 16777216 + i[p++] * 65536 + i[p++] * 256 + i[p++];
  }
  function s(i, p, g) {
    return i[g++] = p >>> 24, i[g++] = p >>> 16, i[g++] = p >>> 8, i[g++] = p, g;
  }
  return I0 = m, I0;
}
/*!
 * modes.js - cipher modes for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation
 */
var X2;
function Qg() {
  if (X2) return yt;
  X2 = 1;
  const e = Mt(), c = Zg(), l = k.alloc(0), w = new Uint32Array([
    27,
    // 8
    135,
    // 16
    1061,
    // 32
    0,
    293,
    // 64
    0,
    0,
    0,
    524355
    // 128
  ]);
  class m {
    constructor(z) {
      e(z && typeof z.encrypt == "function"), e(typeof z.blockSize == "number"), this.ctx = z;
    }
    get blockSize() {
      return this.ctx.blockSize;
    }
    init(z, I) {
      throw new Error("Not implemented.");
    }
    update(z) {
      throw new Error("Not implemented.");
    }
    crypt(z, I) {
      throw new Error("Not implemented.");
    }
    final() {
      throw new Error("Not implemented.");
    }
    destroy() {
      throw new Error("Not implemented.");
    }
    setAutoPadding(z) {
      return e(typeof z == "boolean"), this._setAutoPadding(z), this;
    }
    setAAD(z) {
      return e(k.isBuffer(z)), this._setAAD(z), this;
    }
    setCCM(z, I, ne) {
      return e(z >>> 0 === z), e(I >>> 0 === I), e(ne == null || k.isBuffer(ne)), this._setCCM(z, I, ne), this;
    }
    getAuthTag() {
      return this._getAuthTag();
    }
    setAuthTag(z) {
      return e(k.isBuffer(z)), this._setAuthTag(z), this;
    }
    _setAutoPadding(z) {
      throw new Error("Not available.");
    }
    _setAAD(z) {
      throw new Error("Cipher is not authenticated.");
    }
    _setCCM(z, I, ne) {
      throw new Error("Not available.");
    }
    _getAuthTag() {
      throw new Error("Cipher is not authenticated.");
    }
    _setAuthTag(z) {
      throw new Error("Cipher is not authenticated.");
    }
  }
  class f extends m {
    constructor(z, I) {
      super(z), this.padding = !0, this.unpad = I, this.block = k.alloc(this.blockSize), this.blockPos = -1, this.last = null, this.lastSize = 0, I && (this.last = k.alloc(this.blockSize));
    }
    init(z, I) {
      return I == null && (I = l), e(k.isBuffer(z)), e(k.isBuffer(I)), this.ctx.init(z), this.blockPos = 0, this.lastSize = 0, this._init(z, I), this;
    }
    _updateSize(z) {
      if (this.blockPos + z < this.blockSize)
        return 0;
      let I = 0;
      return this.unpad && (I += this.lastSize), this.blockPos > 0 && (z -= this.blockSize - this.blockPos, I += this.blockSize), z >= this.blockSize && (I += z - z % this.blockSize), e(I >= this.blockSize), I;
    }
    update(z) {
      if (e(k.isBuffer(z)), this.blockPos === -1)
        throw new Error("Cipher is not initialized.");
      const I = this._updateSize(z.length), ne = k.alloc(I);
      if (this.blockPos + z.length < this.blockSize)
        return this.blockPos += z.copy(this.block, this.blockPos, 0, z.length), ne;
      let t = z.length, d = 0, B = 0;
      if (this.unpad && (B += this.last.copy(ne, B, 0, this.lastSize)), this.blockPos > 0) {
        const U = this.blockSize - this.blockPos;
        d += z.copy(this.block, this.blockPos, d, d + U), t -= U, this._update(ne, B, this.block, 0), B += this.blockSize, this.blockPos = 0;
      }
      for (; t >= this.blockSize; )
        this._update(ne, B, z, d), d += this.blockSize, t -= this.blockSize, B += this.blockSize;
      return t > 0 && (this.blockPos = z.copy(this.block, 0, d, d + t)), e(B === I), this.unpad ? (this.lastSize = ne.copy(this.last, 0, I - this.blockSize, I), ne.slice(0, I - this.blockSize)) : ne;
    }
    crypt(z, I) {
      if (e(k.isBuffer(z)), e(k.isBuffer(I)), e(z.length === I.length), this.blockPos === -1)
        throw new Error("Cipher is not initialized.");
      if (this.unpad || this.blockPos !== 0)
        throw new Error("Cannot crypt while buffering.");
      if (I.length % this.blockSize !== 0)
        throw new Error("Input must be a multiple of the block size.");
      const ne = this.blockSize;
      let t = I.length, d = 0;
      for (; t > 0; )
        this._update(z, d, I, d), d += ne, t -= ne;
      return z;
    }
    final() {
      if (this.blockPos === -1)
        throw new Error("Cipher is not initialized.");
      try {
        return this._final();
      } finally {
        this.destroy();
      }
    }
    destroy() {
      this.ctx.destroy(), this.blockPos = -1, this.lastSize = 0;
      for (let z = 0; z < this.blockSize; z++)
        this.block[z] = 0;
      if (this.unpad)
        for (let z = 0; z < this.blockSize; z++)
          this.last[z] = 0;
      return this._destroy(), this;
    }
    _init(z, I) {
      throw new Error("Not implemented.");
    }
    _update(z, I, ne, t) {
      throw new Error("Not implemented.");
    }
    _final() {
      throw new Error("Not implemented.");
    }
    _destroy() {
      throw new Error("Not implemented.");
    }
  }
  class n extends m {
    constructor(z) {
      super(z), this.pos = -1;
    }
    init(z, I) {
      return I == null && (I = l), e(k.isBuffer(z)), e(k.isBuffer(I)), this.ctx.init(z), this.pos = 0, this._init(z, I), this;
    }
    update(z) {
      if (e(k.isBuffer(z)), this.pos === -1)
        throw new Error("Cipher is not initialized.");
      const I = k.alloc(z.length);
      return this._crypt(I, z), I;
    }
    crypt(z, I) {
      if (e(k.isBuffer(z)), e(k.isBuffer(I)), e(z.length === I.length), this.pos === -1)
        throw new Error("Cipher is not initialized.");
      return this._crypt(z, I), z;
    }
    final() {
      if (this.pos === -1)
        throw new Error("Cipher is not initialized.");
      try {
        return this._final();
      } finally {
        this.destroy();
      }
    }
    destroy() {
      return this.ctx.destroy(), this.pos = -1, this._destroy(), this;
    }
    _init(z, I) {
      throw new Error("Not implemented.");
    }
    _crypt(z, I) {
      throw new Error("Not implemented.");
    }
    _final() {
      throw new Error("Not implemented.");
    }
    _destroy() {
      throw new Error("Not implemented.");
    }
  }
  class u extends f {
    constructor(z) {
      super(z, !1);
    }
    _init(z, I) {
      e(I.length === 0);
    }
    _update(z, I, ne, t) {
      this.ctx.encrypt(z, I, ne, t);
    }
    _final() {
      if (this.blockPos !== 0)
        throw new Error("Bad encrypt (trailing bytes).");
      return k.alloc(0);
    }
    _destroy() {
    }
  }
  class o extends f {
    constructor(z) {
      super(z, !1);
    }
    _init(z, I) {
      e(I.length === 0);
    }
    _update(z, I, ne, t) {
      this.ctx.decrypt(z, I, ne, t);
    }
    _final() {
      if (this.blockPos !== 0)
        throw new Error("Bad decrypt (trailing bytes).");
      return k.alloc(0);
    }
    _destroy() {
    }
  }
  class s extends f {
    constructor(z) {
      super(z, !1);
    }
    _final() {
      if (!this.padding) {
        if (this.blockPos !== 0)
          throw new Error("Bad encrypt (trailing bytes).");
        return k.alloc(0);
      }
      const z = this.blockSize - this.blockPos, I = k.from(this.block);
      for (let ne = this.blockPos; ne < this.blockSize; ne++)
        I[ne] = z;
      return this._update(I, 0, I, 0), I;
    }
    _setAutoPadding(z) {
      this.padding = z;
    }
  }
  class i extends f {
    constructor(z) {
      super(z, !0);
    }
    _final() {
      if (this.blockPos !== 0)
        throw new Error("Bad decrypt (trailing bytes).");
      if (!this.padding)
        return k.alloc(0);
      if (this.lastSize === 0)
        throw new Error("Bad decrypt (no data).");
      e(this.lastSize === this.last.length), e(this.lastSize === this.blockSize);
      const z = k.from(this.last);
      let I = z[z.length - 1], ne = 1;
      ne &= I - 1 >>> 31 ^ 1, ne &= I - this.blockSize - 1 >>> 31, I &= -ne;
      const t = this.blockSize - I;
      for (let d = 0; d < this.blockSize; d++) {
        const B = z[d];
        ne &= d - t >>> 31 | (B ^ I) - 1 >>> 31;
      }
      if (!ne)
        throw new Error("Bad decrypt (padding).");
      return z.slice(0, t);
    }
    _setAutoPadding(z) {
      if (this.lastSize !== 0 || this.blockPos !== 0)
        throw new Error("Cannot set auto padding.");
      this.padding = z, this.unpad = z;
    }
  }
  class p extends s {
    constructor(z) {
      super(z);
    }
    _init(z, I) {
      e(I.length === 0);
    }
    _update(z, I, ne, t) {
      this.ctx.encrypt(z, I, ne, t);
    }
    _destroy() {
    }
  }
  class g extends i {
    constructor(z) {
      super(z);
    }
    _init(z, I) {
      e(I.length === 0);
    }
    _update(z, I, ne, t) {
      this.ctx.decrypt(z, I, ne, t);
    }
    _destroy() {
    }
  }
  class S extends s {
    constructor(z) {
      super(z), this.prev = k.alloc(this.blockSize);
    }
    _init(z, I) {
      e(I.length === this.blockSize), I.copy(this.prev, 0);
    }
    _update(z, I, ne, t) {
      for (let d = 0; d < this.blockSize; d++)
        this.prev[d] ^= ne[t + d];
      this.ctx.encrypt(z, I, this.prev, 0), z.copy(this.prev, 0, I, I + this.blockSize);
    }
    _destroy() {
      for (let z = 0; z < this.blockSize; z++)
        this.prev[z] = 0;
    }
  }
  class y extends i {
    constructor(z) {
      super(z), this.prev = k.alloc(this.blockSize), this.tmp = k.alloc(this.blockSize);
    }
    _init(z, I) {
      e(I.length === this.blockSize), I.copy(this.prev, 0);
    }
    _update(z, I, ne, t) {
      if (ge(z, I, ne, t)) {
        this.prev.copy(this.tmp, 0), ne.copy(this.prev, 0, t, t + this.blockSize), this.ctx.decrypt(z, I, ne, t);
        for (let d = 0; d < this.blockSize; d++)
          z[I + d] ^= this.tmp[d];
      } else {
        this.ctx.decrypt(z, I, ne, t);
        for (let d = 0; d < this.blockSize; d++)
          z[I + d] ^= this.prev[d];
        ne.copy(this.prev, 0, t, t + this.blockSize);
      }
    }
    _destroy() {
      for (let z = 0; z < this.blockSize; z++)
        this.prev[z] = 0, this.tmp[z] = 0;
    }
  }
  class b extends f {
    constructor(z) {
      super(z, !0), this.prev = k.alloc(this.blockSize);
    }
    _init(z, I) {
      e(I.length === this.blockSize), I.copy(this.prev, 0);
    }
    _update(z, I, ne, t) {
      for (let d = 0; d < this.blockSize; d++)
        this.prev[d] ^= ne[t + d];
      this.ctx.encrypt(z, I, this.prev, 0), z.copy(this.prev, 0, I, I + this.blockSize);
    }
    _final() {
      if (!this.padding) {
        if (this.blockPos !== 0)
          throw new Error("Bad encrypt (trailing bytes).");
        return k.alloc(0);
      }
      if (this.lastSize === 0)
        throw new Error("Bad encrypt (no data).");
      for (let I = 0; I < this.blockPos; I++)
        this.prev[I] ^= this.block[I];
      this.ctx.encrypt(this.prev, 0, this.prev, 0);
      const z = this.last.slice(0, this.blockPos);
      return k.concat([this.prev, z]);
    }
    _destroy() {
      for (let z = 0; z < this.blockSize; z++)
        this.prev[z] = 0;
    }
    _setAutoPadding(z) {
      if (this.lastSize !== 0 || this.blockPos !== 0)
        throw new Error("Cannot set auto padding.");
      this.padding = z, this.unpad = z;
    }
  }
  class h extends f {
    constructor(z) {
      super(z, !0), this.prev = k.alloc(this.blockSize), this.tmp = k.alloc(this.blockSize);
    }
    _init(z, I) {
      e(I.length === this.blockSize), I.copy(this.prev, 0);
    }
    _update(z, I, ne, t) {
      if (ge(z, I, ne, t)) {
        this.prev.copy(this.tmp, 0), ne.copy(this.prev, 0, t, t + this.blockSize), this.ctx.decrypt(z, I, ne, t);
        for (let d = 0; d < this.blockSize; d++)
          z[I + d] ^= this.tmp[d];
      } else {
        this.ctx.decrypt(z, I, ne, t);
        for (let d = 0; d < this.blockSize; d++)
          z[I + d] ^= this.prev[d];
        ne.copy(this.prev, 0, t, t + this.blockSize);
      }
    }
    _final() {
      if (!this.padding) {
        if (this.blockPos !== 0)
          throw new Error("Bad decrypt (trailing bytes).");
        return k.alloc(0);
      }
      if (this.lastSize === 0)
        throw new Error("Bad decrypt (no data).");
      const z = k.alloc(this.blockSize);
      this.ctx.decrypt(this.prev, 0, this.prev, 0);
      for (let ne = 0; ne < this.blockSize; ne++)
        z[ne] = this.last[ne] ^ this.prev[ne];
      for (let ne = 0; ne < this.blockPos; ne++)
        this.last[ne] = this.block[ne], this.block[ne] ^= this.prev[ne];
      for (let ne = this.blockPos; ne < this.blockSize; ne++)
        this.last[ne] = this.prev[ne];
      this.ctx.decrypt(this.last, 0, this.last, 0);
      for (let ne = 0; ne < this.blockSize; ne++)
        this.last[ne] ^= z[ne];
      const I = this.block.slice(0, this.blockPos);
      return k.concat([this.last, I]);
    }
    _destroy() {
      for (let z = 0; z < this.blockSize; z++)
        this.prev[z] = 0, this.tmp[z] = 0;
    }
    _setAutoPadding(z) {
      if (this.lastSize !== 0 || this.blockPos !== 0)
        throw new Error("Cannot set auto padding.");
      this.padding = z, this.unpad = z;
    }
  }
  class a extends f {
    constructor(z, I) {
      super(z, !0), this.encrypt = I, this.poly = w[this.blockSize >>> 4], this.tweak = k.alloc(this.blockSize), this.prev = k.alloc(this.blockSize);
    }
    init(z, I) {
      e(k.isBuffer(z)), e(k.isBuffer(I)), e(z.length > 0 && (z.length & 1) === 0), e(I.length === this.blockSize);
      const ne = z.length >>> 1, t = z.slice(0, ne), d = z.slice(ne);
      if (Ee(t, d, ne))
        throw new Error("XTS keys are equal.");
      return this.ctx.init(d), this.ctx.encrypt(this.tweak, 0, I, 0), this.ctx.init(t), this.blockPos = 0, this.lastSize = 0, this;
    }
    _shift() {
      let z = 0;
      this.encrypt || this.tweak.copy(this.prev, 0);
      for (let I = 0; I < this.blockSize; I++) {
        const ne = this.tweak[I] >> 7;
        this.tweak[I] <<= 1, this.tweak[I] |= z, z = ne;
      }
      z = -z & 255, this.tweak[2] ^= this.poly >> 16 & z, this.tweak[1] ^= this.poly >> 8 & z, this.tweak[0] ^= this.poly >> 0 & z;
    }
    _update(z, I, ne, t) {
      for (let d = 0; d < this.blockSize; d++)
        z[I + d] = ne[t + d] ^ this.tweak[d];
      this.encrypt ? this.ctx.encrypt(z, I, z, I) : this.ctx.decrypt(z, I, z, I);
      for (let d = 0; d < this.blockSize; d++)
        z[I + d] ^= this.tweak[d];
      this._shift();
    }
    _destroy() {
      for (let z = 0; z < this.blockSize; z++)
        this.tweak[z] = 0, this.prev[z] = 0;
    }
    _setAutoPadding(z) {
      if (this.lastSize !== 0 || this.blockPos !== 0)
        throw new Error("Cannot set auto padding.");
      this.padding = z, this.unpad = z;
    }
  }
  class E extends a {
    constructor(z) {
      super(z, !0);
    }
    _final() {
      if (!this.padding) {
        if (this.blockPos !== 0)
          throw new Error("Bad encrypt (trailing bytes).");
        return k.alloc(0);
      }
      if (this.lastSize === 0)
        throw new Error("Bad encrypt (no data).");
      if (this.blockPos === 0)
        return k.from(this.last);
      const z = k.alloc(this.blockPos);
      for (let I = 0; I < this.blockPos; I++)
        z[I] = this.last[I], this.last[I] = this.block[I];
      for (let I = 0; I < this.blockSize; I++)
        this.last[I] ^= this.tweak[I];
      this.ctx.encrypt(this.last, 0, this.last, 0);
      for (let I = 0; I < this.blockSize; I++)
        this.last[I] ^= this.tweak[I];
      return k.concat([this.last, z]);
    }
  }
  class H extends a {
    constructor(z) {
      super(z, !1);
    }
    _final() {
      if (!this.padding) {
        if (this.blockPos !== 0)
          throw new Error("Bad decrypt (trailing bytes).");
        return k.alloc(0);
      }
      if (this.lastSize === 0)
        throw new Error("Bad decrypt (no data).");
      if (this.blockPos === 0)
        return k.from(this.last);
      for (let I = 0; I < this.blockSize; I++)
        this.last[I] ^= this.prev[I];
      this.ctx.encrypt(this.last, 0, this.last, 0);
      for (let I = 0; I < this.blockSize; I++)
        this.last[I] ^= this.prev[I];
      for (let I = 0; I < this.blockSize; I++)
        this.last[I] ^= this.tweak[I];
      this.ctx.decrypt(this.last, 0, this.last, 0);
      for (let I = 0; I < this.blockSize; I++)
        this.last[I] ^= this.tweak[I];
      const z = k.alloc(this.blockPos);
      for (let I = 0; I < this.blockPos; I++)
        z[I] = this.last[I], this.last[I] = this.block[I];
      for (let I = 0; I < this.blockSize; I++)
        this.last[I] ^= this.prev[I];
      this.ctx.decrypt(this.last, 0, this.last, 0);
      for (let I = 0; I < this.blockSize; I++)
        this.last[I] ^= this.prev[I];
      return k.concat([this.last, z]);
    }
  }
  class j extends n {
    constructor(z) {
      super(z), this.state = k.alloc(this.blockSize), this.ctr = k.alloc(this.blockSize);
    }
    _init(z, I) {
      e(I.length === this.blockSize), I.copy(this.ctr, 0);
    }
    _increment() {
      for (let z = this.ctr.length - 1; z >= 0 && (this.ctr[z] += 1, this.ctr[z] === 0); z--)
        ;
    }
    _crypt(z, I) {
      const ne = this.blockSize - 1;
      for (let t = 0; t < I.length; t++)
        (this.pos & ne) === 0 && (this.ctx.encrypt(this.state, 0, this.ctr, 0), this._increment(), this.pos = 0), z[t] = I[t] ^ this.state[this.pos++];
    }
    _final() {
      return k.alloc(0);
    }
    _destroy() {
      for (let z = 0; z < this.blockSize; z++)
        this.state[z] = 0, this.ctr[z] = 0;
    }
  }
  class G extends j {
    constructor(z) {
      super(z);
    }
  }
  class N extends j {
    constructor(z) {
      super(z);
    }
  }
  class T extends n {
    constructor(z) {
      super(z), this.state = k.alloc(this.blockSize), this.prev = k.alloc(this.blockSize);
    }
    _init(z, I) {
      e(I.length === this.blockSize), I.copy(this.prev, 0);
    }
    _final() {
      return k.alloc(0);
    }
    _destroy() {
      for (let z = 0; z < this.blockSize; z++)
        this.state[z] = 0, this.prev[z] = 0;
    }
  }
  class A extends T {
    constructor(z) {
      super(z);
    }
    _crypt(z, I) {
      const ne = this.blockSize - 1;
      for (let t = 0; t < I.length; t++)
        (this.pos & ne) === 0 && (this.ctx.encrypt(this.state, 0, this.prev, 0), this.pos = 0), z[t] = I[t] ^ this.state[this.pos], this.prev[this.pos] = z[t], this.pos += 1;
    }
  }
  class q extends T {
    constructor(z) {
      super(z);
    }
    _crypt(z, I) {
      const ne = this.blockSize - 1;
      for (let t = 0; t < I.length; t++)
        (this.pos & ne) === 0 && (this.ctx.encrypt(this.state, 0, this.prev, 0), this.pos = 0), this.prev[this.pos] = I[t], z[t] = I[t] ^ this.state[this.pos], this.pos += 1;
    }
  }
  class _ extends n {
    constructor(z) {
      super(z), this.state = k.alloc(this.blockSize);
    }
    _init(z, I) {
      e(k.isBuffer(I)), e(I.length === this.blockSize), I.copy(this.state, 0);
    }
    _crypt(z, I) {
      const ne = this.blockSize - 1;
      for (let t = 0; t < I.length; t++)
        (this.pos & ne) === 0 && (this.ctx.encrypt(this.state, 0, this.state, 0), this.pos = 0), z[t] = I[t] ^ this.state[this.pos++];
    }
    _final() {
      return k.alloc(0);
    }
    _destroy() {
      for (let z = 0; z < this.blockSize; z++)
        this.state[z] = 0;
    }
  }
  class F extends _ {
    constructor(z) {
      super(z);
    }
  }
  class R extends _ {
    constructor(z) {
      super(z);
    }
  }
  class L extends n {
    constructor(z, I) {
      e(z.blockSize === 16), super(z), this.encrypt = I, this.hash = new c(), this.ctr = k.alloc(16), this.state = k.alloc(16), this.key = k.alloc(16), this.mask = k.alloc(16), this.tag = null, this.mac = null;
    }
    _init(z, I) {
      for (let ne = 0; ne < 16; ne++)
        this.ctr[ne] = 0, this.key[ne] = 0, this.mask[ne] = 0;
      return this._encipher(this.key, this.key), this.hash.init(this.key), I.length !== 12 && (this.hash.update(I), I = this.hash.final(), this.hash.init(this.key)), I.copy(this.ctr, 0), I.length === 12 && (this.ctr[12] = 0, this.ctr[13] = 0, this.ctr[14] = 0, this.ctr[15] = 1), this._encipher(this.mask, this.mask), this.tag = null, this.mac = null, this;
    }
    _increment() {
      let z = 1, I = 4;
      for (; I--; )
        z += this.ctr[12 + I], this.ctr[12 + I] = z, z >>= 8;
    }
    _encipher(z, I) {
      for (let ne = 0; ne < I.length; ne++)
        (this.pos & 15) === 0 && (this.ctx.encrypt(this.state, 0, this.ctr, 0), this._increment(), this.pos = 0), z[ne] = I[ne] ^ this.state[this.pos++];
    }
    _crypt(z, I) {
      this.encrypt ? (this._encipher(z, I), this.hash.update(z)) : (this.hash.update(I), this._encipher(z, I));
    }
    _final() {
      const z = this.hash.final();
      for (let I = 0; I < 16; I++)
        z[I] ^= this.mask[I];
      if (this.encrypt)
        return this.mac = z, k.alloc(0);
      if (!this.tag)
        throw new Error("No tag provided.");
      if (!Ee(z, this.tag, this.tag.length))
        throw new Error("Invalid tag.");
      return k.alloc(0);
    }
    _destroy() {
      this.hash.destroy();
      for (let z = 0; z < 16; z++)
        this.ctr[z] = 0, this.state[z] = 0, this.key[z] = 0, this.mask[z] = 0;
      if (this.tag) {
        for (let z = 0; z < this.tag.length; z++)
          this.tag[z] = 0;
        this.tag = null;
      }
    }
    _setAAD(z) {
      if (this.pos === -1)
        throw new Error("Cipher is not initialized.");
      return this.hash.aad(z), this;
    }
    _getAuthTag() {
      if (!this.encrypt)
        throw new Error("Must be a cipher context.");
      if (!this.mac)
        throw new Error("Cipher is not finalized.");
      return k.from(this.mac);
    }
    _setAuthTag(z) {
      if (this.encrypt)
        throw new Error("Must be a decipher context.");
      if (this.pos === -1)
        throw new Error("Cipher is not initialized.");
      if (z.length !== 4 && z.length !== 8 && (z.length < 12 || z.length > 16))
        throw new RangeError("Invalid tag size.");
      return this.tag = k.from(z), this;
    }
  }
  class fe extends L {
    constructor(z) {
      super(z, !0);
    }
  }
  class ue extends L {
    constructor(z) {
      super(z, !1);
    }
  }
  class ae {
    constructor(z) {
      this.ctx = z, this.size = z.blockSize, this.mac = k.alloc(this.size), this.pos = -1;
    }
    init() {
      return this.mac.fill(0), this.pos = 0, this;
    }
    update(z) {
      if (e(k.isBuffer(z)), this.pos === -1)
        throw new Error("Context is not initialized.");
      for (let I = 0; I < z.length; I++)
        this.mac[this.pos++] ^= z[I], this.pos === this.size && (this.ctx.encrypt(this.mac, 0, this.mac, 0), this.pos = 0);
    }
    pad() {
      this.pos > 0 && (this.ctx.encrypt(this.mac, 0, this.mac, 0), this.pos = 0);
    }
    final() {
      if (this.pos === -1)
        throw new Error("Context is not initialized.");
      return this.pad(), this.pos = -1, k.from(this.mac);
    }
  }
  class D extends n {
    constructor(z, I) {
      e(z.blockSize === 16), super(z), this.encrypt = I, this.hash = new ae(z), this.state = k.alloc(16), this.ctr = k.alloc(16), this.tagLen = 0, this.iv = null, this.mac = null, this.tag = null;
    }
    _increment() {
      for (let z = 15; z >= 1 && (this.ctr[z] += 1, this.ctr[z] === 0); z--)
        ;
    }
    _encipher(z, I) {
      for (let ne = 0; ne < I.length; ne++)
        (this.pos & 15) === 0 && (this.ctx.encrypt(this.state, 0, this.ctr, 0), this._increment(), this.pos = 0), z[ne] = I[ne] ^ this.state[this.pos++];
    }
    _init(z, I) {
      if (I.length < 7)
        throw new RangeError("Invalid nonce length.");
      I.length > 13 && (I = I.slice(0, 13)), this.iv = k.from(I), this.pos = -1, this.tagLen = 0, this.mac = null, this.tag = null;
    }
    _setCCM(z, I, ne) {
      if (!this.iv)
        throw new Error("Cipher is not initialized.");
      let t = z, d = Math.ceil((32 - Math.clz32(t)) / 8);
      d < 2 && (d = 2);
      const B = I, U = 15 - d, J = (ne && ne.length > 0) | 0, C = k.alloc(16);
      if (B < 4 || B > 16 || (B & 1) !== 0)
        throw new RangeError("Invalid tag length.");
      C[0] = 64 * J + 8 * ((B - 2) / 2) + (d - 1), this.iv.copy(C, 1, 0, Math.min(U, this.iv.length));
      for (let M = 15; M >= 1 + U; M--)
        C[M] = t & 255, t >>>= 8;
      if (e(t === 0), this.hash.init(), this.hash.update(C), J) {
        if (ne.length < 65280) {
          const M = k.alloc(2);
          M[0] = ne.length >>> 8, M[1] = ne.length >>> 0, this.hash.update(M);
        } else if (ne.length < 4294967295) {
          const M = k.alloc(6);
          M[0] = 255, M[1] = 254, M[2] = ne.length >>> 24, M[3] = ne.length >>> 16, M[4] = ne.length >>> 8, M[5] = ne.length >>> 0, this.hash.update(M);
        } else
          throw new RangeError("Invalid AAD length.");
        this.hash.update(ne), this.hash.pad();
      }
      C[0] &= 7, C[15] = 1;
      for (let M = 14; M >= 1 + U; M--)
        C[M] = 0;
      C.copy(this.ctr, 0), this.pos = 0, this.tagLen = B, this.iv = null;
    }
    _crypt(z, I) {
      this.encrypt ? (this.hash.update(I), this._encipher(z, I)) : (this._encipher(z, I), this.hash.update(z));
    }
    _final() {
      const z = this.hash.final();
      let I = 16 - ((this.ctr[0] & 7) + 1);
      for (; I < 16; )
        this.ctr[I++] = 0;
      if (this.pos = 0, this._encipher(z, z), this.encrypt)
        return this.mac = z.slice(0, this.tagLen), k.alloc(0);
      if (!this.tag)
        throw new Error("No tag provided.");
      if (!Ee(z, this.tag, this.tagLen))
        throw new Error("Invalid tag.");
      return k.alloc(0);
    }
    _destroy() {
      for (let z = 0; z < 16; z++)
        this.state[z] = 0, this.ctr[z] = 0;
      this.tagLen = 0, this.iv = null, this.tag = null;
    }
    _getAuthTag() {
      if (!this.encrypt)
        throw new Error("Must be a cipher context.");
      if (!this.mac)
        throw new Error("Cipher is not finalized.");
      return k.from(this.mac);
    }
    _setAuthTag(z) {
      if (this.encrypt)
        throw new Error("Must be a decipher context.");
      if (this.pos === -1)
        throw new Error("Cipher is not initialized.");
      if (this.tagLen === 0 || z.length !== this.tagLen)
        throw new RangeError("Invalid tag size.");
      return this.tag = k.from(z), this;
    }
  }
  class Q extends D {
    constructor(z) {
      super(z, !0);
    }
  }
  class W extends D {
    constructor(z) {
      super(z, !1);
    }
  }
  class oe {
    constructor(z) {
      this.ctx = z, this.poly = w[z.blockSize >>> 4], this.size = z.blockSize, this.mac = k.alloc(this.size), this.pos = -1;
    }
    init(z) {
      return this.mac.fill(0), this.pos = 0, z != null && (this.mac[this.size - 1] ^= z, this.pos = this.size), this;
    }
    shift(z, I) {
      let ne = 0;
      for (let t = this.size - 1; t >= 0; t--) {
        const d = I[t] >> 7;
        z[t] = I[t] << 1 | ne, ne = d;
      }
      ne = -ne & 255, z[this.size - 3] ^= this.poly >> 16 & ne, z[this.size - 2] ^= this.poly >> 8 & ne, z[this.size - 1] ^= this.poly >> 0 & ne;
    }
    update(z) {
      if (e(k.isBuffer(z)), this.pos === -1)
        throw new Error("Context is not initialized.");
      for (let I = 0; I < z.length; I++)
        this.pos === this.size && (this.ctx.encrypt(this.mac, 0, this.mac, 0), this.pos = 0), this.mac[this.pos++] ^= z[I];
    }
    final() {
      if (this.pos === -1)
        throw new Error("Context is not initialized.");
      const z = k.alloc(this.size);
      this.ctx.encrypt(z, 0, z, 0), this.shift(z, z), this.pos < this.size && (this.mac[this.pos] ^= 128, this.shift(z, z));
      for (let I = 0; I < this.size; I++)
        this.mac[I] ^= z[I];
      return this.ctx.encrypt(this.mac, 0, this.mac, 0), this.pos = -1, k.from(this.mac);
    }
  }
  class v extends n {
    constructor(z, I) {
      super(z), this.encrypt = I, this.hash1 = new oe(z), this.hash2 = new oe(z), this.state = k.alloc(this.blockSize), this.ctr = k.alloc(this.blockSize), this.mask = k.alloc(this.blockSize), this.mac = null, this.tag = null;
    }
    _increment() {
      let z = this.blockSize, I = 1;
      for (; z--; )
        I += this.ctr[z], this.ctr[z] = I, I >>= 8;
    }
    _encipher(z, I) {
      const ne = this.blockSize - 1;
      for (let t = 0; t < I.length; t++)
        (this.pos & ne) === 0 && (this.ctx.encrypt(this.state, 0, this.ctr, 0), this._increment(), this.pos = 0), z[t] = I[t] ^ this.state[this.pos++];
    }
    _init(z, I) {
      e(I.length > 0), this.hash1.init(0), this.hash1.update(I), this.mask = this.hash1.final(), this.mask.copy(this.ctr, 0), this.hash1.init(1), this.hash2.init(2), this.mac = null, this.tag = null;
    }
    _crypt(z, I) {
      this.encrypt ? (this._encipher(z, I), this.hash2.update(z)) : (this.hash2.update(I), this._encipher(z, I));
    }
    _final() {
      const z = k.alloc(this.blockSize), I = this.hash1.final(), ne = this.hash2.final();
      for (let t = 0; t < this.blockSize; t++)
        z[t] = I[t] ^ ne[t] ^ this.mask[t];
      if (this.encrypt)
        return this.mac = z, k.alloc(0);
      if (!this.tag)
        throw new Error("No tag provided.");
      if (!Ee(z, this.tag, this.tag.length))
        throw new Error("Invalid tag.");
      return k.alloc(0);
    }
    _destroy() {
      for (let z = 0; z < this.blockSize; z++)
        this.state[z] = 0, this.ctr[z] = 0, this.mask[z] = 0;
      this.tag = null;
    }
    _setAAD(z) {
      if (this.pos === -1)
        throw new Error("Cipher is not initialized.");
      return this.hash1.update(z), this;
    }
    _getAuthTag() {
      if (!this.encrypt)
        throw new Error("Must be a cipher context.");
      if (!this.mac)
        throw new Error("Cipher is not finalized.");
      return k.from(this.mac);
    }
    _setAuthTag(z) {
      if (this.encrypt)
        throw new Error("Must be a decipher context.");
      if (this.pos === -1)
        throw new Error("Cipher is not initialized.");
      if (z.length === 0 || z.length > this.blockSize)
        throw new RangeError("Invalid tag size.");
      return this.tag = k.from(z), this;
    }
  }
  class Y extends v {
    constructor(z) {
      super(z, !0);
    }
  }
  class he extends v {
    constructor(z) {
      super(z, !1);
    }
  }
  function le(we, z = !0) {
    switch (e(typeof we == "string"), e(typeof z == "boolean"), we) {
      case "RAW":
        return z ? u : o;
      case "ECB":
        return z ? p : g;
      case "CBC":
        return z ? S : y;
      case "CTS":
        return z ? b : h;
      case "XTS":
        return z ? E : H;
      case "CTR":
        return z ? G : N;
      case "CFB":
        return z ? A : q;
      case "OFB":
        return z ? F : R;
      case "GCM":
        return z ? fe : ue;
      case "CCM":
        return z ? Q : W;
      case "EAX":
        return z ? Y : he;
      default:
        throw new Error(`Unknown mode: ${we}.`);
    }
  }
  function ge(we, z, I, ne) {
    return we.buffer === I.buffer && we.byteOffset === I.byteOffset && z === ne;
  }
  function Ee(we, z, I) {
    let ne = 0;
    for (let t = 0; t < I; t++)
      ne |= we[t] ^ z[t];
    return ne - 1 >>> 31;
  }
  return yt.Mode = m, yt.Block = f, yt.Stream = n, yt.RawCipher = u, yt.RawDecipher = o, yt.PKCS7Cipher = s, yt.PKCS7Decipher = i, yt.ECBCipher = p, yt.ECBDecipher = g, yt.CBCCipher = S, yt.CBCDecipher = y, yt.CTSCipher = b, yt.CTSDecipher = h, yt.XTS = a, yt.XTSCipher = E, yt.XTSDecipher = H, yt.CTR = j, yt.CTRCipher = G, yt.CTRDecipher = N, yt.CFB = T, yt.CFBCipher = A, yt.CFBDecipher = q, yt.OFB = _, yt.OFBCipher = F, yt.OFBDecipher = R, yt.GCM = L, yt.GCMCipher = fe, yt.GCMDecipher = ue, yt.CBCMAC = ae, yt.CCM = D, yt.CCMCipher = Q, yt.CCMDecipher = W, yt.CMAC = oe, yt.EAX = v, yt.EAXCipher = Y, yt.EAXDecipher = he, yt.get = le, yt;
}
/*!
 * aes.js - aes128/192/256 for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var G2;
function ex() {
  if (G2) return Tn;
  G2 = 1;
  const e = Wg(), { CBCCipher: c, CBCDecipher: l } = Qg();
  function w(f, n, u) {
    const o = new c(new e(256));
    return o.init(n, u), k.concat([o.update(f), o.final()]);
  }
  function m(f, n, u) {
    const o = new l(new e(256));
    return o.init(n, u), k.concat([o.update(f), o.final()]);
  }
  return Tn.native = 0, Tn.encipher = w, Tn.decipher = m, Tn;
}
/*!
 * keccak.js - Keccak/SHA3 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on emn178/js-sha3:
 *   Copyright (c) 2015-2017, Chen, Yi-Cyuan (MIT License).
 *   https://github.com/emn178/js-sha3
 *
 * Parts of this software are based on rhash/RHash:
 *   Copyright (c) 2005-2014, Aleksey Kravchenko
 *   https://github.com/rhash/RHash
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/SHA-3
 *   https://keccak.team/specifications.html
 *   https://csrc.nist.gov/projects/hash-functions/sha-3-project/sha-3-standardization
 *   http://dx.doi.org/10.6028/NIST.FIPS.202
 *   https://github.com/rhash/RHash/blob/master/librhash/sha3.c
 *   https://github.com/emn178/js-sha3/blob/master/src/sha3.js
 */
var A0, J2;
function C7() {
  if (J2) return A0;
  J2 = 1;
  const e = Mt(), c = ni(), l = 2147483648, w = new Uint32Array([
    1,
    0,
    32898,
    0,
    32906,
    2147483648,
    2147516416,
    2147483648,
    32907,
    0,
    2147483649,
    0,
    2147516545,
    2147483648,
    32777,
    2147483648,
    138,
    0,
    136,
    0,
    2147516425,
    0,
    2147483658,
    0,
    2147516555,
    0,
    139,
    2147483648,
    32905,
    2147483648,
    32771,
    2147483648,
    32770,
    2147483648,
    128,
    2147483648,
    32778,
    0,
    2147483658,
    2147483648,
    2147516545,
    2147483648,
    32896,
    2147483648,
    2147483649,
    0,
    2147516424,
    2147483648
  ]);
  class m {
    constructor() {
      this.state = new Uint32Array(50), this.block = k.alloc(200), this.bs = 136, this.pos = l;
    }
    init(u) {
      u == null && (u = 256), e(u >>> 0 === u), e(u >= 128), e(u <= 512);
      const o = 1600 - u * 2;
      return e(o >= 0 && (o & 63) === 0), this.bs = o >>> 3, this.pos = 0, this;
    }
    update(u) {
      e(k.isBuffer(u)), e(!(this.pos & l), "Context is not initialized.");
      let o = u.length, s = this.pos, i = 0;
      if (this.pos = (this.pos + o) % this.bs, s > 0) {
        let p = this.bs - s;
        if (p > o && (p = o), u.copy(this.block, s, i, i + p), s += p, o -= p, i += p, s < this.bs)
          return this;
        this._transform(this.block, 0);
      }
      for (; o >= this.bs; )
        this._transform(u, i), i += this.bs, o -= this.bs;
      return o > 0 && u.copy(this.block, 0, i, i + o), this;
    }
    final(u, o) {
      u == null && (u = 1), (o == null || o === 0) && (o = 100 - (this.bs >>> 1)), e((u & 255) === u), e(o >>> 0 === o), e(!(this.pos & l), "Context is not initialized."), this.block.fill(0, this.pos, this.bs), this.block[this.pos] |= u, this.block[this.bs - 1] |= 128, this._transform(this.block, 0), this.pos = l, e(o <= this.bs);
      const s = k.alloc(o);
      for (let i = 0; i < o; i++)
        s[i] = this.state[i >>> 2] >>> 8 * (i & 3);
      for (let i = 0; i < 50; i++)
        this.state[i] = 0;
      for (let i = 0; i < this.bs; i++)
        this.block[i] = 0;
      return s;
    }
    _transform(u, o) {
      const s = this.bs >>> 2, i = this.state;
      for (let p = 0; p < s; p++)
        i[p] ^= f(u, o + p * 4);
      for (let p = 0; p < 48; p += 2) {
        const g = i[0] ^ i[10] ^ i[20] ^ i[30] ^ i[40], S = i[1] ^ i[11] ^ i[21] ^ i[31] ^ i[41], y = i[2] ^ i[12] ^ i[22] ^ i[32] ^ i[42], b = i[3] ^ i[13] ^ i[23] ^ i[33] ^ i[43], h = i[4] ^ i[14] ^ i[24] ^ i[34] ^ i[44], a = i[5] ^ i[15] ^ i[25] ^ i[35] ^ i[45], E = i[6] ^ i[16] ^ i[26] ^ i[36] ^ i[46], H = i[7] ^ i[17] ^ i[27] ^ i[37] ^ i[47], j = i[8] ^ i[18] ^ i[28] ^ i[38] ^ i[48], G = i[9] ^ i[19] ^ i[29] ^ i[39] ^ i[49], N = j ^ (y << 1 | b >>> 31), T = G ^ (b << 1 | y >>> 31), A = g ^ (h << 1 | a >>> 31), q = S ^ (a << 1 | h >>> 31), _ = y ^ (E << 1 | H >>> 31), F = b ^ (H << 1 | E >>> 31), R = h ^ (j << 1 | G >>> 31), L = a ^ (G << 1 | j >>> 31), fe = E ^ (g << 1 | S >>> 31), ue = H ^ (S << 1 | g >>> 31);
        i[0] ^= N, i[1] ^= T, i[10] ^= N, i[11] ^= T, i[20] ^= N, i[21] ^= T, i[30] ^= N, i[31] ^= T, i[40] ^= N, i[41] ^= T, i[2] ^= A, i[3] ^= q, i[12] ^= A, i[13] ^= q, i[22] ^= A, i[23] ^= q, i[32] ^= A, i[33] ^= q, i[42] ^= A, i[43] ^= q, i[4] ^= _, i[5] ^= F, i[14] ^= _, i[15] ^= F, i[24] ^= _, i[25] ^= F, i[34] ^= _, i[35] ^= F, i[44] ^= _, i[45] ^= F, i[6] ^= R, i[7] ^= L, i[16] ^= R, i[17] ^= L, i[26] ^= R, i[27] ^= L, i[36] ^= R, i[37] ^= L, i[46] ^= R, i[47] ^= L, i[8] ^= fe, i[9] ^= ue, i[18] ^= fe, i[19] ^= ue, i[28] ^= fe, i[29] ^= ue, i[38] ^= fe, i[39] ^= ue, i[48] ^= fe, i[49] ^= ue;
        const ae = i[0], D = i[1], Q = i[11] << 4 | i[10] >>> 28, W = i[10] << 4 | i[11] >>> 28, oe = i[20] << 3 | i[21] >>> 29, v = i[21] << 3 | i[20] >>> 29, Y = i[31] << 9 | i[30] >>> 23, he = i[30] << 9 | i[31] >>> 23, le = i[40] << 18 | i[41] >>> 14, ge = i[41] << 18 | i[40] >>> 14, Ee = i[2] << 1 | i[3] >>> 31, we = i[3] << 1 | i[2] >>> 31, z = i[13] << 12 | i[12] >>> 20, I = i[12] << 12 | i[13] >>> 20, ne = i[22] << 10 | i[23] >>> 22, t = i[23] << 10 | i[22] >>> 22, d = i[33] << 13 | i[32] >>> 19, B = i[32] << 13 | i[33] >>> 19, U = i[42] << 2 | i[43] >>> 30, J = i[43] << 2 | i[42] >>> 30, C = i[5] << 30 | i[4] >>> 2, M = i[4] << 30 | i[5] >>> 2, $ = i[14] << 6 | i[15] >>> 26, r = i[15] << 6 | i[14] >>> 26, x = i[25] << 11 | i[24] >>> 21, O = i[24] << 11 | i[25] >>> 21, K = i[34] << 15 | i[35] >>> 17, X = i[35] << 15 | i[34] >>> 17, P = i[45] << 29 | i[44] >>> 3, V = i[44] << 29 | i[45] >>> 3, re = i[6] << 28 | i[7] >>> 4, ce = i[7] << 28 | i[6] >>> 4, de = i[17] << 23 | i[16] >>> 9, pe = i[16] << 23 | i[17] >>> 9, se = i[26] << 25 | i[27] >>> 7, Z = i[27] << 25 | i[26] >>> 7, ee = i[36] << 21 | i[37] >>> 11, me = i[37] << 21 | i[36] >>> 11, Ae = i[47] << 24 | i[46] >>> 8, Oe = i[46] << 24 | i[47] >>> 8, ye = i[8] << 27 | i[9] >>> 5, _e = i[9] << 27 | i[8] >>> 5, ke = i[18] << 20 | i[19] >>> 12, Me = i[19] << 20 | i[18] >>> 12, De = i[29] << 7 | i[28] >>> 25, Ne = i[28] << 7 | i[29] >>> 25, $e = i[38] << 8 | i[39] >>> 24, bt = i[39] << 8 | i[38] >>> 24, Ve = i[48] << 14 | i[49] >>> 18, je = i[49] << 14 | i[48] >>> 18;
        i[0] = ae ^ ~z & x, i[1] = D ^ ~I & O, i[10] = re ^ ~ke & oe, i[11] = ce ^ ~Me & v, i[20] = Ee ^ ~$ & se, i[21] = we ^ ~r & Z, i[30] = ye ^ ~Q & ne, i[31] = _e ^ ~W & t, i[40] = C ^ ~de & De, i[41] = M ^ ~pe & Ne, i[2] = z ^ ~x & ee, i[3] = I ^ ~O & me, i[12] = ke ^ ~oe & d, i[13] = Me ^ ~v & B, i[22] = $ ^ ~se & $e, i[23] = r ^ ~Z & bt, i[32] = Q ^ ~ne & K, i[33] = W ^ ~t & X, i[42] = de ^ ~De & Y, i[43] = pe ^ ~Ne & he, i[4] = x ^ ~ee & Ve, i[5] = O ^ ~me & je, i[14] = oe ^ ~d & P, i[15] = v ^ ~B & V, i[24] = se ^ ~$e & le, i[25] = Z ^ ~bt & ge, i[34] = ne ^ ~K & Ae, i[35] = t ^ ~X & Oe, i[44] = De ^ ~Y & U, i[45] = Ne ^ ~he & J, i[6] = ee ^ ~Ve & ae, i[7] = me ^ ~je & D, i[16] = d ^ ~P & re, i[17] = B ^ ~V & ce, i[26] = $e ^ ~le & Ee, i[27] = bt ^ ~ge & we, i[36] = K ^ ~Ae & ye, i[37] = X ^ ~Oe & _e, i[46] = Y ^ ~U & C, i[47] = he ^ ~J & M, i[8] = Ve ^ ~ae & z, i[9] = je ^ ~D & I, i[18] = P ^ ~re & ke, i[19] = V ^ ~ce & Me, i[28] = le ^ ~Ee & $, i[29] = ge ^ ~we & r, i[38] = Ae ^ ~ye & Q, i[39] = Oe ^ ~_e & W, i[48] = U ^ ~C & de, i[49] = J ^ ~M & pe, i[0] ^= w[p + 0], i[1] ^= w[p + 1];
      }
    }
    static hash() {
      return new m();
    }
    static hmac(u, o, s) {
      u == null && (u = 256), e(u >>> 0 === u);
      const i = 1600 - u * 2;
      return e(i >= 0 && (i & 63) === 0), new c(m, i >>> 3, [u], [o, s]);
    }
    static digest(u, o, s, i) {
      return m.ctx.init(o).update(u).final(s, i);
    }
    static root(u, o, s, i, p) {
      return s == null && (s = 256), p == null && (p = 0), p === 0 && (p = s >>> 3), e(s >>> 0 === s), e((s & 7) === 0), e(p >>> 0 === p), e(k.isBuffer(u) && u.length === p), e(k.isBuffer(o) && o.length === p), m.ctx.init(s).update(u).update(o).final(i, p);
    }
    static multi(u, o, s, i, p, g) {
      const { ctx: S } = m;
      return S.init(i), S.update(u), S.update(o), s && S.update(s), S.final(p, g);
    }
    static mac(u, o, s, i, p) {
      return m.hmac(s, i, p).init(o).update(u).final();
    }
  }
  m.native = 0, m.id = "KECCAK256", m.size = 32, m.bits = 256, m.blockSize = 136, m.zero = k.alloc(32, 0), m.ctx = new m();
  function f(n, u) {
    return n[u++] + n[u++] * 256 + n[u++] * 65536 + n[u] * 16777216;
  }
  return A0 = m, A0;
}
var zn = {};
/*!
 * murmur3.js - murmur3 hash for bcrypto
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/MurmurHash
 *   https://github.com/aappleby/smhasher
 */
var W2;
function Fl() {
  if (W2) return zn;
  W2 = 1;
  const e = Mt();
  function c(n, u) {
    e(k.isBuffer(n)), e(typeof u == "number");
    const o = n.length - (n.length & 3), s = 3432918353, i = 461845907;
    let p = u | 0;
    for (let S = 0; S < o; S += 4) {
      let y = f(n, S);
      y = w(y, s), y = m(y, 15), y = w(y, i), p ^= y, p = m(p, 13), p = w(p, 5) + 3864292196 | 0;
    }
    let g = 0;
    switch (n.length & 3) {
      case 3:
        g ^= n[o + 2] << 16;
      case 2:
        g ^= n[o + 1] << 8;
      case 1:
        g ^= n[o + 0], g = w(g, s), g = m(g, 15), g = w(g, i), p ^= g;
    }
    return p ^= n.length, p ^= p >>> 16, p = w(p, 2246822507), p ^= p >>> 13, p = w(p, 3266489909), p ^= p >>> 16, p >>> 0;
  }
  function l(n, u, o) {
    e(typeof u == "number"), e(typeof o == "number");
    const s = w(u, 4221880213) + (o | 0);
    return c(n, s);
  }
  function w(n, u) {
    const o = n & 65535, s = u & 65535, i = n >>> 16, p = u >>> 16, g = o * s;
    return i * s + p * o + (g >>> 16) << 16 | g & 65535;
  }
  function m(n, u) {
    return n << u | n >>> 32 - u;
  }
  function f(n, u) {
    return n[u++] + n[u++] * 256 + n[u++] * 65536 + n[u] * 16777216;
  }
  return zn.native = 0, zn.sum = c, zn.tweak = l, zn;
}
/*!
 * p224.js - ECDSA-P224 for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var O0, Z2;
function D7() {
  if (Z2) return O0;
  Z2 = 1;
  const e = es(), c = br();
  return O0 = new e("P224", c, c), O0;
}
/*!
 * p256.js - ECDSA-P256 for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var _0, Q2;
function U7() {
  if (Q2) return _0;
  Q2 = 1;
  const e = es(), c = br();
  return _0 = new e("P256", c, c), _0;
}
/*!
 * sha384.js - SHA384 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/hash.js:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/hash.js
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/SHA-2
 *   https://tools.ietf.org/html/rfc4634
 *   https://github.com/indutny/hash.js/blob/master/lib/hash/sha/384.js
 */
var R0, e6;
function Hl() {
  if (e6) return R0;
  e6 = 1;
  const e = Mt(), c = $i(), l = ni();
  class w extends c {
    constructor() {
      super();
    }
    init() {
      return this.state[0] = 3418070365, this.state[1] = 3238371032, this.state[2] = 1654270250, this.state[3] = 914150663, this.state[4] = 2438529370, this.state[5] = 812702999, this.state[6] = 355462360, this.state[7] = 4144912697, this.state[8] = 1731405415, this.state[9] = 4290775857, this.state[10] = 2394180231, this.state[11] = 1750603025, this.state[12] = 3675008525, this.state[13] = 1694076839, this.state[14] = 1203062813, this.state[15] = 3204075428, this.size = 0, this;
    }
    final() {
      return super.final().slice(0, 48);
    }
    static hash() {
      return new w();
    }
    static hmac() {
      return new l(w, 128);
    }
    static digest(f) {
      return w.ctx.init().update(f).final();
    }
    static root(f, n) {
      return e(k.isBuffer(f) && f.length === 48), e(k.isBuffer(n) && n.length === 48), w.ctx.init().update(f).update(n).final();
    }
    static multi(f, n, u) {
      const { ctx: o } = w;
      return o.init(), o.update(f), o.update(n), u && o.update(u), o.final();
    }
    static mac(f, n) {
      return w.hmac().init(n).update(f).final();
    }
  }
  return w.native = 0, w.id = "SHA384", w.size = 48, w.bits = 384, w.blockSize = 128, w.zero = k.alloc(48, 0), w.ctx = new w(), R0 = w, R0;
}
/*!
 * p384.js - ECDSA-P384 for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var P0, t6;
function F7() {
  if (t6) return P0;
  t6 = 1;
  const e = es(), c = Hl();
  return P0 = new e("P384", c, c), P0;
}
/*!
 * shake.js - SHAKE implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/SHA-3
 *   https://keccak.team/specifications.html
 *   https://csrc.nist.gov/projects/hash-functions/sha-3-project/sha-3-standardization
 *   http://dx.doi.org/10.6028/NIST.FIPS.202
 */
var k0, r6;
function H7() {
  if (r6) return k0;
  r6 = 1;
  const e = C7();
  class c extends e {
    /**
     * Create a SHAKE Context.
     * @constructor
     */
    constructor() {
      super();
    }
    final(w) {
      return super.final(31, w);
    }
    static hash() {
      return new c();
    }
    static hmac(w, m) {
      return super.hmac(w, 31, m);
    }
    static digest(w, m, f) {
      return super.digest(w, m, 31, f);
    }
    static root(w, m, f, n) {
      return super.root(w, m, f, 31, n);
    }
    static multi(w, m, f, n, u) {
      return super.multi(w, m, f, n, 31, u);
    }
    static mac(w, m, f, n) {
      return super.mac(w, m, f, 31, n);
    }
  }
  return c.native = e.native, c.id = "SHAKE256", c.size = 32, c.bits = 256, c.blockSize = 136, c.zero = k.alloc(32, 0), c.ctx = new c(), k0 = c, k0;
}
/*!
 * shake256.js - SHAKE256 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var B0, i6;
function L7() {
  if (i6) return B0;
  i6 = 1;
  const e = H7();
  class c extends e {
    constructor() {
      super();
    }
    init() {
      return super.init(256);
    }
    static hash() {
      return new c();
    }
    static hmac(w) {
      return super.hmac(256, w);
    }
    static digest(w, m) {
      return super.digest(w, 256, m);
    }
    static root(w, m, f) {
      return super.root(w, m, 256, f);
    }
    static multi(w, m, f, n) {
      return super.multi(w, m, f, 256, n);
    }
    static mac(w, m, f) {
      return super.mac(w, m, 256, f);
    }
  }
  return c.native = e.native, c.id = "SHAKE256", c.size = 32, c.bits = 256, c.blockSize = 136, c.zero = k.alloc(32, 0), c.ctx = new c(), B0 = c, B0;
}
/*!
 * p521.js - ECDSA-P521 for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var M0, n6;
function K7() {
  if (n6) return M0;
  n6 = 1;
  const e = es(), c = $i(), l = L7();
  return M0 = new e("P521", c, l), M0;
}
var zt = {}, Cn = {};
/*!
 * primes.js - Prime number generation for javascript
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on golang/go:
 *   Copyright (c) 2009, The Go Authors. All rights reserved.
 *   https://github.com/golang/go
 *
 * Parts of this software are based on indutny/miller-rabin:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/miller-rabin
 *
 * Resources:
 *   https://github.com/golang/go/blob/master/src/crypto/rsa/rsa.go
 *   https://github.com/golang/go/blob/master/src/math/big/prime.go
 *   https://github.com/golang/go/blob/master/src/math/big/int.go
 *   https://github.com/golang/go/blob/master/src/math/big/nat.go
 *   https://github.com/golang/go/blob/master/src/crypto/rand/util.go
 *   https://github.com/indutny/miller-rabin/blob/master/lib/mr.js
 */
var s6;
function tx() {
  if (s6) return Cn;
  s6 = 1;
  const e = Mt(), c = jr(), l = Hi(), w = new Uint8Array([
    3,
    5,
    7,
    11,
    13,
    17,
    19,
    23,
    29,
    31,
    37,
    41,
    43,
    47,
    53
  ]), m = new c("16294579238595022365", 10), f = 10412 | 1 << 17 | 1 << 19 | 1 << 23 | 1 << 29 | 1 << 31, n = 35360 | 1 << 21 | 1 << 27 | 1 << 29, u = new c(1155 * 13 * 17 * 19 * 23 * 37), o = new c(899 * 41 * 43 * 47 * 53);
  function s(g, S = 20, y = l) {
    if (e(g >>> 0 === g), e(S >>> 0 === S), e(y != null), g < 2)
      throw new Error("Prime must be at least 2 bits.");
    for (; ; ) {
      const b = c.randomBits(y, g);
      b.setn(g - 1, 1), b.setn(g - 2, 1), b.setn(0, 1);
      const h = b.mod(m);
      e:
        for (let a = 0; a < 1 << 20; a += 2) {
          const E = h.addn(a);
          for (let H = 0; H < w.length; H++) {
            const j = w[H];
            if (E.modrn(j) === 0 && (g > 6 || E.cmpn(j) !== 0))
              continue e;
          }
          b.iaddn(a);
          break;
        }
      if (b.bitLength() === g && i(b, S, y))
        return b;
    }
  }
  function i(g, S, y = l) {
    if (e(g instanceof c), g.sign() <= 0)
      return !1;
    if (g.cmpn(64) < 0) {
      const a = g.word(0);
      return a > 31 ? (n & 1 << a - 32) !== 0 : (f & 1 << a) !== 0;
    }
    if (g.isEven())
      return !1;
    const b = g.mod(u).toNumber(), h = g.mod(o).toNumber();
    return b % 3 === 0 || b % 5 === 0 || b % 7 === 0 || b % 11 === 0 || b % 13 === 0 || b % 17 === 0 || b % 19 === 0 || b % 23 === 0 || b % 37 === 0 || h % 29 === 0 || h % 31 === 0 || h % 41 === 0 || h % 43 === 0 || h % 47 === 0 || h % 53 === 0 ? !1 : g.isPrime(y, S);
  }
  function p(g, S, y) {
    if (!i(g, S, y))
      return !1;
    const b = g.subn(1).iushrn(1);
    return !!i(b, S, y);
  }
  return Cn.randomPrime = s, Cn.isProbablePrime = i, Cn.isSafePrime = p, Cn;
}
var Wr = {};
/*!
 * base64.js - base64 for javascript
 * Copyright (c) 2019-2020, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://tools.ietf.org/html/rfc4648
 */
var o6;
function rx() {
  if (o6) return Wr;
  o6 = 1;
  const e = Mt(), c = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", l = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", w = [
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    62,
    -1,
    -1,
    -1,
    63,
    52,
    53,
    54,
    55,
    56,
    57,
    58,
    59,
    60,
    61,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    16,
    17,
    18,
    19,
    20,
    21,
    22,
    23,
    24,
    25,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    26,
    27,
    28,
    29,
    30,
    31,
    32,
    33,
    34,
    35,
    36,
    37,
    38,
    39,
    40,
    41,
    42,
    43,
    44,
    45,
    46,
    47,
    48,
    49,
    50,
    51,
    -1,
    -1,
    -1,
    -1,
    -1
  ], m = [
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    62,
    -1,
    -1,
    52,
    53,
    54,
    55,
    56,
    57,
    58,
    59,
    60,
    61,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    16,
    17,
    18,
    19,
    20,
    21,
    22,
    23,
    24,
    25,
    -1,
    -1,
    -1,
    -1,
    63,
    -1,
    26,
    27,
    28,
    29,
    30,
    31,
    32,
    33,
    34,
    35,
    36,
    37,
    38,
    39,
    40,
    41,
    42,
    43,
    44,
    45,
    46,
    47,
    48,
    49,
    50,
    51,
    -1,
    -1,
    -1,
    -1,
    -1
  ];
  function f(h, a, E) {
    e(k.isBuffer(h));
    let H = h.length, j = "", G = 0;
    for (; H >= 3; ) {
      const N = h[G++], T = h[G++], A = h[G++];
      j += a[N >> 2], j += a[(N & 3) << 4 | T >> 4], j += a[(T & 15) << 2 | A >> 6], j += a[A & 63], H -= 3;
    }
    switch (H) {
      case 1: {
        const N = h[G++];
        j += a[N >> 2], j += a[(N & 3) << 4], E && (j += "==");
        break;
      }
      case 2: {
        const N = h[G++], T = h[G++];
        j += a[N >> 2], j += a[(N & 3) << 4 | T >> 4], j += a[(T & 15) << 2], E && (j += "=");
        break;
      }
    }
    return j;
  }
  function n(h, a, E) {
    e(typeof h == "string");
    const H = k.alloc(E);
    let j = h.length, G = 0, N = 0;
    if (j > 0 && h[j - 1] === "=" && (j -= 1), j > 0 && h[j - 1] === "=" && (j -= 1), (j & 3) === 1)
      throw new Error("Invalid base64 string.");
    for (; j >= 4; ) {
      const T = h.charCodeAt(G++), A = h.charCodeAt(G++), q = h.charCodeAt(G++), _ = h.charCodeAt(G++);
      if ((T | A | q | _) & 65408)
        throw new Error("Invalid base64 string.");
      const F = a[T], R = a[A], L = a[q], fe = a[_];
      if ((F | R | L | fe) < 0)
        throw new Error("Invalid base64 string.");
      H[N++] = F << 2 | R >> 4, H[N++] = R << 4 | L >> 2, H[N++] = L << 6 | fe >> 0, j -= 4;
    }
    switch (j) {
      case 1:
        throw new Error("Invalid base64 string.");
      case 2: {
        const T = h.charCodeAt(G++), A = h.charCodeAt(G++);
        if ((T | A) & 65408)
          throw new Error("Invalid base64 string.");
        const q = a[T], _ = a[A];
        if ((q | _) < 0)
          throw new Error("Invalid base64 string.");
        if (H[N++] = q << 2 | _ >> 4, _ & 15)
          throw new Error("Invalid base64 string.");
        break;
      }
      case 3: {
        const T = h.charCodeAt(G++), A = h.charCodeAt(G++), q = h.charCodeAt(G++);
        if ((T | A | q) & 65408)
          throw new Error("Invalid base64 string.");
        const _ = a[T], F = a[A], R = a[q];
        if ((_ | F | R) < 0)
          throw new Error("Invalid base64 string.");
        if (H[N++] = _ << 2 | F >> 4, H[N++] = F << 4 | R >> 2, R & 3)
          throw new Error("Invalid base64 string.");
        break;
      }
    }
    return e(N === E), H;
  }
  function u(h, a) {
    e(typeof h == "string");
    let E = h.length;
    if (E > 0 && h[E - 1] === "=" && (E -= 1), E > 0 && h[E - 1] === "=" && (E -= 1), (E & 3) === 1)
      return !1;
    for (let H = 0; H < E; H++) {
      const j = h.charCodeAt(H);
      if (j & 65408 || a[j] === -1)
        return !1;
    }
    switch (E & 3) {
      case 1:
        return !1;
      case 2:
        return (a[h.charCodeAt(E - 1)] & 15) === 0;
      case 3:
        return (a[h.charCodeAt(E - 1)] & 3) === 0;
    }
    return !0;
  }
  function o(h) {
    return f(h, c, !0);
  }
  function s(h) {
    const a = y(h);
    if (!b(h, a))
      throw new Error("Invalid base64 padding.");
    return n(h, w, a);
  }
  function i(h) {
    const a = y(h);
    return b(h, a) ? u(h, w) : !1;
  }
  function p(h) {
    return f(h, l, !1);
  }
  function g(h) {
    const a = y(h);
    if (!b(h, 0))
      throw new Error("Invalid base64 padding.");
    return n(h, m, a);
  }
  function S(h) {
    return b(h, 0) ? u(h, m) : !1;
  }
  function y(h) {
    e(typeof h == "string");
    let a = h.length;
    a > 0 && h[a - 1] === "=" && (a -= 1), a > 0 && h[a - 1] === "=" && (a -= 1);
    let E = (a >>> 2) * 3;
    const H = a & 3;
    return H && (E += H - 1), E;
  }
  function b(h, a) {
    switch (e(typeof h == "string"), a % 3) {
      case 0:
        return h.length === 0 ? !0 : h.length === 1 ? h[0] !== "=" : h[h.length - 2] !== "=" && h[h.length - 1] !== "=";
      case 1:
        return h.length >= 4 && h[h.length - 2] === "=" && h[h.length - 1] === "=";
      case 2:
        return h.length >= 4 && h[h.length - 2] !== "=" && h[h.length - 1] === "=";
      default:
        throw new Error("unreachable");
    }
  }
  return Wr.native = 0, Wr.encode = o, Wr.decode = s, Wr.test = i, Wr.encodeURL = p, Wr.decodeURL = g, Wr.testURL = S, Wr;
}
var Wt = {};
/*!
 * safe.js - constant-time equals for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on golang/go:
 *   Copyright (c) 2009 The Go Authors. All rights reserved.
 *   https://github.com/golang/go
 *
 * Resources:
 *   https://github.com/golang/go/blob/master/src/crypto/subtle/constant_time.go
 */
var a6;
function V7() {
  if (a6) return Wt;
  a6 = 1;
  const e = Mt();
  function c(b, h) {
    if (e(k.isBuffer(b)), e(k.isBuffer(h)), m(b.length, 0))
      return m(h.length, 0);
    let a = b.length ^ h.length;
    for (let E = 0; E < h.length; E++)
      a |= b[E % b.length] ^ h[E];
    return a - 1 >>> 31;
  }
  function l(b, h) {
    if (e(k.isBuffer(b)), e(k.isBuffer(h)), !m(b.length, h.length))
      return 0;
    let a = 0;
    for (let E = 0; E < b.length; E++)
      a |= b[E] ^ h[E];
    return a - 1 >>> 31;
  }
  function w(b, h) {
    return m(b & 255, h & 255);
  }
  function m(b, h) {
    return (b ^ h) - 1 >>> 31;
  }
  function f(b, h, a) {
    return b & a - 1 | h & ~(a - 1);
  }
  function n(b, h) {
    return b - h >>> 31;
  }
  function u(b, h) {
    return b - h - 1 >>> 31;
  }
  function o(b, h) {
    return h - b >>> 31;
  }
  function s(b, h) {
    return h - b - 1 >>> 31;
  }
  function i(b, h) {
    return f(b, h, n(h, b));
  }
  function p(b, h) {
    return f(b, h, o(h, b));
  }
  function g(b) {
    return (b | 0) * (b >> 31 | 1);
  }
  function S(b) {
    return (b >> 31 | -b >> 31) & 1;
  }
  function y(b, h, a) {
    e(k.isBuffer(b)), e(k.isBuffer(h)), e(m(b.length, h.length));
    const E = a - 1 & 255, H = ~(a - 1) & 255;
    for (let j = 0; j < b.length; j++)
      b[j] = b[j] & E | h[j] & H;
  }
  return Wt.safeCompare = c, Wt.safeEqual = l, Wt.safeEqualByte = w, Wt.safeEqualInt = m, Wt.safeSelect = f, Wt.safeLT = n, Wt.safeLTE = u, Wt.safeGT = o, Wt.safeGTE = s, Wt.safeMin = i, Wt.safeMax = p, Wt.safeAbs = g, Wt.safeBool = S, Wt.safeCopy = y, Wt;
}
/*!
 * rsa.js - RSA for javascript
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on golang/go:
 *   Copyright (c) 2009 The Go Authors. All rights reserved.
 *   https://github.com/golang/go
 *
 * Parts of this software are based on indutny/miller-rabin:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/miller-rabin
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/RSA_(cryptosystem)
 *   https://tools.ietf.org/html/rfc3447
 *   https://tools.ietf.org/html/rfc8017
 *   https://github.com/openssl/openssl/blob/master/crypto/rsa/rsa_ossl.c
 *   https://github.com/openssl/openssl/blob/master/crypto/rsa/rsa_sign.c
 *   https://github.com/openssl/openssl/blob/master/crypto/rsa/rsa_oaep.c
 *   https://github.com/openssl/openssl/blob/master/crypto/rsa/rsa_pss.c
 *   https://github.com/openssl/openssl/blob/master/crypto/rsa/rsa_pk1.c
 *   https://github.com/golang/go/blob/master/src/crypto/rsa/rsa.go
 *   https://github.com/golang/go/blob/master/src/crypto/rsa/pkcs1v15.go
 *   https://github.com/golang/go/blob/master/src/crypto/rsa/pss.go
 *   https://github.com/golang/go/blob/master/src/crypto/subtle/constant_time.go
 *   https://github.com/ARMmbed/mbed-crypto/blob/master/library/rsa.c
 *
 * References:
 *
 *   [RFC8017] PKCS #1: RSA Cryptography Specifications Version 2.2
 *     K. Moriarty, B. Kaliski, J. Jonsson, A. Rusch
 *     https://tools.ietf.org/html/rfc8017
 *
 *   [FIPS186] Federal Information Processing Standards Publication 186-4
 *     National Institute of Standards and Technology
 *     https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf
 */
var f6;
function $7() {
  if (f6) return zt;
  f6 = 1;
  const e = Mt(), c = jr(), l = Hi(), { randomPrime: w } = tx(), m = rx(), f = E7(), n = V7(), {
    safeEqual: u,
    safeEqualByte: o,
    safeSelect: s,
    safeLTE: i
  } = n, p = 2048, g = 65537, S = 512, y = 16384, b = 3, h = 2 ** 33 - 1, a = 33, E = 0, H = -1, j = k.alloc(8, 0), G = k.alloc(0), N = {
    __proto__: null,
    BLAKE2B160: k.from("3027300f060b2b060104018d3a0c02010505000414", "hex"),
    BLAKE2B256: k.from("3033300f060b2b060104018d3a0c02010805000420", "hex"),
    BLAKE2B384: k.from("3043300f060b2b060104018d3a0c02010c05000430", "hex"),
    BLAKE2B512: k.from("3053300f060b2b060104018d3a0c02011005000440", "hex"),
    BLAKE2S128: k.from("3023300f060b2b060104018d3a0c02020405000410", "hex"),
    BLAKE2S160: k.from("3027300f060b2b060104018d3a0c02020505000414", "hex"),
    BLAKE2S224: k.from("302f300f060b2b060104018d3a0c0202070500041c", "hex"),
    BLAKE2S256: k.from("3033300f060b2b060104018d3a0c02020805000420", "hex"),
    GOST94: k.from("302e300a06062a850302021405000420", "hex"),
    HASH160: k.from([20]),
    HASH256: k.from([32]),
    KECCAK224: k.from([28]),
    KECCAK256: k.from([32]),
    KECCAK384: k.from([48]),
    KECCAK512: k.from([64]),
    MD2: k.from("3020300c06082a864886f70d020205000410", "hex"),
    MD4: k.from("3020300c06082a864886f70d020405000410", "hex"),
    MD5: k.from("3020300c06082a864886f70d020505000410", "hex"),
    MD5SHA1: k.from([36]),
    RIPEMD160: k.from("3021300906052b2403020105000414", "hex"),
    SHA1: k.from("3021300906052b0e03021a05000414", "hex"),
    SHA224: k.from("302d300d06096086480165030402040500041c", "hex"),
    SHA256: k.from("3031300d060960864801650304020105000420", "hex"),
    SHA384: k.from("3041300d060960864801650304020205000430", "hex"),
    SHA512: k.from("3051300d060960864801650304020305000440", "hex"),
    SHA3_224: k.from("302d300d06096086480165030402070500041c", "hex"),
    SHA3_256: k.from("3031300d060960864801650304020805000420", "hex"),
    SHA3_384: k.from("3041300d060960864801650304020905000430", "hex"),
    SHA3_512: k.from("3051300d060960864801650304020a05000440", "hex"),
    SHAKE128: k.from("3021300d060960864801650304020b05000410", "hex"),
    SHAKE256: k.from("3031300d060960864801650304020c05000420", "hex"),
    WHIRLPOOL: k.from("304e300a060628cf0603003705000440", "hex")
  };
  class T {
    constructor() {
      this.n = new c(0), this.e = new c(0);
    }
    bits() {
      return this.n.bitLength();
    }
    size() {
      return this.n.byteLength();
    }
    isSane() {
      return this.n.sign() > 0 && this.e.sign() > 0 && this.n.bitLength() <= y && this.e.bitLength() <= a;
    }
    verify() {
      return !(!this.isSane() || this.n.bitLength() < S || !this.n.isOdd() || this.e.cmpn(b) < 0 || !this.e.isOdd());
    }
    encrypt(M) {
      e(k.isBuffer(M));
      const { n: $, e: r } = this, x = c.decode(M);
      if (x.cmp($) >= 0)
        throw new Error("Invalid RSA message size.");
      return x.powm(r, $).encode("be", $.byteLength());
    }
    encode() {
      const M = f.sizeInt(this.n) + f.sizeInt(this.e), $ = k.alloc(f.sizeSeq(M));
      let r = 0;
      return r = f.writeSeq($, r, M), r = f.writeInt($, r, this.n), r = f.writeInt($, r, this.e), e(r === $.length), $;
    }
    decode(M) {
      let $ = 0;
      if ($ = f.readSeq(M, $), [this.n, $] = f.readInt(M, $), [this.e, $] = f.readInt(M, $), $ !== M.length)
        throw new Error("Trailing bytes.");
      return this;
    }
    static decode(M) {
      return new T().decode(M);
    }
  }
  class A extends T {
    constructor() {
      super(), this.d = new c(0), this.p = new c(0), this.q = new c(0), this.dp = new c(0), this.dq = new c(0), this.qi = new c(0);
    }
    isSane() {
      return this.n.sign() > 0 && this.e.sign() > 0 && this.d.sign() > 0 && this.p.sign() > 0 && this.q.sign() > 0 && this.dp.sign() > 0 && this.dq.sign() > 0 && this.qi.sign() > 0 && this.n.bitLength() <= y && this.e.bitLength() <= a && this.d.bitLength() <= y && this.p.bitLength() <= y && this.q.bitLength() <= y && this.dp.bitLength() <= y && this.dq.bitLength() <= y && this.qi.bitLength() <= y;
    }
    verify() {
      if (!this.isSane() || this.n.bitLength() < S || !this.n.isOdd() || this.e.cmpn(b) < 0 || !this.e.isOdd() || this.p.cmpn(3) < 0 || !this.p.isOdd() || this.q.cmpn(3) < 0 || !this.q.isOdd())
        return !1;
      const M = this.p.subn(1), $ = this.q.subn(1), r = M.mul($);
      if (this.d.cmpn(2) < 0 || this.d.cmp(r) >= 0 || this.dp.sign() === 0 || this.dp.cmp(M) >= 0 || this.dq.sign() === 0 || this.dq.cmp($) >= 0 || this.qi.cmpn(2) < 0 || this.qi.cmp(this.p) >= 0 || this.p.cmp(this.q) === 0 || this.p.mul(this.q).cmp(this.n) !== 0)
        return !1;
      const x = r.div(M.gcd($));
      return !(this.e.mul(this.d).imod(x).cmpn(1) !== 0 || this.d.mod(M).cmp(this.dp) !== 0 || this.d.mod($).cmp(this.dq) !== 0 || this.q.mul(this.qi).imod(this.p).cmpn(1) !== 0);
    }
    decrypt(M) {
      e(k.isBuffer(M));
      const { n: $, e: r, p: x, q: O, dp: K, dq: X, qi: P } = this, V = c.decode(M);
      if (V.cmp($) >= 0)
        throw new Error("Invalid RSA message size.");
      let re, ce;
      for (; ; ) {
        const ee = c.random(l, 1, $);
        try {
          ce = ee.invert($);
        } catch {
          continue;
        }
        re = ee.powm(r, $);
        break;
      }
      V.imul(re).imod($);
      const de = V.powm(K, x, !0), pe = V.powm(X, O, !0), Z = de.sub(pe).mul(P).imod(x).mul(O).iadd(pe).imod($);
      if (Z.powm(r, $).cmp(V) !== 0)
        throw new Error("Invalid RSA private key.");
      return Z.imul(ce).imod($), Z.encode("be", $.byteLength());
    }
    generate(M, $) {
      e(M >>> 0 === M), e(Number.isSafeInteger($) && $ >= 0), e(M >= 64), e($ >= 3 && ($ & 1) !== 0);
      const r = new c($);
      for (; ; ) {
        const x = w((M >>> 1) + (M & 1)), O = w(M >>> 1);
        if (x.cmp(O) === 0 || (x.cmp(O) < 0 && x.swap(O), x.sub(O).bitLength() <= (M >>> 1) - 99))
          continue;
        const K = x.mul(O);
        if (K.bitLength() !== M)
          continue;
        const X = x.subn(1), P = O.subn(1), V = X.mul(P);
        if (r.gcd(V).cmpn(1) !== 0)
          continue;
        const re = V.div(X.gcd(P)), ce = r.invert(re);
        if (ce.bitLength() <= M + 1 >>> 1)
          continue;
        const de = ce.mod(X), pe = ce.mod(P), se = O.invert(x);
        return this.n = K, this.e = r, this.d = ce, this.p = x, this.q = O, this.dp = de, this.dq = pe, this.qi = se, this;
      }
    }
    async _generateSubtle(M, $) {
      e(M >>> 0 === M), e(Number.isSafeInteger($) && $ >= 0), e(M >= 64), e($ >= 3 && ($ & 1) !== 0);
      const r = dn.crypto || dn.msCrypto;
      if (!r)
        throw new Error("Crypto API not available.");
      const { subtle: x } = r;
      if (!x || !x.generateKey || !x.exportKey)
        throw new Error("Subtle API not available.");
      const O = new c($), K = {
        name: "RSASSA-PKCS1-v1_5",
        modulusLength: M,
        publicExponent: O.toArrayLike(Uint8Array, "be", 8),
        hash: { name: "SHA-256" }
      }, X = await x.generateKey(K, !0, ["sign"]), P = await x.exportKey("jwk", X.privateKey), V = c.decode(m.decodeURL(P.p)), re = c.decode(m.decodeURL(P.q));
      return this.fromPQE(V, re, O);
    }
    async generateAsync(M, $) {
      try {
        return await this._generateSubtle(M, $);
      } catch {
        return this.generate(M, $);
      }
    }
    fromPQE(M, $, r) {
      if (e(M instanceof c), e($ instanceof c), e(r instanceof c), M.cmp($) < 0 && ([M, $] = [$, M]), M.cmp($) === 0)
        throw new Error("Invalid RSA private key.");
      if (M.cmpn(3) < 0 || M.bitLength() > y)
        throw new Error("Invalid RSA private key.");
      if ($.cmpn(3) < 0 || $.bitLength() > y)
        throw new Error("Invalid RSA private key.");
      if (r.cmpn(b) < 0 || r.bitLength() > a)
        throw new Error("Invalid RSA private key.");
      if (!M.isOdd() || !$.isOdd() || !r.isOdd())
        throw new Error("Invalid RSA private key.");
      const x = M.mul($);
      if (e(x.isOdd()), x.bitLength() < S || x.bitLength() > y)
        throw new Error("Invalid RSA private key.");
      const O = M.subn(1), K = $.subn(1), X = O.lcm(K), P = r.invert(X), V = P.mod(O), re = P.mod(K), ce = $.invert(M);
      return this.n = x, this.e = r, this.d = P, this.p = M, this.q = $, this.dp = V, this.dq = re, this.qi = ce, this;
    }
    fromPQD(M, $, r) {
      if (e(M instanceof c), e($ instanceof c), e(r instanceof c), M.cmpn(3) < 0 || M.bitLength() > y)
        throw new Error("Invalid RSA private key.");
      if ($.cmpn(3) < 0 || $.bitLength() > y)
        throw new Error("Invalid RSA private key.");
      if (!M.isOdd() || !$.isOdd())
        throw new Error("Invalid RSA private key.");
      const x = M.subn(1), O = $.subn(1), K = x.mul(O);
      if (r.cmpn(2) < 0 || r.cmp(K) >= 0)
        throw new Error("Invalid RSA private key.");
      const X = K.div(x.gcd(O)), P = r.invert(X);
      return this.fromPQE(M, $, P);
    }
    fromNED(M, $, r) {
      if (e(M instanceof c), e($ instanceof c), e(r instanceof c), M.sign() < 0)
        throw new Error("Invalid RSA private key.");
      if (M.bitLength() < S || M.bitLength() > y)
        throw new Error("Invalid RSA private key.");
      if ($.cmpn(b) < 0 || $.bitLength() > a)
        throw new Error("Invalid RSA private key.");
      if (r.cmpn(2) < 0 || r.bitLength() > y)
        throw new Error("Invalid RSA private key.");
      if (!M.isOdd() || !$.isOdd())
        throw new Error("Invalid RSA private key.");
      const x = $.mul(r).isubn(1), O = M.subn(1), K = x.zeroBits(), X = x.ushrn(K);
      for (let P = 0; P < 64; P++) {
        let re = c.random(l, 2, O).powm(X, M);
        if (!(re.cmpn(1) === 0 || re.cmp(O) === 0))
          for (let ce = 1; ce < K; ce++) {
            const de = re.sqr().imod(M);
            if (de.cmpn(1) === 0) {
              const pe = M.gcd(re.subn(1)), se = M.gcd(re.addn(1));
              return this.fromPQE(pe, se, $);
            }
            if (de.cmp(O) === 0)
              break;
            re = de;
          }
      }
      throw new Error("Invalid RSA private key.");
    }
    toPublic() {
      const M = new T();
      return M.n = this.n, M.e = this.e, M;
    }
    encode() {
      let M = 0;
      M += f.sizeVersion(0), M += f.sizeInt(this.n), M += f.sizeInt(this.e), M += f.sizeInt(this.d), M += f.sizeInt(this.p), M += f.sizeInt(this.q), M += f.sizeInt(this.dp), M += f.sizeInt(this.dq), M += f.sizeInt(this.qi);
      const $ = k.alloc(f.sizeSeq(M));
      let r = 0;
      return r = f.writeSeq($, r, M), r = f.writeVersion($, r, 0), r = f.writeInt($, r, this.n), r = f.writeInt($, r, this.e), r = f.writeInt($, r, this.d), r = f.writeInt($, r, this.p), r = f.writeInt($, r, this.q), r = f.writeInt($, r, this.dp), r = f.writeInt($, r, this.dq), r = f.writeInt($, r, this.qi), e(r === $.length), $;
    }
    decode(M) {
      let $ = 0;
      if ($ = f.readSeq(M, $), $ = f.readVersion(M, $, 0), [this.n, $] = f.readInt(M, $), [this.e, $] = f.readInt(M, $), [this.d, $] = f.readInt(M, $), [this.p, $] = f.readInt(M, $), [this.q, $] = f.readInt(M, $), [this.dp, $] = f.readInt(M, $), [this.dq, $] = f.readInt(M, $), [this.qi, $] = f.readInt(M, $), $ !== M.length)
        throw new Error("Trailing bytes.");
      return this;
    }
    static generate(M, $) {
      return new A().generate(M, $);
    }
    static async generateAsync(M, $) {
      return new A().generateAsync(M, $);
    }
    static fromPQE(M, $, r) {
      return new A().fromPQE(M, $, r);
    }
    static fromPQD(M, $, r) {
      return new A().fromPQD(M, $, r);
    }
    static fromNED(M, $, r) {
      return new A().fromNED(M, $, r);
    }
    static decode(M) {
      return new A().decode(M);
    }
  }
  function q(C, M) {
    if (C == null && (C = p), M == null && (M = g), e(C >>> 0 === C), e(Number.isSafeInteger(M) && M >= 0), C < S || C > y)
      throw new RangeError(`"bits" ranges from ${S} to ${y}.`);
    if (M < b || M > h)
      throw new RangeError(`"exponent" ranges from ${b} to ${h}.`);
    if (M === 1 || (M & 1) === 0)
      throw new RangeError('"exponent" must be odd.');
    return A.generate(C, M).encode();
  }
  async function _(C, M) {
    if (C == null && (C = p), M == null && (M = g), e(C >>> 0 === C), e(Number.isSafeInteger(M) && M >= 0), C < S || C > y)
      throw new RangeError(`"bits" ranges from ${S} to ${y}.`);
    if (M < b || M > h)
      throw new RangeError(`"exponent" ranges from ${b} to ${h}.`);
    if (M === 1 || (M & 1) === 0)
      throw new RangeError('"exponent" must be odd.');
    return (await A.generateAsync(C, M)).encode();
  }
  function F(C) {
    const M = A.decode(C);
    if (!M.verify())
      throw new Error("Invalid RSA private key.");
    return M.bits();
  }
  function R(C) {
    e(k.isBuffer(C));
    let M;
    try {
      M = A.decode(C);
    } catch {
      return !1;
    }
    return M.verify();
  }
  function L(C) {
    e(C && typeof C == "object");
    let M = new A();
    return C.n != null && (M.n = c.decode(C.n)), C.e != null && (M.e = c.decode(C.e)), C.d != null && (M.d = c.decode(C.d)), C.p != null && (M.p = c.decode(C.p)), C.q != null && (M.q = c.decode(C.q)), C.dp != null && (M.dp = c.decode(C.dp)), C.dq != null && (M.dq = c.decode(C.dq)), C.qi != null && (M.qi = c.decode(C.qi)), M.verify() || (!M.p.isZero() && !M.q.isZero() ? M.e.isZero() ? M = A.fromPQD(M.p, M.q, M.d) : M = A.fromPQE(M.p, M.q, M.e) : M = A.fromNED(M.n, M.e, M.d)), M.encode();
  }
  function fe(C) {
    const M = A.decode(C);
    if (!M.verify())
      throw new Error("Invalid RSA private key.");
    return {
      n: M.n.encode(),
      e: M.e.encode(),
      d: M.d.encode(),
      p: M.p.encode(),
      q: M.q.encode(),
      dp: M.dp.encode(),
      dq: M.dq.encode(),
      qi: M.qi.encode()
    };
  }
  function ue(C) {
    const M = A.decode(C);
    if (!M.verify())
      throw new Error("Invalid RSA private key.");
    return M.toPublic().encode();
  }
  function ae(C) {
    const M = T.decode(C);
    if (!M.verify())
      throw new Error("Invalid RSA public key.");
    return M.bits();
  }
  function D(C) {
    e(k.isBuffer(C));
    let M;
    try {
      M = T.decode(C);
    } catch {
      return !1;
    }
    return M.verify();
  }
  function Q(C) {
    e(C && typeof C == "object");
    const M = new T();
    if (C.n != null && (M.n = c.decode(C.n)), C.e != null && (M.e = c.decode(C.e)), !M.verify())
      throw new Error("Invalid RSA public key.");
    return M.encode();
  }
  function W(C) {
    const M = T.decode(C);
    if (!M.verify())
      throw new Error("Invalid RSA public key.");
    return {
      n: M.n.encode(),
      e: M.e.encode()
    };
  }
  function oe(C, M, $) {
    C && typeof C.id == "string" && (C = C.id), e(C == null || typeof C == "string"), e(k.isBuffer(M));
    const [r, x] = d(C, M);
    if (!r)
      throw new Error("Unknown RSA hash function.");
    if (M.length !== x)
      throw new Error("Invalid RSA message size.");
    const O = A.decode($);
    if (!O.verify())
      throw new Error("Invalid RSA private key.");
    const K = r.length + x, X = O.size();
    if (X < K + 11)
      throw new Error("Invalid RSA message size.");
    const P = k.alloc(X);
    P[0] = 0, P[1] = 1;
    for (let V = 2; V < X - K - 1; V++)
      P[V] = 255;
    return P[X - K - 1] = 0, r.copy(P, X - K), M.copy(P, X - x), O.decrypt(P);
  }
  function v(C, M, $, r) {
    C && typeof C.id == "string" && (C = C.id), e(C == null || typeof C == "string"), e(k.isBuffer(M)), e(k.isBuffer($)), e(k.isBuffer(r));
    try {
      return Y(C, M, $, r);
    } catch {
      return !1;
    }
  }
  function Y(C, M, $, r) {
    const [x, O] = d(C, M);
    if (!x || M.length !== O)
      return !1;
    const K = T.decode(r);
    if (!K.verify())
      return !1;
    const X = K.size();
    if ($.length !== X)
      return !1;
    const P = x.length + O;
    if (X < P + 11)
      return !1;
    const V = K.encrypt($);
    let re = 1;
    re &= o(V[0], 0), re &= o(V[1], 1);
    for (let ce = 2; ce < X - P - 1; ce++)
      re &= o(V[ce], 255);
    return re &= o(V[X - P - 1], 0), re &= u(V.slice(X - P, X - O), x), re &= u(V.slice(X - O, X), M), re === 1;
  }
  function he(C, M) {
    e(k.isBuffer(C));
    const $ = T.decode(M);
    if (!$.verify())
      throw new Error("Invalid RSA public key.");
    const r = $.size();
    if (C.length > r - 11)
      throw new Error("Invalid RSA message size.");
    const x = k.alloc(r), O = C.length, K = r - O - 3;
    x[0] = 0, x[1] = 2, l.randomFill(x, 2, K);
    for (let X = 2; X < 2 + K; X++)
      for (; x[X] === 0; )
        l.randomFill(x, X, 1);
    return x[r - O - 1] = 0, C.copy(x, r - O), $.encrypt(x);
  }
  function le(C, M) {
    e(k.isBuffer(C));
    const $ = A.decode(M);
    if (!$.verify())
      throw new Error("Invalid RSA private key.");
    const r = $.size();
    if (r < 11)
      throw new Error("Invalid RSA private key.");
    if (C.length !== r)
      throw new Error("Invalid RSA message size.");
    const x = $.decrypt(C), O = o(x[0], 0), K = o(x[1], 2);
    let X = 0, P = 1;
    for (let de = 2; de < x.length; de++) {
      const pe = o(x[de], 0);
      X = s(X, de, P & pe), P = s(P, 0, pe);
    }
    const V = i(10, X), re = O & K & (P ^ 1) & V, ce = s(0, X + 1, re);
    if (re === 0)
      throw new Error("Invalid RSA ciphertext.");
    return x.slice(ce);
  }
  function ge(C, M, $, r) {
    if (r == null && (r = H), e(C && typeof C.id == "string"), e(k.isBuffer(M)), e((r | 0) === r), M.length !== C.size)
      throw new Error("Invalid RSA message size.");
    const x = A.decode($);
    if (!x.verify())
      throw new Error("Invalid RSA private key.");
    const O = x.bits(), K = O + 7 >>> 3, X = O + 6 >>> 3;
    if (r === E ? r = X - 2 - C.size : r === H && (r = C.size), r < 0 || r > K)
      throw new Error("Invalid PSS salt length.");
    const P = l.randomBytes(r), V = U(C, M, O - 1, P);
    return x.decrypt(V);
  }
  function Ee(C, M, $, r, x) {
    x == null && (x = H), e(C && typeof C.id == "string"), e(k.isBuffer(M)), e(k.isBuffer($)), e(k.isBuffer(r)), e((x | 0) === x);
    try {
      return we(C, M, $, r, x);
    } catch {
      return !1;
    }
  }
  function we(C, M, $, r, x) {
    if (M.length !== C.size)
      return !1;
    const O = T.decode(r);
    if (!O.verify())
      return !1;
    const K = O.bits(), X = K + 7 >>> 3;
    if ($.length !== X || (x === E ? x = 0 : x === H && (x = C.size), x < 0 || x > X))
      return !1;
    let P = O.encrypt($);
    if ((K - 1 & 7) === 0) {
      if (P[0] !== 0)
        return !1;
      P = P.slice(1);
    }
    return J(C, M, P, K - 1, x);
  }
  function z(C, M, $, r) {
    r == null && (r = G), e(C && typeof C.id == "string"), e(k.isBuffer(M)), e(k.isBuffer(r));
    const x = T.decode($);
    if (!x.verify())
      throw new Error("Invalid RSA public key.");
    const O = x.size(), K = M.length, X = C.size;
    if (K > O - 2 * X - 2)
      throw new Error("Invalid RSA message size.");
    const P = k.alloc(O), V = C.digest(r), re = P.slice(1, 1 + X), ce = P.slice(1 + X), de = ce.length;
    return P[0] = 0, l.randomFill(re, 0, re.length), V.copy(ce, 0), ce.fill(0, X, de - K - 1), ce[de - K - 1] = 1, M.copy(ce, de - K), B(C, ce, re), B(C, re, ce), x.encrypt(P);
  }
  function I(C, M, $, r) {
    r == null && (r = G), e(C && typeof C.id == "string"), e(k.isBuffer(M)), e(k.isBuffer(r));
    const x = A.decode($);
    if (!x.verify())
      throw new Error("Invalid RSA private key.");
    const O = x.size(), K = M.length, X = C.size;
    if (O < X * 2 + 2)
      throw new Error("Invalid RSA private key size.");
    if (K !== O)
      throw new Error("Invalid RSA message size.");
    const P = x.decrypt(M), V = C.digest(r), re = o(P[0], 0), ce = P.slice(1, X + 1), de = P.slice(X + 1);
    B(C, ce, de), B(C, de, ce);
    const pe = de.slice(0, X), se = u(pe, V), Z = de.slice(X);
    let ee = 1, me = 0, Ae = 0;
    for (let ye = 0; ye < Z.length; ye++) {
      const _e = o(Z[ye], 0), ke = o(Z[ye], 1);
      me = s(me, ye, ee & ke), ee = s(ee, 0, ke), Ae = s(Ae, 1, ee & (_e ^ 1));
    }
    if ((re & se & (Ae ^ 1) & (ee ^ 1)) === 0)
      throw new Error("Invalid RSA ciphertext.");
    return Z.slice(me + 1);
  }
  function ne(C, M, $) {
    e(k.isBuffer(C)), e(M >>> 0 === M);
    const r = T.decode($);
    if (!r.verify())
      throw new Error("Invalid RSA public key.");
    if (C.length !== r.size())
      throw new Error("Invalid RSA ciphertext.");
    if (M < r.bits())
      throw new Error("Cannot make ciphertext smaller.");
    const x = M + 7 >>> 3, O = c.decode(C);
    if (O.cmp(r.n) >= 0)
      throw new Error("Invalid RSA ciphertext.");
    const K = c.shift(1, M), X = K.sub(O).iadd(r.n).isubn(1).div(r.n);
    e(X.sign() > 0);
    let P = K;
    for (; P.cmp(K) >= 0; ) {
      const V = c.random(l, 0, X);
      P = O.add(V.mul(r.n));
    }
    return e(P.mod(r.n).cmp(O) === 0), e(P.bitLength() <= M), P.encode("be", x);
  }
  function t(C, M, $) {
    e(k.isBuffer(C)), e(M >>> 0 === M);
    const r = T.decode($);
    if (!r.verify())
      throw new Error("Invalid RSA public key.");
    const x = r.size();
    if (C.length < x)
      throw new Error("Invalid RSA ciphertext.");
    const O = c.decode(C);
    if (M !== 0 && O.bitLength() > M)
      throw new Error("Invalid RSA ciphertext.");
    return O.imod(r.n).encode("be", x);
  }
  function d(C, M) {
    if (e(C == null || typeof C == "string"), e(k.isBuffer(M)), C == null)
      return [G, M.length];
    const $ = N[C];
    return $ == null ? [null, 0] : $.length === 1 ? [G, $[0]] : [
      $,
      $[$.length - 1]
    ];
  }
  function B(C, M, $) {
    e(C && typeof C.id == "string"), e(k.isBuffer(M)), e(k.isBuffer($));
    const r = k.alloc(4, 0);
    let x = 0;
    for (; x < M.length; ) {
      const O = C.multi($, r);
      let K = 0;
      for (; x < M.length && K < O.length; )
        M[x++] ^= O[K++];
      for (K = 3; K >= 0 && (r[K] += 1, r[K] === 0); K--)
        ;
    }
  }
  function U(C, M, $, r) {
    e(C && typeof C.id == "string"), e(k.isBuffer(M)), e($ >>> 0 === $), e(k.isBuffer(r));
    const x = C.size, O = r.length, K = $ + 7 >>> 3;
    if (M.length !== x)
      throw new Error("Invalid RSA message size.");
    if (K < x + O + 2)
      throw new Error("Message too long.");
    const X = k.alloc(K), P = X.slice(0, K - x - 1), V = X.slice(K - x - 1, K - 1), re = C.multi(j, M, r), ce = 255 >>> 8 * K - $;
    return P.fill(0, 0, K - O - x - 2), P[K - O - x - 2] = 1, r.copy(P, K - O - x - 1), re.copy(V, 0), X[K - 1] = 188, B(C, P, V), P[0] &= ce, X;
  }
  function J(C, M, $, r, x) {
    e(C && typeof C.id == "string"), e(k.isBuffer(M)), e(k.isBuffer($)), e(r >>> 0 === r), e(x >>> 0 === x);
    const O = C.size, K = r + 7 >>> 3;
    if (M.length !== O || K < O + x + 2 || $[K - 1] !== 188)
      return !1;
    const X = $.slice(0, K - O - 1), P = $.slice(K - O - 1, K - 1), V = 255 >>> 8 * K - r;
    if ($[0] & ~V)
      return !1;
    if (B(C, X, P), X[0] &= V, x === 0) {
      x = -1;
      for (let de = 0; de < X.length; de++)
        if (X[de] !== 0) {
          if (X[de] === 1) {
            x = X.length - (de + 1);
            break;
          }
          return !1;
        }
      if (x === -1)
        return !1;
    } else {
      const de = X.length - x - 1;
      for (let pe = 0; pe < de; pe++)
        if (X[pe] !== 0)
          return !1;
      if (X[de] !== 1)
        return !1;
    }
    const re = X.slice(X.length - x);
    return C.multi(j, M, re).equals(P);
  }
  return zt.native = 0, zt.SALT_LENGTH_AUTO = E, zt.SALT_LENGTH_HASH = H, zt.privateKeyGenerate = q, zt.privateKeyGenerateAsync = _, zt.privateKeyBits = F, zt.privateKeyVerify = R, zt.privateKeyImport = L, zt.privateKeyExport = fe, zt.publicKeyCreate = ue, zt.publicKeyBits = ae, zt.publicKeyVerify = D, zt.publicKeyImport = Q, zt.publicKeyExport = W, zt.sign = oe, zt.verify = v, zt.encrypt = he, zt.decrypt = le, zt.signPSS = ge, zt.verifyPSS = Ee, zt.encryptOAEP = z, zt.decryptOAEP = I, zt.veil = ne, zt.unveil = t, zt;
}
var Dn = {};
/*!
 * scrypt.js - scrypt for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on Tarsnap/scrypt:
 *   Copyright (c) 2005-2016, Colin Percival. All rights reserved.
 *   Copyright (c) 2005-2016, Tarsnap Backup Inc. All rights reserved.
 *   Copyright (c) 2014, Sean Kelly. All rights reserved.
 *   https://github.com/Tarsnap/scrypt
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/Scrypt
 *   http://www.tarsnap.com/scrypt.html
 *   http://www.tarsnap.com/scrypt/scrypt.pdf
 *   https://github.com/Tarsnap/scrypt/blob/master/lib/crypto/crypto_scrypt-ref.c
 */
var c6;
function ix() {
  if (c6) return Dn;
  c6 = 1;
  const e = Mt(), c = Tl(), l = br(), w = k.alloc(64), m = new Uint32Array(16), f = new Uint32Array(16);
  function n(j, G, N, T, A, q) {
    if (typeof j == "string" && (j = k.from(j, "utf8")), typeof G == "string" && (G = k.from(G, "utf8")), G == null && (G = k.alloc(0)), e(k.isBuffer(j)), e(k.isBuffer(G)), e(N >>> 0 === N), e(T >>> 0 === T), e(A >>> 0 === A), e(q >>> 0 === q), T * A >= 1 << 30)
      throw new Error("EFBIG");
    if ((N & N - 1) !== 0 || N === 0)
      throw new Error("EINVAL");
    if (N > 4294967295)
      throw new Error("EINVAL");
    const _ = k.alloc(256 * T), F = k.alloc(128 * T * N), R = c.derive(l, j, G, 1, A * 128 * T);
    for (let L = 0; L < A; L++)
      g(R, L * 128 * T, T, N, F, _);
    return a(), c.derive(l, j, R, 1, q);
  }
  async function u(j, G, N, T, A, q) {
    if (typeof j == "string" && (j = k.from(j, "utf8")), typeof G == "string" && (G = k.from(G, "utf8")), G == null && (G = k.alloc(0)), e(k.isBuffer(j)), e(k.isBuffer(G)), e(N >>> 0 === N), e(T >>> 0 === T), e(A >>> 0 === A), e(q >>> 0 === q), T * A >= 1 << 30)
      throw new Error("EFBIG");
    if ((N & N - 1) !== 0 || N === 0)
      throw new Error("EINVAL");
    if (N > 4294967295)
      throw new Error("EINVAL");
    const _ = k.alloc(256 * T), F = k.alloc(128 * T * N), R = await c.deriveAsync(l, j, G, 1, A * 128 * T);
    for (let L = 0; L < A; L++)
      await S(R, L * 128 * T, T, N, F, _);
    return a(), c.deriveAsync(l, j, R, 1, q);
  }
  function o(j) {
    const G = m, N = f;
    for (let T = 0; T < 16; T++)
      G[T] = E(j, T * 4);
    for (let T = 0; T < 16; T++)
      N[T] = G[T];
    for (let T = 0; T < 8; T += 2)
      N[4] ^= s(N[0] + N[12], 7), N[8] ^= s(N[4] + N[0], 9), N[12] ^= s(N[8] + N[4], 13), N[0] ^= s(N[12] + N[8], 18), N[9] ^= s(N[5] + N[1], 7), N[13] ^= s(N[9] + N[5], 9), N[1] ^= s(N[13] + N[9], 13), N[5] ^= s(N[1] + N[13], 18), N[14] ^= s(N[10] + N[6], 7), N[2] ^= s(N[14] + N[10], 9), N[6] ^= s(N[2] + N[14], 13), N[10] ^= s(N[6] + N[2], 18), N[3] ^= s(N[15] + N[11], 7), N[7] ^= s(N[3] + N[15], 9), N[11] ^= s(N[7] + N[3], 13), N[15] ^= s(N[11] + N[7], 18), N[1] ^= s(N[0] + N[3], 7), N[2] ^= s(N[1] + N[0], 9), N[3] ^= s(N[2] + N[1], 13), N[0] ^= s(N[3] + N[2], 18), N[6] ^= s(N[5] + N[4], 7), N[7] ^= s(N[6] + N[5], 9), N[4] ^= s(N[7] + N[6], 13), N[5] ^= s(N[4] + N[7], 18), N[11] ^= s(N[10] + N[9], 7), N[8] ^= s(N[11] + N[10], 9), N[9] ^= s(N[8] + N[11], 13), N[10] ^= s(N[9] + N[8], 18), N[12] ^= s(N[15] + N[14], 7), N[13] ^= s(N[12] + N[15], 9), N[14] ^= s(N[13] + N[12], 13), N[15] ^= s(N[14] + N[13], 18);
    for (let T = 0; T < 16; T++)
      G[T] += N[T];
    for (let T = 0; T < 16; T++)
      H(j, G[T], 4 * T);
  }
  function s(j, G) {
    return j << G | j >>> 32 - G;
  }
  function i(j, G, N, T) {
    const A = w;
    y(A, j, 0, (2 * T - 1) * 64, 64);
    for (let q = 0; q < 2 * T; q++)
      b(A, j, 0, q * 64, 64), o(A), y(G, A, N + q * 64, 0, 64);
    for (let q = 0; q < T; q++)
      y(j, G, q * 64, N + q * 2 * 64, 64);
    for (let q = 0; q < T; q++)
      y(j, G, (q + T) * 64, N + (q * 2 + 1) * 64, 64);
  }
  function p(j, G) {
    return E(j, (2 * G - 1) * 64);
  }
  function g(j, G, N, T, A, q) {
    const _ = q, F = q;
    y(_, j, 0, G, 128 * N);
    for (let R = 0; R < T; R++)
      y(A, _, R * (128 * N), 0, 128 * N), i(_, F, 128 * N, N);
    for (let R = 0; R < T; R++) {
      const L = p(_, N) & T - 1;
      b(_, A, 0, L * (128 * N), 128 * N), i(_, F, 128 * N, N);
    }
    y(j, _, G, 0, 128 * N);
  }
  async function S(j, G, N, T, A, q) {
    const _ = q, F = q;
    y(_, j, 0, G, 128 * N);
    for (let R = 0; R < T; R++)
      y(A, _, R * (128 * N), 0, 128 * N), i(_, F, 128 * N, N), await h();
    for (let R = 0; R < T; R++) {
      const L = p(_, N) & T - 1;
      b(_, A, 0, L * (128 * N), 128 * N), i(_, F, 128 * N, N), await h();
    }
    y(j, _, G, 0, 128 * N);
  }
  function y(j, G, N, T, A) {
    G.copy(j, N, T, T + A);
  }
  function b(j, G, N, T, A) {
    for (let q = 0; q < A; q++)
      j[N + q] ^= G[T + q];
  }
  function h() {
    return new Promise((j) => setImmediate(j));
  }
  function a() {
    for (let j = 0; j < 64; j++)
      w[j] = 0;
    for (let j = 0; j < 16; j++)
      m[j] = 0, f[j] = 0;
  }
  function E(j, G) {
    return j[G++] + j[G++] * 256 + j[G++] * 65536 + j[G] * 16777216;
  }
  function H(j, G, N) {
    return j[N++] = G, G >>>= 8, j[N++] = G, G >>>= 8, j[N++] = G, G >>>= 8, j[N++] = G, N;
  }
  return Dn.native = 0, Dn.derive = n, Dn.deriveAsync = u, Dn;
}
/*!
 * sha224.js - SHA224 implementation for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/hash.js:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/hash.js
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/SHA-2
 *   https://tools.ietf.org/html/rfc4634
 *   https://github.com/indutny/hash.js/blob/master/lib/hash/sha/224.js
 */
var N0, u6;
function j7() {
  if (u6) return N0;
  u6 = 1;
  const e = Mt(), c = br(), l = ni();
  class w extends c {
    constructor() {
      super();
    }
    init() {
      return this.state[0] = 3238371032, this.state[1] = 914150663, this.state[2] = 812702999, this.state[3] = 4144912697, this.state[4] = 4290775857, this.state[5] = 1750603025, this.state[6] = 1694076839, this.state[7] = 3204075428, this.size = 0, this;
    }
    final() {
      return super.final().slice(0, 28);
    }
    static hash() {
      return new w();
    }
    static hmac() {
      return new l(w, 64);
    }
    static digest(f) {
      return w.ctx.init().update(f).final();
    }
    static root(f, n) {
      return e(k.isBuffer(f) && f.length === 28), e(k.isBuffer(n) && n.length === 28), w.ctx.init().update(f).update(n).final();
    }
    static multi(f, n, u) {
      const { ctx: o } = w;
      return o.init(), o.update(f), o.update(n), u && o.update(u), o.final();
    }
    static mac(f, n) {
      return w.hmac().init(n).update(f).final();
    }
  }
  return w.native = 0, w.id = "SHA224", w.size = 28, w.bits = 224, w.blockSize = 64, w.zero = k.alloc(28, 0), w.ctx = new w(), N0 = w, N0;
}
/*!
 * bcrypto.js - crypto for bcrypto
 * Copyright (c) 2014-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var h6;
function nx() {
  return h6 || (h6 = 1, function(e) {
    e.aes = ex(), e.BN = jr(), e.ChaCha20 = I7(), e.cleanse = ao(), e.Hash160 = wn(), e.Hash256 = qr(), e.HmacDRBG = A7(), e.Keccak = C7(), e.merkle = N7(), e.murmur3 = Fl(), e.p224 = D7(), e.p256 = U7(), e.p384 = F7(), e.p521 = K7(), e.pbkdf2 = Tl(), e.random = Hi(), e.RIPEMD160 = ll(), e.rsa = $7(), e.safe = V7(), e.scrypt = ix(), e.secp256k1 = Yr(), e.SHA1 = _7(), e.SHA224 = j7(), e.SHA256 = br(), e.SHA384 = Hl(), e.SHA512 = $i(), e.SHAKE = H7(), e.SHAKE256 = L7(), e.version = "5.5.1", e.native = e.SHA256.native;
  }(S0)), S0;
}
var ws = {};
/*!
 * bloom.js - bloom filter for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var q0, l6;
function sx() {
  if (l6) return q0;
  l6 = 1;
  const { enforce: e } = dt, c = Bt, l = Fl(), w = k.alloc(0), m = 0.48045301391820144, f = 0.6931471805599453;
  class n extends c.Struct {
    /**
     * Create a bloom filter.
     * @constructor
     * @param {Number} size - Filter size in bits.
     * @param {Number} n - Number of hash functions.
     * @param {Number} tweak - Seed value.
     * @param {Number|String} - Update type.
     * @property {Buffer} filter
     * @property {Number} size
     * @property {Number} n
     * @property {Number} tweak
     * @property {Number} update - Update flag (see {@link BloomFilter.flags}).
     */
    constructor(s, i, p, g) {
      super(), this.filter = w, this.size = 0, this.n = 0, this.tweak = 0, this.update = n.flags.NONE, s != null && this.fromOptions(s, i, p, g);
    }
    /**
     * Inject properties from options.
     * @private
     * @param {Number} size - Filter size in bits.
     * @param {Number} n - Number of hash functions.
     * @param {Number} tweak - Seed value.
     * @param {Number|String} - Update type.
     * @returns {BloomFilter}
     */
    fromOptions(s, i, p, g) {
      return (p == null || p === -1) && (p = Math.random() * 4294967296 >>> 0), (g == null || g === -1) && (g = n.flags.NONE), typeof g == "string" && (g = n.flags[g.toUpperCase()], e(g != null, "update", "flag")), e(Number.isSafeInteger(s) && s >= 0, "size", "integer"), e(Number.isSafeInteger(i) && i >= 0, "n", "integer"), e(p >>> 0 === p, "tweak", "integer"), e(g >>> 0 === g, "update", "integer"), e(g <= 2, "update", "range between 0 and 2"), s < 8 && (s = 8), i === 0 && (i = 1), s -= s & 7, this.filter = k.alloc(s / 8, 0), this.size = s, this.n = i, this.tweak = p, this.update = g, this;
    }
    /**
     * Instantiate bloom filter from options.
     * @param {Number} size - Filter size in bits.
     * @param {Number} n - Number of hash functions.
     * @param {Number} tweak - Seed value.
     * @param {Number|String} - Update type.
     * @returns {BloomFilter}
     */
    static fromOptions(s, i, p, g) {
      return new this().fromOptions(s, i, p, g);
    }
    /**
     * Perform the mumur3 hash on data.
     * @param {Buffer} value
     * @param {Number} n
     * @returns {Number}
     */
    hash(s, i) {
      return l.tweak(s, i, this.tweak) % this.size;
    }
    /**
     * Reset the filter.
     */
    reset() {
      this.filter.fill(0);
    }
    /**
     * Add data to the filter.
     * @param {Buffer|String}
     * @param {String?} enc - Can be any of the Buffer object's encodings.
     */
    add(s, i) {
      const p = u(s, i);
      for (let g = 0; g < this.n; g++) {
        const S = this.hash(p, g);
        this.filter[S >>> 3] |= 1 << (7 & S);
      }
    }
    /**
     * Test whether data is present in the filter.
     * @param {Buffer|String} value
     * @param {String?} enc - Can be any of the Buffer object's encodings.
     * @returns {Boolean}
     */
    test(s, i) {
      const p = u(s, i);
      for (let g = 0; g < this.n; g++) {
        const S = this.hash(p, g);
        if ((this.filter[S >>> 3] & 1 << (7 & S)) === 0)
          return !1;
      }
      return !0;
    }
    /**
     * Test whether data is present in the
     * filter and potentially add data.
     * @param {Buffer|String} value
     * @param {String?} enc - Can be any of the Buffer object's encodings.
     * @returns {Boolean} Whether data was added.
     */
    added(s, i) {
      const p = u(s, i);
      let g = !1;
      for (let S = 0; S < this.n; S++) {
        const y = this.hash(p, S);
        !g && (this.filter[y >>> 3] & 1 << (7 & y)) === 0 && (g = !0), this.filter[y >>> 3] |= 1 << (7 & y);
      }
      return g;
    }
    /**
     * Create a filter from a false positive rate.
     * @param {Number} items - Expected number of items.
     * @param {Number} rate - False positive rate (0.0-1.0).
     * @param {Number|String} update
     * @example
     * BloomFilter.fromRate(800000, 0.0001, 'none');
     * @returns {BloomFilter}
     */
    static fromRate(s, i, p) {
      e(Number.isSafeInteger(s) && s > 0, "items", "integer"), e(typeof i == "number" && isFinite(i), "rate", "number"), e(i >= 0 && i <= 1, "rate", "range between 0.1 and 1.0.");
      const g = -1 / m * s * Math.log(i) | 0, S = Math.max(8, g);
      if (p !== -1 && S > n.MAX_BLOOM_FILTER_SIZE * 8)
        throw new Error("Bloom filter size violates policy limits!");
      const y = Math.max(1, S / s * f | 0);
      if (p !== -1 && y > n.MAX_HASH_FUNCS)
        throw new Error("Bloom filter size violates policy limits!");
      return new this(S, y, -1, p);
    }
    /**
     * Ensure the filter is within the size limits.
     * @returns {Boolean}
     */
    isWithinConstraints() {
      return !(this.size > n.MAX_BLOOM_FILTER_SIZE * 8 || this.n > n.MAX_HASH_FUNCS);
    }
    /**
     * Get serialization size.
     * @returns {Number}
     */
    getSize() {
      return c.sizeVarBytes(this.filter) + 9;
    }
    /**
     * Write filter to buffer writer.
     * @param {BufferWriter} bw
     */
    write(s) {
      return s.writeVarBytes(this.filter), s.writeU32(this.n), s.writeU32(this.tweak), s.writeU8(this.update), s;
    }
    /**
     * Inject properties from buffer reader.
     * @private
     * @param {BufferReader} br
     */
    read(s) {
      if (this.filter = s.readVarBytes(), this.size = this.filter.length * 8, this.n = s.readU32(), this.tweak = s.readU32(), this.update = s.readU8(), this.update > 2)
        throw new Error("Invalid update flag.");
      return this;
    }
  }
  n.MAX_BLOOM_FILTER_SIZE = 36e3, n.MAX_HASH_FUNCS = 50, n.flags = {
    /**
     * Never update the filter with outpoints.
     */
    NONE: 0,
    /**
     * Always update the filter with outpoints.
     */
    ALL: 1,
    /**
     * Only update the filter with outpoints if it is
     * "asymmetric" in terms of addresses (pubkey/multisig).
     */
    PUBKEY_ONLY: 2
  }, n.flagsByVal = [
    "NONE",
    "ALL",
    "PUBKEY_ONLY"
  ];
  function u(o, s) {
    return typeof o != "string" ? (e(k.isBuffer(o), "value", "buffer"), o) : (e(typeof s == "string", "enc", "string"), k.from(o, s));
  }
  return q0 = n, q0;
}
/*!
 * rollingfilter.js - rolling bloom filter for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var T0, d6;
function ox() {
  if (d6) return T0;
  d6 = 1;
  const { enforce: e } = dt, { encoding: c } = Bt, l = Fl(), w = k.alloc(0);
  class m {
    /**
     * Create a rolling bloom filter.
     * @constructor
     * @param {Number} items - Expected number of items.
     * @param {Number} rate - False positive rate (0.0-1.0).
     */
    constructor(i, p) {
      this.entries = 0, this.generation = 1, this.n = 0, this.limit = 0, this.size = 0, this.items = 0, this.tweak = 0, this.filter = w, i != null && this.fromRate(i, p);
    }
    /**
     * Inject properties from items and FPR.
     * @private
     * @param {Number} items - Expected number of items.
     * @param {Number} rate - False positive rate (0.0-1.0).
     * @returns {RollingFilter}
     */
    fromRate(i, p) {
      e(Number.isSafeInteger(i) && i > 0, "items", "integer"), e(typeof p == "number" && isFinite(p), "rate", "number"), e(p >= 0 && p <= 1, "rate", "range between 0.1 and 1.0.");
      const g = Math.log(p), S = Math.max(1, Math.min(Math.round(g / Math.log(0.5)), 50)), y = (i + 1) / 2 | 0, b = y * 3;
      let h = -1 * S * b / Math.log(1 - Math.exp(g / S));
      h = Math.ceil(h), i = ((h + 63) / 64 | 0) << 1, i >>>= 0, i = Math.max(1, i);
      const a = Math.random() * 4294967296 >>> 0, E = k.alloc(i * 8, 0);
      return this.n = S, this.limit = y, this.size = h, this.items = i, this.tweak = a, this.filter = E, this;
    }
    /**
     * Instantiate rolling filter from items and FPR.
     * @param {Number} items - Expected number of items.
     * @param {Number} rate - False positive rate (0.0-1.0).
     * @returns {RollingFilter}
     */
    static fromRate(i, p) {
      return new this().fromRate(i, p);
    }
    /**
     * Perform the mumur3 hash on data.
     * @param {Buffer} value
     * @param {Number} seed
     * @returns {Number}
     */
    hash(i, p) {
      return l.tweak(i, p, this.tweak);
    }
    /**
     * Reset the filter.
     */
    reset() {
      this.entries !== 0 && (this.entries = 0, this.generation = 1, this.filter.fill(0));
    }
    /**
     * Add data to the filter.
     * @param {Buffer|String}
     * @param {String?} enc - Can be any of the Buffer object's encodings.
     */
    add(i, p) {
      const g = o(i, p);
      if (this.entries === this.limit) {
        this.entries = 0, this.generation += 1, this.generation === 4 && (this.generation = 1);
        const S = (this.generation & 1) * 4294967295, y = (this.generation >>> 1) * 4294967295;
        for (let b = 0; b < this.items; b += 2) {
          const h = b * 8, a = (b + 1) * 8, E = n(this.filter, h), H = n(this.filter, a), j = E.hi ^ S | H.hi ^ y, G = E.lo ^ S | H.lo ^ y;
          E.hi &= j, E.lo &= G, H.hi &= j, H.lo &= G, u(this.filter, E, h), u(this.filter, H, a);
        }
      }
      this.entries += 1;
      for (let S = 0; S < this.n; S++) {
        const y = this.hash(g, S), b = y & 63, h = (y >>> 6) % this.items, a = (h & -2) * 8, E = (h | 1) * 8, H = b % 8, j = (b - H) / 8;
        this.filter[a + j] &= ~(1 << H), this.filter[a + j] |= (this.generation & 1) << H, this.filter[E + j] &= ~(1 << H), this.filter[E + j] |= this.generation >>> 1 << H;
      }
    }
    /**
     * Test whether data is present in the filter.
     * @param {Buffer|String} value
     * @param {String?} enc - Can be any of the Buffer object's encodings.
     * @returns {Boolean}
     */
    test(i, p) {
      if (this.entries === 0)
        return !1;
      const g = o(i, p);
      for (let S = 0; S < this.n; S++) {
        const y = this.hash(g, S), b = y & 63, h = (y >>> 6) % this.items, a = (h & -2) * 8, E = (h | 1) * 8, H = b % 8, j = (b - H) / 8, G = this.filter[a + j] >>> H & 1, N = this.filter[E + j] >>> H & 1;
        if ((G | N) === 0)
          return !1;
      }
      return !0;
    }
    /**
     * Test whether data is present in the
     * filter and potentially add data.
     * @param {Buffer|String} value
     * @param {String?} enc - Can be any of the Buffer object's encodings.
     * @returns {Boolean} Whether data was added.
     */
    added(i, p) {
      const g = o(i, p);
      return this.test(g) ? !1 : (this.add(g), !0);
    }
  }
  class f {
    constructor(i, p) {
      this.hi = i, this.lo = p;
    }
  }
  function n(s, i) {
    const p = c.readU32(s, i + 4), g = c.readU32(s, i);
    return new f(p, g);
  }
  function u(s, i, p) {
    c.writeU32(s, i.hi, p + 4), c.writeU32(s, i.lo, p);
  }
  function o(s, i) {
    return typeof s != "string" ? (e(k.isBuffer(s), "value", "buffer"), s) : (e(typeof i == "string", "enc", "string"), k.from(s, i));
  }
  return T0 = m, T0;
}
/*!
 * bfilter.js - bloom filters for javascript
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var b6;
function ax() {
  if (b6) return ws;
  b6 = 1;
  const e = sx(), c = ox();
  return ws.BloomFilter = e, ws.RollingFilter = c, ws;
}
var ui = {}, z0, p6;
function Y7() {
  return p6 || (p6 = 1, z0 = [
    k.from(
      "ebd41040e4bb3ec742c9e381d31ef2a41a48b6685c96e7cef3c1df6cd4331c99",
      "hex"
    ),
    k.from(
      "ca42dd41745fd0b81eb902362cf9d8bf719da1bd1b1efc946f5b4c99f42c1b9e",
      "hex"
    ),
    k.from(
      "eb04cf5eb1f39afa762f2bb120f296cba520c1b97db1589565b81cb9a17b7244",
      "hex"
    ),
    k.from(
      "6dc47172e01cbcb0bf62580d895fe2b8ac9ad4f873801e0c10b9c837d21eb177",
      "hex"
    ),
    k.from(
      "16af57a9f676b0ab126095aa5ebadef22ab31119d644ac95cd4b93dbf3f26aeb",
      "hex"
    ),
    k.from(
      "687fa451382278fff0c8b11f8d43d576671c6eb2bceab413fb83d965d06d2ff2",
      "hex"
    ),
    k.from(
      "73c176434f1bc6d5adf45b0e76e727287c8de57616c1e6e6141a2b2cbc7d8e4c",
      "hex"
    ),
    k.from(
      "ff856a2d251dcd88d36656f450126798cfabaade40799c722de4d2b5db36a73a",
      "hex"
    ),
    k.from(
      "a0459b9f63b22559f5fa5d4c6db3f9f72ff19342033578f073bf1d1b46cbb912",
      "hex"
    ),
    k.from(
      "a0234f3bc8527ca5628eec81ad5d69895da5680dc91d1cb8477f33f878b95b0b",
      "hex"
    ),
    k.from(
      "69fac9bd55fb0ac78d53bbee5cf1d597989fd0aaab20a25151bdf1733ee7d122",
      "hex"
    ),
    k.from(
      "d7a7a0fb5d7e2731d771e9484ebcdef71d5f0c3e0a2948782bc83ee0ea699ef4",
      "hex"
    ),
    k.from(
      "a45ede3bbbf09c8ae15c72efc07268d693a21c996fd51e67ca079460fd6d8873",
      "hex"
    ),
    k.from(
      "85a0dd7dd720adb7ff05f83d542b209dc7ff4528f7d677b18389fea5e5c49e86",
      "hex"
    ),
    k.from(
      "18f1fc7f205df8adddeb7fe007dd57e3af375a9c4d8d73546bf4f1fed1e18d35",
      "hex"
    ),
    k.from(
      "e75e72ed9f560eec6eb4800073a43fc3ad19195a392282017895974a99026b6c",
      "hex"
    ),
    k.from(
      "7908b40314c138100b518d0735807ffbfcf8518a0095337105ba386b153dd927",
      "hex"
    ),
    k.from(
      "cecddc905099d8dadfc5b1d209b737cbe2c18cfb2c10c0ff0bcf0d3286fc1aa2",
      "hex"
    ),
    k.from(
      "c3846bf24b9e93ca64274c0ec67c1ecc5e024ffcacd2d74019350e81fe546ae4",
      "hex"
    ),
    k.from(
      "1465fa205397b876faa6f0a9958e5590e40fcc7faa4fb7c2c8677521fb5fb658",
      "hex"
    ),
    k.from(
      "7600295eefe85b9e1fd624db76062aaaae59818a54d2774cd4c0b2c01131e1b3",
      "hex"
    ),
    k.from(
      "3e9099b5015e8f486c00bcea9d111ee721faba355a89bcf1df69561e3dc6325c",
      "hex"
    ),
    k.from(
      "4348a0e9444c78cb265e058d5e8944b4d84f9662bd26db257f8934a443c70161",
      "hex"
    ),
    k.from(
      "7431e5f4c3c1ce4690774f0b61e05440883ba9a01ed00ba6abd7806ed3b118cf",
      "hex"
    ),
    k.from(
      "0f993c8aef97baaf5687140ed59ad1821bb4afacf0aa9a58b5d57a338a3afbcb",
      "hex"
    ),
    k.from(
      "0687260331a72403d909f105e69bcf0d32e1bd2493ffc6d9206d11bcd6770739",
      "hex"
    ),
    k.from(
      "62dd0be9b9f50a163ea0f8e75c053b1eca57ea55c8688f647c6881f2c8357b95",
      "hex"
    ),
    k.from(
      "be6c4da2bbb9ba59b6f3939768374246c3c005993fa98f020d1dedbed48a81d5",
      "hex"
    ),
    k.from(
      "37d51006c512eaab626421f1ec8c92013fc5f82ae98ee533eb4619b8deb4d06c",
      "hex"
    ),
    k.from(
      "8d722f81a9c113c0791df136a2966db26c950a971db46b4199f4ea54b78bfb9f",
      "hex"
    ),
    k.from(
      "9acfab7e43c8d880d06b262a94deeee4b4659989c3d0caf19baf6405e41ab7df",
      "hex"
    ),
    k.from(
      "f1c1b50ae5a20dd8030ec9f6bc24823dd367b5255759b4e71b61fce9f7375d73",
      "hex"
    ),
    k.from(
      "4200f5043ac8590ebb527d209ed1503029fbcbd41ca1b506ec27f15ade7dac69",
      "hex"
    ),
    k.from(
      "0c2cd63df7806fa399ede809116b575bf87989f06518f9808c860503178baf66",
      "hex"
    ),
    k.from(
      "15f0ba00a3ac7af3ac884c072b1011a077bd77c097f40164b2f8598abd83860c",
      "hex"
    ),
    k.from(
      "1793927a0614549789adce2f8f34f7f0b66d0f3ae3a3b84d21ec15dbba4fadc7",
      "hex"
    ),
    k.from(
      "41c923866ab4cad6b7ad578081582e020797a6cbdf4fff78ce8396b38937d7f5",
      "hex"
    ),
    k.from(
      "e3b6a2db2ed7ce48842f7ac53241c7b71d54144bfb40c11f3f1d0b42f5eea12d",
      "hex"
    ),
    k.from(
      "b6191a50d0c3977f7da99bcdaac86a227daeb9679ec70ba3b0c9d92271c170d3",
      "hex"
    ),
    k.from(
      "960adf0063e96356750c2965dd0a0867da0b9cbd6e77714aeafb2349ab393da3",
      "hex"
    ),
    k.from(
      "c0a6f4dc63a24bfdcf54ef2a6a082a0a72de35803e2ff5ff527ae5d87206dfd5",
      "hex"
    ),
    k.from(
      "eaa962c4fa4a6bafebe415196d351ccd888d4f53f3fa8ae6d7c466a94e6042bb",
      "hex"
    ),
    k.from(
      "b478b812250df878635c2aa7ec7d155eaa625ee82916e2cd294361886cd1fbd4",
      "hex"
    ),
    k.from(
      "a4310d50af18a6447190372a86afaf8b951ffb431d837f1e5688b45971ed1557",
      "hex"
    ),
    k.from(
      "4b03f45807ad70f21bfc2cae71c9fde4604c064cf5ffb686bae5dbaad7fdd34c",
      "hex"
    ),
    k.from(
      "5edb7ac43b82a06a8761e8d7be4979ebf2611f7dd79bf91c1c6b566a219ed766",
      "hex"
    ),
    k.from(
      "2399561127a57125de8cefea610ddf2fa078b5c8067f4e828290bfb860e84b3c",
      "hex"
    ),
    k.from(
      "69ddd7ea90bb57c93e135dc85ea6fcd5480b603239bdc454fc758b2a26cf7f79",
      "hex"
    ),
    k.from(
      "6c61dac3a2def031506be036d2a6fe401994fbd13df9c8d466599274c446ec98",
      "hex"
    ),
    k.from(
      "668c83947da63b724bece1743c31a0e6aed0db8ec5b31be377bb784f91b6716f",
      "hex"
    ),
    k.from(
      "f9e67d336c51002ac054c632022d66dda2e7e3fff10ad061ed31d8bbb410cfb2",
      "hex"
    ),
    k.from(
      "bf0feefb9e3a581ad5f9e9db7589985743d261085c4d314f6f5d7259aa421612",
      "hex"
    ),
    k.from(
      "3c5f81fea5fab82c64bfa2eaecafcde8e077fc8620a7cae537163df36edbf378",
      "hex"
    ),
    k.from(
      "cbb522d7b7f127ad6a0113865bdf1cd4102e7d0759af635a7cf4720dc963c53b",
      "hex"
    ),
    k.from(
      "04048028bf1f2864d48f9ad4d83294366a828856553f3b14303f90147f5d40ef",
      "hex"
    ),
    k.from(
      "2530cc8e98321502bad96f9b1fba1b099e2d299e0f4548bb914f363bc0d4531f",
      "hex"
    ),
    k.from(
      "063e4afac491dfd332f3089b8542e94617d893d7fe944e10a7937ee29d9693c0",
      "hex"
    ),
    k.from(
      "136335439334a7698016a0d324de72284e079d7b5220bb8fbd747816eebebaca",
      "hex"
    ),
    k.from(
      "45140b3247eb9cc8c5b4f0d7b53091f73292089e6e5a63e2749dd3aca9198eda",
      "hex"
    ),
    k.from(
      "2ce1cb0bf9d2f9e102993fbe215152c3b2dd0cabde1c68e5319b839154dbb7f5",
      "hex"
    ),
    k.from(
      "568d6905a2c88708a4b3025190edcfedb1974a606a13c6e5290fcb2ae63edab5",
      "hex"
    ),
    k.from(
      "0376ab1d54c5f9803ce4b2e201a0ee7eef7b57b636e8a93c9b8d4860c96f5fa7",
      "hex"
    ),
    k.from(
      "0a81ec5a929777f145904af38d5d509f66b5e2c58fcdb531058b0e17f3f0b41b",
      "hex"
    ),
    k.from(
      "70a73f7f376b60074248904534b11482d5bf0e698ecc498df52577ebf2e93b9a",
      "hex"
    ),
    k.from(
      "bd71fdf6da97e4cf62d1647add2581b07d79adf8397eb4ecba9c5e8488821423",
      "hex"
    ),
    k.from(
      "5c58468d55f58e497e743982d2b50010b6d165374acf83a7d4a32db768c4408e",
      "hex"
    ),
    k.from(
      "bfd88fe1101c41ae3e801bf8be56350ee9bad1a6b9bd515edc5c6d5b8711ac44",
      "hex"
    ),
    k.from(
      "513b2cecb810d4cde5dd85391adfc6c2dd60d87bb736d2b521484aa47a0ebef6",
      "hex"
    ),
    k.from(
      "88497f01602f3154246ae28c4d5aef10f1d87ebb76626f4ae0b7f95ba7968799",
      "hex"
    ),
    k.from(
      "bc104f15a48be709dca542a7e1d4b9df6f054527e802eaa92d595444258afe71",
      "hex"
    ),
    k.from(
      "55926084ec963a64b96e2abe01ce0ba86a64fbfebcc7aab5afc155b37fd76066",
      "hex"
    ),
    k.from(
      "c1b48299aba5208fe9630ace55ca68a03eda5a519c8802a0d3a673be8f8e557d",
      "hex"
    ),
    k.from(
      "9a114025197c5bb95d94e63d55cd43790847b646b23cdf11ada4a00eff15fb48",
      "hex"
    ),
    k.from(
      "edf7ebbca27a2a384d387b7d4010c666e2edb4843e4c29b4ae1d5b9332e6b24d",
      "hex"
    ),
    k.from(
      "fd73dad31c644ff1b43bef0ccdda96710b9cd9875eca7e31707af3e96d522bbd",
      "hex"
    ),
    k.from(
      "3e84ba4342908516e77573c0992f0979ca084e4685681ff195ccba8a229b8a76",
      "hex"
    ),
    k.from(
      "49e7a442acf0ea6287050054b52564b650e4f49e42e348d6aa38e039e957b1c1",
      "hex"
    ),
    k.from(
      "eec5496b988ce98625b934092eec2908bed0b0f316c2d4730c84eaf1f3d34881",
      "hex"
    ),
    k.from(
      "e23d4a036d7b70e9f595b1422079d2b91edfbb1fb651a0633eaa8a9dc5f80703",
      "hex"
    ),
    k.from(
      "9a6ec012e1a7da9dbe34194d478ad7c0db1822fb071df12981496ed104384113",
      "hex"
    ),
    k.from(
      "59769007f7685d0fcd50872f9f95d5755a5b2b457d81f3692b610a98672f0e1b",
      "hex"
    ),
    k.from(
      "dd6936fe21f8f077c123a1a521c12224f72255b73e03a7260693e8a24b0fa389",
      "hex"
    ),
    k.from(
      "b0bfd52bb0d7d9bd92bf5d4dc13da255c02c542f378365ea893911f55e55f23c",
      "hex"
    ),
    k.from(
      "91e2f5788d5810eba7ba58737de1548a8ecacd014598bc0b143e041b17052552",
      "hex"
    ),
    k.from(
      "f356bea244b7a91eb35d53ca9ad7864ace018e2d35d5f8f96ddf68a6f41aa474",
      "hex"
    ),
    k.from(
      "8a866fd1b276b57e578e921c65828a2bed58e9f2f288054134b7f1f4bfc9cc74",
      "hex"
    ),
    k.from(
      "8fe4fb0af93a4d0d67db0bebb23e37c71bf325dcbcdd240ea04daf58b47e1840",
      "hex"
    ),
    k.from(
      "88ef81de202eb018452e43f864725cea5fbd1fc2d9d205730709c5d8b8690f46",
      "hex"
    ),
    k.from(
      "7d05ebb682339f8c9451ee094eebfefa7953a114edb2f44949452fab7d2fc185",
      "hex"
    ),
    k.from(
      "7e37cb8b4c47090cab36551ba6f45db840680fba166a952db100717f43053fc2",
      "hex"
    ),
    k.from(
      "cb3ccbb76031e5e0138f8dd39a23f9de47ffc35e43c1144cea27d46a5ab1cb5f",
      "hex"
    ),
    k.from(
      "31ad6648f8104138c738f39ea4320133393e3a18cc02296ef97c2ac9ef6731d0",
      "hex"
    ),
    k.from(
      "552f7bdcf1a7af9e6ce672017f4f12abf77240c78e761ac203d1d9d20ac89988",
      "hex"
    ),
    k.from(
      "52f0e1c4e58ec629291b60317f074671b85d7ea80d5b07273463534b32b40234",
      "hex"
    ),
    k.from(
      "e793c9b02fd8aa13e21c31228accb08119643b749c898964b1746d46c3d4cbd2",
      "hex"
    ),
    k.from(
      "4ff460d54b9c86dabfbcfc5712e0400d2bed3fbc4d4fbdaa86e06adcd2a9ad7a",
      "hex"
    ),
    k.from(
      "bec94911c2955676db6c0a550986d76e3ba005667c442c9762b4fbb773de228c",
      "hex"
    ),
    k.from(
      "179fbc148a3dd00fd24ea13458cc43bfa7f59c8182d783a513f6ebec100c8924",
      "hex"
    ),
    k.from(
      "3c4fb0b95ab8b30032f432b86f535fe172c185d0fd39865837cf36187fa6f428",
      "hex"
    ),
    k.from(
      "4d2491414cfe956746ec4cefa6cf6f72e28a1329432f9d8a907ac4cb5dadc15a",
      "hex"
    ),
    k.from(
      "5d56499be4d2e08bcfcad08a3e38723d50503bde706948e42f55603019e528ae",
      "hex"
    ),
    k.from(
      "30d0895a9a448a262091635522d1f52010b5867acae12c78ef958fd4f4389f2f",
      "hex"
    ),
    k.from(
      "43df5774b03e7fef5fe40d931a7bedf1bb2e6b42738c4e6d3841103d3aa7f339",
      "hex"
    ),
    k.from(
      "02ed0eb28c14da45165c566791700d6451d7fb56f0b2ab1d3b8eb070e56edff5",
      "hex"
    ),
    k.from(
      "5cc3d78e4e1d5e45547a04e6873e64f90cf9536d1ccc2ef800f355c4c5fd70fd",
      "hex"
    ),
    k.from(
      "49351b903444c185ccdc5c693d24d8555cb208d6a8141307699f4af063199d78",
      "hex"
    ),
    k.from(
      "2a99f5bc1174b73cbb1d620884e01c34e51ccb3978da125f0e33268883bf4158",
      "hex"
    ),
    k.from(
      "6b9c08e86eb0f767cfad65cd98b62149e5494a67f5845e7bd1ed019f27b86bd6",
      "hex"
    ),
    k.from(
      "a1339d33281a0b56e557d3d32b1ce7f9367eb094bd5fa72a7e5004c8ded7cafe",
      "hex"
    ),
    k.from(
      "b676f2eddae8775cd36cb0f63cd1d4603961f49e6265ba013a2f0307b6d0b804",
      "hex"
    ),
    k.from(
      "a040929a02ce53b4acf4f2ffc6981ce4496f755e6d45fe0b2a692bcd52523f36",
      "hex"
    ),
    k.from(
      "44b545aa8a25e65a73ca15dc27fc36d24c1cb9953a066539b11582dc487b4833",
      "hex"
    ),
    k.from(
      "152a402bfcdf2cd548054d2275b39c7fca3ec0978078b0f0ea76e561a6c7433e",
      "hex"
    ),
    k.from(
      "6cc05041e6445e74696c4cfbc9f80f543b7eabbb44b4ce6f787c6a9971c42f17",
      "hex"
    ),
    k.from(
      "56c77128d98c18d91b4cfdffbc25ee9103d4758ea2abad826a90f3457d460eb4",
      "hex"
    ),
    k.from(
      "27995829fe6a7515c1bfe848f9c4761db16c225929257bf40d0894f29ea8baf2",
      "hex"
    ),
    k.from(
      "b7c36231706e81078c367cb896198f1e3208dd926949dd8f5709a410f75b6292",
      "hex"
    ),
    k.from(
      "96bcec06264976f37460779acf28c5a7cfe8a3c0aae11a8ffcee05c0bddf08c6",
      "hex"
    ),
    k.from(
      "ebc5570c29018c4d67b1aa127baf12f703b4611ebc17b7dab5573894179b93fa",
      "hex"
    ),
    k.from(
      "8ecde6884f3d87b1125ba31ac3fcb13d7016de7f57cc904fe1cb97c6ae98196e",
      "hex"
    ),
    k.from(
      "1ba5b2aa8c65401a82960118f80bec4f62304d83cec4713a19c39c011ea46db4",
      "hex"
    ),
    k.from(
      "18ce6cfe7bf14e60b2e347b8dfe868cb31d02ebb3ada271569f50343b46db3a4",
      "hex"
    ),
    k.from(
      "e35d28419ed02025cfa69038cd623962458da5c695fbdea3c22b0bfb25897092",
      "hex"
    ),
    k.from(
      "54455f7129c20b1447c418f997168f24c58fc5023bf5da5be2eb6e1dd8902ed5",
      "hex"
    ),
    k.from(
      "46edc3689046d53a453fb3104ab80dcaec658b2660ea1629dd7e867990648716",
      "hex"
    ),
    k.from(
      "bfff8fd04433487d6a8aa60c1a29767a9fc2bbb05e420f713a13b992891d3893",
      "hex"
    ),
    k.from(
      "d40e9c86cd8fe468c1776959f49ea774fa548684b6c406f3909261f4dce2575c",
      "hex"
    ),
    k.from(
      "0753e940378c1bd5e3836e395daea5cb839e5046f1bd0eae1951cf10fec7c965",
      "hex"
    ),
    k.from(
      "5a885db19c01d912c5759388938cafbbdf031ab2d48e91ee15589b42971d039c",
      "hex"
    ),
    k.from(
      "85666a562ee0be5ce925c1d8890a6f76a87ec16d4d7d5f29ea7419cf20123b69",
      "hex"
    ),
    k.from(
      "3417bb06cc6007da1b961c920b8ab4ce3fad820e4aa30b9acbc4a74ebdcebc65",
      "hex"
    ),
    k.from(
      "2e7bf16cc22485a7bbe2aa8696750761b0ae39be3b2fe9d0cc6d4ef73491425c",
      "hex"
    ),
    k.from(
      "22a2c1f7bded704cc1e701b5f408c310880fe956b5de2a4a44f99c873a25a7c8",
      "hex"
    ),
    k.from(
      "67add1166b020ae61b8f5fc96813c04c2aa589960796865572a3c7e737613dfd",
      "hex"
    ),
    // R3 (Let's Encrypt)
    k.from(
      "96bcec06264976f37460779acf28c5a7cfe8a3c0aae11a8ffcee05c0bddf08c6",
      "hex"
    )
    // ISRG Root X1 (Let's Encrypt)
  ]), z0;
}
/*!
 * protoreader.js - protobufs for bcoin
 * Copyright (c) 2016-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var C0, m6;
function uo() {
  if (m6) return C0;
  m6 = 1;
  const e = dt, c = Vm, l = {
    VARINT: 0,
    FIXED64: 1,
    DELIMITED: 2,
    START_GROUP: 3,
    END_GROUP: 4,
    FIXED32: 5
  };
  class w extends c {
    /**
     * Create a protoreader.
     * @constructor
     */
    constructor(o, s) {
      super(o, s);
    }
    readVarint() {
      const { size: o, value: s } = m(this.data, this.offset);
      return this.offset += o, s;
    }
    readFieldValue(o, s) {
      const i = this.readField(o, s);
      return i ? (e(i.value != null), i.value) : -1;
    }
    readFieldU64(o, s) {
      const i = this.readField(o, s);
      return i ? (e(i.type === l.VARINT || i.type === l.FIXED64), i.value) : -1;
    }
    readFieldU32(o, s) {
      const i = this.readField(o, s);
      return i ? (e(i.type === l.VARINT || i.type === l.FIXED32), i.value) : -1;
    }
    readFieldBytes(o, s) {
      const i = this.readField(o, s);
      return i ? (e(i.data), i.data) : null;
    }
    readFieldString(o, s, i) {
      const p = this.readField(o, s);
      return p ? (e(p.data), p.data.toString(i || "utf8")) : null;
    }
    nextTag() {
      if (this.left() === 0)
        return -1;
      const o = this.readField();
      return this.seek(-o.size), o.tag;
    }
    readField(o, s) {
      const i = this.offset, p = this.readVarint(), g = new f(p);
      if (o != null && g.tag !== o)
        return e(s, "Non-optional field not present."), this.offset = i, null;
      switch (g.type) {
        case l.VARINT:
          g.value = this.readVarint();
          break;
        case l.FIXED64:
          g.value = this.readU64();
          break;
        case l.DELIMITED:
          g.data = this.readVarBytes();
          break;
        case l.START_GROUP:
          for (g.group = []; ; ) {
            const S = this.readField();
            if (S.type === l.END_GROUP)
              break;
            g.group.push(S);
          }
          break;
        case l.END_GROUP:
          e(!1, "Unexpected end group.");
          break;
        case l.FIXED32:
          g.value = this.readU32();
          break;
        default:
          e(!1, "Bad wire type.");
          break;
      }
      return g.size = this.offset - i, g;
    }
  }
  function m(u, o) {
    let s = 0, i = 128, p = 0;
    for (; i & 128; ) {
      if (o >= u.length) {
        s = 0;
        break;
      }
      switch (i = u[o], p) {
        case 0:
        case 1:
        case 2:
        case 3:
          s += (i & 127) << 7 * p;
          break;
        case 4:
          s += (i & 127) * (1 << 7 * p);
          break;
        default:
          s += (i & 127) * Math.pow(2, 7 * p);
          break;
      }
      o += 1, p += 1, e(p < 7, "Number exceeds 2^53-1.");
    }
    return new n(p, s);
  }
  class f {
    constructor(o) {
      this.tag = o >>> 3, this.type = o & 7, this.size = 0, this.value = 0, this.data = null, this.group = null;
    }
  }
  class n {
    constructor(o, s) {
      this.size = o, this.value = s;
    }
  }
  return C0 = w, C0;
}
/*!
 * protowriter.js - protobufs for bcoin
 * Copyright (c) 2016-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var D0, g6;
function ho() {
  if (g6) return D0;
  g6 = 1;
  const e = dt, c = jm, l = {
    VARINT: 0,
    DELIMITED: 2
  };
  class w extends c {
    /**
     * Create a protowriter.
     * @constructor
     */
    constructor() {
      super();
    }
    writeVarint(o) {
      const s = n(o);
      switch (s) {
        case 6: {
          const i = f(o);
          this.writeU32BE(i / 65536 | 0), this.writeU16BE(i & 65535);
          break;
        }
        case 5: {
          const i = f(o);
          this.writeU32BE(i / 256 | 0), this.writeU8(i & 255);
          break;
        }
        case 4: {
          const i = f(o);
          this.writeU32BE(i);
          break;
        }
        case 3: {
          const i = f(o);
          this.writeU16BE(i >> 8), this.writeU8(i & 255);
          break;
        }
        case 2: {
          const i = f(o);
          this.writeU16BE(i);
          break;
        }
        case 1: {
          const i = f(o);
          this.writeU8(i);
          break;
        }
        default: {
          const i = k.allocUnsafe(s);
          m(i, o, 0), this.writeBytes(i);
          break;
        }
      }
    }
    writeFieldVarint(o, s) {
      const i = o << 3 | l.VARINT;
      this.writeVarint(i), this.writeVarint(s);
    }
    writeFieldU64(o, s) {
      e(Number.isSafeInteger(s)), this.writeFieldVarint(o, s);
    }
    writeFieldU32(o, s) {
      e(s <= 4294967295), this.writeFieldVarint(o, s);
    }
    writeFieldBytes(o, s) {
      const i = o << 3 | l.DELIMITED;
      this.writeVarint(i), this.writeVarint(s.length), this.writeBytes(s);
    }
    writeFieldString(o, s, i) {
      typeof s == "string" && (s = k.from(s, i || "utf8")), this.writeFieldBytes(o, s);
    }
  }
  function m(u, o, s) {
    e(Number.isSafeInteger(o), "Number exceeds 2^53-1.");
    do {
      e(s < u.length);
      let i = o & 127;
      o -= o % 128, o /= 128, o !== 0 && (i |= 128), u[s] = i, s += 1;
    } while (o > 0);
    return s;
  }
  function f(u) {
    e(Number.isSafeInteger(u), "Number exceeds 2^53-1.");
    let o = 0, s = 0;
    do {
      e(s < 7);
      let i = u & 127;
      u -= u % 128, u /= 128, u !== 0 && (i |= 128), o *= 256, o += i, s += 1;
    } while (u > 0);
    return o;
  }
  function n(u) {
    e(Number.isSafeInteger(u), "Number exceeds 2^53-1.");
    let o = 0;
    do
      u -= u % 128, u /= 128, o += 1;
    while (u > 0);
    return o;
  }
  return D0 = w, D0;
}
/*!
 * paymentdetails.js - bip70 paymentdetails for bcoin
 * Copyright (c) 2016-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var U0, x6;
function Ll() {
  if (x6) return U0;
  x6 = 1;
  const e = dt, c = uo(), l = ho();
  class w {
    /**
     * Create payment details.
     * @constructor
     * @param {Object?} options
     * @property {String|null} network
     * @property {Object[]} outputs
     * @property {Number} time
     * @property {Number} expires
     * @property {String|null} memo
     * @property {String|null} paymentUrl
     * @property {Buffer|null} merchantData
     */
    constructor(f) {
      this.network = null, this.outputs = [], this.time = Math.floor(Date.now() / 1e3), this.expires = -1, this.memo = null, this.paymentUrl = null, this.merchantData = null, f && this.fromOptions(f);
    }
    /**
     * Inject properties from options.
     * @private
     * @param {Object} options
     * @returns {PaymentDetails}
     */
    fromOptions(f) {
      if (f.network != null && (e(typeof f.network == "string"), this.network = f.network), f.outputs) {
        e(Array.isArray(f.outputs));
        for (const n of f.outputs)
          e(n && typeof n == "object"), e(Number.isSafeInteger(n.value) && n.value >= 0), e(k.isBuffer(n.script)), this.outputs.push(n);
      }
      return f.time != null && (e(Number.isSafeInteger(f.time)), this.time = f.time), f.expires != null && (e(Number.isSafeInteger(f.expires)), this.expires = f.expires), f.memo != null && (e(typeof f.memo == "string"), this.memo = f.memo), f.paymentUrl != null && (e(typeof f.paymentUrl == "string"), this.paymentUrl = f.paymentUrl), f.merchantData && this.setData(f.merchantData), this;
    }
    /**
     * Instantiate payment details from options.
     * @param {Object} options
     * @returns {PaymentDetails}
     */
    static fromOptions(f) {
      return new w().fromOptions(f);
    }
    /**
     * Test whether the payment is expired.
     * @returns {Boolean}
     */
    isExpired() {
      return this.expires === -1 ? !1 : Math.floor(Date.now() / 1e3) > this.expires;
    }
    /**
     * Set payment details.
     * @param {Object} data
     * @param {String?} enc
     */
    setData(f, n) {
      if (f == null || k.isBuffer(f)) {
        this.merchantData = f;
        return;
      }
      if (typeof f != "string") {
        e(!n || n === "json"), this.merchantData = k.from(JSON.stringify(f), "utf8");
        return;
      }
      this.merchantData = k.from(f, n);
    }
    /**
     * Get payment details.
     * @param {String?} enc
     * @returns {String|Object|null}
     */
    getData(f) {
      let n = this.merchantData;
      if (!n)
        return null;
      if (!f)
        return n;
      if (f === "json") {
        n = n.toString("utf8");
        try {
          n = JSON.parse(n);
        } catch {
          return null;
        }
        return n;
      }
      return n.toString(f);
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     * @returns {PaymentDetails}
     */
    fromRaw(f) {
      const n = new c(f);
      for (this.network = n.readFieldString(1, !0); n.nextTag() === 2; ) {
        const u = new c(n.readFieldBytes(2)), o = {
          value: u.readFieldU64(1, !0),
          script: u.readFieldBytes(2, !0)
        };
        this.outputs.push(o);
      }
      return this.time = n.readFieldU64(3), this.expires = n.readFieldU64(4, !0), this.memo = n.readFieldString(5, !0), this.paymentUrl = n.readFieldString(6, !0), this.merchantData = n.readFieldBytes(7, !0), this;
    }
    /**
     * Instantiate payment details from serialized data.
     * @param {Buffer} data
     * @returns {PaymentDetails}
     */
    static fromRaw(f, n) {
      return typeof f == "string" && (f = k.from(f, n)), new w().fromRaw(f);
    }
    /**
     * Serialize the payment details (protobuf).
     * @returns {Buffer}
     */
    toRaw() {
      const f = new l();
      this.network != null && f.writeFieldString(1, this.network);
      for (const n of this.outputs) {
        const u = new l();
        u.writeFieldU64(1, n.value), u.writeFieldBytes(2, n.script), f.writeFieldBytes(2, u.render());
      }
      return f.writeFieldU64(3, this.time), this.expires !== -1 && f.writeFieldU64(4, this.expires), this.memo != null && f.writeFieldString(5, this.memo), this.paymentUrl != null && f.writeFieldString(6, this.paymentUrl), this.merchantData && f.writeFieldString(7, this.merchantData), f.render();
    }
  }
  return U0 = w, U0;
}
/*!
 * payment.js - bip70 payment for bcoin
 * Copyright (c) 2016-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var F0, w6;
function X7() {
  if (w6) return F0;
  w6 = 1;
  const e = dt, c = uo(), l = ho(), { setData: w, getData: m } = Ll().prototype;
  class f {
    /**
     * Create a payment.
     * @constructor
     * @param {Object?} options
     * @property {Buffer} merchantData
     * @property {Buffer[]} transactions
     * @property {Buffer[]} refundTo
     * @property {String|null} memo
     */
    constructor(u) {
      this.merchantData = null, this.transactions = [], this.refundTo = [], this.memo = null, u && this.fromOptions(u);
    }
    /**
     * Inject properties from options.
     * @private
     * @param {Object} options
     * @returns {Payment}
     */
    fromOptions(u) {
      if (u.merchantData && this.setData(u.merchantData), u.transactions) {
        e(Array.isArray(u.transactions));
        for (const o of u.transactions)
          e(k.isBuffer(o)), this.transactions.push(o);
      }
      if (u.refundTo) {
        e(Array.isArray(u.refundTo));
        for (const o of u.refundTo)
          e(o && typeof o == "object"), e(Number.isSafeInteger(o.value) && o.value >= 0), e(k.isBuffer(o.script)), this.refundTo.push(o);
      }
      return u.memo != null && (e(typeof u.memo == "string"), this.memo = u.memo), this;
    }
    /**
     * Instantiate payment from options.
     * @param {Object} options
     * @returns {Payment}
     */
    static fromOptions(u) {
      return new f().fromOptions(u);
    }
    /**
     * Set payment details.
     * @param {Object} data
     * @param {String?} enc
     */
    setData(u, o) {
      return w.call(this, u, o);
    }
    /**
     * Get payment details.
     * @param {String?} enc
     * @returns {String|Object|null}
     */
    getData(u) {
      return m.call(this, u);
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     * @returns {Payment}
     */
    fromRaw(u) {
      const o = new c(u);
      for (this.merchantData = o.readFieldBytes(1, !0); o.nextTag() === 2; ) {
        const s = o.readFieldBytes(2);
        this.transactions.push(s);
      }
      for (; o.nextTag() === 3; ) {
        const s = new c(o.readFieldBytes(3)), i = {
          value: s.readFieldU64(1, !0),
          script: s.readFieldBytes(2, !0)
        };
        this.refundTo.push(i);
      }
      return this.memo = o.readFieldString(4, !0), this;
    }
    /**
     * Instantiate payment from serialized data.
     * @param {Buffer} data
     * @returns {Payment}
     */
    static fromRaw(u, o) {
      return typeof u == "string" && (u = k.from(u, o)), new f().fromRaw(u);
    }
    /**
     * Serialize the payment (protobuf).
     * @returns {Buffer}
     */
    toRaw() {
      const u = new l();
      this.merchantData && u.writeFieldBytes(1, this.merchantData);
      for (const o of this.transactions)
        u.writeFieldBytes(2, o);
      for (const o of this.refundTo) {
        const s = new l();
        s.writeFieldU64(1, o.value), s.writeFieldBytes(2, o.script), u.writeFieldBytes(3, s.render());
      }
      return this.memo != null && u.writeFieldString(4, this.memo), u.render();
    }
  }
  return F0 = f, F0;
}
/*!
 * paymentack.js - bip70 paymentack for bcoin
 * Copyright (c) 2016-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var H0, y6;
function fx() {
  if (y6) return H0;
  y6 = 1;
  const e = dt, c = uo(), l = ho(), w = X7();
  class m {
    /**
     * Create a payment ack.
     * @constructor
     * @param {Object?} options
     * @property {Payment} payment
     * @property {String|null} memo
     */
    constructor(n) {
      this.payment = new w(), this.memo = null, n && this.fromOptions(n);
    }
    /**
     * Inject properties from options.
     * @private
     * @param {Object} options
     * @returns {PaymentACK}
     */
    fromOptions(n) {
      return n.payment && this.payment.fromOptions(n.payment), n.memo != null && (e(typeof n.memo == "string"), this.memo = n.memo), this;
    }
    /**
     * Instantiate payment ack from options.
     * @param {Object} options
     * @returns {PaymentACK}
     */
    static fromOptions(n) {
      return new m().fromOptions(n);
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     * @returns {PaymentACK}
     */
    fromRaw(n) {
      const u = new c(n);
      return this.payment.fromRaw(u.readFieldBytes(1)), this.memo = u.readFieldString(2, !0), this;
    }
    /**
     * Instantiate payment ack from serialized data.
     * @param {Buffer} data
     * @returns {PaymentACK}
     */
    static fromRaw(n, u) {
      return typeof n == "string" && (n = k.from(n, u)), new m().fromRaw(n);
    }
    /**
     * Serialize the payment ack (protobuf).
     * @returns {Buffer}
     */
    toRaw() {
      const n = new l();
      return n.writeFieldBytes(1, this.payment.toRaw()), this.memo != null && n.writeFieldString(2, this.memo), n.render();
    }
  }
  return H0 = m, H0;
}
var L0 = {}, K0 = {};
/*!
 * asn1.js - asn1 parsing for bcoin
 * Copyright (c) 2016-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 *
 * Parts of this software are based on asn1.js.
 * https://github.com/indutny/asn1.js
 *
 * Copyright Fedor Indutny, 2013.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 */
var v6;
function cx() {
  return v6 || (v6 = 1, function(e) {
    const c = Bt, l = e;
    l.readTag = function(m) {
      let f = m.readU8();
      const n = (f & 32) === 0;
      if ((f & 31) === 31) {
        let u = f;
        for (f = 0; (u & 128) === 128; )
          u = m.readU8(), f <<= 7, f |= u & 127;
      } else
        f &= 31;
      return {
        type: f,
        primitive: n,
        size: l.readSize(m, n)
      };
    }, l.readSize = function(m, f) {
      let n = m.readU8();
      if (!f && n === 128)
        throw new Error("Indefinite size.");
      if ((n & 128) === 0)
        return n;
      const u = n & 127;
      if (u > 3)
        throw new Error("Length octet is too long.");
      n = 0;
      for (let o = 0; o < u; o++)
        n <<= 8, n |= m.readU8();
      return n;
    }, l.readSeq = function(m) {
      const f = l.implicit(m, 16);
      return m.readBytes(f.size);
    }, l.implicit = function(m, f) {
      const n = l.readTag(m);
      if (n.type !== f)
        throw new Error(`Unexpected tag: ${n.type}.`);
      return n;
    }, l.explicit = function(m, f) {
      const n = m.offset;
      return l.readTag(m).type !== f ? (m.offset = n, !1) : !0;
    }, l.seq = function(m) {
      return c.read(l.readSeq(m), !0);
    }, l.readInt = function(m, f) {
      const n = l.implicit(m, 2), u = m.readBytes(n.size);
      return f ? u.readUIntBE(0, u.length) : u;
    }, l.readExplicitInt = function(m, f, n) {
      return l.explicit(m, f) ? l.readInt(m, n) : -1;
    }, l.readBitstr = function(m) {
      const f = l.implicit(m, 3), n = m.readBytes(f.size);
      return l.alignBitstr(n);
    }, l.readString = function(m) {
      const f = l.readTag(m);
      switch (f.type) {
        case 3: {
          const n = m.readBytes(f.size);
          return l.alignBitstr(n).toString("utf8");
        }
        // Note:
        // Fuck all these.
        case 4:
        // octstr
        case 18:
        // numstr
        case 19:
        // prinstr
        case 20:
        // t61str
        case 21:
        // videostr
        case 22:
        // ia5str
        case 25:
        // graphstr
        case 12:
        // utf8str
        case 26:
        // iso646str
        case 27:
        // genstr
        case 28:
        // unistr
        case 29:
        // charstr
        case 30:
          return m.readString(f.size, "utf8");
        default:
          throw new Error(`Unexpected tag: ${f.type}.`);
      }
    }, l.alignBitstr = function(m) {
      const f = m[0], n = (m.length - 1) * 8 - f, u = m.slice(1), o = 8 - n % 8;
      if (o === 8 || u.length === 0)
        return u;
      const s = k.allocUnsafe(u.length);
      s[0] = u[0] >>> o;
      for (let i = 1; i < u.length; i++)
        s[i] = u[i - 1] << 8 - o, s[i] |= u[i] >>> o;
      return s;
    }, l.readCert = function(m) {
      const f = m;
      return f.start(), m = l.seq(f), {
        tbs: l.readTBS(m),
        sigAlg: l.readAlgIdent(m),
        sig: l.readBitstr(m),
        raw: f.endData(!0)
      };
    }, l.readTBS = function(m) {
      const f = m;
      return f.start(), m = l.seq(f), {
        version: l.readExplicitInt(m, 0, !0),
        serial: l.readInt(m),
        sig: l.readAlgIdent(m),
        issuer: l.readName(m),
        validity: l.readValidity(m),
        subject: l.readName(m),
        pubkey: l.readPubkey(m),
        raw: f.endData(!0)
      };
    }, l.readPubkey = function(m) {
      return m = l.seq(m), {
        alg: l.readAlgIdent(m),
        pubkey: l.readBitstr(m)
      };
    }, l.readName = function(m) {
      const f = [];
      for (m = l.seq(m); m.left(); )
        l.implicit(m, 17), l.implicit(m, 16), f.push({
          type: l.readOID(m),
          value: l.readString(m)
        });
      return f;
    }, l.readValidity = function(m) {
      return m = l.seq(m), {
        notBefore: l.readTime(m),
        notAfter: l.readTime(m)
      };
    }, l.readTime = function(m) {
      const f = l.readTag(m), n = m.readString(f.size, "ascii");
      let u, o, s, i, p, g;
      switch (f.type) {
        case 23:
          u = n.slice(0, 2) | 0, o = n.slice(2, 4) | 0, s = n.slice(4, 6) | 0, i = n.slice(6, 8) | 0, p = n.slice(8, 10) | 0, g = n.slice(10, 12) | 0, u < 70 ? u = 2e3 + u : u = 1900 + u;
          break;
        case 24:
          u = n.slice(0, 4) | 0, o = n.slice(4, 6) | 0, s = n.slice(6, 8) | 0, i = n.slice(8, 10) | 0, p = n.slice(10, 12) | 0, g = n.slice(12, 14) | 0;
          break;
        default:
          throw new Error(`Unexpected tag: ${f.type}.`);
      }
      return Date.UTC(u, o - 1, s, i, p, g, 0) / 1e3;
    }, l.readOID = function(m) {
      const f = l.implicit(m, 6), n = m.readBytes(f.size);
      return l.formatOID(n);
    }, l.formatOID = function(m) {
      const f = c.read(m), n = [];
      let u = 0, o = 0;
      for (; f.left(); )
        o = f.readU8(), u <<= 7, u |= o & 127, (o & 128) === 0 && (n.push(u), u = 0);
      o & 128 && n.push(u);
      const s = n[0] / 40 | 0, i = n[0] % 40;
      return [s, i].concat(n.slice(1)).join(".");
    }, l.readAlgIdent = function(m) {
      let f = null;
      m = l.seq(m);
      const n = l.readOID(m);
      if (m.left() > 0) {
        const u = l.readTag(m);
        f = m.readBytes(u.size), f.length === 0 && (f = null);
      }
      return {
        alg: n,
        params: f
      };
    }, l.readRSAPublic = function(m) {
      return m = l.seq(m), {
        modulus: l.readInt(m),
        publicExponent: l.readInt(m)
      };
    }, l.readRSAPrivate = function(m) {
      return m = l.seq(m), {
        version: l.readInt(m, !0),
        modulus: l.readInt(m),
        publicExponent: l.readInt(m),
        privateExponent: l.readInt(m),
        prime1: l.readInt(m),
        prime2: l.readInt(m),
        exponent1: l.readInt(m),
        exponent2: l.readInt(m),
        coefficient: l.readInt(m)
      };
    }, l.parseRSAPublic = function(m) {
      return l.readRSAPublic(c.read(m, !0));
    }, l.parseRSAPrivate = function(m) {
      return l.readRSAPrivate(c.read(m, !0));
    }, l.parseCert = function(m) {
      return l.readCert(c.read(m, !0));
    }, l.parseTBS = function(m) {
      return l.readTBS(c.read(m, !0));
    };
  }(K0)), K0;
}
var ys = {};
/*!
 * pk.js - public key algorithms for bcoin
 * Copyright (c) 2016-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var S6;
function ux() {
  if (S6) return ys;
  S6 = 1;
  const e = dt, c = j7(), l = br(), w = Hl(), m = $i(), f = $7(), n = D7(), u = U7(), o = F7(), s = K7();
  ys.verify = function(S, y, b, h) {
    const a = i(S);
    if (!a)
      return !1;
    switch (h.alg) {
      case "rsa":
        return f.verify(a, a.digest(y), b, h.data);
      case "ecdsa": {
        const E = p(h.curve);
        return E ? E.verifyDER(a.digest(y), b, h.data) : !1;
      }
      default:
        throw new Error(`Unsupported algorithm: ${h.alg}.`);
    }
  }, ys.sign = function(S, y, b) {
    const h = i(S);
    if (!h)
      throw new Error(`Unsupported hash algorithm: ${S}.`);
    switch (b.alg) {
      case "rsa":
        return f.sign(h, h.digest(y), b.data);
      case "ecdsa": {
        const a = p(b.curve);
        if (!a)
          throw new Error(`Unsupported curve: ${b.curve}.`);
        return a.signDER(h.digest(y), b.data);
      }
      default:
        throw new Error(`Unsupported algorithm: ${b.alg}.`);
    }
  };
  function i(g) {
    switch (e(typeof g == "string"), g) {
      case "sha224":
        return c;
      case "sha256":
        return l;
      case "sha384":
        return w;
      case "sha512":
        return m;
      default:
        return null;
    }
  }
  function p(g) {
    switch (e(typeof g == "string"), g) {
      case "p224":
        return n;
      case "p256":
        return u;
      case "p384":
        return o;
      case "p521":
        return s;
      default:
        return null;
    }
  }
  return ys;
}
/*!
 * x509.js - x509 handling for bcoin
 * Copyright (c) 2016-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var E6;
function G7() {
  return E6 || (E6 = 1, function(e) {
    const c = dt, l = br(), w = cx(), m = ux(), f = Y7(), n = e;
    n.trusted = /* @__PURE__ */ new Set(), n.allowUntrusted = !1, n.oid = {
      "1.2.840.10040.4.1": { key: "dsa", hash: null },
      "1.2.840.10040.4.2": { key: "dsa", hash: null },
      "1.2.840.10040.4.3": { key: "dsa", hash: "sha1" },
      "1.2.840.113549.1.1.1": { key: "rsa", hash: null },
      "1.2.840.113549.1.1.2": { key: "rsa", hash: "md2" },
      "1.2.840.113549.1.1.3": { key: "rsa", hash: "md4" },
      "1.2.840.113549.1.1.4": { key: "rsa", hash: "md5" },
      "1.2.840.113549.1.1.5": { key: "rsa", hash: "sha1" },
      "1.2.840.113549.1.1.11": { key: "rsa", hash: "sha256" },
      "1.2.840.113549.1.1.12": { key: "rsa", hash: "sha384" },
      "1.2.840.113549.1.1.13": { key: "rsa", hash: "sha512" },
      "1.2.840.113549.1.1.14": { key: "rsa", hash: "sha224" },
      "2.16.840.1.101.3.4.2.8": { key: "rsa", hash: "sha3-256" },
      "2.16.840.1.101.3.4.2.9": { key: "rsa", hash: "sha3-384" },
      "2.16.840.1.101.3.4.2.10": { key: "rsa", hash: "sha3-512" },
      "1.2.840.10045.2.1": { key: "ecdsa", hash: null },
      "1.2.840.10045.4.1": { key: "ecdsa", hash: "sha1" },
      "1.2.840.10045.4.3.1": { key: "ecdsa", hash: "sha224" },
      "1.2.840.10045.4.3.2": { key: "ecdsa", hash: "sha256" },
      "1.2.840.10045.4.3.3": { key: "ecdsa", hash: "sha384" },
      "1.2.840.10045.4.3.4": { key: "ecdsa", hash: "sha512" }
    }, n.curves = {
      "1.3.132.0.33": "p224",
      "1.2.840.10045.3.1.7": "p256",
      "1.3.132.0.34": "p384",
      "1.3.132.0.35": "p521"
    }, n.getSubjectOID = function(o, s) {
      const i = o.tbs.subject;
      for (const p of i)
        if (p.type === s)
          return p.value;
      return null;
    }, n.getCAName = function(o) {
      return n.getSubjectOID(o, "2.5.4.3") || n.getSubjectOID(o, "2.5.4.11") || n.getSubjectOID(o, "2.5.4.10") || "Unknown";
    }, n.isTrusted = function(o) {
      const i = l.digest(o.raw).toString("hex");
      return n.trusted.has(i);
    }, n.setTrust = function(o) {
      c(Array.isArray(o), "Certs must be an array.");
      for (const s of o) {
        c(k.isBuffer(s), "Certificates must be DER.");
        const i = n.parse(s), g = l.digest(i.raw).toString("hex");
        n.trusted.add(g);
      }
    }, n.setFingerprints = function(o) {
      c(Array.isArray(o), "Certs must be an array.");
      for (const s of o) {
        c(k.isBuffer(s), "Fingerprint must be a buffer."), c(s.length === 32, "Fingerprint must be a sha256 hash.");
        const i = s.toString("hex");
        n.trusted.add(i);
      }
    }, n.getKeyAlgorithm = function(o) {
      const s = o.tbs.pubkey.alg.alg, i = n.oid[s];
      if (!i)
        throw new Error(`Unknown key algorithm: ${s}.`);
      return i;
    }, n.getSigAlgorithm = function(o) {
      const s = o.sigAlg.alg, i = n.oid[s];
      if (!i || !i.hash)
        throw new Error(`Unknown signature algorithm: ${s}.`);
      return i;
    }, n.getCurve = function(o) {
      let s;
      try {
        s = w.formatOID(o);
      } catch {
        throw new Error("Could not parse curve OID.");
      }
      const i = n.curves[s];
      if (!i)
        throw new Error(`Unknown ECDSA curve: ${s}.`);
      return i;
    }, n.parse = function(o) {
      try {
        return w.parseCert(o);
      } catch {
        throw new Error("Could not parse DER certificate.");
      }
    }, n.getPublicKey = function(o) {
      const s = n.getKeyAlgorithm(o), i = o.tbs.pubkey.pubkey, p = o.tbs.pubkey.alg.params;
      let g = null;
      if (s.key === "ecdsa") {
        if (!p)
          throw new Error("No curve selected for ECDSA (cert).");
        g = n.getCurve(p);
      }
      return {
        alg: s.key,
        data: i,
        params: p,
        curve: g
      };
    }, n.verifyTime = function(o) {
      const s = o.tbs.validity, i = Math.floor(Date.now() / 1e3);
      return i > s.notBefore && i < s.notAfter;
    }, n.getSigningKey = function(o, s) {
      c(s.length !== 0, "No chain available.");
      const i = n.parse(s[0]), p = n.getPublicKey(i);
      return {
        alg: p.alg,
        data: o,
        params: p.params,
        curve: p.curve
      };
    }, n.signSubject = function(o, s, i, p) {
      const g = n.getSigningKey(i, p);
      return m.sign(o, s, g);
    }, n.getVerifyKey = function(o) {
      if (o.length === 0)
        throw new Error("No verify key available (cert chain).");
      const s = n.parse(o[0]);
      return n.getPublicKey(s);
    }, n.verifySubject = function(o, s, i, p) {
      const g = n.getVerifyKey(p);
      return m.verify(o, s, i, g);
    }, n.parseChain = function(o) {
      const s = [];
      for (const i of o) {
        const p = n.parse(i);
        s.push(p);
      }
      return s;
    }, n.verifyTimes = function(o) {
      for (const s of o)
        if (!n.verifyTime(s))
          return !1;
      return !0;
    }, n.verifyTrust = function(o) {
      if (n.allowUntrusted)
        return !0;
      for (const s of o)
        if (n.isTrusted(s))
          return !0;
      return !1;
    }, n.verifyChain = function(o) {
      const s = n.parseChain(o);
      if (!n.verifyTimes(s))
        throw new Error("Invalid certificate times.");
      for (let i = 1; i < s.length; i++) {
        const p = s[i - 1], g = s[i], S = n.getSigAlgorithm(p), y = n.getPublicKey(g), b = p.tbs.raw, h = p.sig;
        if (!m.verify(S.hash, b, h, y))
          throw new Error(`${S.key} verification failed for chain.`);
      }
      if (!n.verifyTrust(s))
        throw new Error("Certificate chain is untrusted.");
      return !0;
    }, n.setFingerprints(f);
  }(L0)), L0;
}
/*!
 * paymentrequest.js - bip70 paymentrequest for bcoin
 * Copyright (c) 2016-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var V0, I6;
function hx() {
  if (I6) return V0;
  I6 = 1;
  const e = dt, c = uo(), l = ho(), w = Ll(), m = G7();
  class f {
    /**
     * Create a payment request.
     * @constructor
     * @param {Object?} options
     * @property {Number} version
     * @property {String|null} pkiType
     * @property {Buffer|null} pkiData
     * @property {PaymentDetails} paymentDetails
     * @property {Buffer|null} signature
     */
    constructor(s) {
      this.version = -1, this.pkiType = null, this.pkiData = null, this.paymentDetails = new w(), this.signature = null, s && this.fromOptions(s);
    }
    /**
     * Inject properties from options.
     * @private
     * @param {Object} options
     * @returns {PaymentRequest}
     */
    fromOptions(s) {
      return s.version != null && (e((s.version | 0) === s.version), this.version = s.version), s.pkiType != null && (e(typeof s.pkiType == "string"), this.pkiType = s.pkiType), s.pkiData && (e(k.isBuffer(s.pkiData)), this.pkiData = s.pkiData), s.paymentDetails && this.paymentDetails.fromOptions(s.paymentDetails), s.signature && (e(k.isBuffer(s.signature)), this.signature = s.signature), s.chain && this.setChain(s.chain), this;
    }
    /**
     * Instantiate payment request from options.
     * @param {Object} options
     * @returns {PaymentRequest}
     */
    static fromOptions(s) {
      return new f().fromOptions(s);
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     * @returns {PaymentRequest}
     */
    fromRaw(s) {
      const i = new c(s);
      return this.version = i.readFieldU32(1, !0), this.pkiType = i.readFieldString(2, !0), this.pkiData = i.readFieldBytes(3, !0), this.paymentDetails.fromRaw(i.readFieldBytes(4)), this.signature = i.readFieldBytes(5, !0), this;
    }
    /**
     * Instantiate payment request from serialized data.
     * @param {Buffer} data
     * @returns {PaymentRequest}
     */
    static fromRaw(s, i) {
      return typeof s == "string" && (s = k.from(s, i)), new f().fromRaw(s);
    }
    /**
     * Serialize the payment request (protobuf).
     * @returns {Buffer}
     */
    toRaw() {
      const s = new l();
      return this.version !== -1 && s.writeFieldU32(1, this.version), this.pkiType != null && s.writeFieldString(2, this.pkiType), this.pkiData && s.writeFieldBytes(3, this.pkiData), s.writeFieldBytes(4, this.paymentDetails.toRaw()), this.signature && s.writeFieldBytes(5, this.signature), s.render();
    }
    /**
     * Get payment request signature algorithm.
     * @returns {Object|null}
     */
    getAlgorithm() {
      if (!this.pkiType)
        throw new Error("No PKI type available.");
      const s = this.pkiType.split("+");
      if (s.length !== 2)
        throw new Error("Could not parse PKI algorithm.");
      if (s[0] !== "x509")
        throw new Error(`Unknown PKI type: ${s[0]}.`);
      if (s[1] !== "sha1" && s[1] !== "sha256")
        throw new Error(`Unknown hash algorithm: ${s[1]}.`);
      return new n(s[0], s[1]);
    }
    /**
     * Serialize payment request for sighash.
     * @returns {Buffer}
     */
    signatureData() {
      const s = this.signature;
      this.signature = k.alloc(0);
      const i = this.toRaw();
      return this.signature = s, i;
    }
    /**
     * Set x509 certificate chain.
     * @param {Buffer[]} chain
     */
    setChain(s) {
      const i = new l();
      e(Array.isArray(s), "Chain must be an array.");
      for (const p of s)
        e(k.isBuffer(p), "Certificates must be DER."), i.writeFieldBytes(1, p);
      this.pkiData = i.render();
    }
    /**
     * Get x509 certificate chain.
     * @returns {Buffer[]}
     */
    getChain() {
      const s = [];
      if (!this.pkiData)
        return s;
      const i = new c(this.pkiData);
      for (; i.nextTag() === 1; )
        s.push(i.readFieldBytes(1));
      return s;
    }
    /**
     * Sign payment request (chain must be set).
     * @param {Buffer} key
     * @param {Buffer[]?} certs
     */
    sign(s, i) {
      i && this.setChain(i), this.pkiType || (this.pkiType = "x509+sha256");
      const p = this.getAlgorithm(), g = this.signatureData(), S = this.getChain();
      this.signature = m.signSubject(p.hash, g, s, S);
    }
    /**
     * Verify payment request signature.
     * @returns {Boolean}
     */
    verify() {
      if (!this.pkiType || this.pkiType === "none" || !this.signature)
        return !1;
      let s;
      try {
        s = this.getAlgorithm();
      } catch {
        return !1;
      }
      const i = this.signatureData(), p = this.signature, g = this.getChain();
      try {
        return m.verifySubject(s.hash, i, p, g);
      } catch {
        return !1;
      }
    }
    /**
     * Verify x509 certificate chain.
     * @returns {Boolean}
     */
    verifyChain() {
      if (!this.pkiType || this.pkiType === "none")
        return !1;
      try {
        return m.verifyChain(this.getChain());
      } catch {
        return !1;
      }
    }
    /**
     * Get root certificate authority.
     * @returns {Object|null}
     */
    getCA() {
      if (!this.pkiType || this.pkiType === "none")
        throw new Error("No CA found (pkiType).");
      const s = this.getChain();
      if (s.length === 0)
        throw new Error("No CA found (chain).");
      const i = m.parse(s[s.length - 1]);
      return new u(i);
    }
  }
  class n {
    /**
     * Create an algorithm.
     * @constructor
     * @ignore
     */
    constructor(s, i) {
      this.key = s, this.hash = i;
    }
  }
  class u {
    /**
     * Create a CA.
     * @constructor
     * @ignore
     */
    constructor(s) {
      this.name = m.getCAName(s), this.trusted = m.isTrusted(s), this.cert = s;
    }
  }
  return V0 = f, V0;
}
/*!
 * b70.js - bip70 for bcoin
 * Copyright (c) 2016-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var A6;
function lx() {
  return A6 || (A6 = 1, ui.certs = Y7(), ui.PaymentACK = fx(), ui.PaymentDetails = Ll(), ui.Payment = X7(), ui.PaymentRequest = hx(), ui.x509 = G7()), ui;
}
var $0 = {}, dx = "@hansekontor/checkout-components", bx = "1.3.0", O6 = {
  name: dx,
  version: bx
};
/*!
 * pkg.js - package constants
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * Copyright (c) 2018, bcash developers.
 * https://github.com/bcoin-org/bcash
 */
var _6;
function px() {
  return _6 || (_6 = 1, function(e) {
    const c = e;
    c.name = O6.name, c.core = "bcash", c.organization = "badger-cash", c.currency = "bitcoin cash", c.unit = "bch", c.base = "satoshi", c.cfg = `${c.core}.conf`, c.url = `https://github.com/${c.organization}/${c.name}`, c.version = O6.version;
  }($0)), $0;
}
/*!
 * bcoin.js - a javascript bitcoin library.
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License).
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var R6;
function mx() {
  return R6 || (R6 = 1, function(e, c) {
    const l = c;
    l.set = function(m) {
      return l.Network.set(m), l;
    }, l.btc = Ng(), l.Amount = Di(), l.URI = O7(), l.coins = qg(), l.Coins = Nl(), l.CoinEntry = so(), l.CoinView = ql(), l.hd = Vg(), l.HDPrivateKey = M7(), l.HDPublicKey = Cl(), e.exports.Mnemonic = zl(), l.primitives = Yg(), l.Address = Li(), l.Block = Ul(), l.Coin = no(), l.Headers = ns(), l.Input = co(), l.InvItem = fo(), l.KeyRing = q7(), l.MerkleBlock = Dl(), l.MTX = T7(), l.Outpoint = vn(), l.Output = Vi(), l.TX = is(), l.protocol = Gg(), l.consensus = Xt(), l.Network = Tr(), l.networks = El(), l.policy = yn(), l.script = Jg(), l.Opcode = Ml(), l.Script = si(), l.ScriptNum = Ki(), l.SigCache = z7(), l.Stack = ro(), l.utils = cr(), l.util = pr(), l.bcrypto = nx(), l.bfilter = ax(), l.b70 = lx(), l.pkg = px();
  }(ps, ps.exports)), ps.exports;
}
var gx = mx(), ss = /* @__PURE__ */ Ym(gx);
class xx {
  balances;
  utxos;
  slp;
  parsedTxHistory;
  constructor() {
    this.balances = {
      totalBalance: 0,
      totalBalanceInSatoshis: 0
    }, this.utxos = [], this.parsedTxHistory = [], this.slp = {
      tokens: new lo(),
      slpUtxos: [],
      nonSlpUtxos: []
    };
  }
}
class lo {
  prod;
  sandbox;
  constructor() {
    this.prod = {
      rawBalance: 0,
      balance: 0,
      info: {
        tokenId: "52b12c03466936e7e3b2dcfcff847338c53c611ba8ab74dd8e4dadf7ded12cf6",
        ticker: "BUX",
        name: "Badger Universal Token",
        uri: "https://bux.digital",
        hash: "",
        decimals: 4,
        version: 2,
        vaultScriptHash: "08d6edf91c7b93d18306d3b8244587e43f11df4b"
      },
      tokenId: "52b12c03466936e7e3b2dcfcff847338c53c611ba8ab74dd8e4dadf7ded12cf6"
    }, this.sandbox = {
      rawBalance: 0,
      balance: 0,
      info: {
        tokenId: "4075459e0ac841f234bc73fc4fe46fe5490be4ed98bc8ca3f9b898443a5a381a",
        ticker: "BUXs",
        name: "BUX (Sandbox)",
        uri: "",
        hash: "",
        decimals: 4,
        version: 2,
        vaultScriptHash: "16748bbeb9fa3f2bdeb0fc5f7e23dd9ad166ace6"
      },
      tokenId: "4075459e0ac841f234bc73fc4fe46fe5490be4ed98bc8ca3f9b898443a5a381a"
    };
  }
}
const { Mnemonic: wx, HDPrivateKey: yx, KeyRing: vx } = ss, Sx = () => new wx({
  language: "english"
}), Ex = (e, c) => {
  const l = e.derivePath(c), w = l.toPublic().publicKey.toString("hex"), m = vx.fromPrivate(l.privateKey, null), f = m.getAddress("string"), n = Bi.decode(f), u = Bi.encode(
    "etoken",
    n.type,
    n.hash
  ), o = m.toSecret(), s = m.getAddress("base58");
  return {
    publicKey: w,
    cashAddress: f,
    slpAddress: u,
    fundingWif: o,
    legacyAddress: s
  };
}, Ix = (e) => {
  const c = yx.fromPhrase(e.getPhrase()), w = Ex(c, "m/44'/1899'/0'/0/0"), m = w.cashAddress.slice(12, 17);
  return {
    mnemonic: e,
    name: m,
    Path1899: w,
    state: new xx()
  };
}, Ax = (e, c) => c ? !c.find((m) => m.mnemonic.toString() === e.toString()) : !0, Ox = (e, c) => {
  const l = [e];
  for (let w = 0; w < c.length; w++)
    c[w].name === e.name || l.push(c[w]);
  return l;
};
class _x {
  wallets;
  constructor(c = []) {
    this.wallets = c;
  }
}
var Rx = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, j0 = Math.ceil, yr = Math.floor, ar = "[BigNumber Error] ", P6 = ar + "Number primitive has more than 15 significant digits: ", kr = 1e14, wt = 14, Y0 = 9007199254740991, X0 = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], hi = 1e7, Vt = 1e9;
function J7(e) {
  var c, l, w, m = E.prototype = { constructor: E, toString: null, valueOf: null }, f = new E(1), n = 20, u = 4, o = -7, s = 21, i = -1e7, p = 1e7, g = !1, S = 1, y = 0, b = {
    prefix: "",
    groupSize: 3,
    secondaryGroupSize: 0,
    groupSeparator: ",",
    decimalSeparator: ".",
    fractionGroupSize: 0,
    fractionGroupSeparator: " ",
    // non-breaking space
    suffix: ""
  }, h = "0123456789abcdefghijklmnopqrstuvwxyz", a = !0;
  function E(A, q) {
    var _, F, R, L, fe, ue, ae, D, Q = this;
    if (!(Q instanceof E)) return new E(A, q);
    if (q == null) {
      if (A && A._isBigNumber === !0) {
        Q.s = A.s, !A.c || A.e > p ? Q.c = Q.e = null : A.e < i ? Q.c = [Q.e = 0] : (Q.e = A.e, Q.c = A.c.slice());
        return;
      }
      if ((ue = typeof A == "number") && A * 0 == 0) {
        if (Q.s = 1 / A < 0 ? (A = -A, -1) : 1, A === ~~A) {
          for (L = 0, fe = A; fe >= 10; fe /= 10, L++) ;
          L > p ? Q.c = Q.e = null : (Q.e = L, Q.c = [A]);
          return;
        }
        D = String(A);
      } else {
        if (!Rx.test(D = String(A))) return w(Q, D, ue);
        Q.s = D.charCodeAt(0) == 45 ? (D = D.slice(1), -1) : 1;
      }
      (L = D.indexOf(".")) > -1 && (D = D.replace(".", "")), (fe = D.search(/e/i)) > 0 ? (L < 0 && (L = fe), L += +D.slice(fe + 1), D = D.substring(0, fe)) : L < 0 && (L = D.length);
    } else {
      if (Ut(q, 2, h.length, "Base"), q == 10 && a)
        return Q = new E(A), N(Q, n + Q.e + 1, u);
      if (D = String(A), ue = typeof A == "number") {
        if (A * 0 != 0) return w(Q, D, ue, q);
        if (Q.s = 1 / A < 0 ? (D = D.slice(1), -1) : 1, E.DEBUG && D.replace(/^0\.0*|\./, "").length > 15)
          throw Error(P6 + A);
      } else
        Q.s = D.charCodeAt(0) === 45 ? (D = D.slice(1), -1) : 1;
      for (_ = h.slice(0, q), L = fe = 0, ae = D.length; fe < ae; fe++)
        if (_.indexOf(F = D.charAt(fe)) < 0) {
          if (F == ".") {
            if (fe > L) {
              L = ae;
              continue;
            }
          } else if (!R && (D == D.toUpperCase() && (D = D.toLowerCase()) || D == D.toLowerCase() && (D = D.toUpperCase()))) {
            R = !0, fe = -1, L = 0;
            continue;
          }
          return w(Q, String(A), ue, q);
        }
      ue = !1, D = l(D, q, 10, Q.s), (L = D.indexOf(".")) > -1 ? D = D.replace(".", "") : L = D.length;
    }
    for (fe = 0; D.charCodeAt(fe) === 48; fe++) ;
    for (ae = D.length; D.charCodeAt(--ae) === 48; ) ;
    if (D = D.slice(fe, ++ae)) {
      if (ae -= fe, ue && E.DEBUG && ae > 15 && (A > Y0 || A !== yr(A)))
        throw Error(P6 + Q.s * A);
      if ((L = L - fe - 1) > p)
        Q.c = Q.e = null;
      else if (L < i)
        Q.c = [Q.e = 0];
      else {
        if (Q.e = L, Q.c = [], fe = (L + 1) % wt, L < 0 && (fe += wt), fe < ae) {
          for (fe && Q.c.push(+D.slice(0, fe)), ae -= wt; fe < ae; )
            Q.c.push(+D.slice(fe, fe += wt));
          fe = wt - (D = D.slice(fe)).length;
        } else
          fe -= ae;
        for (; fe--; D += "0") ;
        Q.c.push(+D);
      }
    } else
      Q.c = [Q.e = 0];
  }
  E.clone = J7, E.ROUND_UP = 0, E.ROUND_DOWN = 1, E.ROUND_CEIL = 2, E.ROUND_FLOOR = 3, E.ROUND_HALF_UP = 4, E.ROUND_HALF_DOWN = 5, E.ROUND_HALF_EVEN = 6, E.ROUND_HALF_CEIL = 7, E.ROUND_HALF_FLOOR = 8, E.EUCLID = 9, E.config = E.set = function(A) {
    var q, _;
    if (A != null)
      if (typeof A == "object") {
        if (A.hasOwnProperty(q = "DECIMAL_PLACES") && (_ = A[q], Ut(_, 0, Vt, q), n = _), A.hasOwnProperty(q = "ROUNDING_MODE") && (_ = A[q], Ut(_, 0, 8, q), u = _), A.hasOwnProperty(q = "EXPONENTIAL_AT") && (_ = A[q], _ && _.pop ? (Ut(_[0], -Vt, 0, q), Ut(_[1], 0, Vt, q), o = _[0], s = _[1]) : (Ut(_, -Vt, Vt, q), o = -(s = _ < 0 ? -_ : _))), A.hasOwnProperty(q = "RANGE"))
          if (_ = A[q], _ && _.pop)
            Ut(_[0], -Vt, -1, q), Ut(_[1], 1, Vt, q), i = _[0], p = _[1];
          else if (Ut(_, -Vt, Vt, q), _)
            i = -(p = _ < 0 ? -_ : _);
          else
            throw Error(ar + q + " cannot be zero: " + _);
        if (A.hasOwnProperty(q = "CRYPTO"))
          if (_ = A[q], _ === !!_)
            if (_)
              if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes))
                g = _;
              else
                throw g = !_, Error(ar + "crypto unavailable");
            else
              g = _;
          else
            throw Error(ar + q + " not true or false: " + _);
        if (A.hasOwnProperty(q = "MODULO_MODE") && (_ = A[q], Ut(_, 0, 9, q), S = _), A.hasOwnProperty(q = "POW_PRECISION") && (_ = A[q], Ut(_, 0, Vt, q), y = _), A.hasOwnProperty(q = "FORMAT"))
          if (_ = A[q], typeof _ == "object") b = _;
          else throw Error(ar + q + " not an object: " + _);
        if (A.hasOwnProperty(q = "ALPHABET"))
          if (_ = A[q], typeof _ == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(_))
            a = _.slice(0, 10) == "0123456789", h = _;
          else
            throw Error(ar + q + " invalid: " + _);
      } else
        throw Error(ar + "Object expected: " + A);
    return {
      DECIMAL_PLACES: n,
      ROUNDING_MODE: u,
      EXPONENTIAL_AT: [o, s],
      RANGE: [i, p],
      CRYPTO: g,
      MODULO_MODE: S,
      POW_PRECISION: y,
      FORMAT: b,
      ALPHABET: h
    };
  }, E.isBigNumber = function(A) {
    if (!A || A._isBigNumber !== !0) return !1;
    if (!E.DEBUG) return !0;
    var q, _, F = A.c, R = A.e, L = A.s;
    e: if ({}.toString.call(F) == "[object Array]") {
      if ((L === 1 || L === -1) && R >= -Vt && R <= Vt && R === yr(R)) {
        if (F[0] === 0) {
          if (R === 0 && F.length === 1) return !0;
          break e;
        }
        if (q = (R + 1) % wt, q < 1 && (q += wt), String(F[0]).length == q) {
          for (q = 0; q < F.length; q++)
            if (_ = F[q], _ < 0 || _ >= kr || _ !== yr(_)) break e;
          if (_ !== 0) return !0;
        }
      }
    } else if (F === null && R === null && (L === null || L === 1 || L === -1))
      return !0;
    throw Error(ar + "Invalid BigNumber: " + A);
  }, E.maximum = E.max = function() {
    return j(arguments, -1);
  }, E.minimum = E.min = function() {
    return j(arguments, 1);
  }, E.random = function() {
    var A = 9007199254740992, q = Math.random() * A & 2097151 ? function() {
      return yr(Math.random() * A);
    } : function() {
      return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
    };
    return function(_) {
      var F, R, L, fe, ue, ae = 0, D = [], Q = new E(f);
      if (_ == null ? _ = n : Ut(_, 0, Vt), fe = j0(_ / wt), g)
        if (crypto.getRandomValues) {
          for (F = crypto.getRandomValues(new Uint32Array(fe *= 2)); ae < fe; )
            ue = F[ae] * 131072 + (F[ae + 1] >>> 11), ue >= 9e15 ? (R = crypto.getRandomValues(new Uint32Array(2)), F[ae] = R[0], F[ae + 1] = R[1]) : (D.push(ue % 1e14), ae += 2);
          ae = fe / 2;
        } else if (crypto.randomBytes) {
          for (F = crypto.randomBytes(fe *= 7); ae < fe; )
            ue = (F[ae] & 31) * 281474976710656 + F[ae + 1] * 1099511627776 + F[ae + 2] * 4294967296 + F[ae + 3] * 16777216 + (F[ae + 4] << 16) + (F[ae + 5] << 8) + F[ae + 6], ue >= 9e15 ? crypto.randomBytes(7).copy(F, ae) : (D.push(ue % 1e14), ae += 7);
          ae = fe / 7;
        } else
          throw g = !1, Error(ar + "crypto unavailable");
      if (!g)
        for (; ae < fe; )
          ue = q(), ue < 9e15 && (D[ae++] = ue % 1e14);
      for (fe = D[--ae], _ %= wt, fe && _ && (ue = X0[wt - _], D[ae] = yr(fe / ue) * ue); D[ae] === 0; D.pop(), ae--) ;
      if (ae < 0)
        D = [L = 0];
      else {
        for (L = -1; D[0] === 0; D.splice(0, 1), L -= wt) ;
        for (ae = 1, ue = D[0]; ue >= 10; ue /= 10, ae++) ;
        ae < wt && (L -= wt - ae);
      }
      return Q.e = L, Q.c = D, Q;
    };
  }(), E.sum = function() {
    for (var A = 1, q = arguments, _ = new E(q[0]); A < q.length; ) _ = _.plus(q[A++]);
    return _;
  }, l = /* @__PURE__ */ function() {
    var A = "0123456789";
    function q(_, F, R, L) {
      for (var fe, ue = [0], ae, D = 0, Q = _.length; D < Q; ) {
        for (ae = ue.length; ae--; ue[ae] *= F) ;
        for (ue[0] += L.indexOf(_.charAt(D++)), fe = 0; fe < ue.length; fe++)
          ue[fe] > R - 1 && (ue[fe + 1] == null && (ue[fe + 1] = 0), ue[fe + 1] += ue[fe] / R | 0, ue[fe] %= R);
      }
      return ue.reverse();
    }
    return function(_, F, R, L, fe) {
      var ue, ae, D, Q, W, oe, v, Y, he = _.indexOf("."), le = n, ge = u;
      for (he >= 0 && (Q = y, y = 0, _ = _.replace(".", ""), Y = new E(F), oe = Y.pow(_.length - he), y = Q, Y.c = q(
        Zr(wr(oe.c), oe.e, "0"),
        10,
        R,
        A
      ), Y.e = Y.c.length), v = q(_, F, R, fe ? (ue = h, A) : (ue = A, h)), D = Q = v.length; v[--Q] == 0; v.pop()) ;
      if (!v[0]) return ue.charAt(0);
      if (he < 0 ? --D : (oe.c = v, oe.e = D, oe.s = L, oe = c(oe, Y, le, ge, R), v = oe.c, W = oe.r, D = oe.e), ae = D + le + 1, he = v[ae], Q = R / 2, W = W || ae < 0 || v[ae + 1] != null, W = ge < 4 ? (he != null || W) && (ge == 0 || ge == (oe.s < 0 ? 3 : 2)) : he > Q || he == Q && (ge == 4 || W || ge == 6 && v[ae - 1] & 1 || ge == (oe.s < 0 ? 8 : 7)), ae < 1 || !v[0])
        _ = W ? Zr(ue.charAt(1), -le, ue.charAt(0)) : ue.charAt(0);
      else {
        if (v.length = ae, W)
          for (--R; ++v[--ae] > R; )
            v[ae] = 0, ae || (++D, v = [1].concat(v));
        for (Q = v.length; !v[--Q]; ) ;
        for (he = 0, _ = ""; he <= Q; _ += ue.charAt(v[he++])) ;
        _ = Zr(_, D, ue.charAt(0));
      }
      return _;
    };
  }(), c = /* @__PURE__ */ function() {
    function A(F, R, L) {
      var fe, ue, ae, D, Q = 0, W = F.length, oe = R % hi, v = R / hi | 0;
      for (F = F.slice(); W--; )
        ae = F[W] % hi, D = F[W] / hi | 0, fe = v * ae + D * oe, ue = oe * ae + fe % hi * hi + Q, Q = (ue / L | 0) + (fe / hi | 0) + v * D, F[W] = ue % L;
      return Q && (F = [Q].concat(F)), F;
    }
    function q(F, R, L, fe) {
      var ue, ae;
      if (L != fe)
        ae = L > fe ? 1 : -1;
      else
        for (ue = ae = 0; ue < L; ue++)
          if (F[ue] != R[ue]) {
            ae = F[ue] > R[ue] ? 1 : -1;
            break;
          }
      return ae;
    }
    function _(F, R, L, fe) {
      for (var ue = 0; L--; )
        F[L] -= ue, ue = F[L] < R[L] ? 1 : 0, F[L] = ue * fe + F[L] - R[L];
      for (; !F[0] && F.length > 1; F.splice(0, 1)) ;
    }
    return function(F, R, L, fe, ue) {
      var ae, D, Q, W, oe, v, Y, he, le, ge, Ee, we, z, I, ne, t, d, B = F.s == R.s ? 1 : -1, U = F.c, J = R.c;
      if (!U || !U[0] || !J || !J[0])
        return new E(
          // Return NaN if either NaN, or both Infinity or 0.
          !F.s || !R.s || (U ? J && U[0] == J[0] : !J) ? NaN : (
            // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.
            U && U[0] == 0 || !J ? B * 0 : B / 0
          )
        );
      for (he = new E(B), le = he.c = [], D = F.e - R.e, B = L + D + 1, ue || (ue = kr, D = vr(F.e / wt) - vr(R.e / wt), B = B / wt | 0), Q = 0; J[Q] == (U[Q] || 0); Q++) ;
      if (J[Q] > (U[Q] || 0) && D--, B < 0)
        le.push(1), W = !0;
      else {
        for (I = U.length, t = J.length, Q = 0, B += 2, oe = yr(ue / (J[0] + 1)), oe > 1 && (J = A(J, oe, ue), U = A(U, oe, ue), t = J.length, I = U.length), z = t, ge = U.slice(0, t), Ee = ge.length; Ee < t; ge[Ee++] = 0) ;
        d = J.slice(), d = [0].concat(d), ne = J[0], J[1] >= ue / 2 && ne++;
        do {
          if (oe = 0, ae = q(J, ge, t, Ee), ae < 0) {
            if (we = ge[0], t != Ee && (we = we * ue + (ge[1] || 0)), oe = yr(we / ne), oe > 1)
              for (oe >= ue && (oe = ue - 1), v = A(J, oe, ue), Y = v.length, Ee = ge.length; q(v, ge, Y, Ee) == 1; )
                oe--, _(v, t < Y ? d : J, Y, ue), Y = v.length, ae = 1;
            else
              oe == 0 && (ae = oe = 1), v = J.slice(), Y = v.length;
            if (Y < Ee && (v = [0].concat(v)), _(ge, v, Ee, ue), Ee = ge.length, ae == -1)
              for (; q(J, ge, t, Ee) < 1; )
                oe++, _(ge, t < Ee ? d : J, Ee, ue), Ee = ge.length;
          } else ae === 0 && (oe++, ge = [0]);
          le[Q++] = oe, ge[0] ? ge[Ee++] = U[z] || 0 : (ge = [U[z]], Ee = 1);
        } while ((z++ < I || ge[0] != null) && B--);
        W = ge[0] != null, le[0] || le.splice(0, 1);
      }
      if (ue == kr) {
        for (Q = 1, B = le[0]; B >= 10; B /= 10, Q++) ;
        N(he, L + (he.e = Q + D * wt - 1) + 1, fe, W);
      } else
        he.e = D, he.r = +W;
      return he;
    };
  }();
  function H(A, q, _, F) {
    var R, L, fe, ue, ae;
    if (_ == null ? _ = u : Ut(_, 0, 8), !A.c) return A.toString();
    if (R = A.c[0], fe = A.e, q == null)
      ae = wr(A.c), ae = F == 1 || F == 2 && (fe <= o || fe >= s) ? Ss(ae, fe) : Zr(ae, fe, "0");
    else if (A = N(new E(A), q, _), L = A.e, ae = wr(A.c), ue = ae.length, F == 1 || F == 2 && (q <= L || L <= o)) {
      for (; ue < q; ae += "0", ue++) ;
      ae = Ss(ae, L);
    } else if (q -= fe + (F === 2 && L > fe), ae = Zr(ae, L, "0"), L + 1 > ue) {
      if (--q > 0) for (ae += "."; q--; ae += "0") ;
    } else if (q += L - ue, q > 0)
      for (L + 1 == ue && (ae += "."); q--; ae += "0") ;
    return A.s < 0 && R ? "-" + ae : ae;
  }
  function j(A, q) {
    for (var _, F, R = 1, L = new E(A[0]); R < A.length; R++)
      F = new E(A[R]), (!F.s || (_ = Oi(L, F)) === q || _ === 0 && L.s === q) && (L = F);
    return L;
  }
  function G(A, q, _) {
    for (var F = 1, R = q.length; !q[--R]; q.pop()) ;
    for (R = q[0]; R >= 10; R /= 10, F++) ;
    return (_ = F + _ * wt - 1) > p ? A.c = A.e = null : _ < i ? A.c = [A.e = 0] : (A.e = _, A.c = q), A;
  }
  w = /* @__PURE__ */ function() {
    var A = /^(-?)0([xbo])(?=\w[\w.]*$)/i, q = /^([^.]+)\.$/, _ = /^\.([^.]+)$/, F = /^-?(Infinity|NaN)$/, R = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
    return function(L, fe, ue, ae) {
      var D, Q = ue ? fe : fe.replace(R, "");
      if (F.test(Q))
        L.s = isNaN(Q) ? null : Q < 0 ? -1 : 1;
      else {
        if (!ue && (Q = Q.replace(A, function(W, oe, v) {
          return D = (v = v.toLowerCase()) == "x" ? 16 : v == "b" ? 2 : 8, !ae || ae == D ? oe : W;
        }), ae && (D = ae, Q = Q.replace(q, "$1").replace(_, "0.$1")), fe != Q))
          return new E(Q, D);
        if (E.DEBUG)
          throw Error(ar + "Not a" + (ae ? " base " + ae : "") + " number: " + fe);
        L.s = null;
      }
      L.c = L.e = null;
    };
  }();
  function N(A, q, _, F) {
    var R, L, fe, ue, ae, D, Q, W = A.c, oe = X0;
    if (W) {
      e: {
        for (R = 1, ue = W[0]; ue >= 10; ue /= 10, R++) ;
        if (L = q - R, L < 0)
          L += wt, fe = q, ae = W[D = 0], Q = yr(ae / oe[R - fe - 1] % 10);
        else if (D = j0((L + 1) / wt), D >= W.length)
          if (F) {
            for (; W.length <= D; W.push(0)) ;
            ae = Q = 0, R = 1, L %= wt, fe = L - wt + 1;
          } else
            break e;
        else {
          for (ae = ue = W[D], R = 1; ue >= 10; ue /= 10, R++) ;
          L %= wt, fe = L - wt + R, Q = fe < 0 ? 0 : yr(ae / oe[R - fe - 1] % 10);
        }
        if (F = F || q < 0 || // Are there any non-zero digits after the rounding digit?
        // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
        // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
        W[D + 1] != null || (fe < 0 ? ae : ae % oe[R - fe - 1]), F = _ < 4 ? (Q || F) && (_ == 0 || _ == (A.s < 0 ? 3 : 2)) : Q > 5 || Q == 5 && (_ == 4 || F || _ == 6 && // Check whether the digit to the left of the rounding digit is odd.
        (L > 0 ? fe > 0 ? ae / oe[R - fe] : 0 : W[D - 1]) % 10 & 1 || _ == (A.s < 0 ? 8 : 7)), q < 1 || !W[0])
          return W.length = 0, F ? (q -= A.e + 1, W[0] = oe[(wt - q % wt) % wt], A.e = -q || 0) : W[0] = A.e = 0, A;
        if (L == 0 ? (W.length = D, ue = 1, D--) : (W.length = D + 1, ue = oe[wt - L], W[D] = fe > 0 ? yr(ae / oe[R - fe] % oe[fe]) * ue : 0), F)
          for (; ; )
            if (D == 0) {
              for (L = 1, fe = W[0]; fe >= 10; fe /= 10, L++) ;
              for (fe = W[0] += ue, ue = 1; fe >= 10; fe /= 10, ue++) ;
              L != ue && (A.e++, W[0] == kr && (W[0] = 1));
              break;
            } else {
              if (W[D] += ue, W[D] != kr) break;
              W[D--] = 0, ue = 1;
            }
        for (L = W.length; W[--L] === 0; W.pop()) ;
      }
      A.e > p ? A.c = A.e = null : A.e < i && (A.c = [A.e = 0]);
    }
    return A;
  }
  function T(A) {
    var q, _ = A.e;
    return _ === null ? A.toString() : (q = wr(A.c), q = _ <= o || _ >= s ? Ss(q, _) : Zr(q, _, "0"), A.s < 0 ? "-" + q : q);
  }
  return m.absoluteValue = m.abs = function() {
    var A = new E(this);
    return A.s < 0 && (A.s = 1), A;
  }, m.comparedTo = function(A, q) {
    return Oi(this, new E(A, q));
  }, m.decimalPlaces = m.dp = function(A, q) {
    var _, F, R, L = this;
    if (A != null)
      return Ut(A, 0, Vt), q == null ? q = u : Ut(q, 0, 8), N(new E(L), A + L.e + 1, q);
    if (!(_ = L.c)) return null;
    if (F = ((R = _.length - 1) - vr(this.e / wt)) * wt, R = _[R]) for (; R % 10 == 0; R /= 10, F--) ;
    return F < 0 && (F = 0), F;
  }, m.dividedBy = m.div = function(A, q) {
    return c(this, new E(A, q), n, u);
  }, m.dividedToIntegerBy = m.idiv = function(A, q) {
    return c(this, new E(A, q), 0, 1);
  }, m.exponentiatedBy = m.pow = function(A, q) {
    var _, F, R, L, fe, ue, ae, D, Q, W = this;
    if (A = new E(A), A.c && !A.isInteger())
      throw Error(ar + "Exponent not an integer: " + T(A));
    if (q != null && (q = new E(q)), ue = A.e > 14, !W.c || !W.c[0] || W.c[0] == 1 && !W.e && W.c.length == 1 || !A.c || !A.c[0])
      return Q = new E(Math.pow(+T(W), ue ? A.s * (2 - vs(A)) : +T(A))), q ? Q.mod(q) : Q;
    if (ae = A.s < 0, q) {
      if (q.c ? !q.c[0] : !q.s) return new E(NaN);
      F = !ae && W.isInteger() && q.isInteger(), F && (W = W.mod(q));
    } else {
      if (A.e > 9 && (W.e > 0 || W.e < -1 || (W.e == 0 ? W.c[0] > 1 || ue && W.c[1] >= 24e7 : W.c[0] < 8e13 || ue && W.c[0] <= 9999975e7)))
        return L = W.s < 0 && vs(A) ? -0 : 0, W.e > -1 && (L = 1 / L), new E(ae ? 1 / L : L);
      y && (L = j0(y / wt + 2));
    }
    for (ue ? (_ = new E(0.5), ae && (A.s = 1), D = vs(A)) : (R = Math.abs(+T(A)), D = R % 2), Q = new E(f); ; ) {
      if (D) {
        if (Q = Q.times(W), !Q.c) break;
        L ? Q.c.length > L && (Q.c.length = L) : F && (Q = Q.mod(q));
      }
      if (R) {
        if (R = yr(R / 2), R === 0) break;
        D = R % 2;
      } else if (A = A.times(_), N(A, A.e + 1, 1), A.e > 14)
        D = vs(A);
      else {
        if (R = +T(A), R === 0) break;
        D = R % 2;
      }
      W = W.times(W), L ? W.c && W.c.length > L && (W.c.length = L) : F && (W = W.mod(q));
    }
    return F ? Q : (ae && (Q = f.div(Q)), q ? Q.mod(q) : L ? N(Q, y, u, fe) : Q);
  }, m.integerValue = function(A) {
    var q = new E(this);
    return A == null ? A = u : Ut(A, 0, 8), N(q, q.e + 1, A);
  }, m.isEqualTo = m.eq = function(A, q) {
    return Oi(this, new E(A, q)) === 0;
  }, m.isFinite = function() {
    return !!this.c;
  }, m.isGreaterThan = m.gt = function(A, q) {
    return Oi(this, new E(A, q)) > 0;
  }, m.isGreaterThanOrEqualTo = m.gte = function(A, q) {
    return (q = Oi(this, new E(A, q))) === 1 || q === 0;
  }, m.isInteger = function() {
    return !!this.c && vr(this.e / wt) > this.c.length - 2;
  }, m.isLessThan = m.lt = function(A, q) {
    return Oi(this, new E(A, q)) < 0;
  }, m.isLessThanOrEqualTo = m.lte = function(A, q) {
    return (q = Oi(this, new E(A, q))) === -1 || q === 0;
  }, m.isNaN = function() {
    return !this.s;
  }, m.isNegative = function() {
    return this.s < 0;
  }, m.isPositive = function() {
    return this.s > 0;
  }, m.isZero = function() {
    return !!this.c && this.c[0] == 0;
  }, m.minus = function(A, q) {
    var _, F, R, L, fe = this, ue = fe.s;
    if (A = new E(A, q), q = A.s, !ue || !q) return new E(NaN);
    if (ue != q)
      return A.s = -q, fe.plus(A);
    var ae = fe.e / wt, D = A.e / wt, Q = fe.c, W = A.c;
    if (!ae || !D) {
      if (!Q || !W) return Q ? (A.s = -q, A) : new E(W ? fe : NaN);
      if (!Q[0] || !W[0])
        return W[0] ? (A.s = -q, A) : new E(Q[0] ? fe : (
          // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
          u == 3 ? -0 : 0
        ));
    }
    if (ae = vr(ae), D = vr(D), Q = Q.slice(), ue = ae - D) {
      for ((L = ue < 0) ? (ue = -ue, R = Q) : (D = ae, R = W), R.reverse(), q = ue; q--; R.push(0)) ;
      R.reverse();
    } else
      for (F = (L = (ue = Q.length) < (q = W.length)) ? ue : q, ue = q = 0; q < F; q++)
        if (Q[q] != W[q]) {
          L = Q[q] < W[q];
          break;
        }
    if (L && (R = Q, Q = W, W = R, A.s = -A.s), q = (F = W.length) - (_ = Q.length), q > 0) for (; q--; Q[_++] = 0) ;
    for (q = kr - 1; F > ue; ) {
      if (Q[--F] < W[F]) {
        for (_ = F; _ && !Q[--_]; Q[_] = q) ;
        --Q[_], Q[F] += kr;
      }
      Q[F] -= W[F];
    }
    for (; Q[0] == 0; Q.splice(0, 1), --D) ;
    return Q[0] ? G(A, Q, D) : (A.s = u == 3 ? -1 : 1, A.c = [A.e = 0], A);
  }, m.modulo = m.mod = function(A, q) {
    var _, F, R = this;
    return A = new E(A, q), !R.c || !A.s || A.c && !A.c[0] ? new E(NaN) : !A.c || R.c && !R.c[0] ? new E(R) : (S == 9 ? (F = A.s, A.s = 1, _ = c(R, A, 0, 3), A.s = F, _.s *= F) : _ = c(R, A, 0, S), A = R.minus(_.times(A)), !A.c[0] && S == 1 && (A.s = R.s), A);
  }, m.multipliedBy = m.times = function(A, q) {
    var _, F, R, L, fe, ue, ae, D, Q, W, oe, v, Y, he, le, ge = this, Ee = ge.c, we = (A = new E(A, q)).c;
    if (!Ee || !we || !Ee[0] || !we[0])
      return !ge.s || !A.s || Ee && !Ee[0] && !we || we && !we[0] && !Ee ? A.c = A.e = A.s = null : (A.s *= ge.s, !Ee || !we ? A.c = A.e = null : (A.c = [0], A.e = 0)), A;
    for (F = vr(ge.e / wt) + vr(A.e / wt), A.s *= ge.s, ae = Ee.length, W = we.length, ae < W && (Y = Ee, Ee = we, we = Y, R = ae, ae = W, W = R), R = ae + W, Y = []; R--; Y.push(0)) ;
    for (he = kr, le = hi, R = W; --R >= 0; ) {
      for (_ = 0, oe = we[R] % le, v = we[R] / le | 0, fe = ae, L = R + fe; L > R; )
        D = Ee[--fe] % le, Q = Ee[fe] / le | 0, ue = v * D + Q * oe, D = oe * D + ue % le * le + Y[L] + _, _ = (D / he | 0) + (ue / le | 0) + v * Q, Y[L--] = D % he;
      Y[L] = _;
    }
    return _ ? ++F : Y.splice(0, 1), G(A, Y, F);
  }, m.negated = function() {
    var A = new E(this);
    return A.s = -A.s || null, A;
  }, m.plus = function(A, q) {
    var _, F = this, R = F.s;
    if (A = new E(A, q), q = A.s, !R || !q) return new E(NaN);
    if (R != q)
      return A.s = -q, F.minus(A);
    var L = F.e / wt, fe = A.e / wt, ue = F.c, ae = A.c;
    if (!L || !fe) {
      if (!ue || !ae) return new E(R / 0);
      if (!ue[0] || !ae[0]) return ae[0] ? A : new E(ue[0] ? F : R * 0);
    }
    if (L = vr(L), fe = vr(fe), ue = ue.slice(), R = L - fe) {
      for (R > 0 ? (fe = L, _ = ae) : (R = -R, _ = ue), _.reverse(); R--; _.push(0)) ;
      _.reverse();
    }
    for (R = ue.length, q = ae.length, R - q < 0 && (_ = ae, ae = ue, ue = _, q = R), R = 0; q; )
      R = (ue[--q] = ue[q] + ae[q] + R) / kr | 0, ue[q] = kr === ue[q] ? 0 : ue[q] % kr;
    return R && (ue = [R].concat(ue), ++fe), G(A, ue, fe);
  }, m.precision = m.sd = function(A, q) {
    var _, F, R, L = this;
    if (A != null && A !== !!A)
      return Ut(A, 1, Vt), q == null ? q = u : Ut(q, 0, 8), N(new E(L), A, q);
    if (!(_ = L.c)) return null;
    if (R = _.length - 1, F = R * wt + 1, R = _[R]) {
      for (; R % 10 == 0; R /= 10, F--) ;
      for (R = _[0]; R >= 10; R /= 10, F++) ;
    }
    return A && L.e + 1 > F && (F = L.e + 1), F;
  }, m.shiftedBy = function(A) {
    return Ut(A, -Y0, Y0), this.times("1e" + A);
  }, m.squareRoot = m.sqrt = function() {
    var A, q, _, F, R, L = this, fe = L.c, ue = L.s, ae = L.e, D = n + 4, Q = new E("0.5");
    if (ue !== 1 || !fe || !fe[0])
      return new E(!ue || ue < 0 && (!fe || fe[0]) ? NaN : fe ? L : 1 / 0);
    if (ue = Math.sqrt(+T(L)), ue == 0 || ue == 1 / 0 ? (q = wr(fe), (q.length + ae) % 2 == 0 && (q += "0"), ue = Math.sqrt(+q), ae = vr((ae + 1) / 2) - (ae < 0 || ae % 2), ue == 1 / 0 ? q = "5e" + ae : (q = ue.toExponential(), q = q.slice(0, q.indexOf("e") + 1) + ae), _ = new E(q)) : _ = new E(ue + ""), _.c[0]) {
      for (ae = _.e, ue = ae + D, ue < 3 && (ue = 0); ; )
        if (R = _, _ = Q.times(R.plus(c(L, R, D, 1))), wr(R.c).slice(0, ue) === (q = wr(_.c)).slice(0, ue))
          if (_.e < ae && --ue, q = q.slice(ue - 3, ue + 1), q == "9999" || !F && q == "4999") {
            if (!F && (N(R, R.e + n + 2, 0), R.times(R).eq(L))) {
              _ = R;
              break;
            }
            D += 4, ue += 4, F = 1;
          } else {
            (!+q || !+q.slice(1) && q.charAt(0) == "5") && (N(_, _.e + n + 2, 1), A = !_.times(_).eq(L));
            break;
          }
    }
    return N(_, _.e + n + 1, u, A);
  }, m.toExponential = function(A, q) {
    return A != null && (Ut(A, 0, Vt), A++), H(this, A, q, 1);
  }, m.toFixed = function(A, q) {
    return A != null && (Ut(A, 0, Vt), A = A + this.e + 1), H(this, A, q);
  }, m.toFormat = function(A, q, _) {
    var F, R = this;
    if (_ == null)
      A != null && q && typeof q == "object" ? (_ = q, q = null) : A && typeof A == "object" ? (_ = A, A = q = null) : _ = b;
    else if (typeof _ != "object")
      throw Error(ar + "Argument not an object: " + _);
    if (F = R.toFixed(A, q), R.c) {
      var L, fe = F.split("."), ue = +_.groupSize, ae = +_.secondaryGroupSize, D = _.groupSeparator || "", Q = fe[0], W = fe[1], oe = R.s < 0, v = oe ? Q.slice(1) : Q, Y = v.length;
      if (ae && (L = ue, ue = ae, ae = L, Y -= L), ue > 0 && Y > 0) {
        for (L = Y % ue || ue, Q = v.substr(0, L); L < Y; L += ue) Q += D + v.substr(L, ue);
        ae > 0 && (Q += D + v.slice(L)), oe && (Q = "-" + Q);
      }
      F = W ? Q + (_.decimalSeparator || "") + ((ae = +_.fractionGroupSize) ? W.replace(
        new RegExp("\\d{" + ae + "}\\B", "g"),
        "$&" + (_.fractionGroupSeparator || "")
      ) : W) : Q;
    }
    return (_.prefix || "") + F + (_.suffix || "");
  }, m.toFraction = function(A) {
    var q, _, F, R, L, fe, ue, ae, D, Q, W, oe, v = this, Y = v.c;
    if (A != null && (ue = new E(A), !ue.isInteger() && (ue.c || ue.s !== 1) || ue.lt(f)))
      throw Error(ar + "Argument " + (ue.isInteger() ? "out of range: " : "not an integer: ") + T(ue));
    if (!Y) return new E(v);
    for (q = new E(f), D = _ = new E(f), F = ae = new E(f), oe = wr(Y), L = q.e = oe.length - v.e - 1, q.c[0] = X0[(fe = L % wt) < 0 ? wt + fe : fe], A = !A || ue.comparedTo(q) > 0 ? L > 0 ? q : D : ue, fe = p, p = 1 / 0, ue = new E(oe), ae.c[0] = 0; Q = c(ue, q, 0, 1), R = _.plus(Q.times(F)), R.comparedTo(A) != 1; )
      _ = F, F = R, D = ae.plus(Q.times(R = D)), ae = R, q = ue.minus(Q.times(R = q)), ue = R;
    return R = c(A.minus(_), F, 0, 1), ae = ae.plus(R.times(D)), _ = _.plus(R.times(F)), ae.s = D.s = v.s, L = L * 2, W = c(D, F, L, u).minus(v).abs().comparedTo(
      c(ae, _, L, u).minus(v).abs()
    ) < 1 ? [D, F] : [ae, _], p = fe, W;
  }, m.toNumber = function() {
    return +T(this);
  }, m.toPrecision = function(A, q) {
    return A != null && Ut(A, 1, Vt), H(this, A, q, 2);
  }, m.toString = function(A) {
    var q, _ = this, F = _.s, R = _.e;
    return R === null ? F ? (q = "Infinity", F < 0 && (q = "-" + q)) : q = "NaN" : (A == null ? q = R <= o || R >= s ? Ss(wr(_.c), R) : Zr(wr(_.c), R, "0") : A === 10 && a ? (_ = N(new E(_), n + R + 1, u), q = Zr(wr(_.c), _.e, "0")) : (Ut(A, 2, h.length, "Base"), q = l(Zr(wr(_.c), R, "0"), 10, A, F, !0)), F < 0 && _.c[0] && (q = "-" + q)), q;
  }, m.valueOf = m.toJSON = function() {
    return T(this);
  }, m._isBigNumber = !0, m[Symbol.toStringTag] = "BigNumber", m[Symbol.for("nodejs.util.inspect.custom")] = m.valueOf, e != null && E.set(e), E;
}
function vr(e) {
  var c = e | 0;
  return e > 0 || e === c ? c : c - 1;
}
function wr(e) {
  for (var c, l, w = 1, m = e.length, f = e[0] + ""; w < m; ) {
    for (c = e[w++] + "", l = wt - c.length; l--; c = "0" + c) ;
    f += c;
  }
  for (m = f.length; f.charCodeAt(--m) === 48; ) ;
  return f.slice(0, m + 1 || 1);
}
function Oi(e, c) {
  var l, w, m = e.c, f = c.c, n = e.s, u = c.s, o = e.e, s = c.e;
  if (!n || !u) return null;
  if (l = m && !m[0], w = f && !f[0], l || w) return l ? w ? 0 : -u : n;
  if (n != u) return n;
  if (l = n < 0, w = o == s, !m || !f) return w ? 0 : !m ^ l ? 1 : -1;
  if (!w) return o > s ^ l ? 1 : -1;
  for (u = (o = m.length) < (s = f.length) ? o : s, n = 0; n < u; n++) if (m[n] != f[n]) return m[n] > f[n] ^ l ? 1 : -1;
  return o == s ? 0 : o > s ^ l ? 1 : -1;
}
function Ut(e, c, l, w) {
  if (e < c || e > l || e !== yr(e))
    throw Error(ar + (w || "Argument") + (typeof e == "number" ? e < c || e > l ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(e));
}
function vs(e) {
  var c = e.c.length - 1;
  return vr(e.e / wt) == c && e.c[c] % 2 != 0;
}
function Ss(e, c) {
  return (e.length > 1 ? e.charAt(0) + "." + e.slice(1) : e) + (c < 0 ? "e" : "e+") + c;
}
function Zr(e, c, l) {
  var w, m;
  if (c < 0) {
    for (m = l + "."; ++c; m += l) ;
    e = m + e;
  } else if (w = e.length, ++c > w) {
    for (m = l, c -= w; --c; m += l) ;
    e += m;
  } else c < w && (e = e.slice(0, c) + "." + e.slice(c));
  return e;
}
var dr = J7();
const W7 = "https://ecash.badger.cash:8332", Px = async (e) => await (await fetch(`${W7}/coin/address/${e}?slp=true`)).json(), kx = (e) => {
  const c = e.nonSlpUtxos.reduce(
    (m, f) => m + f.value,
    0
  );
  return {
    totalBalance: Tx(c),
    totalBalanceInSatoshis: c
  };
}, Bx = (e) => {
  const c = e.filter(
    (f) => !f.slp || f.slp && f.slp.value == "0"
  ), l = e.filter(
    (f) => f.slp && (f.slp.value != "0" || f.slp.type == "MINT")
  ), w = new lo();
  for (let f = 0; f < l.length; f++) {
    const n = l[f], u = n.slp.tokenId, o = u === w.prod.tokenId, s = u === w.sandbox.tokenId;
    if ((o || s) && !(n.slp.type === "BATON"))
      if (o) {
        const g = new dr(w.prod.rawBalance).plus(n.slp.value);
        w.prod.rawBalance = g.toNumber();
      } else {
        const g = new dr(w.sandbox.rawBalance).plus(n.slp.value);
        w.sandbox.rawBalance = g.toNumber();
      }
  }
  return w.prod.balance = new dr(w.prod.rawBalance).dividedBy(10 ** w.prod.info.decimals).toNumber(), w.sandbox.balance = new dr(w.sandbox.rawBalance).dividedBy(10 ** w.sandbox.info.decimals).toNumber(), {
    tokens: w,
    nonSlpUtxos: c,
    slpUtxos: l
  };
}, Mx = async (e) => {
  const c = `${W7}/tx/address/${e}?slp=true`;
  return await (await fetch(c)).json();
}, Nx = (e, c) => {
  const l = [], w = new lo();
  for (let m = 0; m < e.length; m++) {
    const f = e[m];
    if (![w.prod.tokenId, w.sandbox.tokenId].includes(f.slpToken?.tokenId))
      continue;
    const o = qx(f, c);
    l.push(o);
  }
  return l;
}, qx = (e, c) => {
  const l = {};
  l.txid = e.hash, l.height = e.height, l.blocktime = e.time, l.confirmations = e.confirmations;
  const w = new lo(), m = e.slpToken.tokenId === w.sandbox.tokenId;
  l.sandbox = m, l.amountSent = 0, l.amountReceived = 0, l.sender = e.inputs[0].coin.address;
  let f = !1;
  for (const g of e.inputs)
    if (c === g.coin.address) {
      f = !0;
      break;
    }
  l.outgoing = f;
  const u = e.outputs.find((g) => g.slp).slp.type;
  l.type = u;
  const o = [];
  for (const g of e.outputs)
    g.slp && o.push(g.address);
  l.recipients = o;
  const s = e.inputs.filter(
    (g) => g.coin.slp && c === g.coin.address && u != "MINT"
  ).reduce((g, S) => g.plus(S.coin.slp.value), new dr(0)), i = e.outputs.filter(
    (g) => g.slp && c === g.address && g.slp.type != "BATON"
  ).reduce((g, S) => g.plus(S.slp.value), new dr(0)), p = 10 ** parseInt(e.slpToken.decimals);
  if (s.gte(i)) {
    const S = s.minus(i).div(p);
    l.amountSent = S.toNumber();
  } else {
    const S = i.minus(s).div(p);
    l.amountReceived = S.toNumber();
  }
  return l;
}, Tx = (e) => {
  const l = new dr(e), w = new dr(10 ** -2);
  return l.times(w).toNumber();
};
class zx {
  listeners;
  constructor() {
    this.listeners = {};
  }
  on(c, l) {
    !!this.listeners[c] || (this.listeners[c] = []), this.listeners[c].push(l);
  }
  off(c, l) {
    !!this.listeners[c] && (this.listeners[c] = this.listeners[c].filter(
      (m) => m !== l
    ));
  }
  emit(c, l) {
    !!this.listeners[c] && this.listeners[c].forEach((m) => m(c, l));
  }
}
const on = new zx();
function Cx(e, c) {
  const l = tm(e);
  Yn(() => {
    l.current = e;
  }, [e]), Yn(() => {
    let w = null;
    const m = () => {
      const f = l.current();
      f instanceof Promise ? f.then(() => {
        w = setTimeout(m, c);
      }) : w = setTimeout(m, c);
    };
    if (w !== null)
      return w = setTimeout(m, c), () => clearTimeout(w);
    m();
  }, [c]);
}
var G0, k6;
function Z7() {
  if (k6) return G0;
  k6 = 1;
  var e = Object.prototype.toString;
  return G0 = function(l) {
    var w = e.call(l), m = w === "[object Arguments]";
    return m || (m = w !== "[object Array]" && l !== null && typeof l == "object" && typeof l.length == "number" && l.length >= 0 && e.call(l.callee) === "[object Function]"), m;
  }, G0;
}
var J0, B6;
function Dx() {
  if (B6) return J0;
  B6 = 1;
  var e;
  if (!Object.keys) {
    var c = Object.prototype.hasOwnProperty, l = Object.prototype.toString, w = Z7(), m = Object.prototype.propertyIsEnumerable, f = !m.call({ toString: null }, "toString"), n = m.call(function() {
    }, "prototype"), u = [
      "toString",
      "toLocaleString",
      "valueOf",
      "hasOwnProperty",
      "isPrototypeOf",
      "propertyIsEnumerable",
      "constructor"
    ], o = function(g) {
      var S = g.constructor;
      return S && S.prototype === g;
    }, s = {
      $applicationCache: !0,
      $console: !0,
      $external: !0,
      $frame: !0,
      $frameElement: !0,
      $frames: !0,
      $innerHeight: !0,
      $innerWidth: !0,
      $onmozfullscreenchange: !0,
      $onmozfullscreenerror: !0,
      $outerHeight: !0,
      $outerWidth: !0,
      $pageXOffset: !0,
      $pageYOffset: !0,
      $parent: !0,
      $scrollLeft: !0,
      $scrollTop: !0,
      $scrollX: !0,
      $scrollY: !0,
      $self: !0,
      $webkitIndexedDB: !0,
      $webkitStorageInfo: !0,
      $window: !0
    }, i = function() {
      if (typeof window > "u")
        return !1;
      for (var g in window)
        try {
          if (!s["$" + g] && c.call(window, g) && window[g] !== null && typeof window[g] == "object")
            try {
              o(window[g]);
            } catch {
              return !0;
            }
        } catch {
          return !0;
        }
      return !1;
    }(), p = function(g) {
      if (typeof window > "u" || !i)
        return o(g);
      try {
        return o(g);
      } catch {
        return !1;
      }
    };
    e = function(S) {
      var y = S !== null && typeof S == "object", b = l.call(S) === "[object Function]", h = w(S), a = y && l.call(S) === "[object String]", E = [];
      if (!y && !b && !h)
        throw new TypeError("Object.keys called on a non-object");
      var H = n && b;
      if (a && S.length > 0 && !c.call(S, 0))
        for (var j = 0; j < S.length; ++j)
          E.push(String(j));
      if (h && S.length > 0)
        for (var G = 0; G < S.length; ++G)
          E.push(String(G));
      else
        for (var N in S)
          !(H && N === "prototype") && c.call(S, N) && E.push(String(N));
      if (f)
        for (var T = p(S), A = 0; A < u.length; ++A)
          !(T && u[A] === "constructor") && c.call(S, u[A]) && E.push(u[A]);
      return E;
    };
  }
  return J0 = e, J0;
}
var W0, M6;
function Kl() {
  if (M6) return W0;
  M6 = 1;
  var e = Array.prototype.slice, c = Z7(), l = Object.keys, w = l ? function(n) {
    return l(n);
  } : Dx(), m = Object.keys;
  return w.shim = function() {
    if (Object.keys) {
      var n = function() {
        var u = Object.keys(arguments);
        return u && u.length === arguments.length;
      }(1, 2);
      n || (Object.keys = function(o) {
        return c(o) ? m(e.call(o)) : m(o);
      });
    } else
      Object.keys = w;
    return Object.keys || w;
  }, W0 = w, W0;
}
var Z0, N6;
function bo() {
  if (N6) return Z0;
  N6 = 1;
  var e = Object.defineProperty || !1;
  if (e)
    try {
      e({}, "a", { value: 1 });
    } catch {
      e = !1;
    }
  return Z0 = e, Z0;
}
var Q0, q6;
function Vl() {
  return q6 || (q6 = 1, Q0 = SyntaxError), Q0;
}
var ef, T6;
function Ir() {
  return T6 || (T6 = 1, ef = TypeError), ef;
}
var tf, z6;
function Ux() {
  return z6 || (z6 = 1, tf = Object.getOwnPropertyDescriptor), tf;
}
var rf, C6;
function ji() {
  if (C6) return rf;
  C6 = 1;
  var e = /* @__PURE__ */ Ux();
  if (e)
    try {
      e([], "length");
    } catch {
      e = null;
    }
  return rf = e, rf;
}
var nf, D6;
function $l() {
  if (D6) return nf;
  D6 = 1;
  var e = /* @__PURE__ */ bo(), c = /* @__PURE__ */ Vl(), l = /* @__PURE__ */ Ir(), w = /* @__PURE__ */ ji();
  return nf = function(f, n, u) {
    if (!f || typeof f != "object" && typeof f != "function")
      throw new l("`obj` must be an object or a function`");
    if (typeof n != "string" && typeof n != "symbol")
      throw new l("`property` must be a string or a symbol`");
    if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null)
      throw new l("`nonEnumerable`, if provided, must be a boolean or null");
    if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null)
      throw new l("`nonWritable`, if provided, must be a boolean or null");
    if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null)
      throw new l("`nonConfigurable`, if provided, must be a boolean or null");
    if (arguments.length > 6 && typeof arguments[6] != "boolean")
      throw new l("`loose`, if provided, must be a boolean");
    var o = arguments.length > 3 ? arguments[3] : null, s = arguments.length > 4 ? arguments[4] : null, i = arguments.length > 5 ? arguments[5] : null, p = arguments.length > 6 ? arguments[6] : !1, g = !!w && w(f, n);
    if (e)
      e(f, n, {
        configurable: i === null && g ? g.configurable : !i,
        enumerable: o === null && g ? g.enumerable : !o,
        value: u,
        writable: s === null && g ? g.writable : !s
      });
    else if (p || !o && !s && !i)
      f[n] = u;
    else
      throw new c("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
  }, nf;
}
var sf, U6;
function jl() {
  if (U6) return sf;
  U6 = 1;
  var e = /* @__PURE__ */ bo(), c = function() {
    return !!e;
  };
  return c.hasArrayLengthDefineBug = function() {
    if (!e)
      return null;
    try {
      return e([], "length", { value: 1 }).length !== 1;
    } catch {
      return !0;
    }
  }, sf = c, sf;
}
var of, F6;
function oi() {
  if (F6) return of;
  F6 = 1;
  var e = Kl(), c = typeof Symbol == "function" && typeof Symbol("foo") == "symbol", l = Object.prototype.toString, w = Array.prototype.concat, m = /* @__PURE__ */ $l(), f = function(s) {
    return typeof s == "function" && l.call(s) === "[object Function]";
  }, n = /* @__PURE__ */ jl()(), u = function(s, i, p, g) {
    if (i in s) {
      if (g === !0) {
        if (s[i] === p)
          return;
      } else if (!f(g) || !g())
        return;
    }
    n ? m(s, i, p, !0) : m(s, i, p);
  }, o = function(s, i) {
    var p = arguments.length > 2 ? arguments[2] : {}, g = e(i);
    c && (g = w.call(g, Object.getOwnPropertySymbols(i)));
    for (var S = 0; S < g.length; S += 1)
      u(s, g[S], i[g[S]], p[g[S]]);
  };
  return o.supportsDescriptors = !!n, of = o, of;
}
var af = { exports: {} }, ff, H6;
function Yl() {
  return H6 || (H6 = 1, ff = Object), ff;
}
var cf, L6;
function Q7() {
  return L6 || (L6 = 1, cf = Error), cf;
}
var uf, K6;
function Fx() {
  return K6 || (K6 = 1, uf = EvalError), uf;
}
var hf, V6;
function Hx() {
  return V6 || (V6 = 1, hf = RangeError), hf;
}
var lf, $6;
function Lx() {
  return $6 || ($6 = 1, lf = ReferenceError), lf;
}
var df, j6;
function Kx() {
  return j6 || (j6 = 1, df = URIError), df;
}
var bf, Y6;
function Vx() {
  return Y6 || (Y6 = 1, bf = Math.abs), bf;
}
var pf, X6;
function $x() {
  return X6 || (X6 = 1, pf = Math.floor), pf;
}
var mf, G6;
function jx() {
  return G6 || (G6 = 1, mf = Math.max), mf;
}
var gf, J6;
function Yx() {
  return J6 || (J6 = 1, gf = Math.min), gf;
}
var xf, W6;
function Xx() {
  return W6 || (W6 = 1, xf = Math.pow), xf;
}
var wf, Z6;
function Gx() {
  return Z6 || (Z6 = 1, wf = Math.round), wf;
}
var yf, Q6;
function Jx() {
  return Q6 || (Q6 = 1, yf = Number.isNaN || function(c) {
    return c !== c;
  }), yf;
}
var vf, e5;
function Wx() {
  if (e5) return vf;
  e5 = 1;
  var e = /* @__PURE__ */ Jx();
  return vf = function(l) {
    return e(l) || l === 0 ? l : l < 0 ? -1 : 1;
  }, vf;
}
var Sf, t5;
function po() {
  return t5 || (t5 = 1, Sf = function() {
    if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
      return !1;
    if (typeof Symbol.iterator == "symbol")
      return !0;
    var c = {}, l = Symbol("test"), w = Object(l);
    if (typeof l == "string" || Object.prototype.toString.call(l) !== "[object Symbol]" || Object.prototype.toString.call(w) !== "[object Symbol]")
      return !1;
    var m = 42;
    c[l] = m;
    for (var f in c)
      return !1;
    if (typeof Object.keys == "function" && Object.keys(c).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(c).length !== 0)
      return !1;
    var n = Object.getOwnPropertySymbols(c);
    if (n.length !== 1 || n[0] !== l || !Object.prototype.propertyIsEnumerable.call(c, l))
      return !1;
    if (typeof Object.getOwnPropertyDescriptor == "function") {
      var u = (
        /** @type {PropertyDescriptor} */
        Object.getOwnPropertyDescriptor(c, l)
      );
      if (u.value !== m || u.enumerable !== !0)
        return !1;
    }
    return !0;
  }), Sf;
}
var Ef, r5;
function Xl() {
  if (r5) return Ef;
  r5 = 1;
  var e = typeof Symbol < "u" && Symbol, c = po();
  return Ef = function() {
    return typeof e != "function" || typeof Symbol != "function" || typeof e("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : c();
  }, Ef;
}
var If, i5;
function ep() {
  return i5 || (i5 = 1, If = typeof Reflect < "u" && Reflect.getPrototypeOf || null), If;
}
var Af, n5;
function tp() {
  if (n5) return Af;
  n5 = 1;
  var e = /* @__PURE__ */ Yl();
  return Af = e.getPrototypeOf || null, Af;
}
var Of, s5;
function Zx() {
  if (s5) return Of;
  s5 = 1;
  var e = "Function.prototype.bind called on incompatible ", c = Object.prototype.toString, l = Math.max, w = "[object Function]", m = function(o, s) {
    for (var i = [], p = 0; p < o.length; p += 1)
      i[p] = o[p];
    for (var g = 0; g < s.length; g += 1)
      i[g + o.length] = s[g];
    return i;
  }, f = function(o, s) {
    for (var i = [], p = s, g = 0; p < o.length; p += 1, g += 1)
      i[g] = o[p];
    return i;
  }, n = function(u, o) {
    for (var s = "", i = 0; i < u.length; i += 1)
      s += u[i], i + 1 < u.length && (s += o);
    return s;
  };
  return Of = function(o) {
    var s = this;
    if (typeof s != "function" || c.apply(s) !== w)
      throw new TypeError(e + s);
    for (var i = f(arguments, 1), p, g = function() {
      if (this instanceof p) {
        var a = s.apply(
          this,
          m(i, arguments)
        );
        return Object(a) === a ? a : this;
      }
      return s.apply(
        o,
        m(i, arguments)
      );
    }, S = l(0, s.length - i.length), y = [], b = 0; b < S; b++)
      y[b] = "$" + b;
    if (p = Function("binder", "return function (" + n(y, ",") + "){ return binder.apply(this,arguments); }")(g), s.prototype) {
      var h = function() {
      };
      h.prototype = s.prototype, p.prototype = new h(), h.prototype = null;
    }
    return p;
  }, Of;
}
var _f, o5;
function os() {
  if (o5) return _f;
  o5 = 1;
  var e = Zx();
  return _f = Function.prototype.bind || e, _f;
}
var Rf, a5;
function Gl() {
  return a5 || (a5 = 1, Rf = Function.prototype.call), Rf;
}
var Pf, f5;
function Jl() {
  return f5 || (f5 = 1, Pf = Function.prototype.apply), Pf;
}
var kf, c5;
function Qx() {
  return c5 || (c5 = 1, kf = typeof Reflect < "u" && Reflect && Reflect.apply), kf;
}
var Bf, u5;
function rp() {
  if (u5) return Bf;
  u5 = 1;
  var e = os(), c = Jl(), l = Gl(), w = Qx();
  return Bf = w || e.call(l, c), Bf;
}
var Mf, h5;
function Wl() {
  if (h5) return Mf;
  h5 = 1;
  var e = os(), c = /* @__PURE__ */ Ir(), l = Gl(), w = rp();
  return Mf = function(f) {
    if (f.length < 1 || typeof f[0] != "function")
      throw new c("a function is required");
    return w(e, l, f);
  }, Mf;
}
var Nf, l5;
function ew() {
  if (l5) return Nf;
  l5 = 1;
  var e = Wl(), c = /* @__PURE__ */ ji(), l;
  try {
    l = /** @type {{ __proto__?: typeof Array.prototype }} */
    [].__proto__ === Array.prototype;
  } catch (n) {
    if (!n || typeof n != "object" || !("code" in n) || n.code !== "ERR_PROTO_ACCESS")
      throw n;
  }
  var w = !!l && c && c(
    Object.prototype,
    /** @type {keyof typeof Object.prototype} */
    "__proto__"
  ), m = Object, f = m.getPrototypeOf;
  return Nf = w && typeof w.get == "function" ? e([w.get]) : typeof f == "function" ? (
    /** @type {import('./get')} */
    function(u) {
      return f(u == null ? u : m(u));
    }
  ) : !1, Nf;
}
var qf, d5;
function mo() {
  if (d5) return qf;
  d5 = 1;
  var e = ep(), c = tp(), l = /* @__PURE__ */ ew();
  return qf = e ? function(m) {
    return e(m);
  } : c ? function(m) {
    if (!m || typeof m != "object" && typeof m != "function")
      throw new TypeError("getProto: not an object");
    return c(m);
  } : l ? function(m) {
    return l(m);
  } : null, qf;
}
var Tf, b5;
function Zl() {
  if (b5) return Tf;
  b5 = 1;
  var e = Function.prototype.call, c = Object.prototype.hasOwnProperty, l = os();
  return Tf = l.call(e, c), Tf;
}
var zf, p5;
function ai() {
  if (p5) return zf;
  p5 = 1;
  var e, c = /* @__PURE__ */ Yl(), l = /* @__PURE__ */ Q7(), w = /* @__PURE__ */ Fx(), m = /* @__PURE__ */ Hx(), f = /* @__PURE__ */ Lx(), n = /* @__PURE__ */ Vl(), u = /* @__PURE__ */ Ir(), o = /* @__PURE__ */ Kx(), s = /* @__PURE__ */ Vx(), i = /* @__PURE__ */ $x(), p = /* @__PURE__ */ jx(), g = /* @__PURE__ */ Yx(), S = /* @__PURE__ */ Xx(), y = /* @__PURE__ */ Gx(), b = /* @__PURE__ */ Wx(), h = Function, a = function(I) {
    try {
      return h('"use strict"; return (' + I + ").constructor;")();
    } catch {
    }
  }, E = /* @__PURE__ */ ji(), H = /* @__PURE__ */ bo(), j = function() {
    throw new u();
  }, G = E ? function() {
    try {
      return arguments.callee, j;
    } catch {
      try {
        return E(arguments, "callee").get;
      } catch {
        return j;
      }
    }
  }() : j, N = Xl()(), T = mo(), A = tp(), q = ep(), _ = Jl(), F = Gl(), R = {}, L = typeof Uint8Array > "u" || !T ? e : T(Uint8Array), fe = {
    __proto__: null,
    "%AggregateError%": typeof AggregateError > "u" ? e : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer > "u" ? e : ArrayBuffer,
    "%ArrayIteratorPrototype%": N && T ? T([][Symbol.iterator]()) : e,
    "%AsyncFromSyncIteratorPrototype%": e,
    "%AsyncFunction%": R,
    "%AsyncGenerator%": R,
    "%AsyncGeneratorFunction%": R,
    "%AsyncIteratorPrototype%": R,
    "%Atomics%": typeof Atomics > "u" ? e : Atomics,
    "%BigInt%": typeof BigInt > "u" ? e : BigInt,
    "%BigInt64Array%": typeof BigInt64Array > "u" ? e : BigInt64Array,
    "%BigUint64Array%": typeof BigUint64Array > "u" ? e : BigUint64Array,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView > "u" ? e : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": l,
    "%eval%": eval,
    // eslint-disable-line no-eval
    "%EvalError%": w,
    "%Float16Array%": typeof Float16Array > "u" ? e : Float16Array,
    "%Float32Array%": typeof Float32Array > "u" ? e : Float32Array,
    "%Float64Array%": typeof Float64Array > "u" ? e : Float64Array,
    "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? e : FinalizationRegistry,
    "%Function%": h,
    "%GeneratorFunction%": R,
    "%Int8Array%": typeof Int8Array > "u" ? e : Int8Array,
    "%Int16Array%": typeof Int16Array > "u" ? e : Int16Array,
    "%Int32Array%": typeof Int32Array > "u" ? e : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": N && T ? T(T([][Symbol.iterator]())) : e,
    "%JSON%": typeof JSON == "object" ? JSON : e,
    "%Map%": typeof Map > "u" ? e : Map,
    "%MapIteratorPrototype%": typeof Map > "u" || !N || !T ? e : T((/* @__PURE__ */ new Map())[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": c,
    "%Object.getOwnPropertyDescriptor%": E,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise > "u" ? e : Promise,
    "%Proxy%": typeof Proxy > "u" ? e : Proxy,
    "%RangeError%": m,
    "%ReferenceError%": f,
    "%Reflect%": typeof Reflect > "u" ? e : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set > "u" ? e : Set,
    "%SetIteratorPrototype%": typeof Set > "u" || !N || !T ? e : T((/* @__PURE__ */ new Set())[Symbol.iterator]()),
    "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? e : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": N && T ? T(""[Symbol.iterator]()) : e,
    "%Symbol%": N ? Symbol : e,
    "%SyntaxError%": n,
    "%ThrowTypeError%": G,
    "%TypedArray%": L,
    "%TypeError%": u,
    "%Uint8Array%": typeof Uint8Array > "u" ? e : Uint8Array,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? e : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array > "u" ? e : Uint16Array,
    "%Uint32Array%": typeof Uint32Array > "u" ? e : Uint32Array,
    "%URIError%": o,
    "%WeakMap%": typeof WeakMap > "u" ? e : WeakMap,
    "%WeakRef%": typeof WeakRef > "u" ? e : WeakRef,
    "%WeakSet%": typeof WeakSet > "u" ? e : WeakSet,
    "%Function.prototype.call%": F,
    "%Function.prototype.apply%": _,
    "%Object.defineProperty%": H,
    "%Object.getPrototypeOf%": A,
    "%Math.abs%": s,
    "%Math.floor%": i,
    "%Math.max%": p,
    "%Math.min%": g,
    "%Math.pow%": S,
    "%Math.round%": y,
    "%Math.sign%": b,
    "%Reflect.getPrototypeOf%": q
  };
  if (T)
    try {
      null.error;
    } catch (I) {
      var ue = T(T(I));
      fe["%Error.prototype%"] = ue;
    }
  var ae = function I(ne) {
    var t;
    if (ne === "%AsyncFunction%")
      t = a("async function () {}");
    else if (ne === "%GeneratorFunction%")
      t = a("function* () {}");
    else if (ne === "%AsyncGeneratorFunction%")
      t = a("async function* () {}");
    else if (ne === "%AsyncGenerator%") {
      var d = I("%AsyncGeneratorFunction%");
      d && (t = d.prototype);
    } else if (ne === "%AsyncIteratorPrototype%") {
      var B = I("%AsyncGenerator%");
      B && T && (t = T(B.prototype));
    }
    return fe[ne] = t, t;
  }, D = {
    __proto__: null,
    "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
    "%ArrayPrototype%": ["Array", "prototype"],
    "%ArrayProto_entries%": ["Array", "prototype", "entries"],
    "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
    "%ArrayProto_keys%": ["Array", "prototype", "keys"],
    "%ArrayProto_values%": ["Array", "prototype", "values"],
    "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
    "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
    "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
    "%BooleanPrototype%": ["Boolean", "prototype"],
    "%DataViewPrototype%": ["DataView", "prototype"],
    "%DatePrototype%": ["Date", "prototype"],
    "%ErrorPrototype%": ["Error", "prototype"],
    "%EvalErrorPrototype%": ["EvalError", "prototype"],
    "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
    "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
    "%FunctionPrototype%": ["Function", "prototype"],
    "%Generator%": ["GeneratorFunction", "prototype"],
    "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
    "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
    "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
    "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
    "%JSONParse%": ["JSON", "parse"],
    "%JSONStringify%": ["JSON", "stringify"],
    "%MapPrototype%": ["Map", "prototype"],
    "%NumberPrototype%": ["Number", "prototype"],
    "%ObjectPrototype%": ["Object", "prototype"],
    "%ObjProto_toString%": ["Object", "prototype", "toString"],
    "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
    "%PromisePrototype%": ["Promise", "prototype"],
    "%PromiseProto_then%": ["Promise", "prototype", "then"],
    "%Promise_all%": ["Promise", "all"],
    "%Promise_reject%": ["Promise", "reject"],
    "%Promise_resolve%": ["Promise", "resolve"],
    "%RangeErrorPrototype%": ["RangeError", "prototype"],
    "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
    "%RegExpPrototype%": ["RegExp", "prototype"],
    "%SetPrototype%": ["Set", "prototype"],
    "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
    "%StringPrototype%": ["String", "prototype"],
    "%SymbolPrototype%": ["Symbol", "prototype"],
    "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
    "%TypedArrayPrototype%": ["TypedArray", "prototype"],
    "%TypeErrorPrototype%": ["TypeError", "prototype"],
    "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
    "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
    "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
    "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
    "%URIErrorPrototype%": ["URIError", "prototype"],
    "%WeakMapPrototype%": ["WeakMap", "prototype"],
    "%WeakSetPrototype%": ["WeakSet", "prototype"]
  }, Q = os(), W = /* @__PURE__ */ Zl(), oe = Q.call(F, Array.prototype.concat), v = Q.call(_, Array.prototype.splice), Y = Q.call(F, String.prototype.replace), he = Q.call(F, String.prototype.slice), le = Q.call(F, RegExp.prototype.exec), ge = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, Ee = /\\(\\)?/g, we = function(ne) {
    var t = he(ne, 0, 1), d = he(ne, -1);
    if (t === "%" && d !== "%")
      throw new n("invalid intrinsic syntax, expected closing `%`");
    if (d === "%" && t !== "%")
      throw new n("invalid intrinsic syntax, expected opening `%`");
    var B = [];
    return Y(ne, ge, function(U, J, C, M) {
      B[B.length] = C ? Y(M, Ee, "$1") : J || U;
    }), B;
  }, z = function(ne, t) {
    var d = ne, B;
    if (W(D, d) && (B = D[d], d = "%" + B[0] + "%"), W(fe, d)) {
      var U = fe[d];
      if (U === R && (U = ae(d)), typeof U > "u" && !t)
        throw new u("intrinsic " + ne + " exists, but is not available. Please file an issue!");
      return {
        alias: B,
        name: d,
        value: U
      };
    }
    throw new n("intrinsic " + ne + " does not exist!");
  };
  return zf = function(ne, t) {
    if (typeof ne != "string" || ne.length === 0)
      throw new u("intrinsic name must be a non-empty string");
    if (arguments.length > 1 && typeof t != "boolean")
      throw new u('"allowMissing" argument must be a boolean');
    if (le(/^%?[^%]*%?$/, ne) === null)
      throw new n("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    var d = we(ne), B = d.length > 0 ? d[0] : "", U = z("%" + B + "%", t), J = U.name, C = U.value, M = !1, $ = U.alias;
    $ && (B = $[0], v(d, oe([0, 1], $)));
    for (var r = 1, x = !0; r < d.length; r += 1) {
      var O = d[r], K = he(O, 0, 1), X = he(O, -1);
      if ((K === '"' || K === "'" || K === "`" || X === '"' || X === "'" || X === "`") && K !== X)
        throw new n("property names with quotes must have matching quotes");
      if ((O === "constructor" || !x) && (M = !0), B += "." + O, J = "%" + B + "%", W(fe, J))
        C = fe[J];
      else if (C != null) {
        if (!(O in C)) {
          if (!t)
            throw new u("base intrinsic for " + ne + " exists, but the property is not available.");
          return;
        }
        if (E && r + 1 >= d.length) {
          var P = E(C, O);
          x = !!P, x && "get" in P && !("originalValue" in P.get) ? C = P.get : C = C[O];
        } else
          x = W(C, O), C = C[O];
        x && !M && (fe[J] = C);
      }
    }
    return C;
  }, zf;
}
var Cf, m5;
function tw() {
  if (m5) return Cf;
  m5 = 1;
  var e = /* @__PURE__ */ ai(), c = /* @__PURE__ */ $l(), l = /* @__PURE__ */ jl()(), w = /* @__PURE__ */ ji(), m = /* @__PURE__ */ Ir(), f = e("%Math.floor%");
  return Cf = function(u, o) {
    if (typeof u != "function")
      throw new m("`fn` is not a function");
    if (typeof o != "number" || o < 0 || o > 4294967295 || f(o) !== o)
      throw new m("`length` must be a positive 32-bit integer");
    var s = arguments.length > 2 && !!arguments[2], i = !0, p = !0;
    if ("length" in u && w) {
      var g = w(u, "length");
      g && !g.configurable && (i = !1), g && !g.writable && (p = !1);
    }
    return (i || p || !s) && (l ? c(
      /** @type {Parameters<define>[0]} */
      u,
      "length",
      o,
      !0,
      !0
    ) : c(
      /** @type {Parameters<define>[0]} */
      u,
      "length",
      o
    )), u;
  }, Cf;
}
var Df, g5;
function rw() {
  if (g5) return Df;
  g5 = 1;
  var e = os(), c = Jl(), l = rp();
  return Df = function() {
    return l(e, c, arguments);
  }, Df;
}
var x5;
function Yi() {
  return x5 || (x5 = 1, function(e) {
    var c = /* @__PURE__ */ tw(), l = /* @__PURE__ */ bo(), w = Wl(), m = rw();
    e.exports = function(n) {
      var u = w(arguments), o = n.length - (arguments.length - 1);
      return c(
        u,
        1 + (o > 0 ? o : 0),
        !0
      );
    }, l ? l(e.exports, "apply", { value: m }) : e.exports.apply = m;
  }(af)), af.exports;
}
var Uf, w5;
function Gt() {
  if (w5) return Uf;
  w5 = 1;
  var e = /* @__PURE__ */ ai(), c = Wl(), l = c([e("%String.prototype.indexOf%")]);
  return Uf = function(m, f) {
    var n = (
      /** @type {(this: unknown, ...args: unknown[]) => unknown} */
      e(m, !!f)
    );
    return typeof n == "function" && l(m, ".prototype.") > -1 ? c(
      /** @type {const} */
      [n]
    ) : n;
  }, Uf;
}
var Ff, y5;
function ip() {
  if (y5) return Ff;
  y5 = 1;
  var e = Kl(), c = po()(), l = /* @__PURE__ */ Gt(), w = /* @__PURE__ */ Yl(), m = l("Array.prototype.push"), f = l("Object.prototype.propertyIsEnumerable"), n = c ? w.getOwnPropertySymbols : null;
  return Ff = function(o, s) {
    if (o == null)
      throw new TypeError("target must be an object");
    var i = w(o);
    if (arguments.length === 1)
      return i;
    for (var p = 1; p < arguments.length; ++p) {
      var g = w(arguments[p]), S = e(g), y = c && (w.getOwnPropertySymbols || n);
      if (y)
        for (var b = y(g), h = 0; h < b.length; ++h) {
          var a = b[h];
          f(g, a) && m(S, a);
        }
      for (var E = 0; E < S.length; ++E) {
        var H = S[E];
        if (f(g, H)) {
          var j = g[H];
          i[H] = j;
        }
      }
    }
    return i;
  }, Ff;
}
var Hf, v5;
function Ql() {
  if (v5) return Hf;
  v5 = 1;
  var e = ip(), c = function() {
    if (!Object.assign)
      return !1;
    for (var w = "abcdefghijklmnopqrst", m = w.split(""), f = {}, n = 0; n < m.length; ++n)
      f[m[n]] = m[n];
    var u = Object.assign({}, f), o = "";
    for (var s in u)
      o += s;
    return w !== o;
  }, l = function() {
    if (!Object.assign || !Object.preventExtensions)
      return !1;
    var w = Object.preventExtensions({ 1: 2 });
    try {
      Object.assign(w, "xy");
    } catch {
      return w[1] === "y";
    }
    return !1;
  };
  return Hf = function() {
    return !Object.assign || c() || l() ? e : Object.assign;
  }, Hf;
}
var Lf, S5;
function iw() {
  if (S5) return Lf;
  S5 = 1;
  var e = oi(), c = Ql();
  return Lf = function() {
    var w = c();
    return e(
      Object,
      { assign: w },
      { assign: function() {
        return Object.assign !== w;
      } }
    ), w;
  }, Lf;
}
var Kf, E5;
function nw() {
  if (E5) return Kf;
  E5 = 1;
  var e = oi(), c = Yi(), l = ip(), w = Ql(), m = iw(), f = c.apply(w()), n = function(o, s) {
    return f(Object, arguments);
  };
  return e(n, {
    getPolyfill: w,
    implementation: l,
    shim: m
  }), Kf = n, Kf;
}
var Vf, I5;
function e1() {
  if (I5) return Vf;
  I5 = 1;
  var e = /* @__PURE__ */ ai(), c = Yi(), l = c(e("String.prototype.indexOf"));
  return Vf = function(m, f) {
    var n = e(m, !!f);
    return typeof n == "function" && l(m, ".prototype.") > -1 ? c(n) : n;
  }, Vf;
}
var $f, A5;
function sw() {
  if (A5) return $f;
  A5 = 1;
  var e = function() {
    return typeof (function() {
    }).name == "string";
  }, c = Object.getOwnPropertyDescriptor;
  if (c)
    try {
      c([], "length");
    } catch {
      c = null;
    }
  e.functionsHaveConfigurableNames = function() {
    if (!e() || !c)
      return !1;
    var m = c(function() {
    }, "name");
    return !!m && !!m.configurable;
  };
  var l = Function.prototype.bind;
  return e.boundFunctionsHaveNames = function() {
    return e() && typeof l == "function" && (function() {
    }).bind().name !== "";
  }, $f = e, $f;
}
var jf, O5;
function ow() {
  if (O5) return jf;
  O5 = 1;
  var e = /* @__PURE__ */ $l(), c = /* @__PURE__ */ jl()(), l = sw().functionsHaveConfigurableNames(), w = /* @__PURE__ */ Ir();
  return jf = function(f, n) {
    if (typeof f != "function")
      throw new w("`fn` is not a function");
    var u = arguments.length > 2 && !!arguments[2];
    return (!u || l) && (c ? e(
      /** @type {Parameters<define>[0]} */
      f,
      "name",
      n,
      !0,
      !0
    ) : e(
      /** @type {Parameters<define>[0]} */
      f,
      "name",
      n
    )), f;
  }, jf;
}
var Yf, _5;
function np() {
  if (_5) return Yf;
  _5 = 1;
  var e = ow(), c = /* @__PURE__ */ Ir(), l = Object;
  return Yf = e(function() {
    if (this == null || this !== l(this))
      throw new c("RegExp.prototype.flags getter called on non-object");
    var m = "";
    return this.hasIndices && (m += "d"), this.global && (m += "g"), this.ignoreCase && (m += "i"), this.multiline && (m += "m"), this.dotAll && (m += "s"), this.unicode && (m += "u"), this.unicodeSets && (m += "v"), this.sticky && (m += "y"), m;
  }, "get flags", !0), Yf;
}
var Xf, R5;
function sp() {
  if (R5) return Xf;
  R5 = 1;
  var e = np(), c = oi().supportsDescriptors, l = Object.getOwnPropertyDescriptor;
  return Xf = function() {
    if (c && /a/mig.flags === "gim") {
      var m = l(RegExp.prototype, "flags");
      if (m && typeof m.get == "function" && "dotAll" in RegExp.prototype && "hasIndices" in RegExp.prototype) {
        var f = "", n = {};
        if (Object.defineProperty(n, "hasIndices", {
          get: function() {
            f += "d";
          }
        }), Object.defineProperty(n, "sticky", {
          get: function() {
            f += "y";
          }
        }), m.get.call(n), f === "dy")
          return m.get;
      }
    }
    return e;
  }, Xf;
}
var Gf, P5;
function aw() {
  if (P5) return Gf;
  P5 = 1;
  var e = oi().supportsDescriptors, c = sp(), l = /* @__PURE__ */ ji(), w = Object.defineProperty, m = /* @__PURE__ */ Q7(), f = mo(), n = /a/;
  return Gf = function() {
    if (!e || !f)
      throw new m("RegExp.prototype.flags requires a true ES5 environment that supports property descriptors");
    var o = c(), s = f(n), i = l(s, "flags");
    return (!i || i.get !== o) && w(s, "flags", {
      configurable: !0,
      enumerable: !1,
      get: o
    }), o;
  }, Gf;
}
var Jf, k5;
function fw() {
  if (k5) return Jf;
  k5 = 1;
  var e = oi(), c = Yi(), l = np(), w = sp(), m = aw(), f = c(w());
  return e(f, {
    getPolyfill: w,
    implementation: l,
    shim: m
  }), Jf = f, Jf;
}
var Un = { exports: {} }, Wf, B5;
function xi() {
  if (B5) return Wf;
  B5 = 1;
  var e = po();
  return Wf = function() {
    return e() && !!Symbol.toStringTag;
  }, Wf;
}
var Zf, M5;
function t1() {
  if (M5) return Zf;
  M5 = 1;
  var e = xi()(), c = /* @__PURE__ */ Gt(), l = c("Object.prototype.toString"), w = function(u) {
    return e && u && typeof u == "object" && Symbol.toStringTag in u ? !1 : l(u) === "[object Arguments]";
  }, m = function(u) {
    return w(u) ? !0 : u !== null && typeof u == "object" && "length" in u && typeof u.length == "number" && u.length >= 0 && l(u) !== "[object Array]" && "callee" in u && l(u.callee) === "[object Function]";
  }, f = function() {
    return w(arguments);
  }();
  return w.isLegacyArguments = m, Zf = f ? w : m, Zf;
}
const cw = {}, uw = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: cw
}, Symbol.toStringTag, { value: "Module" })), hw = /* @__PURE__ */ im(uw);
var Qf, N5;
function go() {
  if (N5) return Qf;
  N5 = 1;
  var e = typeof Map == "function" && Map.prototype, c = Object.getOwnPropertyDescriptor && e ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null, l = e && c && typeof c.get == "function" ? c.get : null, w = e && Map.prototype.forEach, m = typeof Set == "function" && Set.prototype, f = Object.getOwnPropertyDescriptor && m ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null, n = m && f && typeof f.get == "function" ? f.get : null, u = m && Set.prototype.forEach, o = typeof WeakMap == "function" && WeakMap.prototype, s = o ? WeakMap.prototype.has : null, i = typeof WeakSet == "function" && WeakSet.prototype, p = i ? WeakSet.prototype.has : null, g = typeof WeakRef == "function" && WeakRef.prototype, S = g ? WeakRef.prototype.deref : null, y = Boolean.prototype.valueOf, b = Object.prototype.toString, h = Function.prototype.toString, a = String.prototype.match, E = String.prototype.slice, H = String.prototype.replace, j = String.prototype.toUpperCase, G = String.prototype.toLowerCase, N = RegExp.prototype.test, T = Array.prototype.concat, A = Array.prototype.join, q = Array.prototype.slice, _ = Math.floor, F = typeof BigInt == "function" ? BigInt.prototype.valueOf : null, R = Object.getOwnPropertySymbols, L = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Symbol.prototype.toString : null, fe = typeof Symbol == "function" && typeof Symbol.iterator == "object", ue = typeof Symbol == "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === fe || !0) ? Symbol.toStringTag : null, ae = Object.prototype.propertyIsEnumerable, D = (typeof Reflect == "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(ye) {
    return ye.__proto__;
  } : null);
  function Q(ye, _e) {
    if (ye === 1 / 0 || ye === -1 / 0 || ye !== ye || ye && ye > -1e3 && ye < 1e3 || N.call(/e/, _e))
      return _e;
    var ke = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
    if (typeof ye == "number") {
      var Me = ye < 0 ? -_(-ye) : _(ye);
      if (Me !== ye) {
        var De = String(Me), Ne = E.call(_e, De.length + 1);
        return H.call(De, ke, "$&_") + "." + H.call(H.call(Ne, /([0-9]{3})/g, "$&_"), /_$/, "");
      }
    }
    return H.call(_e, ke, "$&_");
  }
  var W = hw, oe = W.custom, v = U(oe) ? oe : null, Y = {
    __proto__: null,
    double: '"',
    single: "'"
  }, he = {
    __proto__: null,
    double: /(["\\])/g,
    single: /(['\\])/g
  };
  Qf = function ye(_e, ke, Me, De) {
    var Ne = ke || {};
    if (M(Ne, "quoteStyle") && !M(Y, Ne.quoteStyle))
      throw new TypeError('option "quoteStyle" must be "single" or "double"');
    if (M(Ne, "maxStringLength") && (typeof Ne.maxStringLength == "number" ? Ne.maxStringLength < 0 && Ne.maxStringLength !== 1 / 0 : Ne.maxStringLength !== null))
      throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
    var $e = M(Ne, "customInspect") ? Ne.customInspect : !0;
    if (typeof $e != "boolean" && $e !== "symbol")
      throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
    if (M(Ne, "indent") && Ne.indent !== null && Ne.indent !== "	" && !(parseInt(Ne.indent, 10) === Ne.indent && Ne.indent > 0))
      throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
    if (M(Ne, "numericSeparator") && typeof Ne.numericSeparator != "boolean")
      throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
    var bt = Ne.numericSeparator;
    if (typeof _e > "u")
      return "undefined";
    if (_e === null)
      return "null";
    if (typeof _e == "boolean")
      return _e ? "true" : "false";
    if (typeof _e == "string")
      return ce(_e, Ne);
    if (typeof _e == "number") {
      if (_e === 0)
        return 1 / 0 / _e > 0 ? "0" : "-0";
      var Ve = String(_e);
      return bt ? Q(_e, Ve) : Ve;
    }
    if (typeof _e == "bigint") {
      var je = String(_e) + "n";
      return bt ? Q(_e, je) : je;
    }
    var _t = typeof Ne.depth > "u" ? 5 : Ne.depth;
    if (typeof Me > "u" && (Me = 0), Me >= _t && _t > 0 && typeof _e == "object")
      return we(_e) ? "[Array]" : "[Object]";
    var Je = me(Ne, Me);
    if (typeof De > "u")
      De = [];
    else if (x(De, _e) >= 0)
      return "[Circular]";
    function Ye(tt, it, _r) {
      if (it && (De = q.call(De), De.push(it)), _r) {
        var st = {
          depth: Ne.depth
        };
        return M(Ne, "quoteStyle") && (st.quoteStyle = Ne.quoteStyle), ye(tt, st, Me + 1, De);
      }
      return ye(tt, Ne, Me + 1, De);
    }
    if (typeof _e == "function" && !I(_e)) {
      var Ot = r(_e), We = Oe(_e, Ye);
      return "[Function" + (Ot ? ": " + Ot : " (anonymous)") + "]" + (We.length > 0 ? " { " + A.call(We, ", ") + " }" : "");
    }
    if (U(_e)) {
      var Ze = fe ? H.call(String(_e), /^(Symbol\(.*\))_[^)]*$/, "$1") : L.call(_e);
      return typeof _e == "object" && !fe ? pe(Ze) : Ze;
    }
    if (re(_e)) {
      for (var Tt = "<" + G.call(String(_e.nodeName)), Qe = _e.attributes || [], rt = 0; rt < Qe.length; rt++)
        Tt += " " + Qe[rt].name + "=" + le(ge(Qe[rt].value), "double", Ne);
      return Tt += ">", _e.childNodes && _e.childNodes.length && (Tt += "..."), Tt += "</" + G.call(String(_e.nodeName)) + ">", Tt;
    }
    if (we(_e)) {
      if (_e.length === 0)
        return "[]";
      var ur = Oe(_e, Ye);
      return Je && !ee(ur) ? "[" + Ae(ur, Je) + "]" : "[ " + A.call(ur, ", ") + " ]";
    }
    if (ne(_e)) {
      var nt = Oe(_e, Ye);
      return !("cause" in Error.prototype) && "cause" in _e && !ae.call(_e, "cause") ? "{ [" + String(_e) + "] " + A.call(T.call("[cause]: " + Ye(_e.cause), nt), ", ") + " }" : nt.length === 0 ? "[" + String(_e) + "]" : "{ [" + String(_e) + "] " + A.call(nt, ", ") + " }";
    }
    if (typeof _e == "object" && $e) {
      if (v && typeof _e[v] == "function" && W)
        return W(_e, { depth: _t - Me });
      if ($e !== "symbol" && typeof _e.inspect == "function")
        return _e.inspect();
    }
    if (O(_e)) {
      var ft = [];
      return w && w.call(_e, function(tt, it) {
        ft.push(Ye(it, _e, !0) + " => " + Ye(tt, _e));
      }), Z("Map", l.call(_e), ft, Je);
    }
    if (P(_e)) {
      var gr = [];
      return u && u.call(_e, function(tt) {
        gr.push(Ye(tt, _e));
      }), Z("Set", n.call(_e), gr, Je);
    }
    if (K(_e))
      return se("WeakMap");
    if (V(_e))
      return se("WeakSet");
    if (X(_e))
      return se("WeakRef");
    if (d(_e))
      return pe(Ye(Number(_e)));
    if (J(_e))
      return pe(Ye(F.call(_e)));
    if (B(_e))
      return pe(y.call(_e));
    if (t(_e))
      return pe(Ye(String(_e)));
    if (typeof window < "u" && _e === window)
      return "{ [object Window] }";
    if (typeof globalThis < "u" && _e === globalThis || typeof Ft < "u" && _e === Ft)
      return "{ [object globalThis] }";
    if (!z(_e) && !I(_e)) {
      var et = Oe(_e, Ye), ct = D ? D(_e) === Object.prototype : _e instanceof Object || _e.constructor === Object, hr = _e instanceof Object ? "" : "null prototype", ut = !ct && ue && Object(_e) === _e && ue in _e ? E.call($(_e), 8, -1) : hr ? "Object" : "", lt = ct || typeof _e.constructor != "function" ? "" : _e.constructor.name ? _e.constructor.name + " " : "", lr = lt + (ut || hr ? "[" + A.call(T.call([], ut || [], hr || []), ": ") + "] " : "");
      return et.length === 0 ? lr + "{}" : Je ? lr + "{" + Ae(et, Je) + "}" : lr + "{ " + A.call(et, ", ") + " }";
    }
    return String(_e);
  };
  function le(ye, _e, ke) {
    var Me = ke.quoteStyle || _e, De = Y[Me];
    return De + ye + De;
  }
  function ge(ye) {
    return H.call(String(ye), /"/g, "&quot;");
  }
  function Ee(ye) {
    return !ue || !(typeof ye == "object" && (ue in ye || typeof ye[ue] < "u"));
  }
  function we(ye) {
    return $(ye) === "[object Array]" && Ee(ye);
  }
  function z(ye) {
    return $(ye) === "[object Date]" && Ee(ye);
  }
  function I(ye) {
    return $(ye) === "[object RegExp]" && Ee(ye);
  }
  function ne(ye) {
    return $(ye) === "[object Error]" && Ee(ye);
  }
  function t(ye) {
    return $(ye) === "[object String]" && Ee(ye);
  }
  function d(ye) {
    return $(ye) === "[object Number]" && Ee(ye);
  }
  function B(ye) {
    return $(ye) === "[object Boolean]" && Ee(ye);
  }
  function U(ye) {
    if (fe)
      return ye && typeof ye == "object" && ye instanceof Symbol;
    if (typeof ye == "symbol")
      return !0;
    if (!ye || typeof ye != "object" || !L)
      return !1;
    try {
      return L.call(ye), !0;
    } catch {
    }
    return !1;
  }
  function J(ye) {
    if (!ye || typeof ye != "object" || !F)
      return !1;
    try {
      return F.call(ye), !0;
    } catch {
    }
    return !1;
  }
  var C = Object.prototype.hasOwnProperty || function(ye) {
    return ye in this;
  };
  function M(ye, _e) {
    return C.call(ye, _e);
  }
  function $(ye) {
    return b.call(ye);
  }
  function r(ye) {
    if (ye.name)
      return ye.name;
    var _e = a.call(h.call(ye), /^function\s*([\w$]+)/);
    return _e ? _e[1] : null;
  }
  function x(ye, _e) {
    if (ye.indexOf)
      return ye.indexOf(_e);
    for (var ke = 0, Me = ye.length; ke < Me; ke++)
      if (ye[ke] === _e)
        return ke;
    return -1;
  }
  function O(ye) {
    if (!l || !ye || typeof ye != "object")
      return !1;
    try {
      l.call(ye);
      try {
        n.call(ye);
      } catch {
        return !0;
      }
      return ye instanceof Map;
    } catch {
    }
    return !1;
  }
  function K(ye) {
    if (!s || !ye || typeof ye != "object")
      return !1;
    try {
      s.call(ye, s);
      try {
        p.call(ye, p);
      } catch {
        return !0;
      }
      return ye instanceof WeakMap;
    } catch {
    }
    return !1;
  }
  function X(ye) {
    if (!S || !ye || typeof ye != "object")
      return !1;
    try {
      return S.call(ye), !0;
    } catch {
    }
    return !1;
  }
  function P(ye) {
    if (!n || !ye || typeof ye != "object")
      return !1;
    try {
      n.call(ye);
      try {
        l.call(ye);
      } catch {
        return !0;
      }
      return ye instanceof Set;
    } catch {
    }
    return !1;
  }
  function V(ye) {
    if (!p || !ye || typeof ye != "object")
      return !1;
    try {
      p.call(ye, p);
      try {
        s.call(ye, s);
      } catch {
        return !0;
      }
      return ye instanceof WeakSet;
    } catch {
    }
    return !1;
  }
  function re(ye) {
    return !ye || typeof ye != "object" ? !1 : typeof HTMLElement < "u" && ye instanceof HTMLElement ? !0 : typeof ye.nodeName == "string" && typeof ye.getAttribute == "function";
  }
  function ce(ye, _e) {
    if (ye.length > _e.maxStringLength) {
      var ke = ye.length - _e.maxStringLength, Me = "... " + ke + " more character" + (ke > 1 ? "s" : "");
      return ce(E.call(ye, 0, _e.maxStringLength), _e) + Me;
    }
    var De = he[_e.quoteStyle || "single"];
    De.lastIndex = 0;
    var Ne = H.call(H.call(ye, De, "\\$1"), /[\x00-\x1f]/g, de);
    return le(Ne, "single", _e);
  }
  function de(ye) {
    var _e = ye.charCodeAt(0), ke = {
      8: "b",
      9: "t",
      10: "n",
      12: "f",
      13: "r"
    }[_e];
    return ke ? "\\" + ke : "\\x" + (_e < 16 ? "0" : "") + j.call(_e.toString(16));
  }
  function pe(ye) {
    return "Object(" + ye + ")";
  }
  function se(ye) {
    return ye + " { ? }";
  }
  function Z(ye, _e, ke, Me) {
    var De = Me ? Ae(ke, Me) : A.call(ke, ", ");
    return ye + " (" + _e + ") {" + De + "}";
  }
  function ee(ye) {
    for (var _e = 0; _e < ye.length; _e++)
      if (x(ye[_e], `
`) >= 0)
        return !1;
    return !0;
  }
  function me(ye, _e) {
    var ke;
    if (ye.indent === "	")
      ke = "	";
    else if (typeof ye.indent == "number" && ye.indent > 0)
      ke = A.call(Array(ye.indent + 1), " ");
    else
      return null;
    return {
      base: ke,
      prev: A.call(Array(_e + 1), ke)
    };
  }
  function Ae(ye, _e) {
    if (ye.length === 0)
      return "";
    var ke = `
` + _e.prev + _e.base;
    return ke + A.call(ye, "," + ke) + `
` + _e.prev;
  }
  function Oe(ye, _e) {
    var ke = we(ye), Me = [];
    if (ke) {
      Me.length = ye.length;
      for (var De = 0; De < ye.length; De++)
        Me[De] = M(ye, De) ? _e(ye[De], ye) : "";
    }
    var Ne = typeof R == "function" ? R(ye) : [], $e;
    if (fe) {
      $e = {};
      for (var bt = 0; bt < Ne.length; bt++)
        $e["$" + Ne[bt]] = Ne[bt];
    }
    for (var Ve in ye)
      M(ye, Ve) && (ke && String(Number(Ve)) === Ve && Ve < ye.length || fe && $e["$" + Ve] instanceof Symbol || (N.call(/[^\w$]/, Ve) ? Me.push(_e(Ve, ye) + ": " + _e(ye[Ve], ye)) : Me.push(Ve + ": " + _e(ye[Ve], ye))));
    if (typeof R == "function")
      for (var je = 0; je < Ne.length; je++)
        ae.call(ye, Ne[je]) && Me.push("[" + _e(Ne[je]) + "]: " + _e(ye[Ne[je]], ye));
    return Me;
  }
  return Qf;
}
var ec, q5;
function lw() {
  if (q5) return ec;
  q5 = 1;
  var e = /* @__PURE__ */ go(), c = /* @__PURE__ */ Ir(), l = function(u, o, s) {
    for (var i = u, p; (p = i.next) != null; i = p)
      if (p.key === o)
        return i.next = p.next, s || (p.next = /** @type {NonNullable<typeof list.next>} */
        u.next, u.next = p), p;
  }, w = function(u, o) {
    if (u) {
      var s = l(u, o);
      return s && s.value;
    }
  }, m = function(u, o, s) {
    var i = l(u, o);
    i ? i.value = s : u.next = /** @type {import('./list.d.ts').ListNode<typeof value, typeof key>} */
    {
      // eslint-disable-line no-param-reassign, no-extra-parens
      key: o,
      next: u.next,
      value: s
    };
  }, f = function(u, o) {
    return u ? !!l(u, o) : !1;
  }, n = function(u, o) {
    if (u)
      return l(u, o, !0);
  };
  return ec = function() {
    var o, s = {
      assert: function(i) {
        if (!s.has(i))
          throw new c("Side channel does not contain " + e(i));
      },
      delete: function(i) {
        var p = o && o.next, g = n(o, i);
        return g && p && p === g && (o = void 0), !!g;
      },
      get: function(i) {
        return w(o, i);
      },
      has: function(i) {
        return f(o, i);
      },
      set: function(i, p) {
        o || (o = {
          next: void 0
        }), m(
          /** @type {NonNullable<typeof $o>} */
          o,
          i,
          p
        );
      }
    };
    return s;
  }, ec;
}
var tc, T5;
function op() {
  if (T5) return tc;
  T5 = 1;
  var e = /* @__PURE__ */ ai(), c = /* @__PURE__ */ Gt(), l = /* @__PURE__ */ go(), w = /* @__PURE__ */ Ir(), m = e("%Map%", !0), f = c("Map.prototype.get", !0), n = c("Map.prototype.set", !0), u = c("Map.prototype.has", !0), o = c("Map.prototype.delete", !0), s = c("Map.prototype.size", !0);
  return tc = !!m && /** @type {Exclude<import('.'), false>} */
  function() {
    var p, g = {
      assert: function(S) {
        if (!g.has(S))
          throw new w("Side channel does not contain " + l(S));
      },
      delete: function(S) {
        if (p) {
          var y = o(p, S);
          return s(p) === 0 && (p = void 0), y;
        }
        return !1;
      },
      get: function(S) {
        if (p)
          return f(p, S);
      },
      has: function(S) {
        return p ? u(p, S) : !1;
      },
      set: function(S, y) {
        p || (p = new m()), n(p, S, y);
      }
    };
    return g;
  }, tc;
}
var rc, z5;
function dw() {
  if (z5) return rc;
  z5 = 1;
  var e = /* @__PURE__ */ ai(), c = /* @__PURE__ */ Gt(), l = /* @__PURE__ */ go(), w = op(), m = /* @__PURE__ */ Ir(), f = e("%WeakMap%", !0), n = c("WeakMap.prototype.get", !0), u = c("WeakMap.prototype.set", !0), o = c("WeakMap.prototype.has", !0), s = c("WeakMap.prototype.delete", !0);
  return rc = f ? (
    /** @type {Exclude<import('.'), false>} */
    function() {
      var p, g, S = {
        assert: function(y) {
          if (!S.has(y))
            throw new m("Side channel does not contain " + l(y));
        },
        delete: function(y) {
          if (f && y && (typeof y == "object" || typeof y == "function")) {
            if (p)
              return s(p, y);
          } else if (w && g)
            return g.delete(y);
          return !1;
        },
        get: function(y) {
          return f && y && (typeof y == "object" || typeof y == "function") && p ? n(p, y) : g && g.get(y);
        },
        has: function(y) {
          return f && y && (typeof y == "object" || typeof y == "function") && p ? o(p, y) : !!g && g.has(y);
        },
        set: function(y, b) {
          f && y && (typeof y == "object" || typeof y == "function") ? (p || (p = new f()), u(p, y, b)) : w && (g || (g = w()), g.set(y, b));
        }
      };
      return S;
    }
  ) : w, rc;
}
var ic, C5;
function ap() {
  if (C5) return ic;
  C5 = 1;
  var e = /* @__PURE__ */ Ir(), c = /* @__PURE__ */ go(), l = lw(), w = op(), m = dw(), f = m || w || l;
  return ic = function() {
    var u, o = {
      assert: function(s) {
        if (!o.has(s))
          throw new e("Side channel does not contain " + c(s));
      },
      delete: function(s) {
        return !!u && u.delete(s);
      },
      get: function(s) {
        return u && u.get(s);
      },
      has: function(s) {
        return !!u && u.has(s);
      },
      set: function(s, i) {
        u || (u = f()), u.set(s, i);
      }
    };
    return o;
  }, ic;
}
var nc, D5;
function bw() {
  if (D5) return nc;
  D5 = 1;
  var e = /* @__PURE__ */ Zl(), c = ap()(), l = /* @__PURE__ */ Ir(), w = {
    assert: function(m, f) {
      if (!m || typeof m != "object" && typeof m != "function")
        throw new l("`O` is not an object");
      if (typeof f != "string")
        throw new l("`slot` must be a string");
      if (c.assert(m), !w.has(m, f))
        throw new l("`" + f + "` is not present on `O`");
    },
    get: function(m, f) {
      if (!m || typeof m != "object" && typeof m != "function")
        throw new l("`O` is not an object");
      if (typeof f != "string")
        throw new l("`slot` must be a string");
      var n = c.get(m);
      return n && n[
        /** @type {SaltedInternalSlot} */
        "$" + f
      ];
    },
    has: function(m, f) {
      if (!m || typeof m != "object" && typeof m != "function")
        throw new l("`O` is not an object");
      if (typeof f != "string")
        throw new l("`slot` must be a string");
      var n = c.get(m);
      return !!n && e(
        n,
        /** @type {SaltedInternalSlot} */
        "$" + f
      );
    },
    set: function(m, f, n) {
      if (!m || typeof m != "object" && typeof m != "function")
        throw new l("`O` is not an object");
      if (typeof f != "string")
        throw new l("`slot` must be a string");
      var u = c.get(m);
      u || (u = {}, c.set(m, u)), u[
        /** @type {SaltedInternalSlot} */
        "$" + f
      ] = n;
    }
  };
  return Object.freeze && Object.freeze(w), nc = w, nc;
}
var sc, U5;
function pw() {
  if (U5) return sc;
  U5 = 1;
  var e = bw(), c = /* @__PURE__ */ Vl(), l = typeof StopIteration == "object" ? StopIteration : null;
  return sc = function(m) {
    if (!l)
      throw new c("this environment lacks StopIteration");
    e.set(m, "[[Done]]", !1);
    var f = {
      next: (
        /** @type {() => IteratorResult<T>} */
        function() {
          var u = (
            /** @type {typeof origIterator} */
            e.get(this, "[[Iterator]]")
          ), o = !!e.get(u, "[[Done]]");
          try {
            return {
              done: o,
              // eslint-disable-next-line no-extra-parens
              value: o ? void 0 : (
                /** @type {T} */
                u.next()
              )
            };
          } catch (s) {
            if (e.set(u, "[[Done]]", !0), s !== l)
              throw s;
            return {
              done: !0,
              value: void 0
            };
          }
        }
      )
    };
    return e.set(f, "[[Iterator]]", m), f;
  }, sc;
}
var oc, F5;
function fp() {
  if (F5) return oc;
  F5 = 1;
  var e = {}.toString;
  return oc = Array.isArray || function(c) {
    return e.call(c) == "[object Array]";
  }, oc;
}
var ac, H5;
function cp() {
  if (H5) return ac;
  H5 = 1;
  var e = /* @__PURE__ */ Gt(), c = e("String.prototype.valueOf"), l = function(u) {
    try {
      return c(u), !0;
    } catch {
      return !1;
    }
  }, w = e("Object.prototype.toString"), m = "[object String]", f = xi()();
  return ac = function(u) {
    return typeof u == "string" ? !0 : !u || typeof u != "object" ? !1 : f ? l(u) : w(u) === m;
  }, ac;
}
var fc, L5;
function up() {
  if (L5) return fc;
  L5 = 1;
  var e = typeof Map == "function" && Map.prototype ? Map : null, c = typeof Set == "function" && Set.prototype ? Set : null, l;
  e || (l = function(n) {
    return !1;
  });
  var w = e ? Map.prototype.has : null, m = c ? Set.prototype.has : null;
  return !l && !w && (l = function(n) {
    return !1;
  }), fc = l || function(n) {
    if (!n || typeof n != "object")
      return !1;
    try {
      if (w.call(n), m)
        try {
          m.call(n);
        } catch {
          return !0;
        }
      return n instanceof e;
    } catch {
    }
    return !1;
  }, fc;
}
var cc, K5;
function hp() {
  if (K5) return cc;
  K5 = 1;
  var e = typeof Map == "function" && Map.prototype ? Map : null, c = typeof Set == "function" && Set.prototype ? Set : null, l;
  c || (l = function(n) {
    return !1;
  });
  var w = e ? Map.prototype.has : null, m = c ? Set.prototype.has : null;
  return !l && !m && (l = function(n) {
    return !1;
  }), cc = l || function(n) {
    if (!n || typeof n != "object")
      return !1;
    try {
      if (m.call(n), w)
        try {
          w.call(n);
        } catch {
          return !0;
        }
      return n instanceof c;
    } catch {
    }
    return !1;
  }, cc;
}
var V5;
function mw() {
  if (V5) return Un.exports;
  V5 = 1;
  var e = /* @__PURE__ */ t1(), c = /* @__PURE__ */ pw();
  if (Xl()() || po()()) {
    var l = Symbol.iterator;
    Un.exports = function(q) {
      if (q != null && typeof q[l] < "u")
        return q[l]();
      if (e(q))
        return Array.prototype[l].call(q);
    };
  } else {
    var w = fp(), m = cp(), f = /* @__PURE__ */ ai(), n = f("%Map%", !0), u = f("%Set%", !0), o = e1(), s = o("Array.prototype.push"), i = o("String.prototype.charCodeAt"), p = o("String.prototype.slice"), g = function(q, _) {
      var F = q.length;
      if (_ + 1 >= F)
        return _ + 1;
      var R = i(q, _);
      if (R < 55296 || R > 56319)
        return _ + 1;
      var L = i(q, _ + 1);
      return L < 56320 || L > 57343 ? _ + 1 : _ + 2;
    }, S = function(q) {
      var _ = 0;
      return {
        next: function() {
          var R = _ >= q.length, L;
          return R || (L = q[_], _ += 1), {
            done: R,
            value: L
          };
        }
      };
    }, y = function(q, _) {
      if (w(q) || e(q))
        return S(q);
      if (m(q)) {
        var F = 0;
        return {
          next: function() {
            var L = g(q, F), fe = p(q, F, L);
            return F = L, {
              done: L > q.length,
              value: fe
            };
          }
        };
      }
      if (_ && typeof q["_es6-shim iterator_"] < "u")
        return q["_es6-shim iterator_"]();
    };
    if (!n && !u)
      Un.exports = function(q) {
        if (q != null)
          return y(q, !0);
      };
    else {
      var b = /* @__PURE__ */ up(), h = /* @__PURE__ */ hp(), a = o("Map.prototype.forEach", !0), E = o("Set.prototype.forEach", !0);
      if (typeof St > "u" || !St.versions || !St.versions.node)
        var H = o("Map.prototype.iterator", !0), j = o("Set.prototype.iterator", !0);
      var G = o("Map.prototype.@@iterator", !0) || o("Map.prototype._es6-shim iterator_", !0), N = o("Set.prototype.@@iterator", !0) || o("Set.prototype._es6-shim iterator_", !0), T = function(q) {
        if (b(q)) {
          if (H)
            return c(H(q));
          if (G)
            return G(q);
          if (a) {
            var _ = [];
            return a(q, function(R, L) {
              s(_, [L, R]);
            }), S(_);
          }
        }
        if (h(q)) {
          if (j)
            return c(j(q));
          if (N)
            return N(q);
          if (E) {
            var F = [];
            return E(q, function(R) {
              s(F, R);
            }), S(F);
          }
        }
      };
      Un.exports = function(q) {
        return T(q) || y(q);
      };
    }
  }
  return Un.exports;
}
var uc, $5;
function lp() {
  if ($5) return uc;
  $5 = 1;
  var e = function(c) {
    return c !== c;
  };
  return uc = function(l, w) {
    return l === 0 && w === 0 ? 1 / l === 1 / w : !!(l === w || e(l) && e(w));
  }, uc;
}
var hc, j5;
function r1() {
  if (j5) return hc;
  j5 = 1;
  var e = lp();
  return hc = function() {
    return typeof Object.is == "function" ? Object.is : e;
  }, hc;
}
var lc, Y5;
function gw() {
  if (Y5) return lc;
  Y5 = 1;
  var e = r1(), c = oi();
  return lc = function() {
    var w = e();
    return c(Object, { is: w }, {
      is: function() {
        return Object.is !== w;
      }
    }), w;
  }, lc;
}
var dc, X5;
function dp() {
  if (X5) return dc;
  X5 = 1;
  var e = oi(), c = Yi(), l = lp(), w = r1(), m = gw(), f = c(w(), Object);
  return e(f, {
    getPolyfill: w,
    implementation: l,
    shim: m
  }), dc = f, dc;
}
var bc, G5;
function bp() {
  if (G5) return bc;
  G5 = 1;
  var e = Yi(), c = /* @__PURE__ */ Gt(), l = /* @__PURE__ */ ai(), w = l("%ArrayBuffer%", !0), m = c("ArrayBuffer.prototype.byteLength", !0), f = c("Object.prototype.toString"), n = !!w && !m && new w(0).slice, u = !!n && e(n);
  return bc = m || u ? function(s) {
    if (!s || typeof s != "object")
      return !1;
    try {
      return m ? m(s) : u(s, 0), !0;
    } catch {
      return !1;
    }
  } : w ? function(s) {
    return f(s) === "[object ArrayBuffer]";
  } : function(s) {
    return !1;
  }, bc;
}
var pc, J5;
function xw() {
  if (J5) return pc;
  J5 = 1;
  var e = /* @__PURE__ */ Gt(), c = e("Date.prototype.getDay"), l = function(u) {
    try {
      return c(u), !0;
    } catch {
      return !1;
    }
  }, w = e("Object.prototype.toString"), m = "[object Date]", f = xi()();
  return pc = function(u) {
    return typeof u != "object" || u === null ? !1 : f ? l(u) : w(u) === m;
  }, pc;
}
var mc, W5;
function pp() {
  if (W5) return mc;
  W5 = 1;
  var e = /* @__PURE__ */ Gt(), c = xi()(), l = /* @__PURE__ */ Zl(), w = /* @__PURE__ */ ji(), m;
  if (c) {
    var f = e("RegExp.prototype.exec"), n = {}, u = function() {
      throw n;
    }, o = {
      toString: u,
      valueOf: u
    };
    typeof Symbol.toPrimitive == "symbol" && (o[Symbol.toPrimitive] = u), m = function(g) {
      if (!g || typeof g != "object")
        return !1;
      var S = (
        /** @type {NonNullable<typeof gOPD>} */
        w(
          /** @type {{ lastIndex?: unknown }} */
          g,
          "lastIndex"
        )
      ), y = S && l(S, "value");
      if (!y)
        return !1;
      try {
        f(
          g,
          /** @type {string} */
          /** @type {unknown} */
          o
        );
      } catch (b) {
        return b === n;
      }
    };
  } else {
    var s = e("Object.prototype.toString"), i = "[object RegExp]";
    m = function(g) {
      return !g || typeof g != "object" && typeof g != "function" ? !1 : s(g) === i;
    };
  }
  return mc = m, mc;
}
var gc, Z5;
function ww() {
  if (Z5) return gc;
  Z5 = 1;
  var e = /* @__PURE__ */ Gt(), c = e("SharedArrayBuffer.prototype.byteLength", !0);
  return gc = c ? function(w) {
    if (!w || typeof w != "object")
      return !1;
    try {
      return c(w), !0;
    } catch {
      return !1;
    }
  } : function(w) {
    return !1;
  }, gc;
}
var xc, Q5;
function yw() {
  if (Q5) return xc;
  Q5 = 1;
  var e = /* @__PURE__ */ Gt(), c = e("Number.prototype.toString"), l = function(u) {
    try {
      return c(u), !0;
    } catch {
      return !1;
    }
  }, w = e("Object.prototype.toString"), m = "[object Number]", f = xi()();
  return xc = function(u) {
    return typeof u == "number" ? !0 : !u || typeof u != "object" ? !1 : f ? l(u) : w(u) === m;
  }, xc;
}
var wc, e4;
function vw() {
  if (e4) return wc;
  e4 = 1;
  var e = /* @__PURE__ */ Gt(), c = e("Boolean.prototype.toString"), l = e("Object.prototype.toString"), w = function(u) {
    try {
      return c(u), !0;
    } catch {
      return !1;
    }
  }, m = "[object Boolean]", f = xi()();
  return wc = function(u) {
    return typeof u == "boolean" ? !0 : u === null || typeof u != "object" ? !1 : f ? w(u) : l(u) === m;
  }, wc;
}
var Es = { exports: {} }, yc, t4;
function mp() {
  if (t4) return yc;
  t4 = 1;
  var e = /* @__PURE__ */ Gt(), c = pp(), l = e("RegExp.prototype.exec"), w = /* @__PURE__ */ Ir();
  return yc = function(f) {
    if (!c(f))
      throw new w("`regex` must be a RegExp");
    return function(u) {
      return l(f, u) !== null;
    };
  }, yc;
}
var r4;
function Sw() {
  if (r4) return Es.exports;
  r4 = 1;
  var e = /* @__PURE__ */ Gt(), c = e("Object.prototype.toString"), l = Xl()(), w = /* @__PURE__ */ mp();
  if (l) {
    var m = e("Symbol.prototype.toString"), f = w(/^Symbol\(.*\)$/), n = function(o) {
      return typeof o.valueOf() != "symbol" ? !1 : f(m(o));
    };
    Es.exports = function(o) {
      if (typeof o == "symbol")
        return !0;
      if (!o || typeof o != "object" || c(o) !== "[object Symbol]")
        return !1;
      try {
        return n(o);
      } catch {
        return !1;
      }
    };
  } else
    Es.exports = function(o) {
      return !1;
    };
  return Es.exports;
}
var Is = { exports: {} }, vc, i4;
function Ew() {
  if (i4) return vc;
  i4 = 1;
  var e = typeof BigInt < "u" && BigInt;
  return vc = function() {
    return typeof e == "function" && typeof BigInt == "function" && typeof e(42) == "bigint" && typeof BigInt(42) == "bigint";
  }, vc;
}
var n4;
function Iw() {
  if (n4) return Is.exports;
  n4 = 1;
  var e = Ew()();
  if (e) {
    var c = BigInt.prototype.valueOf, l = function(m) {
      try {
        return c.call(m), !0;
      } catch {
      }
      return !1;
    };
    Is.exports = function(m) {
      return m === null || typeof m > "u" || typeof m == "boolean" || typeof m == "string" || typeof m == "number" || typeof m == "symbol" || typeof m == "function" ? !1 : typeof m == "bigint" ? !0 : l(m);
    };
  } else
    Is.exports = function(m) {
      return !1;
    };
  return Is.exports;
}
var Sc, s4;
function Aw() {
  if (s4) return Sc;
  s4 = 1;
  var e = cp(), c = yw(), l = vw(), w = Sw(), m = Iw();
  return Sc = function(n) {
    if (n == null || typeof n != "object" && typeof n != "function")
      return null;
    if (e(n))
      return "String";
    if (c(n))
      return "Number";
    if (l(n))
      return "Boolean";
    if (w(n))
      return "Symbol";
    if (m(n))
      return "BigInt";
  }, Sc;
}
var Ec, o4;
function Ow() {
  if (o4) return Ec;
  o4 = 1;
  var e = typeof WeakMap == "function" && WeakMap.prototype ? WeakMap : null, c = typeof WeakSet == "function" && WeakSet.prototype ? WeakSet : null, l;
  e || (l = function(n) {
    return !1;
  });
  var w = e ? e.prototype.has : null, m = c ? c.prototype.has : null;
  return !l && !w && (l = function(n) {
    return !1;
  }), Ec = l || function(n) {
    if (!n || typeof n != "object")
      return !1;
    try {
      if (w.call(n, w), m)
        try {
          m.call(n, m);
        } catch {
          return !0;
        }
      return n instanceof e;
    } catch {
    }
    return !1;
  }, Ec;
}
var As = { exports: {} }, a4;
function _w() {
  if (a4) return As.exports;
  a4 = 1;
  var e = /* @__PURE__ */ ai(), c = /* @__PURE__ */ Gt(), l = e("%WeakSet%", !0), w = c("WeakSet.prototype.has", !0);
  if (w) {
    var m = c("WeakMap.prototype.has", !0);
    As.exports = function(n) {
      if (!n || typeof n != "object")
        return !1;
      try {
        if (w(n, w), m)
          try {
            m(n, m);
          } catch {
            return !0;
          }
        return n instanceof l;
      } catch {
      }
      return !1;
    };
  } else
    As.exports = function(n) {
      return !1;
    };
  return As.exports;
}
var Ic, f4;
function Rw() {
  if (f4) return Ic;
  f4 = 1;
  var e = /* @__PURE__ */ up(), c = /* @__PURE__ */ hp(), l = Ow(), w = /* @__PURE__ */ _w();
  return Ic = function(f) {
    if (f && typeof f == "object") {
      if (e(f))
        return "Map";
      if (c(f))
        return "Set";
      if (l(f))
        return "WeakMap";
      if (w(f))
        return "WeakSet";
    }
    return !1;
  }, Ic;
}
var Ac, c4;
function Pw() {
  if (c4) return Ac;
  c4 = 1;
  var e = Function.prototype.toString, c = typeof Reflect == "object" && Reflect !== null && Reflect.apply, l, w;
  if (typeof c == "function" && typeof Object.defineProperty == "function")
    try {
      l = Object.defineProperty({}, "length", {
        get: function() {
          throw w;
        }
      }), w = {}, c(function() {
        throw 42;
      }, null, l);
    } catch (E) {
      E !== w && (c = null);
    }
  else
    c = null;
  var m = /^\s*class\b/, f = function(H) {
    try {
      var j = e.call(H);
      return m.test(j);
    } catch {
      return !1;
    }
  }, n = function(H) {
    try {
      return f(H) ? !1 : (e.call(H), !0);
    } catch {
      return !1;
    }
  }, u = Object.prototype.toString, o = "[object Object]", s = "[object Function]", i = "[object GeneratorFunction]", p = "[object HTMLAllCollection]", g = "[object HTML document.all class]", S = "[object HTMLCollection]", y = typeof Symbol == "function" && !!Symbol.toStringTag, b = !(0 in [,]), h = function() {
    return !1;
  };
  if (typeof document == "object") {
    var a = document.all;
    u.call(a) === u.call(document.all) && (h = function(H) {
      if ((b || !H) && (typeof H > "u" || typeof H == "object"))
        try {
          var j = u.call(H);
          return (j === p || j === g || j === S || j === o) && H("") == null;
        } catch {
        }
      return !1;
    });
  }
  return Ac = c ? function(H) {
    if (h(H))
      return !0;
    if (!H || typeof H != "function" && typeof H != "object")
      return !1;
    try {
      c(H, null, l);
    } catch (j) {
      if (j !== w)
        return !1;
    }
    return !f(H) && n(H);
  } : function(H) {
    if (h(H))
      return !0;
    if (!H || typeof H != "function" && typeof H != "object")
      return !1;
    if (y)
      return n(H);
    if (f(H))
      return !1;
    var j = u.call(H);
    return j !== s && j !== i && !/^\[object HTML/.test(j) ? !1 : n(H);
  }, Ac;
}
var Oc, u4;
function kw() {
  if (u4) return Oc;
  u4 = 1;
  var e = Pw(), c = Object.prototype.toString, l = Object.prototype.hasOwnProperty, w = function(o, s, i) {
    for (var p = 0, g = o.length; p < g; p++)
      l.call(o, p) && (i == null ? s(o[p], p, o) : s.call(i, o[p], p, o));
  }, m = function(o, s, i) {
    for (var p = 0, g = o.length; p < g; p++)
      i == null ? s(o.charAt(p), p, o) : s.call(i, o.charAt(p), p, o);
  }, f = function(o, s, i) {
    for (var p in o)
      l.call(o, p) && (i == null ? s(o[p], p, o) : s.call(i, o[p], p, o));
  };
  function n(u) {
    return c.call(u) === "[object Array]";
  }
  return Oc = function(o, s, i) {
    if (!e(s))
      throw new TypeError("iterator must be a function");
    var p;
    arguments.length >= 3 && (p = i), n(o) ? w(o, s, p) : typeof o == "string" ? m(o, s, p) : f(o, s, p);
  }, Oc;
}
var _c, h4;
function Bw() {
  return h4 || (h4 = 1, _c = [
    "Float16Array",
    "Float32Array",
    "Float64Array",
    "Int8Array",
    "Int16Array",
    "Int32Array",
    "Uint8Array",
    "Uint8ClampedArray",
    "Uint16Array",
    "Uint32Array",
    "BigInt64Array",
    "BigUint64Array"
  ]), _c;
}
var Rc, l4;
function Mw() {
  if (l4) return Rc;
  l4 = 1;
  var e = /* @__PURE__ */ Bw(), c = typeof globalThis > "u" ? Ft : globalThis;
  return Rc = function() {
    for (var w = [], m = 0; m < e.length; m++)
      typeof c[e[m]] == "function" && (w[w.length] = e[m]);
    return w;
  }, Rc;
}
var Pc, d4;
function i1() {
  if (d4) return Pc;
  d4 = 1;
  var e = kw(), c = /* @__PURE__ */ Mw(), l = Yi(), w = /* @__PURE__ */ Gt(), m = /* @__PURE__ */ ji(), f = mo(), n = w("Object.prototype.toString"), u = xi()(), o = typeof globalThis > "u" ? Ft : globalThis, s = c(), i = w("String.prototype.slice"), p = w("Array.prototype.indexOf", !0) || function(h, a) {
    for (var E = 0; E < h.length; E += 1)
      if (h[E] === a)
        return E;
    return -1;
  }, g = { __proto__: null };
  u && m && f ? e(s, function(b) {
    var h = new o[b]();
    if (Symbol.toStringTag in h && f) {
      var a = f(h), E = m(a, Symbol.toStringTag);
      if (!E && a) {
        var H = f(a);
        E = m(H, Symbol.toStringTag);
      }
      g["$" + b] = l(E.get);
    }
  }) : e(s, function(b) {
    var h = new o[b](), a = h.slice || h.set;
    a && (g[
      /** @type {`$${import('.').TypedArrayName}`} */
      "$" + b
    ] = /** @type {import('./types').BoundSlice | import('./types').BoundSet} */
    // @ts-expect-error TODO FIXME
    l(a));
  });
  var S = function(h) {
    var a = !1;
    return e(
      /** @type {Record<`\$${import('.').TypedArrayName}`, Getter>} */
      g,
      /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
      function(E, H) {
        if (!a)
          try {
            "$" + E(h) === H && (a = /** @type {import('.').TypedArrayName} */
            i(H, 1));
          } catch {
          }
      }
    ), a;
  }, y = function(h) {
    var a = !1;
    return e(
      /** @type {Record<`\$${import('.').TypedArrayName}`, Getter>} */
      g,
      /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
      function(E, H) {
        if (!a)
          try {
            E(h), a = /** @type {import('.').TypedArrayName} */
            i(H, 1);
          } catch {
          }
      }
    ), a;
  };
  return Pc = function(h) {
    if (!h || typeof h != "object")
      return !1;
    if (!u) {
      var a = i(n(h), 8, -1);
      return p(s, a) > -1 ? a : a !== "Object" ? !1 : y(h);
    }
    return m ? S(h) : null;
  }, Pc;
}
var kc, b4;
function Nw() {
  if (b4) return kc;
  b4 = 1;
  var e = /* @__PURE__ */ Gt(), c = e("ArrayBuffer.prototype.byteLength", !0), l = /* @__PURE__ */ bp();
  return kc = function(m) {
    return l(m) ? c ? c(m) : m.byteLength : NaN;
  }, kc;
}
var Bc, p4;
function qw() {
  if (p4) return Bc;
  p4 = 1;
  var e = nw(), c = e1(), l = fw(), w = /* @__PURE__ */ ai(), m = mw(), f = ap(), n = dp(), u = /* @__PURE__ */ t1(), o = fp(), s = /* @__PURE__ */ bp(), i = /* @__PURE__ */ xw(), p = pp(), g = /* @__PURE__ */ ww(), S = Kl(), y = Aw(), b = /* @__PURE__ */ Rw(), h = /* @__PURE__ */ i1(), a = /* @__PURE__ */ Nw(), E = c("SharedArrayBuffer.prototype.byteLength", !0), H = c("Date.prototype.getTime"), j = Object.getPrototypeOf, G = c("Object.prototype.toString"), N = w("%Set%", !0), T = c("Map.prototype.has", !0), A = c("Map.prototype.get", !0), q = c("Map.prototype.size", !0), _ = c("Set.prototype.add", !0), F = c("Set.prototype.delete", !0), R = c("Set.prototype.has", !0), L = c("Set.prototype.size", !0);
  function fe(le, ge, Ee, we) {
    for (var z = m(le), I; (I = z.next()) && !I.done; )
      if (W(ge, I.value, Ee, we))
        return F(le, I.value), !0;
    return !1;
  }
  function ue(le) {
    if (typeof le > "u")
      return null;
    if (typeof le != "object")
      return typeof le == "symbol" ? !1 : typeof le == "string" || typeof le == "number" ? +le == +le : !0;
  }
  function ae(le, ge, Ee, we, z, I) {
    var ne = ue(Ee);
    if (ne != null)
      return ne;
    var t = A(ge, ne), d = e({}, z, { strict: !1 });
    return typeof t > "u" && !T(ge, ne) || !W(we, t, d, I) ? !1 : !T(le, ne) && W(we, t, d, I);
  }
  function D(le, ge, Ee) {
    var we = ue(Ee);
    return we ?? (R(ge, we) && !R(le, we));
  }
  function Q(le, ge, Ee, we, z, I) {
    for (var ne = m(le), t, d; (t = ne.next()) && !t.done; )
      if (d = t.value, // eslint-disable-next-line no-use-before-define
      W(Ee, d, z, I) && W(we, A(ge, d), z, I))
        return F(le, d), !0;
    return !1;
  }
  function W(le, ge, Ee, we) {
    var z = Ee || {};
    if (z.strict ? n(le, ge) : le === ge)
      return !0;
    var I = y(le), ne = y(ge);
    if (I !== ne)
      return !1;
    if (!le || !ge || typeof le != "object" && typeof ge != "object")
      return z.strict ? n(le, ge) : le == ge;
    var t = we.has(le), d = we.has(ge), B;
    if (t && d) {
      if (we.get(le) === we.get(ge))
        return !0;
    } else
      B = {};
    return t || we.set(le, B), d || we.set(ge, B), he(le, ge, z, we);
  }
  function oe(le) {
    return !le || typeof le != "object" || typeof le.length != "number" || typeof le.copy != "function" || typeof le.slice != "function" || le.length > 0 && typeof le[0] != "number" ? !1 : !!(le.constructor && le.constructor.isBuffer && le.constructor.isBuffer(le));
  }
  function v(le, ge, Ee, we) {
    if (L(le) !== L(ge))
      return !1;
    for (var z = m(le), I = m(ge), ne, t, d; (ne = z.next()) && !ne.done; )
      if (ne.value && typeof ne.value == "object")
        d || (d = new N()), _(d, ne.value);
      else if (!R(ge, ne.value)) {
        if (Ee.strict || !D(le, ge, ne.value))
          return !1;
        d || (d = new N()), _(d, ne.value);
      }
    if (d) {
      for (; (t = I.next()) && !t.done; )
        if (t.value && typeof t.value == "object") {
          if (!fe(d, t.value, Ee.strict, we))
            return !1;
        } else if (!Ee.strict && !R(le, t.value) && !fe(d, t.value, Ee.strict, we))
          return !1;
      return L(d) === 0;
    }
    return !0;
  }
  function Y(le, ge, Ee, we) {
    if (q(le) !== q(ge))
      return !1;
    for (var z = m(le), I = m(ge), ne, t, d, B, U, J; (ne = z.next()) && !ne.done; )
      if (B = ne.value[0], U = ne.value[1], B && typeof B == "object")
        d || (d = new N()), _(d, B);
      else if (J = A(ge, B), typeof J > "u" && !T(ge, B) || !W(U, J, Ee, we)) {
        if (Ee.strict || !ae(le, ge, B, U, Ee, we))
          return !1;
        d || (d = new N()), _(d, B);
      }
    if (d) {
      for (; (t = I.next()) && !t.done; )
        if (B = t.value[0], J = t.value[1], B && typeof B == "object") {
          if (!Q(d, le, B, J, Ee, we))
            return !1;
        } else if (!Ee.strict && (!le.has(B) || !W(A(le, B), J, Ee, we)) && !Q(d, le, B, J, e({}, Ee, { strict: !1 }), we))
          return !1;
      return L(d) === 0;
    }
    return !0;
  }
  function he(le, ge, Ee, we) {
    var z, I;
    if (typeof le != typeof ge || le == null || ge == null || G(le) !== G(ge) || u(le) !== u(ge))
      return !1;
    var ne = o(le), t = o(ge);
    if (ne !== t)
      return !1;
    var d = le instanceof Error, B = ge instanceof Error;
    if (d !== B || (d || B) && (le.name !== ge.name || le.message !== ge.message))
      return !1;
    var U = p(le), J = p(ge);
    if (U !== J || (U || J) && (le.source !== ge.source || l(le) !== l(ge)))
      return !1;
    var C = i(le), M = i(ge);
    if (C !== M || (C || M) && H(le) !== H(ge) || Ee.strict && j && j(le) !== j(ge))
      return !1;
    var $ = h(le), r = h(ge);
    if ($ !== r)
      return !1;
    if ($ || r) {
      if (le.length !== ge.length)
        return !1;
      for (z = 0; z < le.length; z++)
        if (le[z] !== ge[z])
          return !1;
      return !0;
    }
    var x = oe(le), O = oe(ge);
    if (x !== O)
      return !1;
    if (x || O) {
      if (le.length !== ge.length)
        return !1;
      for (z = 0; z < le.length; z++)
        if (le[z] !== ge[z])
          return !1;
      return !0;
    }
    var K = s(le), X = s(ge);
    if (K !== X)
      return !1;
    if (K || X)
      return a(le) !== a(ge) ? !1 : typeof Uint8Array == "function" && W(new Uint8Array(le), new Uint8Array(ge), Ee, we);
    var P = g(le), V = g(ge);
    if (P !== V)
      return !1;
    if (P || V)
      return E(le) !== E(ge) ? !1 : typeof Uint8Array == "function" && W(new Uint8Array(le), new Uint8Array(ge), Ee, we);
    if (typeof le != typeof ge)
      return !1;
    var re = S(le), ce = S(ge);
    if (re.length !== ce.length)
      return !1;
    for (re.sort(), ce.sort(), z = re.length - 1; z >= 0; z--)
      if (re[z] != ce[z])
        return !1;
    for (z = re.length - 1; z >= 0; z--)
      if (I = re[z], !W(le[I], ge[I], Ee, we))
        return !1;
    var de = b(le), pe = b(ge);
    return de !== pe ? !1 : de === "Set" || pe === "Set" ? v(le, ge, Ee, we) : de === "Map" ? Y(le, ge, Ee, we) : !0;
  }
  return Bc = function(ge, Ee, we) {
    return W(ge, Ee, we, f());
  }, Bc;
}
var Tw = qw();
const zw = /* @__PURE__ */ Nr(Tw), { Mnemonic: Cw } = ss, gp = ol({}), Dw = ({ children: e }) => {
  const [c, l] = jn(), [w, m] = jn(new _x()), [f, n] = jn(!0), [u, o] = jn(!1);
  Yn(() => {
    s();
  }, []), Yn(() => {
    u && (on.emit("WALLET_LOADED", "success"), w.wallets.length > 0 ? g(w) : n(!1));
  }, [u, w.wallets[0]?.name]), Cx(() => {
    c && (console.log("useTimeout UPDATE WALLET"), g(w));
  }, 1e4);
  const s = async () => {
    console.log("loadCashtabState()");
    const b = await E1.getItem("wallets");
    if (console.log("loadCashtabState found wallets", b), b) {
      console.log("set stored wallets clause");
      const h = Object.assign(w, { wallets: b });
      console.log("new cashtab state", h), m(h);
    }
    o(!0);
  }, i = async (b, h) => {
    const a = h ? Cw.fromPhrase(h) : Sx();
    if (Ax(a, [])) {
      const H = Ix(a);
      console.log("newWallet", H), b ? await p("wallets", [H, ...w.wallets]) : await p("wallets", [...w.wallets, H]), on.emit("WALLET_ADDED", "success");
    } else
      throw new Error("Wallet already exists");
  }, p = async (b, h) => {
    console.log("updateCashtabState key", b, "value", h), m({ ...w, [`${b}`]: h }), n(!0), await E1.setItem(b, h), n(!1);
  }, g = async (b) => {
    const h = b.wallets[0];
    if (!h)
      throw new Error("No wallet found");
    const a = h.Path1899.cashAddress, E = await Px(a), H = h.state.utxos, j = !zw(E, H);
    if (console.log("utxosHAveChanged", j), !j) {
      c || l(h);
      return;
    }
    const G = Bx(E), N = kx(G), T = await Mx(a), A = Nx(T, a), q = {
      balances: N,
      utxos: E,
      slp: G,
      parsedTxHistory: A
    };
    h.state = q;
    const _ = b.wallets.slice(1), F = [h, ..._];
    await p("wallets", F), l(h), on.emit("WALLET_UPDATED", "success");
  };
  return /* @__PURE__ */ fn(gp, { value: {
    wallet: c,
    cashtab: w,
    createWallet: i,
    activateWallet: async (b) => {
      const h = Ox(b, w.wallets);
      await p("wallets", h), on.emit("WALLET_CHANGED", "success");
    },
    removeWallet: async (b) => {
      const h = w.wallets.filter((a) => a.name !== b.name);
      await p("wallets", h), on.emit("WALLET_DELETED", "success");
    },
    update: g,
    walletLoading: f,
    walletLoaded: u
  }, children: e });
}, Uw = () => {
  const e = al(gp);
  if (!e)
    throw new Error("useWallet must be used within an WalletProvider");
  return e;
}, { Mnemonic: Fw } = ss, m4 = (e) => {
  let c;
  try {
    return c = Fw.fromPhrase(e), c.toString() === e;
  } catch (l) {
    return console.error(l), !1;
  }
};
var li = {}, Mc, g4;
function xp() {
  return g4 || (g4 = 1, Mc = [
    k.from(
      "ebd41040e4bb3ec742c9e381d31ef2a41a48b6685c96e7cef3c1df6cd4331c99",
      "hex"
    ),
    k.from(
      "ca42dd41745fd0b81eb902362cf9d8bf719da1bd1b1efc946f5b4c99f42c1b9e",
      "hex"
    ),
    k.from(
      "eb04cf5eb1f39afa762f2bb120f296cba520c1b97db1589565b81cb9a17b7244",
      "hex"
    ),
    k.from(
      "6dc47172e01cbcb0bf62580d895fe2b8ac9ad4f873801e0c10b9c837d21eb177",
      "hex"
    ),
    k.from(
      "16af57a9f676b0ab126095aa5ebadef22ab31119d644ac95cd4b93dbf3f26aeb",
      "hex"
    ),
    k.from(
      "687fa451382278fff0c8b11f8d43d576671c6eb2bceab413fb83d965d06d2ff2",
      "hex"
    ),
    k.from(
      "73c176434f1bc6d5adf45b0e76e727287c8de57616c1e6e6141a2b2cbc7d8e4c",
      "hex"
    ),
    k.from(
      "ff856a2d251dcd88d36656f450126798cfabaade40799c722de4d2b5db36a73a",
      "hex"
    ),
    k.from(
      "a0459b9f63b22559f5fa5d4c6db3f9f72ff19342033578f073bf1d1b46cbb912",
      "hex"
    ),
    k.from(
      "a0234f3bc8527ca5628eec81ad5d69895da5680dc91d1cb8477f33f878b95b0b",
      "hex"
    ),
    k.from(
      "69fac9bd55fb0ac78d53bbee5cf1d597989fd0aaab20a25151bdf1733ee7d122",
      "hex"
    ),
    k.from(
      "d7a7a0fb5d7e2731d771e9484ebcdef71d5f0c3e0a2948782bc83ee0ea699ef4",
      "hex"
    ),
    k.from(
      "a45ede3bbbf09c8ae15c72efc07268d693a21c996fd51e67ca079460fd6d8873",
      "hex"
    ),
    k.from(
      "85a0dd7dd720adb7ff05f83d542b209dc7ff4528f7d677b18389fea5e5c49e86",
      "hex"
    ),
    k.from(
      "18f1fc7f205df8adddeb7fe007dd57e3af375a9c4d8d73546bf4f1fed1e18d35",
      "hex"
    ),
    k.from(
      "e75e72ed9f560eec6eb4800073a43fc3ad19195a392282017895974a99026b6c",
      "hex"
    ),
    k.from(
      "7908b40314c138100b518d0735807ffbfcf8518a0095337105ba386b153dd927",
      "hex"
    ),
    k.from(
      "cecddc905099d8dadfc5b1d209b737cbe2c18cfb2c10c0ff0bcf0d3286fc1aa2",
      "hex"
    ),
    k.from(
      "c3846bf24b9e93ca64274c0ec67c1ecc5e024ffcacd2d74019350e81fe546ae4",
      "hex"
    ),
    k.from(
      "1465fa205397b876faa6f0a9958e5590e40fcc7faa4fb7c2c8677521fb5fb658",
      "hex"
    ),
    k.from(
      "7600295eefe85b9e1fd624db76062aaaae59818a54d2774cd4c0b2c01131e1b3",
      "hex"
    ),
    k.from(
      "3e9099b5015e8f486c00bcea9d111ee721faba355a89bcf1df69561e3dc6325c",
      "hex"
    ),
    k.from(
      "4348a0e9444c78cb265e058d5e8944b4d84f9662bd26db257f8934a443c70161",
      "hex"
    ),
    k.from(
      "7431e5f4c3c1ce4690774f0b61e05440883ba9a01ed00ba6abd7806ed3b118cf",
      "hex"
    ),
    k.from(
      "0f993c8aef97baaf5687140ed59ad1821bb4afacf0aa9a58b5d57a338a3afbcb",
      "hex"
    ),
    k.from(
      "0687260331a72403d909f105e69bcf0d32e1bd2493ffc6d9206d11bcd6770739",
      "hex"
    ),
    k.from(
      "62dd0be9b9f50a163ea0f8e75c053b1eca57ea55c8688f647c6881f2c8357b95",
      "hex"
    ),
    k.from(
      "be6c4da2bbb9ba59b6f3939768374246c3c005993fa98f020d1dedbed48a81d5",
      "hex"
    ),
    k.from(
      "37d51006c512eaab626421f1ec8c92013fc5f82ae98ee533eb4619b8deb4d06c",
      "hex"
    ),
    k.from(
      "8d722f81a9c113c0791df136a2966db26c950a971db46b4199f4ea54b78bfb9f",
      "hex"
    ),
    k.from(
      "9acfab7e43c8d880d06b262a94deeee4b4659989c3d0caf19baf6405e41ab7df",
      "hex"
    ),
    k.from(
      "f1c1b50ae5a20dd8030ec9f6bc24823dd367b5255759b4e71b61fce9f7375d73",
      "hex"
    ),
    k.from(
      "4200f5043ac8590ebb527d209ed1503029fbcbd41ca1b506ec27f15ade7dac69",
      "hex"
    ),
    k.from(
      "0c2cd63df7806fa399ede809116b575bf87989f06518f9808c860503178baf66",
      "hex"
    ),
    k.from(
      "15f0ba00a3ac7af3ac884c072b1011a077bd77c097f40164b2f8598abd83860c",
      "hex"
    ),
    k.from(
      "1793927a0614549789adce2f8f34f7f0b66d0f3ae3a3b84d21ec15dbba4fadc7",
      "hex"
    ),
    k.from(
      "41c923866ab4cad6b7ad578081582e020797a6cbdf4fff78ce8396b38937d7f5",
      "hex"
    ),
    k.from(
      "e3b6a2db2ed7ce48842f7ac53241c7b71d54144bfb40c11f3f1d0b42f5eea12d",
      "hex"
    ),
    k.from(
      "b6191a50d0c3977f7da99bcdaac86a227daeb9679ec70ba3b0c9d92271c170d3",
      "hex"
    ),
    k.from(
      "960adf0063e96356750c2965dd0a0867da0b9cbd6e77714aeafb2349ab393da3",
      "hex"
    ),
    k.from(
      "c0a6f4dc63a24bfdcf54ef2a6a082a0a72de35803e2ff5ff527ae5d87206dfd5",
      "hex"
    ),
    k.from(
      "eaa962c4fa4a6bafebe415196d351ccd888d4f53f3fa8ae6d7c466a94e6042bb",
      "hex"
    ),
    k.from(
      "b478b812250df878635c2aa7ec7d155eaa625ee82916e2cd294361886cd1fbd4",
      "hex"
    ),
    k.from(
      "a4310d50af18a6447190372a86afaf8b951ffb431d837f1e5688b45971ed1557",
      "hex"
    ),
    k.from(
      "4b03f45807ad70f21bfc2cae71c9fde4604c064cf5ffb686bae5dbaad7fdd34c",
      "hex"
    ),
    k.from(
      "5edb7ac43b82a06a8761e8d7be4979ebf2611f7dd79bf91c1c6b566a219ed766",
      "hex"
    ),
    k.from(
      "2399561127a57125de8cefea610ddf2fa078b5c8067f4e828290bfb860e84b3c",
      "hex"
    ),
    k.from(
      "69ddd7ea90bb57c93e135dc85ea6fcd5480b603239bdc454fc758b2a26cf7f79",
      "hex"
    ),
    k.from(
      "6c61dac3a2def031506be036d2a6fe401994fbd13df9c8d466599274c446ec98",
      "hex"
    ),
    k.from(
      "668c83947da63b724bece1743c31a0e6aed0db8ec5b31be377bb784f91b6716f",
      "hex"
    ),
    k.from(
      "f9e67d336c51002ac054c632022d66dda2e7e3fff10ad061ed31d8bbb410cfb2",
      "hex"
    ),
    k.from(
      "bf0feefb9e3a581ad5f9e9db7589985743d261085c4d314f6f5d7259aa421612",
      "hex"
    ),
    k.from(
      "3c5f81fea5fab82c64bfa2eaecafcde8e077fc8620a7cae537163df36edbf378",
      "hex"
    ),
    k.from(
      "cbb522d7b7f127ad6a0113865bdf1cd4102e7d0759af635a7cf4720dc963c53b",
      "hex"
    ),
    k.from(
      "04048028bf1f2864d48f9ad4d83294366a828856553f3b14303f90147f5d40ef",
      "hex"
    ),
    k.from(
      "2530cc8e98321502bad96f9b1fba1b099e2d299e0f4548bb914f363bc0d4531f",
      "hex"
    ),
    k.from(
      "063e4afac491dfd332f3089b8542e94617d893d7fe944e10a7937ee29d9693c0",
      "hex"
    ),
    k.from(
      "136335439334a7698016a0d324de72284e079d7b5220bb8fbd747816eebebaca",
      "hex"
    ),
    k.from(
      "45140b3247eb9cc8c5b4f0d7b53091f73292089e6e5a63e2749dd3aca9198eda",
      "hex"
    ),
    k.from(
      "2ce1cb0bf9d2f9e102993fbe215152c3b2dd0cabde1c68e5319b839154dbb7f5",
      "hex"
    ),
    k.from(
      "568d6905a2c88708a4b3025190edcfedb1974a606a13c6e5290fcb2ae63edab5",
      "hex"
    ),
    k.from(
      "0376ab1d54c5f9803ce4b2e201a0ee7eef7b57b636e8a93c9b8d4860c96f5fa7",
      "hex"
    ),
    k.from(
      "0a81ec5a929777f145904af38d5d509f66b5e2c58fcdb531058b0e17f3f0b41b",
      "hex"
    ),
    k.from(
      "70a73f7f376b60074248904534b11482d5bf0e698ecc498df52577ebf2e93b9a",
      "hex"
    ),
    k.from(
      "bd71fdf6da97e4cf62d1647add2581b07d79adf8397eb4ecba9c5e8488821423",
      "hex"
    ),
    k.from(
      "5c58468d55f58e497e743982d2b50010b6d165374acf83a7d4a32db768c4408e",
      "hex"
    ),
    k.from(
      "bfd88fe1101c41ae3e801bf8be56350ee9bad1a6b9bd515edc5c6d5b8711ac44",
      "hex"
    ),
    k.from(
      "513b2cecb810d4cde5dd85391adfc6c2dd60d87bb736d2b521484aa47a0ebef6",
      "hex"
    ),
    k.from(
      "88497f01602f3154246ae28c4d5aef10f1d87ebb76626f4ae0b7f95ba7968799",
      "hex"
    ),
    k.from(
      "bc104f15a48be709dca542a7e1d4b9df6f054527e802eaa92d595444258afe71",
      "hex"
    ),
    k.from(
      "55926084ec963a64b96e2abe01ce0ba86a64fbfebcc7aab5afc155b37fd76066",
      "hex"
    ),
    k.from(
      "c1b48299aba5208fe9630ace55ca68a03eda5a519c8802a0d3a673be8f8e557d",
      "hex"
    ),
    k.from(
      "9a114025197c5bb95d94e63d55cd43790847b646b23cdf11ada4a00eff15fb48",
      "hex"
    ),
    k.from(
      "edf7ebbca27a2a384d387b7d4010c666e2edb4843e4c29b4ae1d5b9332e6b24d",
      "hex"
    ),
    k.from(
      "fd73dad31c644ff1b43bef0ccdda96710b9cd9875eca7e31707af3e96d522bbd",
      "hex"
    ),
    k.from(
      "3e84ba4342908516e77573c0992f0979ca084e4685681ff195ccba8a229b8a76",
      "hex"
    ),
    k.from(
      "49e7a442acf0ea6287050054b52564b650e4f49e42e348d6aa38e039e957b1c1",
      "hex"
    ),
    k.from(
      "eec5496b988ce98625b934092eec2908bed0b0f316c2d4730c84eaf1f3d34881",
      "hex"
    ),
    k.from(
      "e23d4a036d7b70e9f595b1422079d2b91edfbb1fb651a0633eaa8a9dc5f80703",
      "hex"
    ),
    k.from(
      "9a6ec012e1a7da9dbe34194d478ad7c0db1822fb071df12981496ed104384113",
      "hex"
    ),
    k.from(
      "59769007f7685d0fcd50872f9f95d5755a5b2b457d81f3692b610a98672f0e1b",
      "hex"
    ),
    k.from(
      "dd6936fe21f8f077c123a1a521c12224f72255b73e03a7260693e8a24b0fa389",
      "hex"
    ),
    k.from(
      "b0bfd52bb0d7d9bd92bf5d4dc13da255c02c542f378365ea893911f55e55f23c",
      "hex"
    ),
    k.from(
      "91e2f5788d5810eba7ba58737de1548a8ecacd014598bc0b143e041b17052552",
      "hex"
    ),
    k.from(
      "f356bea244b7a91eb35d53ca9ad7864ace018e2d35d5f8f96ddf68a6f41aa474",
      "hex"
    ),
    k.from(
      "8a866fd1b276b57e578e921c65828a2bed58e9f2f288054134b7f1f4bfc9cc74",
      "hex"
    ),
    k.from(
      "8fe4fb0af93a4d0d67db0bebb23e37c71bf325dcbcdd240ea04daf58b47e1840",
      "hex"
    ),
    k.from(
      "88ef81de202eb018452e43f864725cea5fbd1fc2d9d205730709c5d8b8690f46",
      "hex"
    ),
    k.from(
      "7d05ebb682339f8c9451ee094eebfefa7953a114edb2f44949452fab7d2fc185",
      "hex"
    ),
    k.from(
      "7e37cb8b4c47090cab36551ba6f45db840680fba166a952db100717f43053fc2",
      "hex"
    ),
    k.from(
      "cb3ccbb76031e5e0138f8dd39a23f9de47ffc35e43c1144cea27d46a5ab1cb5f",
      "hex"
    ),
    k.from(
      "31ad6648f8104138c738f39ea4320133393e3a18cc02296ef97c2ac9ef6731d0",
      "hex"
    ),
    k.from(
      "552f7bdcf1a7af9e6ce672017f4f12abf77240c78e761ac203d1d9d20ac89988",
      "hex"
    ),
    k.from(
      "52f0e1c4e58ec629291b60317f074671b85d7ea80d5b07273463534b32b40234",
      "hex"
    ),
    k.from(
      "e793c9b02fd8aa13e21c31228accb08119643b749c898964b1746d46c3d4cbd2",
      "hex"
    ),
    k.from(
      "4ff460d54b9c86dabfbcfc5712e0400d2bed3fbc4d4fbdaa86e06adcd2a9ad7a",
      "hex"
    ),
    k.from(
      "bec94911c2955676db6c0a550986d76e3ba005667c442c9762b4fbb773de228c",
      "hex"
    ),
    k.from(
      "179fbc148a3dd00fd24ea13458cc43bfa7f59c8182d783a513f6ebec100c8924",
      "hex"
    ),
    k.from(
      "3c4fb0b95ab8b30032f432b86f535fe172c185d0fd39865837cf36187fa6f428",
      "hex"
    ),
    k.from(
      "4d2491414cfe956746ec4cefa6cf6f72e28a1329432f9d8a907ac4cb5dadc15a",
      "hex"
    ),
    k.from(
      "5d56499be4d2e08bcfcad08a3e38723d50503bde706948e42f55603019e528ae",
      "hex"
    ),
    k.from(
      "30d0895a9a448a262091635522d1f52010b5867acae12c78ef958fd4f4389f2f",
      "hex"
    ),
    k.from(
      "43df5774b03e7fef5fe40d931a7bedf1bb2e6b42738c4e6d3841103d3aa7f339",
      "hex"
    ),
    k.from(
      "02ed0eb28c14da45165c566791700d6451d7fb56f0b2ab1d3b8eb070e56edff5",
      "hex"
    ),
    k.from(
      "5cc3d78e4e1d5e45547a04e6873e64f90cf9536d1ccc2ef800f355c4c5fd70fd",
      "hex"
    ),
    k.from(
      "49351b903444c185ccdc5c693d24d8555cb208d6a8141307699f4af063199d78",
      "hex"
    ),
    k.from(
      "2a99f5bc1174b73cbb1d620884e01c34e51ccb3978da125f0e33268883bf4158",
      "hex"
    ),
    k.from(
      "6b9c08e86eb0f767cfad65cd98b62149e5494a67f5845e7bd1ed019f27b86bd6",
      "hex"
    ),
    k.from(
      "a1339d33281a0b56e557d3d32b1ce7f9367eb094bd5fa72a7e5004c8ded7cafe",
      "hex"
    ),
    k.from(
      "b676f2eddae8775cd36cb0f63cd1d4603961f49e6265ba013a2f0307b6d0b804",
      "hex"
    ),
    k.from(
      "a040929a02ce53b4acf4f2ffc6981ce4496f755e6d45fe0b2a692bcd52523f36",
      "hex"
    ),
    k.from(
      "44b545aa8a25e65a73ca15dc27fc36d24c1cb9953a066539b11582dc487b4833",
      "hex"
    ),
    k.from(
      "152a402bfcdf2cd548054d2275b39c7fca3ec0978078b0f0ea76e561a6c7433e",
      "hex"
    ),
    k.from(
      "6cc05041e6445e74696c4cfbc9f80f543b7eabbb44b4ce6f787c6a9971c42f17",
      "hex"
    ),
    k.from(
      "56c77128d98c18d91b4cfdffbc25ee9103d4758ea2abad826a90f3457d460eb4",
      "hex"
    ),
    k.from(
      "27995829fe6a7515c1bfe848f9c4761db16c225929257bf40d0894f29ea8baf2",
      "hex"
    ),
    k.from(
      "b7c36231706e81078c367cb896198f1e3208dd926949dd8f5709a410f75b6292",
      "hex"
    ),
    k.from(
      "96bcec06264976f37460779acf28c5a7cfe8a3c0aae11a8ffcee05c0bddf08c6",
      "hex"
    ),
    k.from(
      "ebc5570c29018c4d67b1aa127baf12f703b4611ebc17b7dab5573894179b93fa",
      "hex"
    ),
    k.from(
      "8ecde6884f3d87b1125ba31ac3fcb13d7016de7f57cc904fe1cb97c6ae98196e",
      "hex"
    ),
    k.from(
      "1ba5b2aa8c65401a82960118f80bec4f62304d83cec4713a19c39c011ea46db4",
      "hex"
    ),
    k.from(
      "18ce6cfe7bf14e60b2e347b8dfe868cb31d02ebb3ada271569f50343b46db3a4",
      "hex"
    ),
    k.from(
      "e35d28419ed02025cfa69038cd623962458da5c695fbdea3c22b0bfb25897092",
      "hex"
    ),
    k.from(
      "54455f7129c20b1447c418f997168f24c58fc5023bf5da5be2eb6e1dd8902ed5",
      "hex"
    ),
    k.from(
      "46edc3689046d53a453fb3104ab80dcaec658b2660ea1629dd7e867990648716",
      "hex"
    ),
    k.from(
      "bfff8fd04433487d6a8aa60c1a29767a9fc2bbb05e420f713a13b992891d3893",
      "hex"
    ),
    k.from(
      "d40e9c86cd8fe468c1776959f49ea774fa548684b6c406f3909261f4dce2575c",
      "hex"
    ),
    k.from(
      "0753e940378c1bd5e3836e395daea5cb839e5046f1bd0eae1951cf10fec7c965",
      "hex"
    ),
    k.from(
      "5a885db19c01d912c5759388938cafbbdf031ab2d48e91ee15589b42971d039c",
      "hex"
    ),
    k.from(
      "85666a562ee0be5ce925c1d8890a6f76a87ec16d4d7d5f29ea7419cf20123b69",
      "hex"
    ),
    k.from(
      "3417bb06cc6007da1b961c920b8ab4ce3fad820e4aa30b9acbc4a74ebdcebc65",
      "hex"
    ),
    k.from(
      "2e7bf16cc22485a7bbe2aa8696750761b0ae39be3b2fe9d0cc6d4ef73491425c",
      "hex"
    ),
    k.from(
      "22a2c1f7bded704cc1e701b5f408c310880fe956b5de2a4a44f99c873a25a7c8",
      "hex"
    ),
    k.from(
      "67add1166b020ae61b8f5fc96813c04c2aa589960796865572a3c7e737613dfd",
      "hex"
    )
    // R3 (Let's Encrypt)
  ]), Mc;
}
/*!
 * protoreader.js - protobufs for bcoin
 * Copyright (c) 2016-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var Nc, x4;
function xo() {
  if (x4) return Nc;
  x4 = 1;
  const e = Xe(), c = $s(), l = {
    VARINT: 0,
    FIXED64: 1,
    DELIMITED: 2,
    START_GROUP: 3,
    END_GROUP: 4,
    FIXED32: 5
  };
  class w extends c {
    /**
     * Create a protoreader.
     * @constructor
     */
    constructor(o, s) {
      super(o, s);
    }
    readVarint() {
      const { size: o, value: s } = m(this.data, this.offset);
      return this.offset += o, s;
    }
    readFieldValue(o, s) {
      const i = this.readField(o, s);
      return i ? (e(i.value != null), i.value) : -1;
    }
    readFieldU64(o, s) {
      const i = this.readField(o, s);
      return i ? (e(i.type === l.VARINT || i.type === l.FIXED64), i.value) : -1;
    }
    readFieldU32(o, s) {
      const i = this.readField(o, s);
      return i ? (e(i.type === l.VARINT || i.type === l.FIXED32), i.value) : -1;
    }
    readFieldBytes(o, s) {
      const i = this.readField(o, s);
      return i ? (e(i.data), i.data) : null;
    }
    readFieldString(o, s, i) {
      const p = this.readField(o, s);
      return p ? (e(p.data), p.data.toString(i || "utf8")) : null;
    }
    nextTag() {
      if (this.left() === 0)
        return -1;
      const o = this.readField();
      return this.seek(-o.size), o.tag;
    }
    readField(o, s) {
      const i = this.offset, p = this.readVarint(), g = new f(p);
      if (o != null && g.tag !== o)
        return e(s, "Non-optional field not present."), this.offset = i, null;
      switch (g.type) {
        case l.VARINT:
          g.value = this.readVarint();
          break;
        case l.FIXED64:
          g.value = this.readU64();
          break;
        case l.DELIMITED:
          g.data = this.readVarBytes();
          break;
        case l.START_GROUP:
          for (g.group = []; ; ) {
            const S = this.readField();
            if (S.type === l.END_GROUP)
              break;
            g.group.push(S);
          }
          break;
        case l.END_GROUP:
          e(!1, "Unexpected end group.");
          break;
        case l.FIXED32:
          g.value = this.readU32();
          break;
        default:
          e(!1, "Bad wire type.");
          break;
      }
      return g.size = this.offset - i, g;
    }
  }
  function m(u, o) {
    let s = 0, i = 128, p = 0;
    for (; i & 128; ) {
      if (o >= u.length) {
        s = 0;
        break;
      }
      switch (i = u[o], p) {
        case 0:
        case 1:
        case 2:
        case 3:
          s += (i & 127) << 7 * p;
          break;
        case 4:
          s += (i & 127) * (1 << 7 * p);
          break;
        default:
          s += (i & 127) * Math.pow(2, 7 * p);
          break;
      }
      o += 1, p += 1, e(p < 7, "Number exceeds 2^53-1.");
    }
    return new n(p, s);
  }
  class f {
    constructor(o) {
      this.tag = o >>> 3, this.type = o & 7, this.size = 0, this.value = 0, this.data = null, this.group = null;
    }
  }
  class n {
    constructor(o, s) {
      this.size = o, this.value = s;
    }
  }
  return Nc = w, Nc;
}
var qc, w4;
function wo() {
  if (w4) return qc;
  w4 = 1;
  const e = Xe(), c = js(), l = {
    VARINT: 0,
    DELIMITED: 2
  };
  class w extends c {
    /**
     * Create a protowriter.
     * @constructor
     */
    constructor() {
      super();
    }
    writeVarint(o) {
      const s = n(o);
      switch (s) {
        case 6: {
          const i = f(o);
          this.writeU32BE(i / 65536 | 0), this.writeU16BE(i & 65535);
          break;
        }
        case 5: {
          const i = f(o);
          this.writeU32BE(i / 256 | 0), this.writeU8(i & 255);
          break;
        }
        case 4: {
          const i = f(o);
          this.writeU32BE(i);
          break;
        }
        case 3: {
          const i = f(o);
          this.writeU16BE(i >> 8), this.writeU8(i & 255);
          break;
        }
        case 2: {
          const i = f(o);
          this.writeU16BE(i);
          break;
        }
        case 1: {
          const i = f(o);
          this.writeU8(i);
          break;
        }
        default: {
          const i = k.allocUnsafe(s);
          m(i, o, 0), this.writeBytes(i);
          break;
        }
      }
    }
    writeFieldVarint(o, s) {
      const i = o << 3 | l.VARINT;
      this.writeVarint(i), this.writeVarint(s);
    }
    writeFieldU64(o, s) {
      e(Number.isSafeInteger(s)), this.writeFieldVarint(o, s);
    }
    writeFieldU32(o, s) {
      e(s <= 4294967295), this.writeFieldVarint(o, s);
    }
    writeFieldBytes(o, s) {
      const i = o << 3 | l.DELIMITED;
      this.writeVarint(i), this.writeVarint(s.length), this.writeBytes(s);
    }
    writeFieldString(o, s, i) {
      typeof s == "string" && (s = k.from(s, i || "utf8")), this.writeFieldBytes(o, s);
    }
  }
  function m(u, o, s) {
    e(Number.isSafeInteger(o), "Number exceeds 2^53-1.");
    do {
      e(s < u.length);
      let i = o & 127;
      o -= o % 128, o /= 128, o !== 0 && (i |= 128), u[s] = i, s += 1;
    } while (o > 0);
    return s;
  }
  function f(u) {
    e(Number.isSafeInteger(u), "Number exceeds 2^53-1.");
    let o = 0, s = 0;
    do {
      e(s < 7);
      let i = u & 127;
      u -= u % 128, u /= 128, u !== 0 && (i |= 128), o *= 256, o += i, s += 1;
    } while (u > 0);
    return o;
  }
  function n(u) {
    e(Number.isSafeInteger(u), "Number exceeds 2^53-1.");
    let o = 0;
    do
      u -= u % 128, u /= 128, o += 1;
    while (u > 0);
    return o;
  }
  return qc = w, qc;
}
var Tc, y4;
function n1() {
  if (y4) return Tc;
  y4 = 1;
  const e = Xe(), c = xo(), l = wo();
  class w {
    /**
     * Create payment details.
     * @constructor
     * @param {Object?} options
     * @property {String|null} network
     * @property {Object[]} outputs
     * @property {Number} time
     * @property {Number} expires
     * @property {String|null} memo
     * @property {String|null} paymentUrl
     * @property {Buffer|null} merchantData
     */
    constructor(f) {
      this.network = null, this.outputs = [], this.time = Math.floor(Date.now() / 1e3), this.expires = -1, this.memo = null, this.paymentUrl = null, this.merchantData = null, f && this.fromOptions(f);
    }
    /**
     * Inject properties from options.
     * @private
     * @param {Object} options
     * @returns {PaymentDetails}
     */
    fromOptions(f) {
      if (f.network != null && (e(typeof f.network == "string"), this.network = f.network), f.outputs) {
        e(Array.isArray(f.outputs));
        for (const n of f.outputs)
          e(n && typeof n == "object"), e(Number.isSafeInteger(n.value) && n.value >= 0), e(k.isBuffer(n.script)), this.outputs.push(n);
      }
      return f.time != null && (e(Number.isSafeInteger(f.time)), this.time = f.time), f.expires != null && (e(Number.isSafeInteger(f.expires)), this.expires = f.expires), f.memo != null && (e(typeof f.memo == "string"), this.memo = f.memo), f.paymentUrl != null && (e(typeof f.paymentUrl == "string"), this.paymentUrl = f.paymentUrl), f.merchantData && this.setData(f.merchantData), this;
    }
    /**
     * Instantiate payment details from options.
     * @param {Object} options
     * @returns {PaymentDetails}
     */
    static fromOptions(f) {
      return new w().fromOptions(f);
    }
    /**
     * Test whether the payment is expired.
     * @returns {Boolean}
     */
    isExpired() {
      return this.expires === -1 ? !1 : Math.floor(Date.now() / 1e3) > this.expires;
    }
    /**
     * Set payment details.
     * @param {Object} data
     * @param {String?} enc
     */
    setData(f, n) {
      if (f == null || k.isBuffer(f)) {
        this.merchantData = f;
        return;
      }
      if (typeof f != "string") {
        e(!n || n === "json"), this.merchantData = k.from(JSON.stringify(f), "utf8");
        return;
      }
      this.merchantData = k.from(f, n);
    }
    /**
     * Get payment details.
     * @param {String?} enc
     * @returns {String|Object|null}
     */
    getData(f) {
      let n = this.merchantData;
      if (!n)
        return null;
      if (!f)
        return n;
      if (f === "json") {
        n = n.toString("utf8");
        try {
          n = JSON.parse(n);
        } catch {
          return null;
        }
        return n;
      }
      return n.toString(f);
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     * @returns {PaymentDetails}
     */
    fromRaw(f) {
      const n = new c(f);
      for (this.network = n.readFieldString(1, !0); n.nextTag() === 2; ) {
        const u = new c(n.readFieldBytes(2)), o = {
          value: u.readFieldU64(1, !0),
          script: u.readFieldBytes(2, !0)
        };
        this.outputs.push(o);
      }
      return this.time = n.readFieldU64(3), this.expires = n.readFieldU64(4, !0), this.memo = n.readFieldString(5, !0), this.paymentUrl = n.readFieldString(6, !0), this.merchantData = n.readFieldBytes(7, !0), this;
    }
    /**
     * Instantiate payment details from serialized data.
     * @param {Buffer} data
     * @returns {PaymentDetails}
     */
    static fromRaw(f, n) {
      return typeof f == "string" && (f = k.from(f, n)), new w().fromRaw(f);
    }
    /**
     * Serialize the payment details (protobuf).
     * @returns {Buffer}
     */
    toRaw() {
      const f = new l();
      this.network != null && f.writeFieldString(1, this.network);
      for (const n of this.outputs) {
        const u = new l();
        u.writeFieldU64(1, n.value), u.writeFieldBytes(2, n.script), f.writeFieldBytes(2, u.render());
      }
      return f.writeFieldU64(3, this.time), this.expires !== -1 && f.writeFieldU64(4, this.expires), this.memo != null && f.writeFieldString(5, this.memo), this.paymentUrl != null && f.writeFieldString(6, this.paymentUrl), this.merchantData && f.writeFieldString(7, this.merchantData), f.render();
    }
  }
  return Tc = w, Tc;
}
var zc, v4;
function wp() {
  if (v4) return zc;
  v4 = 1;
  const e = Xe(), c = xo(), l = wo(), { setData: w, getData: m } = n1().prototype;
  class f {
    /**
     * Create a payment.
     * @constructor
     * @param {Object?} options
     * @property {Buffer} merchantData
     * @property {Buffer[]} transactions
     * @property {Buffer[]} refundTo
     * @property {String|null} memo
     */
    constructor(u) {
      this.merchantData = null, this.transactions = [], this.refundTo = [], this.memo = null, u && this.fromOptions(u);
    }
    /**
     * Inject properties from options.
     * @private
     * @param {Object} options
     * @returns {Payment}
     */
    fromOptions(u) {
      if (u.merchantData && this.setData(u.merchantData), u.transactions) {
        e(Array.isArray(u.transactions));
        for (const o of u.transactions)
          e(k.isBuffer(o)), this.transactions.push(o);
      }
      if (u.refundTo) {
        e(Array.isArray(u.refundTo));
        for (const o of u.refundTo)
          e(o && typeof o == "object"), e(Number.isSafeInteger(o.value) && o.value >= 0), e(k.isBuffer(o.script)), this.refundTo.push(o);
      }
      return u.memo != null && (e(typeof u.memo == "string"), this.memo = u.memo), this;
    }
    /**
     * Instantiate payment from options.
     * @param {Object} options
     * @returns {Payment}
     */
    static fromOptions(u) {
      return new f().fromOptions(u);
    }
    /**
     * Set payment details.
     * @param {Object} data
     * @param {String?} enc
     */
    setData(u, o) {
      return w.call(this, u, o);
    }
    /**
     * Get payment details.
     * @param {String?} enc
     * @returns {String|Object|null}
     */
    getData(u) {
      return m.call(this, u);
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     * @returns {Payment}
     */
    fromRaw(u) {
      const o = new c(u);
      for (this.merchantData = o.readFieldBytes(1, !0); o.nextTag() === 2; ) {
        const s = o.readFieldBytes(2);
        this.transactions.push(s);
      }
      for (; o.nextTag() === 3; ) {
        const s = new c(o.readFieldBytes(3)), i = {
          value: s.readFieldU64(1, !0),
          script: s.readFieldBytes(2, !0)
        };
        this.refundTo.push(i);
      }
      return this.memo = o.readFieldString(4, !0), this;
    }
    /**
     * Instantiate payment from serialized data.
     * @param {Buffer} data
     * @returns {Payment}
     */
    static fromRaw(u, o) {
      return typeof u == "string" && (u = k.from(u, o)), new f().fromRaw(u);
    }
    /**
     * Serialize the payment (protobuf).
     * @returns {Buffer}
     */
    toRaw() {
      const u = new l();
      this.merchantData && u.writeFieldBytes(1, this.merchantData);
      for (const o of this.transactions)
        u.writeFieldBytes(2, o);
      for (const o of this.refundTo) {
        const s = new l();
        s.writeFieldU64(1, o.value), s.writeFieldBytes(2, o.script), u.writeFieldBytes(3, s.render());
      }
      return this.memo != null && u.writeFieldString(4, this.memo), u.render();
    }
  }
  return zc = f, zc;
}
var Cc, S4;
function Hw() {
  if (S4) return Cc;
  S4 = 1;
  const e = Xe(), c = xo(), l = wo(), w = wp();
  class m {
    /**
     * Create a payment ack.
     * @constructor
     * @param {Object?} options
     * @property {Payment} payment
     * @property {String|null} memo
     */
    constructor(n) {
      this.payment = new w(), this.memo = null, n && this.fromOptions(n);
    }
    /**
     * Inject properties from options.
     * @private
     * @param {Object} options
     * @returns {PaymentACK}
     */
    fromOptions(n) {
      return n.payment && this.payment.fromOptions(n.payment), n.memo != null && (e(typeof n.memo == "string"), this.memo = n.memo), this;
    }
    /**
     * Instantiate payment ack from options.
     * @param {Object} options
     * @returns {PaymentACK}
     */
    static fromOptions(n) {
      return new m().fromOptions(n);
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     * @returns {PaymentACK}
     */
    fromRaw(n) {
      const u = new c(n);
      return this.payment.fromRaw(u.readFieldBytes(1)), this.memo = u.readFieldString(2, !0), this;
    }
    /**
     * Instantiate payment ack from serialized data.
     * @param {Buffer} data
     * @returns {PaymentACK}
     */
    static fromRaw(n, u) {
      return typeof n == "string" && (n = k.from(n, u)), new m().fromRaw(n);
    }
    /**
     * Serialize the payment ack (protobuf).
     * @returns {Buffer}
     */
    toRaw() {
      const n = new l();
      return n.writeFieldBytes(1, this.payment.toRaw()), this.memo != null && n.writeFieldString(2, this.memo), n.render();
    }
  }
  return Cc = m, Cc;
}
var Dc = {}, Uc = {}, Os = {}, Fc = {};
/*!
 * fixed.js - fixed number parsing
 * Copyright (c) 2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var E4;
function yp() {
  return E4 || (E4 = 1, function(e) {
    const c = Xe();
    e.encode = function(n, u) {
      c(Number.isSafeInteger(n), "Invalid integer value.");
      let o = "";
      n < 0 && (n = -n, o = "-");
      const s = l(u);
      let i = n % s, p = (n - i) / s;
      for (i = i.toString(10), p = p.toString(10); i.length < u; )
        i = "0" + i;
      return i = i.replace(/0+$/, ""), c(i.length <= u, "Invalid integer value."), i.length === 0 && (i = "0"), u === 0 ? `${o}${p}` : `${o}${p}.${i}`;
    }, e.decode = function(n, u) {
      c(typeof n == "string"), c(n.length <= 32, "Fixed number string too large.");
      let o = 1;
      n.length > 0 && n[0] === "-" && (n = n.substring(1), o = -1);
      let s = n, i = "0";
      const p = n.indexOf(".");
      for (p !== -1 && (s = n.substring(0, p), i = n.substring(p + 1)), s = s.replace(/^0+/, ""), i = i.replace(/0+$/, ""), c(
        s.length <= 16 - u,
        "Fixed number string exceeds 2^53-1."
      ), c(
        i.length <= u,
        "Too many decimal places in fixed number string."
      ), s.length === 0 && (s = "0"); i.length < u; )
        i += "0";
      i.length === 0 && (i = "0"), c(
        /^\d+$/.test(s) && /^\d+$/.test(i),
        "Non-numeric characters in fixed number string."
      ), s = parseInt(s, 10), i = parseInt(i, 10);
      const g = l(u), S = w(g), y = m(g);
      return c(
        s < y || s === y && i <= S,
        "Fixed number string exceeds 2^53-1."
      ), o * (s * g + i);
    }, e.toFloat = function(n, u) {
      return parseFloat(e.encode(n, u));
    }, e.fromFloat = function(n, u) {
      return c(typeof n == "number" && isFinite(n)), c(Number.isSafeInteger(u)), e.decode(n.toFixed(u), u);
    };
    function l(f) {
      switch (f) {
        case 0:
          return 1;
        case 1:
          return 10;
        case 2:
          return 100;
        case 3:
          return 1e3;
        case 4:
          return 1e4;
        case 5:
          return 1e5;
        case 6:
          return 1e6;
        case 7:
          return 1e7;
        case 8:
          return 1e8;
      }
      throw new Error("Exponent is too large.");
    }
    function w(f) {
      switch (f) {
        case 1:
          return 0;
        case 10:
          return 1;
        case 100:
          return 91;
        case 1e3:
          return 991;
        case 1e4:
          return 991;
        case 1e5:
          return 40991;
        case 1e6:
          return 740991;
        case 1e7:
          return 4740991;
        case 1e8:
          return 54740991;
      }
      throw new Error("Exponent is too large.");
    }
    function m(f) {
      switch (f) {
        case 1:
          return 9007199254740991;
        case 10:
          return 900719925474099;
        case 100:
          return 90071992547409;
        case 1e3:
          return 9007199254740;
        case 1e4:
          return 900719925474;
        case 1e5:
          return 90071992547;
        case 1e6:
          return 9007199254;
        case 1e7:
          return 900719925;
        case 1e8:
          return 90071992;
      }
      throw new Error("Exponent is too large.");
    }
  }(Fc)), Fc;
}
/*!
 * amount.js - amount object for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var Hc, I4;
function wi() {
  if (I4) return Hc;
  I4 = 1;
  const e = Xe(), c = yp();
  class l {
    /**
     * Create an amount.
     * @constructor
     * @param {(String|Number)?} value
     * @param {String?} unit
     */
    constructor(m, f) {
      this.value = 0, m != null && this.fromOptions(m, f);
    }
    /**
     * Inject properties from options.
     * @private
     * @param {(String|Number)?} value
     * @param {String?} unit
     * @returns {Amount}
     */
    fromOptions(m, f) {
      return typeof f == "string" ? this.from(f, m) : typeof m == "number" ? this.fromValue(m) : this.fromBTC(m);
    }
    /**
     * Get satoshi value.
     * @returns {Amount}
     */
    toValue() {
      return this.value;
    }
    /**
     * Get satoshi string or value.
     * @param {Boolean?} num
     * @returns {String|Amount}
     */
    toSatoshis(m) {
      return m ? this.value : this.value.toString(10);
    }
    /**
     * Get bits string or value.
     * @param {Boolean?} num
     * @returns {String|Amount}
     */
    toBits(m) {
      return l.encode(this.value, 2, m);
    }
    /**
     * Get mbtc string or value.
     * @param {Boolean?} num
     * @returns {String|Amount}
     */
    toMBTC(m) {
      return l.encode(this.value, 5, m);
    }
    /**
     * Get btc string or value.
     * @param {Boolean?} num
     * @returns {String|Amount}
     */
    toBTC(m) {
      return l.encode(this.value, 8, m);
    }
    /**
     * Get unit string or value.
     * @param {String} unit - Can be `sat`,
     * `ubtc`, `bits`, `mbtc`, or `btc`.
     * @param {Boolean?} num
     * @returns {String|Amount}
     */
    to(m, f) {
      switch (m) {
        case "sat":
          return this.toSatoshis(f);
        case "ubtc":
        case "bits":
          return this.toBits(f);
        case "mbtc":
          return this.toMBTC(f);
        case "btc":
          return this.toBTC(f);
      }
      throw new Error(`Unknown unit "${m}".`);
    }
    /**
     * Convert amount to bitcoin string.
     * @returns {String}
     */
    toString() {
      return this.toBTC();
    }
    /**
     * Inject properties from value.
     * @private
     * @param {Amount} value
     * @returns {Amount}
     */
    fromValue(m) {
      return e(
        Number.isSafeInteger(m) && m >= 0,
        "Value must be an int64."
      ), this.value = m, this;
    }
    /**
     * Inject properties from satoshis.
     * @private
     * @param {Number|String} value
     * @returns {Amount}
     */
    fromSatoshis(m) {
      return this.value = l.decode(m, 0), this;
    }
    /**
     * Inject properties from bits.
     * @private
     * @param {Number|String} value
     * @returns {Amount}
     */
    fromBits(m) {
      return this.value = l.decode(m, 2), this;
    }
    /**
     * Inject properties from mbtc.
     * @private
     * @param {Number|String} value
     * @returns {Amount}
     */
    fromMBTC(m) {
      return this.value = l.decode(m, 5), this;
    }
    /**
     * Inject properties from btc.
     * @private
     * @param {Number|String} value
     * @returns {Amount}
     */
    fromBTC(m) {
      return this.value = l.decode(m, 8), this;
    }
    /**
     * Inject properties from unit.
     * @private
     * @param {String} unit
     * @param {Number|String} value
     * @returns {Amount}
     */
    from(m, f) {
      switch (m) {
        case "sat":
          return this.fromSatoshis(f);
        case "ubtc":
        case "bits":
          return this.fromBits(f);
        case "mbtc":
          return this.fromMBTC(f);
        case "btc":
          return this.fromBTC(f);
      }
      throw new Error(`Unknown unit "${m}".`);
    }
    /**
     * Instantiate amount from options.
     * @param {(String|Number)?} value
     * @param {String?} unit
     * @returns {Amount}
     */
    static fromOptions(m, f) {
      return new this().fromOptions(m, f);
    }
    /**
     * Instantiate amount from value.
     * @private
     * @param {Amount} value
     * @returns {Amount}
     */
    static fromValue(m) {
      return new this().fromValue(m);
    }
    /**
     * Instantiate amount from satoshis.
     * @param {Number|String} value
     * @returns {Amount}
     */
    static fromSatoshis(m) {
      return new this().fromSatoshis(m);
    }
    /**
     * Instantiate amount from bits.
     * @param {Number|String} value
     * @returns {Amount}
     */
    static fromBits(m) {
      return new this().fromBits(m);
    }
    /**
     * Instantiate amount from mbtc.
     * @param {Number|String} value
     * @returns {Amount}
     */
    static fromMBTC(m) {
      return new this().fromMBTC(m);
    }
    /**
     * Instantiate amount from btc.
     * @param {Number|String} value
     * @returns {Amount}
     */
    static fromBTC(m) {
      return new this().fromBTC(m);
    }
    /**
     * Instantiate amount from unit.
     * @param {String} unit
     * @param {Number|String} value
     * @returns {Amount}
     */
    static from(m, f) {
      return new this().from(m, f);
    }
    /**
     * Inspect amount.
     * @returns {String}
     */
    inspect() {
      return `<Amount: ${this.toString()}>`;
    }
    /**
     * Safely convert satoshis to a BTC string.
     * This function explicitly avoids any
     * floating point arithmetic.
     * @param {Amount} value - Satoshis.
     * @returns {String} BTC string.
     */
    static btc(m, f) {
      return typeof m == "string" ? m : l.encode(m, 8, f);
    }
    /**
     * Safely convert a BTC string to satoshis.
     * @param {String} str - BTC
     * @returns {Amount} Satoshis.
     * @throws on parse error
     */
    static value(m) {
      return typeof m == "number" ? m : l.decode(m, 8);
    }
    /**
     * Safely convert satoshis to a BTC string.
     * @param {Amount} value
     * @param {Number} exp - Exponent.
     * @param {Boolean} num - Return a number.
     * @returns {String|Number}
     */
    static encode(m, f, n) {
      return n ? c.toFloat(m, f) : c.encode(m, f);
    }
    /**
     * Safely convert a BTC string to satoshis.
     * @param {String|Number} value - BTC
     * @param {Number} exp - Exponent.
     * @returns {Amount} Satoshis.
     * @throws on parse error
     */
    static decode(m, f) {
      return typeof m == "number" ? c.fromFloat(m, f) : c.decode(m, f);
    }
  }
  return Hc = l, Hc;
}
/*!
 * assert.js - assert for bcrypto
 * Copyright (c) 2020, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var Lc, A4;
function Nt() {
  if (A4) return Lc;
  A4 = 1;
  function e(c, l) {
    if (!c) {
      const w = new Error(l || "Assertion failed");
      throw Error.captureStackTrace && Error.captureStackTrace(w, e), w;
    }
  }
  return Lc = e, Lc;
}
var Kc, O4;
function fi() {
  if (O4) return Kc;
  O4 = 1;
  const e = Nt();
  class c {
    /**
     * Create an HMAC.
     * @param {Function} Hash
     * @param {Number} size
     * @param {Array} [x=[]]
     * @param {Array} [y=[]]
     */
    constructor(w, m, f = [], n = []) {
      e(typeof w == "function"), e(m >>> 0 === m), e(Array.isArray(f)), e(Array.isArray(n)), this.hash = w, this.size = m, this.x = f, this.y = n, this.inner = new w(), this.outer = new w();
    }
    /**
     * Initialize HMAC context.
     * @param {Buffer} data
     */
    init(w) {
      if (e(k.isBuffer(w)), w.length > this.size) {
        const f = this.hash, n = new f();
        n.init(...this.x), n.update(w), w = n.final(...this.y), e(w.length <= this.size);
      }
      const m = k.alloc(this.size);
      for (let f = 0; f < w.length; f++)
        m[f] = w[f] ^ 54;
      for (let f = w.length; f < m.length; f++)
        m[f] = 54;
      this.inner.init(...this.x), this.inner.update(m);
      for (let f = 0; f < w.length; f++)
        m[f] = w[f] ^ 92;
      for (let f = w.length; f < m.length; f++)
        m[f] = 92;
      return this.outer.init(...this.x), this.outer.update(m), this;
    }
    /**
     * Update HMAC context.
     * @param {Buffer} data
     */
    update(w) {
      return this.inner.update(w), this;
    }
    /**
     * Finalize HMAC context.
     * @returns {Buffer}
     */
    final() {
      return this.outer.update(this.inner.final(...this.y)), this.outer.final(...this.y);
    }
  }
  return Kc = c, Kc;
}
var Vc, _4;
function Ar() {
  if (_4) return Vc;
  _4 = 1;
  const e = Nt(), c = fi(), l = -1, w = k.alloc(8, 0), m = k.alloc(64, 0);
  m[0] = 128;
  const f = new Uint32Array([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ]);
  class n {
    constructor() {
      this.state = new Uint32Array(8), this.msg = new Uint32Array(64), this.block = k.alloc(64), this.size = l;
    }
    init() {
      return this.state[0] = 1779033703, this.state[1] = 3144134277, this.state[2] = 1013904242, this.state[3] = 2773480762, this.state[4] = 1359893119, this.state[5] = 2600822924, this.state[6] = 528734635, this.state[7] = 1541459225, this.size = 0, this;
    }
    update(h) {
      return e(k.isBuffer(h)), this._update(h, h.length), this;
    }
    final() {
      return this._final(k.alloc(32));
    }
    _update(h, a) {
      e(this.size !== l, "Context is not initialized.");
      let E = this.size & 63, H = 0;
      if (this.size += a, E > 0) {
        let j = 64 - E;
        if (j > a && (j = a), h.copy(this.block, E, H, H + j), E += j, a -= j, H += j, E < 64)
          return;
        this._transform(this.block, 0);
      }
      for (; a >= 64; )
        this._transform(h, H), H += 64, a -= 64;
      a > 0 && h.copy(this.block, 0, H, H + a);
    }
    _final(h) {
      e(this.size !== l, "Context is not initialized.");
      const a = this.size & 63, E = this.size * 8;
      y(w, E * (1 / 4294967296) >>> 0, 0), y(w, E >>> 0, 4), this._update(m, 1 + (119 - a & 63)), this._update(w, 8);
      for (let H = 0; H < 8; H++)
        y(h, this.state[H], H * 4), this.state[H] = 0;
      for (let H = 0; H < 64; H++)
        this.msg[H] = 0;
      for (let H = 0; H < 64; H++)
        this.block[H] = 0;
      return this.size = l, h;
    }
    _transform(h, a) {
      const E = this.msg;
      let H = this.state[0], j = this.state[1], G = this.state[2], N = this.state[3], T = this.state[4], A = this.state[5], q = this.state[6], _ = this.state[7], F = 0;
      for (; F < 16; F++)
        E[F] = S(h, a + F * 4);
      for (; F < 64; F++)
        E[F] = i(E[F - 2]) + E[F - 7] + s(E[F - 15]) + E[F - 16];
      for (F = 0; F < 64; F++) {
        const R = _ + o(T) + p(T, A, q) + f[F] + E[F], L = u(H) + g(H, j, G);
        _ = q, q = A, A = T, T = N + R >>> 0, N = G, G = j, j = H, H = R + L >>> 0;
      }
      this.state[0] += H, this.state[1] += j, this.state[2] += G, this.state[3] += N, this.state[4] += T, this.state[5] += A, this.state[6] += q, this.state[7] += _;
    }
    static hash() {
      return new n();
    }
    static hmac() {
      return new c(n, 64);
    }
    static digest(h) {
      return n.ctx.init().update(h).final();
    }
    static root(h, a) {
      return e(k.isBuffer(h) && h.length === 32), e(k.isBuffer(a) && a.length === 32), n.ctx.init().update(h).update(a).final();
    }
    static multi(h, a, E) {
      const { ctx: H } = n;
      return H.init(), H.update(h), H.update(a), E && H.update(E), H.final();
    }
    static mac(h, a) {
      return n.hmac().init(a).update(h).final();
    }
  }
  n.native = 0, n.id = "SHA256", n.size = 32, n.bits = 256, n.blockSize = 64, n.zero = k.alloc(32, 0), n.ctx = new n();
  function u(b) {
    return (b >>> 2 | b << 30) ^ (b >>> 13 | b << 19) ^ (b >>> 22 | b << 10);
  }
  function o(b) {
    return (b >>> 6 | b << 26) ^ (b >>> 11 | b << 21) ^ (b >>> 25 | b << 7);
  }
  function s(b) {
    return (b >>> 7 | b << 25) ^ (b >>> 18 | b << 14) ^ b >>> 3;
  }
  function i(b) {
    return (b >>> 17 | b << 15) ^ (b >>> 19 | b << 13) ^ b >>> 10;
  }
  function p(b, h, a) {
    return a ^ b & (h ^ a);
  }
  function g(b, h, a) {
    return b & h | a & (b | h);
  }
  function S(b, h) {
    return b[h++] * 16777216 + b[h++] * 65536 + b[h++] * 256 + b[h];
  }
  function y(b, h, a) {
    return b[a++] = h >>> 24, b[a++] = h >>> 16, b[a++] = h >>> 8, b[a++] = h, a;
  }
  return Vc = n, Vc;
}
var $c, R4;
function s1() {
  if (R4) return $c;
  R4 = 1;
  const e = Nt(), c = fi(), l = -1, w = k.alloc(8, 0), m = k.alloc(64, 0);
  m[0] = 128;
  const f = new Uint8Array([
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    7,
    4,
    13,
    1,
    10,
    6,
    15,
    3,
    12,
    0,
    9,
    5,
    2,
    14,
    11,
    8,
    3,
    10,
    14,
    4,
    9,
    15,
    8,
    1,
    2,
    7,
    0,
    6,
    13,
    11,
    5,
    12,
    1,
    9,
    11,
    10,
    0,
    8,
    12,
    4,
    13,
    3,
    7,
    15,
    14,
    5,
    6,
    2,
    4,
    0,
    5,
    9,
    7,
    12,
    2,
    10,
    14,
    1,
    3,
    8,
    11,
    6,
    15,
    13
  ]), n = new Uint8Array([
    5,
    14,
    7,
    0,
    9,
    2,
    11,
    4,
    13,
    6,
    15,
    8,
    1,
    10,
    3,
    12,
    6,
    11,
    3,
    7,
    0,
    13,
    5,
    10,
    14,
    15,
    8,
    12,
    4,
    9,
    1,
    2,
    15,
    5,
    1,
    3,
    7,
    14,
    6,
    9,
    11,
    8,
    12,
    2,
    10,
    0,
    4,
    13,
    8,
    6,
    4,
    1,
    3,
    11,
    15,
    0,
    5,
    12,
    2,
    13,
    9,
    7,
    10,
    14,
    12,
    15,
    10,
    4,
    1,
    5,
    8,
    7,
    6,
    2,
    13,
    14,
    0,
    3,
    9,
    11
  ]), u = new Uint8Array([
    11,
    14,
    15,
    12,
    5,
    8,
    7,
    9,
    11,
    13,
    14,
    15,
    6,
    7,
    9,
    8,
    7,
    6,
    8,
    13,
    11,
    9,
    7,
    15,
    7,
    12,
    15,
    9,
    11,
    7,
    13,
    12,
    11,
    13,
    6,
    7,
    14,
    9,
    13,
    15,
    14,
    8,
    13,
    6,
    5,
    12,
    7,
    5,
    11,
    12,
    14,
    15,
    14,
    15,
    9,
    8,
    9,
    14,
    5,
    6,
    8,
    6,
    5,
    12,
    9,
    15,
    5,
    11,
    6,
    8,
    13,
    12,
    5,
    12,
    13,
    14,
    11,
    8,
    5,
    6
  ]), o = new Uint8Array([
    8,
    9,
    9,
    11,
    13,
    15,
    15,
    5,
    7,
    7,
    8,
    11,
    14,
    14,
    12,
    6,
    9,
    13,
    15,
    7,
    12,
    8,
    9,
    11,
    7,
    7,
    12,
    7,
    6,
    15,
    13,
    11,
    9,
    7,
    15,
    11,
    8,
    6,
    6,
    14,
    12,
    13,
    5,
    14,
    13,
    13,
    7,
    5,
    15,
    5,
    8,
    11,
    14,
    14,
    6,
    14,
    6,
    9,
    12,
    9,
    12,
    5,
    15,
    8,
    8,
    5,
    12,
    9,
    12,
    5,
    14,
    6,
    8,
    13,
    6,
    5,
    15,
    13,
    11,
    11
  ]);
  class s {
    constructor() {
      this.state = new Uint32Array(5), this.msg = new Uint32Array(16), this.block = k.alloc(64), this.size = l;
    }
    init() {
      return this.state[0] = 1732584193, this.state[1] = 4023233417, this.state[2] = 2562383102, this.state[3] = 271733878, this.state[4] = 3285377520, this.size = 0, this;
    }
    update(a) {
      return e(k.isBuffer(a)), this._update(a, a.length), this;
    }
    final() {
      return this._final(k.alloc(20));
    }
    _update(a, E) {
      e(this.size !== l, "Context is not initialized.");
      let H = this.size & 63, j = 0;
      if (this.size += E, H > 0) {
        let G = 64 - H;
        if (G > E && (G = E), a.copy(this.block, H, j, j + G), H += G, E -= G, j += G, H < 64)
          return;
        this._transform(this.block, 0);
      }
      for (; E >= 64; )
        this._transform(a, j), j += 64, E -= 64;
      E > 0 && a.copy(this.block, 0, j, j + E);
    }
    _final(a) {
      e(this.size !== l, "Context is not initialized.");
      const E = this.size & 63, H = this.size * 8;
      b(w, H >>> 0, 0), b(w, H * (1 / 4294967296) >>> 0, 4), this._update(m, 1 + (119 - E & 63)), this._update(w, 8);
      for (let j = 0; j < 5; j++)
        b(a, this.state[j], j * 4), this.state[j] = 0;
      for (let j = 0; j < 16; j++)
        this.msg[j] = 0;
      for (let j = 0; j < 64; j++)
        this.block[j] = 0;
      return this.size = l, a;
    }
    _transform(a, E) {
      const H = this.msg;
      let j = this.state[0], G = this.state[1], N = this.state[2], T = this.state[3], A = this.state[4], q = j, _ = G, F = N, R = T, L = A;
      for (let ue = 0; ue < 16; ue++)
        H[ue] = y(a, E + ue * 4);
      for (let ue = 0; ue < 80; ue++) {
        let ae = j + p(ue, G, N, T) + H[f[ue]] + g(ue), D = i(ae, u[ue]), Q = D + A;
        j = A, A = T, T = i(N, 10), N = G, G = Q, ae = q + p(79 - ue, _, F, R) + H[n[ue]] + S(ue), D = i(ae, o[ue]), Q = D + L, q = L, L = R, R = i(F, 10), F = _, _ = Q;
      }
      const fe = this.state[1] + N + R;
      this.state[1] = this.state[2] + T + L, this.state[2] = this.state[3] + A + q, this.state[3] = this.state[4] + j + _, this.state[4] = this.state[0] + G + F, this.state[0] = fe;
    }
    static hash() {
      return new s();
    }
    static hmac() {
      return new c(s, 64);
    }
    static digest(a) {
      return s.ctx.init().update(a).final();
    }
    static root(a, E) {
      return e(k.isBuffer(a) && a.length === 20), e(k.isBuffer(E) && E.length === 20), s.ctx.init().update(a).update(E).final();
    }
    static multi(a, E, H) {
      const { ctx: j } = s;
      return j.init(), j.update(a), j.update(E), H && j.update(H), j.final();
    }
    static mac(a, E) {
      return s.hmac().init(E).update(a).final();
    }
  }
  s.native = 0, s.id = "RIPEMD160", s.size = 20, s.bits = 160, s.blockSize = 64, s.zero = k.alloc(20, 0), s.ctx = new s();
  function i(h, a) {
    return h << a | h >>> 32 - a;
  }
  function p(h, a, E, H) {
    return h <= 15 ? a ^ E ^ H : h <= 31 ? a & E | ~a & H : h <= 47 ? (a | ~E) ^ H : h <= 63 ? a & H | E & ~H : a ^ (E | ~H);
  }
  function g(h) {
    return h <= 15 ? 0 : h <= 31 ? 1518500249 : h <= 47 ? 1859775393 : h <= 63 ? 2400959708 : 2840853838;
  }
  function S(h) {
    return h <= 15 ? 1352829926 : h <= 31 ? 1548603684 : h <= 47 ? 1836072691 : h <= 63 ? 2053994217 : 0;
  }
  function y(h, a) {
    return h[a++] + h[a++] * 256 + h[a++] * 65536 + h[a] * 16777216;
  }
  function b(h, a, E) {
    return h[E++] = a, a >>>= 8, h[E++] = a, a >>>= 8, h[E++] = a, a >>>= 8, h[E++] = a, E;
  }
  return $c = s, $c;
}
var jc, P4;
function Xi() {
  if (P4) return jc;
  P4 = 1;
  const e = Nt(), c = Ar(), l = s1(), w = fi(), m = new l();
  class f {
    constructor() {
      this.ctx = new c();
    }
    init() {
      return this.ctx.init(), this;
    }
    update(u) {
      return this.ctx.update(u), this;
    }
    final() {
      const u = k.alloc(32);
      return this.ctx._final(u), m.init(), m.update(u), m._final(u), u.slice(0, 20);
    }
    static hash() {
      return new f();
    }
    static hmac() {
      return new w(f, 64);
    }
    static digest(u) {
      return f.ctx.init().update(u).final();
    }
    static root(u, o) {
      return e(k.isBuffer(u) && u.length === 20), e(k.isBuffer(o) && o.length === 20), f.ctx.init().update(u).update(o).final();
    }
    static multi(u, o, s) {
      const { ctx: i } = f;
      return i.init(), i.update(u), i.update(o), s && i.update(s), i.final();
    }
    static mac(u, o) {
      return f.hmac().init(o).update(u).final();
    }
  }
  return f.native = 0, f.id = "HASH160", f.size = 20, f.bits = 160, f.blockSize = 64, f.zero = k.alloc(20, 0), f.ctx = new f(), jc = f, jc;
}
var Yc, k4;
function mr() {
  if (k4) return Yc;
  k4 = 1;
  const e = Nt(), c = Ar(), l = fi();
  class w {
    constructor() {
      this.ctx = new c();
    }
    init() {
      return this.ctx.init(), this;
    }
    update(f) {
      return this.ctx.update(f), this;
    }
    final() {
      const f = k.alloc(32);
      return this.ctx._final(f), this.ctx.init(), this.ctx.update(f), this.ctx._final(f), f;
    }
    static hash() {
      return new w();
    }
    static hmac() {
      return new l(w, 64);
    }
    static digest(f) {
      return w.ctx.init().update(f).final();
    }
    static root(f, n) {
      return e(k.isBuffer(f) && f.length === 32), e(k.isBuffer(n) && n.length === 32), w.ctx.init().update(f).update(n).final();
    }
    static multi(f, n, u) {
      const { ctx: o } = w;
      return o.init(), o.update(f), o.update(n), u && o.update(u), o.final();
    }
    static mac(f, n) {
      return w.hmac().init(n).update(f).final();
    }
  }
  return w.native = 0, w.id = "HASH256", w.size = 32, w.bits = 256, w.blockSize = 64, w.zero = k.alloc(32, 0), w.ctx = new w(), Yc = w, Yc;
}
var Xc = {};
/*!
 * binary.js - binary search utils for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var B4;
function yo() {
  return B4 || (B4 = 1, function(e) {
    e.search = function(w, m, f, n) {
      let u = 0, o = w.length - 1;
      for (; u <= o; ) {
        const s = u + o >>> 1, i = f(w[s], m);
        if (i === 0)
          return s;
        i < 0 ? u = s + 1 : o = s - 1;
      }
      return n ? u : -1;
    }, e.insert = function(w, m, f, n) {
      const u = e.search(w, m, f, !0);
      return n && u < w.length && f(w[u], m) === 0 ? -1 : (u === 0 ? w.unshift(m) : u === w.length ? w.push(m) : w.splice(u, 0, m), u);
    }, e.remove = function(w, m, f) {
      const n = e.search(w, m, f, !1);
      return n === -1 ? !1 : (c(w, n), !0);
    };
    function c(l, w) {
      if (w === 0) {
        l.shift();
        return;
      }
      let m = w + 1;
      for (; m < l.length; )
        l[w++] = l[m++];
      l.pop();
    }
  }(Xc)), Xc;
}
var Gc = {}, Jc = {}, Wc = {}, Zc = {}, Qc, M4;
function Lw() {
  if (M4) return Qc;
  M4 = 1;
  var e = /* @__PURE__ */ Gt(), c = /* @__PURE__ */ mp(), l = c(/^\s*(?:function)?\*/), w = xi()(), m = mo(), f = e("Object.prototype.toString"), n = e("Function.prototype.toString"), u = function() {
    if (!w)
      return !1;
    try {
      return Function("return function*() {}")();
    } catch {
    }
  }, o;
  return Qc = function(i) {
    if (typeof i != "function")
      return !1;
    if (l(n(i)))
      return !0;
    if (!w) {
      var p = f(i);
      return p === "[object GeneratorFunction]";
    }
    if (!m)
      return !1;
    if (typeof o > "u") {
      var g = u();
      o = g ? (
        /** @type {GeneratorFunctionConstructor} */
        m(g)
      ) : !1;
    }
    return m(i) === o;
  }, Qc;
}
var eu, N4;
function Kw() {
  if (N4) return eu;
  N4 = 1;
  var e = /* @__PURE__ */ i1();
  return eu = function(l) {
    return !!e(l);
  }, eu;
}
var q4;
function Vw() {
  return q4 || (q4 = 1, function(e) {
    var c = /* @__PURE__ */ t1(), l = Lw(), w = /* @__PURE__ */ i1(), m = /* @__PURE__ */ Kw();
    function f(r) {
      return r.call.bind(r);
    }
    var n = typeof BigInt < "u", u = typeof Symbol < "u", o = f(Object.prototype.toString), s = f(Number.prototype.valueOf), i = f(String.prototype.valueOf), p = f(Boolean.prototype.valueOf);
    if (n)
      var g = f(BigInt.prototype.valueOf);
    if (u)
      var S = f(Symbol.prototype.valueOf);
    function y(r, x) {
      if (typeof r != "object")
        return !1;
      try {
        return x(r), !0;
      } catch {
        return !1;
      }
    }
    e.isArgumentsObject = c, e.isGeneratorFunction = l, e.isTypedArray = m;
    function b(r) {
      return typeof Promise < "u" && r instanceof Promise || r !== null && typeof r == "object" && typeof r.then == "function" && typeof r.catch == "function";
    }
    e.isPromise = b;
    function h(r) {
      return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(r) : m(r) || he(r);
    }
    e.isArrayBufferView = h;
    function a(r) {
      return w(r) === "Uint8Array";
    }
    e.isUint8Array = a;
    function E(r) {
      return w(r) === "Uint8ClampedArray";
    }
    e.isUint8ClampedArray = E;
    function H(r) {
      return w(r) === "Uint16Array";
    }
    e.isUint16Array = H;
    function j(r) {
      return w(r) === "Uint32Array";
    }
    e.isUint32Array = j;
    function G(r) {
      return w(r) === "Int8Array";
    }
    e.isInt8Array = G;
    function N(r) {
      return w(r) === "Int16Array";
    }
    e.isInt16Array = N;
    function T(r) {
      return w(r) === "Int32Array";
    }
    e.isInt32Array = T;
    function A(r) {
      return w(r) === "Float32Array";
    }
    e.isFloat32Array = A;
    function q(r) {
      return w(r) === "Float64Array";
    }
    e.isFloat64Array = q;
    function _(r) {
      return w(r) === "BigInt64Array";
    }
    e.isBigInt64Array = _;
    function F(r) {
      return w(r) === "BigUint64Array";
    }
    e.isBigUint64Array = F;
    function R(r) {
      return o(r) === "[object Map]";
    }
    R.working = typeof Map < "u" && R(/* @__PURE__ */ new Map());
    function L(r) {
      return typeof Map > "u" ? !1 : R.working ? R(r) : r instanceof Map;
    }
    e.isMap = L;
    function fe(r) {
      return o(r) === "[object Set]";
    }
    fe.working = typeof Set < "u" && fe(/* @__PURE__ */ new Set());
    function ue(r) {
      return typeof Set > "u" ? !1 : fe.working ? fe(r) : r instanceof Set;
    }
    e.isSet = ue;
    function ae(r) {
      return o(r) === "[object WeakMap]";
    }
    ae.working = typeof WeakMap < "u" && ae(/* @__PURE__ */ new WeakMap());
    function D(r) {
      return typeof WeakMap > "u" ? !1 : ae.working ? ae(r) : r instanceof WeakMap;
    }
    e.isWeakMap = D;
    function Q(r) {
      return o(r) === "[object WeakSet]";
    }
    Q.working = typeof WeakSet < "u" && Q(/* @__PURE__ */ new WeakSet());
    function W(r) {
      return Q(r);
    }
    e.isWeakSet = W;
    function oe(r) {
      return o(r) === "[object ArrayBuffer]";
    }
    oe.working = typeof ArrayBuffer < "u" && oe(new ArrayBuffer());
    function v(r) {
      return typeof ArrayBuffer > "u" ? !1 : oe.working ? oe(r) : r instanceof ArrayBuffer;
    }
    e.isArrayBuffer = v;
    function Y(r) {
      return o(r) === "[object DataView]";
    }
    Y.working = typeof ArrayBuffer < "u" && typeof DataView < "u" && Y(new DataView(new ArrayBuffer(1), 0, 1));
    function he(r) {
      return typeof DataView > "u" ? !1 : Y.working ? Y(r) : r instanceof DataView;
    }
    e.isDataView = he;
    var le = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : void 0;
    function ge(r) {
      return o(r) === "[object SharedArrayBuffer]";
    }
    function Ee(r) {
      return typeof le > "u" ? !1 : (typeof ge.working > "u" && (ge.working = ge(new le())), ge.working ? ge(r) : r instanceof le);
    }
    e.isSharedArrayBuffer = Ee;
    function we(r) {
      return o(r) === "[object AsyncFunction]";
    }
    e.isAsyncFunction = we;
    function z(r) {
      return o(r) === "[object Map Iterator]";
    }
    e.isMapIterator = z;
    function I(r) {
      return o(r) === "[object Set Iterator]";
    }
    e.isSetIterator = I;
    function ne(r) {
      return o(r) === "[object Generator]";
    }
    e.isGeneratorObject = ne;
    function t(r) {
      return o(r) === "[object WebAssembly.Module]";
    }
    e.isWebAssemblyCompiledModule = t;
    function d(r) {
      return y(r, s);
    }
    e.isNumberObject = d;
    function B(r) {
      return y(r, i);
    }
    e.isStringObject = B;
    function U(r) {
      return y(r, p);
    }
    e.isBooleanObject = U;
    function J(r) {
      return n && y(r, g);
    }
    e.isBigIntObject = J;
    function C(r) {
      return u && y(r, S);
    }
    e.isSymbolObject = C;
    function M(r) {
      return d(r) || B(r) || U(r) || J(r) || C(r);
    }
    e.isBoxedPrimitive = M;
    function $(r) {
      return typeof Uint8Array < "u" && (v(r) || Ee(r));
    }
    e.isAnyArrayBuffer = $, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(r) {
      Object.defineProperty(e, r, {
        enumerable: !1,
        value: function() {
          throw new Error(r + " is not supported in userland");
        }
      });
    });
  }(Zc)), Zc;
}
var tu, T4;
function $w() {
  return T4 || (T4 = 1, tu = function(c) {
    return c && typeof c == "object" && typeof c.copy == "function" && typeof c.fill == "function" && typeof c.readUInt8 == "function";
  }), tu;
}
var _s = { exports: {} }, z4;
function jw() {
  return z4 || (z4 = 1, typeof Object.create == "function" ? _s.exports = function(c, l) {
    l && (c.super_ = l, c.prototype = Object.create(l.prototype, {
      constructor: {
        value: c,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }));
  } : _s.exports = function(c, l) {
    if (l) {
      c.super_ = l;
      var w = function() {
      };
      w.prototype = l.prototype, c.prototype = new w(), c.prototype.constructor = c;
    }
  }), _s.exports;
}
var C4;
function Ci() {
  return C4 || (C4 = 1, function(e) {
    var c = Object.getOwnPropertyDescriptors || function(he) {
      for (var le = Object.keys(he), ge = {}, Ee = 0; Ee < le.length; Ee++)
        ge[le[Ee]] = Object.getOwnPropertyDescriptor(he, le[Ee]);
      return ge;
    }, l = /%[sdj%]/g;
    e.format = function(Y) {
      if (!G(Y)) {
        for (var he = [], le = 0; le < arguments.length; le++)
          he.push(n(arguments[le]));
        return he.join(" ");
      }
      for (var le = 1, ge = arguments, Ee = ge.length, we = String(Y).replace(l, function(I) {
        if (I === "%%") return "%";
        if (le >= Ee) return I;
        switch (I) {
          case "%s":
            return String(ge[le++]);
          case "%d":
            return Number(ge[le++]);
          case "%j":
            try {
              return JSON.stringify(ge[le++]);
            } catch {
              return "[Circular]";
            }
          default:
            return I;
        }
      }), z = ge[le]; le < Ee; z = ge[++le])
        E(z) || !q(z) ? we += " " + z : we += " " + n(z);
      return we;
    }, e.deprecate = function(Y, he) {
      if (typeof St < "u" && St.noDeprecation === !0)
        return Y;
      if (typeof St > "u")
        return function() {
          return e.deprecate(Y, he).apply(this, arguments);
        };
      var le = !1;
      function ge() {
        if (!le) {
          if (St.throwDeprecation)
            throw new Error(he);
          St.traceDeprecation ? console.trace(he) : console.error(he), le = !0;
        }
        return Y.apply(this, arguments);
      }
      return ge;
    };
    var w = {}, m = /^$/;
    if (St.env.NODE_DEBUG) {
      var f = St.env.NODE_DEBUG;
      f = f.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), m = new RegExp("^" + f + "$", "i");
    }
    e.debuglog = function(Y) {
      if (Y = Y.toUpperCase(), !w[Y])
        if (m.test(Y)) {
          var he = St.pid;
          w[Y] = function() {
            var le = e.format.apply(e, arguments);
            console.error("%s %d: %s", Y, he, le);
          };
        } else
          w[Y] = function() {
          };
      return w[Y];
    };
    function n(Y, he) {
      var le = {
        seen: [],
        stylize: o
      };
      return arguments.length >= 3 && (le.depth = arguments[2]), arguments.length >= 4 && (le.colors = arguments[3]), a(he) ? le.showHidden = he : he && e._extend(le, he), T(le.showHidden) && (le.showHidden = !1), T(le.depth) && (le.depth = 2), T(le.colors) && (le.colors = !1), T(le.customInspect) && (le.customInspect = !0), le.colors && (le.stylize = u), i(le, Y, le.depth);
    }
    e.inspect = n, n.colors = {
      bold: [1, 22],
      italic: [3, 23],
      underline: [4, 24],
      inverse: [7, 27],
      white: [37, 39],
      grey: [90, 39],
      black: [30, 39],
      blue: [34, 39],
      cyan: [36, 39],
      green: [32, 39],
      magenta: [35, 39],
      red: [31, 39],
      yellow: [33, 39]
    }, n.styles = {
      special: "cyan",
      number: "yellow",
      boolean: "yellow",
      undefined: "grey",
      null: "bold",
      string: "green",
      date: "magenta",
      // "name": intentionally not styling
      regexp: "red"
    };
    function u(Y, he) {
      var le = n.styles[he];
      return le ? "\x1B[" + n.colors[le][0] + "m" + Y + "\x1B[" + n.colors[le][1] + "m" : Y;
    }
    function o(Y, he) {
      return Y;
    }
    function s(Y) {
      var he = {};
      return Y.forEach(function(le, ge) {
        he[le] = !0;
      }), he;
    }
    function i(Y, he, le) {
      if (Y.customInspect && he && R(he.inspect) && // Filter out the util module, it's inspect function is special
      he.inspect !== e.inspect && // Also filter out any prototype objects using the circular check.
      !(he.constructor && he.constructor.prototype === he)) {
        var ge = he.inspect(le, Y);
        return G(ge) || (ge = i(Y, ge, le)), ge;
      }
      var Ee = p(Y, he);
      if (Ee)
        return Ee;
      var we = Object.keys(he), z = s(we);
      if (Y.showHidden && (we = Object.getOwnPropertyNames(he)), F(he) && (we.indexOf("message") >= 0 || we.indexOf("description") >= 0))
        return g(he);
      if (we.length === 0) {
        if (R(he)) {
          var I = he.name ? ": " + he.name : "";
          return Y.stylize("[Function" + I + "]", "special");
        }
        if (A(he))
          return Y.stylize(RegExp.prototype.toString.call(he), "regexp");
        if (_(he))
          return Y.stylize(Date.prototype.toString.call(he), "date");
        if (F(he))
          return g(he);
      }
      var ne = "", t = !1, d = ["{", "}"];
      if (h(he) && (t = !0, d = ["[", "]"]), R(he)) {
        var B = he.name ? ": " + he.name : "";
        ne = " [Function" + B + "]";
      }
      if (A(he) && (ne = " " + RegExp.prototype.toString.call(he)), _(he) && (ne = " " + Date.prototype.toUTCString.call(he)), F(he) && (ne = " " + g(he)), we.length === 0 && (!t || he.length == 0))
        return d[0] + ne + d[1];
      if (le < 0)
        return A(he) ? Y.stylize(RegExp.prototype.toString.call(he), "regexp") : Y.stylize("[Object]", "special");
      Y.seen.push(he);
      var U;
      return t ? U = S(Y, he, le, z, we) : U = we.map(function(J) {
        return y(Y, he, le, z, J, t);
      }), Y.seen.pop(), b(U, ne, d);
    }
    function p(Y, he) {
      if (T(he))
        return Y.stylize("undefined", "undefined");
      if (G(he)) {
        var le = "'" + JSON.stringify(he).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return Y.stylize(le, "string");
      }
      if (j(he))
        return Y.stylize("" + he, "number");
      if (a(he))
        return Y.stylize("" + he, "boolean");
      if (E(he))
        return Y.stylize("null", "null");
    }
    function g(Y) {
      return "[" + Error.prototype.toString.call(Y) + "]";
    }
    function S(Y, he, le, ge, Ee) {
      for (var we = [], z = 0, I = he.length; z < I; ++z)
        Q(he, String(z)) ? we.push(y(
          Y,
          he,
          le,
          ge,
          String(z),
          !0
        )) : we.push("");
      return Ee.forEach(function(ne) {
        ne.match(/^\d+$/) || we.push(y(
          Y,
          he,
          le,
          ge,
          ne,
          !0
        ));
      }), we;
    }
    function y(Y, he, le, ge, Ee, we) {
      var z, I, ne;
      if (ne = Object.getOwnPropertyDescriptor(he, Ee) || { value: he[Ee] }, ne.get ? ne.set ? I = Y.stylize("[Getter/Setter]", "special") : I = Y.stylize("[Getter]", "special") : ne.set && (I = Y.stylize("[Setter]", "special")), Q(ge, Ee) || (z = "[" + Ee + "]"), I || (Y.seen.indexOf(ne.value) < 0 ? (E(le) ? I = i(Y, ne.value, null) : I = i(Y, ne.value, le - 1), I.indexOf(`
`) > -1 && (we ? I = I.split(`
`).map(function(t) {
        return "  " + t;
      }).join(`
`).slice(2) : I = `
` + I.split(`
`).map(function(t) {
        return "   " + t;
      }).join(`
`))) : I = Y.stylize("[Circular]", "special")), T(z)) {
        if (we && Ee.match(/^\d+$/))
          return I;
        z = JSON.stringify("" + Ee), z.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (z = z.slice(1, -1), z = Y.stylize(z, "name")) : (z = z.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), z = Y.stylize(z, "string"));
      }
      return z + ": " + I;
    }
    function b(Y, he, le) {
      var ge = Y.reduce(function(Ee, we) {
        return we.indexOf(`
`) >= 0, Ee + we.replace(/\u001b\[\d\d?m/g, "").length + 1;
      }, 0);
      return ge > 60 ? le[0] + (he === "" ? "" : he + `
 `) + " " + Y.join(`,
  `) + " " + le[1] : le[0] + he + " " + Y.join(", ") + " " + le[1];
    }
    e.types = Vw();
    function h(Y) {
      return Array.isArray(Y);
    }
    e.isArray = h;
    function a(Y) {
      return typeof Y == "boolean";
    }
    e.isBoolean = a;
    function E(Y) {
      return Y === null;
    }
    e.isNull = E;
    function H(Y) {
      return Y == null;
    }
    e.isNullOrUndefined = H;
    function j(Y) {
      return typeof Y == "number";
    }
    e.isNumber = j;
    function G(Y) {
      return typeof Y == "string";
    }
    e.isString = G;
    function N(Y) {
      return typeof Y == "symbol";
    }
    e.isSymbol = N;
    function T(Y) {
      return Y === void 0;
    }
    e.isUndefined = T;
    function A(Y) {
      return q(Y) && fe(Y) === "[object RegExp]";
    }
    e.isRegExp = A, e.types.isRegExp = A;
    function q(Y) {
      return typeof Y == "object" && Y !== null;
    }
    e.isObject = q;
    function _(Y) {
      return q(Y) && fe(Y) === "[object Date]";
    }
    e.isDate = _, e.types.isDate = _;
    function F(Y) {
      return q(Y) && (fe(Y) === "[object Error]" || Y instanceof Error);
    }
    e.isError = F, e.types.isNativeError = F;
    function R(Y) {
      return typeof Y == "function";
    }
    e.isFunction = R;
    function L(Y) {
      return Y === null || typeof Y == "boolean" || typeof Y == "number" || typeof Y == "string" || typeof Y == "symbol" || // ES6 symbol
      typeof Y > "u";
    }
    e.isPrimitive = L, e.isBuffer = $w();
    function fe(Y) {
      return Object.prototype.toString.call(Y);
    }
    function ue(Y) {
      return Y < 10 ? "0" + Y.toString(10) : Y.toString(10);
    }
    var ae = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    function D() {
      var Y = /* @__PURE__ */ new Date(), he = [
        ue(Y.getHours()),
        ue(Y.getMinutes()),
        ue(Y.getSeconds())
      ].join(":");
      return [Y.getDate(), ae[Y.getMonth()], he].join(" ");
    }
    e.log = function() {
      console.log("%s - %s", D(), e.format.apply(e, arguments));
    }, e.inherits = jw(), e._extend = function(Y, he) {
      if (!he || !q(he)) return Y;
      for (var le = Object.keys(he), ge = le.length; ge--; )
        Y[le[ge]] = he[le[ge]];
      return Y;
    };
    function Q(Y, he) {
      return Object.prototype.hasOwnProperty.call(Y, he);
    }
    var W = typeof Symbol < "u" ? Symbol("util.promisify.custom") : void 0;
    e.promisify = function(he) {
      if (typeof he != "function")
        throw new TypeError('The "original" argument must be of type Function');
      if (W && he[W]) {
        var le = he[W];
        if (typeof le != "function")
          throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        return Object.defineProperty(le, W, {
          value: le,
          enumerable: !1,
          writable: !1,
          configurable: !0
        }), le;
      }
      function le() {
        for (var ge, Ee, we = new Promise(function(ne, t) {
          ge = ne, Ee = t;
        }), z = [], I = 0; I < arguments.length; I++)
          z.push(arguments[I]);
        z.push(function(ne, t) {
          ne ? Ee(ne) : ge(t);
        });
        try {
          he.apply(this, z);
        } catch (ne) {
          Ee(ne);
        }
        return we;
      }
      return Object.setPrototypeOf(le, Object.getPrototypeOf(he)), W && Object.defineProperty(le, W, {
        value: le,
        enumerable: !1,
        writable: !1,
        configurable: !0
      }), Object.defineProperties(
        le,
        c(he)
      );
    }, e.promisify.custom = W;
    function oe(Y, he) {
      if (!Y) {
        var le = new Error("Promise was rejected with a falsy value");
        le.reason = Y, Y = le;
      }
      return he(Y);
    }
    function v(Y) {
      if (typeof Y != "function")
        throw new TypeError('The "original" argument must be of type Function');
      function he() {
        for (var le = [], ge = 0; ge < arguments.length; ge++)
          le.push(arguments[ge]);
        var Ee = le.pop();
        if (typeof Ee != "function")
          throw new TypeError("The last argument must be of type Function");
        var we = this, z = function() {
          return Ee.apply(we, arguments);
        };
        Y.apply(this, le).then(
          function(I) {
            St.nextTick(z.bind(null, null, I));
          },
          function(I) {
            St.nextTick(oe.bind(null, I, z));
          }
        );
      }
      return Object.setPrototypeOf(he, Object.getPrototypeOf(Y)), Object.defineProperties(
        he,
        c(Y)
      ), he;
    }
    e.callbackify = v;
  }(Wc)), Wc;
}
/*!
 * custom.js - custom inspect symbol for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var D4;
function vp() {
  if (D4) return Jc;
  D4 = 1;
  const { inspect: e } = Ci();
  return Jc.custom = e.custom || "inspect", Jc;
}
var ru, U4;
function Xr() {
  if (U4) return ru;
  U4 = 1;
  const { custom: e } = vp(), c = [
    "",
    "0",
    "00",
    "000",
    "0000",
    "00000",
    "000000",
    "0000000",
    "00000000",
    "000000000",
    "0000000000",
    "00000000000",
    "000000000000",
    "0000000000000",
    "00000000000000",
    "000000000000000",
    "0000000000000000",
    "00000000000000000",
    "000000000000000000",
    "0000000000000000000",
    "00000000000000000000",
    "000000000000000000000",
    "0000000000000000000000",
    "00000000000000000000000",
    "000000000000000000000000",
    "0000000000000000000000000"
  ], l = [
    0,
    25,
    16,
    12,
    11,
    10,
    9,
    8,
    8,
    7,
    7,
    7,
    7,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5
  ], w = [
    0,
    33554432,
    43046721,
    16777216,
    48828125,
    60466176,
    40353607,
    16777216,
    43046721,
    1e7,
    19487171,
    35831808,
    62748517,
    7529536,
    11390625,
    16777216,
    24137569,
    34012224,
    47045881,
    64e6,
    4084101,
    5153632,
    6436343,
    7962624,
    9765625,
    11881376,
    14348907,
    17210368,
    20511149,
    243e5,
    28629151,
    33554432,
    39135393,
    45435424,
    52521875,
    60466176
  ], m = {
    p192: null,
    p224: null,
    p521: null,
    k256: null,
    p251: null,
    p25519: null,
    p448: null
  }, f = {
    NONE: 0,
    QUO: 1,
    REM: 2,
    BOTH: 3,
    EUCLID: 4,
    ALL: 7
  }, n = 4, u = 1 << n - 1, o = typeof BigInt == "function";
  class s {
    constructor(t, d, B) {
      this.words = [0], this.length = 1, this.negative = 0, this.red = null, this.from(t, d, B);
    }
    /*
     * Addition Engine
     */
    _iadd(t, d) {
      let B = 0, U = 0;
      for (t.length < d.length && ([t, d] = [d, t]), t !== this && this._alloc(t.length); U < d.length; U++) {
        const J = (t.words[U] | 0) + (d.words[U] | 0) + B;
        this.words[U] = J & 67108863, B = J >>> 26;
      }
      for (; B !== 0 && U < t.length; U++) {
        const J = (t.words[U] | 0) + B;
        this.words[U] = J & 67108863, B = J >>> 26;
      }
      if (this.length = t.length, B !== 0)
        this._alloc(this.length + 1), this.words[this.length++] = B;
      else if (t !== this)
        for (; U < t.length; U++)
          this.words[U] = t.words[U];
      return this;
    }
    _iaddn(t) {
      if (this.words[0] += t, this.words[0] < 67108864)
        return this;
      let d = 0;
      for (this._alloc(this.length + 1), this.words[this.length] = 0; d < this.length && this.words[d] >= 67108864; d++)
        this.words[d] -= 67108864, this.words[d + 1] += 1;
      return this.length = Math.max(this.length, d + 1), this;
    }
    /*
     * Addition
     */
    iadd(t) {
      if (_(s.isBN(t), "num", "bignum"), this.negative === t.negative)
        this._iadd(this, t);
      else {
        const d = this.ucmp(t);
        if (d === 0)
          return this.words[0] = 0, this.length = 1, this.negative = 0, this;
        d < 0 ? (this._isub(t, this), this.negative ^= 1) : this._isub(this, t);
      }
      return this;
    }
    iaddn(t) {
      _(D(t), "num", "smi");
      const d = t < 0 | 0;
      return d && (t = -t), this.negative === d ? this._iaddn(t) : this.length === 1 && this.words[0] < t ? (this.words[0] = t - this.words[0], this.negative ^= 1) : this._isubn(t), this;
    }
    add(t) {
      return _(s.isBN(t), "num", "bignum"), t.length > this.length ? t.clone().iadd(this) : this.clone().iadd(t);
    }
    addn(t) {
      return this.clone().iaddn(t);
    }
    /*
     * Subtraction Engine
     */
    _isub(t, d) {
      let B = 0, U = 0;
      for (q(t.length >= d.length), t !== this && this._alloc(t.length); U < d.length; U++) {
        const J = (t.words[U] | 0) - (d.words[U] | 0) + B;
        B = J >> 26, this.words[U] = J & 67108863;
      }
      for (; B !== 0 && U < t.length; U++) {
        const J = (t.words[U] | 0) + B;
        B = J >> 26, this.words[U] = J & 67108863;
      }
      if (q(B === 0), t !== this)
        for (; U < t.length; U++)
          this.words[U] = t.words[U];
      return this.length = Math.max(this.length, U), this._strip();
    }
    _isubn(t) {
      if (this.words[0] -= t, this.words[0] >= 0)
        return this._normalize();
      q(this.length !== 1), this._alloc(this.length + 1);
      for (let d = 0; d < this.length && this.words[d] < 0; d++)
        this.words[d] += 67108864, this.words[d + 1] -= 1;
      return this.words[this.length] = 0, this._strip();
    }
    /*
     * Subtraction
     */
    isub(t) {
      if (_(s.isBN(t), "num", "bignum"), this.negative !== t.negative)
        this._iadd(this, t);
      else {
        const d = this.ucmp(t);
        if (d === 0)
          return this.words[0] = 0, this.length = 1, this.negative = 0, this;
        d < 0 ? (this._isub(t, this), this.negative ^= 1) : this._isub(this, t);
      }
      return this;
    }
    isubn(t) {
      _(D(t), "num", "smi");
      const d = t < 0 | 0;
      return d && (t = -t), this.negative !== d ? this._iaddn(t) : this.length === 1 && this.words[0] < t ? (this.words[0] = t - this.words[0], this.negative ^= 1) : this._isubn(t), this;
    }
    sub(t) {
      return this.clone().isub(t);
    }
    subn(t) {
      return this.clone().isubn(t);
    }
    /*
     * Multiplication Engine
     */
    _mul(t, d) {
      if (_(s.isBN(t), "num", "bignum"), _(s.isBN(d), "out", "bignum"), this.length === 10 && t.length === 10)
        return I(this, t, d);
      const B = this.length + t.length;
      return B < 63 ? Ee(this, t, d) : B < 1024 ? we(this, t, d) : z(this, t, d);
    }
    /*
     * Multiplication
     */
    imul(t) {
      return this.mul(t)._move(this);
    }
    imuln(t) {
      _(D(t), "num", "smi");
      const d = t < 0 | 0;
      d && (t = -t);
      let B = 0;
      for (let U = 0; U < this.length; U++) {
        const J = this.words[U] * t, C = (J & 67108863) + (B & 67108863);
        B >>= 26, B += J / 67108864 | 0, B += C >>> 26, this.words[U] = C & 67108863;
      }
      return this.negative ^= d, B !== 0 ? (this._alloc(this.length + 1), this.words[this.length++] = B) : this._strip(), this;
    }
    mul(t) {
      _(s.isBN(t), "num", "bignum");
      const d = this.length + t.length, B = new s();
      B.words = new Array(d);
      for (let U = 0; U < d; U++)
        B.words[U] = 0;
      return this._mul(t, B);
    }
    muln(t) {
      return this.clone().imuln(t);
    }
    /*
     * Multiplication + Shift
     */
    mulShift(t, d) {
      _(s.isBN(t), "num", "bignum"), _(d >>> 0 === d, "bits", "uint32");
      const B = this.mul(t), U = B.utestn(d - 1);
      return B.iushrn(d), this.negative ^ t.negative ? B.isubn(U) : B.iaddn(U);
    }
    /*
     * Division Engine
     */
    _div(t, d) {
      _(s.isBN(t), "num", "bignum"), q((d & f.ALL) === d), q(d !== f.NONE);
      const B = this, U = t;
      if (fe(!U.isZero()), B.isZero())
        return [new s(0), new s(0)];
      const J = B.negative, C = U.negative;
      B.negative = 0, U.negative = 0;
      let M = null, $ = null;
      return B.ucmp(U) < 0 ? (d & f.QUO && (M = new s(0)), d & f.REM && ($ = B.clone())) : U.length === 1 ? (d & f.QUO && (M = B.quon(U.words[0])), d & f.REM && ($ = B.remn(U.words[0]))) : [M, $] = B._wordDiv(U, d), B.negative = J, U.negative = C, d & f.QUO && (M.negative = B.negative ^ U.negative, M._normalize()), d & f.REM && ($.negative = B.negative, $._normalize()), d & f.EUCLID && (d & f.QUO && (q((d & f.REM) !== 0), $.negative !== 0 && (U.negative !== 0 ? M.iaddn(1) : M.isubn(1))), d & f.REM && $.negative !== 0 && (U.negative !== 0 ? $.isub(U) : $.iadd(U))), [M, $];
    }
    _wordDiv(t, d) {
      let B = this.clone(), U = t, J = null, C;
      const M = U.words[U.length - 1] | 0, $ = 26 - oe(M);
      $ !== 0 ? (U = U.clone(), B.iushln($), U.iushln($), C = U.words[U.length - 1] | 0) : C = M;
      const r = B.length - U.length;
      if (q(r >= 0), d & f.QUO) {
        J = new s(0), J.length = r + 1, J.words = new Array(J.length);
        for (let O = 0; O < J.length; O++)
          J.words[O] = 0;
      }
      const x = B.clone();
      x._ishlnsubmul(U, 1, r), x.negative === 0 && (J && (J.words[r] = 1), B = x);
      for (let O = r - 1; O >= 0; O--) {
        const K = B.words[U.length + O], X = B.words[U.length + O - 1], P = (K * 67108864 + X) / C | 0;
        let V = Math.min(P, 67108863);
        for (B._ishlnsubmul(U, V, O); B.negative !== 0; )
          V -= 1, B.negative = 0, B._ishlnsubmul(U, 1, O), B.ineg();
        J && (J.words[O] = V);
      }
      return J && J._strip(), d & f.REM && $ !== 0 && B.iushrn($), [J, B];
    }
    _ishlnsubmul(t, d, B) {
      let U = 0, J = 0;
      for (this._expand(t.length + B); J < t.length; J++) {
        const C = (this.words[J + B] | 0) + U, M = t.words[J] * d, $ = C - (M & 67108863);
        U = ($ >> 26) - (M / 67108864 | 0), this.words[J + B] = $ & 67108863;
      }
      for (; J < this.length - B; J++) {
        const C = (this.words[J + B] | 0) + U;
        U = C >> 26, this.words[J + B] = C & 67108863;
      }
      if (U === 0)
        return this._strip();
      q(U === -1), U = 0;
      for (let C = 0; C < this.length; C++) {
        const M = -(this.words[C] | 0) + U;
        U = M >> 26, this.words[C] = M & 67108863;
      }
      return this.negative = 1, this._strip();
    }
    /*
     * Truncation Division + Modulo
     */
    quorem(t) {
      return this._div(t, f.BOTH);
    }
    /*
     * Truncation Division
     */
    iquo(t) {
      return this.quo(t)._move(this);
    }
    iquon(t) {
      _(D(t), "num", "smi"), fe(t !== 0);
      const d = t < 0 | 0;
      d && (t = -t);
      let B = 0;
      for (let U = this.length - 1; U >= 0; U--) {
        const J = (this.words[U] | 0) + B * 67108864;
        this.words[U] = J / t | 0, B = J % t;
      }
      return this.negative ^= d, this._strip();
    }
    quo(t) {
      return this._div(t, f.QUO)[0];
    }
    quon(t) {
      return this.clone().iquon(t);
    }
    /*
     * Truncation Modulo
     */
    irem(t) {
      return this.rem(t)._move(this);
    }
    iremn(t) {
      let d = this.remrn(t);
      return d < 0 && (d = -d), this.words[0] = d, this.length = 1, this._normalize();
    }
    rem(t) {
      return this._div(t, f.REM)[1];
    }
    remn(t) {
      return this.clone().iremn(t);
    }
    remrn(t) {
      _(D(t), "num", "smi"), fe(t !== 0), t < 0 && (t = -t);
      const d = (1 << 26) % t;
      let B = 0;
      for (let U = this.length - 1; U >= 0; U--)
        B = (d * B + (this.words[U] | 0)) % t;
      return this.negative !== 0 ? -B | 0 : B;
    }
    /*
     * Euclidean Division + Modulo
     */
    divmod(t) {
      return this._div(t, f.BOTH | f.EUCLID);
    }
    /*
     * Euclidean Division
     */
    idiv(t) {
      return this.div(t)._move(this);
    }
    idivn(t) {
      if (this.negative === 0)
        return this.iquon(t);
      const d = this.remrn(t);
      return this.iquon(t), d < 0 && (t < 0 ? this.iaddn(1) : this.isubn(1)), this;
    }
    div(t) {
      return this._div(t, f.BOTH | f.EUCLID)[0];
    }
    divn(t) {
      return this.clone().idivn(t);
    }
    /*
     * Euclidean Modulo
     */
    imod(t) {
      return this.ucmp(t) < 0 ? (this.negative !== 0 && (this._isub(t, this), this.negative = 0), this) : this.mod(t)._move(this);
    }
    imodn(t) {
      return this.words[0] = this.modrn(t), this.length = 1, this.negative = 0, this;
    }
    mod(t) {
      return this._div(t, f.REM | f.EUCLID)[1];
    }
    modn(t) {
      return this.clone().imodn(t);
    }
    modrn(t) {
      _(D(t), "num", "smi");
      let d = this.remrn(t);
      return d < 0 && (t < 0 ? d -= t : d += t), d;
    }
    /*
     * Round Division
     */
    divRound(t) {
      const [d, B] = this.quorem(t);
      if (B.isZero())
        return d;
      const U = t.words[0] & 1;
      t.iushrn(1);
      const J = B.ucmp(t);
      return t.iushln(1), t.words[0] |= U, J < 0 || t.isOdd() && J === 0 ? d : this.negative ^ t.negative ? d.isubn(1) : d.iaddn(1);
    }
    /*
     * Exponentiation
     */
    ipow(t) {
      return this.pow(t)._move(this);
    }
    ipown(t) {
      return this.pown(t)._move(this);
    }
    pow(t) {
      _(s.isBN(t), "num", "bignum");
      let d = oe(t.words[t.length - 1]), B = new s(1);
      for (let U = t.length - 1; U >= 0; U--) {
        const J = t.words[U];
        for (let C = d - 1; C >= 0; C--)
          B = B.sqr(), J >> C & 1 && (B = B.mul(this));
        d = 26;
      }
      return B;
    }
    pown(t) {
      if (_(D(t), "num", "smi"), t < 0 && (t = -t), t === 0)
        return new s(1);
      if (t === 1)
        return this.clone();
      const d = oe(t);
      let B = this;
      for (let U = d - 2; U >= 0; U--)
        B = B.sqr(), t >> U & 1 && (B = B.mul(this));
      return B;
    }
    isqr() {
      return this.imul(this);
    }
    sqr() {
      return this.mul(this);
    }
    /*
     * Roots Engine
     */
    _rootrem(t, d) {
      if (_(t >>> 0 === t, "num", "uint32"), t === 0)
        throw new RangeError("Zeroth root.");
      if (~t & this.negative)
        throw new RangeError("Negative with even root.");
      if (this.ucmpn(1) <= 0)
        return [this.clone(), new s(0)];
      let B = new s(0), U = s.shift(1, this.bitLength() / t + 1 | 0), J, C;
      if (this.negative !== 0 && U.ineg(), t === 2)
        do
          B = U, U = this.quo(B), U.iadd(B), U.iushrn(1);
        while (U.ucmp(B) < 0);
      else
        do
          B = U, U = B.pown(t - 1), U = this.quo(U), J = B.muln(t - 1), U.iadd(J), U = U.quon(t);
        while (U.ucmp(B) < 0);
      return d && (U = B.pown(t), C = this.sub(U)), [B, C];
    }
    /*
     * Roots
     */
    rootrem(t) {
      return this._rootrem(t, 1);
    }
    iroot(t) {
      return this.root(t)._move(this);
    }
    root(t) {
      return this._rootrem(t, 0)[0];
    }
    isPower(t) {
      if (_(t >>> 0 === t, "num", "uint32"), t === 0 || ~t & this.negative)
        return !1;
      const [, d] = this.rootrem(t);
      return d.sign() === 0;
    }
    sqrtrem() {
      return this.rootrem(2);
    }
    isqrt() {
      return this.sqrt()._move(this);
    }
    sqrt() {
      return this.root(2);
    }
    isSquare() {
      return this.isPower(2);
    }
    /*
     * AND
     */
    iand(t) {
      _(s.isBN(t), "num", "bignum");
      let d = this, B = t;
      if (d === B)
        return d;
      if ((d.negative | B.negative) === 0)
        return d.iuand(B);
      if ((d.negative & B.negative) === 1)
        return d.iaddn(1), B.iaddn(1), d.iuor(B), d.isubn(1), B.isubn(1), d;
      d.negative !== 0 && ([d, B] = [B.clone(), d]);
      const U = d.bitLength();
      return B.iaddn(1), B.inotn(U), d.iuand(B), B.inotn(U), B.isubn(1), d._move(this);
    }
    iandn(t) {
      return _(D(t), "num", "smi"), (this.negative | t < 0) !== 0 ? this.iand(new s(t)) : (this.words[0] &= t, this.length = 1, this);
    }
    and(t) {
      return this.clone().iand(t);
    }
    andn(t) {
      return this.clone().iandn(t);
    }
    andrn(t) {
      if (_(D(t), "num", "smi"), (this.negative | t < 0) !== 0) {
        const d = this.iand(new s(t));
        if (d.length > 1)
          throw new RangeError("Number exceeds 26 bits.");
        return d.negative !== 0 ? -d.words[0] : d.words[0];
      }
      return this.words[0] & t;
    }
    /*
     * Unsigned AND
     */
    iuand(t) {
      _(s.isBN(t), "num", "bignum"), this.length = Math.min(this.length, t.length);
      for (let d = 0; d < this.length; d++)
        this.words[d] &= t.words[d];
      return this._strip();
    }
    iuandn(t) {
      return _(D(t), "num", "smi"), this.words[0] &= Math.abs(t), this.length = 1, this._normalize();
    }
    uand(t) {
      return this.clone().iuand(t);
    }
    uandn(t) {
      return this.clone().iuandn(t);
    }
    uandrn(t) {
      _(D(t), "num", "smi");
      const d = this.words[0] & Math.abs(t);
      return this.negative !== 0 ? -d | 0 : d;
    }
    /*
     * OR
     */
    ior(t) {
      _(s.isBN(t), "num", "bignum");
      let d = this, B = t;
      return d === B ? d : (d.negative | B.negative) === 0 ? d.iuor(B) : (d.negative & B.negative) === 1 ? (d.iaddn(1), B.iaddn(1), d.iuand(B), d.isubn(1), B.isubn(1), d) : (B = B.clone(), d.negative !== 0 && ([d, B] = [B, d]), B.iaddn(1), d.inotn(B.bitLength()), B.iuand(d), B.isubn(1), B._move(this));
    }
    iorn(t) {
      return _(D(t), "num", "smi"), (this.negative | t < 0) !== 0 ? this.ior(new s(t)) : (this.words[0] |= t, this);
    }
    or(t) {
      return this.clone().ior(t);
    }
    orn(t) {
      return this.clone().iorn(t);
    }
    /*
     * Unsigned OR
     */
    iuor(t) {
      _(s.isBN(t), "num", "bignum"), this._expand(t.length);
      for (let d = 0; d < t.length; d++)
        this.words[d] |= t.words[d];
      return this;
    }
    iuorn(t) {
      return _(D(t), "num", "smi"), this.words[0] |= Math.abs(t), this;
    }
    uor(t) {
      return this.clone().iuor(t);
    }
    uorn(t) {
      return this.clone().iuorn(t);
    }
    /*
     * XOR
     */
    ixor(t) {
      _(s.isBN(t), "num", "bignum");
      let d = this, B = t;
      return d === B ? (d.words[0] = 0, d.length = 1, d.negative = 0, d) : (d.negative | B.negative) === 0 ? d.iuxor(B) : (d.negative & B.negative) === 1 ? (d.iaddn(1), B.iaddn(1), d.iuxor(B), d.ineg(), B.isubn(1), d) : (d.negative !== 0 && ([d, B] = [B.clone(), d]), B.iaddn(1), d.iuxor(B), d.iaddn(1), d.ineg(), B.isubn(1), d._move(this));
    }
    ixorn(t) {
      return _(D(t), "num", "smi"), (this.negative | t < 0) !== 0 ? this.ixor(new s(t)) : (this.words[0] ^= t, this);
    }
    xor(t) {
      return this.clone().ixor(t);
    }
    xorn(t) {
      return this.clone().ixorn(t);
    }
    /*
     * Unsigned XOR
     */
    iuxor(t) {
      _(s.isBN(t), "num", "bignum");
      let d = this, B = t;
      d.length < B.length && ([d, B] = [B, d]);
      let U = 0;
      for (; U < B.length; U++)
        this.words[U] = d.words[U] ^ B.words[U];
      if (d !== this)
        for (this._alloc(d.length); U < d.length; U++)
          this.words[U] = d.words[U];
      return this.length = d.length, this._strip();
    }
    iuxorn(t) {
      return _(D(t), "num", "smi"), this.words[0] ^= Math.abs(t), this._normalize();
    }
    uxor(t) {
      return this.clone().iuxor(t);
    }
    uxorn(t) {
      return this.clone().iuxorn(t);
    }
    /*
     * NOT
     */
    inot() {
      return this.negative !== 0 ? this.ineg().isubn(1) : this.iaddn(1).ineg(), this;
    }
    not() {
      return this.clone().inot();
    }
    inotn(t) {
      _(t >>> 0 === t, "width", "uint32");
      const d = t % 26;
      let B = Math.ceil(t / 26), U = 0;
      for (this._expand(B), d > 0 && (B -= 1); U < B; U++)
        this.words[U] ^= 67108863;
      return d > 0 && (this.words[U] ^= (1 << d) - 1), this._strip();
    }
    notn(t) {
      return this.clone().inotn(t);
    }
    /*
     * Left Shift
     */
    ishl(t) {
      return _(s.isBN(t), "bits", "bignum"), _(t.bitLength() <= 32, "bits", "uint32"), this.ishln(t.toNumber());
    }
    ishln(t) {
      return this.iushln(t);
    }
    shl(t) {
      return this.clone().ishl(t);
    }
    shln(t) {
      return this.clone().ishln(t);
    }
    /*
     * Unsigned Left Shift
     */
    iushl(t) {
      return _(s.isBN(t), "bits", "bignum"), _(t.bitLength() <= 32, "bits", "uint32"), this.iushln(t.toNumber());
    }
    iushln(t) {
      _(t >>> 0 === t, "bits", "uint32");
      const d = t % 26, B = (t - d) / 26, U = (1 << d) - 1 << 26 - d;
      if (d !== 0) {
        let J = 0;
        for (let C = 0; C < this.length; C++) {
          const M = this.words[C] & U, $ = (this.words[C] | 0) - M << d;
          this.words[C] = $ | J, J = M >>> 26 - d;
        }
        J !== 0 && (this._alloc(this.length + 1), this.words[this.length++] = J);
      }
      if (B !== 0) {
        this._alloc(this.length + B);
        for (let J = this.length - 1; J >= 0; J--)
          this.words[J + B] = this.words[J];
        for (let J = 0; J < B; J++)
          this.words[J] = 0;
        this.length += B;
      }
      return this._strip();
    }
    ushl(t) {
      return this.clone().iushl(t);
    }
    ushln(t) {
      return this.clone().iushln(t);
    }
    /*
     * Right Shift Engine
     */
    _split(t, d) {
      const B = t % 26, U = Math.min((t - B) / 26, this.length), J = (1 << B) - 1;
      if (d) {
        d._alloc(U);
        for (let M = 0; M < U; M++)
          d.words[M] = this.words[M];
        d.length = U;
      }
      if (U !== 0) if (this.length > U) {
        this.length -= U;
        for (let M = 0; M < this.length; M++)
          this.words[M] = this.words[M + U];
      } else
        this.words[0] = 0, this.length = 1;
      let C = 0;
      if (B !== 0)
        for (let M = this.length - 1; M >= 0; M--) {
          const $ = this.words[M] | 0;
          this.words[M] = C << 26 - B | $ >>> B, C = $ & J;
        }
      return d && (C !== 0 ? (d._alloc(d.length + 1), d.words[d.length++] = C) : (d.length === 0 && (d.words[d.length++] = 0), d._strip())), this._strip();
    }
    /*
     * Right Shift
     */
    ishr(t) {
      return _(s.isBN(t), "bits", "bignum"), _(t.bitLength() <= 32, "bits", "uint32"), this.ishrn(t.toNumber());
    }
    ishrn(t) {
      return _(t >>> 0 === t, "bits", "uint32"), this.negative !== 0 ? (this.iaddn(1), this.iushrn(t), this.isubn(1), this) : this.iushrn(t);
    }
    shr(t) {
      return this.clone().ishr(t);
    }
    shrn(t) {
      return this.clone().ishrn(t);
    }
    /*
     * Unsigned Right Shift
     */
    iushr(t) {
      return _(s.isBN(t), "bits", "bignum"), _(t.bitLength() <= 32, "bits", "uint32"), this.iushrn(t.toNumber());
    }
    iushrn(t) {
      return _(t >>> 0 === t, "bits", "uint32"), this._split(t, null);
    }
    ushr(t) {
      return this.clone().iushr(t);
    }
    ushrn(t) {
      return this.clone().iushrn(t);
    }
    /*
     * Bit Manipulation
     */
    setn(t, d) {
      return _(t >>> 0 === t, "bit", "uint32"), this.negative !== 0 ? (this.iaddn(1), this.usetn(t, !d), this.isubn(1), this) : this.usetn(t, d);
    }
    usetn(t, d) {
      _(t >>> 0 === t, "bit", "uint32");
      const B = t % 26, U = (t - B) / 26;
      return this._expand(U + 1), d ? this.words[U] |= 1 << B : this.words[U] &= ~(1 << B), this._strip();
    }
    testn(t) {
      _(t >>> 0 === t, "bit", "uint32");
      const d = t % 26, B = (t - d) / 26;
      if (this.length <= B)
        return this.negative;
      const U = this.words[B], J = U >> d & 1;
      if (this.negative !== 0) {
        if (d > 0 && U & (1 << d) - 1)
          return J ^ 1;
        let C = B;
        for (; C--; )
          if (this.words[C] > 0)
            return J ^ 1;
      }
      return J;
    }
    utestn(t) {
      _(t >>> 0 === t, "bit", "uint32");
      const d = t % 26, B = (t - d) / 26;
      return this.length <= B ? 0 : this.words[B] >> d & 1;
    }
    imaskn(t) {
      return _(t >>> 0 === t, "bits", "uint32"), this.negative !== 0 && (this.iaddn(1), this.inotn(t + 1), this.ineg()), this.iumaskn(t);
    }
    maskn(t) {
      return this.clone().imaskn(t);
    }
    iumaskn(t) {
      _(t >>> 0 === t, "bits", "uint32");
      const d = t % 26;
      let B = (t - d) / 26;
      return this.length <= B ? this : (d !== 0 && (B += 1), this.length = Math.min(B, this.length), d !== 0 && (this.words[this.length - 1] &= (1 << d) - 1), this.length === 0 && (this.words[this.length++] = 0), this._strip());
    }
    umaskn(t) {
      return this.clone().iumaskn(t);
    }
    andln(t) {
      return this.words[0] & t;
    }
    bit(t) {
      return this.utestn(t);
    }
    bits(t, d) {
      _(t >>> 0 === t, "pos", "uint32"), _(d >>> 0 === d, "width", "uint32"), _(d <= 26, "width", "width");
      const B = t % 26, U = (t - B) / 26;
      if (U >= this.length)
        return 0;
      let J = this.words[U] >> B & (1 << d) - 1;
      if (B + d > 26 && U + 1 < this.length) {
        const C = B + d - 26, M = this.words[U + 1] & (1 << C) - 1;
        J |= M << 26 - B;
      }
      return J;
    }
    /*
     * Negation
     */
    ineg() {
      return this.isZero() || (this.negative ^= 1), this;
    }
    neg() {
      return this.clone().ineg();
    }
    iabs() {
      return this.negative = 0, this;
    }
    abs() {
      return this.clone().iabs();
    }
    /*
     * Comparison
     */
    cmp(t) {
      if (_(s.isBN(t), "num", "bignum"), this.negative !== t.negative)
        return t.negative - this.negative;
      const d = this.ucmp(t);
      return this.negative !== 0 ? -d | 0 : d;
    }
    cmpn(t) {
      _(D(t), "num", "smi");
      const d = t < 0 | 0;
      if (this.negative !== d)
        return d - this.negative;
      const B = this.ucmpn(t);
      return this.negative !== 0 ? -B | 0 : B;
    }
    eq(t) {
      return this.cmp(t) === 0;
    }
    eqn(t) {
      return this.cmpn(t) === 0;
    }
    gt(t) {
      return this.cmp(t) > 0;
    }
    gtn(t) {
      return this.cmpn(t) > 0;
    }
    gte(t) {
      return this.cmp(t) >= 0;
    }
    gten(t) {
      return this.cmpn(t) >= 0;
    }
    lt(t) {
      return this.cmp(t) < 0;
    }
    ltn(t) {
      return this.cmpn(t) < 0;
    }
    lte(t) {
      return this.cmp(t) <= 0;
    }
    lten(t) {
      return this.cmpn(t) <= 0;
    }
    sign() {
      return this.negative !== 0 ? -1 : this.length === 1 && this.words[0] === 0 ? 0 : 1;
    }
    isZero() {
      return this.length === 1 && this.words[0] === 0;
    }
    isNeg() {
      return this.negative !== 0;
    }
    isPos() {
      return this.negative === 0;
    }
    isOdd() {
      return (this.words[0] & 1) === 1;
    }
    isEven() {
      return (this.words[0] & 1) === 0;
    }
    /*
     * Unsigned Comparison
     */
    ucmp(t) {
      if (_(s.isBN(t), "num", "bignum"), this.length < t.length)
        return -1;
      if (this.length > t.length)
        return 1;
      for (let d = this.length - 1; d >= 0; d--) {
        const B = this.words[d] | 0, U = t.words[d] | 0;
        if (B !== U)
          return (B > U) - (B < U);
      }
      return 0;
    }
    ucmpn(t) {
      if (_(D(t), "num", "smi"), this.length > 1)
        return 1;
      const d = this.words[0] | 0;
      return t < 0 && (t = -t), (d > t) - (d < t);
    }
    /*
     * Number Theoretic Functions
     */
    legendre(t) {
      const d = o ? s.red(t) : s.mont(t);
      return this.toRed(d).redLegendre();
    }
    jacobi(t) {
      if (_(s.isBN(t), "num", "bignum"), t.isZero() || t.isEven())
        throw new Error("jacobi: `num` must be odd.");
      let d = this._cloneNormal(), B = t.clone(), U = 1;
      for (B.isNeg() && (d.isNeg() && (U = -1), B.ineg()), (d.isNeg() || d.ucmp(B) >= 0) && d.imod(B); !d.isZero(); ) {
        if (d._makeOdd() & 1) {
          const M = B.andln(7);
          (M === 3 || M === 5) && (U = -U);
        }
        d.ucmp(B) < 0 && ([d, B] = [B, d], d.andln(3) === 3 && B.andln(3) === 3 && (U = -U)), d._isub(d, B).iushrn(1);
        const C = B.andln(7);
        (C === 3 || C === 5) && (U = -U);
      }
      return B.cmpn(1) !== 0 ? 0 : U;
    }
    kronecker(t) {
      if (_(s.isBN(t), "num", "bignum"), this.isZero())
        return t.ucmpn(1) === 0 ? 1 : 0;
      if (t.isZero())
        return this.ucmpn(1) === 0 ? 1 : 0;
      if (((this.words[0] | t.words[0]) & 1) === 0)
        return 0;
      const d = this, B = t.clone(), U = B._makeOdd(), J = [0, 1, 0, -1, 0, -1, 0, 1];
      let C = d.jacobi(B);
      return U & 1 && (C *= J[d.andln(7)]), C | 0;
    }
    igcd(t) {
      return this.gcd(t)._move(this);
    }
    gcd(t) {
      if (_(s.isBN(t), "num", "bignum"), this.isZero())
        return t.abs();
      if (t.isZero())
        return this.abs();
      let d = this.clone(), B = t.clone();
      d.negative = 0, B.negative = 0;
      const U = d._factor2(B);
      for (U !== 0 && (d.iushrn(U), B.iushrn(U)); ; ) {
        d._makeOdd(), B._makeOdd();
        const J = d.ucmp(B);
        if (J < 0)
          [d, B] = [B, d];
        else if (J === 0 || B.ucmpn(1) === 0)
          break;
        d._isub(d, B);
      }
      return B.iushln(U);
    }
    ilcm(t) {
      return this.lcm(t)._move(this);
    }
    lcm(t) {
      return _(s.isBN(t), "num", "bignum"), this.isZero() || t.isZero() ? new s(0) : this.quo(this.gcd(t)).mul(t).iabs();
    }
    egcd(t) {
      if (_(s.isBN(t), "num", "bignum"), this.isZero())
        return [
          new s(0),
          new s(t.sign()),
          t.abs()
        ];
      if (t.isZero())
        return [
          new s(this.sign()),
          new s(0),
          this.abs()
        ];
      const d = this.clone(), B = t.clone();
      d.negative = 0, B.negative = 0;
      const U = new s(1), J = new s(0), C = new s(0), M = new s(1), $ = d._factor2(B);
      $ > 0 && (d.iushrn($), B.iushrn($));
      const r = d.clone(), x = B.clone();
      for (; !d.isZero(); ) {
        let O = d._makeOdd(), K = B._makeOdd();
        for (; O--; )
          (U.isOdd() || J.isOdd()) && (U.iadd(x), J.isub(r)), U.iushrn(1), J.iushrn(1);
        for (; K--; )
          (C.isOdd() || M.isOdd()) && (C.iadd(x), M.isub(r)), C.iushrn(1), M.iushrn(1);
        d.cmp(B) >= 0 ? (d.isub(B), U.isub(C), J.isub(M)) : (B.isub(d), C.isub(U), M.isub(J));
      }
      return this.negative !== 0 && C.ineg(), t.negative !== 0 && M.ineg(), [C, M, B.iushln($)];
    }
    iinvert(t) {
      return this.invert(t)._move(this);
    }
    invert(t) {
      if (_(s.isBN(t), "num", "bignum"), F(t.sign() > 0, "invert"), t.isOdd())
        return this._invertp(t);
      if (t.cmpn(1) === 0)
        throw new RangeError("Not invertible.");
      const [d, , B] = this.egcd(t);
      if (B.cmpn(1) !== 0)
        throw new RangeError("Not invertible.");
      return d.imod(t);
    }
    ifermat(t) {
      return this.fermat(t)._move(this);
    }
    fermat(t) {
      const d = o ? s.red(t) : s.mont(t);
      return this.toRed(d).redFermat().fromRed();
    }
    ipowm(t, d, B) {
      return this.powm(t, d, B)._move(this);
    }
    powm(t, d, B) {
      const U = !o && B ? s.mont(d) : s.red(d);
      return this.toRed(U).redPow(t).fromRed();
    }
    ipowmn(t, d, B) {
      return this.powmn(t, d, B)._move(this);
    }
    powmn(t, d, B) {
      const U = B ? s.mont(d) : s.red(d);
      return this.toRed(U).redPown(t).fromRed();
    }
    isqrtm(t) {
      return this.sqrtm(t)._move(this);
    }
    sqrtm(t) {
      _(s.isBN(t), "p", "bignum");
      let d;
      return t.andln(3) === 3 || t.andln(7) === 5 ? d = s.red(t) : d = s.mont(t), this.toRed(d).redSqrt().fromRed();
    }
    isqrtpq(t, d) {
      return this.sqrtpq(t, d)._move(this);
    }
    sqrtpq(t, d) {
      const B = this.sqrtm(t), U = this.sqrtm(d), [J, C] = t.egcd(d), M = U.mul(J).mul(t), $ = B.mul(C).mul(d), r = t.mul(d);
      return M.iadd($).imod(r);
    }
    /*
     * Primality Testing
     */
    isPrime(t, d, B) {
      return _(d >>> 0 === d, "reps", "uint32"), !(!this.isPrimeMR(t, d + 1, !0) || !this.isPrimeLucas(B));
    }
    isPrimeMR(t, d, B = !1) {
      _(d >>> 0 === d, "reps", "uint32"), _(d > 0, "reps", "integer"), _(typeof B == "boolean", "force2", "boolean");
      const U = this;
      if (U.cmpn(7) < 0)
        return U.cmpn(2) === 0 || U.cmpn(3) === 0 || U.cmpn(5) === 0;
      if (U.isEven())
        return !1;
      const J = U.subn(1), C = J.subn(2), M = J.zeroBits(), $ = J.ushrn(M), r = s.red(U), x = J.toRed(r), O = new s(1).toRed(r);
      e:
        for (let K = 0; K < d; K++) {
          let X;
          K === d - 1 && B ? X = new s(2) : (X = s.random(t, 0, C), X.iaddn(2));
          let P = X.toRed(r).redPow($);
          if (!(P.cmp(O) === 0 || P.cmp(x) === 0)) {
            for (let V = 1; V < M; V++) {
              if (P = P.redSqr(), P.cmp(x) === 0)
                continue e;
              if (P.cmp(O) === 0)
                return !1;
            }
            return !1;
          }
        }
      return !0;
    }
    isPrimeLucas(t = 0) {
      _(t >>> 0 === t, "limit", "uint32");
      const d = this;
      if (d.cmpn(1) <= 0)
        return !1;
      if (d.isEven())
        return d.cmpn(2) === 0;
      let B = 3;
      for (; ; ) {
        if (B > 1e4)
          throw new Error(`Cannot find (D/n) = -1 for ${d.toString(10)}.`);
        if (t !== 0 && B > t)
          return !1;
        const r = new s(B * B - 4).jacobi(d);
        if (r === -1)
          break;
        if (r === 0)
          return d.cmpn(B + 2) === 0;
        if (B === 40 && d.isSquare())
          return !1;
        B += 1;
      }
      const U = d.addn(1), J = U._makeOdd();
      let C = new s(2), M = new s(B);
      for (let $ = U.bitLength(); $ >= 0; $--)
        U.utestn($) ? (C = C.mul(M).isubn(B).imod(d), M = M.sqr().isubn(2).imod(d)) : (M = M.mul(C).isubn(B).imod(d), C = C.sqr().isubn(2).imod(d));
      if (C.cmpn(2) === 0 || C.cmp(d.subn(2)) === 0) {
        const $ = C.muln(B).imod(d), r = M.ushln(1).imod(d);
        if ($.cmp(r) === 0)
          return !0;
      }
      for (let $ = 0; $ < J - 1; $++) {
        if (C.isZero())
          return !0;
        if (C.cmpn(2) === 0)
          return !1;
        C = C.sqr().isubn(2).imod(d);
      }
      return !1;
    }
    /*
     * Twos Complement
     */
    toTwos(t) {
      return this.negative !== 0 ? this.abs().inotn(t).iaddn(1) : this.clone();
    }
    fromTwos(t) {
      return _(t >>> 0 === t, "width", "uint32"), F(t > 0, "width"), this.testn(t - 1) ? this.notn(t).iaddn(1).ineg() : this.clone();
    }
    /*
     * Reduction Context
     */
    toRed(t) {
      if (_(t instanceof G, "ctx", "reduction context"), this.red)
        throw new Error("Already in reduction context.");
      return t.convertTo(this);
    }
    fromRed() {
      return R(this.red, "fromRed"), this.red.convertFrom(this);
    }
    forceRed(t) {
      if (_(t instanceof G, "ctx", "reduction context"), this.red) {
        if (!t.m.eq(this.red.m) || t.mont !== this.red.mont)
          throw new Error("Already in reduction context.");
      } else
        F(this.negative === 0, "red"), F(this.ucmp(t.m) < 0, "red");
      return this.clone()._forceRed(t);
    }
    redIAdd(t) {
      return _(s.isBN(t), "num", "bignum"), R(this.red, "redIAdd"), this.red.iadd(this, t);
    }
    redAdd(t) {
      return _(s.isBN(t), "num", "bignum"), R(this.red, "redAdd"), this.red.add(this, t);
    }
    redIAddn(t) {
      return _(D(t), "num", "smi"), R(this.red, "redIAddn"), this.red.iaddn(this, t);
    }
    redAddn(t) {
      return _(D(t), "num", "smi"), R(this.red, "redAddn"), this.red.addn(this, t);
    }
    redISub(t) {
      return _(s.isBN(t), "num", "bignum"), R(this.red, "redISub"), this.red.isub(this, t);
    }
    redSub(t) {
      return _(s.isBN(t), "num", "bignum"), R(this.red, "redSub"), this.red.sub(this, t);
    }
    redISubn(t) {
      return _(D(t), "num", "smi"), R(this.red, "redISubn"), this.red.isubn(this, t);
    }
    redSubn(t) {
      return _(D(t), "num", "smi"), R(this.red, "redSubn"), this.red.subn(this, t);
    }
    redIMul(t) {
      return _(s.isBN(t), "num", "bignum"), R(this.red, "redIMul"), this.red.imul(this, t);
    }
    redMul(t) {
      return _(s.isBN(t), "num", "bignum"), R(this.red, "redMul"), this.red.mul(this, t);
    }
    redIMuln(t) {
      return _(D(t), "num", "smi"), R(this.red, "redIMuln"), this.red.imuln(this, t);
    }
    redMuln(t) {
      return _(D(t), "num", "smi"), R(this.red, "redMuln"), this.red.muln(this, t);
    }
    redIDiv(t) {
      return _(s.isBN(t), "num", "bignum"), R(this.red, "redIDiv"), this.red.idiv(this, t);
    }
    redDiv(t) {
      return _(s.isBN(t), "num", "bignum"), R(this.red, "redDiv"), this.red.div(this, t);
    }
    redIDivn(t) {
      return _(D(t), "num", "smi"), R(this.red, "redIDivn"), this.red.idivn(this, t);
    }
    redDivn(t) {
      return _(D(t), "num", "smi"), R(this.red, "redDivn"), this.red.divn(this, t);
    }
    redIPow(t) {
      return _(s.isBN(t), "num", "bignum"), R(this.red, "redIPow"), L(!t.red, "redIPow"), this.red.ipow(this, t);
    }
    redPow(t) {
      return _(s.isBN(t), "num", "bignum"), R(this.red, "redPow"), L(!t.red, "redPow"), this.red.pow(this, t);
    }
    redIPown(t) {
      return _(D(t), "num", "smi"), R(this.red, "redIPown"), this.red.ipown(this, t);
    }
    redPown(t) {
      return _(D(t), "num", "smi"), R(this.red, "redPown"), this.red.pown(this, t);
    }
    redISqr() {
      return R(this.red, "redISqr"), this.red.isqr(this);
    }
    redSqr() {
      return R(this.red, "redSqr"), this.red.sqr(this);
    }
    redISqrt() {
      return R(this.red, "redISqrt"), this.red.isqrt(this);
    }
    redSqrt() {
      return R(this.red, "redSqrt"), this.red.sqrt(this);
    }
    redIDivSqrt(t) {
      return R(this.red, "redIDivSqrt"), this.red.idivsqrt(this, t);
    }
    redDivSqrt(t) {
      return R(this.red, "redDivSqrt"), this.red.divsqrt(this, t);
    }
    redIsSquare() {
      return R(this.red, "redIsSquare"), this.red.isSquare(this);
    }
    redIShl(t) {
      return _(s.isBN(t), "num", "bignum"), R(this.red, "redIShl"), L(!t.red, "redIShl"), this.red.ishl(this, t);
    }
    redShl(t) {
      return _(s.isBN(t), "num", "bignum"), R(this.red, "redShl"), L(!t.red, "redShl"), this.red.shl(this, t);
    }
    redIShln(t) {
      return _(t >>> 0 === t, "num", "uint32"), R(this.red, "redIShln"), this.red.ishln(this, t);
    }
    redShln(t) {
      return _(t >>> 0 === t, "num", "uint32"), R(this.red, "redShln"), this.red.shln(this, t);
    }
    redINeg() {
      return R(this.red, "redINeg"), this.red.ineg(this);
    }
    redNeg() {
      return R(this.red, "redNeg"), this.red.neg(this);
    }
    redEq(t) {
      return _(s.isBN(t), "num", "bignum"), R(this.red, "redEq"), this.red.eq(this, t);
    }
    redEqn(t) {
      return _(D(t), "num", "smi"), R(this.red, "redEqn"), this.red.eqn(this, t);
    }
    redIsHigh() {
      return R(this.red, "redIsHigh"), this.red.isHigh(this);
    }
    redIsLow() {
      return R(this.red, "redIsLow"), this.red.isLow(this);
    }
    redIsOdd() {
      return R(this.red, "redIsOdd"), this.red.isOdd(this);
    }
    redIsEven() {
      return R(this.red, "redIsEven"), this.red.isEven(this);
    }
    redLegendre() {
      return R(this.red, "redLegendre"), this.red.legendre(this);
    }
    redJacobi() {
      return R(this.red, "redJacobi"), this.red.jacobi(this);
    }
    redKronecker() {
      return R(this.red, "redKronecker"), this.red.kronecker(this);
    }
    redIInvert() {
      return R(this.red, "redIInvert"), this.red.iinvert(this);
    }
    redInvert() {
      return R(this.red, "redInvert"), this.red.invert(this);
    }
    redIFermat() {
      return R(this.red, "redIFermat"), this.red.ifermat(this);
    }
    redFermat() {
      return R(this.red, "redFermat"), this.red.fermat(this);
    }
    /*
     * Internal
     */
    _move(t) {
      return t.words = this.words, t.length = this.length, t.negative = this.negative, t.red = this.red, t;
    }
    _alloc(t) {
      for (; this.words.length < t; )
        this.words.push(0);
      return this;
    }
    _expand(t) {
      for (this._alloc(t); this.length < t; )
        this.words[this.length++] = 0;
      return this;
    }
    _strip() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length -= 1;
      return this._normalize();
    }
    _normalize() {
      return q(this.length > 0), this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }
    _check() {
      return q(this.length > 0), q(this.length <= this.words.length), this.length === 1 ? (this.words[0] === 0 && q(this.negative === 0), this) : (q(this.words[this.length - 1] !== 0), this);
    }
    _invertp(t) {
      if (_(s.isBN(t), "p", "bignum"), F(t.sign() > 0, "invert"), q(t.isOdd()), t.cmpn(1) === 0)
        throw new RangeError("Not invertible.");
      const d = this.clone(), B = t.clone(), U = new s(1), J = new s(0);
      for ((d.isNeg() || d.ucmp(B) >= 0) && d.imod(B); !d.isZero(); ) {
        let C = d._makeOdd(), M = B._makeOdd();
        for (; C--; )
          U.isOdd() && U._iadd(U, t), U.iushrn(1);
        for (; M--; )
          J.isOdd() && J._iadd(J, t), J.iushrn(1);
        d.ucmp(B) >= 0 ? (d._isub(d, B), U.ucmp(J) < 0 ? (U._isub(J, U), U._isub(t, U)) : U._isub(U, J)) : (B._isub(B, d), J.ucmp(U) < 0 ? (J._isub(U, J), J._isub(t, J)) : J._isub(J, U));
      }
      if (B.cmpn(1) !== 0)
        throw new RangeError("Not invertible.");
      return q(J.negative === 0), q(J.ucmp(t) < 0), J;
    }
    _makeOdd() {
      const t = this.zeroBits();
      return t > 0 && this.iushrn(t), t;
    }
    _factor2(t) {
      if ((this.words[0] | t.words[0]) & 1)
        return 0;
      const d = Math.min(this.length, t.length);
      let B = 0;
      for (let U = 0; U < d; U++) {
        const J = v(this.words[U] | t.words[U]);
        if (B += J, J !== 26)
          break;
      }
      return B;
    }
    _cloneNormal() {
      return this.red ? this.fromRed() : this.clone();
    }
    _forceRed(t) {
      return this.red = t, this;
    }
    /*
     * Helpers
     */
    clone() {
      const t = new s();
      t.words = new Array(this.length);
      for (let d = 0; d < this.length; d++)
        t.words[d] = this.words[d];
      return t.length = this.length, t.negative = this.negative, t.red = this.red, t;
    }
    inject(t) {
      _(s.isBN(t), "num", "bignum"), this._alloc(t.length);
      for (let d = 0; d < t.length; d++)
        this.words[d] = t.words[d];
      return this.length = t.length, this.negative = t.negative, this.red = t.red, this;
    }
    set(t, d) {
      return this.fromNumber(t, d);
    }
    swap(t) {
      _(s.isBN(t), "num", "bignum");
      const d = this, B = t;
      return [d.words, B.words] = [B.words, d.words], [d.length, B.length] = [B.length, d.length], [d.negative, B.negative] = [B.negative, d.negative], [d.red, B.red] = [B.red, d.red], d;
    }
    reverse() {
      const t = this.negative;
      return this.fromBuffer(this.toBuffer("be"), "le"), this.negative = t, this;
    }
    byteLength() {
      return Math.ceil(this.bitLength() / 8);
    }
    bitLength() {
      const t = this.words[this.length - 1], d = oe(t);
      return (this.length - 1) * 26 + d;
    }
    zeroBits() {
      if (this.isZero() || this.isOdd())
        return 0;
      let t = 0;
      for (let d = 0; d < this.length; d++) {
        const B = v(this.words[d]);
        if (t += B, B !== 26)
          break;
      }
      return t;
    }
    isSafe() {
      return this.length <= 2 || this.length === 3 && this.words[2] === 1;
    }
    word(t) {
      return _(t >>> 0 === t, "pos", "uint32"), t >= this.length ? 0 : this.words[t];
    }
    [e]() {
      let t = "BN";
      return this.red && (t = "BN-R"), `<${t}: ${this.toString(10)}>`;
    }
    /*
     * Conversion
     */
    toNumber() {
      let t = this.words[0];
      if (this.length === 2)
        t += this.words[1] * 67108864;
      else if (this.length === 3 && this.words[2] === 1)
        t += 4503599627370496 + this.words[1] * 67108864;
      else if (this.length > 2)
        throw new RangeError("Number can only safely store up to 53 bits.");
      return this.negative !== 0 ? -t : t;
    }
    toDouble() {
      let t = 0;
      for (let d = this.length - 1; d >= 0; d--)
        t = t * 67108864 + this.words[d];
      return this.negative !== 0 ? -t : t;
    }
    valueOf() {
      return this.toDouble();
    }
    toBigInt() {
      if (!o)
        throw new Error("BigInt is not supported!");
      const t = BigInt(52), d = BigInt(26);
      let B = this.length - 1, U = BigInt(0);
      for (; B >= 1; B -= 2) {
        const J = this.words[B] * 67108864, C = this.words[B - 1];
        U = U << t | BigInt(J + C);
      }
      return B >= 0 && (U = U << d | BigInt(this.words[0])), this.negative !== 0 ? -U : U;
    }
    toBool() {
      return !this.isZero();
    }
    toString(t, d) {
      if (t = W(t), d == null && (d = 0), d === 0 && (d = 1), _(t >>> 0 === t, "base", "uint32"), _(d >>> 0 === d, "padding", "uint32"), t < 2 || t > 36)
        throw new RangeError("Base ranges between 2 and 36.");
      if (this._check(), t === 16) {
        let M = "", $ = 0, r = 0;
        for (let x = 0; x < this.length; x++) {
          const O = this.words[x], K = ((O << $ | r) & 16777215).toString(16);
          r = O >>> 24 - $ & 16777215, r !== 0 || x !== this.length - 1 ? M = c[6 - K.length] + K + M : M = K + M, $ += 2, $ >= 26 && ($ -= 26, x -= 1);
        }
        for (r !== 0 && (M = r.toString(16) + M); M.length % d !== 0; )
          M = "0" + M;
        return this.negative !== 0 && (M = "-" + M), M;
      }
      const B = l[t - 1], U = w[t - 1], J = this.clone();
      let C = "";
      for (J.negative = 0; !J.isZero(); ) {
        const M = J.remrn(U).toString(t);
        J.iquon(U), J.isZero() ? C = M + C : C = c[B - M.length] + M + C;
      }
      for (this.isZero() && (C = "0"); C.length % d !== 0; )
        C = "0" + C;
      return this.negative !== 0 && (C = "-" + C), C;
    }
    toJSON() {
      return this.toString(16, 2);
    }
    toArray(t, d) {
      return this.toArrayLike(Array, t, d);
    }
    toBuffer(t, d) {
      return this.toArrayLike(k, t, d);
    }
    toArrayLike(t, d, B) {
      d == null && (d = "be"), B == null && (B = 0), _(typeof t == "function", "ArrayType", "function"), _(d === "be" || d === "le", "endian", "endianness"), _(B >>> 0 === B, "length", "uint32"), this._check();
      const U = this.byteLength(), J = B || Math.max(1, U);
      if (U > J)
        throw new RangeError("Byte array longer than desired length.");
      const C = Q(t, J);
      if (d === "be") {
        let M = C.length - 1, $ = 0;
        for (let r = 0; r < this.length; r++) {
          const x = (r & 3) << 1, O = this.words[r] << x | $;
          C[M--] = O & 255, M >= 0 && (C[M--] = O >>> 8 & 255), M >= 0 && (C[M--] = O >>> 16 & 255), x === 6 ? (M >= 0 && (C[M--] = O >>> 24 & 255), $ = 0) : $ = O >>> 24;
        }
        if (M >= 0) {
          for (C[M--] = $; M >= 0; )
            C[M--] = 0;
          $ = 0;
        }
        q($ === 0);
      } else {
        let M = 0, $ = 0;
        for (let r = 0; r < this.length; r++) {
          const x = (r & 3) << 1, O = this.words[r] << x | $;
          C[M++] = O & 255, M < C.length && (C[M++] = O >>> 8 & 255), M < C.length && (C[M++] = O >>> 16 & 255), x === 6 ? (M < C.length && (C[M++] = O >>> 24 & 255), $ = 0) : $ = O >>> 24;
        }
        if (M < C.length) {
          for (C[M++] = $; M < C.length; )
            C[M++] = 0;
          $ = 0;
        }
        q($ === 0);
      }
      return C;
    }
    encode(t, d) {
      return this.toBuffer(t, d);
    }
    /*
     * Instantiation
     */
    of(t, d) {
      return this.fromNumber(t, d);
    }
    fromNumber(t, d) {
      d == null && (d = "be"), _(ae(t), "num", "integer"), _(d === "be" || d === "le", "endian", "endianness");
      const B = t < 0 | 0;
      return B && (t = -t), t < 67108864 ? (this.words[0] = t & 67108863, this.length = 1) : t < 4503599627370496 ? (this.words = [
        t & 67108863,
        t / 67108864 & 67108863
      ], this.length = 2) : (this.words = [
        t & 67108863,
        t / 67108864 & 67108863,
        1
      ], this.length = 3), this.negative = B, d === "le" && this.reverse(), this;
    }
    fromDouble(t, d) {
      d == null && (d = "be"), _(typeof t == "number", "num", "double"), _(d === "be" || d === "le", "endian", "endianness"), isFinite(t) || (t = 0);
      const B = t <= -1 | 0;
      for (t < 0 && (t = -t), t = Math.floor(t), this.words = []; t > 0; ) {
        const U = t % 67108864, J = (t - U) / 67108864;
        this.words.push(U), t = J;
      }
      return this.words.length === 0 && this.words.push(0), this.length = this.words.length, this.negative = B, d === "le" && this.reverse(), this;
    }
    fromBigInt(t, d) {
      if (d == null && (d = "be"), _(typeof t == "bigint", "num", "bigint"), _(d === "be" || d === "le", "endian", "endianness"), !o)
        throw new Error("BigInt is not supported!");
      const B = t < BigInt(0) | 0;
      return this._fromHex(t.toString(16), B), this.negative = B, d === "le" && this.reverse(), this;
    }
    fromBool(t) {
      return _(typeof t == "boolean", "value", "boolean"), this.words[0] = t | 0, this.length = 1, this.negative = 0, this;
    }
    fromString(t, d, B) {
      if ((d === "le" || d === "be") && ([d, B] = [B, d]), d = W(d), B == null && (B = "be"), _(typeof t == "string", "string", "string"), _(d >>> 0 === d, "base", "uint32"), _(B === "be" || B === "le", "endian", "endianness"), d < 2 || d > 36)
        throw new Error("Base ranges between 2 and 36.");
      t = t.replace(/\s+/g, "");
      let U = 0;
      return t.length > 0 && t.charCodeAt(0) === 45 && (U = 1), d === 16 ? this._fromHex(t, U) : this._fromBase(t, d, U), this.negative = U, this._normalize(), B === "le" && this.reverse(), this;
    }
    _fromHex(t, d) {
      this.length = Math.max(2, Math.ceil((t.length - d) / 6)), this.words = new Array(this.length);
      for (let C = 0; C < this.length; C++)
        this.words[C] = 0;
      let B = 0, U = t.length - 6, J = 0;
      for (; U >= d; U -= 6) {
        const C = Y(t, U, U + 6);
        this.words[J] |= C << B & 67108863, this.words[J + 1] |= C >>> 26 - B & 4194303, B += 24, B >= 26 && (B -= 26, J += 1);
      }
      if (U + 6 !== d) {
        const C = Y(t, d, U + 6);
        this.words[J] |= C << B & 67108863, this.words[J + 1] |= C >>> 26 - B & 4194303;
      }
      return this._strip();
    }
    _fromBase(t, d, B) {
      this.words[0] = 0, this.length = 1, this.negative = 0;
      let U = 0, J = 1;
      for (; J <= 67108863; J *= d)
        U += 1;
      U -= 1, J = J / d | 0;
      const C = t.length - B, M = C % U, $ = Math.min(C, C - M) + B;
      let r = B;
      for (; r < $; r += U) {
        const x = he(t, r, r + U, d);
        this.imuln(J), this._iaddn(x);
      }
      if (M !== 0) {
        const x = Math.pow(d, M), O = he(t, r, t.length, d);
        this.imuln(x), this._iaddn(O);
      }
      return this;
    }
    fromJSON(t) {
      if (s.isBN(t))
        return t.red ? t.fromRed() : t.clone();
      if (Array.isArray(t)) {
        for (const d of t)
          _(typeof d == "string", "chunk", "string");
        t = t.join("");
      }
      return this.fromString(t, 16);
    }
    fromBN(t) {
      return this.inject(t);
    }
    fromArray(t, d) {
      return _(Array.isArray(t), "data", "array"), this.fromArrayLike(t, d);
    }
    fromBuffer(t, d) {
      return _(k.isBuffer(t), "data", "buffer"), this.fromArrayLike(t, d);
    }
    fromArrayLike(t, d) {
      if (d == null && (d = "be"), _(t && t.length >>> 0 === t.length, "data", "array-like"), _(d === "be" || d === "le", "endian", "endianness"), t.length === 0)
        return this.words[0] = 0, this.length = 1, this.negative = 0, this;
      this.length = Math.max(2, Math.ceil(t.length / 3)), this.words = new Array(this.length), this.negative = 0;
      for (let M = 0; M < this.length; M++)
        this.words[M] = 0;
      const B = t.length % 3;
      let U = 0, J = 0, C = 0;
      if (d === "be") {
        for (let M = t.length - 1; M >= 2; M -= 3) {
          const $ = t[M] | t[M - 1] << 8 | t[M - 2] << 16;
          this.words[J] |= $ << U & 67108863, this.words[J + 1] = $ >>> 26 - U & 67108863, U += 24, U >= 26 && (U -= 26, J += 1);
        }
        switch (B) {
          case 2:
            C = t[1] | t[0] << 8;
            break;
          case 1:
            C = t[0];
            break;
        }
      } else {
        const M = t.length - B;
        for (let $ = 0; $ < M; $ += 3) {
          const r = t[$] | t[$ + 1] << 8 | t[$ + 2] << 16;
          this.words[J] |= r << U & 67108863, this.words[J + 1] = r >>> 26 - U & 67108863, U += 24, U >= 26 && (U -= 26, J += 1);
        }
        switch (B) {
          case 2:
            C = t[M] | t[M + 1] << 8;
            break;
          case 1:
            C = t[M];
            break;
        }
      }
      return B > 0 && (this.words[J] |= C << U & 67108863, this.words[J + 1] = C >>> 26 - U & 67108863), this._strip();
    }
    decode(t, d) {
      return this.fromBuffer(t, d);
    }
    from(t, d, B) {
      if (t == null)
        return this;
      if ((d === "le" || d === "be") && ([d, B] = [B, d]), typeof t == "number")
        return this.fromNumber(t, B);
      if (typeof t == "bigint")
        return this.fromBigInt(t, B);
      if (typeof t == "string")
        return this.fromString(t, d, B);
      if (typeof t == "object") {
        if (s.isBN(t))
          return this.fromBN(t, B);
        if (t.length >>> 0 === t.length)
          return this.fromArrayLike(t, B);
      }
      if (typeof t == "boolean")
        return this.fromBool(t);
      throw new TypeError("Non-numeric object passed to BN.");
    }
    /*
     * Static Methods
     */
    static min(...t) {
      let d = null;
      for (const B of t)
        _(s.isBN(B), "num", "bignum"), (!d || B.cmp(d) < 0) && (d = B);
      return d || new s(0);
    }
    static max(...t) {
      let d = null;
      for (const B of t)
        _(s.isBN(B), "num", "bignum"), (!d || B.cmp(d) > 0) && (d = B);
      return d || new s(0);
    }
    static cmp(t, d) {
      return _(s.isBN(t), "a", "bignum"), t.cmp(d);
    }
    static ucmp(t, d) {
      return _(s.isBN(t), "a", "bignum"), t.ucmp(d);
    }
    static red(t) {
      return new G(t);
    }
    static barrett(t) {
      return new N(t);
    }
    static mont(t) {
      return new T(t);
    }
    static _prime(t) {
      if (m[t])
        return m[t];
      let d;
      if (t === "p192")
        d = new y();
      else if (t === "p224")
        d = new b();
      else if (t === "p521")
        d = new h();
      else if (t === "k256")
        d = new a();
      else if (t === "p251")
        d = new E();
      else if (t === "p25519")
        d = new H();
      else if (t === "p448")
        d = new j();
      else
        throw new Error(`Unknown prime: "${t}".`);
      return m[t] = d, d;
    }
    static prime(t) {
      return s._prime(t).p.clone();
    }
    static pow(t, d) {
      return t === 2 ? s.shift(1, d) : new s().fromNumber(t).pown(d);
    }
    static shift(t, d) {
      return t === 1 ? new s(0).usetn(d, 1) : new s().fromNumber(t).ishln(d);
    }
    static mask(t) {
      return s.shift(1, t).isubn(1);
    }
    static randomBits(t, d) {
      if (_(t != null, "rng", "rng"), _(d >>> 0 === d, "bits", "uint32"), typeof t == "object") {
        _(typeof t.randomBytes == "function", "rng", "rng");
        const U = d + 7 >>> 3, J = U * 8, C = t.randomBytes(U);
        if (_(k.isBuffer(C), "bytes", "buffer"), C.length !== U)
          throw new RangeError("Invalid number of bytes returned from RNG.");
        const M = s.fromBuffer(C);
        return J > d && M.iushrn(J - d), M;
      }
      _(typeof t == "function", "rng", "rng");
      const B = t(d);
      if (_(s.isBN(B), "num", "bignum"), F(B.negative === 0, "RNG"), L(!B.red, "RNG"), B.bitLength() > d)
        throw new RangeError("Invalid number of bits returned from RNG.");
      return B;
    }
    static random(t, d, B) {
      if (d = s.cast(d, 16), B = s.cast(B, 16), d.cmp(B) > 0)
        throw new RangeError("Minimum cannot be greater than maximum.");
      const U = B.sub(d).iabs(), J = U.bitLength();
      if (J === 0)
        return d.clone();
      for (; ; ) {
        const C = s.randomBits(t, J);
        if (!(C.cmp(U) >= 0))
          return C.iadd(d), C;
      }
    }
    static of(t, d) {
      return new s().of(t, d);
    }
    static fromNumber(t, d) {
      return new s().fromNumber(t, d);
    }
    static fromDouble(t, d) {
      return new s().fromDouble(t, d);
    }
    static fromBigInt(t, d) {
      return new s().fromBigInt(t, d);
    }
    static fromBool(t) {
      return new s().fromBool(t);
    }
    static fromString(t, d, B) {
      return new s().fromString(t, d, B);
    }
    static fromJSON(t) {
      return new s().fromJSON(t);
    }
    static fromBN(t) {
      return new s().fromBN(t);
    }
    static fromArray(t, d) {
      return new s().fromArray(t, d);
    }
    static fromBuffer(t, d) {
      return new s().fromBuffer(t, d);
    }
    static fromArrayLike(t, d) {
      return new s().fromArrayLike(t, d);
    }
    static decode(t, d) {
      return new s().decode(t, d);
    }
    static from(t, d, B) {
      return new s().from(t, d, B);
    }
    static cast(t, d, B) {
      return s.isBN(t) ? t : new s(t, d, B);
    }
    static isBN(t) {
      return t instanceof s;
    }
  }
  s.BN = s, s.wordSize = 26, s.native = 0;
  class i {
    constructor(t, d) {
      this.name = t, this.p = new s(d, 16), this.n = this.p.bitLength(), this.k = s.shift(1, this.n).isub(this.p), this.lo = this.p.clone(), this.one = this.p.clone();
    }
    ireduce(t) {
      const d = t.negative !== 0;
      let B = t.bitLength();
      for (q(B <= this.n * 2), t.negative = 0; B > this.n; )
        this.split(t, this.lo), this.imulK(t), t._iadd(t, this.lo), B = t.bitLength();
      const U = B < this.n ? -1 : t.ucmp(this.p);
      return U === 0 ? (t.words[0] = 0, t.length = 1) : U > 0 && t._isub(t, this.p), d && !t.isZero() && t._isub(this.p, t), t;
    }
    split(t, d) {
      t._split(this.n, d);
    }
    imulK(t) {
      return t.imul(this.k);
    }
    pm2(t) {
      throw new Error("Not implemented.");
    }
    fermat(t) {
      return this.pm2(t);
    }
  }
  class p extends i {
    constructor(t, d) {
      super(t, d);
    }
    pm3d4(t) {
      throw new Error("Not implemented.");
    }
    pp1d4(t) {
      throw new Error("Not implemented.");
    }
    sqrt(t) {
      const { red: d } = t, B = this.pp1d4(t);
      if (!d.sqr(B).eq(t))
        throw new ue(B);
      return B;
    }
    divsqrt(t, d) {
      const { red: B } = t, U = B.sqr(t), J = B.mul(U, t), C = B.mul(J, U), M = B.mul(B.sqr(d), d), $ = this.pm3d4(B.mul(C, M)), r = B.mul(B.mul(J, d), $);
      if (B.mul(d, B.sqr(r)).eq(t))
        return r;
      throw new ue(r);
    }
  }
  class g extends i {
    constructor(t, d, B) {
      super(t, d), this.sm1 = new s(B, 16);
    }
    pm5d8(t) {
      throw new Error("Not implemented.");
    }
    pp3d8(t) {
      throw new Error("Not implemented.");
    }
    sqrt(t) {
      const { red: d } = t, B = this.sm1._forceRed(d), U = this.pp3d8(t);
      if (d.sqr(U).eq(t))
        return U;
      const J = d.mul(U, B);
      if (d.sqr(J).eq(t))
        return J;
      throw new ue(U);
    }
    divsqrt(t, d) {
      const { red: B } = t, U = this.sm1._forceRed(B), J = B.mul(B.sqr(d), d), C = B.mul(B.sqr(J), d), M = this.pm5d8(B.mul(t, C)), $ = B.mul(B.mul(t, J), M), r = B.mul(d, B.sqr($));
      if (r.eq(t))
        return $;
      const x = B.ineg(r);
      if (x.eq(t))
        return B.mul($, U);
      throw x.eq(B.mul(t, U)) ? new ue(B.mul($, U)) : new ue($);
    }
  }
  class S extends i {
    constructor(t, d, B) {
      super(t, d), this.g = new s(B, 16), this.z = this.p.subn(1).zeroBits();
    }
    powS(t) {
      throw new Error("Not implemented.");
    }
    powE(t) {
      throw new Error("Not implemented.");
    }
    sqrt(t) {
      const { red: d } = t;
      switch (d.jacobi(t)) {
        case -1:
          throw new ue(t);
        case 0:
          return t.clone();
      }
      let B = this.g._forceRed(d), U = this.powE(t), J = this.powS(t), C = this.z;
      for (; ; ) {
        let M = J, $ = 0;
        for (; M.cmpn(1) !== 0 && $ < C; )
          M = d.sqr(M), $ += 1;
        if ($ === 0)
          break;
        q($ < C), M = d.sqrn(B, C - $ - 1), B = d.sqr(M), U = d.mul(U, M), J = d.mul(J, B), C = $;
      }
      return U;
    }
    divsqrt(t, d) {
      const { red: B } = t;
      if (d.isZero())
        throw new ue(d);
      return this.sqrt(B.div(t, d));
    }
  }
  class y extends p {
    constructor() {
      super("p192", "ffffffff ffffffff ffffffff fffffffeffffffff ffffffff");
    }
    imulK(t) {
      const d = this.one.inject(t);
      return t.iushln(64)._iadd(t, d);
    }
    core(t) {
      const { red: d } = t, B = d.sqrnmul(t, 1, t), U = d.sqrnmul(B, 1, t), J = d.sqrnmul(U, 3, U), C = d.sqrnmul(J, 6, J), M = d.sqrnmul(C, 12, C), $ = d.sqrnmul(M, 6, J), r = d.sqrnmul($, 1, t), x = d.sqrnmul(r, 31, r), O = d.sqrnmul(x, 62, x), K = d.sqrnmul(O, 3, U), X = d.sqrn(K, 1);
      return d.sqrnmul(X, 62, x);
    }
    pm3d4(t) {
      return this.core(t);
    }
    pm2(t) {
      const { red: d } = t, B = this.core(t), U = d.sqrn(B, 1);
      return d.sqrnmul(U, 1, t);
    }
    pp1d4(t) {
      const { red: d } = t, B = d.sqrnmul(t, 1, t), U = d.sqrnmul(B, 2, B), J = d.sqrnmul(U, 4, U), C = d.sqrnmul(J, 8, J), M = d.sqrnmul(C, 16, C), $ = d.sqrnmul(M, 32, M), r = d.sqrnmul($, 64, $);
      return d.sqrn(r, 62);
    }
  }
  class b extends S {
    constructor() {
      super(
        "p224",
        "ffffffff ffffffff ffffffff ffffffff00000000 00000000 00000001",
        "6a0fec67 8598a792 0c55b2d4 0b2d6ffbbea3d8ce f3fb3632 dc691b74"
      );
    }
    imulK(t) {
      const d = this.one.inject(t);
      return t.iushln(96)._isub(t, d);
    }
    powS(t) {
      const { red: d } = t, B = d.sqrnmul(t, 1, t), U = d.sqrnmul(B, 2, B), J = d.sqrnmul(U, 4, U), C = d.sqrnmul(J, 8, J), M = d.sqrnmul(C, 16, C), $ = d.sqrnmul(M, 32, M);
      return d.sqrnmul($, 64, $);
    }
    powE(t) {
      const { red: d } = t;
      return d.sqrn(t, 127);
    }
    pm2(t) {
      const { red: d } = t, B = d.sqrnmul(t, 1, t), U = d.sqrnmul(B, 1, t), J = d.sqrnmul(U, 3, U), C = d.sqrnmul(J, 6, J), M = d.sqrnmul(C, 12, C), $ = d.sqrnmul(M, 24, M), r = d.sqrnmul($, 48, $), x = d.sqrnmul(r, 24, M), O = d.sqrnmul(x, 6, J), K = d.sqrnmul(O, 1, t), X = d.sqrn(K, 1);
      return d.sqrnmul(X, 96, r);
    }
  }
  class h extends p {
    constructor() {
      super("p521", "000001ff ffffffff ffffffff ffffffffffffffff ffffffff ffffffff ffffffffffffffff ffffffff ffffffff ffffffffffffffff ffffffff ffffffff ffffffffffffffff");
    }
    imulK(t) {
      return t;
    }
    core(t) {
      const { red: d } = t, B = d.sqrnmul(t, 1, t), U = d.sqrnmul(B, 1, t), J = d.sqrnmul(U, 3, U), C = d.sqrnmul(J, 1, t), M = d.sqrnmul(C, 1, t), $ = d.sqrnmul(M, 8, M), r = d.sqrnmul($, 16, $), x = d.sqrnmul(r, 32, r), O = d.sqrnmul(x, 64, x), K = d.sqrnmul(O, 128, O), X = d.sqrnmul(K, 256, K);
      return d.sqrnmul(X, 7, C);
    }
    pm3d4(t) {
      return this.core(t);
    }
    pm2(t) {
      const { red: d } = t, B = this.core(t), U = d.sqrn(B, 1);
      return d.sqrnmul(U, 1, t);
    }
    pp1d4(t) {
      const { red: d } = t;
      return d.sqrn(t, 519);
    }
  }
  class a extends p {
    constructor() {
      super("k256", "ffffffff ffffffff ffffffff ffffffffffffffff ffffffff fffffffe fffffc2f");
    }
    split(t, d) {
      const U = Math.min(t.length, 9);
      d._alloc(U + 1);
      for (let M = 0; M < U; M++)
        d.words[M] = t.words[M];
      if (d.length = U, t.length <= 9) {
        d._strip(), t.words[0] = 0, t.length = 1;
        return;
      }
      let J = t.words[9], C = 10;
      for (d.words[d.length++] = J & 4194303, d._strip(); C < t.length; C++) {
        const M = t.words[C] | 0;
        t.words[C - 10] = (M & 4194303) << 4 | J >>> 22, J = M;
      }
      J >>>= 22, t.words[C - 10] = J, J === 0 && t.length > 10 ? t.length -= 10 : t.length -= 9, t._strip();
    }
    imulK(t) {
      t._expand(t.length + 2);
      let d = 0;
      for (let B = 0; B < t.length; B++) {
        const U = t.words[B];
        d += U * 977, t.words[B] = d & 67108863, d = U * 64 + Math.floor(d / 67108864);
      }
      return t.words[t.length - 1] === 0 && (t.length -= 1, t.words[t.length - 1] === 0 && (t.length -= 1)), t;
    }
    core(t, d) {
      const { red: B } = t, U = B.sqrnmul(d, 1, t), J = B.sqrnmul(U, 3, U), C = B.sqrnmul(J, 3, U), M = B.sqrnmul(C, 2, d), $ = B.sqrnmul(M, 11, M), r = B.sqrnmul($, 22, $), x = B.sqrnmul(r, 44, r), O = B.sqrnmul(x, 88, x), K = B.sqrnmul(O, 44, r), X = B.sqrnmul(K, 3, U), P = B.sqrn(X, 1), V = B.sqrnmul(P, 22, $);
      return B.sqrn(V, 4);
    }
    pm3d4(t) {
      const { red: d } = t, B = d.sqrnmul(t, 1, t), U = this.core(t, B), J = d.sqrnmul(U, 1, t), C = d.sqrn(J, 1);
      return d.sqrnmul(C, 2, B);
    }
    pm2(t) {
      const { red: d } = t, B = d.sqrnmul(t, 1, t), U = this.core(t, B), J = d.sqrnmul(U, 1, t), C = d.sqrn(J, 1), M = d.sqrnmul(C, 2, B), $ = d.sqrn(M, 1);
      return d.sqrnmul($, 1, t);
    }
    pp1d4(t) {
      const { red: d } = t, B = d.sqrnmul(t, 1, t), U = this.core(t, B), J = d.sqrnmul(U, 2, B);
      return d.sqrn(J, 2);
    }
  }
  class E extends p {
    constructor() {
      super("p251", "07ffffff ffffffff ffffffff ffffffffffffffff ffffffff ffffffff fffffff7");
    }
    imulK(t) {
      if (t.isZero())
        return t;
      let d = 0;
      for (let B = 0; B < t.length; B++) {
        const U = t.words[B] * 9 + d;
        d = U >>> 26, t.words[B] = U & 67108863;
      }
      return d !== 0 && (t._alloc(t.length + 1), t.words[t.length++] = d), t;
    }
    core(t) {
      const { red: d } = t, B = d.sqrnmul(t, 1, t), U = d.sqrnmul(B, 1, t), J = d.sqrnmul(U, 3, U), C = d.sqrnmul(J, 6, J), M = d.sqrnmul(C, 12, C), $ = d.sqrnmul(M, 24, M), r = d.sqrnmul($, 48, $), x = d.sqrnmul(r, 96, r), O = d.sqrnmul(x, 48, $), K = d.sqrnmul(O, 6, J);
      return d.sqrnmul(K, 1, t);
    }
    pm3d4(t) {
      const { red: d } = t, B = this.core(t), U = d.sqrn(B, 1);
      return d.sqrnmul(U, 1, t);
    }
    pm2(t) {
      const { red: d } = t, B = this.core(t), U = d.sqrn(B, 1), J = d.sqrnmul(U, 1, t), C = d.sqrn(J, 1);
      return d.sqrnmul(C, 1, t);
    }
    pp1d4(t) {
      const { red: d } = t, B = this.core(t), U = d.sqrnmul(B, 1, t);
      return d.sqrn(U, 1);
    }
  }
  class H extends g {
    constructor() {
      super(
        "p25519",
        "7fffffff ffffffff ffffffff ffffffffffffffff ffffffff ffffffff ffffffed",
        "2b832480 4fc1df0b 2b4d0099 3dfbd7a72f431806 ad2fe478 c4ee1b27 4a0ea0b0"
      );
    }
    imulK(t) {
      let d = 0;
      for (let B = 0; B < t.length; B++) {
        const U = t.words[B] * 19 + d;
        d = U >>> 26, t.words[B] = U & 67108863;
      }
      return d !== 0 && (t._alloc(t.length + 1), t.words[t.length++] = d), t;
    }
    core(t, d) {
      const { red: B } = t, U = B.sqrnmul(d, 2, d), J = B.sqrnmul(U, 1, t), C = B.sqrnmul(J, 5, J), M = B.sqrnmul(C, 10, C), $ = B.sqrnmul(M, 20, M), r = B.sqrnmul($, 10, C), x = B.sqrnmul(r, 50, r), O = B.sqrnmul(x, 100, x);
      return B.sqrnmul(O, 50, r);
    }
    pm5d8(t) {
      const { red: d } = t, B = d.sqrnmul(t, 1, t), U = this.core(t, B), J = d.sqrn(U, 1);
      return d.sqrnmul(J, 1, t);
    }
    pm2(t) {
      const { red: d } = t, B = d.sqrnmul(t, 1, t), U = this.core(t, B), J = d.sqrn(U, 1), C = d.sqrnmul(J, 1, t), M = d.sqrn(C, 1);
      return d.sqrnmul(M, 2, B);
    }
    pp3d8(t) {
      const { red: d } = t, B = d.sqrnmul(t, 1, t), U = this.core(t, B), J = d.sqrnmul(U, 1, t);
      return d.sqrn(J, 1);
    }
  }
  class j extends p {
    constructor() {
      super("p448", "ffffffff ffffffff ffffffff ffffffffffffffff ffffffff fffffffe ffffffffffffffff ffffffff ffffffff ffffffffffffffff ffffffff");
    }
    imulK(t) {
      const d = this.one.inject(t);
      return t.iushln(224)._iadd(t, d);
    }
    core(t, d) {
      const { red: B } = t, U = B.sqrnmul(d, 1, t), J = B.sqrnmul(U, 3, U), C = B.sqrnmul(J, 3, U), M = B.sqrnmul(C, 2, d), $ = B.sqrnmul(M, 11, M), r = B.sqrnmul($, 22, $), x = B.sqrnmul(r, 44, r), O = B.sqrnmul(x, 88, x), K = B.sqrnmul(O, 44, r);
      return B.sqrnmul(K, 2, d);
    }
    pm3d4(t) {
      const { red: d } = t, B = d.sqrnmul(t, 1, t), U = this.core(t, B), J = d.sqrnmul(U, 1, t), C = d.sqrn(J, 1);
      return d.sqrnmul(C, 222, U);
    }
    pm2(t) {
      const { red: d } = t, B = this.pm3d4(t), U = d.sqrn(B, 1);
      return d.sqrnmul(U, 1, t);
    }
    pp1d4(t) {
      const { red: d } = t, B = d.sqrnmul(t, 1, t), U = this.core(t, B), J = d.sqrnmul(U, 2, B);
      return d.sqrn(J, 222);
    }
  }
  class G {
    constructor(t) {
      let d = null;
      typeof t == "string" && (d = s._prime(t), t = d.p), _(s.isBN(t), "m", "bignum"), L(!t.red, "reduction"), F(t.sign() > 0, "reduction"), this.m = t, this.prime = d, this.mb = null, this.sm1 = null;
    }
    _verify1(t) {
      F(t.negative === 0, "red"), R(t.red != null, "red");
    }
    _verify2(t, d) {
      F((t.negative | d.negative) === 0, "red"), R(t.red != null && t.red === d.red, "red");
    }
    get mont() {
      return !1;
    }
    precompute() {
      if (this.sm1 === null && this.m.andln(7) === 5)
        if (this.prime)
          this.sm1 = this.prime.sm1.clone()._forceRed(this);
        else {
          const t = new s(2).toRed(this), d = this.m.subn(1).iushrn(2);
          this.sm1 = this.pow(t, d);
        }
      return this;
    }
    convertTo(t) {
      const d = t.mod(this.m);
      return d.red = this, d;
    }
    convertFrom(t) {
      const d = t.clone();
      return d.red = null, d;
    }
    intTo(t) {
      return t;
    }
    intFrom(t) {
      return t;
    }
    imod(t) {
      return this.prime ? this.prime.ireduce(t)._forceRed(this) : t.imod(this.m)._forceRed(this);
    }
    iadd(t, d) {
      return this._verify2(t, d), t._iadd(t, d), t.ucmp(this.m) >= 0 && t._isub(t, this.m), t;
    }
    add(t, d) {
      return t.length < d.length ? this.iadd(d.clone(), t) : this.iadd(t.clone(), d);
    }
    iaddn(t, d) {
      return this._verify1(t), d < 0 ? this.isubn(t, -d) : (this.m.length === 1 && (d %= this.m.words[0]), t._iaddn(d), t.ucmp(this.m) >= 0 && t._isub(t, this.m), t);
    }
    addn(t, d) {
      return this.iaddn(t.clone(), d);
    }
    isub(t, d) {
      this._verify2(t, d);
      const B = t.ucmp(d);
      return B === 0 ? (t.words[0] = 0, t.length = 1, t) : (B < 0 ? (t._isub(d, t), t._isub(this.m, t)) : t._isub(t, d), t);
    }
    sub(t, d) {
      return this.isub(t.clone(), d);
    }
    isubn(t, d) {
      return this._verify1(t), d < 0 ? this.iaddn(t, -d) : (this.m.length === 1 && (d %= this.m.words[0]), t.length === 1 && t.words[0] < d ? (t.words[0] = d - t.words[0], t._isub(this.m, t)) : t._isubn(d), t);
    }
    subn(t, d) {
      return this.isubn(t.clone(), d);
    }
    imul(t, d) {
      return this._verify2(t, d), this.imod(t.imul(d));
    }
    mul(t, d) {
      return this._verify2(t, d), this.imod(t.mul(d));
    }
    imuln(t, d) {
      if (this._verify1(t), t.isZero())
        return t;
      if (d === 0)
        return t.words[0] = 0, t.length = 1, t;
      const B = d < 0;
      if (B && (d = -d), this.m.length === 1 && (d %= this.m.words[0]), t.imuln(d), d <= 16)
        for (; t.ucmp(this.m) >= 0; )
          t._isub(t, this.m);
      else
        this.imod(t);
      return B && this.ineg(t), t;
    }
    muln(t, d) {
      return this.imuln(t.clone(), d);
    }
    idiv(t, d) {
      return this.div(t, d)._move(t);
    }
    div(t, d) {
      return this.mul(t, this.invert(d));
    }
    idivn(t, d) {
      return this.divn(t, d)._move(t);
    }
    divn(t, d) {
      return this.div(t, this.convertTo(new s(d)));
    }
    ipow(t, d) {
      return this.pow(t, d)._move(t);
    }
    pow(t, d) {
      return this._verify1(t), d.isNeg() && (t = this.invert(t)), d.length === 1 ? this.pown(t, d.words[0]) : o && !this.prime ? this.powInt(t, d) : this.powNum(t, d);
    }
    powNum(t, d) {
      const B = new s(1).toRed(this), U = new Array(u), J = this.sqr(t);
      U[0] = t;
      for (let $ = 1; $ < u; $++)
        U[$] = this.mul(U[$ - 1], J);
      let C = d.bitLength(), M = B;
      for (; C >= n; ) {
        let $ = n, r = d.bits(C - $, $);
        if (r < u) {
          M = this.sqr(M), C -= 1;
          continue;
        }
        for (; (r & 1) === 0; )
          $ -= 1, r >>= 1;
        M === B ? M = U[r >> 1].clone() : (M = this.sqrn(M, $), M = this.mul(M, U[r >> 1])), C -= $;
      }
      if (C > 0) {
        const $ = d.bits(0, C);
        for (; C--; )
          M = this.sqr(M), $ >> C & 1 && (M = this.mul(M, t));
      }
      return M;
    }
    powInt(t, d) {
      this.mb === null && (this.mb = this.m.toBigInt());
      const B = this.intFrom(t.toBigInt()), U = le(B, d, this.mb), J = this.intTo(U);
      return s.fromBigInt(J)._forceRed(this);
    }
    sqrn(t, d) {
      for (; d--; )
        t = this.sqr(t);
      return t;
    }
    sqrnmul(t, d, B) {
      return this.mul(this.sqrn(t, d), B);
    }
    ipown(t, d) {
      return this.pown(t, d)._move(t);
    }
    pown(t, d) {
      if (this._verify1(t), d < 0 && (t = this.invert(t), d = -d), d === 0)
        return new s(1).toRed(this);
      if (d === 1)
        return t.clone();
      const B = oe(d);
      let U = t;
      for (let J = B - 2; J >= 0; J--)
        U = this.sqr(U), d >> J & 1 && (U = this.mul(U, t));
      return U;
    }
    isqr(t) {
      return this.imul(t, t);
    }
    sqr(t) {
      return this.mul(t, t);
    }
    isqrt(t) {
      return this.sqrt(t)._move(t);
    }
    sqrt(t) {
      return this._verify1(t), this.prime ? this.prime.sqrt(t) : this.m.andln(3) === 3 ? this.sqrt3mod4(t) : this.m.andln(7) === 5 ? this.sm1 != null ? this.sqrt5mod8sm1(t) : this.sqrt5mod8(t) : this.sqrt0(t);
    }
    sqrt3mod4(t) {
      const d = this.m.addn(1).iushrn(2), B = this.pow(t, d);
      if (!this.sqr(B).eq(t))
        throw new ue(B);
      return B;
    }
    sqrt5mod8(t) {
      const d = new s(1).toRed(this), B = this.m.ushrn(3), U = this.add(t, t), J = this.pow(U, B), C = this.mul(U, this.sqr(J)), M = this.mul(this.mul(J, t), this.isub(C, d));
      if (!this.sqr(M).eq(t))
        throw new ue(M);
      return M;
    }
    sqrt5mod8sm1(t) {
      const d = this.m.addn(3).iushrn(3), B = this.pow(t, d);
      if (this.sqr(B).eq(t))
        return B;
      const U = this.mul(B, this.sm1);
      if (this.sqr(U).eq(t))
        return U;
      throw new ue(B);
    }
    sqrt0(t) {
      if (this.m.cmpn(1) === 0 || !this.m.isOdd())
        throw new Error("Invalid prime.");
      switch (this.jacobi(t)) {
        case -1:
          throw new ue(t);
        case 0:
          return t.clone();
      }
      const d = new s(1).toRed(this), B = this.m.subn(1), U = B._makeOdd(), J = new s(2).toRed(this);
      for (; this.jacobi(J) !== -1; )
        this.iadd(J, d);
      let C = this.pow(J, B), M = this.pow(t, B), $ = this.pow(t, B.iaddn(1).iushrn(1)), r = U;
      for (; ; ) {
        let x = M, O = 0;
        for (; !x.eq(d) && O < r; )
          x = this.sqr(x), O += 1;
        if (O === 0)
          break;
        q(O < r), x = this.sqrn(C, r - O - 1), C = this.sqr(x), $ = this.mul($, x), M = this.mul(M, C), r = O;
      }
      return $;
    }
    idivsqrt(t, d) {
      return this.divsqrt(t, d)._move(t);
    }
    divsqrt(t, d) {
      if (this._verify2(t, d), t.isZero() && d.isZero())
        throw new ue(d);
      if (this.prime)
        return this.prime.divsqrt(t, d);
      if (this.m.andln(3) === 3)
        return this.divsqrt3mod4(t, d);
      if (this.sm1 != null && this.m.andln(7) === 5)
        return this.divsqrt5mod8(t, d);
      if (d.isZero())
        throw new ue(d);
      return this.sqrt(this.div(t, d));
    }
    divsqrt3mod4(t, d) {
      const B = this.m.subn(3).iushrn(2), U = this.sqr(t), J = this.mul(U, t), C = this.mul(J, U), M = this.mul(this.sqr(d), d), $ = this.pow(this.mul(C, M), B), r = this.mul(this.mul(J, d), $);
      if (this.mul(d, this.sqr(r)).eq(t))
        return r;
      throw new ue(r);
    }
    divsqrt5mod8(t, d) {
      const B = this.m.subn(5).iushrn(3), U = this.mul(this.sqr(d), d), J = this.mul(this.sqr(U), d), C = this.pow(this.mul(t, J), B), M = this.mul(this.mul(t, U), C), $ = this.mul(d, this.sqr(M));
      if ($.eq(t))
        return M;
      const r = this.ineg($);
      if (r.eq(t))
        return this.mul(M, this.sm1);
      throw r.eq(this.mul(t, this.sm1)) ? new ue(this.mul(M, this.sm1)) : new ue(M);
    }
    isSquare(t) {
      return this.m.isOdd() ? this.jacobi(t) >= 0 : this.kronecker(t) >= 0;
    }
    ishl(t, d) {
      return this._verify1(t), this.imod(t.iushl(d));
    }
    shl(t, d) {
      return this.ishl(t.clone(), d);
    }
    ishln(t, d) {
      if (this._verify1(t), t.iushln(d), d <= 4)
        for (; t.ucmp(this.m) >= 0; )
          t._isub(t, this.m);
      else
        this.imod(t);
      return t;
    }
    shln(t, d) {
      return this.ishln(t.clone(), d);
    }
    ineg(t) {
      return this._verify1(t), t.isZero() || t._isub(this.m, t), t;
    }
    neg(t) {
      return this.ineg(t.clone());
    }
    eq(t, d) {
      return this._verify2(t, d), t.ucmp(d) === 0;
    }
    eqn(t, d) {
      if (this._verify1(t), this.m.length === 1)
        return d %= this.m.words[0], d < 0 && (d += this.m.words[0]), t.ucmpn(d) === 0;
      if (d < 0) {
        this.m._isubn(-d);
        const B = t.ucmp(this.m);
        return this.m._iaddn(-d), B === 0;
      }
      return t.ucmpn(d) === 0;
    }
    isHigh(t) {
      return !this.isLow(t);
    }
    isLow(t) {
      return this._verify1(t), t.ucmp(this.m.ushrn(1)) <= 0;
    }
    isOdd(t) {
      return this._verify1(t), t.isOdd();
    }
    isEven(t) {
      return this._verify1(t), t.isEven();
    }
    legendre(t) {
      if (this._verify1(t), this.m.isEven())
        throw new Error("legendre: `num` must be odd.");
      const d = this.m.subn(1).iushrn(1), B = this.pow(t, d);
      if (B.isZero())
        return 0;
      const U = new s(1).toRed(this);
      if (B.eq(U))
        return 1;
      if (B.eq(this.ineg(U)))
        return -1;
      throw new Error("Invalid prime.");
    }
    jacobi(t) {
      return this._verify1(t), t.jacobi(this.m);
    }
    kronecker(t) {
      return this._verify1(t), t.kronecker(this.m);
    }
    iinvert(t) {
      return this.invert(t)._move(t);
    }
    invert(t) {
      return this._verify1(t), t.invert(this.m)._forceRed(this);
    }
    ifermat(t) {
      return this.fermat(t)._move(t);
    }
    fermat(t) {
      if (this._verify1(t), t.isZero() || this.m.cmpn(1) === 0)
        throw new RangeError("Not invertible.");
      return this.prime ? this.prime.fermat(t) : this.pow(t, this.m.subn(2));
    }
    invertAll(t) {
      _(Array.isArray(t), "elems", "array");
      for (const J of t)
        _(s.isBN(J), "elem", "bignum"), this._verify1(J);
      if (this.m.cmpn(1) === 0 || this.m.isEven())
        throw new RangeError("Not invertible.");
      const d = t.length, B = new Array(d);
      if (d === 0)
        return B;
      let U = new s(1).toRed(this);
      for (let J = 0; J < d; J++) {
        if (t[J].isZero()) {
          B[J] = t[J].clone();
          continue;
        }
        B[J] = U, U = this.mul(U, t[J]);
      }
      U = this.invert(U);
      for (let J = d - 1; J >= 0; J--)
        t[J].isZero() || (B[J] = this.mul(U, B[J]), U = this.mul(U, t[J]));
      return B;
    }
    [e]() {
      return this.prime ? `<Red: ${this.prime.name}>` : `<Red: ${this.m.toString(10)}>`;
    }
  }
  class N extends G {
    constructor(t) {
      super(t), this.prime = null, this.n = this.m.bitLength(), this.n % 26 !== 0 && (this.n += 26 - this.n % 26), this.k = this.n * 2, this.w = this.k / 26, this.b = s.shift(1, this.k).div(this.m);
    }
    convertTo(t) {
      return t.length > this.w ? super.convertTo(t) : this.imod(t.clone());
    }
    _shift(t) {
      let d = 0, B = this.w;
      for (; B < t.length; )
        t.words[d++] = t.words[B++];
      d === 0 && (t.words[d++] = 0), t.length = d;
    }
    imod(t) {
      const d = t.negative;
      q(t.length <= this.w), t.negative = 0;
      const B = t.mul(this.b);
      return this._shift(B), t._isub(t, B.mul(this.m)), t.ucmp(this.m) >= 0 && t._isub(t, this.m), d && !t.isZero() && t._isub(this.m, t), t.red = this, t;
    }
  }
  class T extends G {
    constructor(t) {
      super(t), this.prime = null, this.n = this.m.length * 26, this.r = s.shift(1, this.n), this.r2 = s.shift(1, this.n * 2).imod(this.m), this.ri = this.r.invert(this.m), this.mi = this.r.mul(this.ri).isubn(1).div(this.m), this.rib = null;
    }
    get mont() {
      return !0;
    }
    convertTo(t) {
      return t.isNeg() || t.ucmp(this.m) >= 0 ? this.imod(t.ushln(this.n)) : this.mul(t, this.r2);
    }
    convertFrom(t) {
      const d = this.mul(t, new s(1));
      return d.red = null, d;
    }
    intTo(t) {
      return (t << BigInt(this.n)) % this.mb;
    }
    intFrom(t) {
      return this.rib === null && (this.rib = this.ri.toBigInt()), t * this.rib % this.mb;
    }
    iaddn(t, d) {
      return this.iadd(t, this.convertTo(new s(d)));
    }
    isubn(t, d) {
      return this.isub(t, this.convertTo(new s(d)));
    }
    imul(t, d) {
      return this.mul(t, d)._move(t);
    }
    mul(t, d) {
      if (t.isZero() || d.isZero())
        return new s(0)._forceRed(this);
      const B = t.mul(d), U = B.umaskn(this.n).mul(this.mi).iumaskn(this.n), J = B.iadd(U.mul(this.m)).iushrn(this.n);
      return J.ucmp(this.m) >= 0 && J._isub(J, this.m), J._forceRed(this);
    }
    imuln(t, d) {
      if (this._verify1(t), t.isZero())
        return t;
      if (d === 0)
        return t.words[0] = 0, t.length = 1, t;
      const B = d < 0;
      B && (d = -d), this.m.length === 1 && (d %= this.m.words[0]);
      const U = oe(d);
      if (U > 5)
        this.imul(t, this.convertTo(new s(d)));
      else if ((d & d - 1) === 0)
        for (let J = 0; J < U - 1; J++)
          this.iadd(t, t);
      else {
        const J = t.clone();
        for (let C = U - 2; C >= 0; C--)
          this.iadd(t, t), d >> C & 1 && this.iadd(t, J);
      }
      return B && this.ineg(t), t;
    }
    eqn(t, d) {
      return this._verify1(t), d === 0 ? t.isZero() : t.ucmp(this.convertTo(new s(d))) === 0;
    }
    isLow(t) {
      return this._verify1(t), this.convertFrom(t).ucmp(this.m.ushrn(1)) <= 0;
    }
    isOdd(t) {
      return this._verify1(t), this.convertFrom(t).isOdd();
    }
    isEven(t) {
      return this._verify1(t), this.convertFrom(t).isEven();
    }
    invert(t) {
      return this._verify1(t), this.imod(t.invert(this.m).mul(this.r2));
    }
  }
  function A(ne, t, d) {
    const B = new ne(t);
    return ne.captureStackTrace && ne.captureStackTrace(B, d), B;
  }
  function q(ne, t) {
    if (!ne)
      throw A(Error, t || "Assertion failed.", q);
  }
  function _(ne, t, d) {
    if (!ne) {
      const B = `"${t}" must be a(n) ${d}.`;
      throw A(TypeError, B, _);
    }
  }
  function F(ne, t) {
    if (!ne) {
      const d = `"${t}" only works with positive numbers.`;
      throw A(RangeError, d, F);
    }
  }
  function R(ne, t) {
    if (!ne) {
      const d = `"${t}" only works with red numbers.`;
      throw A(TypeError, d, R);
    }
  }
  function L(ne, t) {
    if (!ne) {
      const d = `"${t}" only works with normal numbers.`;
      throw A(TypeError, d, L);
    }
  }
  function fe(ne) {
    if (!ne)
      throw A(RangeError, "Cannot divide by zero.", fe);
  }
  class ue extends Error {
    constructor(t) {
      super(), this.name = "SquareRootError", this.message = "X is not a square mod P.", this.result = t.fromRed(), Error.captureStackTrace && Error.captureStackTrace(this, ue);
    }
  }
  function ae(ne) {
    return Number.isSafeInteger(ne);
  }
  function D(ne) {
    return ae(ne) && ne >= -67108863 && ne <= 67108863;
  }
  function Q(ne, t) {
    return ne.allocUnsafeSlow ? ne.allocUnsafeSlow(t) : new ne(t);
  }
  function W(ne) {
    if (ne == null)
      return 10;
    if (typeof ne == "number")
      return ne;
    switch (ne) {
      case "bin":
        return 2;
      case "oct":
        return 8;
      case "dec":
        return 10;
      case "hex":
        return 16;
    }
    return 0;
  }
  function oe(ne) {
    if (Math.clz32)
      return 32 - Math.clz32(ne);
    let t = ne, d = 0;
    return t >= 4096 && (d += 13, t >>>= 13), t >= 64 && (d += 7, t >>>= 7), t >= 8 && (d += 4, t >>>= 4), t >= 2 && (d += 2, t >>>= 2), d + t;
  }
  function v(ne) {
    if (ne === 0)
      return 26;
    let t = ne, d = 0;
    return (t & 8191) === 0 && (d += 13, t >>>= 13), (t & 127) === 0 && (d += 7, t >>>= 7), (t & 15) === 0 && (d += 4, t >>>= 4), (t & 3) === 0 && (d += 2, t >>>= 2), (t & 1) === 0 && (d += 1), d;
  }
  function Y(ne, t, d) {
    const B = Math.min(ne.length, d);
    let U = 0, J = 0;
    for (let C = t; C < B; C++) {
      const M = ne.charCodeAt(C) - 48;
      U <<= 4;
      let $;
      M >= 49 && M <= 54 ? $ = M - 49 + 10 : M >= 17 && M <= 22 ? $ = M - 17 + 10 : $ = M, U |= $, J |= $;
    }
    if (J & -16)
      throw new Error("Invalid string.");
    return U;
  }
  function he(ne, t, d, B) {
    const U = Math.min(ne.length, d);
    let J = 0;
    for (let C = t; C < U; C++) {
      const M = ne.charCodeAt(C) - 48;
      J *= B;
      let $;
      if (M >= 49 ? $ = M - 49 + 10 : M >= 17 ? $ = M - 17 + 10 : $ = M, M < 0 || M > 207 || $ >= B)
        throw new Error("Invalid string.");
      J += $;
    }
    return J;
  }
  function le(ne, t, d) {
    const B = BigInt(1), U = new Array(u), J = ne * ne % d;
    U[0] = ne;
    for (let $ = 1; $ < u; $++)
      U[$] = U[$ - 1] * J % d;
    let C = t.bitLength(), M = B;
    for (; C >= n; ) {
      let $ = n, r = t.bits(C - $, $);
      if (r < u) {
        M = M * M % d, C -= 1;
        continue;
      }
      for (; (r & 1) === 0; )
        $ -= 1, r >>= 1;
      M === B ? M = U[r >> 1] : (M = ge(M, $, d), M = M * U[r >> 1] % d), C -= $;
    }
    if (C > 0) {
      const $ = t.bits(0, C);
      for (; C--; )
        M = M * M % d, $ >> C & 1 && (M = M * ne % d);
    }
    return M;
  }
  function ge(ne, t, d) {
    for (let B = 0; B < t; B++)
      ne = ne * ne % d;
    return ne;
  }
  function Ee(ne, t, d) {
    const B = ne.length + t.length;
    d.negative = ne.negative ^ t.negative, d._alloc(B), d.length = B;
    const U = ne.words[0], J = t.words[0], C = U * J, M = C & 67108863;
    let $ = C / 67108864 | 0, r = 1;
    for (d.words[0] = M; r < d.length - 1; r++) {
      let x = $ >>> 26, O = $ & 67108863;
      const K = Math.max(0, r - ne.length + 1), X = Math.min(r, t.length - 1);
      for (let P = K; P <= X; P++) {
        const V = r - P, re = ne.words[V], ce = t.words[P], de = re * ce + O;
        x += de / 67108864 | 0, O = de & 67108863;
      }
      d.words[r] = O | 0, $ = x | 0;
    }
    return $ !== 0 ? d.words[r] = $ | 0 : d.length -= 1, d._strip();
  }
  function we(ne, t, d) {
    const B = ne.length + t.length;
    d.negative = ne.negative ^ t.negative, d._alloc(B), d.length = B;
    let U = 0, J = 0, C = 0;
    for (; C < d.length - 1; C++) {
      let M = J;
      J = 0;
      let $ = U & 67108863;
      const r = Math.max(0, C - ne.length + 1), x = Math.min(C, t.length - 1);
      for (let O = r; O <= x; O++) {
        const K = C - O, X = ne.words[K], P = t.words[O], V = X * P;
        let re = V & 67108863;
        M = M + (V / 67108864 | 0) | 0, re = re + $ | 0, $ = re & 67108863, M = M + (re >>> 26) | 0, J += M >>> 26, M &= 67108863;
      }
      d.words[C] = $, U = M, M = J;
    }
    return U !== 0 ? d.words[C] = U : d.length -= 1, d._strip();
  }
  function z(ne, t, d) {
    if (!o || ne.length + t.length > 82595519)
      return we(ne, t, d);
    const B = BigInt(0), U = BigInt(67108863), J = BigInt(26);
    let C = ne.toBigInt() * t.toBigInt();
    const M = C < B | 0;
    M && (C = -C);
    let $ = 0;
    for (; C > B; )
      d.words[$++] = Number(C & U), C >>= J;
    return $ === 0 && (d.words[$++] = 0), d.length = $, d.negative = M, d;
  }
  function I(ne, t, d) {
    const B = ne.words, U = t.words, J = d.words, C = B[0] | 0, M = C & 8191, $ = C >>> 13, r = B[1] | 0, x = r & 8191, O = r >>> 13, K = B[2] | 0, X = K & 8191, P = K >>> 13, V = B[3] | 0, re = V & 8191, ce = V >>> 13, de = B[4] | 0, pe = de & 8191, se = de >>> 13, Z = B[5] | 0, ee = Z & 8191, me = Z >>> 13, Ae = B[6] | 0, Oe = Ae & 8191, ye = Ae >>> 13, _e = B[7] | 0, ke = _e & 8191, Me = _e >>> 13, De = B[8] | 0, Ne = De & 8191, $e = De >>> 13, bt = B[9] | 0, Ve = bt & 8191, je = bt >>> 13, _t = U[0] | 0, Je = _t & 8191, Ye = _t >>> 13, Ot = U[1] | 0, We = Ot & 8191, Ze = Ot >>> 13, Tt = U[2] | 0, Qe = Tt & 8191, rt = Tt >>> 13, ur = U[3] | 0, nt = ur & 8191, ft = ur >>> 13, gr = U[4] | 0, et = gr & 8191, ct = gr >>> 13, hr = U[5] | 0, ut = hr & 8191, lt = hr >>> 13, lr = U[6] | 0, tt = lr & 8191, it = lr >>> 13, _r = U[7] | 0, st = _r & 8191, gt = _r >>> 13, Dr = U[8] | 0, ot = Dr & 8191, pt = Dr >>> 13, nr = U[9] | 0, ht = nr & 8191, at = nr >>> 13;
    let Ke = 0, Se, te, ve;
    d.negative = ne.negative ^ t.negative, d._alloc(20), d.length = 19, Se = Math.imul(M, Je), te = Math.imul(M, Ye), te = te + Math.imul($, Je) | 0, ve = Math.imul($, Ye);
    let Dt = (Ke + Se | 0) + ((te & 8191) << 13) | 0;
    Ke = (ve + (te >>> 13) | 0) + (Dt >>> 26) | 0, Dt &= 67108863, Se = Math.imul(x, Je), te = Math.imul(x, Ye), te = te + Math.imul(O, Je) | 0, ve = Math.imul(O, Ye), Se = Se + Math.imul(M, We) | 0, te = te + Math.imul(M, Ze) | 0, te = te + Math.imul($, We) | 0, ve = ve + Math.imul($, Ze) | 0;
    let xe = (Ke + Se | 0) + ((te & 8191) << 13) | 0;
    Ke = (ve + (te >>> 13) | 0) + (xe >>> 26) | 0, xe &= 67108863, Se = Math.imul(X, Je), te = Math.imul(X, Ye), te = te + Math.imul(P, Je) | 0, ve = Math.imul(P, Ye), Se = Se + Math.imul(x, We) | 0, te = te + Math.imul(x, Ze) | 0, te = te + Math.imul(O, We) | 0, ve = ve + Math.imul(O, Ze) | 0, Se = Se + Math.imul(M, Qe) | 0, te = te + Math.imul(M, rt) | 0, te = te + Math.imul($, Qe) | 0, ve = ve + Math.imul($, rt) | 0;
    let ie = (Ke + Se | 0) + ((te & 8191) << 13) | 0;
    Ke = (ve + (te >>> 13) | 0) + (ie >>> 26) | 0, ie &= 67108863, Se = Math.imul(re, Je), te = Math.imul(re, Ye), te = te + Math.imul(ce, Je) | 0, ve = Math.imul(ce, Ye), Se = Se + Math.imul(X, We) | 0, te = te + Math.imul(X, Ze) | 0, te = te + Math.imul(P, We) | 0, ve = ve + Math.imul(P, Ze) | 0, Se = Se + Math.imul(x, Qe) | 0, te = te + Math.imul(x, rt) | 0, te = te + Math.imul(O, Qe) | 0, ve = ve + Math.imul(O, rt) | 0, Se = Se + Math.imul(M, nt) | 0, te = te + Math.imul(M, ft) | 0, te = te + Math.imul($, nt) | 0, ve = ve + Math.imul($, ft) | 0;
    let be = (Ke + Se | 0) + ((te & 8191) << 13) | 0;
    Ke = (ve + (te >>> 13) | 0) + (be >>> 26) | 0, be &= 67108863, Se = Math.imul(pe, Je), te = Math.imul(pe, Ye), te = te + Math.imul(se, Je) | 0, ve = Math.imul(se, Ye), Se = Se + Math.imul(re, We) | 0, te = te + Math.imul(re, Ze) | 0, te = te + Math.imul(ce, We) | 0, ve = ve + Math.imul(ce, Ze) | 0, Se = Se + Math.imul(X, Qe) | 0, te = te + Math.imul(X, rt) | 0, te = te + Math.imul(P, Qe) | 0, ve = ve + Math.imul(P, rt) | 0, Se = Se + Math.imul(x, nt) | 0, te = te + Math.imul(x, ft) | 0, te = te + Math.imul(O, nt) | 0, ve = ve + Math.imul(O, ft) | 0, Se = Se + Math.imul(M, et) | 0, te = te + Math.imul(M, ct) | 0, te = te + Math.imul($, et) | 0, ve = ve + Math.imul($, ct) | 0;
    let Ie = (Ke + Se | 0) + ((te & 8191) << 13) | 0;
    Ke = (ve + (te >>> 13) | 0) + (Ie >>> 26) | 0, Ie &= 67108863, Se = Math.imul(ee, Je), te = Math.imul(ee, Ye), te = te + Math.imul(me, Je) | 0, ve = Math.imul(me, Ye), Se = Se + Math.imul(pe, We) | 0, te = te + Math.imul(pe, Ze) | 0, te = te + Math.imul(se, We) | 0, ve = ve + Math.imul(se, Ze) | 0, Se = Se + Math.imul(re, Qe) | 0, te = te + Math.imul(re, rt) | 0, te = te + Math.imul(ce, Qe) | 0, ve = ve + Math.imul(ce, rt) | 0, Se = Se + Math.imul(X, nt) | 0, te = te + Math.imul(X, ft) | 0, te = te + Math.imul(P, nt) | 0, ve = ve + Math.imul(P, ft) | 0, Se = Se + Math.imul(x, et) | 0, te = te + Math.imul(x, ct) | 0, te = te + Math.imul(O, et) | 0, ve = ve + Math.imul(O, ct) | 0, Se = Se + Math.imul(M, ut) | 0, te = te + Math.imul(M, lt) | 0, te = te + Math.imul($, ut) | 0, ve = ve + Math.imul($, lt) | 0;
    let Re = (Ke + Se | 0) + ((te & 8191) << 13) | 0;
    Ke = (ve + (te >>> 13) | 0) + (Re >>> 26) | 0, Re &= 67108863, Se = Math.imul(Oe, Je), te = Math.imul(Oe, Ye), te = te + Math.imul(ye, Je) | 0, ve = Math.imul(ye, Ye), Se = Se + Math.imul(ee, We) | 0, te = te + Math.imul(ee, Ze) | 0, te = te + Math.imul(me, We) | 0, ve = ve + Math.imul(me, Ze) | 0, Se = Se + Math.imul(pe, Qe) | 0, te = te + Math.imul(pe, rt) | 0, te = te + Math.imul(se, Qe) | 0, ve = ve + Math.imul(se, rt) | 0, Se = Se + Math.imul(re, nt) | 0, te = te + Math.imul(re, ft) | 0, te = te + Math.imul(ce, nt) | 0, ve = ve + Math.imul(ce, ft) | 0, Se = Se + Math.imul(X, et) | 0, te = te + Math.imul(X, ct) | 0, te = te + Math.imul(P, et) | 0, ve = ve + Math.imul(P, ct) | 0, Se = Se + Math.imul(x, ut) | 0, te = te + Math.imul(x, lt) | 0, te = te + Math.imul(O, ut) | 0, ve = ve + Math.imul(O, lt) | 0, Se = Se + Math.imul(M, tt) | 0, te = te + Math.imul(M, it) | 0, te = te + Math.imul($, tt) | 0, ve = ve + Math.imul($, it) | 0;
    let Be = (Ke + Se | 0) + ((te & 8191) << 13) | 0;
    Ke = (ve + (te >>> 13) | 0) + (Be >>> 26) | 0, Be &= 67108863, Se = Math.imul(ke, Je), te = Math.imul(ke, Ye), te = te + Math.imul(Me, Je) | 0, ve = Math.imul(Me, Ye), Se = Se + Math.imul(Oe, We) | 0, te = te + Math.imul(Oe, Ze) | 0, te = te + Math.imul(ye, We) | 0, ve = ve + Math.imul(ye, Ze) | 0, Se = Se + Math.imul(ee, Qe) | 0, te = te + Math.imul(ee, rt) | 0, te = te + Math.imul(me, Qe) | 0, ve = ve + Math.imul(me, rt) | 0, Se = Se + Math.imul(pe, nt) | 0, te = te + Math.imul(pe, ft) | 0, te = te + Math.imul(se, nt) | 0, ve = ve + Math.imul(se, ft) | 0, Se = Se + Math.imul(re, et) | 0, te = te + Math.imul(re, ct) | 0, te = te + Math.imul(ce, et) | 0, ve = ve + Math.imul(ce, ct) | 0, Se = Se + Math.imul(X, ut) | 0, te = te + Math.imul(X, lt) | 0, te = te + Math.imul(P, ut) | 0, ve = ve + Math.imul(P, lt) | 0, Se = Se + Math.imul(x, tt) | 0, te = te + Math.imul(x, it) | 0, te = te + Math.imul(O, tt) | 0, ve = ve + Math.imul(O, it) | 0, Se = Se + Math.imul(M, st) | 0, te = te + Math.imul(M, gt) | 0, te = te + Math.imul($, st) | 0, ve = ve + Math.imul($, gt) | 0;
    let Pe = (Ke + Se | 0) + ((te & 8191) << 13) | 0;
    Ke = (ve + (te >>> 13) | 0) + (Pe >>> 26) | 0, Pe &= 67108863, Se = Math.imul(Ne, Je), te = Math.imul(Ne, Ye), te = te + Math.imul($e, Je) | 0, ve = Math.imul($e, Ye), Se = Se + Math.imul(ke, We) | 0, te = te + Math.imul(ke, Ze) | 0, te = te + Math.imul(Me, We) | 0, ve = ve + Math.imul(Me, Ze) | 0, Se = Se + Math.imul(Oe, Qe) | 0, te = te + Math.imul(Oe, rt) | 0, te = te + Math.imul(ye, Qe) | 0, ve = ve + Math.imul(ye, rt) | 0, Se = Se + Math.imul(ee, nt) | 0, te = te + Math.imul(ee, ft) | 0, te = te + Math.imul(me, nt) | 0, ve = ve + Math.imul(me, ft) | 0, Se = Se + Math.imul(pe, et) | 0, te = te + Math.imul(pe, ct) | 0, te = te + Math.imul(se, et) | 0, ve = ve + Math.imul(se, ct) | 0, Se = Se + Math.imul(re, ut) | 0, te = te + Math.imul(re, lt) | 0, te = te + Math.imul(ce, ut) | 0, ve = ve + Math.imul(ce, lt) | 0, Se = Se + Math.imul(X, tt) | 0, te = te + Math.imul(X, it) | 0, te = te + Math.imul(P, tt) | 0, ve = ve + Math.imul(P, it) | 0, Se = Se + Math.imul(x, st) | 0, te = te + Math.imul(x, gt) | 0, te = te + Math.imul(O, st) | 0, ve = ve + Math.imul(O, gt) | 0, Se = Se + Math.imul(M, ot) | 0, te = te + Math.imul(M, pt) | 0, te = te + Math.imul($, ot) | 0, ve = ve + Math.imul($, pt) | 0;
    let qe = (Ke + Se | 0) + ((te & 8191) << 13) | 0;
    Ke = (ve + (te >>> 13) | 0) + (qe >>> 26) | 0, qe &= 67108863, Se = Math.imul(Ve, Je), te = Math.imul(Ve, Ye), te = te + Math.imul(je, Je) | 0, ve = Math.imul(je, Ye), Se = Se + Math.imul(Ne, We) | 0, te = te + Math.imul(Ne, Ze) | 0, te = te + Math.imul($e, We) | 0, ve = ve + Math.imul($e, Ze) | 0, Se = Se + Math.imul(ke, Qe) | 0, te = te + Math.imul(ke, rt) | 0, te = te + Math.imul(Me, Qe) | 0, ve = ve + Math.imul(Me, rt) | 0, Se = Se + Math.imul(Oe, nt) | 0, te = te + Math.imul(Oe, ft) | 0, te = te + Math.imul(ye, nt) | 0, ve = ve + Math.imul(ye, ft) | 0, Se = Se + Math.imul(ee, et) | 0, te = te + Math.imul(ee, ct) | 0, te = te + Math.imul(me, et) | 0, ve = ve + Math.imul(me, ct) | 0, Se = Se + Math.imul(pe, ut) | 0, te = te + Math.imul(pe, lt) | 0, te = te + Math.imul(se, ut) | 0, ve = ve + Math.imul(se, lt) | 0, Se = Se + Math.imul(re, tt) | 0, te = te + Math.imul(re, it) | 0, te = te + Math.imul(ce, tt) | 0, ve = ve + Math.imul(ce, it) | 0, Se = Se + Math.imul(X, st) | 0, te = te + Math.imul(X, gt) | 0, te = te + Math.imul(P, st) | 0, ve = ve + Math.imul(P, gt) | 0, Se = Se + Math.imul(x, ot) | 0, te = te + Math.imul(x, pt) | 0, te = te + Math.imul(O, ot) | 0, ve = ve + Math.imul(O, pt) | 0, Se = Se + Math.imul(M, ht) | 0, te = te + Math.imul(M, at) | 0, te = te + Math.imul($, ht) | 0, ve = ve + Math.imul($, at) | 0;
    let Te = (Ke + Se | 0) + ((te & 8191) << 13) | 0;
    Ke = (ve + (te >>> 13) | 0) + (Te >>> 26) | 0, Te &= 67108863, Se = Math.imul(Ve, We), te = Math.imul(Ve, Ze), te = te + Math.imul(je, We) | 0, ve = Math.imul(je, Ze), Se = Se + Math.imul(Ne, Qe) | 0, te = te + Math.imul(Ne, rt) | 0, te = te + Math.imul($e, Qe) | 0, ve = ve + Math.imul($e, rt) | 0, Se = Se + Math.imul(ke, nt) | 0, te = te + Math.imul(ke, ft) | 0, te = te + Math.imul(Me, nt) | 0, ve = ve + Math.imul(Me, ft) | 0, Se = Se + Math.imul(Oe, et) | 0, te = te + Math.imul(Oe, ct) | 0, te = te + Math.imul(ye, et) | 0, ve = ve + Math.imul(ye, ct) | 0, Se = Se + Math.imul(ee, ut) | 0, te = te + Math.imul(ee, lt) | 0, te = te + Math.imul(me, ut) | 0, ve = ve + Math.imul(me, lt) | 0, Se = Se + Math.imul(pe, tt) | 0, te = te + Math.imul(pe, it) | 0, te = te + Math.imul(se, tt) | 0, ve = ve + Math.imul(se, it) | 0, Se = Se + Math.imul(re, st) | 0, te = te + Math.imul(re, gt) | 0, te = te + Math.imul(ce, st) | 0, ve = ve + Math.imul(ce, gt) | 0, Se = Se + Math.imul(X, ot) | 0, te = te + Math.imul(X, pt) | 0, te = te + Math.imul(P, ot) | 0, ve = ve + Math.imul(P, pt) | 0, Se = Se + Math.imul(x, ht) | 0, te = te + Math.imul(x, at) | 0, te = te + Math.imul(O, ht) | 0, ve = ve + Math.imul(O, at) | 0;
    let Ue = (Ke + Se | 0) + ((te & 8191) << 13) | 0;
    Ke = (ve + (te >>> 13) | 0) + (Ue >>> 26) | 0, Ue &= 67108863, Se = Math.imul(Ve, Qe), te = Math.imul(Ve, rt), te = te + Math.imul(je, Qe) | 0, ve = Math.imul(je, rt), Se = Se + Math.imul(Ne, nt) | 0, te = te + Math.imul(Ne, ft) | 0, te = te + Math.imul($e, nt) | 0, ve = ve + Math.imul($e, ft) | 0, Se = Se + Math.imul(ke, et) | 0, te = te + Math.imul(ke, ct) | 0, te = te + Math.imul(Me, et) | 0, ve = ve + Math.imul(Me, ct) | 0, Se = Se + Math.imul(Oe, ut) | 0, te = te + Math.imul(Oe, lt) | 0, te = te + Math.imul(ye, ut) | 0, ve = ve + Math.imul(ye, lt) | 0, Se = Se + Math.imul(ee, tt) | 0, te = te + Math.imul(ee, it) | 0, te = te + Math.imul(me, tt) | 0, ve = ve + Math.imul(me, it) | 0, Se = Se + Math.imul(pe, st) | 0, te = te + Math.imul(pe, gt) | 0, te = te + Math.imul(se, st) | 0, ve = ve + Math.imul(se, gt) | 0, Se = Se + Math.imul(re, ot) | 0, te = te + Math.imul(re, pt) | 0, te = te + Math.imul(ce, ot) | 0, ve = ve + Math.imul(ce, pt) | 0, Se = Se + Math.imul(X, ht) | 0, te = te + Math.imul(X, at) | 0, te = te + Math.imul(P, ht) | 0, ve = ve + Math.imul(P, at) | 0;
    let Fe = (Ke + Se | 0) + ((te & 8191) << 13) | 0;
    Ke = (ve + (te >>> 13) | 0) + (Fe >>> 26) | 0, Fe &= 67108863, Se = Math.imul(Ve, nt), te = Math.imul(Ve, ft), te = te + Math.imul(je, nt) | 0, ve = Math.imul(je, ft), Se = Se + Math.imul(Ne, et) | 0, te = te + Math.imul(Ne, ct) | 0, te = te + Math.imul($e, et) | 0, ve = ve + Math.imul($e, ct) | 0, Se = Se + Math.imul(ke, ut) | 0, te = te + Math.imul(ke, lt) | 0, te = te + Math.imul(Me, ut) | 0, ve = ve + Math.imul(Me, lt) | 0, Se = Se + Math.imul(Oe, tt) | 0, te = te + Math.imul(Oe, it) | 0, te = te + Math.imul(ye, tt) | 0, ve = ve + Math.imul(ye, it) | 0, Se = Se + Math.imul(ee, st) | 0, te = te + Math.imul(ee, gt) | 0, te = te + Math.imul(me, st) | 0, ve = ve + Math.imul(me, gt) | 0, Se = Se + Math.imul(pe, ot) | 0, te = te + Math.imul(pe, pt) | 0, te = te + Math.imul(se, ot) | 0, ve = ve + Math.imul(se, pt) | 0, Se = Se + Math.imul(re, ht) | 0, te = te + Math.imul(re, at) | 0, te = te + Math.imul(ce, ht) | 0, ve = ve + Math.imul(ce, at) | 0;
    let Le = (Ke + Se | 0) + ((te & 8191) << 13) | 0;
    Ke = (ve + (te >>> 13) | 0) + (Le >>> 26) | 0, Le &= 67108863, Se = Math.imul(Ve, et), te = Math.imul(Ve, ct), te = te + Math.imul(je, et) | 0, ve = Math.imul(je, ct), Se = Se + Math.imul(Ne, ut) | 0, te = te + Math.imul(Ne, lt) | 0, te = te + Math.imul($e, ut) | 0, ve = ve + Math.imul($e, lt) | 0, Se = Se + Math.imul(ke, tt) | 0, te = te + Math.imul(ke, it) | 0, te = te + Math.imul(Me, tt) | 0, ve = ve + Math.imul(Me, it) | 0, Se = Se + Math.imul(Oe, st) | 0, te = te + Math.imul(Oe, gt) | 0, te = te + Math.imul(ye, st) | 0, ve = ve + Math.imul(ye, gt) | 0, Se = Se + Math.imul(ee, ot) | 0, te = te + Math.imul(ee, pt) | 0, te = te + Math.imul(me, ot) | 0, ve = ve + Math.imul(me, pt) | 0, Se = Se + Math.imul(pe, ht) | 0, te = te + Math.imul(pe, at) | 0, te = te + Math.imul(se, ht) | 0, ve = ve + Math.imul(se, at) | 0;
    let Ge = (Ke + Se | 0) + ((te & 8191) << 13) | 0;
    Ke = (ve + (te >>> 13) | 0) + (Ge >>> 26) | 0, Ge &= 67108863, Se = Math.imul(Ve, ut), te = Math.imul(Ve, lt), te = te + Math.imul(je, ut) | 0, ve = Math.imul(je, lt), Se = Se + Math.imul(Ne, tt) | 0, te = te + Math.imul(Ne, it) | 0, te = te + Math.imul($e, tt) | 0, ve = ve + Math.imul($e, it) | 0, Se = Se + Math.imul(ke, st) | 0, te = te + Math.imul(ke, gt) | 0, te = te + Math.imul(Me, st) | 0, ve = ve + Math.imul(Me, gt) | 0, Se = Se + Math.imul(Oe, ot) | 0, te = te + Math.imul(Oe, pt) | 0, te = te + Math.imul(ye, ot) | 0, ve = ve + Math.imul(ye, pt) | 0, Se = Se + Math.imul(ee, ht) | 0, te = te + Math.imul(ee, at) | 0, te = te + Math.imul(me, ht) | 0, ve = ve + Math.imul(me, at) | 0;
    let mt = (Ke + Se | 0) + ((te & 8191) << 13) | 0;
    Ke = (ve + (te >>> 13) | 0) + (mt >>> 26) | 0, mt &= 67108863, Se = Math.imul(Ve, tt), te = Math.imul(Ve, it), te = te + Math.imul(je, tt) | 0, ve = Math.imul(je, it), Se = Se + Math.imul(Ne, st) | 0, te = te + Math.imul(Ne, gt) | 0, te = te + Math.imul($e, st) | 0, ve = ve + Math.imul($e, gt) | 0, Se = Se + Math.imul(ke, ot) | 0, te = te + Math.imul(ke, pt) | 0, te = te + Math.imul(Me, ot) | 0, ve = ve + Math.imul(Me, pt) | 0, Se = Se + Math.imul(Oe, ht) | 0, te = te + Math.imul(Oe, at) | 0, te = te + Math.imul(ye, ht) | 0, ve = ve + Math.imul(ye, at) | 0;
    let Et = (Ke + Se | 0) + ((te & 8191) << 13) | 0;
    Ke = (ve + (te >>> 13) | 0) + (Et >>> 26) | 0, Et &= 67108863, Se = Math.imul(Ve, st), te = Math.imul(Ve, gt), te = te + Math.imul(je, st) | 0, ve = Math.imul(je, gt), Se = Se + Math.imul(Ne, ot) | 0, te = te + Math.imul(Ne, pt) | 0, te = te + Math.imul($e, ot) | 0, ve = ve + Math.imul($e, pt) | 0, Se = Se + Math.imul(ke, ht) | 0, te = te + Math.imul(ke, at) | 0, te = te + Math.imul(Me, ht) | 0, ve = ve + Math.imul(Me, at) | 0;
    let It = (Ke + Se | 0) + ((te & 8191) << 13) | 0;
    Ke = (ve + (te >>> 13) | 0) + (It >>> 26) | 0, It &= 67108863, Se = Math.imul(Ve, ot), te = Math.imul(Ve, pt), te = te + Math.imul(je, ot) | 0, ve = Math.imul(je, pt), Se = Se + Math.imul(Ne, ht) | 0, te = te + Math.imul(Ne, at) | 0, te = te + Math.imul($e, ht) | 0, ve = ve + Math.imul($e, at) | 0;
    let kt = (Ke + Se | 0) + ((te & 8191) << 13) | 0;
    Ke = (ve + (te >>> 13) | 0) + (kt >>> 26) | 0, kt &= 67108863, Se = Math.imul(Ve, ht), te = Math.imul(Ve, at), te = te + Math.imul(je, ht) | 0, ve = Math.imul(je, at);
    let Rt = (Ke + Se | 0) + ((te & 8191) << 13) | 0;
    return Ke = (ve + (te >>> 13) | 0) + (Rt >>> 26) | 0, Rt &= 67108863, J[0] = Dt, J[1] = xe, J[2] = ie, J[3] = be, J[4] = Ie, J[5] = Re, J[6] = Be, J[7] = Pe, J[8] = qe, J[9] = Te, J[10] = Ue, J[11] = Fe, J[12] = Le, J[13] = Ge, J[14] = mt, J[15] = Et, J[16] = It, J[17] = kt, J[18] = Rt, Ke !== 0 && (J[19] = Ke, d.length += 1), d;
  }
  return Math.imul || (I = Ee), s.Red = G, ru = s, ru;
}
var F4;
function o1() {
  return F4 || (F4 = 1, function(e) {
    const c = Xr(), l = e;
    function w(o) {
      return k.from(o, "hex");
    }
    l.types = ["main", "testnet", "regtest", "simnet"];
    const m = {};
    m.type = "main", m.seeds = [
      "seed.flowee.cash",
      "seed-bch.bitcoinforks.org",
      "btccash-seeder.bitcoinunlimited.info",
      "seed.bchd.cash",
      "seed.bch.loping.net",
      "dnsseed.electroncash.de"
    ], m.magic = 3908297187, m.port = 8333, m.checkpointMap = {
      11111: w("1d7c6eb2fd42f55925e92efad68b61edd22fba29fde8783df744e26900000000"),
      33333: w("a6d0b5df7d0df069ceb1e736a216ad187a50b07aaa4e78748a58d52d00000000"),
      74e3: w("201a66b853f9e7814a820e2af5f5dc79c07144e31ce4c9a39339570000000000"),
      105e3: w("97dc6b1d15fbeef373a744fee0b254b0d2c820a3ae7f0228ce91020000000000"),
      134444: w("feb0d2420d4a18914c81ac30f494a5d4ff34cd15d34cfd2fb105000000000000"),
      168e3: w("63b703835cb735cb9a89d733cbe66f212f63795e0172ea619e09000000000000"),
      193e3: w("17138bca83bdc3e6f60f01177c3877a98266de40735f2a459f05000000000000"),
      21e4: w("2e3471a19b8e22b7f939c63663076603cf692f19837e34958b04000000000000"),
      216116: w("4edf231bf170234e6a811460f95c94af9464e41ee833b4f4b401000000000000"),
      225430: w("32595730b165f097e7b806a679cf7f3e439040f750433808c101000000000000"),
      25e4: w("14d2f24d29bed75354f3f88a5fb50022fc064b02291fdf873800000000000000"),
      279e3: w("407ebde958e44190fa9e810ea1fc3a7ef601c3b0a0728cae0100000000000000"),
      295e3: w("83a93246c67003105af33ae0b29dd66f689d0f0ff54e9b4d0000000000000000"),
      300255: w("b2f3a0f0de4120c1089d5f5280a263059f9b6e7c520428160000000000000000"),
      319400: w("3bf115fd057391587ca39a531c5d4989e1adec9b2e05c6210000000000000000"),
      343185: w("548536d48e7678fcfa034202dd45d4a76b1ad061f38b2b070000000000000000"),
      352940: w("ffc9520143e41c94b6e03c2fa3e62bb76b55ba2df45d75100000000000000000"),
      382320: w("b28afdde92b0899715e40362f56afdb20e3d135bedc68d0a0000000000000000"),
      401465: w("eed16cb3e893ed9366f27c39a9ecd95465d02e3ef40e45010000000000000000"),
      42e4: w("a1ff746b2d42b834cb7d6b8981b09c265c2cabc016e8cc020000000000000000"),
      44e4: w("9bf296b8de5f834f7635d5e258a434ad51b4dbbcf7c08c030000000000000000"),
      45e4: w("0ba2070c62cd9da1f8cef88a0648c661a411d33e728340010000000000000000"),
      46e4: w("8c25fc7e414d3e868d6ce0ec473c30ad44e7e8bc1b75ef000000000000000000"),
      47e4: w("89756d1ed75901437300af10d5ab69070a282e729c536c000000000000000000"),
      // UAHF fork block:
      478559: w("ec5e1a193601f25ff1d94b421ddead0dbefcb99cf91e65000000000000000000"),
      48e4: w("f93408ffca92d88a6e46d3b90046f97bde6be0c08e7ed40c0000000000000000"),
      49e4: w("d1c65d766c6dc270b8ff4f1edb052fb71dc2b4750ede8a010000000000000000"),
      5e5: w("01b2328355f4a4dc9efa5c610687304507b7df9f3f4de1050000000000000000"),
      // DAA fork block
      504031: w("9cabb6ee1b1a4c3b659d70be75810be83d0a0db665bf1e010000000000000000"),
      51e4: w("040e6b1f2f4cb198a5780d366bf81e591de257642b9267030000000000000000"),
      525e3: w("c994fba2bf168333fd969bcfa64f03ca1b62074f9a8f1b010000000000000000"),
      // Monolith Activation
      530359: w("0391c40195cf8ae3436f3955f1a8444f07468fd08bda1a010000000000000000"),
      // Magnetic Anomaly Activation:
      556767: w("6cd5e644acccee5743ce2e93c541d34169933b6eff2646000000000000000000"),
      // Great Wall Activation:
      582680: w("18cc7d8c39ca16dc749acb7278a471964f7dec6ae3b8b4010000000000000000"),
      // Graviton Activation:
      609136: w("b1c55b4f69aa2e3209c91ae413c355c65aacfa07b28bb4000000000000000000"),
      // Phonon Activation:
      635259: w("f73075b2c598f49b3a19558c070b52d5a5d6c21fefdf33000000000000000000"),
      // Axion Activation:
      661648: w("7d7510f907bdc9bd2907e56beceaef31f78f2c8b9d4c28040000000000000000"),
      664198: w("60824622a1d2b689fbb234ce2c5939ff92e8ed8c57902f0c0000000000000000"),
      680140: w("0b7c2ff6c3658cb3f846aa092145c44a1d45638b56482c230000000000000000"),
      // Tachyon Activation
      686621: w("45b7e5be980bd6e98a22f895fcdc80546d9f0a57f7e68f3c0000000000000000"),
      // Selectron Activation
      713661: w("8defaaea383ab73c75ceea3f08190f3ab5ccc70743f876060000000000000000"),
      // Gluon activation
      739536: w("617bfc596bce59b129242fe67b5afe0509560946cd04db060000000000000000"),
      // Jefferson activation
      766195: w("94e0246db72955957dedb431eb1096de9a5b715348c92b100000000000000000")
    }, m.lastCheckpoint = 525e3, m.halvingInterval = 21e4, m.genesis = {
      version: 1,
      hash: w("6fe28c0ab6f1b372c1a6a246ae63f74f931e8365e15a089c68d6190000000000"),
      prevBlock: w("0000000000000000000000000000000000000000000000000000000000000000"),
      merkleRoot: w("3ba3edfd7a7b12b27ac72c3e67768f617fc81bc3888a51323a9fb8aa4b1e5e4a"),
      time: 1231006505,
      bits: 486604799,
      nonce: 2083236893,
      height: 0
    }, m.genesisBlock = "0100000000000000000000000000000000000000000000000000000000000000000000003ba3edfd7a7b12b27ac72c3e67768f617fc81bc3888a51323a9fb8aa4b1e5e4a29ab5f49ffff001d1dac2b7c0101000000010000000000000000000000000000000000000000000000000000000000000000ffffffff4d04ffff001d0104455468652054696d65732030332f4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66207365636f6e64206261696c6f757420666f722062616e6b73ffffffff0100f2052a01000000434104678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5fac00000000", m.pow = {
      /**
       * Default target.
       * @const {BN}
       */
      limit: new c(
        "00000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
        "hex"
      ),
      /**
       * Compact pow limit.
       * @const {Number}
       * @default
       */
      bits: 486604799,
      /**
       * Half Life value used in DAA.
       * Represents the value of two days in seconds
       * @const {Number}
       * @default
       */
      halfLife: 172800,
      /**
       * Minimum chainwork for best chain.
       * @const {BN}
       */
      chainwork: new c(
        "0000000000000000000000000000000000000000013c95e14d4d9db91d671020",
        "hex"
      ),
      /**
       * Desired retarget period in seconds.
       * @const {Number}
       * @default
       */
      targetTimespan: 336 * 60 * 60,
      /**
       * Average block time.
       * @const {Number}
       * @default
       */
      targetSpacing: 600,
      /**
       * Retarget interval in blocks.
       * @const {Number}
       * @default
       */
      retargetInterval: 2016,
      /**
       * Whether to reset target if a block
       * has not been mined recently.
       * @const {Boolean}
       * @default
       */
      targetReset: !1,
      /**
       * Do not allow retargetting.
       * @const {Boolean}
       * @default
       */
      noRetargeting: !1
    }, m.block = {
      /**
       * Height at which bip34 was activated.
       * Used for avoiding bip30 checks.
       */
      bip34height: 227931,
      /**
       * Hash of the block that activated bip34.
       */
      bip34hash: w("b808089c756add1591b1d17bab44bba3fed9e02f942ab4894b02000000000000"),
      /**
       * Height at which bip65 was activated.
       */
      bip65height: 388381,
      /**
       * Hash of the block that activated bip65.
       */
      bip65hash: w("f035476cfaeb9f677c2cdad00fd908c556775ded24b6c2040000000000000000"),
      /**
       * Height at which bip66 was activated.
       */
      bip66height: 363725,
      /**
       * Hash of the block that activated bip66.
       */
      bip66hash: w("3109b588941188a9f1c2576aae462d729b8cce9da1ea79030000000000000000"),
      /**
       * Height at which UAHF was activated.
       */
      uahfHeight: 478558,
      /**
       * Hash of the block that activated UAHF.
       */
      uahfHash: w("432d350741fbf28f2e1486eabe2c4e143bfe2241af6518010000000000000000"),
      /**
       * Height at which DAA was activated.
       * November 13, 2017 hard fork
       */
      daaHeight: 504031,
      /**
       * Hash of the block that activated DAA
       */
      daaHash: w("9cabb6ee1b1a4c3b659d70be75810be83d0a0db665bf1e010000000000000000"),
      /**
       * Height at which Magnetic Anomaly was activated.
       * Nov 15, 2018 hard fork
       */
      magneticAnomalyHeight: 556767,
      /**
       * Hash of the block that activatd Magnetic Anomaly.
       * November 15, 2018
       */
      maaHash: w("6cd5e644acccee5743ce2e93c541d34169933b6eff2646000000000000000000"),
      /**
       * Height at which Great Wall was activated.
       * Wed, 15 May 2019 hard fork
       */
      greatWallActivationHeight: 582680,
      /**
       * Hash of the block that activated Great Wall.
       * May 15, 2019
       */
      gwaHash: w("18cc7d8c39ca16dc749acb7278a471964f7dec6ae3b8b4010000000000000000"),
      /**
       * Graviton Hard Fork activation time.
       * Nov 15, 2019 12:00:00 UTC
       */
      gravitonActivationTime: 1573819200,
      /**
       * Height at which Graviton was activated.
       * Friday, 15 November 2019 hard fork
       */
      gravitonHeight: 609136,
      /**
       * Hash of the block that activated Graviton.
       * November 15th, 2019
       */
      gravitonHash: w("b1c55b4f69aa2e3209c91ae413c355c65aacfa07b28bb4000000000000000000"),
      /**
       * Time at which Phonon was activated.
       * May 15, 2020 12:00:00 UTC
       */
      phononActivationTime: 1589544e3,
      /**
      * Height at which Phonon Activation occured.
      * May 15, 2020
      */
      phononHeight: 635259,
      /**
      * Hash of the block that activated Phonon.
      * May 15th 2020
      */
      phononHash: w("f73075b2c598f49b3a19558c070b52d5a5d6c21fefdf33000000000000000000"),
      /**
       * Time at which Asert3d-2i was activated.
       * November 15, 2020 12:00:00 UTC
       */
      asertActivationTime: 1605441600,
      /**
       * Time at which Axion was activated.
       * November 15, 2020 12:00:00 UTC
       */
      axionActivationTime: 1605441600,
      /**
      * Height at which Axion Activation occured.
      * November 15, 2020
      */
      axionHeight: 661648,
      /**
      * Hash of the block that activated Axion.
      * November 15th 2020
      */
      axionHash: w("7d7510f907bdc9bd2907e56beceaef31f78f2c8b9d4c28040000000000000000"),
      /**
       * Time at which Tachyon was activated.
       * May 15, 2021 12:00:00 UTC
       */
      tachyonActivationTime: 162108e4,
      /**
      * Height at which Tachyon Activation occured.
      * May 15, 2021 12:00:00 UTC
      */
      tachyonHeight: 686621,
      /**
      * Hash of the block that activated Tachyon.
      * May 15, 2021 12:00:00 UTC
      */
      tachyonHash: w("45b7e5be980bd6e98a22f895fcdc80546d9f0a57f7e68f3c0000000000000000"),
      /**
       * Time at which Selectron was activated.
       * November 15, 2021 12:00:00 UTC
       */
      selectronActivationTime: 1636977600,
      /**
      * Height at which Selectron Activation occured.
      *  November 15, 2021 12:00:00 UTC
      */
      selectronHeight: 713661,
      /**
      * Hash of the block that activated Selectron.
      * November 15, 2021 12:00:00 UTC
      */
      selectronHash: w("8defaaea383ab73c75ceea3f08190f3ab5ccc70743f876060000000000000000"),
      /**
       * Time at which Gluon was activated.
       * May 15, 2022 12:00:00 UTC
       */
      gluonActivationTime: 1652572800,
      /**
      * Height at which Gluon activation occured.
      *  May 15, 2022 12:00:00 UTC
      */
      gluonHeight: 739536,
      /**
      * Hash of the block that activated Gluon.
      * May 15, 2022 12:00:00 UTC
      */
      gluonHash: w("617bfc596bce59b129242fe67b5afe0509560946cd04db060000000000000000"),
      /**
       * Time at which Jefferson was activated.
       * November 15, 2022 12:00:00 UTC
       */
      jeffersonActivationTime: 1668470400,
      /**
      * Height at which Gluon activation occured.
      *  November 15, 2022 12:00:00 UTC
      */
      jeffersonHeight: 766195,
      /**
      * Hash of the block that activated Gluon.
      * November 15, 2022 12:00:00 UTC
      */
      jeffersonHash: w("94e0246db72955957dedb431eb1096de9a5b715348c92b100000000000000000"),
      /**
       * Time at which Wellington was activated.
       * May 15, 2023 12:00:00 UTC
       */
      wellingtonActivationTime: 1684108800,
      /**
       * Safe height to start pruning.
       */
      pruneAfterHeight: 1e3,
      /**
       * Safe number of blocks to keep.
       */
      keepBlocks: 288,
      /**
       * Age used for the time delta to
       * determine whether the chain is synced.
       */
      maxTipAge: 1440 * 60,
      /**
       * Height at which block processing is
       * slow enough that we can output
       * logs without spamming.
       */
      slowHeight: 325e3
    }, m.bip30 = {
      91842: w("eccae000e3c8e4e093936360431f3b7603c563c1ff6181390a4d0a0000000000"),
      91880: w("21d77ccb4c08386a04ac0196ae10f6a1d2c2a377558ca190f143070000000000")
    }, m.activationThreshold = 1916, m.minerWindow = 2016, m.deployments = {
      csv: {
        name: "csv",
        bit: 0,
        startTime: 1462060800,
        // May 1st, 2016
        timeout: 1493596800,
        // May 1st, 2017
        threshold: -1,
        window: -1,
        required: !1,
        force: !0
      },
      testdummy: {
        name: "testdummy",
        bit: 28,
        startTime: 1199145601,
        // January 1, 2008
        timeout: 1230767999,
        // December 31, 2008
        threshold: -1,
        window: -1,
        required: !1,
        force: !0
      }
    }, m.deploys = [
      m.deployments.csv,
      m.deployments.testdummy
    ], m.keyPrefix = {
      privkey: 128,
      xpubkey: 76067358,
      xprivkey: 76066276,
      xpubkey58: "xpub",
      xprivkey58: "xprv",
      coinType: 0
    }, m.addressPrefix = {
      pubkeyhash: 0,
      scripthash: 5,
      cashaddr: "ecash"
    }, m.requireStandard = !0, m.rpcPort = 8332, m.walletPort = 8334, m.minRelay = 1e3, m.feeRate = 1e5, m.maxFeeRate = 4e5, m.selfConnect = !1, m.requestMempool = !1;
    const f = {};
    f.type = "testnet", f.seeds = [
      "testnet-seed.bitcoinabc.org",
      // Bitcoin ABC seeder
      "testnet-seed-abc.bitcoinforks.org",
      // bitcoinforks seeders
      "testnet-seed.deadalnix.me",
      // Amaury SÉCHET
      "testnet-seed.bchd.cash"
    ], f.magic = 4109624820, f.port = 18333, f.checkpointMap = {
      546: w("70cb6af7ebbcb1315d3414029c556c55f3e2fc353c4c9063a76c932a00000000"),
      1e4: w("02a1b43f52591e53b660069173ac83b675798e12599dbb0442b7580000000000"),
      5e4: w("0c6ceabe803cec55ba2831e445956d0a43ba9521743a802cddac7e0700000000"),
      9e4: w("cafc21e17faf90461a5905aa03302c394912651ed9475ae711723e0d00000000"),
      1e5: w("1e0a16bbadccde1d80c66597b1939e45f91b570d29f95fc158299e0000000000"),
      14e4: w("92c0877b54c556889b72175ccbe0c91a1208f6ef7efb2c006101062300000000"),
      17e4: w("508125560d202b89757889bb0e49c712477be20440058f05db4f0e0000000000"),
      21e4: w("32365454b5f29a826bff8ad9b0448cad0072fc73d50e482d91a3dece00000000"),
      23e4: w("b11a447e62643e0b27406eb0fc270cb8126d7b5b70822fb642d9513400000000"),
      27e4: w("1c42b811cf9c163932f6e95ec55bf9b5e2cb5324e7e93001572e000000000000"),
      3e5: w("a141bf3972424853f04367b47995e220e0b5a2706e5618766f22000000000000"),
      34e4: w("67edd4d92e405608109164b15f92b193377d49325b0ed036739c010000000000"),
      35e4: w("592b44bc0f7a4286cf07ead8497114c6952c1c7dea7305193deacf8e00000000"),
      39e4: w("f217e183484fb6d695609cc71fa2ae24c3020943407e0150b298030000000000"),
      42e4: w("de9e73a3b91fbb014e036e8583a17d6b638a699aeb2de8573d12580800000000"),
      46e4: w("2e8baaffc107f15c87aebe01664b63d07476afa53bcbada1281a030000000000"),
      5e5: w("06f60922a2aab2757317820fc6ffaf6a470e2cbb0f63a2aac0a7010000000000"),
      54e4: w("8dd0bebfbc4878f5af09d3e848dcc57827d2c1cebea8ec5d8cbe420500000000"),
      57e4: w("87acbd4cd3c40ec9bd648f8698ed226b31187274c06cc7a9af79030000000000"),
      6e5: w("169a05b3bb04b7d13ad628915630900a5ed2e89f3a9dc6064f62000000000000"),
      63e4: w("bbbe117035432a6a4effcb297207a02b031735b43e0d19a9217c000000000000"),
      67e4: w("080bfe75caed8624fcfdfbc65973c8f962d7bdc495a891f5d16b7d0000000000"),
      7e5: w("c14d3f6a1e7c7d66fd940951e44f3c3be1273bea4d2ab1786140000000000000"),
      74e4: w("b3b423f0462fd78a01e4f1a59a2737a0525b5dbb9bba0b4634f9000000000000"),
      78e4: w("0381582e34c3755964dc2813e2b33e521e5596367144e1670851050000000000"),
      8e5: w("03b5f8ab257e02903f509f5ff2935220eec2e77b1819651d099b200000000000"),
      84e4: w("dac1648107bd4394e57e4083c86d42b548b1cfb119665f179ea80a0000000000"),
      88e4: w("ff90b4bb07eded8e96715bf595c09c7d21dd8c61b8306ff48705d60000000000"),
      9e5: w("9bd8ac418beeb1a2cf5d68c8b5c6ebaa947a5b766e5524898d6f350000000000"),
      94e4: w("c98f1651a475b00d12f8c25eb166ee843affaa90610e36a19d68030000000000"),
      98e4: w("cc8e9774542d044a9698ca2336ae02d5987157e676f1c76aa3877c0000000000"),
      101e4: w("9d9fb11abc2712d80368229e97b8d827b2a07d27eb5335e5c924000000000000"),
      105e4: w("d8190cf0af7f08e179cab51d67db0b44b87951a78f7fdc31b4a01a0000000000"),
      109e4: w("41f83c47e02a8852d033ac884df7cca877726b384a461fb9e802000000000000"),
      113e4: w("b8d63c3830e3c5685d3f7d2c2271fdb2ce3315619a473c324ea1a4ce00000000"),
      // UAHF fork block.
      1155875: w("38f1ae7f0ea8c1b589884c5fbd0b83721e3ab6759a4b897206857cf100000000"),
      // DAA fork block.
      1188697: w("fb47e0ab0d2448f71192a09fe61bc9c46cd3b4e7bd778091d00e170000000000"),
      // GWA fork block.
      1303885: w("d323ee8d7ede5bef62f84db98f93cc8c47fae4f02e8938914700000000000000"),
      // Graviton fork block
      1341712: w("5ba3af2992073940ed9e5a9d9eef9194bbfba905d92b202eea44fcff00000000"),
      // Phonon fork block.
      1378461: w("d715e9fab7bbdf301081eeadbe6e931db282cf6b92b1365f9b50f59900000000")
    }, f.lastCheckpoint = 1341712, f.halvingInterval = 21e4, f.genesis = {
      version: 1,
      hash: w("43497fd7f826957108f4a30fd9cec3aeba79972084e90ead01ea330900000000"),
      prevBlock: w("0000000000000000000000000000000000000000000000000000000000000000"),
      merkleRoot: w("3ba3edfd7a7b12b27ac72c3e67768f617fc81bc3888a51323a9fb8aa4b1e5e4a"),
      time: 1296688602,
      bits: 486604799,
      nonce: 414098458,
      height: 0
    }, f.genesisBlock = "0100000000000000000000000000000000000000000000000000000000000000000000003ba3edfd7a7b12b27ac72c3e67768f617fc81bc3888a51323a9fb8aa4b1e5e4adae5494dffff001d1aa4ae180101000000010000000000000000000000000000000000000000000000000000000000000000ffffffff4d04ffff001d0104455468652054696d65732030332f4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66207365636f6e64206261696c6f757420666f722062616e6b73ffffffff0100f2052a01000000434104678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5fac00000000", f.pow = {
      limit: new c(
        "00000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
        "hex"
      ),
      bits: 486604799,
      chainwork: new c(
        "00000000000000000000000000000000000000000000006956e7298fb096a1cc",
        "hex"
      ),
      halfLife: 172800,
      targetTimespan: 336 * 60 * 60,
      targetSpacing: 600,
      retargetInterval: 2016,
      targetReset: !0,
      noRetargeting: !1
    }, f.block = {
      bip34height: 21111,
      bip34hash: w("f88ecd9912d00d3f5c2a8e0f50417d3e415c75b3abe584346da9b32300000000"),
      bip65height: 581885,
      bip65hash: w("b61e864fbec41dfaf09da05d1d76dc068b0dd82ee7982ff255667f0000000000"),
      bip66height: 330776,
      bip66hash: w("82a14b9e5ea81d4832b8e2cd3c2a6092b5a3853285a8995ec4c8042100000000"),
      uahfHeight: 1155875,
      uahfHash: w("38f1ae7f0ea8c1b589884c5fbd0b83721e3ab6759a4b897206857cf100000000"),
      daaHeight: 1188697,
      daaHash: w("fb47e0ab0d2448f71192a09fe61bc9c46cd3b4e7bd778091d00e170000000000"),
      magneticAnomalyHeight: 1267996,
      maaHash: w("244b485f4871816d3ca060f6f363abe81c6fa1bed45c09e0fa01000000000000"),
      greatWallActivationHeight: 1303885,
      gwaHash: w("d323ee8d7ede5bef62f84db98f93cc8c47fae4f02e8938914700000000000000"),
      gravitonActivationTime: 1573819200,
      gravitonHeight: 1341712,
      gravitonHash: w("5ba3af2992073940ed9e5a9d9eef9194bbfba905d92b202eea44fcff00000000"),
      phononActivationTime: 1589544e3,
      asertActivationTime: 1605441600,
      pruneAfterHeight: 1e3,
      keepBlocks: 1e4,
      maxTipAge: 1440 * 60,
      slowHeight: 95e4
    }, f.bip30 = {}, f.activationThreshold = 1512, f.minerWindow = 2016, f.deployments = {
      csv: {
        name: "csv",
        bit: 0,
        startTime: 1456790400,
        // March 1st, 2016
        timeout: 1493596800,
        // May 1st, 2017
        threshold: -1,
        window: -1,
        required: !1,
        force: !0
      },
      testdummy: {
        name: "testdummy",
        bit: 28,
        startTime: 1199145601,
        // January 1, 2008
        timeout: 1230767999,
        // December 31, 2008
        threshold: -1,
        window: -1,
        required: !1,
        force: !0
      }
    }, f.deploys = [
      f.deployments.csv,
      f.deployments.testdummy
    ], f.keyPrefix = {
      privkey: 239,
      xpubkey: 70617039,
      xprivkey: 70615956,
      xpubkey58: "tpub",
      xprivkey58: "tprv",
      coinType: 1
    }, f.addressPrefix = {
      pubkeyhash: 111,
      scripthash: 196,
      cashaddr: "xectest"
    }, f.requireStandard = !1, f.rpcPort = 18332, f.walletPort = 18334, f.minRelay = 1e3, f.feeRate = 2e4, f.maxFeeRate = 6e4, f.selfConnect = !1, f.requestMempool = !1;
    const n = {};
    n.type = "regtest", n.seeds = [
      "127.0.0.1"
    ], n.magic = 4206867930, n.port = 48444, n.checkpointMap = {}, n.lastCheckpoint = 0, n.halvingInterval = 150, n.genesis = {
      version: 1,
      hash: w("06226e46111a0b59caaf126043eb5bbf28c34f3a5e332a1fc7b2b73cf188910f"),
      prevBlock: w("0000000000000000000000000000000000000000000000000000000000000000"),
      merkleRoot: w("3ba3edfd7a7b12b27ac72c3e67768f617fc81bc3888a51323a9fb8aa4b1e5e4a"),
      time: 1296688602,
      bits: 545259519,
      nonce: 2,
      height: 0
    }, n.genesisBlock = "0100000000000000000000000000000000000000000000000000000000000000000000003ba3edfd7a7b12b27ac72c3e67768f617fc81bc3888a51323a9fb8aa4b1e5e4adae5494dffff7f20020000000101000000010000000000000000000000000000000000000000000000000000000000000000ffffffff4d04ffff001d0104455468652054696d65732030332f4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66207365636f6e64206261696c6f757420666f722062616e6b73ffffffff0100f2052a01000000434104678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5fac00000000", n.pow = {
      limit: new c(
        "7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
        "hex"
      ),
      bits: 545259519,
      chainwork: new c(
        "0000000000000000000000000000000000000000000000000000000000000002",
        "hex"
      ),
      halfLife: 172800,
      targetTimespan: 336 * 60 * 60,
      targetSpacing: 600,
      retargetInterval: 2016,
      targetReset: !0,
      noRetargeting: !0
    }, n.block = {
      bip34height: 1e8,
      bip34hash: null,
      bip65height: 1351,
      bip65hash: null,
      bip66height: 1251,
      bip66hash: null,
      uahfHeight: 0,
      uahfHash: null,
      daaHeight: 0,
      daaHash: null,
      magneticAnomalyHeight: 0,
      maaHash: null,
      greatWallActivationHeight: 0,
      gwaHash: null,
      gravitonHeight: 0,
      gravitonHash: null,
      phononActivationTime: 0,
      asertActivationTime: 0,
      pruneAfterHeight: 1e3,
      keepBlocks: 1e4,
      maxTipAge: 4294967295,
      slowHeight: 0
    }, n.bip30 = {}, n.activationThreshold = 108, n.minerWindow = 144, n.deployments = {
      csv: {
        name: "csv",
        bit: 0,
        startTime: 0,
        timeout: 4294967295,
        threshold: -1,
        window: -1,
        required: !1,
        force: !0
      },
      testdummy: {
        name: "testdummy",
        bit: 28,
        startTime: 0,
        timeout: 4294967295,
        threshold: -1,
        window: -1,
        required: !1,
        force: !0
      }
    }, n.deploys = [
      n.deployments.csv,
      n.deployments.testdummy
    ], n.keyPrefix = {
      privkey: 90,
      xpubkey: 3937729029,
      xprivkey: 3937666247,
      xpubkey58: "rpub",
      xprivkey58: "rprv",
      coinType: 1
    }, n.addressPrefix = {
      pubkeyhash: 60,
      scripthash: 38,
      cashaddr: "xecreg"
    }, n.requireStandard = !1, n.rpcPort = 48332, n.walletPort = 48334, n.minRelay = 1e3, n.feeRate = 2e4, n.maxFeeRate = 6e4, n.selfConnect = !0, n.requestMempool = !0;
    const u = {};
    u.type = "simnet", u.seeds = [
      "127.0.0.1"
    ], u.magic = 4076531172, u.port = 18555, u.checkpointMap = {}, u.lastCheckpoint = 0, u.halvingInterval = 21e4, u.genesis = {
      version: 1,
      hash: w("f67ad7695d9b662a72ff3d8edbbb2de0bfa67b13974bb9910d116d5cbd863e68"),
      prevBlock: w("0000000000000000000000000000000000000000000000000000000000000000"),
      merkleRoot: w("3ba3edfd7a7b12b27ac72c3e67768f617fc81bc3888a51323a9fb8aa4b1e5e4a"),
      time: 1401292357,
      bits: 545259519,
      nonce: 2,
      height: 0
    }, u.genesisBlock = "0100000000000000000000000000000000000000000000000000000000000000000000003ba3edfd7a7b12b27ac72c3e67768f617fc81bc3888a51323a9fb8aa4b1e5e4a45068653ffff7f20020000000101000000010000000000000000000000000000000000000000000000000000000000000000ffffffff4d04ffff001d0104455468652054696d65732030332f4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66207365636f6e64206261696c6f757420666f722062616e6b73ffffffff0100f2052a01000000434104678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5fac00000000", u.pow = {
      limit: new c(
        // High target of 0x207fffff (545259519)
        "7fffff0000000000000000000000000000000000000000000000000000000000",
        "hex"
      ),
      bits: 545259519,
      chainwork: new c(
        "0000000000000000000000000000000000000000000000000000000000000002",
        "hex"
      ),
      halfLife: 172800,
      targetTimespan: 336 * 60 * 60,
      targetSpacing: 600,
      retargetInterval: 2016,
      targetReset: !0,
      noRetargeting: !1
    }, u.block = {
      bip34height: 0,
      bip34hash: w("f67ad7695d9b662a72ff3d8edbbb2de0bfa67b13974bb9910d116d5cbd863e68"),
      bip65height: 0,
      bip65hash: w("f67ad7695d9b662a72ff3d8edbbb2de0bfa67b13974bb9910d116d5cbd863e68"),
      bip66height: 0,
      bip66hash: w("f67ad7695d9b662a72ff3d8edbbb2de0bfa67b13974bb9910d116d5cbd863e68"),
      uahfHeight: 0,
      uahfHash: null,
      daaHeight: 0,
      daaHash: null,
      magneticAnomalyActivationTime: 15423e5,
      greatWallActivationTime: 1557921600,
      pruneAfterHeight: 1e3,
      keepBlocks: 1e4,
      maxTipAge: 4294967295,
      slowHeight: 0
    }, u.bip30 = {}, u.activationThreshold = 75, u.minerWindow = 100, u.deployments = {
      csv: {
        name: "csv",
        bit: 0,
        startTime: 0,
        // March 1st, 2016
        timeout: 4294967295,
        // May 1st, 2017
        threshold: -1,
        window: -1,
        required: !1,
        force: !0
      },
      testdummy: {
        name: "testdummy",
        bit: 28,
        startTime: 1199145601,
        // January 1, 2008
        timeout: 1230767999,
        // December 31, 2008
        threshold: -1,
        window: -1,
        required: !1,
        force: !0
      }
    }, u.deploys = [
      u.deployments.csv,
      u.deployments.testdummy
    ], u.keyPrefix = {
      privkey: 100,
      xpubkey: 69254458,
      xprivkey: 69253376,
      xpubkey58: "spub",
      xprivkey58: "sprv",
      coinType: 115
    }, u.addressPrefix = {
      pubkeyhash: 63,
      scripthash: 123,
      cashaddr: "xecsim"
    }, u.requireStandard = !1, u.rpcPort = 18556, u.walletPort = 18558, u.minRelay = 1e3, u.feeRate = 2e4, u.maxFeeRate = 6e4, u.selfConnect = !1, u.requestMempool = !1, l.main = m, l.testnet = f, l.regtest = n, l.simnet = u;
  }(Gc)), Gc;
}
var iu = {}, H4;
function Lt() {
  return H4 || (H4 = 1, function(e) {
    const c = Xe(), l = Xr();
    e.COIN = 1e8, e.MAX_MONEY = 21e6 * e.COIN, e.BASE_REWARD = 50 * e.COIN, e.HALF_REWARD = Math.floor(e.BASE_REWARD / 2), e.MAX_BLOCK_SIZE = 1e6, e.MAX_FORK_BLOCK_SIZE = 32e6, e.MAX_TX_VERSION = 2, e.MAX_TX_SIZE = 1e6, e.MAX_TX_SIGCHECKS = 3e3, e.MAX_BLOCK_SIGCHECKS_RATIO = 141, e.MIN_TX_SIZE = 100, e.MAX_RAW_BLOCK_SIZE = 32e6, e.MAX_BLOCK_SIGOPS_PER_MB = 2e4, e.MAX_TX_SIGOPS = 2e4, e.MAX_BLOCK_SIGOPS_COST = 8e4, e.MAX_COINBASE_SCRIPTSIG_SIZE = 100, e.COINBASE_RULE_ADDR = [
      "ecash:pqnqv9lt7e5vjyp0w88zf2af0l92l8rxdg2jj94l5j",
      "ecash:prfhcnyqnl5cgrnmlfmms675w93ld7mvvqd0y8lz07"
    ], e.MEDIAN_TIMESPAN = 11, e.VERSION_TOP_BITS = 536870912, e.VERSION_TOP_MASK = 3758096384, e.COINBASE_MATURITY = 100, e.LOCKTIME_THRESHOLD = 5e8, e.SEQUENCE_DISABLE_FLAG = 1 << 31 >>> 0, e.SEQUENCE_TYPE_FLAG = 1 << 22, e.SEQUENCE_GRANULARITY = 9, e.SEQUENCE_MASK = 65535, e.MAX_SCRIPT_SIZE = 1e4, e.MAX_SCRIPT_STACK = 1e3, e.MAX_SCRIPT_PUSH = 520, e.MAX_SCRIPT_OPS = 201, e.MAX_MULTISIG_PUBKEYS = 20, e.BIP16_TIME = 1333238400, e.ZERO_HASH = k.alloc(32, 0), e.NULL_HASH = "0000000000000000000000000000000000000000000000000000000000000000", e.ANTI_REPLAY_COMMITMENT = "Bitcoin: A Peer-to-Peer Electronic Cash System", e.fromCompact = function(m) {
      if (m === 0)
        return new l(0);
      const f = m >>> 24, n = m >>> 23 & 1;
      let u = m & 8388607, o;
      return f <= 3 ? (u >>>= 8 * (3 - f), o = new l(u)) : (o = new l(u), o.iushln(8 * (f - 3))), n && o.ineg(), o;
    }, e.toCompact = function(m) {
      if (m.isZero())
        return 0;
      let f = m.byteLength(), n;
      f <= 3 ? (n = m.toNumber(), n <<= 8 * (3 - f)) : n = m.ushrn(8 * (f - 3)).toNumber(), n & 8388608 && (n >>= 8, f++);
      let u = f << 24 | n;
      return m.isNeg() && (u |= 8388608), u >>>= 0, u;
    }, e.verifyPOW = function(m, f) {
      const n = e.fromCompact(f);
      return !(n.isNeg() || n.isZero() || n.bitLength() > 256 || new l(m, "le").gt(n));
    }, e.getReward = function(m, f) {
      c(m >= 0, "Bad height for reward.");
      const n = Math.floor(m / f);
      return n >= 33 ? 0 : n === 0 ? e.BASE_REWARD : e.HALF_REWARD >>> n - 1;
    }, e.hasBit = function(m, f) {
      const n = e.VERSION_TOP_MASK, u = e.VERSION_TOP_BITS, o = (m & n) >>> 0, s = 1 << f;
      return o === u && (m & s) !== 0;
    }, e.maxBlockSigops = function(m) {
      return (1 + ((m - 1) / 1e6 | 0)) * e.MAX_BLOCK_SIGOPS_PER_MB;
    }, e.maxBlockSigchecks = function(m) {
      return m / e.MAX_BLOCK_SIGCHECKS_RATIO;
    };
  }(iu)), iu;
}
var Rs = { exports: {} }, L4;
function vo() {
  if (L4) return Rs.exports;
  L4 = 1;
  var e = typeof Reflect == "object" ? Reflect : null, c = e && typeof e.apply == "function" ? e.apply : function(G, N, T) {
    return Function.prototype.apply.call(G, N, T);
  }, l;
  e && typeof e.ownKeys == "function" ? l = e.ownKeys : Object.getOwnPropertySymbols ? l = function(G) {
    return Object.getOwnPropertyNames(G).concat(Object.getOwnPropertySymbols(G));
  } : l = function(G) {
    return Object.getOwnPropertyNames(G);
  };
  function w(j) {
    console && console.warn && console.warn(j);
  }
  var m = Number.isNaN || function(G) {
    return G !== G;
  };
  function f() {
    f.init.call(this);
  }
  Rs.exports = f, Rs.exports.once = a, f.EventEmitter = f, f.prototype._events = void 0, f.prototype._eventsCount = 0, f.prototype._maxListeners = void 0;
  var n = 10;
  function u(j) {
    if (typeof j != "function")
      throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof j);
  }
  Object.defineProperty(f, "defaultMaxListeners", {
    enumerable: !0,
    get: function() {
      return n;
    },
    set: function(j) {
      if (typeof j != "number" || j < 0 || m(j))
        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + j + ".");
      n = j;
    }
  }), f.init = function() {
    (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
  }, f.prototype.setMaxListeners = function(G) {
    if (typeof G != "number" || G < 0 || m(G))
      throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + G + ".");
    return this._maxListeners = G, this;
  };
  function o(j) {
    return j._maxListeners === void 0 ? f.defaultMaxListeners : j._maxListeners;
  }
  f.prototype.getMaxListeners = function() {
    return o(this);
  }, f.prototype.emit = function(G) {
    for (var N = [], T = 1; T < arguments.length; T++) N.push(arguments[T]);
    var A = G === "error", q = this._events;
    if (q !== void 0)
      A = A && q.error === void 0;
    else if (!A)
      return !1;
    if (A) {
      var _;
      if (N.length > 0 && (_ = N[0]), _ instanceof Error)
        throw _;
      var F = new Error("Unhandled error." + (_ ? " (" + _.message + ")" : ""));
      throw F.context = _, F;
    }
    var R = q[G];
    if (R === void 0)
      return !1;
    if (typeof R == "function")
      c(R, this, N);
    else
      for (var L = R.length, fe = y(R, L), T = 0; T < L; ++T)
        c(fe[T], this, N);
    return !0;
  };
  function s(j, G, N, T) {
    var A, q, _;
    if (u(N), q = j._events, q === void 0 ? (q = j._events = /* @__PURE__ */ Object.create(null), j._eventsCount = 0) : (q.newListener !== void 0 && (j.emit(
      "newListener",
      G,
      N.listener ? N.listener : N
    ), q = j._events), _ = q[G]), _ === void 0)
      _ = q[G] = N, ++j._eventsCount;
    else if (typeof _ == "function" ? _ = q[G] = T ? [N, _] : [_, N] : T ? _.unshift(N) : _.push(N), A = o(j), A > 0 && _.length > A && !_.warned) {
      _.warned = !0;
      var F = new Error("Possible EventEmitter memory leak detected. " + _.length + " " + String(G) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      F.name = "MaxListenersExceededWarning", F.emitter = j, F.type = G, F.count = _.length, w(F);
    }
    return j;
  }
  f.prototype.addListener = function(G, N) {
    return s(this, G, N, !1);
  }, f.prototype.on = f.prototype.addListener, f.prototype.prependListener = function(G, N) {
    return s(this, G, N, !0);
  };
  function i() {
    if (!this.fired)
      return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
  }
  function p(j, G, N) {
    var T = { fired: !1, wrapFn: void 0, target: j, type: G, listener: N }, A = i.bind(T);
    return A.listener = N, T.wrapFn = A, A;
  }
  f.prototype.once = function(G, N) {
    return u(N), this.on(G, p(this, G, N)), this;
  }, f.prototype.prependOnceListener = function(G, N) {
    return u(N), this.prependListener(G, p(this, G, N)), this;
  }, f.prototype.removeListener = function(G, N) {
    var T, A, q, _, F;
    if (u(N), A = this._events, A === void 0)
      return this;
    if (T = A[G], T === void 0)
      return this;
    if (T === N || T.listener === N)
      --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete A[G], A.removeListener && this.emit("removeListener", G, T.listener || N));
    else if (typeof T != "function") {
      for (q = -1, _ = T.length - 1; _ >= 0; _--)
        if (T[_] === N || T[_].listener === N) {
          F = T[_].listener, q = _;
          break;
        }
      if (q < 0)
        return this;
      q === 0 ? T.shift() : b(T, q), T.length === 1 && (A[G] = T[0]), A.removeListener !== void 0 && this.emit("removeListener", G, F || N);
    }
    return this;
  }, f.prototype.off = f.prototype.removeListener, f.prototype.removeAllListeners = function(G) {
    var N, T, A;
    if (T = this._events, T === void 0)
      return this;
    if (T.removeListener === void 0)
      return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : T[G] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete T[G]), this;
    if (arguments.length === 0) {
      var q = Object.keys(T), _;
      for (A = 0; A < q.length; ++A)
        _ = q[A], _ !== "removeListener" && this.removeAllListeners(_);
      return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
    }
    if (N = T[G], typeof N == "function")
      this.removeListener(G, N);
    else if (N !== void 0)
      for (A = N.length - 1; A >= 0; A--)
        this.removeListener(G, N[A]);
    return this;
  };
  function g(j, G, N) {
    var T = j._events;
    if (T === void 0)
      return [];
    var A = T[G];
    return A === void 0 ? [] : typeof A == "function" ? N ? [A.listener || A] : [A] : N ? h(A) : y(A, A.length);
  }
  f.prototype.listeners = function(G) {
    return g(this, G, !0);
  }, f.prototype.rawListeners = function(G) {
    return g(this, G, !1);
  }, f.listenerCount = function(j, G) {
    return typeof j.listenerCount == "function" ? j.listenerCount(G) : S.call(j, G);
  }, f.prototype.listenerCount = S;
  function S(j) {
    var G = this._events;
    if (G !== void 0) {
      var N = G[j];
      if (typeof N == "function")
        return 1;
      if (N !== void 0)
        return N.length;
    }
    return 0;
  }
  f.prototype.eventNames = function() {
    return this._eventsCount > 0 ? l(this._events) : [];
  };
  function y(j, G) {
    for (var N = new Array(G), T = 0; T < G; ++T)
      N[T] = j[T];
    return N;
  }
  function b(j, G) {
    for (; G + 1 < j.length; G++)
      j[G] = j[G + 1];
    j.pop();
  }
  function h(j) {
    for (var G = new Array(j.length), N = 0; N < G.length; ++N)
      G[N] = j[N].listener || j[N];
    return G;
  }
  function a(j, G) {
    return new Promise(function(N, T) {
      function A(_) {
        j.removeListener(G, q), T(_);
      }
      function q() {
        typeof j.removeListener == "function" && j.removeListener("error", A), N([].slice.call(arguments));
      }
      H(j, G, q, { once: !0 }), G !== "error" && E(j, A, { once: !0 });
    });
  }
  function E(j, G, N) {
    typeof j.on == "function" && H(j, "error", G, N);
  }
  function H(j, G, N, T) {
    if (typeof j.on == "function")
      T.once ? j.once(G, N) : j.on(G, N);
    else if (typeof j.addEventListener == "function")
      j.addEventListener(G, function A(q) {
        T.once && j.removeEventListener(G, A), N(q);
      });
    else
      throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof j);
  }
  return Rs.exports;
}
var nu = {}, K4;
function Qt() {
  return K4 || (K4 = 1, function(e) {
    const c = Xe(), l = e;
    l.bench = function(m) {
      if (!St.hrtime) {
        const f = Date.now();
        if (m) {
          const [s, i] = m, p = s * 1e3 + i / 1e6;
          return f - p;
        }
        const n = f % 1e3, u = (f - n) / 1e3, o = n * 1e6;
        return [u, o];
      }
      if (m) {
        const [f, n] = St.hrtime(m);
        return f * 1e3 + n / 1e6;
      }
      return St.hrtime();
    }, l.now = function() {
      return Math.floor(Date.now() / 1e3);
    }, l.ms = function() {
      return Date.now();
    }, l.date = function(m) {
      return m == null && (m = l.now()), new Date(m * 1e3).toISOString().slice(0, -5) + "Z";
    }, l.time = function(m) {
      return m == null ? l.now() : new Date(m) / 1e3 | 0;
    }, l.revHex = function(m) {
      return c(k.isBuffer(m)), k.from(m).reverse().toString("hex");
    }, l.fromRev = function(m) {
      return c(typeof m == "string"), c((m.length & 1) === 0), k.from(m, "hex").reverse();
    };
  }(nu)), nu;
}
/*!
 * timedata.js - time management for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var su, V4;
function Sp() {
  if (V4) return su;
  V4 = 1;
  const e = vo(), c = Qt(), l = yo();
  class w extends e {
    /**
     * Create time data.
     * @constructor
     * @param {Number} [limit=200]
     */
    constructor(n) {
      super(), n == null && (n = 200), this.samples = [], this.known = /* @__PURE__ */ new Map(), this.limit = n, this.offset = 0, this.checked = !1;
    }
    /**
     * Add time data.
     * @param {String} id
     * @param {Number} time
     */
    add(n, u) {
      if (this.samples.length >= this.limit || this.known.has(n))
        return;
      const o = u - c.now();
      if (this.known.set(n, o), l.insert(this.samples, o, m), this.emit("sample", o, this.samples.length), this.samples.length >= 5 && this.samples.length % 2 === 1) {
        let s = this.samples[this.samples.length >>> 1];
        if (Math.abs(s) >= 4200) {
          if (!this.checked) {
            let i = !1;
            for (const p of this.samples)
              if (p !== 0 && Math.abs(p) < 300) {
                i = !0;
                break;
              }
            i || (this.checked = !0, this.emit("mismatch"));
          }
          s = 0;
        }
        this.offset = s, this.emit("offset", this.offset);
      }
    }
    /**
     * Get the current adjusted time.
     * @returns {Number} Adjusted Time.
     */
    now() {
      return c.now() + this.offset;
    }
    /**
     * Adjust a timestamp.
     * @param {Number} time
     * @returns {Number} Adjusted Time.
     */
    adjust(n) {
      return n + this.offset;
    }
    /**
     * Unadjust a timestamp.
     * @param {Number} time
     * @returns {Number} Local Time.
     */
    local(n) {
      return n - this.offset;
    }
    /**
     * Get the current adjusted time in milliseconds.
     * @returns {Number} Adjusted Time.
     */
    ms() {
      return Date.now() + this.offset * 1e3;
    }
  }
  function m(f, n) {
    return f - n;
  }
  return su = w, su;
}
var ou, $4;
function Or() {
  if ($4) return ou;
  $4 = 1;
  const e = Xe(), c = yo(), l = o1(), w = Lt(), m = Sp();
  class f {
    /**
     * Create a network.
     * @constructor
     * @param {Object} options
     */
    constructor(a) {
      e(!f[a.type], "Cannot create two networks."), this.type = a.type, this.seeds = a.seeds, this.magic = a.magic, this.port = a.port, this.checkpointMap = a.checkpointMap, this.lastCheckpoint = a.lastCheckpoint, this.checkpoints = [], this.halvingInterval = a.halvingInterval, this.genesis = a.genesis, this.genesisBlock = a.genesisBlock, this.pow = a.pow, this.block = a.block, this.bip30 = a.bip30, this.activationThreshold = a.activationThreshold, this.minerWindow = a.minerWindow, this.deployments = a.deployments, this.deploys = a.deploys, this.unknownBits = ~w.VERSION_TOP_MASK, this.keyPrefix = a.keyPrefix, this.addressPrefix = a.addressPrefix, this.requireStandard = a.requireStandard, this.rpcPort = a.rpcPort, this.walletPort = a.walletPort, this.minRelay = a.minRelay, this.feeRate = a.feeRate, this.maxFeeRate = a.maxFeeRate, this.selfConnect = a.selfConnect, this.requestMempool = a.requestMempool, this.time = new m(), this.init();
    }
    /**
     * Get a deployment by bit index.
     * @param {Number} bit
     * @returns {Object}
     */
    init() {
      let a = 0;
      for (const E of this.deploys)
        a |= 1 << E.bit;
      a |= w.VERSION_TOP_MASK, this.unknownBits = ~a >>> 0;
      for (const E of Object.keys(this.checkpointMap)) {
        const H = this.checkpointMap[E], j = Number(E);
        this.checkpoints.push({ hash: H, height: j });
      }
      this.checkpoints.sort(u);
    }
    /**
     * Get a deployment by bit index.
     * @param {Number} bit
     * @returns {Object}
     */
    byBit(a) {
      const E = c.search(this.deploys, a, n);
      return E === -1 ? null : this.deploys[E];
    }
    /**
     * Get network adjusted time.
     * @returns {Number}
     */
    now() {
      return this.time.now();
    }
    /**
     * Get network adjusted time in milliseconds.
     * @returns {Number}
     */
    ms() {
      return this.time.ms();
    }
    /**
     * Create a network. Get existing network if possible.
     * @param {NetworkType|Object} options
     * @returns {Network}
     */
    static create(a) {
      if (typeof a == "string" && (a = l[a]), e(a, "Unknown network."), f[a.type])
        return f[a.type];
      const E = new f(a);
      return f[E.type] = E, f.primary || (f.primary = E), E;
    }
    /**
     * Set the default network. This network will be used
     * if nothing is passed as the `network` option for
     * certain objects.
     * @param {NetworkType} type - Network type.
     * @returns {Network}
     */
    static set(a) {
      return e(typeof a == "string", "Bad network."), f.primary = f.get(a), f.type = a, f.primary;
    }
    /**
     * Get a network with a string or a Network object.
     * @param {NetworkType|Network} type - Network type.
     * @returns {Network}
     */
    static get(a) {
      if (!a)
        return e(f.primary, "No default network."), f.primary;
      if (a instanceof f)
        return a;
      if (typeof a == "string")
        return f.create(a);
      throw new Error("Unknown network.");
    }
    /**
     * Get a network with a string or a Network object.
     * @param {NetworkType|Network} type - Network type.
     * @returns {Network}
     */
    static ensure(a) {
      return a ? a instanceof f ? a : typeof a == "string" && l[a] ? f.create(a) : (e(f.primary, "No default network."), f.primary) : (e(f.primary, "No default network."), f.primary);
    }
    /**
     * Get a network by an associated comparator.
     * @private
     * @param {Object} value
     * @param {Function} compare
     * @param {Network|null} network
     * @param {String} name
     * @returns {Network}
     */
    static by(a, E, H, j) {
      if (H) {
        if (H = f.get(H), E(H, a))
          return H;
        throw new Error(`Network mismatch for ${j}.`);
      }
      for (const G of l.types)
        if (H = l[G], E(H, a))
          return f.get(G);
      throw new Error(`Network not found for ${j}.`);
    }
    /**
     * Get a network by its magic number.
     * @param {Number} value
     * @param {Network?} network
     * @returns {Network}
     */
    static fromMagic(a, E) {
      return f.by(a, o, E, "magic number");
    }
    /**
     * Get a network by its WIF prefix.
     * @param {Number} value
     * @param {Network?} network
     * @returns {Network}
     */
    static fromWIF(a, E) {
      return f.by(a, s, E, "WIF");
    }
    /**
     * Get a network by its xpubkey prefix.
     * @param {Number} value
     * @param {Network?} network
     * @returns {Network}
     */
    static fromPublic(a, E) {
      return f.by(a, i, E, "xpubkey");
    }
    /**
     * Get a network by its xprivkey prefix.
     * @param {Number} value
     * @param {Network?} network
     * @returns {Network}
     */
    static fromPrivate(a, E) {
      return f.by(a, p, E, "xprivkey");
    }
    /**
     * Get a network by its xpubkey base58 prefix.
     * @param {String} prefix
     * @param {Network?} network
     * @returns {Network}
     */
    static fromPublic58(a, E) {
      return f.by(a, g, E, "xpubkey");
    }
    /**
     * Get a network by its xprivkey base58 prefix.
     * @param {String} prefix
     * @param {Network?} network
     * @returns {Network}
     */
    static fromPrivate58(a, E) {
      return f.by(a, S, E, "xprivkey");
    }
    /**
     * Get a network by its base58 address prefix.
     * @param {Number} value
     * @param {Network?} network
     * @returns {Network}
     */
    static fromAddress(a, E) {
      return f.by(a, y, E, "base58 address");
    }
    /**
     * Get a network by its cashaddr address prefix.
     * @param {String} hrp
     * @param {Network?} network
     * @returns {Network}
     */
    static fromCashAddr(a, E) {
      return f.by(a, b, E, "cashaddr address");
    }
    /**
     * Convert the network to a string.
     * @returns {String}
     */
    toString() {
      return this.type;
    }
    /**
     * Inspect the network.
     * @returns {String}
     */
    inspect() {
      return `<Network: ${this.type}>`;
    }
    /**
     * Test an object to see if it is a Network.
     * @param {Object} obj
     * @returns {Boolean}
     */
    static isNetwork(a) {
      return a instanceof f;
    }
  }
  f.primary = null, f.type = null, f.main = null, f.testnet = null, f.regtest = null, f.segnet4 = null, f.simnet = null, f.set(St.env.BCASH_NETWORK || "main");
  function n(h, a) {
    return h.bit - a;
  }
  function u(h, a) {
    return h.height - a.height;
  }
  function o(h, a) {
    return h.magic === a;
  }
  function s(h, a) {
    return h.keyPrefix.privkey === a;
  }
  function i(h, a) {
    return h.keyPrefix.xpubkey === a;
  }
  function p(h, a) {
    return h.keyPrefix.xprivkey === a;
  }
  function g(h, a) {
    return h.keyPrefix.xpubkey58 === a;
  }
  function S(h, a) {
    return h.keyPrefix.xprivkey58 === a;
  }
  function y(h, a) {
    const E = h.addressPrefix;
    switch (a) {
      case E.pubkeyhash:
      case E.scripthash:
        return !0;
    }
    return !1;
  }
  function b(h, a) {
    return h.addressPrefix.cashaddr === a;
  }
  return ou = f, ou;
}
var _i = {}, au = {}, Ri = {}, j4;
function yi() {
  if (j4) return Ri;
  j4 = 1;
  const e = Nt(), c = Ft.crypto || Ft.msCrypto, l = c && typeof c.getRandomValues == "function", w = l ? c.getRandomValues.bind(c) : null, m = new Uint32Array(16), f = 65536;
  let n = 0;
  function u(S) {
    e(S >>> 0 === S);
    const y = k.alloc(S);
    return g(y, 0, S), y;
  }
  function o(S, y, b) {
    return e(k.isBuffer(S)), y == null && (y = 0), e(y >>> 0 === y), b == null && (b = S.length - y), e(b >>> 0 === b), e(y + b <= S.length), g(S, y, b), S;
  }
  function s() {
    return (n & 15) === 0 && (p(m), n = 0), m[n++];
  }
  function i(S, y) {
    e(S >>> 0 === S), e(y >>> 0 === y), e(y >= S);
    const b = y - S;
    if (b === 0)
      return S;
    const h = -b >>> 0;
    let a, E;
    do
      a = s(), E = a % b;
    while (a - E > h);
    return E + S;
  }
  function p(S) {
    if (!l)
      throw new Error("Entropy source not available.");
    return w(S);
  }
  function g(S, y, b) {
    if (e(k.isBuffer(S)), e(S.buffer instanceof ArrayBuffer), e(S.byteOffset >>> 0 === S.byteOffset), e(S.byteLength >>> 0 === S.byteLength), e(y >>> 0 === y), e(b >>> 0 === b), e(y + b <= S.byteLength), b > 2 ** 31 - 1)
      throw new RangeError('The value "size" is out of range.');
    const h = S.byteOffset + y, a = new Uint8Array(S.buffer, h, b);
    if (a.length > f)
      for (let E = 0; E < a.length; E += f) {
        let H = E + f;
        H > a.length && (H = a.length), p(a.subarray(E, H));
      }
    else
      a.length > 0 && p(a);
  }
  return Ri.native = 0, Ri.randomBytes = u, Ri.randomFill = o, Ri.randomInt = s, Ri.randomRange = i, Ri;
}
var or = {}, fu = { exports: {} }, cu = {}, Y4;
function Ep() {
  if (Y4) return cu;
  Y4 = 1;
  function e(E) {
    "@babel/helpers - typeof";
    return e = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(H) {
      return typeof H;
    } : function(H) {
      return H && typeof Symbol == "function" && H.constructor === Symbol && H !== Symbol.prototype ? "symbol" : typeof H;
    }, e(E);
  }
  function c(E, H, j) {
    return Object.defineProperty(E, "prototype", { writable: !1 }), E;
  }
  function l(E, H) {
    if (!(E instanceof H))
      throw new TypeError("Cannot call a class as a function");
  }
  function w(E, H) {
    if (typeof H != "function" && H !== null)
      throw new TypeError("Super expression must either be null or a function");
    E.prototype = Object.create(H && H.prototype, { constructor: { value: E, writable: !0, configurable: !0 } }), Object.defineProperty(E, "prototype", { writable: !1 }), H && m(E, H);
  }
  function m(E, H) {
    return m = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(G, N) {
      return G.__proto__ = N, G;
    }, m(E, H);
  }
  function f(E) {
    var H = o();
    return function() {
      var G = s(E), N;
      if (H) {
        var T = s(this).constructor;
        N = Reflect.construct(G, arguments, T);
      } else
        N = G.apply(this, arguments);
      return n(this, N);
    };
  }
  function n(E, H) {
    if (H && (e(H) === "object" || typeof H == "function"))
      return H;
    if (H !== void 0)
      throw new TypeError("Derived constructors may only return object or undefined");
    return u(E);
  }
  function u(E) {
    if (E === void 0)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return E;
  }
  function o() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
    if (typeof Proxy == "function") return !0;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      })), !0;
    } catch {
      return !1;
    }
  }
  function s(E) {
    return s = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(j) {
      return j.__proto__ || Object.getPrototypeOf(j);
    }, s(E);
  }
  var i = {}, p, g;
  function S(E, H, j) {
    j || (j = Error);
    function G(T, A, q) {
      return typeof H == "string" ? H : H(T, A, q);
    }
    var N = /* @__PURE__ */ function(T) {
      w(q, T);
      var A = f(q);
      function q(_, F, R) {
        var L;
        return l(this, q), L = A.call(this, G(_, F, R)), L.code = E, L;
      }
      return c(q);
    }(j);
    i[E] = N;
  }
  function y(E, H) {
    if (Array.isArray(E)) {
      var j = E.length;
      return E = E.map(function(G) {
        return String(G);
      }), j > 2 ? "one of ".concat(H, " ").concat(E.slice(0, j - 1).join(", "), ", or ") + E[j - 1] : j === 2 ? "one of ".concat(H, " ").concat(E[0], " or ").concat(E[1]) : "of ".concat(H, " ").concat(E[0]);
    } else
      return "of ".concat(H, " ").concat(String(E));
  }
  function b(E, H, j) {
    return E.substr(0, H.length) === H;
  }
  function h(E, H, j) {
    return (j === void 0 || j > E.length) && (j = E.length), E.substring(j - H.length, j) === H;
  }
  function a(E, H, j) {
    return typeof j != "number" && (j = 0), j + H.length > E.length ? !1 : E.indexOf(H, j) !== -1;
  }
  return S("ERR_AMBIGUOUS_ARGUMENT", 'The "%s" argument is ambiguous. %s', TypeError), S("ERR_INVALID_ARG_TYPE", function(E, H, j) {
    p === void 0 && (p = sl()), p(typeof E == "string", "'name' must be a string");
    var G;
    typeof H == "string" && b(H, "not ") ? (G = "must not be", H = H.replace(/^not /, "")) : G = "must be";
    var N;
    if (h(E, " argument"))
      N = "The ".concat(E, " ").concat(G, " ").concat(y(H, "type"));
    else {
      var T = a(E, ".") ? "property" : "argument";
      N = 'The "'.concat(E, '" ').concat(T, " ").concat(G, " ").concat(y(H, "type"));
    }
    return N += ". Received type ".concat(e(j)), N;
  }, TypeError), S("ERR_INVALID_ARG_VALUE", function(E, H) {
    var j = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "is invalid";
    g === void 0 && (g = Ci());
    var G = g.inspect(H);
    return G.length > 128 && (G = "".concat(G.slice(0, 128), "...")), "The argument '".concat(E, "' ").concat(j, ". Received ").concat(G);
  }, TypeError), S("ERR_INVALID_RETURN_VALUE", function(E, H, j) {
    var G;
    return j && j.constructor && j.constructor.name ? G = "instance of ".concat(j.constructor.name) : G = "type ".concat(e(j)), "Expected ".concat(E, ' to be returned from the "').concat(H, '"') + " function but got ".concat(G, ".");
  }, TypeError), S("ERR_MISSING_ARGS", function() {
    for (var E = arguments.length, H = new Array(E), j = 0; j < E; j++)
      H[j] = arguments[j];
    p === void 0 && (p = sl()), p(H.length > 0, "At least one arg needs to be specified");
    var G = "The ", N = H.length;
    switch (H = H.map(function(T) {
      return '"'.concat(T, '"');
    }), N) {
      case 1:
        G += "".concat(H[0], " argument");
        break;
      case 2:
        G += "".concat(H[0], " and ").concat(H[1], " arguments");
        break;
      default:
        G += H.slice(0, N - 1).join(", "), G += ", and ".concat(H[N - 1], " arguments");
        break;
    }
    return "".concat(G, " must be specified");
  }, TypeError), cu.codes = i, cu;
}
var uu, X4;
function Yw() {
  if (X4) return uu;
  X4 = 1;
  function e(W, oe) {
    var v = Object.keys(W);
    if (Object.getOwnPropertySymbols) {
      var Y = Object.getOwnPropertySymbols(W);
      oe && (Y = Y.filter(function(he) {
        return Object.getOwnPropertyDescriptor(W, he).enumerable;
      })), v.push.apply(v, Y);
    }
    return v;
  }
  function c(W) {
    for (var oe = 1; oe < arguments.length; oe++) {
      var v = arguments[oe] != null ? arguments[oe] : {};
      oe % 2 ? e(Object(v), !0).forEach(function(Y) {
        l(W, Y, v[Y]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(W, Object.getOwnPropertyDescriptors(v)) : e(Object(v)).forEach(function(Y) {
        Object.defineProperty(W, Y, Object.getOwnPropertyDescriptor(v, Y));
      });
    }
    return W;
  }
  function l(W, oe, v) {
    return oe = n(oe), oe in W ? Object.defineProperty(W, oe, { value: v, enumerable: !0, configurable: !0, writable: !0 }) : W[oe] = v, W;
  }
  function w(W, oe) {
    if (!(W instanceof oe))
      throw new TypeError("Cannot call a class as a function");
  }
  function m(W, oe) {
    for (var v = 0; v < oe.length; v++) {
      var Y = oe[v];
      Y.enumerable = Y.enumerable || !1, Y.configurable = !0, "value" in Y && (Y.writable = !0), Object.defineProperty(W, n(Y.key), Y);
    }
  }
  function f(W, oe, v) {
    return oe && m(W.prototype, oe), Object.defineProperty(W, "prototype", { writable: !1 }), W;
  }
  function n(W) {
    var oe = u(W, "string");
    return E(oe) === "symbol" ? oe : String(oe);
  }
  function u(W, oe) {
    if (E(W) !== "object" || W === null) return W;
    var v = W[Symbol.toPrimitive];
    if (v !== void 0) {
      var Y = v.call(W, oe);
      if (E(Y) !== "object") return Y;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return String(W);
  }
  function o(W, oe) {
    if (typeof oe != "function" && oe !== null)
      throw new TypeError("Super expression must either be null or a function");
    W.prototype = Object.create(oe && oe.prototype, { constructor: { value: W, writable: !0, configurable: !0 } }), Object.defineProperty(W, "prototype", { writable: !1 }), oe && h(W, oe);
  }
  function s(W) {
    var oe = y();
    return function() {
      var Y = a(W), he;
      if (oe) {
        var le = a(this).constructor;
        he = Reflect.construct(Y, arguments, le);
      } else
        he = Y.apply(this, arguments);
      return i(this, he);
    };
  }
  function i(W, oe) {
    if (oe && (E(oe) === "object" || typeof oe == "function"))
      return oe;
    if (oe !== void 0)
      throw new TypeError("Derived constructors may only return object or undefined");
    return p(W);
  }
  function p(W) {
    if (W === void 0)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return W;
  }
  function g(W) {
    var oe = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
    return g = function(Y) {
      if (Y === null || !b(Y)) return Y;
      if (typeof Y != "function")
        throw new TypeError("Super expression must either be null or a function");
      if (typeof oe < "u") {
        if (oe.has(Y)) return oe.get(Y);
        oe.set(Y, he);
      }
      function he() {
        return S(Y, arguments, a(this).constructor);
      }
      return he.prototype = Object.create(Y.prototype, { constructor: { value: he, enumerable: !1, writable: !0, configurable: !0 } }), h(he, Y);
    }, g(W);
  }
  function S(W, oe, v) {
    return y() ? S = Reflect.construct.bind() : S = function(he, le, ge) {
      var Ee = [null];
      Ee.push.apply(Ee, le);
      var we = Function.bind.apply(he, Ee), z = new we();
      return ge && h(z, ge.prototype), z;
    }, S.apply(null, arguments);
  }
  function y() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
    if (typeof Proxy == "function") return !0;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      })), !0;
    } catch {
      return !1;
    }
  }
  function b(W) {
    return Function.toString.call(W).indexOf("[native code]") !== -1;
  }
  function h(W, oe) {
    return h = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(Y, he) {
      return Y.__proto__ = he, Y;
    }, h(W, oe);
  }
  function a(W) {
    return a = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(v) {
      return v.__proto__ || Object.getPrototypeOf(v);
    }, a(W);
  }
  function E(W) {
    "@babel/helpers - typeof";
    return E = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(oe) {
      return typeof oe;
    } : function(oe) {
      return oe && typeof Symbol == "function" && oe.constructor === Symbol && oe !== Symbol.prototype ? "symbol" : typeof oe;
    }, E(W);
  }
  var H = Ci(), j = H.inspect, G = Ep(), N = G.codes.ERR_INVALID_ARG_TYPE;
  function T(W, oe, v) {
    return (v === void 0 || v > W.length) && (v = W.length), W.substring(v - oe.length, v) === oe;
  }
  function A(W, oe) {
    if (oe = Math.floor(oe), W.length == 0 || oe == 0) return "";
    var v = W.length * oe;
    for (oe = Math.floor(Math.log(oe) / Math.log(2)); oe; )
      W += W, oe--;
    return W += W.substring(0, v - W.length), W;
  }
  var q = "", _ = "", F = "", R = "", L = {
    deepStrictEqual: "Expected values to be strictly deep-equal:",
    strictEqual: "Expected values to be strictly equal:",
    strictEqualObject: 'Expected "actual" to be reference-equal to "expected":',
    deepEqual: "Expected values to be loosely deep-equal:",
    equal: "Expected values to be loosely equal:",
    notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:',
    notStrictEqual: 'Expected "actual" to be strictly unequal to:',
    notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":',
    notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:',
    notEqual: 'Expected "actual" to be loosely unequal to:',
    notIdentical: "Values identical but not reference-equal:"
  }, fe = 10;
  function ue(W) {
    var oe = Object.keys(W), v = Object.create(Object.getPrototypeOf(W));
    return oe.forEach(function(Y) {
      v[Y] = W[Y];
    }), Object.defineProperty(v, "message", {
      value: W.message
    }), v;
  }
  function ae(W) {
    return j(W, {
      compact: !1,
      customInspect: !1,
      depth: 1e3,
      maxArrayLength: 1 / 0,
      // Assert compares only enumerable properties (with a few exceptions).
      showHidden: !1,
      // Having a long line as error is better than wrapping the line for
      // comparison for now.
      // TODO(BridgeAR): `breakLength` should be limited as soon as soon as we
      // have meta information about the inspected properties (i.e., know where
      // in what line the property starts and ends).
      breakLength: 1 / 0,
      // Assert does not detect proxies currently.
      showProxy: !1,
      sorted: !0,
      // Inspect getters as we also check them when comparing entries.
      getters: !0
    });
  }
  function D(W, oe, v) {
    var Y = "", he = "", le = 0, ge = "", Ee = !1, we = ae(W), z = we.split(`
`), I = ae(oe).split(`
`), ne = 0, t = "";
    if (v === "strictEqual" && E(W) === "object" && E(oe) === "object" && W !== null && oe !== null && (v = "strictEqualObject"), z.length === 1 && I.length === 1 && z[0] !== I[0]) {
      var d = z[0].length + I[0].length;
      if (d <= fe) {
        if ((E(W) !== "object" || W === null) && (E(oe) !== "object" || oe === null) && (W !== 0 || oe !== 0))
          return "".concat(L[v], `

`) + "".concat(z[0], " !== ").concat(I[0], `
`);
      } else if (v !== "strictEqualObject") {
        var B = St.stderr && St.stderr.isTTY ? St.stderr.columns : 80;
        if (d < B) {
          for (; z[0][ne] === I[0][ne]; )
            ne++;
          ne > 2 && (t = `
  `.concat(A(" ", ne), "^"), ne = 0);
        }
      }
    }
    for (var U = z[z.length - 1], J = I[I.length - 1]; U === J && (ne++ < 2 ? ge = `
  `.concat(U).concat(ge) : Y = U, z.pop(), I.pop(), !(z.length === 0 || I.length === 0)); )
      U = z[z.length - 1], J = I[I.length - 1];
    var C = Math.max(z.length, I.length);
    if (C === 0) {
      var M = we.split(`
`);
      if (M.length > 30)
        for (M[26] = "".concat(q, "...").concat(R); M.length > 27; )
          M.pop();
      return "".concat(L.notIdentical, `

`).concat(M.join(`
`), `
`);
    }
    ne > 3 && (ge = `
`.concat(q, "...").concat(R).concat(ge), Ee = !0), Y !== "" && (ge = `
  `.concat(Y).concat(ge), Y = "");
    var $ = 0, r = L[v] + `
`.concat(_, "+ actual").concat(R, " ").concat(F, "- expected").concat(R), x = " ".concat(q, "...").concat(R, " Lines skipped");
    for (ne = 0; ne < C; ne++) {
      var O = ne - le;
      if (z.length < ne + 1)
        O > 1 && ne > 2 && (O > 4 ? (he += `
`.concat(q, "...").concat(R), Ee = !0) : O > 3 && (he += `
  `.concat(I[ne - 2]), $++), he += `
  `.concat(I[ne - 1]), $++), le = ne, Y += `
`.concat(F, "-").concat(R, " ").concat(I[ne]), $++;
      else if (I.length < ne + 1)
        O > 1 && ne > 2 && (O > 4 ? (he += `
`.concat(q, "...").concat(R), Ee = !0) : O > 3 && (he += `
  `.concat(z[ne - 2]), $++), he += `
  `.concat(z[ne - 1]), $++), le = ne, he += `
`.concat(_, "+").concat(R, " ").concat(z[ne]), $++;
      else {
        var K = I[ne], X = z[ne], P = X !== K && (!T(X, ",") || X.slice(0, -1) !== K);
        P && T(K, ",") && K.slice(0, -1) === X && (P = !1, X += ","), P ? (O > 1 && ne > 2 && (O > 4 ? (he += `
`.concat(q, "...").concat(R), Ee = !0) : O > 3 && (he += `
  `.concat(z[ne - 2]), $++), he += `
  `.concat(z[ne - 1]), $++), le = ne, he += `
`.concat(_, "+").concat(R, " ").concat(X), Y += `
`.concat(F, "-").concat(R, " ").concat(K), $ += 2) : (he += Y, Y = "", (O === 1 || ne === 0) && (he += `
  `.concat(X), $++));
      }
      if ($ > 20 && ne < C - 2)
        return "".concat(r).concat(x, `
`).concat(he, `
`).concat(q, "...").concat(R).concat(Y, `
`) + "".concat(q, "...").concat(R);
    }
    return "".concat(r).concat(Ee ? x : "", `
`).concat(he).concat(Y).concat(ge).concat(t);
  }
  var Q = /* @__PURE__ */ function(W, oe) {
    o(Y, W);
    var v = s(Y);
    function Y(he) {
      var le;
      if (w(this, Y), E(he) !== "object" || he === null)
        throw new N("options", "Object", he);
      var ge = he.message, Ee = he.operator, we = he.stackStartFn, z = he.actual, I = he.expected, ne = Error.stackTraceLimit;
      if (Error.stackTraceLimit = 0, ge != null)
        le = v.call(this, String(ge));
      else if (St.stderr && St.stderr.isTTY && (St.stderr && St.stderr.getColorDepth && St.stderr.getColorDepth() !== 1 ? (q = "\x1B[34m", _ = "\x1B[32m", R = "\x1B[39m", F = "\x1B[31m") : (q = "", _ = "", R = "", F = "")), E(z) === "object" && z !== null && E(I) === "object" && I !== null && "stack" in z && z instanceof Error && "stack" in I && I instanceof Error && (z = ue(z), I = ue(I)), Ee === "deepStrictEqual" || Ee === "strictEqual")
        le = v.call(this, D(z, I, Ee));
      else if (Ee === "notDeepStrictEqual" || Ee === "notStrictEqual") {
        var t = L[Ee], d = ae(z).split(`
`);
        if (Ee === "notStrictEqual" && E(z) === "object" && z !== null && (t = L.notStrictEqualObject), d.length > 30)
          for (d[26] = "".concat(q, "...").concat(R); d.length > 27; )
            d.pop();
        d.length === 1 ? le = v.call(this, "".concat(t, " ").concat(d[0])) : le = v.call(this, "".concat(t, `

`).concat(d.join(`
`), `
`));
      } else {
        var B = ae(z), U = "", J = L[Ee];
        Ee === "notDeepEqual" || Ee === "notEqual" ? (B = "".concat(L[Ee], `

`).concat(B), B.length > 1024 && (B = "".concat(B.slice(0, 1021), "..."))) : (U = "".concat(ae(I)), B.length > 512 && (B = "".concat(B.slice(0, 509), "...")), U.length > 512 && (U = "".concat(U.slice(0, 509), "...")), Ee === "deepEqual" || Ee === "equal" ? B = "".concat(J, `

`).concat(B, `

should equal

`) : U = " ".concat(Ee, " ").concat(U)), le = v.call(this, "".concat(B).concat(U));
      }
      return Error.stackTraceLimit = ne, le.generatedMessage = !ge, Object.defineProperty(p(le), "name", {
        value: "AssertionError [ERR_ASSERTION]",
        enumerable: !1,
        writable: !0,
        configurable: !0
      }), le.code = "ERR_ASSERTION", le.actual = z, le.expected = I, le.operator = Ee, Error.captureStackTrace && Error.captureStackTrace(p(le), we), le.stack, le.name = "AssertionError", i(le);
    }
    return f(Y, [{
      key: "toString",
      value: function() {
        return "".concat(this.name, " [").concat(this.code, "]: ").concat(this.message);
      }
    }, {
      key: oe,
      value: function(le, ge) {
        return j(this, c(c({}, ge), {}, {
          customInspect: !1,
          depth: 0
        }));
      }
    }]), Y;
  }(/* @__PURE__ */ g(Error), j.custom);
  return uu = Q, uu;
}
var hu, G4;
function Ip() {
  return G4 || (G4 = 1, hu = function(c) {
    return c !== c;
  }), hu;
}
var lu, J4;
function Ap() {
  if (J4) return lu;
  J4 = 1;
  var e = Ip();
  return lu = function() {
    return Number.isNaN && Number.isNaN(NaN) && !Number.isNaN("a") ? Number.isNaN : e;
  }, lu;
}
var du, W4;
function Xw() {
  if (W4) return du;
  W4 = 1;
  var e = oi(), c = Ap();
  return du = function() {
    var w = c();
    return e(Number, { isNaN: w }, {
      isNaN: function() {
        return Number.isNaN !== w;
      }
    }), w;
  }, du;
}
var bu, Z4;
function Gw() {
  if (Z4) return bu;
  Z4 = 1;
  var e = Yi(), c = oi(), l = Ip(), w = Ap(), m = Xw(), f = e(w(), Number);
  return c(f, {
    getPolyfill: w,
    implementation: l,
    shim: m
  }), bu = f, bu;
}
var pu, Q4;
function Jw() {
  if (Q4) return pu;
  Q4 = 1;
  function e(P, V) {
    return f(P) || m(P, V) || l(P, V) || c();
  }
  function c() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  function l(P, V) {
    if (P) {
      if (typeof P == "string") return w(P, V);
      var re = Object.prototype.toString.call(P).slice(8, -1);
      if (re === "Object" && P.constructor && (re = P.constructor.name), re === "Map" || re === "Set") return Array.from(P);
      if (re === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(re)) return w(P, V);
    }
  }
  function w(P, V) {
    (V == null || V > P.length) && (V = P.length);
    for (var re = 0, ce = new Array(V); re < V; re++) ce[re] = P[re];
    return ce;
  }
  function m(P, V) {
    var re = P == null ? null : typeof Symbol < "u" && P[Symbol.iterator] || P["@@iterator"];
    if (re != null) {
      var ce, de, pe, se, Z = [], ee = !0, me = !1;
      try {
        if (pe = (re = re.call(P)).next, V !== 0) for (; !(ee = (ce = pe.call(re)).done) && (Z.push(ce.value), Z.length !== V); ee = !0) ;
      } catch (Ae) {
        me = !0, de = Ae;
      } finally {
        try {
          if (!ee && re.return != null && (se = re.return(), Object(se) !== se)) return;
        } finally {
          if (me) throw de;
        }
      }
      return Z;
    }
  }
  function f(P) {
    if (Array.isArray(P)) return P;
  }
  function n(P) {
    "@babel/helpers - typeof";
    return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(V) {
      return typeof V;
    } : function(V) {
      return V && typeof Symbol == "function" && V.constructor === Symbol && V !== Symbol.prototype ? "symbol" : typeof V;
    }, n(P);
  }
  var u = /a/g.flags !== void 0, o = function(V) {
    var re = [];
    return V.forEach(function(ce) {
      return re.push(ce);
    }), re;
  }, s = function(V) {
    var re = [];
    return V.forEach(function(ce, de) {
      return re.push([de, ce]);
    }), re;
  }, i = Object.is ? Object.is : dp(), p = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function() {
    return [];
  }, g = Number.isNaN ? Number.isNaN : Gw();
  function S(P) {
    return P.call.bind(P);
  }
  var y = S(Object.prototype.hasOwnProperty), b = S(Object.prototype.propertyIsEnumerable), h = S(Object.prototype.toString), a = Ci().types, E = a.isAnyArrayBuffer, H = a.isArrayBufferView, j = a.isDate, G = a.isMap, N = a.isRegExp, T = a.isSet, A = a.isNativeError, q = a.isBoxedPrimitive, _ = a.isNumberObject, F = a.isStringObject, R = a.isBooleanObject, L = a.isBigIntObject, fe = a.isSymbolObject, ue = a.isFloat32Array, ae = a.isFloat64Array;
  function D(P) {
    if (P.length === 0 || P.length > 10) return !0;
    for (var V = 0; V < P.length; V++) {
      var re = P.charCodeAt(V);
      if (re < 48 || re > 57) return !0;
    }
    return P.length === 10 && P >= Math.pow(2, 32);
  }
  function Q(P) {
    return Object.keys(P).filter(D).concat(p(P).filter(Object.prototype.propertyIsEnumerable.bind(P)));
  }
  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   */
  function W(P, V) {
    if (P === V)
      return 0;
    for (var re = P.length, ce = V.length, de = 0, pe = Math.min(re, ce); de < pe; ++de)
      if (P[de] !== V[de]) {
        re = P[de], ce = V[de];
        break;
      }
    return re < ce ? -1 : ce < re ? 1 : 0;
  }
  var oe = !0, v = !1, Y = 0, he = 1, le = 2, ge = 3;
  function Ee(P, V) {
    return u ? P.source === V.source && P.flags === V.flags : RegExp.prototype.toString.call(P) === RegExp.prototype.toString.call(V);
  }
  function we(P, V) {
    if (P.byteLength !== V.byteLength)
      return !1;
    for (var re = 0; re < P.byteLength; re++)
      if (P[re] !== V[re])
        return !1;
    return !0;
  }
  function z(P, V) {
    return P.byteLength !== V.byteLength ? !1 : W(new Uint8Array(P.buffer, P.byteOffset, P.byteLength), new Uint8Array(V.buffer, V.byteOffset, V.byteLength)) === 0;
  }
  function I(P, V) {
    return P.byteLength === V.byteLength && W(new Uint8Array(P), new Uint8Array(V)) === 0;
  }
  function ne(P, V) {
    return _(P) ? _(V) && i(Number.prototype.valueOf.call(P), Number.prototype.valueOf.call(V)) : F(P) ? F(V) && String.prototype.valueOf.call(P) === String.prototype.valueOf.call(V) : R(P) ? R(V) && Boolean.prototype.valueOf.call(P) === Boolean.prototype.valueOf.call(V) : L(P) ? L(V) && BigInt.prototype.valueOf.call(P) === BigInt.prototype.valueOf.call(V) : fe(V) && Symbol.prototype.valueOf.call(P) === Symbol.prototype.valueOf.call(V);
  }
  function t(P, V, re, ce) {
    if (P === V)
      return P !== 0 ? !0 : re ? i(P, V) : !0;
    if (re) {
      if (n(P) !== "object")
        return typeof P == "number" && g(P) && g(V);
      if (n(V) !== "object" || P === null || V === null || Object.getPrototypeOf(P) !== Object.getPrototypeOf(V))
        return !1;
    } else {
      if (P === null || n(P) !== "object")
        return V === null || n(V) !== "object" ? P == V : !1;
      if (V === null || n(V) !== "object")
        return !1;
    }
    var de = h(P), pe = h(V);
    if (de !== pe)
      return !1;
    if (Array.isArray(P)) {
      if (P.length !== V.length)
        return !1;
      var se = Q(P), Z = Q(V);
      return se.length !== Z.length ? !1 : B(P, V, re, ce, he, se);
    }
    if (de === "[object Object]" && (!G(P) && G(V) || !T(P) && T(V)))
      return !1;
    if (j(P)) {
      if (!j(V) || Date.prototype.getTime.call(P) !== Date.prototype.getTime.call(V))
        return !1;
    } else if (N(P)) {
      if (!N(V) || !Ee(P, V))
        return !1;
    } else if (A(P) || P instanceof Error) {
      if (P.message !== V.message || P.name !== V.name)
        return !1;
    } else if (H(P)) {
      if (!re && (ue(P) || ae(P))) {
        if (!we(P, V))
          return !1;
      } else if (!z(P, V))
        return !1;
      var ee = Q(P), me = Q(V);
      return ee.length !== me.length ? !1 : B(P, V, re, ce, Y, ee);
    } else {
      if (T(P))
        return !T(V) || P.size !== V.size ? !1 : B(P, V, re, ce, le);
      if (G(P))
        return !G(V) || P.size !== V.size ? !1 : B(P, V, re, ce, ge);
      if (E(P)) {
        if (!I(P, V))
          return !1;
      } else if (q(P) && !ne(P, V))
        return !1;
    }
    return B(P, V, re, ce, Y);
  }
  function d(P, V) {
    return V.filter(function(re) {
      return b(P, re);
    });
  }
  function B(P, V, re, ce, de, pe) {
    if (arguments.length === 5) {
      pe = Object.keys(P);
      var se = Object.keys(V);
      if (pe.length !== se.length)
        return !1;
    }
    for (var Z = 0; Z < pe.length; Z++)
      if (!y(V, pe[Z]))
        return !1;
    if (re && arguments.length === 5) {
      var ee = p(P);
      if (ee.length !== 0) {
        var me = 0;
        for (Z = 0; Z < ee.length; Z++) {
          var Ae = ee[Z];
          if (b(P, Ae)) {
            if (!b(V, Ae))
              return !1;
            pe.push(Ae), me++;
          } else if (b(V, Ae))
            return !1;
        }
        var Oe = p(V);
        if (ee.length !== Oe.length && d(V, Oe).length !== me)
          return !1;
      } else {
        var ye = p(V);
        if (ye.length !== 0 && d(V, ye).length !== 0)
          return !1;
      }
    }
    if (pe.length === 0 && (de === Y || de === he && P.length === 0 || P.size === 0))
      return !0;
    if (ce === void 0)
      ce = {
        val1: /* @__PURE__ */ new Map(),
        val2: /* @__PURE__ */ new Map(),
        position: 0
      };
    else {
      var _e = ce.val1.get(P);
      if (_e !== void 0) {
        var ke = ce.val2.get(V);
        if (ke !== void 0)
          return _e === ke;
      }
      ce.position++;
    }
    ce.val1.set(P, ce.position), ce.val2.set(V, ce.position);
    var Me = O(P, V, re, pe, ce, de);
    return ce.val1.delete(P), ce.val2.delete(V), Me;
  }
  function U(P, V, re, ce) {
    for (var de = o(P), pe = 0; pe < de.length; pe++) {
      var se = de[pe];
      if (t(V, se, re, ce))
        return P.delete(se), !0;
    }
    return !1;
  }
  function J(P) {
    switch (n(P)) {
      case "undefined":
        return null;
      case "object":
        return;
      case "symbol":
        return !1;
      case "string":
        P = +P;
      // Loose equal entries exist only if the string is possible to convert to
      // a regular number and not NaN.
      // Fall through
      case "number":
        if (g(P))
          return !1;
    }
    return !0;
  }
  function C(P, V, re) {
    var ce = J(re);
    return ce ?? (V.has(ce) && !P.has(ce));
  }
  function M(P, V, re, ce, de) {
    var pe = J(re);
    if (pe != null)
      return pe;
    var se = V.get(pe);
    return se === void 0 && !V.has(pe) || !t(ce, se, !1, de) ? !1 : !P.has(pe) && t(ce, se, !1, de);
  }
  function $(P, V, re, ce) {
    for (var de = null, pe = o(P), se = 0; se < pe.length; se++) {
      var Z = pe[se];
      if (n(Z) === "object" && Z !== null)
        de === null && (de = /* @__PURE__ */ new Set()), de.add(Z);
      else if (!V.has(Z)) {
        if (re || !C(P, V, Z))
          return !1;
        de === null && (de = /* @__PURE__ */ new Set()), de.add(Z);
      }
    }
    if (de !== null) {
      for (var ee = o(V), me = 0; me < ee.length; me++) {
        var Ae = ee[me];
        if (n(Ae) === "object" && Ae !== null) {
          if (!U(de, Ae, re, ce)) return !1;
        } else if (!re && !P.has(Ae) && !U(de, Ae, re, ce))
          return !1;
      }
      return de.size === 0;
    }
    return !0;
  }
  function r(P, V, re, ce, de, pe) {
    for (var se = o(P), Z = 0; Z < se.length; Z++) {
      var ee = se[Z];
      if (t(re, ee, de, pe) && t(ce, V.get(ee), de, pe))
        return P.delete(ee), !0;
    }
    return !1;
  }
  function x(P, V, re, ce) {
    for (var de = null, pe = s(P), se = 0; se < pe.length; se++) {
      var Z = e(pe[se], 2), ee = Z[0], me = Z[1];
      if (n(ee) === "object" && ee !== null)
        de === null && (de = /* @__PURE__ */ new Set()), de.add(ee);
      else {
        var Ae = V.get(ee);
        if (Ae === void 0 && !V.has(ee) || !t(me, Ae, re, ce)) {
          if (re || !M(P, V, ee, me, ce)) return !1;
          de === null && (de = /* @__PURE__ */ new Set()), de.add(ee);
        }
      }
    }
    if (de !== null) {
      for (var Oe = s(V), ye = 0; ye < Oe.length; ye++) {
        var _e = e(Oe[ye], 2), ke = _e[0], Me = _e[1];
        if (n(ke) === "object" && ke !== null) {
          if (!r(de, P, ke, Me, re, ce)) return !1;
        } else if (!re && (!P.has(ke) || !t(P.get(ke), Me, !1, ce)) && !r(de, P, ke, Me, !1, ce))
          return !1;
      }
      return de.size === 0;
    }
    return !0;
  }
  function O(P, V, re, ce, de, pe) {
    var se = 0;
    if (pe === le) {
      if (!$(P, V, re, de))
        return !1;
    } else if (pe === ge) {
      if (!x(P, V, re, de))
        return !1;
    } else if (pe === he)
      for (; se < P.length; se++)
        if (y(P, se)) {
          if (!y(V, se) || !t(P[se], V[se], re, de))
            return !1;
        } else {
          if (y(V, se))
            return !1;
          for (var Z = Object.keys(P); se < Z.length; se++) {
            var ee = Z[se];
            if (!y(V, ee) || !t(P[ee], V[ee], re, de))
              return !1;
          }
          return Z.length === Object.keys(V).length;
        }
    for (se = 0; se < ce.length; se++) {
      var me = ce[se];
      if (!t(P[me], V[me], re, de))
        return !1;
    }
    return !0;
  }
  function K(P, V) {
    return t(P, V, v);
  }
  function X(P, V) {
    return t(P, V, oe);
  }
  return pu = {
    isDeepEqual: K,
    isDeepStrictEqual: X
  }, pu;
}
var e3;
function sl() {
  if (e3) return fu.exports;
  e3 = 1;
  function e(le) {
    "@babel/helpers - typeof";
    return e = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(ge) {
      return typeof ge;
    } : function(ge) {
      return ge && typeof Symbol == "function" && ge.constructor === Symbol && ge !== Symbol.prototype ? "symbol" : typeof ge;
    }, e(le);
  }
  function c(le, ge, Ee) {
    return Object.defineProperty(le, "prototype", { writable: !1 }), le;
  }
  function l(le, ge) {
    if (!(le instanceof ge))
      throw new TypeError("Cannot call a class as a function");
  }
  var w = Ep(), m = w.codes, f = m.ERR_AMBIGUOUS_ARGUMENT, n = m.ERR_INVALID_ARG_TYPE, u = m.ERR_INVALID_ARG_VALUE, o = m.ERR_INVALID_RETURN_VALUE, s = m.ERR_MISSING_ARGS, i = Yw(), p = Ci(), g = p.inspect, S = Ci().types, y = S.isPromise, b = S.isRegExp, h = Ql()(), a = r1()(), E = e1()("RegExp.prototype.test"), H, j;
  function G() {
    var le = Jw();
    H = le.isDeepEqual, j = le.isDeepStrictEqual;
  }
  var N = !1, T = fu.exports = R, A = {};
  function q(le) {
    throw le.message instanceof Error ? le.message : new i(le);
  }
  function _(le, ge, Ee, we, z) {
    var I = arguments.length, ne;
    if (I === 0)
      ne = "Failed";
    else if (I === 1)
      Ee = le, le = void 0;
    else {
      if (N === !1) {
        N = !0;
        var t = St.emitWarning ? St.emitWarning : console.warn.bind(console);
        t("assert.fail() with more than one argument is deprecated. Please use assert.strictEqual() instead or only pass a message.", "DeprecationWarning", "DEP0094");
      }
      I === 2 && (we = "!=");
    }
    if (Ee instanceof Error) throw Ee;
    var d = {
      actual: le,
      expected: ge,
      operator: we === void 0 ? "fail" : we,
      stackStartFn: z || _
    };
    Ee !== void 0 && (d.message = Ee);
    var B = new i(d);
    throw ne && (B.message = ne, B.generatedMessage = !0), B;
  }
  T.fail = _, T.AssertionError = i;
  function F(le, ge, Ee, we) {
    if (!Ee) {
      var z = !1;
      if (ge === 0)
        z = !0, we = "No value argument passed to `assert.ok()`";
      else if (we instanceof Error)
        throw we;
      var I = new i({
        actual: Ee,
        expected: !0,
        message: we,
        operator: "==",
        stackStartFn: le
      });
      throw I.generatedMessage = z, I;
    }
  }
  function R() {
    for (var le = arguments.length, ge = new Array(le), Ee = 0; Ee < le; Ee++)
      ge[Ee] = arguments[Ee];
    F.apply(void 0, [R, ge.length].concat(ge));
  }
  T.ok = R, T.equal = function le(ge, Ee, we) {
    if (arguments.length < 2)
      throw new s("actual", "expected");
    ge != Ee && q({
      actual: ge,
      expected: Ee,
      message: we,
      operator: "==",
      stackStartFn: le
    });
  }, T.notEqual = function le(ge, Ee, we) {
    if (arguments.length < 2)
      throw new s("actual", "expected");
    ge == Ee && q({
      actual: ge,
      expected: Ee,
      message: we,
      operator: "!=",
      stackStartFn: le
    });
  }, T.deepEqual = function le(ge, Ee, we) {
    if (arguments.length < 2)
      throw new s("actual", "expected");
    H === void 0 && G(), H(ge, Ee) || q({
      actual: ge,
      expected: Ee,
      message: we,
      operator: "deepEqual",
      stackStartFn: le
    });
  }, T.notDeepEqual = function le(ge, Ee, we) {
    if (arguments.length < 2)
      throw new s("actual", "expected");
    H === void 0 && G(), H(ge, Ee) && q({
      actual: ge,
      expected: Ee,
      message: we,
      operator: "notDeepEqual",
      stackStartFn: le
    });
  }, T.deepStrictEqual = function le(ge, Ee, we) {
    if (arguments.length < 2)
      throw new s("actual", "expected");
    H === void 0 && G(), j(ge, Ee) || q({
      actual: ge,
      expected: Ee,
      message: we,
      operator: "deepStrictEqual",
      stackStartFn: le
    });
  }, T.notDeepStrictEqual = L;
  function L(le, ge, Ee) {
    if (arguments.length < 2)
      throw new s("actual", "expected");
    H === void 0 && G(), j(le, ge) && q({
      actual: le,
      expected: ge,
      message: Ee,
      operator: "notDeepStrictEqual",
      stackStartFn: L
    });
  }
  T.strictEqual = function le(ge, Ee, we) {
    if (arguments.length < 2)
      throw new s("actual", "expected");
    a(ge, Ee) || q({
      actual: ge,
      expected: Ee,
      message: we,
      operator: "strictEqual",
      stackStartFn: le
    });
  }, T.notStrictEqual = function le(ge, Ee, we) {
    if (arguments.length < 2)
      throw new s("actual", "expected");
    a(ge, Ee) && q({
      actual: ge,
      expected: Ee,
      message: we,
      operator: "notStrictEqual",
      stackStartFn: le
    });
  };
  var fe = /* @__PURE__ */ c(function le(ge, Ee, we) {
    var z = this;
    l(this, le), Ee.forEach(function(I) {
      I in ge && (we !== void 0 && typeof we[I] == "string" && b(ge[I]) && E(ge[I], we[I]) ? z[I] = we[I] : z[I] = ge[I]);
    });
  });
  function ue(le, ge, Ee, we, z, I) {
    if (!(Ee in le) || !j(le[Ee], ge[Ee])) {
      if (!we) {
        var ne = new fe(le, z), t = new fe(ge, z, le), d = new i({
          actual: ne,
          expected: t,
          operator: "deepStrictEqual",
          stackStartFn: I
        });
        throw d.actual = le, d.expected = ge, d.operator = I.name, d;
      }
      q({
        actual: le,
        expected: ge,
        message: we,
        operator: I.name,
        stackStartFn: I
      });
    }
  }
  function ae(le, ge, Ee, we) {
    if (typeof ge != "function") {
      if (b(ge)) return E(ge, le);
      if (arguments.length === 2)
        throw new n("expected", ["Function", "RegExp"], ge);
      if (e(le) !== "object" || le === null) {
        var z = new i({
          actual: le,
          expected: ge,
          message: Ee,
          operator: "deepStrictEqual",
          stackStartFn: we
        });
        throw z.operator = we.name, z;
      }
      var I = Object.keys(ge);
      if (ge instanceof Error)
        I.push("name", "message");
      else if (I.length === 0)
        throw new u("error", ge, "may not be an empty object");
      return H === void 0 && G(), I.forEach(function(ne) {
        typeof le[ne] == "string" && b(ge[ne]) && E(ge[ne], le[ne]) || ue(le, ge, ne, Ee, I, we);
      }), !0;
    }
    return ge.prototype !== void 0 && le instanceof ge ? !0 : Error.isPrototypeOf(ge) ? !1 : ge.call({}, le) === !0;
  }
  function D(le) {
    if (typeof le != "function")
      throw new n("fn", "Function", le);
    try {
      le();
    } catch (ge) {
      return ge;
    }
    return A;
  }
  function Q(le) {
    return y(le) || le !== null && e(le) === "object" && typeof le.then == "function" && typeof le.catch == "function";
  }
  function W(le) {
    return Promise.resolve().then(function() {
      var ge;
      if (typeof le == "function") {
        if (ge = le(), !Q(ge))
          throw new o("instance of Promise", "promiseFn", ge);
      } else if (Q(le))
        ge = le;
      else
        throw new n("promiseFn", ["Function", "Promise"], le);
      return Promise.resolve().then(function() {
        return ge;
      }).then(function() {
        return A;
      }).catch(function(Ee) {
        return Ee;
      });
    });
  }
  function oe(le, ge, Ee, we) {
    if (typeof Ee == "string") {
      if (arguments.length === 4)
        throw new n("error", ["Object", "Error", "Function", "RegExp"], Ee);
      if (e(ge) === "object" && ge !== null) {
        if (ge.message === Ee)
          throw new f("error/message", 'The error message "'.concat(ge.message, '" is identical to the message.'));
      } else if (ge === Ee)
        throw new f("error/message", 'The error "'.concat(ge, '" is identical to the message.'));
      we = Ee, Ee = void 0;
    } else if (Ee != null && e(Ee) !== "object" && typeof Ee != "function")
      throw new n("error", ["Object", "Error", "Function", "RegExp"], Ee);
    if (ge === A) {
      var z = "";
      Ee && Ee.name && (z += " (".concat(Ee.name, ")")), z += we ? ": ".concat(we) : ".";
      var I = le.name === "rejects" ? "rejection" : "exception";
      q({
        actual: void 0,
        expected: Ee,
        operator: le.name,
        message: "Missing expected ".concat(I).concat(z),
        stackStartFn: le
      });
    }
    if (Ee && !ae(ge, Ee, we, le))
      throw ge;
  }
  function v(le, ge, Ee, we) {
    if (ge !== A) {
      if (typeof Ee == "string" && (we = Ee, Ee = void 0), !Ee || ae(ge, Ee)) {
        var z = we ? ": ".concat(we) : ".", I = le.name === "doesNotReject" ? "rejection" : "exception";
        q({
          actual: ge,
          expected: Ee,
          operator: le.name,
          message: "Got unwanted ".concat(I).concat(z, `
`) + 'Actual message: "'.concat(ge && ge.message, '"'),
          stackStartFn: le
        });
      }
      throw ge;
    }
  }
  T.throws = function le(ge) {
    for (var Ee = arguments.length, we = new Array(Ee > 1 ? Ee - 1 : 0), z = 1; z < Ee; z++)
      we[z - 1] = arguments[z];
    oe.apply(void 0, [le, D(ge)].concat(we));
  }, T.rejects = function le(ge) {
    for (var Ee = arguments.length, we = new Array(Ee > 1 ? Ee - 1 : 0), z = 1; z < Ee; z++)
      we[z - 1] = arguments[z];
    return W(ge).then(function(I) {
      return oe.apply(void 0, [le, I].concat(we));
    });
  }, T.doesNotThrow = function le(ge) {
    for (var Ee = arguments.length, we = new Array(Ee > 1 ? Ee - 1 : 0), z = 1; z < Ee; z++)
      we[z - 1] = arguments[z];
    v.apply(void 0, [le, D(ge)].concat(we));
  }, T.doesNotReject = function le(ge) {
    for (var Ee = arguments.length, we = new Array(Ee > 1 ? Ee - 1 : 0), z = 1; z < Ee; z++)
      we[z - 1] = arguments[z];
    return W(ge).then(function(I) {
      return v.apply(void 0, [le, I].concat(we));
    });
  }, T.ifError = function le(ge) {
    if (ge != null) {
      var Ee = "ifError got unwanted exception: ";
      e(ge) === "object" && typeof ge.message == "string" ? ge.message.length === 0 && ge.constructor ? Ee += ge.constructor.name : Ee += ge.message : Ee += g(ge);
      var we = new i({
        actual: ge,
        expected: null,
        operator: "ifError",
        message: Ee,
        stackStartFn: le
      }), z = ge.stack;
      if (typeof z == "string") {
        var I = z.split(`
`);
        I.shift();
        for (var ne = we.stack.split(`
`), t = 0; t < I.length; t++) {
          var d = ne.indexOf(I[t]);
          if (d !== -1) {
            ne = ne.slice(0, d);
            break;
          }
        }
        we.stack = "".concat(ne.join(`
`), `
`).concat(I.join(`
`));
      }
      throw we;
    }
  };
  function Y(le, ge, Ee, we, z) {
    if (!b(ge))
      throw new n("regexp", "RegExp", ge);
    var I = z === "match";
    if (typeof le != "string" || E(ge, le) !== I) {
      if (Ee instanceof Error)
        throw Ee;
      var ne = !Ee;
      Ee = Ee || (typeof le != "string" ? 'The "string" argument must be of type string. Received type ' + "".concat(e(le), " (").concat(g(le), ")") : (I ? "The input did not match the regular expression " : "The input was expected to not match the regular expression ") + "".concat(g(ge), `. Input:

`).concat(g(le), `
`));
      var t = new i({
        actual: le,
        expected: ge,
        message: Ee,
        operator: z,
        stackStartFn: we
      });
      throw t.generatedMessage = ne, t;
    }
  }
  T.match = function le(ge, Ee, we) {
    Y(ge, Ee, we, le, "match");
  }, T.doesNotMatch = function le(ge, Ee, we) {
    Y(ge, Ee, we, le, "doesNotMatch");
  };
  function he() {
    for (var le = arguments.length, ge = new Array(le), Ee = 0; Ee < le; Ee++)
      ge[Ee] = arguments[Ee];
    F.apply(void 0, [he, ge.length].concat(ge));
  }
  return T.strict = h(he, T, {
    equal: T.strictEqual,
    deepEqual: T.deepStrictEqual,
    notEqual: T.notStrictEqual,
    notDeepEqual: T.notDeepStrictEqual
  }), T.strict.strict = T.strict, fu.exports;
}
var t3;
function Op() {
  if (t3) return or;
  t3 = 1;
  const e = sl(), c = Xr();
  function l(y, b, h) {
    if (e(k.isBuffer(y)), e(b >>> 0 === b), e(typeof h == "boolean"), b >= y.length)
      throw new Error("Invalid size.");
    const a = y[b], E = a & 127;
    if (b += 1, (a & 128) === 0)
      return [E, b];
    if (h && E === 0)
      throw new Error("Indefinite length.");
    let H = 0;
    for (let j = 0; j < E; j++) {
      e(b < y.length);
      const G = y[b];
      if (b += 1, H >= 1 << 24)
        throw new Error("Length too large.");
      if (H *= 256, H += G, h && H === 0)
        throw new Error("Unexpected leading zeroes.");
    }
    if (h && H < 128)
      throw new Error("Non-minimal length.");
    return [H, b];
  }
  function w(y, b, h = !0) {
    if (e(k.isBuffer(y)), e(b >>> 0 === b), e(typeof h == "boolean"), b >= y.length || y[b] !== 48)
      throw new Error("Invalid sequence tag.");
    b += 1;
    let a;
    if ([a, b] = l(y, b, h), h && b + a !== y.length)
      throw new Error("Trailing bytes.");
    return b;
  }
  function m(y, b, h = !0) {
    if (e(k.isBuffer(y)), e(b >>> 0 === b), e(typeof h == "boolean"), b >= y.length || y[b] !== 2)
      throw new Error("Invalid integer tag.");
    b += 1;
    let a;
    if ([a, b] = l(y, b, h), b + a > y.length)
      throw new Error("Integer body out of bounds.");
    if (h) {
      if (a === 0)
        throw new Error("Zero length integer.");
      if (y[b] & 128)
        throw new Error("Integers must be positive.");
      if (a > 1 && y[b] === 0 && (y[b + 1] & 128) === 0)
        throw new Error("Unexpected leading zeroes.");
    }
    for (; a > 0 && y[b] === 0; )
      b += 1, a -= 1;
    if (a > 2048)
      throw new Error("Invalid integer size.");
    const E = c.decode(y.slice(b, b + a));
    return b += a, [E, b];
  }
  function f(y, b, h, a = !0) {
    e(k.isBuffer(y)), e(b >>> 0 === b), e((h & 255) === h), e(typeof a == "boolean");
    let E;
    if ([E, b] = m(y, b, a), E.cmpn(h) !== 0)
      throw new Error("Invalid version.");
    return b;
  }
  function n(y) {
    return e(y >>> 0 === y), y <= 127 ? 1 : y <= 255 ? 2 : (e(y <= 65535), 3);
  }
  function u(y) {
    return 1 + n(y) + y;
  }
  function o(y) {
    e(y instanceof c);
    const b = y.bitLength();
    let h = b + 7 >>> 3;
    return b > 0 && (b & 7) === 0 && (h += y.testn(b - 1)), b === 0 && (h = 1), 1 + n(h) + h;
  }
  function s(y) {
    return e((y & 255) === y), 3;
  }
  function i(y, b, h) {
    return e(k.isBuffer(y)), e(b >>> 0 === b), e(h >>> 0 === h), h <= 127 ? y[b++] = h : h <= 255 ? (y[b++] = 129, y[b++] = h) : (e(h <= 65535), y[b++] = 130, y[b++] = h >> 8, y[b++] = h & 255), e(b <= y.length), b;
  }
  function p(y, b, h) {
    return e(k.isBuffer(y)), e(b >>> 0 === b), y[b++] = 48, i(y, b, h);
  }
  function g(y, b, h) {
    e(k.isBuffer(y)), e(b >>> 0 === b), e(h instanceof c);
    const a = h.bitLength();
    let E = a + 7 >>> 3, H = 0;
    return a > 0 && (a & 7) === 0 && (H = h.testn(a - 1)), a === 0 && (E = 1), y[b++] = 2, b = i(y, b, H + E), H && (y[b++] = 0), a !== 0 ? h.encode().copy(y, b) : y[b] = 0, b += E, e(b <= y.length), b;
  }
  function S(y, b, h) {
    return e(k.isBuffer(y)), e(b >>> 0 === b), e((h & 255) === h), e(b + 3 <= y.length), y[b++] = 2, y[b++] = 1, y[b++] = h, b;
  }
  return or.readSize = l, or.readSeq = w, or.readInt = m, or.readVersion = f, or.sizeSize = n, or.sizeSeq = u, or.sizeInt = o, or.sizeVersion = s, or.writeSize = i, or.writeSeq = p, or.writeInt = g, or.writeVersion = S, or;
}
var mu, r3;
function _p() {
  if (r3) return mu;
  r3 = 1;
  const e = Nt(), c = new Int8Array(new Int16Array([1]).buffer)[0] === 0;
  class l {
    /**
     * Create a ChaCha20 context.
     * @constructor
     */
    constructor() {
      this.state = new Uint32Array(16), this.stream = new Uint32Array(16), this.bytes = new Uint8Array(this.stream.buffer), this.pos = -1, c && (this.bytes = k.alloc(64));
    }
    /**
     * Initialize chacha20 with a key, nonce, and counter.
     * @param {Buffer} key
     * @param {Buffer} nonce
     * @param {Number} counter
     */
    init(o, s, i) {
      if (i == null && (i = 0), e(k.isBuffer(o)), e(k.isBuffer(s)), e(Number.isSafeInteger(i)), o.length !== 16 && o.length !== 32)
        throw new RangeError("Invalid key size.");
      if (s.length >= 24 && (o = l.derive(o, s.slice(0, 16)), s = s.slice(16)), this.state[0] = 1634760805, this.state[1] = o.length < 32 ? 824206446 : 857760878, this.state[2] = o.length < 32 ? 2036477238 : 2036477234, this.state[3] = 1797285236, this.state[4] = f(o, 0), this.state[5] = f(o, 4), this.state[6] = f(o, 8), this.state[7] = f(o, 12), this.state[8] = f(o, 16 % o.length), this.state[9] = f(o, 20 % o.length), this.state[10] = f(o, 24 % o.length), this.state[11] = f(o, 28 % o.length), this.state[12] = i >>> 0, s.length === 8)
        this.state[13] = i / 4294967296 >>> 0, this.state[14] = f(s, 0), this.state[15] = f(s, 4);
      else if (s.length === 12)
        this.state[13] = f(s, 0), this.state[14] = f(s, 4), this.state[15] = f(s, 8);
      else if (s.length === 16)
        this.state[12] = f(s, 0), this.state[13] = f(s, 4), this.state[14] = f(s, 8), this.state[15] = f(s, 12);
      else
        throw new RangeError("Invalid nonce size.");
      return this.pos = 0, this;
    }
    /**
     * Encrypt/decrypt data.
     * @param {Buffer} data - Will be mutated.
     * @returns {Buffer}
     */
    encrypt(o) {
      if (e(k.isBuffer(o)), this.pos === -1)
        throw new Error("Context is not initialized.");
      for (let s = 0; s < o.length; s++)
        (this.pos & 63) === 0 && (this._block(), this.pos = 0), o[s] ^= this.bytes[this.pos++];
      return o;
    }
    /**
     * Stir the stream.
     */
    _block() {
      for (let o = 0; o < 16; o++)
        this.stream[o] = this.state[o];
      for (let o = 0; o < 10; o++)
        w(this.stream, 0, 4, 8, 12), w(this.stream, 1, 5, 9, 13), w(this.stream, 2, 6, 10, 14), w(this.stream, 3, 7, 11, 15), w(this.stream, 0, 5, 10, 15), w(this.stream, 1, 6, 11, 12), w(this.stream, 2, 7, 8, 13), w(this.stream, 3, 4, 9, 14);
      for (let o = 0; o < 16; o++)
        this.stream[o] += this.state[o];
      if (c)
        for (let o = 0; o < 16; o++)
          n(this.bytes, this.stream[o], o * 4);
      this.state[12] += 1, this.state[12] === 0 && (this.state[13] += 1);
    }
    /**
     * Destroy context.
     */
    destroy() {
      for (let o = 0; o < 16; o++)
        this.state[o] = 0, this.stream[o] = 0;
      if (c)
        for (let o = 0; o < 64; o++)
          this.bytes[o] = 0;
      return this.pos = -1, this;
    }
    /**
     * Derive key with XChaCha20.
     * @param {Buffer} key
     * @param {Buffer} nonce
     * @returns {Buffer}
     */
    static derive(o, s) {
      if (e(k.isBuffer(o)), e(k.isBuffer(s)), o.length !== 16 && o.length !== 32)
        throw new RangeError("Invalid key size.");
      if (s.length !== 16)
        throw new RangeError("Invalid nonce size.");
      const i = new Uint32Array(16);
      i[0] = 1634760805, i[1] = o.length < 32 ? 824206446 : 857760878, i[2] = o.length < 32 ? 2036477238 : 2036477234, i[3] = 1797285236, i[4] = f(o, 0), i[5] = f(o, 4), i[6] = f(o, 8), i[7] = f(o, 12), i[8] = f(o, 16 % o.length), i[9] = f(o, 20 % o.length), i[10] = f(o, 24 % o.length), i[11] = f(o, 28 % o.length), i[12] = f(s, 0), i[13] = f(s, 4), i[14] = f(s, 8), i[15] = f(s, 12);
      for (let g = 0; g < 10; g++)
        w(i, 0, 4, 8, 12), w(i, 1, 5, 9, 13), w(i, 2, 6, 10, 14), w(i, 3, 7, 11, 15), w(i, 0, 5, 10, 15), w(i, 1, 6, 11, 12), w(i, 2, 7, 8, 13), w(i, 3, 4, 9, 14);
      const p = k.alloc(32);
      return n(p, i[0], 0), n(p, i[1], 4), n(p, i[2], 8), n(p, i[3], 12), n(p, i[12], 16), n(p, i[13], 20), n(p, i[14], 24), n(p, i[15], 28), p;
    }
  }
  l.native = 0;
  function w(u, o, s, i, p) {
    u[o] += u[s], u[p] = m(u[p] ^ u[o], 16), u[i] += u[p], u[s] = m(u[s] ^ u[i], 12), u[o] += u[s], u[p] = m(u[p] ^ u[o], 8), u[i] += u[p], u[s] = m(u[s] ^ u[i], 7);
  }
  function m(u, o) {
    return u << o | u >>> 32 - o;
  }
  function f(u, o) {
    return u[o++] + u[o++] * 256 + u[o++] * 65536 + u[o] * 16777216;
  }
  function n(u, o, s) {
    return u[s++] = o, o >>>= 8, u[s++] = o, o >>>= 8, u[s++] = o, o >>>= 8, u[s++] = o, s;
  }
  return mu = l, mu;
}
var gu, i3;
function Ww() {
  if (i3) return gu;
  i3 = 1;
  const e = Nt(), c = Xr(), l = _p(), w = Ar();
  class m {
    constructor(n, u = (o) => o) {
      this.curve = n, this.encode = u, this.hash = new w(), this.chacha = new l(), this.key = k.alloc(32, 0), this.iv = k.alloc(8, 0), this.cache = [new c(1), new c(1)];
    }
    init(n) {
      e(Array.isArray(n)), this.hash.init();
      for (const [u, o, s] of n)
        this.hash.update(w.digest(u)), this.hash.update(o), this.hash.update(this.encode(s));
      return this.key = this.hash.final(), this.cache[0] = new c(1), this.cache[1] = new c(1), this;
    }
    encrypt(n) {
      const u = this.curve.scalarSize * 2, o = k.alloc(u, 0), s = o.slice(0, this.curve.scalarSize), i = o.slice(this.curve.scalarSize);
      return this.chacha.init(this.key, this.iv, n), this.chacha.encrypt(o), [
        this.curve.decodeScalar(s),
        this.curve.decodeScalar(i)
      ];
    }
    refresh(n) {
      let u = 0;
      for (; ; ) {
        this.iv[4] = u, this.iv[5] = u >>> 8, this.iv[6] = u >>> 16, this.iv[7] = u >>> 24, u += 1;
        const [o, s] = this.encrypt(n);
        if (!(o.isZero() || o.cmp(this.curve.n) >= 0) && !(s.isZero() || s.cmp(this.curve.n) >= 0)) {
          this.cache[0] = o, this.cache[1] = s;
          break;
        }
      }
    }
    generate(n) {
      return e(n >>> 0 === n), n & 1 && this.refresh(n >>> 1), this.cache[n & 1];
    }
  }
  return gu = m, gu;
}
var xu, n3;
function Zw() {
  if (n3) return xu;
  n3 = 1;
  const e = Nt(), c = Ww(), l = Xr();
  class w {
    constructor(f, n) {
      this.curve = f, this.hash = n, this.rng = new c(this.curve, this.encode.bind(this));
    }
    check() {
      if (this.curve.p.andln(3) !== 3)
        throw new Error(`Schnorr is not supported for ${this.curve.id}.`);
    }
    encode(f) {
      e(k.isBuffer(f));
      const { fieldSize: n } = this.curve;
      if (f.length === 1 + n)
        return f;
      if (f.length !== 1 + n * 2)
        throw new Error("Invalid point.");
      const u = k.alloc(1 + n);
      return u[0] = 2 | f[f.length - 1] & 1, f.copy(u, 1, 1, 1 + n), u;
    }
    hashInt(...f) {
      const n = new this.hash();
      n.init();
      for (const s of f)
        n.update(s);
      let u = n.final(this.curve.scalarSize);
      u.length > this.curve.scalarSize && (u = u.slice(0, this.curve.scalarSize));
      const o = l.decode(u, this.curve.endian);
      return o.iumaskn(this.curve.scalarBits), o.imod(this.curve.n);
    }
    hashNonce(f, n) {
      return this.hashInt(f, n);
    }
    hashChallenge(f, n, u) {
      return this.hashInt(f, this.encode(n), u);
    }
    sign(f, n) {
      return e(k.isBuffer(f)), this.check(), this._sign(f, n);
    }
    _sign(f, n) {
      const { n: u } = this.curve, o = this.curve.g, s = this.curve.decodeScalar(n);
      if (s.isZero() || s.cmp(u) >= 0)
        throw new Error("Invalid private key.");
      const i = o.mulBlind(s), p = this.hashNonce(n, f);
      if (p.isZero())
        throw new Error("Signing failed (k' = 0).");
      const g = o.mulBlind(p);
      g.isSquare() || p.ineg().imod(u);
      const S = g.encodeX(), y = i.encode(), b = this.hashChallenge(S, y, f), h = p.add(b.mul(s)).imod(u);
      return k.concat([S, this.curve.encodeScalar(h)]);
    }
    verify(f, n, u) {
      if (e(k.isBuffer(f)), e(k.isBuffer(n)), e(k.isBuffer(u)), this.check(), n.length !== this.curve.fieldSize + this.curve.scalarSize)
        return !1;
      try {
        return this._verify(f, n, u);
      } catch {
        return !1;
      }
    }
    _verify(f, n, u) {
      const { p: o, n: s } = this.curve, i = this.curve.g, p = n.slice(0, this.curve.fieldSize), g = n.slice(this.curve.fieldSize), S = this.curve.decodeField(p), y = this.curve.decodeScalar(g), b = this.curve.decodePoint(u);
      if (S.cmp(o) >= 0 || y.cmp(s) >= 0)
        return !1;
      const h = this.hashChallenge(p, u, f), a = i.jmulAdd(y, b, h.ineg().imod(s));
      return !(!a.isSquare() || !a.eqX(S));
    }
    verifyBatch(f) {
      e(Array.isArray(f)), this.check();
      for (const n of f) {
        e(Array.isArray(n) && n.length === 3);
        const [u, o, s] = n;
        if (e(k.isBuffer(u)), e(k.isBuffer(o)), e(k.isBuffer(s)), o.length !== this.curve.fieldSize + this.curve.scalarSize)
          return !1;
      }
      try {
        return this._verifyBatch(f);
      } catch {
        return !1;
      }
    }
    _verifyBatch(f) {
      const { n } = this.curve, u = this.curve.g, o = new Array(1 + f.length * 2), s = new Array(1 + f.length * 2), i = new l(0);
      this.rng.init(f), o[0] = u, s[0] = i;
      for (let p = 0; p < f.length; p++) {
        const [g, S, y] = f[p], b = S.slice(0, this.curve.fieldSize), h = S.slice(this.curve.fieldSize), a = this.curve.decodeSquare(b), E = this.curve.decodeScalar(h), H = this.curve.decodePoint(y);
        if (E.cmp(n) >= 0)
          return !1;
        const j = this.hashChallenge(b, y, g), G = this.rng.generate(p), N = j.mul(G).imod(n);
        i.iadd(E.mul(G)).imod(n), o[1 + p * 2 + 0] = a, s[1 + p * 2 + 0] = G, o[1 + p * 2 + 1] = H, s[1 + p * 2 + 1] = N;
      }
      return i.ineg().imod(n), this.curve.jmulAll(o, s).isInfinity();
    }
  }
  return xu = w, xu;
}
var wu, s3;
function Rp() {
  if (s3) return wu;
  s3 = 1;
  const e = Nt(), c = 281474976710656, l = k.from([0]), w = k.from([1]);
  class m {
    constructor(n, u, o, s) {
      e(n && typeof n.id == "string"), this.hash = n, this.minEntropy = n.id === "SHA1" ? 10 : 24, this.K = k.alloc(n.size), this.V = k.alloc(n.size), this.rounds = 0, u && this.init(u, o, s);
    }
    init(n, u, o) {
      u == null && (u = k.alloc(0)), o == null && (o = k.alloc(0)), e(k.isBuffer(n)), e(k.isBuffer(u)), e(k.isBuffer(o));
      for (let i = 0; i < this.V.length; i++)
        this.K[i] = 0, this.V[i] = 1;
      const s = k.concat([n, u, o]);
      if (s.length < this.minEntropy)
        throw new Error("Not enough entropy.");
      return this.update(s), this.rounds = 1, this;
    }
    reseed(n, u) {
      if (u == null && (u = k.alloc(0)), e(k.isBuffer(n)), e(k.isBuffer(u)), this.rounds === 0)
        throw new Error("DRBG not initialized.");
      const o = k.concat([n, u]);
      if (o.length < this.minEntropy)
        throw new Error("Not enough entropy.");
      return this.update(o), this.rounds = 1, this;
    }
    generate(n, u) {
      if (e(n >>> 0 === n), e(u == null || k.isBuffer(u)), this.rounds === 0)
        throw new Error("DRBG not initialized.");
      if (this.rounds > c)
        throw new Error("Reseed is required.");
      u && u.length > 0 && this.update(u);
      const o = Math.ceil(n / this.hash.size), s = k.alloc(o * this.hash.size);
      for (let i = 0; i < o; i++)
        this.V = this.mac(this.V), this.V.copy(s, i * this.hash.size);
      return this.update(u), this.rounds += 1, s.slice(0, n);
    }
    randomBytes(n) {
      return this.generate(n);
    }
    /*
     * Helpers
     */
    mac(n) {
      return this.hash.mac(n, this.K);
    }
    hmac() {
      return this.hash.hmac().init(this.K);
    }
    update(n) {
      e(n == null || k.isBuffer(n));
      const u = this.hmac();
      if (u.update(this.V), u.update(l), n && u.update(n), this.K = u.final(), this.V = this.mac(this.V), n && n.length > 0) {
        const o = this.hmac();
        o.update(this.V), o.update(w), o.update(n), this.K = o.final(), this.V = this.mac(this.V);
      }
      return this;
    }
  }
  return m.native = 0, wu = m, wu;
}
var tr = {}, o3;
function Qw() {
  if (o3) return tr;
  o3 = 1;
  const { custom: e } = vp(), c = Xr(), l = {
    AFFINE: 0,
    JACOBIAN: 1,
    PROJECTIVE: 2,
    EXTENDED: 3
  }, w = [
    -3,
    // -1 -1
    -1,
    // -1 0
    -5,
    // -1 1
    -7,
    // 0 -1
    0,
    // 0 0
    7,
    // 0 1
    5,
    // 1 -1
    1,
    // 1 0
    3
    // 1 1
  ];
  let m = 0;
  class f {
    constructor(r, x, O) {
      this.Point = null, this.id = null, this.uid = m++, this.ossl = null, this.type = "base", this.endian = "be", this.hash = null, this.prefix = null, this.context = !1, this.prime = null, this.p = null, this.red = null, this.fieldSize = 0, this.fieldBits = 0, this.adjustedSize = 0, this.signBit = 0, this.mask = 0, this.n = null, this.h = null, this.q = null, this.z = null, this.g = null, this.nh = null, this.scalarSize = 0, this.scalarBits = 0, this.zero = null, this.one = null, this.two = null, this.three = null, this.four = null, this.i2 = null, this.i3 = null, this.i4 = null, this.i6 = null, this.torsion = null, this.endo = null, this.hi = null, this._init(r, x, O);
    }
    _init(r, x, O) {
      I(typeof r == "function"), I(typeof x == "string"), I(O && typeof O == "object"), I(O.red == null || O.red instanceof c.Red), I(O.p != null, "Must pass a prime."), I(O.id == null || typeof O.id == "string"), I(O.ossl == null || typeof O.ossl == "string"), I(O.endian == null || typeof O.endian == "string"), I(O.hash == null || typeof O.hash == "string"), I(O.prefix == null || typeof O.prefix == "string"), I(O.context == null || typeof O.context == "boolean"), I(O.prime == null || typeof O.prime == "string"), I(O.torsion == null || Array.isArray(O.torsion)), this.Point = r, this.id = O.id || null, this.ossl = O.ossl || null, this.type = x, this.endian = O.endian || (x === "short" ? "be" : "le"), this.hash = O.hash || null, this.prefix = O.prefix ? k.from(O.prefix, "binary") : null, this.context = O.context || !1, this.prime = O.prime || null, this.p = c.fromJSON(O.p), O.red ? this.red = O.red : (this.red = O.prime ? c.red(O.prime) : c.mont(this.p), this.red.precompute()), this.fieldSize = this.p.byteLength(), this.fieldBits = this.p.bitLength(), this.adjustedSize = this.fieldSize + ((this.fieldBits & 7) === 0), this.signBit = this.adjustedSize * 8 - 1, this.mask = 255, (this.fieldBits & 7) !== 0 && (this.mask = (1 << (this.fieldBits & 7)) - 1), this.n = c.fromJSON(O.n || "0"), this.h = c.fromJSON(O.h || "1"), this.q = this.n.mul(this.h), this.z = c.fromJSON(O.z || "0").toRed(this.red), this.g = null, this.nh = this.n.ushrn(1), this.scalarSize = this.n.byteLength(), this.scalarBits = this.n.bitLength(), this.zero = new c(0).toRed(this.red), this.one = new c(1).toRed(this.red), this.two = new c(2).toRed(this.red), this.three = new c(3).toRed(this.red), this.four = new c(4).toRed(this.red), this.i2 = this.two.redInvert(), this.i3 = this.three.redInvert(), this.i4 = this.i2.redSqr(), this.i6 = this.i2.redMul(this.i3), this.torsion = new Array(this.h.word(0));
      for (let K = 0; K < this.torsion.length; K++)
        this.torsion[K] = this.point();
      return this.endo = null, this.hi = null, this._scale = C(this._scale, this), this.isIsomorphic = C(this.isIsomorphic, this), this.isIsogenous = C(this.isIsogenous, this), I(this.p.sign() > 0 && this.p.isOdd()), I(this.n.sign() >= 0), I(this.h.sign() > 0 && this.h.cmpn(255) <= 0), I(this.endian === "be" || this.endian === "le"), this;
    }
    _finalize(r) {
      if (I(r && typeof r == "object"), this.g = r.g ? this.pointFromJSON(r.g) : this.point(), r.torsion) {
        I(r.torsion.length === this.torsion.length);
        for (let x = 0; x < this.torsion.length; x++)
          this.torsion[x] = this.pointFromJSON(r.torsion[x]);
      }
      return this;
    }
    _findTorsion() {
      I(!this.n.isZero());
      const r = this.h.word(0), x = this.one.redNeg(), O = [this.point()], K = /* @__PURE__ */ new Set();
      let X = r;
      for (; O.length < X; ) {
        let P;
        x.redIAdd(this.one);
        try {
          P = this.pointFromX(x.clone());
        } catch {
          continue;
        }
        try {
          P = P.mul(this.n);
        } catch {
          X = 2;
          continue;
        }
        if (!P.isInfinity()) {
          P.normalize();
          for (const V of [P, P.neg()]) {
            const re = V.key();
            K.has(re) || (O.push(V), K.add(re));
          }
        }
      }
      for (O.sort((P, V) => P.cmp(V)); O.length < r; )
        O.push(this.point());
      return O;
    }
    _fixedMul(r, x) {
      I(r instanceof n), I(x instanceof c), I(r.pre && r.pre.windows);
      const { width: O, points: K } = r._getWindows(0, 0), X = 1 << O, V = (x.bitLength() + O - 1) / O >>> 0;
      let re = this.jpoint();
      for (let ce = 0; ce < V; ce++) {
        const de = x.bits(ce * O, O);
        re = re.add(K[ce * X + de]);
      }
      return x.isNeg() && (re = re.neg()), re;
    }
    _fixedNafMul(r, x) {
      I(r instanceof n), I(x instanceof c), I(r.pre && r.pre.doubles);
      const { step: O, points: K } = r._getDoubles(0, 0), X = Ee(x, 2, x.bitLength() + 1, O), P = ((1 << O + 1) - (O % 2 === 0 ? 2 : 1)) / 3;
      let V = this.jpoint(), re = this.jpoint();
      for (let ce = P; ce > 0; ce--) {
        for (let de = 0; de < X.length; de++) {
          const pe = X[de];
          pe === ce ? re = re.add(K[de]) : pe === -ce && (re = re.sub(K[de]));
        }
        V = V.add(re);
      }
      return V;
    }
    _wnafMul(r, x, O) {
      I(x instanceof n), I(O instanceof c);
      const { width: K, points: X } = x._safeNAF(r), P = ge(O, K, O.bitLength() + 1);
      let V = this.jpoint();
      for (let re = P.length - 1; re >= 0; re--) {
        const ce = P[re];
        re !== P.length - 1 && (V = V.dbl()), ce > 0 ? V = V.add(X[ce - 1 >> 1]) : ce < 0 && (V = V.sub(X[-ce - 1 >> 1]));
      }
      return V;
    }
    _wnafMulAdd(r, x, O) {
      I(r >>> 0 === r), I(Array.isArray(x)), I(Array.isArray(O)), I(x.length === O.length);
      const K = x.length, X = new Array(K), P = new Array(K);
      let V = 0;
      for (let se = 0; se < K; se++) {
        const Z = x[se], ee = O[se];
        if (I(Z instanceof n), I(ee instanceof c), se > 0 && Z.type !== x[se - 1].type)
          throw new Error("Cannot mix points.");
        X[se] = null, P[se] = null, V = Math.max(V, ee.bitLength() + 1);
      }
      let re = null, ce = null, de = 0;
      for (let se = 0; se < K; se++) {
        const Z = x[se], ee = O[se], me = Z._getNAF(0);
        if (me) {
          X[de] = me.points, P[de] = ge(ee, me.width, V), de += 1;
          continue;
        }
        if (!re) {
          re = Z, ce = ee;
          continue;
        }
        X[de] = re._getJNAF(Z), P[de] = z(ce, ee, V), re = null, ce = null, de += 1;
      }
      if (re) {
        const se = re._safeNAF(r);
        X[de] = se.points, P[de] = ge(ce, se.width, V), de += 1;
      }
      let pe = this.jpoint();
      for (let se = V - 1; se >= 0; se--) {
        se !== V - 1 && (pe = pe.dbl());
        for (let Z = 0; Z < de; Z++) {
          const ee = P[Z][se];
          ee > 0 ? pe = pe.add(X[Z][ee - 1 >> 1]) : ee < 0 && (pe = pe.sub(X[Z][-ee - 1 >> 1]));
        }
      }
      return pe;
    }
    _endoWnafMulAdd(r, x) {
      throw new Error("Not implemented.");
    }
    _scale(r, x) {
      switch (I(r instanceof f), I(r.p.eq(this.p)), r.type) {
        case "short":
          return this._scaleShort(r, x);
        case "mont":
          return this._scaleMont(r, x);
        case "edwards":
          return this._scaleEdwards(r, x);
        default:
          throw new Error("Not implemented.");
      }
    }
    _scaleShort(r, x) {
      throw new Error("Not implemented.");
    }
    _scaleMont(r, x) {
      throw new Error("Not implemented.");
    }
    _scaleEdwards(r, x) {
      throw new Error("Not implemented.");
    }
    isElliptic() {
      throw new Error("Not implemented.");
    }
    jinv() {
      throw new Error("Not implemented.");
    }
    isComplete() {
      return !1;
    }
    precompute(r) {
      return I(!this.g.isInfinity(), "Must have base point."), I(!this.n.isZero(), "Must have order."), this.g.precompute(this.n.bitLength(), r), this;
    }
    scalar(r, x, O) {
      const K = new c(r, x, O);
      return I(!K.red), this.n.isZero() ? K : K.imod(this.n);
    }
    field(r, x, O) {
      const K = c.cast(r, x, O);
      return K.red ? K.forceRed(this.red) : K.toRed(this.red);
    }
    point(r, x) {
      throw new Error("Not implemented.");
    }
    jpoint(r, x, O) {
      throw new Error("Not implemented.");
    }
    xpoint(r, x) {
      throw new Error("Not implemented.");
    }
    cpoint(r, x, O, K) {
      if (I(r instanceof c), I(x instanceof c), I(O instanceof c), I(K instanceof c), x.isZero() || K.isZero())
        return this.point();
      const X = x.redMul(K).redInvert(), P = r.redMul(K).redMul(X), V = O.redMul(x).redMul(X);
      return this.point(P, V);
    }
    solveX2(r) {
      throw new Error("Not implemented.");
    }
    solveX(r) {
      return this.solveX2(r).redSqrt();
    }
    solveY2(r) {
      throw new Error("Not implemented.");
    }
    solveY(r) {
      return this.solveY2(r).redSqrt();
    }
    validate(r) {
      throw new Error("Not implemented.");
    }
    pointFromX(r, x) {
      throw new Error("Not implemented.");
    }
    pointFromY(r, x) {
      throw new Error("Not implemented.");
    }
    isIsomorphic(r) {
      throw new Error("Not implemented.");
    }
    isIsogenous(r) {
      throw new Error("Not implemented.");
    }
    pointFromShort(r) {
      throw new Error("Not implemented.");
    }
    pointFromMont(r, x) {
      throw new Error("Not implemented.");
    }
    pointFromEdwards(r) {
      throw new Error("Not implemented.");
    }
    pointFromUniform(r) {
      throw new Error("Not implemented.");
    }
    pointToUniform(r) {
      throw new Error("Not implemented.");
    }
    pointFromHash(r, x = !1) {
      if (I(k.isBuffer(r)), I(typeof x == "boolean"), r.length !== this.fieldSize * 2)
        throw new Error("Invalid hash size.");
      const O = r.slice(0, this.fieldSize), K = r.slice(this.fieldSize), X = this.decodeUniform(O), P = this.decodeUniform(K), V = this.pointFromUniform(X), re = this.pointFromUniform(P), ce = V.add(re);
      return x ? ce.mulH() : ce;
    }
    pointToHash(r, x, O) {
      I(r instanceof this.Point), I(x >>> 0 === x);
      const K = x % this.torsion.length, X = r.add(this.torsion[K]);
      for (; ; ) {
        const P = this.randomField(O), V = this.pointFromUniform(P);
        if (V.neg().eq(V))
          continue;
        const re = X.sub(V), ce = J(O);
        let de;
        try {
          de = this.pointToUniform(re, ce & 15);
        } catch (Z) {
          if (Z.message === "Invalid point.")
            continue;
          throw Z;
        }
        const pe = this.encodeUniform(P, ce >>> 8), se = this.encodeUniform(de, ce >>> 16);
        return k.concat([pe, se]);
      }
    }
    randomScalar(r) {
      const x = this.n.isZero() ? this.p : this.n;
      return c.random(r, 1, x);
    }
    randomField(r) {
      return c.random(r, 1, this.p).toRed(this.red);
    }
    randomPoint(r) {
      let x;
      for (; ; ) {
        const O = this.randomField(r), K = (J(r) & 1) !== 0;
        try {
          x = this.pointFromX(O, K);
        } catch {
          continue;
        }
        return I(x.validate()), x.mulH();
      }
    }
    mulAll(r, x) {
      return this.jmulAll(r, x);
    }
    jmulAll(r, x) {
      return I(Array.isArray(r)), I(r.length === 0 || r[0] instanceof n), this.endo && r.length > 0 && r[0].type === l.AFFINE ? this._endoWnafMulAdd(r, x) : this._wnafMulAdd(5, r, x);
    }
    mulH(r) {
      return I(r instanceof c), this.imulH(r.clone());
    }
    imulH(r) {
      I(r instanceof c), I(!r.red);
      const x = this.h.word(0);
      if ((x & x - 1) === 0) {
        const O = this.h.bitLength();
        return r.iushln(O - 1).imod(this.n);
      }
      return r.imuln(x).imod(this.n);
    }
    normalizeAll(r) {
      I(Array.isArray(r));
      const x = r.length, O = new Array(x);
      for (let P = 0; P < x; P++) {
        const V = r[P];
        if (I(V instanceof n), I(V.curve === this), V.type === l.AFFINE) {
          O[P] = this.one;
          continue;
        }
        O[P] = V.z;
      }
      const K = this.red.invertAll(O), X = new Array(x);
      for (let P = 0; P < x; P++)
        X[P] = r[P].scale(K[P]);
      return X;
    }
    affinizeAll(r) {
      return this.normalizeAll(r);
    }
    clamp(r) {
      I(k.isBuffer(r)), I(r.length === this.scalarSize), I(this.scalarSize <= this.fieldSize);
      let x = this.fieldBits & 7 || 8, O = 0, K = this.scalarSize - 1;
      return this.endian === "be" && ([O, K] = [K, O]), this.scalarSize < this.fieldSize && (x = 8), r[O] &= -this.h.word(0) & 255, r[K] &= (1 << x) - 1, r[K] |= 1 << x - 1, r;
    }
    splitHash(r) {
      I(k.isBuffer(r)), I(r.length === this.adjustedSize * 2), I(this.scalarSize <= this.adjustedSize);
      let x = 0;
      this.endian === "be" && (x = this.adjustedSize - this.scalarSize);
      const O = r.slice(x, x + this.scalarSize), K = r.slice(this.adjustedSize);
      return this.clamp(O), [O, K];
    }
    encodeField(r) {
      return I(r instanceof c), I(!r.red), r.encode(this.endian, this.fieldSize);
    }
    decodeField(r) {
      if (I(k.isBuffer(r)), r.length !== this.fieldSize)
        throw new Error("Invalid field element size.");
      return c.decode(r, this.endian);
    }
    encodeAdjusted(r) {
      return I(r instanceof c), I(!r.red), r.encode(this.endian, this.adjustedSize);
    }
    decodeAdjusted(r) {
      if (I(k.isBuffer(r)), r.length !== this.adjustedSize)
        throw new Error("Invalid field element size.");
      return c.decode(r, this.endian);
    }
    encodeScalar(r) {
      return I(r instanceof c), I(!r.red), r.encode(this.endian, this.scalarSize);
    }
    decodeScalar(r) {
      if (I(k.isBuffer(r)), r.length !== this.scalarSize)
        throw new Error("Invalid scalar size.");
      return c.decode(r, this.endian);
    }
    encodeClamped(r) {
      return this.clamp(this.encodeScalar(r));
    }
    decodeClamped(r) {
      if (I(k.isBuffer(r)), r.length !== this.scalarSize)
        throw new Error("Invalid scalar size.");
      const x = this.clamp(k.from(r));
      return c.decode(x, this.endian);
    }
    encodeUniform(r, x) {
      I(r instanceof c), I(x >>> 0 === x);
      const O = this.endian === "le" ? this.fieldSize - 1 : 0, K = r.fromRed().encode(this.endian, this.fieldSize);
      return K[O] |= x & ~this.mask & 255, K;
    }
    decodeUniform(r) {
      if (I(k.isBuffer(r)), r.length !== this.fieldSize)
        throw new Error("Invalid field size.");
      const x = c.decode(r, this.endian);
      return x.iumaskn(this.fieldBits), x.toRed(this.red);
    }
    encodePoint(r, x) {
      return I(r instanceof n), r.encode(x);
    }
    decodePoint(r) {
      throw new Error("Not implemented.");
    }
    encodeX(r) {
      throw new Error("Not implemented.");
    }
    decodeX(r) {
      throw new Error("Not implemented.");
    }
    decodeEven(r) {
      throw new Error("Not implemented.");
    }
    decodeSquare(r) {
      throw new Error("Not implemented.");
    }
    toShort() {
      throw new Error("Not implemented.");
    }
    toMont(r) {
      throw new Error("Not implemented.");
    }
    toEdwards(r) {
      throw new Error("Not implemented.");
    }
    pointToJSON(r, x) {
      return I(r instanceof n), r.toJSON(x);
    }
    pointFromJSON(r) {
      throw new Error("Not implemented.");
    }
    toJSON(r) {
      let x, O, K, X, P;
      return this.type === "edwards" && (x = this.prefix ? this.prefix.toString() : null, O = this.context), this.n.isZero() || (K = this.n.toJSON()), this.z.isZero() || (X = this.z.fromRed(), this.z.redIsHigh() && X.isub(this.p), X = X.toString(16)), this.endo && (P = this.endo.toJSON()), {
        id: this.id,
        ossl: this.ossl,
        type: this.type,
        endian: this.endian,
        hash: this.hash,
        prefix: x,
        context: O,
        prime: this.prime,
        p: this.p.toJSON(),
        a: void 0,
        b: void 0,
        d: void 0,
        n: K,
        h: this.h.toString(16),
        s: void 0,
        z: X,
        c: void 0,
        g: this.g.toJSON(r),
        endo: P
      };
    }
    static fromJSON(r) {
      return new this(r);
    }
  }
  class n {
    constructor(r, x) {
      I(r instanceof f), I(x >>> 0 === x), this.curve = r, this.type = x, this.pre = null;
    }
    _init() {
      throw new Error("Not implemented.");
    }
    _safeNAF(r) {
      if (I(r >>> 0 === r), this.pre && this.pre.naf)
        return this.pre.naf;
      if (r === 0)
        return null;
      const x = 1 << r - 2, O = new Array(x), K = this.toJ(), X = x === 1 ? null : K.dbl();
      O[0] = K;
      for (let P = 1; P < x; P++)
        O[P] = O[P - 1].add(X);
      return new h(r, O);
    }
    _getNAF(r) {
      if (I(r >>> 0 === r), this.pre && this.pre.naf)
        return this.pre.naf;
      if (r === 0)
        return null;
      const x = this._safeNAF(r).points, O = this.curve.affinizeAll(x);
      return new h(r, O);
    }
    _getWindows(r, x) {
      if (I(r >>> 0 === r), I(x >>> 0 === x), this.pre && this.pre.windows)
        return this.pre.windows;
      if (r === 0)
        return null;
      const O = 1 << r, K = (x + r - 1) / r >>> 0, X = new Array(K * O);
      let P = this.toJ();
      for (let re = 0; re < K; re++) {
        X[re * O] = this.curve.jpoint();
        for (let ce = 1; ce < O; ce++)
          X[re * O + ce] = X[re * O + ce - 1].add(P);
        P = P.dblp(r);
      }
      const V = this.curve.affinizeAll(X);
      return new a(r, x, V);
    }
    _getDoubles(r, x) {
      if (I(r >>> 0 === r), I(x >>> 0 === x), this.pre && this.pre.doubles)
        return this.pre.doubles;
      if (r === 0)
        return null;
      const O = Math.ceil(x / r) + 1, K = new Array(O);
      let X = this.toJ(), P = 0;
      K[P++] = X;
      for (let re = 0; re < x; re += r) {
        for (let ce = 0; ce < r; ce++)
          X = X.dbl();
        K[P++] = X;
      }
      I(P === O);
      const V = this.curve.affinizeAll(K);
      return new E(r, V);
    }
    _getBeta() {
      return null;
    }
    _getBlinding(r) {
      if (this.pre && this.pre.blinding)
        return this.pre.blinding;
      if (!r || this.curve.n.isZero())
        return null;
      const x = this.curve.randomScalar(r), O = this.mul(x);
      return new H(x, O);
    }
    _hasWindows(r) {
      if (I(r instanceof c), !this.pre || !this.pre.windows)
        return !1;
      const { width: x, bits: O } = this.pre.windows, K = (O + x - 1) / x >>> 0;
      return r.bitLength() <= K * x;
    }
    _hasDoubles(r) {
      if (I(r instanceof c), !this.pre || !this.pre.doubles)
        return !1;
      const { step: x, points: O } = this.pre.doubles, K = r.bitLength() + 1;
      return O.length >= Math.ceil(K / x) + 1;
    }
    _getJNAF(r) {
      return I(r instanceof n), I(r.type === this.type), [
        this,
        // 1
        this.add(r),
        // 3
        this.sub(r),
        // 5
        r
        // 7
      ];
    }
    _blind(r, x) {
      if (I(r instanceof c), I(!r.red), this.pre && this.pre.blinding) {
        const { blind: K, unblind: X } = this.pre.blinding, P = r.sub(K);
        return [this, P, X];
      }
      if (!x)
        return [this, r, null];
      if (this.pre) {
        if (this.curve.n.isZero())
          return [this, r, null];
        const P = this.curve.randomScalar(x).mul(this.curve.n).iadd(r);
        return [this, P, null];
      }
      return [this.randomize(x), r, null];
    }
    clone() {
      throw new Error("Not implemented.");
    }
    precompute(r, x) {
      return I(r >>> 0 === r), this.pre || (this.pre = new b()), this.pre.naf || (this.pre.naf = this._getNAF(9)), this.pre.doubles || (this.pre.doubles = this._getDoubles(4, r + 1)), this.pre.beta || (this.pre.beta = this._getBeta()), this.pre.blinding || (this.pre.blinding = this._getBlinding(x)), this;
    }
    validate() {
      return this.curve.validate(this);
    }
    normalize() {
      return this;
    }
    scale(r) {
      throw new Error("Not implemented.");
    }
    randomize(r) {
      const x = this.curve.randomField(r);
      return this.scale(x);
    }
    neg() {
      throw new Error("Not implemented.");
    }
    add(r) {
      throw new Error("Not implemented.");
    }
    sub(r) {
      return I(r instanceof n), this.add(r.neg());
    }
    dbl() {
      throw new Error("Not implemented.");
    }
    dblp(r) {
      I(r >>> 0 === r);
      let x = this;
      for (let O = 0; O < r; O++)
        x = x.dbl();
      return x;
    }
    diffAddDbl(r, x) {
      throw new Error("Not implemented.");
    }
    getX() {
      throw new Error("Not implemented.");
    }
    getY() {
      throw new Error("Not implemented.");
    }
    eq(r) {
      throw new Error("Not implemented.");
    }
    cmp(r) {
      throw new Error("Not implemented.");
    }
    isInfinity() {
      throw new Error("Not implemented.");
    }
    isOrder2() {
      throw new Error("Not implemented.");
    }
    isOdd() {
      throw new Error("Not implemented.");
    }
    isEven() {
      throw new Error("Not implemented.");
    }
    isSquare() {
      throw new Error("Not implemented.");
    }
    eqX(r) {
      throw new Error("Not implemented.");
    }
    eqR(r) {
      throw new Error("Not implemented.");
    }
    isSmall() {
      return this.isInfinity() ? !1 : this.jmulH().isInfinity();
    }
    hasTorsion() {
      return this.isInfinity() ? !1 : !this.jmul(this.curve.n).isInfinity();
    }
    order() {
      const { h: r, n: x } = this.curve;
      let O = this.toJ(), K = new c(1);
      for (; !O.isInfinity(); ) {
        if (K.iaddn(1), K.cmp(r) > 0) {
          K = x.clone();
          break;
        }
        O = O.add(this);
      }
      return K;
    }
    mul(r) {
      return this.jmul(r);
    }
    muln(r) {
      return this.jmuln(r);
    }
    mulBlind(r, x) {
      return this.jmulBlind(r, x);
    }
    mulAdd(r, x, O) {
      return this.jmulAdd(r, x, O);
    }
    mulH() {
      return this.jmulH();
    }
    div(r) {
      return this.jdiv(r);
    }
    divn(r) {
      return this.jdivn(r);
    }
    divH() {
      return this.jdivH();
    }
    jmul(r) {
      return this._hasDoubles(r) ? this.curve._fixedNafMul(this, r) : this.curve.endo && this.type === l.AFFINE ? this.curve._endoWnafMulAdd([this], [r]) : this.curve._wnafMul(5, this, r);
    }
    jmuln(r) {
      return I((r | 0) === r), this.jmul(new c(r));
    }
    jmulBlind(r, x = null) {
      const [O, K, X] = this._blind(r, x), P = O.jmul(K);
      return X ? P.add(X) : P;
    }
    jmulAdd(r, x, O) {
      return this.curve.endo && this.type === l.AFFINE ? this.curve._endoWnafMulAdd([this, x], [r, O]) : this.curve._wnafMulAdd(5, [this, x], [r, O]);
    }
    jmulH() {
      const r = this.curve.h.word(0);
      if ((r & r - 1) === 0) {
        const x = this.curve.h.bitLength();
        return this.toJ().dblp(x - 1);
      }
      return this.jmul(this.curve.h);
    }
    jdiv(r) {
      return I(r instanceof c), I(!r.red), this.jmul(r.invert(this.curve.n));
    }
    jdivn(r) {
      return I(!this.curve.n.isZero()), this.curve.h.cmpn(r) === 0 ? this.jdivH() : this.jdiv(new c(r));
    }
    jdivH() {
      return this.curve.n.isZero() ? this.toJ() : this.curve.h.cmpn(1) === 0 ? this.toJ() : (this.curve.hi === null && (this.curve.hi = this.curve.h.invert(this.curve.n)), this.jmul(this.curve.hi));
    }
    toP() {
      return this.normalize();
    }
    toJ() {
      return this;
    }
    toX() {
      return this;
    }
    key() {
      if (this.isInfinity())
        return `${this.curve.uid}:oo`;
      this.normalize();
      const r = this.getX().toString(16), x = this.getY().toString(16);
      return `${this.curve.uid}:${r},${x}`;
    }
    encode(r) {
      throw new Error("Not implemented.");
    }
    static decode(r, x) {
      throw new Error("Not implemented.");
    }
    encodeX() {
      throw new Error("Not implemented.");
    }
    static decodeX(r, x) {
      throw new Error("Not implemented.");
    }
    static decodeEven(r, x) {
      throw new Error("Not implemented.");
    }
    static decodeSquare(r, x) {
      throw new Error("Not implemented.");
    }
    toJSON(r) {
      throw new Error("Not implemented.");
    }
    static fromJSON(r, x) {
      throw new Error("Not implemented.");
    }
    [e]() {
      return "<Point>";
    }
  }
  class u extends f {
    constructor(r) {
      super(o, "short", r), this.a = c.fromJSON(r.a).toRed(this.red), this.b = c.fromJSON(r.b).toRed(this.red), this.c = c.fromJSON(r.c || "0").toRed(this.red), this.ai = this.a.isZero() ? this.zero : this.a.redInvert(), this.zi = this.z.isZero() ? this.zero : this.z.redInvert(), this.zeroA = this.a.isZero(), this.threeA = this.a.eq(this.three.redNeg()), this.redN = this.n.toRed(this.red), this.pmodn = this.p.clone(), this.highOrder = this.n.cmp(this.p) >= 0, this.smallGap = !1, this._finalize(r);
    }
    _finalize(r) {
      return super._finalize(r), r.endo != null ? this.endo = j.fromJSON(this, r.endo) : this.endo = this._getEndomorphism(), this.n.isZero() || (this.pmodn = this.p.mod(this.n), this.smallGap = this.p.div(this.n).cmpn(1) <= 0), this;
    }
    static _isomorphism(r, x, O, K) {
      if (I(r instanceof c), I(x instanceof c), I(O instanceof c), I(K == null || typeof K == "boolean"), I(!r.isZero() || !x.isZero()), O.isZero())
        throw new Error("Invalid coefficient.");
      if (r.isZero()) {
        const pe = O, se = pe.redDiv(x), Z = U(se);
        return I(Z.redJacobi() === 1), [r.clone(), pe.clone()];
      }
      if (x.isZero()) {
        const pe = O, Z = pe.redDiv(r).redSqrt();
        if (Z.redJacobi() !== 1 && Z.redINeg(), Z.redJacobi() !== 1)
          throw new Error("Invalid `a` coefficient.");
        return [pe.clone(), x.clone()];
      }
      const X = O, P = X.redDiv(r), V = P.redSqrt();
      if (K != null ? V.redIsOdd() !== K && V.redINeg() : V.redJacobi() !== 1 && V.redINeg(), V.redJacobi() !== 1)
        throw new Error("Invalid `a` coefficient.");
      const re = P.redMul(V), ce = r.redMul(P), de = x.redMul(re);
      return I(ce.eq(X)), [ce, de];
    }
    _short(r, x) {
      return u._isomorphism(this.a, this.b, r, x);
    }
    _mont(r, x) {
      const [O, K] = this._findRS(x), X = K.redInvert(), P = O.redMuln(3).redMul(X);
      return r != null ? i._isomorphism(P, X, r) : [P, X];
    }
    _edwards(r, x) {
      const [O, K] = this._findRS(x), X = O.redMuln(3), P = K.redMuln(2), V = X.redAdd(P), re = X.redSub(P);
      return r != null ? S._isomorphism(V, re, r) : [V, re];
    }
    _findRS(r) {
      I(r == null || typeof r == "boolean"), I(this.h.word(0) >= 4), I(!this.n.isZero());
      const x = this.one.redNeg();
      let O;
      for (; ; ) {
        x.redIAdd(this.one);
        try {
          O = this.pointFromX(x.clone());
        } catch {
          continue;
        }
        if (O = O.mul(this.n), !O.isInfinity() && O.y.isZero())
          break;
      }
      const K = O.x, P = K.redSqr().redMuln(3).redIAdd(this.a).redSqrt();
      return r != null && P.redIsOdd() !== r && P.redINeg(), [K, P];
    }
    _scale0(r, x) {
      if (I(this.a.isZero() === r.isZero()), I(this.b.isZero() === x.isZero()), this.a.isZero()) {
        const re = this.b.redDiv(this.field(x)), ce = U(re), de = ce.redSqrt(), pe = ce.redMul(de);
        return I(pe.redSqr().eq(re)), I(!de.isZero()), [ce, pe];
      }
      if (this.b.isZero()) {
        const re = this.a.redDiv(this.field(r)), ce = re.redSqrt();
        ce.redJacobi() !== 1 && ce.redINeg();
        const de = ce.redSqrt(), pe = ce.redMul(de);
        return I(pe.redMul(de).eq(re)), I(!de.isZero()), [ce, pe];
      }
      const O = this.a.redDiv(this.field(r)), K = this.b.redDiv(this.field(x)), X = O.redSqrt();
      O.redMul(X).eq(K) || X.redINeg(), I(O.redMul(X).eq(K));
      const P = X.redSqrt(), V = X.redMul(P);
      return I(!P.isZero()), [X, V];
    }
    _scale1(r, x) {
      const O = this.g.x.redDiv(this.field(r)), K = this.g.y.redDiv(this.field(x)), X = O.redSqrt();
      return O.redMul(X).eq(K) || X.redINeg(), I(O.redMul(X).eq(K)), I(!X.isZero()), [O, K];
    }
    _scaleShort(r) {
      return I(r instanceof u), this.g.isInfinity() || r.g.isInfinity() ? this._scale0(r.a, r.b) : this._scale1(r.g.x, r.g.y);
    }
    _scaleMont(r) {
      if (I(r instanceof i), this.g.isInfinity() || r.g.isInfinity()) {
        const [P, V] = r._short();
        return this._scale0(P, V);
      }
      const { x, y: O } = r.g, K = x.redAdd(r.a3).redMul(r.bi), X = O.redMul(r.bi);
      return this._scale1(K, X);
    }
    _scaleEdwards(r) {
      if (I(r instanceof S), this.g.isInfinity() || r.g.isInfinity()) {
        const [_e, ke] = r._short();
        return this._scale0(_e, ke);
      }
      const { x, y: O, z: K } = r.g, X = r.a.redMuln(5), P = r.d.redMuln(5), V = r.d.redSub(r.a), re = P.redSub(r.a), ce = r.d.redSub(X), de = O.redAdd(K), pe = O.redSub(K), se = re.redMul(O).redIAdd(ce.redMul(K)), Z = pe.redMuln(12), ee = V.redMul(de).redMul(K), me = pe.redMul(x).redIMuln(4), Ae = Z.redMul(me).redInvert(), Oe = se.redMul(me).redMul(Ae), ye = ee.redMul(Z).redMul(Ae);
      return this._scale1(Oe, ye);
    }
    _getEndomorphism(r = 0) {
      if (this.n.isZero() || this.g.isInfinity() || !this.zeroA || this.p.modrn(3) !== 1 || this.n.modrn(3) !== 1)
        return null;
      const [x, O] = this._getEndoRoots(this.p), K = [x, O][r & 1].toRed(this.red), [X, P] = this._getEndoRoots(this.n), V = this.point(this.g.x.redMul(K), this.g.y);
      let re;
      this.g.mul(X).eq(V) ? re = X : (I(this.g.mul(P).eq(V)), re = P);
      const ce = this._getEndoBasis(re), de = this._getEndoPrecomp(ce);
      return new j(K, re, ce, de);
    }
    _getEndoRoots(r) {
      const x = r === this.p ? this.red : c.mont(r), O = new c(2).toRed(x), K = new c(3).toRed(x), X = O.redInvert(), P = K.redNeg().redSqrt().redMul(X), V = P.redNeg(), re = P.redSub(X).fromRed(), ce = V.redSub(X).fromRed();
      return [re, ce].sort(c.cmp);
    }
    _getEndoBasis(r) {
      const [x, O, K, X, P, V] = this._egcdSqrt(r), re = K, ce = X.neg(), de = x.sqr().iadd(O.sqr()), pe = P.sqr().iadd(V.sqr());
      let se, Z;
      return de.cmp(pe) <= 0 ? (se = x, Z = O.neg()) : (se = P, Z = V.neg()), [
        new G(re, ce),
        new G(se, Z)
      ];
    }
    _egcdSqrt(r) {
      I(r instanceof c), I(!r.red), I(r.sign() > 0), I(this.n.sign() > 0);
      const x = this.n.ushrn(this.n.bitLength() >>> 1);
      let O = r, K = this.n.clone(), X = new c(1), P = new c(0), V = new c(0), re = new c(1), ce, de, pe, se, Z = 0, ee = 0, me;
      for (; !O.isZero() && Z < 2; ) {
        const ye = K.quo(O), _e = K.sub(ye.mul(O)), ke = V.sub(ye.mul(X)), Me = re.sub(ye.mul(P));
        ee === 0 && _e.cmp(x) < 0 && (ce = me, de = X, pe = _e, se = ke, ee = 1), me = _e, K = O, O = _e, V = X, X = ke, re = P, P = Me, Z += ee;
      }
      return I(ee !== 0, "Could not find r < sqrt(n)."), [
        ce,
        de,
        pe,
        se,
        V,
        X
      ];
    }
    _getEndoPrecomp(r) {
      I(Array.isArray(r)), I(r.length === 2), I(r[0] instanceof G), I(r[1] instanceof G);
      const [x, O] = r, K = x.a.mul(O.b).isub(x.b.mul(O.a)), X = K.bitLength(), P = X >= 160;
      I(K.eq(this.n));
      let V = X + Math.ceil(X / 2) + 1, re, ce;
      for (P && (V -= V & 63); V > X && (re = O.b.ushln(V).divRound(K), ce = x.b.ushln(V).divRound(K), !(re.ucmp(K) < 0 && ce.ucmp(K) < 0)); )
        P ? V -= 64 : V -= 1;
      if (V <= X)
        throw new Error("Could not calculate g1 and g2.");
      return [V, re, ce];
    }
    _endoSplit(r) {
      I(r instanceof c), I(!r.red), I(!this.n.isZero());
      const [x, O] = this.endo.basis, K = O.b.mul(r).divRound(this.n), X = x.b.neg().mul(r).divRound(this.n), P = K.mul(x.a), V = X.mul(O.a), re = K.ineg().mul(x.b), ce = X.mul(O.b), de = r.sub(P).isub(V), pe = re.isub(ce);
      return [de, pe];
    }
    _endoBeta(r) {
      return I(r instanceof o), [r, r._getBeta()];
    }
    _endoWnafMulAdd(r, x) {
      I(Array.isArray(r)), I(Array.isArray(x)), I(r.length === x.length), I(this.endo != null);
      const O = r.length, K = new Array(O * 2), X = new Array(O * 2);
      for (let P = 0; P < O; P++) {
        const [V, re] = this._endoBeta(r[P]), [ce, de] = this._endoSplit(x[P]);
        K[P * 2 + 0] = V, X[P * 2 + 0] = ce, K[P * 2 + 1] = re, X[P * 2 + 1] = de;
      }
      return this._wnafMulAdd(5, K, X);
    }
    _sswu(r) {
      const { b: x, z: O, ai: K, zi: X, one: P } = this, V = O.redSqr(), re = x.redNeg().redMul(K), ce = x.redMul(X).redMul(K), de = r.redSqr(), pe = de.redSqr(), se = V.redMul(pe).redIAdd(O.redMul(de)), Z = se.isZero() ? se : se.redInvert(), ee = Z.isZero() ? ce : re.redMul(P.redAdd(Z)), me = O.redMul(de).redMul(ee), Ae = this.solveY2(ee), Oe = this.solveY2(me), ye = Ae.redIsSquare() | 0, _e = [ee, me][ye ^ 1], ke = [Ae, Oe][ye ^ 1].redSqrt();
      return ke.redIsOdd() !== r.redIsOdd() && ke.redINeg(), this.point(_e, ke);
    }
    _sswui(r, x) {
      const { a: O, b: K, z: X } = this, { x: P, y: V } = r, re = x & 3, ce = O.redSqr().redMul(P.redSqr()), de = O.redMul(K).redMul(P).redIMuln(2), pe = K.redSqr().redMuln(3), se = O.redMul(P).redIAdd(K), Z = ce.redISub(de).redISub(pe).redSqrt(), ee = se.redSub(Z).redINeg(), me = se.redAdd(Z).redINeg(), Ae = se.redMul(X).redIMuln(2), Oe = K.redMul(X).redIMuln(2), ye = [ee, me][re & 1], _e = [Ae, Oe][re >>> 1], ke = ye.redDivSqrt(_e);
      return ke.redIsOdd() !== V.redIsOdd() && ke.redINeg(), ke;
    }
    _svdwf(r) {
      const { c: x, z: O, zi: K, i2: X, i3: P } = this, V = this.solveY2(O), re = P.redMul(K.redSqr()), ce = r.redSqr(), de = ce.redSqr(), pe = ce.redAdd(V), se = ce.redMul(pe), Z = se.isZero() ? se : se.redInvert(), ee = de.redMul(Z).redMul(x), me = pe.redSqr().redMul(pe), Ae = x.redSub(O).redMul(X).redISub(ee), Oe = ee.redSub(x.redAdd(O).redMul(X)), ye = O.redSub(me.redMul(Z).redMul(re)), _e = this.solveY2(Ae), ke = this.solveY2(Oe), Me = this.solveY2(ye), De = _e.redJacobi() | 1, Ne = ke.redJacobi() | 1, $e = t((De - 1) * Ne, 3), bt = [Ae, Oe, ye][$e], Ve = [_e, ke, Me][$e];
      return [bt, Ve];
    }
    _svdw(r) {
      const [x, O] = this._svdwf(r), K = O.redSqrt();
      return K.redIsOdd() !== r.redIsOdd() && K.redINeg(), this.point(x, K);
    }
    _svdwi(r, x) {
      const { b: O, c: K, z: X, zero: P, two: V } = this, { x: re, y: ce } = r, de = x & 3, pe = X.redSqr(), se = pe.redMul(X), Z = pe.redSqr(), ee = se.redAdd(O), me = ee.redMuln(2), Ae = re.redSqr(), Oe = re.redMuln(2).redIAdd(X), ye = re.redMul(pe), _e = K.redSub(Oe), ke = K.redAdd(Oe), Me = Ae.redMul(pe).redIAdd(Z).redIMuln(9), De = re.redMul(se).redIMuln(18), Ne = ee.redMul(re.redSub(X)).redIMuln(12), bt = (de >= 2 ? Me.redISub(De).redIAdd(Ne).redSqrt() : P).redMul(X), Ve = se.redISub(ye).redIMuln(3).redISub(me), je = ee.redMul(_e), _t = ee.redMul(ke), Je = Ve.redAdd(bt), Ye = Ve.redSub(bt), Ot = V, We = [je, _t, Je, Ye][de], Ze = [ke, _e, Ot, Ot][de], Tt = We.redDivSqrt(Ze), [Qe] = this._svdwf(Tt);
      if (!Qe.eq(re))
        throw new Error("Invalid point.");
      return Tt.redIsOdd() !== ce.redIsOdd() && Tt.redINeg(), Tt;
    }
    isElliptic() {
      const { a: r, b: x } = this, K = r.redSqr().redMul(r);
      return !x.redSqr().redMuln(27).redIAdd(K.redMuln(4)).isZero();
    }
    jinv() {
      const { a: r, b: x } = this, K = r.redSqr().redMul(r), X = x.redSqr(), P = K.redMuln(4), V = P.redMuln(1728), re = X.redMuln(27).redIAdd(P);
      if (re.isZero())
        throw new Error("Curve is not elliptic.");
      return V.redDiv(re).fromRed();
    }
    point(r, x) {
      return new o(this, r, x);
    }
    jpoint(r, x, O) {
      return new s(this, r, x, O);
    }
    solveX(r) {
      if (I(r instanceof c), !this.a.isZero())
        throw new Error("Not implemented.");
      const O = r.redSqr().redSub(this.b);
      return B(O);
    }
    solveY2(r) {
      I(r instanceof c);
      const O = r.redSqr().redMul(r).redIAdd(this.b);
      return this.zeroA || (this.threeA ? O.redIAdd(r.redMuln(-3)) : O.redIAdd(this.a.redMul(r))), O;
    }
    validate(r) {
      if (I(r instanceof o), r.inf)
        return !0;
      const { x, y: O } = r, K = this.solveY2(x);
      return O.redSqr().eq(K);
    }
    pointFromX(r, x = null) {
      I(r instanceof c), I(x == null || typeof x == "boolean"), r.red || (r = r.toRed(this.red));
      const O = this.solveY(r);
      if (x != null) {
        if (this.h.cmpn(1) > 0 && O.isZero() && x)
          throw new Error("Invalid point.");
        O.redIsOdd() !== x && O.redINeg();
      }
      return this.point(r, O);
    }
    pointFromY(r, x = 0) {
      I(r instanceof c), I(x >>> 0 === x), r.red || (r = r.toRed(this.red));
      const O = this.solveX(r);
      if (x >= O.length)
        throw new Error("Invalid X coordinate index.");
      const K = O[x];
      return this.point(K, r);
    }
    isIsomorphic(r) {
      if (I(r instanceof f), !r.p.eq(this.p))
        return !1;
      let x, O;
      try {
        [x, O] = this._scale(r);
      } catch {
        return !1;
      }
      if (r.type === "short") {
        const K = this.field(r.a).redMul(x.redSqr()), X = this.field(r.b).redMul(O.redSqr());
        return this.a.eq(K) && this.b.eq(X);
      }
      if (r.type === "mont") {
        const { a3: K, bi: X } = r, P = this.field(K.redMul(X)).redMul(x);
        return this.solveY2(P).isZero();
      }
      if (r.type === "edwards") {
        const K = this.field(r.ad6).redMul(x);
        return this.solveY2(K).isZero();
      }
      return !1;
    }
    isIsogenous(r) {
      return I(r instanceof f), !1;
    }
    pointFromShort(r) {
      if (I(r instanceof o), this.isIsomorphic(r.curve)) {
        if (r.isInfinity())
          return this.point();
        const [x, O] = this._scale(r.curve), K = this.field(r.x), X = this.field(r.y), P = K.redMul(x), V = X.redMul(O);
        return this.point(P, V);
      }
      throw new Error("Not implemented.");
    }
    pointFromMont(r) {
      if (I(r instanceof p), this.isIsomorphic(r.curve)) {
        if (r.isInfinity())
          return this.point();
        const { a3: x, bi: O } = r.curve, [K, X] = this._scale(r.curve), P = r.x.redAdd(x).redMul(O), V = r.y.redMul(O);
        return this.point(
          this.field(P).redMul(K),
          this.field(V).redMul(X)
        );
      }
      throw new Error("Not implemented.");
    }
    pointFromEdwards(r) {
      if (I(r instanceof y), this.isIsomorphic(r.curve)) {
        const { a: x, d: O, ad6: K } = r.curve, [X, P] = this._scale(r.curve);
        if (r.isInfinity())
          return this.point();
        if (r.x.isZero()) {
          const Me = this.field(K).redMul(X);
          return this.point(Me, this.zero);
        }
        const { x: V, y: re, z: ce } = r, de = x.redMuln(5), pe = O.redMuln(5), se = O.redSub(x), Z = pe.redSub(x), ee = O.redSub(de), me = re.redAdd(ce), Ae = re.redSub(ce), Oe = Z.redMul(re).redIAdd(ee.redMul(ce)), ye = Ae.redMuln(12), _e = se.redMul(me).redMul(ce), ke = Ae.redMul(V).redIMuln(4);
        return this.cpoint(
          this.field(Oe).redMul(X),
          this.field(ye),
          this.field(_e).redMul(P),
          this.field(ke)
        );
      }
      throw new Error("Not implemented.");
    }
    pointFromUniform(r) {
      if (I(r instanceof c), this.z.isZero() || this.b.isZero())
        throw new Error("Not implemented.");
      if (!this.a.isZero())
        return this._sswu(r);
      if (!this.c.isZero())
        return this._svdw(r);
      throw new Error("Not implemented.");
    }
    pointToUniform(r, x) {
      if (I(r instanceof o), I(x >>> 0 === x), this.z.isZero() || this.b.isZero())
        throw new Error("Not implemented.");
      if (r.isInfinity())
        throw new Error("Invalid point.");
      const O = (x >>> 4 & 15) % this.torsion.length, K = r.add(this.torsion[O]);
      return ne(() => {
        if (!this.a.isZero())
          return this._sswui(K, x);
        if (!this.c.isZero())
          return this._svdwi(K, x);
        throw new Error("Not implemented.");
      });
    }
    mulAll(r, x) {
      return super.mulAll(r, x).toP();
    }
    affinizeAll(r) {
      const x = this.normalizeAll(r);
      for (let O = 0; O < x.length; O++)
        x[O] = x[O].toP();
      return x;
    }
    decodePoint(r) {
      return o.decode(this, r);
    }
    encodeX(r) {
      return I(r instanceof n), r.encodeX();
    }
    decodeEven(r) {
      return o.decodeEven(this, r);
    }
    decodeSquare(r) {
      return o.decodeSquare(this, r);
    }
    toShort(r, x, O = null) {
      const [K, X] = this._short(r, x), P = new u({
        red: this.red,
        prime: this.prime,
        p: this.p,
        a: K,
        b: X,
        n: this.n,
        h: this.h
      });
      if (O != null) {
        const [, V] = P._scale(this);
        V.redIsOdd() !== O && V.redINeg();
      }
      this.g.isInfinity() || (P.g = P.pointFromShort(this.g));
      for (let V = 0; V < this.h.word(0); V++)
        P.torsion[V] = P.pointFromShort(this.torsion[V]);
      return P;
    }
    toMont(r, x, O = null) {
      const [K, X] = this._mont(r, x), P = new i({
        red: this.red,
        prime: this.prime,
        p: this.p,
        a: K,
        b: X,
        n: this.n,
        h: this.h
      });
      if (O != null) {
        const [, V] = this._scale(P);
        V.redIsOdd() !== O && V.redINeg();
      }
      this.g.isInfinity() || (P.g = P.pointFromShort(this.g));
      for (let V = 0; V < this.h.word(0); V++)
        P.torsion[V] = P.pointFromShort(this.torsion[V]);
      return P;
    }
    toEdwards(r, x, O = null) {
      const [K, X] = this._edwards(r, x), P = new S({
        red: this.red,
        prime: this.prime,
        p: this.p,
        a: K,
        d: X,
        n: this.n,
        h: this.h
      });
      if (O != null) {
        const [, V] = this._scale(P);
        V.redIsOdd() !== O && V.redINeg();
      }
      if (this.g.isInfinity() || (P.g = P.pointFromShort(this.g), P.g.normalize()), P.isComplete())
        for (let V = 0; V < this.h.word(0); V++)
          P.torsion[V] = P.pointFromShort(this.torsion[V]), P.torsion[V].normalize();
      return P;
    }
    pointFromJSON(r) {
      return o.fromJSON(this, r);
    }
    toJSON(r) {
      const x = super.toJSON(r);
      return x.a = this.a.fromRed().toJSON(), x.b = this.b.fromRed().toJSON(), this.c.isZero() || (x.c = this.c.fromRed().toJSON()), x;
    }
  }
  class o extends n {
    constructor(r, x, O) {
      I(r instanceof u), super(r, l.AFFINE), this.x = this.curve.zero, this.y = this.curve.zero, this.inf = !0, x != null && this._init(x, O);
    }
    _init(r, x) {
      I(r instanceof c), I(x instanceof c), this.x = r, this.y = x, this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1;
    }
    _getBeta() {
      if (!this.curve.endo)
        return null;
      if (this.pre && this.pre.beta)
        return this.pre.beta;
      const r = this.x.redMul(this.curve.endo.beta), x = this.curve.point(r, this.y);
      return this.pre && (x.pre = this.pre.map((O) => {
        const K = O.x.redMul(this.curve.endo.beta);
        return this.curve.point(K, O.y);
      }), this.pre.beta = x), x;
    }
    _getJNAF(r) {
      if (I(r instanceof o), this.inf || r.inf)
        return super._getJNAF(r);
      const x = [
        this,
        // 1
        null,
        // 3
        null,
        // 5
        r
        // 7
      ];
      return this.y.eq(r.y) ? (x[1] = this.add(r), x[2] = this.toJ().sub(r)) : this.y.eq(r.y.redNeg()) ? (x[1] = this.toJ().add(r), x[2] = this.sub(r)) : (x[1] = this.toJ().add(r), x[2] = this.toJ().sub(r)), x;
    }
    clone() {
      return this.inf ? this.curve.point() : this.curve.point(this.x, this.y);
    }
    scale(r) {
      return this.toJ().scale(r);
    }
    neg() {
      return this.inf ? this : this.curve.point(this.x, this.y.redNeg());
    }
    add(r) {
      if (I(r instanceof o), this.inf)
        return r;
      if (r.inf)
        return this;
      if (this.x.eq(r.x))
        return this.y.eq(r.y) ? this.dbl() : this.curve.point();
      if (this.y.eq(r.y)) {
        const V = this.x.redNeg().redISub(r.x), re = this.y.redNeg();
        return this.curve.point(V, re);
      }
      const x = this.x.redSub(r.x), K = this.y.redSub(r.y).redDiv(x), X = K.redSqr().redISub(this.x).redISub(r.x), P = K.redMul(this.x.redSub(X)).redISub(this.y);
      return this.curve.point(X, P);
    }
    dbl() {
      if (this.inf)
        return this;
      if (this.y.isZero())
        return this.curve.point();
      const x = this.x.redSqr().redIMuln(3).redIAdd(this.curve.a), O = this.y.redMuln(2), K = x.redDiv(O), X = K.redSqr().redISub(this.x).redISub(this.x), P = K.redMul(this.x.redSub(X)).redISub(this.y);
      return this.curve.point(X, P);
    }
    dblp(r) {
      return this.toJ().dblp(r).toP();
    }
    getX() {
      if (this.inf)
        throw new Error("Invalid point.");
      return this.x.fromRed();
    }
    getY() {
      if (this.inf)
        throw new Error("Invalid point.");
      return this.y.fromRed();
    }
    eq(r) {
      return I(r instanceof o), this === r ? !0 : this.inf ? r.inf : r.inf ? !1 : this.x.eq(r.x) && this.y.eq(r.y);
    }
    cmp(r) {
      return I(r instanceof o), this.inf && !r.inf ? -1 : !this.inf && r.inf ? 1 : this.inf && r.inf ? 0 : this.order().cmp(r.order()) || this.getX().cmp(r.getX()) || this.getY().cmp(r.getY());
    }
    isInfinity() {
      return this.inf;
    }
    isOrder2() {
      return this.inf ? !1 : this.y.isZero();
    }
    isOdd() {
      return this.inf ? !1 : this.y.redIsOdd();
    }
    isEven() {
      return this.inf ? !1 : this.y.redIsEven();
    }
    isSquare() {
      return this.inf ? !1 : this.y.redJacobi() !== -1;
    }
    eqX(r) {
      return I(r instanceof c), I(!r.red), this.inf ? !1 : this.getX().eq(r);
    }
    eqR(r) {
      return I(r instanceof c), I(!r.red), I(!this.curve.n.isZero()), this.inf ? !1 : this.getX().imod(this.curve.n).eq(r);
    }
    mul(r) {
      return super.mul(r).toP();
    }
    muln(r) {
      return super.muln(r).toP();
    }
    mulBlind(r, x) {
      return super.mulBlind(r, x).toP();
    }
    mulAdd(r, x, O) {
      return super.mulAdd(r, x, O).toP();
    }
    mulH() {
      return super.mulH().toP();
    }
    div(r) {
      return super.div(r).toP();
    }
    divn(r) {
      return super.divn(r).toP();
    }
    divH() {
      return super.divH().toP();
    }
    toP() {
      return this;
    }
    toJ() {
      return this.inf ? this.curve.jpoint() : this.curve.jpoint(this.x, this.y, this.curve.one);
    }
    encode(r) {
      r == null && (r = !0), I(typeof r == "boolean");
      const { fieldSize: x } = this.curve;
      if (this.inf)
        throw new Error("Invalid point.");
      if (r) {
        const P = k.alloc(1 + x), V = this.curve.encodeField(this.getX());
        return P[0] = 2 | this.y.redIsOdd(), V.copy(P, 1), P;
      }
      const O = k.alloc(1 + x * 2), K = this.curve.encodeField(this.getX()), X = this.curve.encodeField(this.getY());
      return O[0] = 4, K.copy(O, 1), X.copy(O, 1 + x), O;
    }
    static decode(r, x) {
      I(r instanceof u), I(k.isBuffer(x));
      const O = r.fieldSize;
      if (x.length < 1 + O)
        throw new Error("Not a point.");
      const K = x[0];
      switch (K) {
        case 2:
        case 3: {
          if (x.length !== 1 + O)
            throw new Error("Invalid point size for compressed.");
          const X = r.decodeField(x.slice(1, 1 + O));
          if (X.cmp(r.p) >= 0)
            throw new Error("Invalid point.");
          const P = r.pointFromX(X, K === 3);
          return I(!P.isInfinity()), P;
        }
        case 4:
        case 6:
        case 7: {
          if (x.length !== 1 + O * 2)
            throw new Error("Invalid point size for uncompressed.");
          const X = r.decodeField(x.slice(1, 1 + O)), P = r.decodeField(x.slice(1 + O, 1 + 2 * O));
          if (X.cmp(r.p) >= 0 || P.cmp(r.p) >= 0)
            throw new Error("Invalid point.");
          if (K !== 4 && K !== (6 | P.isOdd()))
            throw new Error("Invalid hybrid encoding.");
          const V = r.point(X, P);
          if (!V.validate())
            throw new Error("Invalid point.");
          return I(!V.isInfinity()), V;
        }
        default:
          throw new Error("Unknown point format.");
      }
    }
    encodeX() {
      return this.curve.encodeField(this.getX());
    }
    static decodeEven(r, x) {
      I(r instanceof u);
      const O = r.decodeField(x);
      if (O.cmp(r.p) >= 0)
        throw new Error("Invalid point.");
      return r.pointFromX(O, !1);
    }
    static decodeSquare(r, x) {
      I(r instanceof u);
      const O = r.decodeField(x);
      if (O.cmp(r.p) >= 0)
        throw new Error("Invalid point.");
      return r.pointFromX(O);
    }
    toJSON(r) {
      if (this.inf)
        return [];
      const x = this.getX().toJSON(), O = this.getY().toJSON();
      return r === !0 && this.pre ? [x, O, this.pre.toJSON()] : [x, O];
    }
    toPretty() {
      if (this.inf)
        return [];
      const r = this.curve.fieldSize * 2, x = M(this.getX(), r), O = M(this.getY(), r);
      return [x, O];
    }
    static fromJSON(r, x) {
      if (I(r instanceof u), I(Array.isArray(x)), I(x.length === 0 || x.length === 2 || x.length === 3), x.length === 0)
        return r.point();
      const O = c.fromJSON(x[0]), K = c.fromJSON(x[1]), X = r.point(O, K);
      return x.length > 2 && x[2] != null && (X.pre = b.fromJSON(X, x[2])), X;
    }
    [e]() {
      return this.inf ? "<ShortPoint: Infinity>" : "<ShortPoint: x=" + this.x.fromRed().toString(16, 2) + " y=" + this.y.fromRed().toString(16, 2) + ">";
    }
  }
  class s extends n {
    constructor(r, x, O, K) {
      I(r instanceof u), super(r, l.JACOBIAN), this.x = this.curve.one, this.y = this.curve.one, this.z = this.curve.zero, this.zOne = !1, x != null && this._init(x, O, K);
    }
    _init(r, x, O) {
      I(r instanceof c), I(x instanceof c), I(O == null || O instanceof c), this.x = r, this.y = x, this.z = O || this.curve.one, this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z.eq(this.curve.one);
    }
    clone() {
      return this.curve.jpoint(this.x, this.y, this.z);
    }
    validate() {
      const { a: r, b: x } = this.curve;
      if (this.isInfinity())
        return !0;
      if (this.zOne)
        return this.curve.validate(this.toP());
      const O = this.y.redSqr(), K = this.x.redSqr().redMul(this.x), X = this.z.redSqr(), P = X.redSqr(), V = P.redMul(X), re = K.redIAdd(x.redMul(V));
      return this.curve.zeroA || (this.curve.threeA ? re.redIAdd(P.redIMuln(-3).redMul(this.x)) : re.redIAdd(r.redMul(P).redMul(this.x))), O.eq(re);
    }
    normalize() {
      if (this.zOne)
        return this;
      if (this.isInfinity())
        return this;
      const r = this.z.redInvert(), x = r.redSqr();
      return this.x = this.x.redMul(x), this.y = this.y.redMul(x).redMul(r), this.z = this.curve.one, this.zOne = !0, this;
    }
    scale(r) {
      if (I(r instanceof c), this.isInfinity())
        return this.curve.jpoint();
      const x = r.redSqr(), O = this.x.redMul(x), K = this.y.redMul(x).redMul(r), X = this.z.redMul(r);
      return this.curve.jpoint(O, K, X);
    }
    neg() {
      return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
    }
    add(r) {
      return I(r instanceof n), r.type === l.AFFINE ? this._mixedAdd(r) : this._add(r);
    }
    _add(r) {
      return I(r instanceof s), this.isInfinity() ? r : r.isInfinity() ? this : this.zOne ? r._addJA(this) : r.zOne ? this._addJA(r) : this._addJJ(r);
    }
    _mixedAdd(r) {
      return I(r instanceof o), this.isInfinity() ? r.toJ() : r.isInfinity() ? this : this._addJA(r);
    }
    _addJJ(r) {
      const x = this.z.redSqr(), O = r.z.redSqr(), K = this.x.redMul(O), X = r.x.redMul(x), P = this.y.redMul(r.z).redMul(O), V = r.y.redMul(this.z).redMul(x), re = X.redISub(K), ce = V.redISub(P);
      if (re.isZero())
        return ce.isZero() ? this.dbl() : this.curve.jpoint();
      const de = re.redSqr(), pe = re.redMul(de), se = K.redMul(de), Z = ce.redSqr().redISub(pe).redISub(se).redISub(se), ee = ce.redMul(se.redISub(Z)).redISub(P.redMul(pe)), me = this.z.redMul(r.z).redMul(re);
      return this.curve.jpoint(Z, ee, me);
    }
    _addJA(r) {
      const x = this.z.redSqr(), O = r.x.redMul(x), K = r.y.redMul(this.z).redMul(x), X = O.redISub(this.x), P = K.redISub(this.y).redIMuln(2);
      if (X.isZero())
        return P.isZero() ? this.dbl() : this.curve.jpoint();
      const V = X.redMuln(2).redSqr(), re = X.redMul(V), ce = this.x.redMul(V), de = P.redSqr().redISub(re).redISub(ce).redISub(ce), pe = P.redMul(ce.redISub(de)).redISub(this.y.redMul(re).redIMuln(2)), se = this.z.redMul(X).redIMuln(2);
      return this.curve.jpoint(de, pe, se);
    }
    dbl() {
      return this.isInfinity() ? this : this.y.isZero() ? this.curve.jpoint() : this.curve.zeroA ? this._dbl0() : this.curve.threeA ? this._dbl3() : this._dblJ();
    }
    _dblJ() {
      const r = this.x.redSqr(), x = this.y.redSqr(), O = this.z.redSqr(), K = this.x.redMul(x).redIMuln(4), X = r.redIMuln(3).redIAdd(this.curve.a.redMul(O.redSqr())), P = X.redSqr().redISub(K).redISub(K), V = P, re = X.redMul(K.redISub(P)).redISub(x.redSqr().redIMuln(8)), ce = this.y.redMul(this.z).redIMuln(2);
      return this.curve.jpoint(V, re, ce);
    }
    _dbl0() {
      const r = this.x.redSqr(), x = this.y.redSqr(), O = x.redSqr(), X = x.redIAdd(this.x).redSqr().redISub(r).redISub(O).redIMuln(2), P = r.redIMuln(3), re = P.redSqr().redISub(X).redISub(X), ce = P.redMul(X.redISub(re)).redISub(O.redIMuln(8)), de = this.y.redMul(this.z).redIMuln(2);
      return this.curve.jpoint(re, ce, de);
    }
    _dbl3() {
      const r = this.z.redSqr(), x = this.y.redSqr(), O = this.x.redMul(x), K = this.x.redSub(r), X = this.x.redAdd(r), P = K.redMul(X).redIMuln(3), V = O.redIMuln(4), re = V.redMuln(2), ce = x.redSqr().redIMuln(8), de = P.redSqr().redISub(re), pe = this.y.redAdd(this.z).redSqr().redISub(x).redISub(r), se = P.redMul(V.redISub(de)).redISub(ce);
      return this.curve.jpoint(de, se, pe);
    }
    getX() {
      if (this.isInfinity())
        throw new Error("Invalid point.");
      return this.normalize(), this.x.fromRed();
    }
    getY() {
      if (this.isInfinity())
        throw new Error("Invalid point.");
      return this.normalize(), this.y.fromRed();
    }
    eq(r) {
      if (I(r instanceof s), this === r)
        return !0;
      if (this.isInfinity())
        return r.isInfinity();
      if (r.isInfinity())
        return !1;
      if (this.z.eq(r.z))
        return this.x.eq(r.x) && this.y.eq(r.y);
      const x = this.z.redSqr(), O = r.z.redSqr(), K = this.x.redMul(O), X = r.x.redMul(x);
      if (!K.eq(X))
        return !1;
      const P = x.redMul(this.z), V = O.redMul(r.z), re = this.y.redMul(V), ce = r.y.redMul(P);
      return re.eq(ce);
    }
    cmp(r) {
      I(r instanceof s);
      const x = this.isInfinity(), O = r.isInfinity();
      return x && !O ? -1 : !x && O ? 1 : x && O ? 0 : this.order().cmp(r.order()) || this.getX().cmp(r.getX()) || this.getY().cmp(r.getY());
    }
    isInfinity() {
      return this.z.isZero();
    }
    isOrder2() {
      return this.isInfinity() ? !1 : this.y.isZero();
    }
    isOdd() {
      return this.isInfinity() ? !1 : (this.normalize(), this.y.redIsOdd());
    }
    isEven() {
      return this.isInfinity() ? !1 : (this.normalize(), this.y.redIsEven());
    }
    isSquare() {
      return this.isInfinity() ? !1 : this.y.redMul(this.z).redJacobi() !== -1;
    }
    eqX(r) {
      if (I(r instanceof c), I(!r.red), this.isInfinity())
        return !1;
      const x = this.z.redSqr(), O = r.toRed(this.curve.red).redMul(x);
      return this.x.eq(O);
    }
    eqR(r) {
      if (I(r instanceof c), I(!r.red), !this.curve.smallGap)
        return this.toP().eqR(r);
      if (this.isInfinity() || r.cmp(this.curve.p) >= 0)
        return !1;
      const x = this.z.redSqr(), O = r.toRed(this.curve.red).redMul(x);
      if (this.x.eq(O))
        return !0;
      if (this.curve.highOrder || r.cmp(this.curve.pmodn) >= 0)
        return !1;
      const K = this.curve.redN.redMul(x);
      return O.redIAdd(K), this.x.eq(O);
    }
    toP() {
      return this.isInfinity() ? this.curve.point() : (this.normalize(), this.curve.point(this.x, this.y));
    }
    toJ() {
      return this;
    }
    encode(r) {
      return this.toP().encode(r);
    }
    static decode(r, x) {
      return o.decode(r, x).toJ();
    }
    encodeX() {
      return this.toP().encodeX();
    }
    static decodeEven(r, x) {
      return o.decodeEven(r, x).toJ();
    }
    static decodeSquare(r, x) {
      return o.decodeSquare(r, x).toJ();
    }
    toJSON(r) {
      return this.toP().toJSON(r);
    }
    toPretty() {
      return this.toP().toPretty();
    }
    static fromJSON(r, x) {
      return o.fromJSON(r, x).toJ();
    }
    [e]() {
      return this.isInfinity() ? "<JPoint: Infinity>" : "<JPoint: x=" + this.x.fromRed().toString(16, 2) + " y=" + this.y.fromRed().toString(16, 2) + " z=" + this.z.fromRed().toString(16, 2) + ">";
    }
  }
  class i extends f {
    constructor(r) {
      super(p, "mont", r), this.a = c.fromJSON(r.a).toRed(this.red), this.b = c.fromJSON(r.b).toRed(this.red), this.bi = this.b.redInvert(), this.a2 = this.a.redAdd(this.two), this.a24 = this.a2.redMul(this.i4), this.a3 = this.a.redMul(this.i3), this.a0 = this.a.redMul(this.bi), this.b0 = this.bi.redSqr(), this._finalize(r);
    }
    static _isomorphism(r, x, O) {
      I(r instanceof c), I(x instanceof c), I(O instanceof c);
      const K = r.clone(), X = O.clone();
      if (x.redDiv(O).redJacobi() !== 1)
        throw new Error("Invalid `b` coefficient.");
      return [K, X];
    }
    _short(r, x) {
      const { a: O, b: K, three: X } = this, P = O.redSqr(), V = P.redMul(O), re = K.redSqr(), ce = re.redMul(K), de = X.redSub(P), pe = re.redMuln(3), se = V.redMuln(2).redISub(O.redMuln(9)), Z = ce.redMuln(27), ee = de.redDiv(pe), me = se.redDiv(Z);
      return r != null ? u._isomorphism(ee, me, r, x) : [ee, me];
    }
    _mont(r) {
      return i._isomorphism(this.a, this.b, r);
    }
    _edwards(r, x = !1) {
      I(typeof x == "boolean");
      const { two: O, bi: K } = this, X = this.a.redAdd(O).redMul(K), P = this.a.redSub(O).redMul(K);
      return x && X.swap(P), r != null ? S._isomorphism(X, P, r) : [X, P];
    }
    _scaleShort(r) {
      I(r instanceof u);
      const [x, O] = r._scale(this);
      return [
        this.field(x.redInvert()),
        this.field(O.redInvert())
      ];
    }
    _scaleMont(r) {
      return I(r instanceof i), this.g.isInfinity() || r.g.isInfinity() ? this.field(r.b).redDivSqrt(this.b) : this.g.y.redDiv(this.field(r.g.y));
    }
    _scaleEdwards(r, x) {
      I(r instanceof S);
      const O = r._scale(this, x);
      return this.field(O);
    }
    _solveY0(r) {
      I(r instanceof c);
      const x = this.a0, O = this.b0, K = r.redSqr();
      return K.redMul(r).redIAdd(x.redMul(K)).redIAdd(O.redMul(r));
    }
    _elligator2(r) {
      const x = this.a0.redNeg(), O = this.one.redAdd(this.z.redMul(r.redSqr()));
      O.isZero() && O.inject(this.one);
      const K = x.redMul(O.redInvert()), X = K.redNeg().redISub(this.a0), P = this._solveY0(K), V = this._solveY0(X), re = P.redIsSquare() | 0, ce = [K, X][re ^ 1], de = [P, V][re ^ 1].redSqrt();
      de.redIsOdd() !== r.redIsOdd() && de.redINeg();
      const pe = this.b.redMul(ce), se = this.b.redMul(de);
      return this.point(pe, se);
    }
    _invert2(r, x) {
      const { x: O, y: K } = r, X = x & 1, P = O.redMul(this.bi), V = K.redMul(this.bi), re = P.redAdd(this.a0), ce = P, de = [re, ce][X].redINeg(), pe = [ce, re][X].redMul(this.z), se = de.redDivSqrt(pe);
      return se.redIsOdd() !== V.redIsOdd() && se.redINeg(), se;
    }
    isElliptic() {
      const r = this.a.redSqr();
      return !this.b.redMul(r.redSub(this.four)).isZero();
    }
    jinv() {
      const { a: r, three: x, four: O } = this, K = r.redSqr(), P = K.redSub(x).redPown(3).redIMuln(256), V = K.redSub(O);
      if (V.isZero())
        throw new Error("Curve is not elliptic.");
      return P.redDiv(V).fromRed();
    }
    point(r, x) {
      return new p(this, r, x);
    }
    jpoint(r, x, O) {
      return I(r == null && x == null && O == null), this.point();
    }
    xpoint(r, x) {
      return new g(this, r, x);
    }
    solveY2(r) {
      I(r instanceof c);
      const x = r.redSqr();
      return x.redMul(r).redIAdd(this.a.redMul(x)).redIAdd(r).redMul(this.bi);
    }
    validate(r) {
      if (I(r instanceof p), r.isInfinity())
        return !0;
      const { x, y: O } = r, K = this.solveY2(x);
      return O.redSqr().eq(K);
    }
    pointFromX(r, x = null) {
      I(r instanceof c), I(x == null || typeof x == "boolean"), r.red || (r = r.toRed(this.red));
      const O = this.solveY(r);
      if (x != null) {
        if (O.isZero() && x)
          throw new Error("Invalid point.");
        O.redIsOdd() !== x && O.redINeg();
      }
      return this.point(r, O);
    }
    isIsomorphic(r, x) {
      if (I(r instanceof f), !r.p.eq(this.p))
        return !1;
      if (r.type === "mont") {
        const O = this.field(r.a), K = this.field(r.b);
        return !this.a.eq(O) || this.b.isZero() ? !1 : K.redDiv(this.b).redJacobi() === 1;
      }
      return r.isIsomorphic(this, x);
    }
    isIsogenous(r) {
      return I(r instanceof f), r.type === "mont" ? !1 : r.isIsogenous(this);
    }
    pointFromShort(r) {
      if (I(r instanceof o), this.isIsomorphic(r.curve)) {
        if (r.isInfinity())
          return this.point();
        const { a3: x, b: O } = this, [K, X] = this._scale(r.curve), P = this.field(r.x).redMul(K), V = this.field(r.y).redMul(X), re = O.redMul(P).redISub(x), ce = O.redMul(V);
        return this.point(re, ce);
      }
      throw new Error("Not implemented.");
    }
    pointFromMont(r) {
      if (I(r instanceof p), this.isIsomorphic(r.curve)) {
        if (r.isInfinity())
          return this.point();
        const x = this._scale(r.curve), O = this.field(r.x), K = this.field(r.y), X = O, P = x.redMul(K);
        return this.point(X, P);
      }
      throw new Error("Not implemented.");
    }
    pointFromEdwards(r) {
      I(r instanceof y), I(r.curve.p.eq(this.p));
      const x = this.field(r.x), O = this.field(r.y), K = this.field(r.z);
      if (this.isIsogenous(r.curve)) {
        if (r.isInfinity())
          return this.point();
        if (r.x.isZero())
          return this.point(this.zero, this.zero);
        const X = K.redSqr().redIMuln(2), P = O.redSqr(), V = x.redSqr(), re = X.redISub(V).redISub(P).redMul(O), ce = V.redMul(x);
        return this.cpoint(P, V, re, ce);
      }
      if (this.isIsomorphic(r.curve, !0)) {
        if (r.isInfinity())
          return this.point();
        if (r.x.isZero())
          return this.point(this.zero, this.zero);
        const X = this._scale(r.curve, !0), P = O.redAdd(K), V = O.redSub(K), re = X.redMul(K).redMul(P), ce = x.redMul(V);
        return this.cpoint(P, V, re, ce);
      }
      if (this.isIsomorphic(r.curve, !1)) {
        if (r.isInfinity())
          return this.point();
        if (r.x.isZero())
          return this.point(this.zero, this.zero);
        const X = this._scale(r.curve, !1), P = K.redAdd(O), V = K.redSub(O), re = X.redMul(K).redMul(P), ce = x.redMul(V);
        return this.cpoint(P, V, re, ce);
      }
      throw new Error("Not implemented.");
    }
    pointFromUniform(r) {
      if (I(r instanceof c), this.z.isZero() || this.a.isZero())
        throw new Error("Not implemented.");
      return this._elligator2(r);
    }
    pointToUniform(r, x) {
      if (I(r instanceof p), I(x >>> 0 === x), this.z.isZero() || this.a.isZero())
        throw new Error("Not implemented.");
      if (r.isInfinity())
        throw new Error("Invalid point.");
      const O = (x >>> 4 & 15) % this.torsion.length, K = r.add(this.torsion[O]);
      return ne(() => this._invert2(K, x));
    }
    decodePoint(r, x) {
      return p.decode(this, r, x);
    }
    encodeX(r) {
      return I(r instanceof g), r.encode();
    }
    decodeX(r) {
      return g.decode(this, r);
    }
    toShort(r, x, O = null) {
      const [K, X] = this._short(r, x), P = new u({
        red: this.red,
        prime: this.prime,
        p: this.p,
        a: K,
        b: X,
        n: this.n,
        h: this.h
      });
      if (O != null) {
        const [, V] = P._scale(this);
        V.redIsOdd() !== O && V.redINeg();
      }
      this.g.isInfinity() || (P.g = P.pointFromMont(this.g));
      for (let V = 0; V < this.h.word(0); V++)
        P.torsion[V] = P.pointFromMont(this.torsion[V]);
      return P;
    }
    toMont(r, x = null) {
      const [O, K] = this._mont(r), X = new i({
        red: this.red,
        prime: this.prime,
        p: this.p,
        a: O,
        b: K,
        n: this.n,
        h: this.h,
        z: this.z
      });
      if (x != null) {
        const P = X._scale(this);
        P.redIsOdd() !== x && P.redINeg();
      }
      this.g.isInfinity() || (X.g = X.pointFromMont(this.g));
      for (let P = 0; P < this.h.word(0); P++)
        X.torsion[P] = X.pointFromMont(this.torsion[P]);
      return X;
    }
    toEdwards(r, x, O = null) {
      const [K, X] = this._edwards(r, x), P = new S({
        red: this.red,
        prime: this.prime,
        p: this.p,
        a: K,
        d: X,
        n: this.n,
        h: this.h,
        z: this.z
      });
      if (O != null) {
        const V = P._scale(this, x);
        V.redIsOdd() !== O && V.redINeg();
      }
      if (this.g.isInfinity() || (P.g = P.pointFromMont(this.g), P.g.normalize()), P.isComplete())
        for (let V = 0; V < this.h.word(0); V++)
          P.torsion[V] = P.pointFromMont(this.torsion[V]), P.torsion[V].normalize();
      return P;
    }
    pointFromJSON(r) {
      return p.fromJSON(this, r);
    }
    toJSON(r) {
      const x = super.toJSON(r);
      return x.a = this.a.fromRed().toJSON(), x.b = this.b.fromRed().toJSON(), x;
    }
  }
  class p extends n {
    constructor(r, x, O) {
      I(r instanceof i), super(r, l.AFFINE), this.x = this.curve.zero, this.y = this.curve.zero, this.inf = !0, x != null && this._init(x, O);
    }
    _init(r, x) {
      I(r instanceof c), I(x instanceof c), this.x = r, this.y = x, this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1;
    }
    clone() {
      return this.inf ? this.curve.point() : this.curve.point(this.x, this.y);
    }
    scale(r) {
      return this.clone();
    }
    randomize(r) {
      return this.clone();
    }
    neg() {
      return this.inf ? this : this.curve.point(this.x, this.y.redNeg());
    }
    add(r) {
      if (I(r instanceof p), this.inf)
        return r;
      if (r.inf)
        return this;
      if (this.x.eq(r.x))
        return this.y.eq(r.y) ? this.dbl() : this.curve.point();
      const x = r.x.redSub(this.x), K = r.y.redSub(this.y).redDiv(x), P = this.curve.b.redMul(K.redSqr()).redISub(this.curve.a).redISub(this.x).redISub(r.x), V = K.redMul(this.x.redSub(P)).redISub(this.y);
      return this.curve.point(P, V);
    }
    dbl() {
      if (this.inf)
        return this;
      if (this.y.isZero())
        return this.curve.point();
      const r = this.x.redSqr().redIMuln(3), x = this.curve.a.redMul(this.x).redIMuln(2), O = r.redIAdd(x).redIAdd(this.curve.one), K = this.curve.b.redMul(this.y).redIMuln(2), X = O.redDiv(K), V = this.curve.b.redMul(X.redSqr()).redISub(this.curve.a).redISub(this.x).redISub(this.x), re = X.redMul(this.x.redSub(V)).redISub(this.y);
      return this.curve.point(V, re);
    }
    getX() {
      if (this.inf)
        throw new Error("Invalid point.");
      return this.x.fromRed();
    }
    getY() {
      if (this.inf)
        throw new Error("Invalid point.");
      return this.y.fromRed();
    }
    eq(r) {
      return I(r instanceof p), this === r ? !0 : this.inf ? r.inf : r.inf ? !1 : this.x.eq(r.x) && this.y.eq(r.y);
    }
    cmp(r) {
      return I(r instanceof p), this.inf && !r.inf ? -1 : !this.inf && r.inf ? 1 : this.inf && r.inf ? 0 : this.order().cmp(r.order()) || this.getX().cmp(r.getX()) || this.getY().cmp(r.getY());
    }
    isInfinity() {
      return this.inf;
    }
    isOrder2() {
      return this.inf ? !1 : this.y.isZero();
    }
    isOdd() {
      return this.inf ? !1 : this.y.redIsOdd();
    }
    isEven() {
      return this.inf ? !1 : this.y.redIsEven();
    }
    toP() {
      return this;
    }
    toJ() {
      return this;
    }
    toX() {
      return this.inf ? this.curve.xpoint() : this.curve.xpoint(this.x, this.curve.one);
    }
    encode() {
      return this.toX().encode();
    }
    static decode(r, x, O) {
      return I(r instanceof i), r.decodeX(x).toP(O);
    }
    toJSON(r) {
      if (this.inf)
        return [];
      const x = this.getX().toJSON(), O = this.getY().toJSON();
      return [x, O];
    }
    toPretty() {
      if (this.inf)
        return [];
      const r = this.curve.fieldSize * 2, x = M(this.getX(), r), O = M(this.getY(), r);
      return [x, O];
    }
    static fromJSON(r, x) {
      if (I(r instanceof i), I(Array.isArray(x)), I(x.length === 0 || x.length === 2 || x.length === 3), x.length === 0)
        return r.point();
      const O = c.fromJSON(x[0]), K = c.fromJSON(x[1]);
      return r.point(O, K);
    }
    [e]() {
      return this.inf ? "<MontPoint: Infinity>" : "<MontPoint: x=" + this.x.fromRed().toString(16, 2) + " y=" + this.y.fromRed().toString(16, 2) + ">";
    }
  }
  class g extends n {
    constructor(r, x, O) {
      I(r instanceof i), super(r, l.PROJECTIVE), this.x = this.curve.one, this.z = this.curve.zero, x != null && this._init(x, O);
    }
    _init(r, x) {
      I(r instanceof c), I(x == null || x instanceof c), this.x = r, this.z = x || this.curve.one, this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red));
    }
    clone() {
      return this.curve.xpoint(this.x, this.z);
    }
    precompute(r, x) {
      return this;
    }
    validate() {
      if (this.isInfinity())
        return !0;
      const { x: r, z: x } = this, O = r.redSqr(), K = O.redMul(r), X = x.redSqr(), P = this.curve.a.redMul(O).redMul(x);
      return K.redIAdd(P).redIAdd(r.redMul(X)).redMul(this.curve.bi).redMul(x).redJacobi() !== -1;
    }
    normalize() {
      return this.isInfinity() ? this : this.z.eq(this.curve.one) ? this : (this.x = this.x.redDiv(this.z), this.z = this.curve.one, this);
    }
    scale(r) {
      if (I(r instanceof c), this.isInfinity())
        return this.curve.xpoint();
      const x = this.x.redMul(r), O = this.z.redMul(r);
      return this.curve.xpoint(x, O);
    }
    neg() {
      return this;
    }
    dbl() {
      const x = this.x.redAdd(this.z).redSqr(), K = this.x.redSub(this.z).redSqr(), X = x.redSub(K), P = x.redMul(K), V = X.redMul(K.redIAdd(this.curve.a24.redMul(X)));
      return this.curve.xpoint(P, V);
    }
    diffAddDbl(r, x) {
      I(r instanceof g), I(x instanceof g);
      const O = r.x.redAdd(r.z), K = O.redSqr(), X = r.x.redSub(r.z), P = X.redSqr(), V = K.redSub(P), re = x.x.redAdd(x.z), de = x.x.redSub(x.z).redMul(O), pe = re.redMul(X), se = this.z.redMul(de.redAdd(pe).redSqr()), Z = this.x.redMul(de.redISub(pe).redSqr()), ee = K.redMul(P), me = V.redMul(P.redIAdd(this.curve.a24.redMul(V)));
      return [
        this.curve.xpoint(ee, me),
        this.curve.xpoint(se, Z)
      ];
    }
    getX() {
      if (this.isInfinity())
        throw new Error("Invalid point.");
      return this.normalize(), this.x.fromRed();
    }
    getY(r) {
      return this.toP(r).getY();
    }
    eq(r) {
      if (I(r instanceof g), this === r)
        return !0;
      if (this.isInfinity())
        return r.isInfinity();
      if (r.isInfinity())
        return !1;
      if (this.z.eq(r.z))
        return this.x.eq(r.x);
      const x = this.x.redMul(r.z), O = r.x.redMul(this.z);
      return x.eq(O);
    }
    cmp(r) {
      I(r instanceof g);
      const x = this.isInfinity(), O = r.isInfinity();
      return x && !O ? -1 : !x && O ? 1 : x && O ? 0 : this.order().cmp(r.order()) || this.getX().cmp(r.getX());
    }
    isInfinity() {
      return this.z.isZero();
    }
    isOrder2() {
      return this.isInfinity() ? !1 : this.x.isZero();
    }
    isOdd() {
      return !1;
    }
    isEven() {
      return !1;
    }
    hasTorsion() {
      return this.isInfinity() ? !1 : this.x.isZero() ? !0 : super.hasTorsion();
    }
    order() {
      try {
        return this.toP().order();
      } catch {
        return new c(1);
      }
    }
    jmul(r) {
      I(r instanceof c), I(!r.red);
      const x = r.bitLength();
      let O = this.curve.xpoint(), K = this;
      for (let X = x - 1; X >= 0; X--)
        r.bit(X) === 0 ? [O, K] = this.diffAddDbl(O, K) : [K, O] = this.diffAddDbl(K, O);
      return O;
    }
    jmulBlind(r, x) {
      return x ? this.randomize(x).jmul(r) : this.jmul(r);
    }
    jmulAdd(r, x, O) {
      throw new Error("Not implemented.");
    }
    toP(r = null) {
      return I(r == null || typeof r == "boolean"), this.isInfinity() ? this.curve.point() : (this.normalize(), this.curve.pointFromX(this.x, r));
    }
    toJ() {
      return this;
    }
    toX() {
      return this;
    }
    key() {
      if (this.isInfinity())
        return `${this.curve.uid}:oo`;
      this.normalize();
      const r = this.getX().toString(16);
      return `${this.curve.uid}:${r}`;
    }
    encode() {
      return this.curve.encodeField(this.getX());
    }
    static decode(r, x) {
      I(r instanceof i);
      const O = r.decodeField(x);
      O.iumaskn(r.fieldBits);
      const K = r.xpoint(O, r.one);
      return I(!K.isInfinity()), K;
    }
    toJSON(r) {
      return this.toP().toJSON(r);
    }
    toPretty() {
      return this.toP().toPretty();
    }
    static fromJSON(r, x) {
      return p.fromJSON(r, x).toX();
    }
    [e]() {
      return this.isInfinity() ? "<XPoint: Infinity>" : "<XPoint: x=" + this.x.fromRed().toString(16, 2) + " z=" + this.z.fromRed().toString(16, 2) + ">";
    }
  }
  class S extends f {
    constructor(r) {
      super(y, "edwards", r), this.a = c.fromJSON(r.a).toRed(this.red), this.d = c.fromJSON(r.d).toRed(this.red), this.s = c.fromJSON(r.s || "0").toRed(this.red), this.si = this.s.isZero() ? this.zero : this.s.redInvert(), this.k = this.d.redMuln(2), this.smi = -this.d.redNeg().word(0), this.ad6 = this.a.redAdd(this.d).redMul(this.i6), this.twisted = !this.a.eq(this.one), this.oneA = this.a.eq(this.one), this.mOneA = this.a.eq(this.one.redNeg()), this.smallD = this.prime != null && this.d.redNeg().length === 1, this.alt = null, this._finalize(r);
    }
    static _isomorphism(r, x, O) {
      I(r instanceof c), I(x instanceof c), I(O instanceof c);
      const K = O.clone(), X = O.redMul(x).redDiv(r);
      if (r.redDiv(O).redJacobi() !== 1)
        throw new Error("Invalid `a` coefficient.");
      return [K, X];
    }
    _short(r, x) {
      const { a: O, d: K } = this, X = O.redSqr(), P = X.redMul(O), V = K.redSqr(), re = V.redMul(K), ce = O.redMul(K).redIMuln(14), de = X.redMul(K), pe = O.redMul(V), se = de.redIAdd(pe).redIMuln(33), Z = X.redAdd(ce).redIAdd(V).redDivn(-48), ee = se.redISub(P).redISub(re).redDivn(864);
      return r != null ? u._isomorphism(Z, ee, r, x) : [Z, ee];
    }
    _mont(r, x = !1) {
      I(typeof x == "boolean");
      let O, K;
      x ? (O = this.d.redAdd(this.a), K = this.d.redSub(this.a)) : (O = this.a.redAdd(this.d), K = this.a.redSub(this.d));
      const X = K.redInvert(), P = O.redMuln(2).redMul(X), V = X.redMuln(4);
      return r != null ? i._isomorphism(P, V, r) : [P, V];
    }
    _edwards(r) {
      return S._isomorphism(this.a, this.d, r);
    }
    _scaleShort(r) {
      I(r instanceof u);
      const [x, O] = r._scale(this);
      return [
        this.field(x.redInvert()),
        this.field(O.redInvert())
      ];
    }
    _scaleMont(r, x = !1) {
      if (I(r instanceof i), I(typeof x == "boolean"), this.g.isInfinity() || r.g.isInfinity()) {
        const [K] = r._edwards(null, x);
        return this.field(K).redDivSqrt(this.a);
      }
      const O = r.g.x.redDiv(r.g.y);
      return this.g.x.redDiv(this.field(O));
    }
    _scaleEdwards(r) {
      return I(r instanceof S), this.g.isInfinity() || r.g.isInfinity() ? this.field(r.a).redDivSqrt(this.a) : this.g.x.redDiv(this.field(r.g.x));
    }
    _mulA(r) {
      return I(r instanceof c), this.oneA ? r.clone() : this.mOneA ? r.redNeg() : this.a.redMul(r);
    }
    _mulD(r) {
      return I(r instanceof c), this.smallD ? r.redMuln(this.smi) : this.d.redMul(r);
    }
    _elligator1(r) {
      const { s: x, si: O, i2: K, one: X, two: P } = this, V = O.redSqr().redIMuln(2), re = x.redSqr().redMul(K), ce = re.redSqr(), de = V.redAdd(re), pe = de.redSqr().redISub(P), se = V.redSub(X), Z = X.redSub(r), ee = X.redAdd(r), me = ee.isZero() ? ee : Z.redDiv(ee), Ae = me.redSqr(), Oe = Ae.redMul(me), _e = Oe.redMul(Ae).redAdd(pe.redMul(Oe)).redIAdd(me), ke = this.field(_e.redJacobi()), Me = this.field(Ae.redAdd(ce).redJacobi()), De = ke.redMul(Me), Ne = ke.redMul(me), $e = ke.redMul(_e).redSqrt().redMul(De), bt = X.redAdd(Ne), Ve = de.redMul(Ne), je = bt.redSqr(), _t = se.redMul(x).redMul(Ne).redMul(bt), Je = me.isZero() ? this.one : $e, Ye = Ve.redSub(je), Ot = Ve.redAdd(je);
      return this.cpoint(_t, Je, Ye, Ot);
    }
    _invert1(r, x) {
      const { s: O, si: K, i2: X, one: P } = this, { x: V, y: re, z: ce } = r, de = x & 1, pe = K.redSqr().redIMuln(2), se = O.redSqr().redMul(X), Z = se.redSqr(), ee = pe.redAdd(se), me = pe.redSub(P), Ae = re.redSub(ce), Oe = re.redAdd(ce).redIMuln(2), ye = Oe.isZero() ? Oe : Ae.redDiv(Oe), _e = P.redAdd(ye.redMul(ee)), De = _e.redSqr().redISub(P).redSqrt().redSub(_e), Ne = P.redAdd(De), bt = me.redMul(O).redMul(De).redMul(Ne).redMul(V.redMul(ce)), Ve = De.redSqr().redIAdd(Z), _t = this.field(bt.redMul(Ve).redJacobi()).redMul(De), Je = P.redSub(_t), Ye = P.redAdd(_t), Ot = Ye.isZero() ? Ye : Je.redDiv(Ye);
      return Ot.redIsOdd() !== !!de && Ot.redINeg(), Ot;
    }
    _alt() {
      return this.alt || (this.alt = this.toMont()), this.alt;
    }
    isElliptic() {
      const r = this.a.redMul(this.d), x = this.a.redSub(this.d);
      return !r.redMul(x).isZero();
    }
    jinv() {
      const { a: r, d: x } = this, O = r.redMul(x), K = r.redSub(x).redPown(4), X = r.redSqr(), P = x.redSqr(), re = X.redAdd(O.redMuln(14)).redIAdd(P).redPown(3).redIMuln(16), ce = O.redMul(K);
      if (ce.isZero())
        throw new Error("Curve is not elliptic.");
      return re.redDiv(ce).fromRed();
    }
    isComplete() {
      return this.a.redJacobi() === 1 && this.d.redJacobi() === -1;
    }
    point(r, x, O, K) {
      return new y(this, r, x, O, K);
    }
    jpoint(r, x, O) {
      return I(r == null && x == null && O == null), this.point();
    }
    cpoint(r, x, O, K) {
      I(r instanceof c), I(x instanceof c), I(O instanceof c), I(K instanceof c);
      const X = r.redMul(K), P = O.redMul(x), V = x.redMul(K), re = r.redMul(O);
      return this.point(X, P, V, re);
    }
    solveX2(r) {
      I(r instanceof c);
      const x = r.redSqr(), O = this._mulD(x).redISub(this.a);
      return x.redISub(this.one).redDiv(O);
    }
    solveX(r) {
      const x = r.redSqr(), O = this._mulD(x).redISub(this.a);
      return x.redISub(this.one).redDivSqrt(O);
    }
    solveY2(r) {
      I(r instanceof c);
      const x = r.redSqr(), O = this._mulA(x).redISub(this.one), K = this._mulD(x).redISub(this.one);
      return O.redDiv(K);
    }
    solveY(r) {
      const x = r.redSqr(), O = this._mulA(x).redISub(this.one), K = this._mulD(x).redISub(this.one);
      return O.redDivSqrt(K);
    }
    validate(r) {
      if (I(r instanceof y), r.zOne) {
        const pe = r.x.redSqr(), se = r.y.redSqr(), Z = this._mulD(pe).redMul(se), ee = this._mulA(pe).redIAdd(se), me = this.one.redAdd(Z), Ae = r.t, Oe = r.x.redMul(r.y);
        return ee.eq(me) && Ae.eq(Oe);
      }
      const x = r.x.redSqr(), O = r.y.redSqr(), K = r.z.redSqr(), X = K.redSqr(), P = this._mulD(x).redMul(O), V = this._mulA(x).redIAdd(O).redMul(K), re = X.redIAdd(P), ce = r.t.redMul(r.z), de = r.x.redMul(r.y);
      return V.eq(re) && ce.eq(de);
    }
    pointFromX(r, x = null) {
      I(r instanceof c), I(x == null || typeof x == "boolean"), r.red || (r = r.toRed(this.red));
      const O = this.solveY(r);
      if (x != null) {
        if (O.isZero() && x)
          throw new Error("Invalid point.");
        O.redIsOdd() !== x && O.redINeg();
      }
      return this.point(r, O);
    }
    pointFromY(r, x = null) {
      I(r instanceof c), I(x == null || typeof x == "boolean"), r.red || (r = r.toRed(this.red));
      const O = this.solveX(r);
      if (x != null) {
        if (O.isZero() && x)
          throw new Error("Invalid point.");
        O.redIsOdd() !== x && O.redINeg();
      }
      return this.point(O, r);
    }
    isIsomorphic(r, x = !1) {
      if (I(r instanceof f), I(typeof x == "boolean"), !r.p.eq(this.p))
        return !1;
      if (r.type === "short")
        return r.isIsomorphic(this);
      if (r.type === "mont") {
        const O = this.field(r.a);
        let K, X;
        return x ? (K = this.d.redAdd(this.a), X = this.d.redSub(this.a)) : (K = this.a.redAdd(this.d), X = this.a.redSub(this.d)), O.redMul(X).eq(K.redIMuln(2));
      }
      if (r.type === "edwards") {
        const O = this.field(r.a), K = this.field(r.d);
        return this.a.redMul(K).eq(O.redMul(this.d));
      }
      return !1;
    }
    isIsogenous(r) {
      if (I(r instanceof f), !r.p.eq(this.p))
        return !1;
      if (r.type === "mont") {
        if (!this.a.eq(this.one))
          return !1;
        const x = this.field(r.a), O = this.field(r.b), K = this.two.redSub(this.d.redMuln(4));
        return x.eq(K) && O.eq(this.one);
      }
      if (r.type === "edwards") {
        const x = this.field(r.a), O = this.field(r.d);
        return x.eq(this.a.redNeg()) && O.eq(this.d.redSub(this.a));
      }
      return !1;
    }
    pointFromShort(r) {
      if (I(r instanceof o), this.isIsomorphic(r.curve)) {
        if (r.isInfinity())
          return this.point();
        if (r.y.isZero())
          return this.point(this.zero, this.one.redNeg());
        const { a: x, d: O } = this, [K, X] = this._scale(r.curve), P = x.redMuln(5), V = O.redMuln(5), re = this.field(r.x).redMul(K), ce = this.field(r.y).redMul(X), de = re.redMuln(6), pe = re.redMuln(12), se = de.redSub(x).redISub(O), Z = ce.redMuln(6), ee = pe.redSub(P).redIAdd(O), me = pe.redAdd(x).redISub(V);
        return this.cpoint(se, Z, ee, me);
      }
      throw new Error("Not implemented.");
    }
    pointFromMont(r) {
      I(r instanceof p), I(r.curve.p.eq(this.p));
      const x = this.field(r.x), O = this.field(r.y);
      if (this.isIsogenous(r.curve)) {
        if (r.isInfinity())
          return this.point();
        if (r.x.isZero())
          return this.point();
        const K = x.redSqr(), X = K.redMul(x), P = X.redMul(x), V = P.redMul(x), re = O.redSqr(), ce = O.redMuln(4), de = K.redSub(this.one), pe = K.redMuln(2), se = re.redMuln(4), Z = X.redIMuln(2), ee = x.redMul(re).redIMuln(4), me = K.redMul(re).redIMuln(2), Ae = re.redIMuln(2), Oe = ce.redMul(de), ye = P.redISub(pe).redIAdd(se).redIAdd(this.one), _e = V.redSub(Z).redISub(ee).redIAdd(x).redINeg(), ke = V.redISub(me).redISub(Z).redISub(Ae).redIAdd(x);
        return this.cpoint(Oe, ye, _e, ke).divn(4);
      }
      if (this.isIsomorphic(r.curve, !0)) {
        if (r.isInfinity())
          return this.point();
        if (r.x.isZero())
          return this.point(this.zero, this.one.redNeg());
        const X = this._scale(r.curve, !0).redMul(x), P = O, V = x.redAdd(this.one), re = x.redSub(this.one);
        return this.cpoint(X, P, V, re);
      }
      if (this.isIsomorphic(r.curve, !1)) {
        if (r.isInfinity())
          return this.point();
        if (r.x.isZero())
          return this.point(this.zero, this.one.redNeg());
        const X = this._scale(r.curve, !1).redMul(x), P = O, V = x.redSub(this.one), re = x.redAdd(this.one);
        return this.cpoint(X, P, V, re);
      }
      throw new Error("Not implemented.");
    }
    pointFromEdwards(r) {
      I(r instanceof y), I(r.curve.p.eq(this.p));
      const x = this.field(r.curve.a), O = this.field(r.x), K = this.field(r.y), X = this.field(r.z), P = this.field(r.t);
      if (this.isIsogenous(r.curve)) {
        const V = O.redMul(K), re = O.redSqr(), ce = K.redSqr(), de = X.redSqr(), pe = x.redMul(re), se = V.redIMuln(2), Z = ce.redSub(pe), ee = ce.redAdd(pe), me = de.redIMuln(2).redISub(ee), Ae = this.cpoint(se, Z, ee, me);
        return this.twisted ? Ae : Ae.divn(4);
      }
      if (this.isIsomorphic(r.curve)) {
        const V = this._scale(r.curve), re = V.redMul(O), ce = K, de = X, pe = V.redMul(P);
        return this.point(re, ce, de, pe);
      }
      throw new Error("Not implemented.");
    }
    pointFromUniform(r, x = null) {
      I(r instanceof c), I(r.red === this.red), I(x == null || x instanceof i), x || (x = this._alt());
      const O = x.field(r), K = x.pointFromUniform(O);
      return this.pointFromMont(K);
    }
    pointToUniform(r, x, O = null) {
      I(r instanceof y), I(x >>> 0 === x), I(O == null || O instanceof i), O || (O = this._alt());
      const K = (x >> 4 & 15) % this.torsion.length, X = r.add(this.torsion[K]), P = O.pointFromEdwards(X), V = O.pointToUniform(P, x & 15);
      return this.field(V);
    }
    pointFromHash(r, x, O = null) {
      I(O == null || O instanceof i), O || (O = this._alt());
      const K = O.pointFromHash(r, x);
      return this.pointFromMont(K);
    }
    pointToHash(r, x, O, K = null) {
      I(r instanceof y), I(x >>> 0 === x), I(K == null || K instanceof i), K || (K = this._alt());
      const X = x % this.torsion.length, P = r.add(this.torsion[X]), V = K.pointFromEdwards(P);
      return K.pointToHash(V, 0, O);
    }
    decodePoint(r) {
      return y.decode(this, r);
    }
    toShort(r, x, O = null) {
      const [K, X] = this._short(r, x), P = new u({
        red: this.red,
        prime: this.prime,
        p: this.p,
        a: K,
        b: X,
        n: this.n,
        h: this.h
      });
      if (O != null) {
        const [, V] = P._scale(this);
        V.redIsOdd() !== O && V.redINeg();
      }
      this.g.isInfinity() || (P.g = P.pointFromEdwards(this.g));
      for (let V = 0; V < this.h.word(0); V++)
        P.torsion[V] = P.pointFromEdwards(this.torsion[V]);
      return P;
    }
    toMont(r, x, O = null) {
      const [K, X] = this._mont(r, x), P = new i({
        red: this.red,
        prime: this.prime,
        p: this.p,
        a: K,
        b: X,
        n: this.n,
        h: this.h,
        z: this.z
      });
      if (O != null) {
        const V = this._scale(P, x);
        V.redIsOdd() !== O && V.redINeg();
      }
      this.g.isInfinity() || (P.g = P.pointFromEdwards(this.g));
      for (let V = 0; V < this.h.word(0); V++)
        P.torsion[V] = P.pointFromEdwards(this.torsion[V]);
      return P;
    }
    toEdwards(r, x = null) {
      const [O, K] = this._edwards(r), X = new S({
        red: this.red,
        prime: this.prime,
        p: this.p,
        a: O,
        d: K,
        n: this.n,
        h: this.h,
        z: this.z
      });
      if (x != null) {
        const P = X._scale(this);
        P.redIsOdd() !== x && P.redINeg();
      }
      if (this.g.isInfinity() || (X.g = X.pointFromEdwards(this.g), X.g.normalize()), X.isComplete())
        for (let P = 0; P < this.h.word(0); P++)
          X.torsion[P] = X.pointFromEdwards(this.torsion[P]), X.torsion[P].normalize();
      return X;
    }
    pointFromJSON(r) {
      return y.fromJSON(this, r);
    }
    toJSON(r) {
      const x = super.toJSON(r);
      return x.a = this.a.fromRed().toJSON(), x.d = this.d.fromRed().toJSON(), this.s.isZero() || (x.s = this.s.fromRed().toJSON()), x;
    }
  }
  class y extends n {
    constructor(r, x, O, K, X) {
      I(r instanceof S), super(r, l.EXTENDED), this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = !0, x != null && this._init(x, O, K, X);
    }
    _init(r, x, O, K) {
      I(r instanceof c), I(x instanceof c), I(O == null || O instanceof c), I(K == null || K instanceof c), this.x = r, this.y = x, this.z = O || this.curve.one, this.t = K || null, this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z.eq(this.curve.one), this._check(), this.t || (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redDiv(this.z)));
    }
    _check() {
      if (this.z.isZero())
        throw new Error("Invalid point.");
    }
    clone() {
      return this.curve.point(this.x, this.y, this.z, this.t);
    }
    normalize() {
      if (this.zOne)
        return this;
      const r = this.z.redInvert();
      return this.x = this.x.redMul(r), this.y = this.y.redMul(r), this.t = this.t.redMul(r), this.z = this.curve.one, this.zOne = !0, this;
    }
    scale(r) {
      I(r instanceof c);
      const x = this.x.redMul(r), O = this.y.redMul(r), K = this.z.redMul(r), X = this.t.redMul(r);
      return this.curve.point(x, O, K, X);
    }
    neg() {
      const r = this.x.redNeg(), x = this.y, O = this.z, K = this.t.redNeg();
      return this.curve.point(r, x, O, K);
    }
    add(r) {
      return I(r instanceof y), this.isInfinity() ? r : r.isInfinity() ? this : this.zOne ? r._add(this) : this._add(r);
    }
    _add(r) {
      return this.curve.mOneA ? this._addM1(r) : this._addA(r);
    }
    _addM1(r) {
      const x = this.y.redSub(this.x).redMul(r.y.redSub(r.x)), O = this.y.redAdd(this.x).redMul(r.y.redAdd(r.x)), K = this.t.redMul(this.curve.k).redMul(r.t), X = r.zOne ? this.z.redAdd(this.z) : this.z.redMul(r.z).redIMuln(2), P = O.redSub(x), V = X.redSub(K), re = X.redIAdd(K), ce = O.redIAdd(x), de = P.redMul(V), pe = re.redMul(ce), se = P.redMul(ce), Z = V.redMul(re);
      return this.curve.point(de, pe, Z, se);
    }
    _addA(r) {
      const x = this.x.redMul(r.x), O = this.y.redMul(r.y), K = this.curve._mulD(this.t).redMul(r.t), X = r.zOne ? this.z.clone() : this.z.redMul(r.z), V = this.x.redAdd(this.y).redMul(r.x.redAdd(r.y)).redISub(x).redISub(O), re = X.redSub(K), ce = X.redIAdd(K), de = O.redISub(this.curve._mulA(x)), pe = V.redMul(re), se = ce.redMul(de), Z = V.redMul(de), ee = re.redMul(ce);
      return this.curve.point(pe, se, ee, Z);
    }
    dbl() {
      return this.isInfinity() ? this : this._dbl();
    }
    _dbl() {
      const r = this.x.redSqr(), x = this.y.redSqr(), O = this.zOne ? this.curve.two : this.z.redSqr().redIMuln(2), K = this.curve._mulA(r), X = this.x.redAdd(this.y).redSqr().redISub(r).redISub(x), P = K.redAdd(x), V = P.redSub(O), re = K.redISub(x), ce = X.redMul(V), de = P.redMul(re), pe = X.redMul(re), se = V.redMul(P);
      return this.curve.point(ce, de, se, pe);
    }
    getX() {
      return this.normalize(), this.x.fromRed();
    }
    getY() {
      return this.normalize(), this.y.fromRed();
    }
    eq(r) {
      if (I(r instanceof y), I(!this.z.isZero()), I(!r.z.isZero()), this === r)
        return !0;
      if (this.z.eq(r.z))
        return this.x.eq(r.x) && this.y.eq(r.y);
      const x = this.x.redMul(r.z), O = r.x.redMul(this.z);
      if (!x.eq(O))
        return !1;
      const K = this.y.redMul(r.z), X = r.y.redMul(this.z);
      return K.eq(X);
    }
    cmp(r) {
      return I(r instanceof y), this.order().cmp(r.order()) || this.getY().cmp(r.getY()) || this.getX().cmp(r.getX());
    }
    isInfinity() {
      return I(!this.z.isZero()), this.x.isZero() ? this.y.eq(this.z) : !1;
    }
    isOrder2() {
      return this.isInfinity() ? !1 : this.x.isZero();
    }
    isOdd() {
      return this.normalize(), this.x.redIsOdd();
    }
    isEven() {
      return this.normalize(), this.x.redIsEven();
    }
    toP() {
      return this.normalize();
    }
    toJ() {
      return this;
    }
    encode() {
      const r = this.getY();
      return r.setn(this.curve.signBit, this.x.redIsOdd()), this.curve.encodeAdjusted(r);
    }
    static decode(r, x) {
      I(r instanceof S);
      const O = r.decodeAdjusted(x), K = O.testn(r.signBit) !== 0;
      if (O.setn(r.signBit, 0), O.cmp(r.p) >= 0)
        throw new Error("Invalid point.");
      return r.pointFromY(O, K);
    }
    toJSON(r) {
      if (this.isInfinity())
        return [];
      const x = this.getX().toJSON(), O = this.getY().toJSON();
      return r === !0 && this.pre ? [x, O, this.pre.toJSON()] : [x, O];
    }
    toPretty() {
      const r = this.curve.fieldSize * 2, x = M(this.getX(), r), O = M(this.getY(), r);
      return [x, O];
    }
    static fromJSON(r, x) {
      if (I(r instanceof S), I(Array.isArray(x)), I(x.length === 0 || x.length === 2 || x.length === 3), x.length === 0)
        return r.point();
      const O = c.fromJSON(x[0]), K = c.fromJSON(x[1]), X = r.point(O, K);
      return x.length > 2 && x[2] != null && (X.pre = b.fromJSON(X, x[2])), X;
    }
    [e]() {
      return this.isInfinity() ? "<EdwardsPoint: Infinity>" : "<EdwardsPoint: x=" + this.x.fromRed().toString(16, 2) + " y=" + this.y.fromRed().toString(16, 2) + " z=" + this.z.fromRed().toString(16, 2) + ">";
    }
  }
  class b {
    constructor() {
      this.naf = null, this.windows = null, this.doubles = null, this.blinding = null, this.beta = null;
    }
    map(r) {
      I(typeof r == "function");
      const x = new this.constructor();
      return this.naf && (x.naf = this.naf.map(r)), this.doubles && (x.doubles = this.doubles.map(r)), x;
    }
    toJSON() {
      return {
        naf: this.naf ? this.naf.toJSON() : null,
        windows: this.windows ? this.windows.toJSON() : null,
        doubles: this.doubles ? this.doubles.toJSON() : null,
        blinding: this.blinding ? this.blinding.toJSON() : void 0
      };
    }
    fromJSON(r, x) {
      return I(r instanceof n), I(x && typeof x == "object"), x.naf != null && (this.naf = h.fromJSON(r, x.naf)), x.windows != null && (this.windows = a.fromJSON(r, x.windows)), x.doubles != null && (this.doubles = E.fromJSON(r, x.doubles)), x.blinding != null && (this.blinding = H.fromJSON(r, x.blinding)), this;
    }
    static fromJSON(r, x) {
      return new this().fromJSON(r, x);
    }
  }
  class h {
    constructor(r, x) {
      this.width = r, this.points = x;
    }
    map(r) {
      I(typeof r == "function");
      const { width: x } = this, O = [];
      for (const K of this.points)
        O.push(r(K));
      return new this.constructor(x, O);
    }
    toJSON() {
      return {
        width: this.width,
        points: this.points.slice(1).map((r) => r.toJSON())
      };
    }
    static fromJSON(r, x) {
      I(r instanceof n), I(x && typeof x == "object"), I(x.width >>> 0 === x.width), I(Array.isArray(x.points));
      const { curve: O } = r, { width: K } = x, X = [r];
      for (const P of x.points)
        X.push(O.pointFromJSON(P));
      return new this(K, X);
    }
  }
  class a {
    constructor(r, x, O) {
      this.width = r, this.bits = x, this.points = O;
    }
    toJSON() {
      return {
        width: this.width,
        bits: this.bits,
        points: this.points.slice(1).map((r) => r.toJSON())
      };
    }
    static fromJSON(r, x) {
      I(r instanceof n), I(x && typeof x == "object"), I(x.width >>> 0 === x.width), I(x.bits >>> 0 === x.bits), I(Array.isArray(x.points));
      const { curve: O } = r, { width: K, bits: X } = x, P = [r];
      for (const V of x.points)
        P.push(O.pointFromJSON(V));
      return new this(K, X, P);
    }
  }
  class E {
    constructor(r, x) {
      this.step = r, this.points = x;
    }
    map(r) {
      I(typeof r == "function");
      const { step: x } = this, O = [];
      for (const K of this.points)
        O.push(r(K));
      return new this.constructor(x, O);
    }
    toJSON() {
      return {
        step: this.step,
        points: this.points.slice(1).map((r) => r.toJSON())
      };
    }
    static fromJSON(r, x) {
      I(r instanceof n), I(x && typeof x == "object"), I(x.step >>> 0 === x.step), I(Array.isArray(x.points));
      const { curve: O } = r, { step: K } = x, X = [r];
      for (const P of x.points)
        X.push(O.pointFromJSON(P));
      return new this(K, X);
    }
  }
  class H {
    constructor(r, x) {
      this.blind = r, this.unblind = x;
    }
    toJSON() {
      return {
        blind: this.blind.toJSON(),
        unblind: this.unblind.toJSON()
      };
    }
    static fromJSON(r, x) {
      I(r instanceof n), I(x && typeof x == "object");
      const { curve: O } = r, K = c.fromJSON(x.blind), X = O.pointFromJSON(x.unblind);
      return new this(K, X);
    }
  }
  class j {
    constructor(r, x, O, K) {
      this.beta = r, this.lambda = x, this.basis = O, this.pre = K;
    }
    toJSON() {
      return {
        beta: this.beta.fromRed().toJSON(),
        lambda: this.lambda.toJSON(),
        basis: [
          this.basis[0].toJSON(),
          this.basis[1].toJSON()
        ],
        pre: [
          this.pre[0],
          this.pre[1].toJSON(),
          this.pre[2].toJSON()
        ]
      };
    }
    static fromJSON(r, x) {
      I(r instanceof f), I(x && typeof x == "object"), I(Array.isArray(x.basis)), I(Array.isArray(x.pre)), I(x.basis.length === 2), I(x.pre.length === 3), I(x.pre[0] >>> 0 === x.pre[0]);
      const O = c.fromJSON(x.beta).toRed(r.red), K = c.fromJSON(x.lambda), X = [
        G.fromJSON(x.basis[0]),
        G.fromJSON(x.basis[1])
      ], P = [
        x.pre[0],
        c.fromJSON(x.pre[1]),
        c.fromJSON(x.pre[2])
      ];
      return new this(O, K, X, P);
    }
  }
  class G {
    constructor(r, x) {
      this.a = r, this.b = x;
    }
    toJSON() {
      return {
        a: this.a.toJSON(),
        b: this.b.toJSON()
      };
    }
    static fromJSON(r) {
      I(r && typeof r == "object");
      const x = c.fromJSON(r.a), O = c.fromJSON(r.b);
      return new this(x, O);
    }
  }
  class N extends u {
    constructor(r) {
      super({
        id: "P192",
        ossl: "prime192v1",
        type: "short",
        endian: "be",
        hash: "SHA256",
        prime: "p192",
        // 2^192 - 2^64 - 1 (= 3 mod 4)
        p: [
          "ffffffff ffffffff ffffffff fffffffe",
          "ffffffff ffffffff"
        ],
        // -3 mod p
        a: [
          "ffffffff ffffffff ffffffff fffffffe",
          "ffffffff fffffffc"
        ],
        b: [
          "64210519 e59c80e7 0fa7e9ab 72243049",
          "feb8deec c146b9b1"
        ],
        n: [
          "ffffffff ffffffff ffffffff 99def836",
          "146bc9b1 b4d22831"
        ],
        h: "1",
        // Icart
        z: "-5",
        g: [
          [
            "188da80e b03090f6 7cbf20eb 43a18800",
            "f4ff0afd 82ff1012"
          ],
          [
            "07192b95 ffc8da78 631011ed 6b24cdd5",
            "73f977a1 1e794811"
          ],
          r
        ]
      });
    }
  }
  class T extends u {
    constructor(r) {
      super({
        id: "P224",
        ossl: "secp224r1",
        type: "short",
        endian: "be",
        hash: "SHA256",
        prime: "p224",
        // 2^224 - 2^96 + 1 (1 mod 16)
        p: [
          "ffffffff ffffffff ffffffff ffffffff",
          "00000000 00000000 00000001"
        ],
        // -3 mod p
        a: [
          "ffffffff ffffffff ffffffff fffffffe",
          "ffffffff ffffffff fffffffe"
        ],
        b: [
          "b4050a85 0c04b3ab f5413256 5044b0b7",
          "d7bfd8ba 270b3943 2355ffb4"
        ],
        n: [
          "ffffffff ffffffff ffffffff ffff16a2",
          "e0b8f03e 13dd2945 5c5c2a3d"
        ],
        h: "1",
        // SSWU
        z: "1f",
        g: [
          [
            "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3",
            "56c21122 343280d6 115c1d21"
          ],
          [
            "bd376388 b5f723fb 4c22dfe6 cd4375a0",
            "5a074764 44d58199 85007e34"
          ],
          r
        ]
      });
    }
  }
  class A extends u {
    constructor(r) {
      super({
        id: "P256",
        ossl: "prime256v1",
        type: "short",
        endian: "be",
        hash: "SHA256",
        prime: null,
        // 2^256 - 2^224 + 2^192 + 2^96 - 1 (= 3 mod 4)
        p: [
          "ffffffff 00000001 00000000 00000000",
          "00000000 ffffffff ffffffff ffffffff"
        ],
        // -3 mod p
        a: [
          "ffffffff 00000001 00000000 00000000",
          "00000000 ffffffff ffffffff fffffffc"
        ],
        b: [
          "5ac635d8 aa3a93e7 b3ebbd55 769886bc",
          "651d06b0 cc53b0f6 3bce3c3e 27d2604b"
        ],
        n: [
          "ffffffff 00000000 ffffffff ffffffff",
          "bce6faad a7179e84 f3b9cac2 fc632551"
        ],
        h: "1",
        // SSWU
        z: "-a",
        g: [
          [
            "6b17d1f2 e12c4247 f8bce6e5 63a440f2",
            "77037d81 2deb33a0 f4a13945 d898c296"
          ],
          [
            "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16",
            "2bce3357 6b315ece cbb64068 37bf51f5"
          ],
          r
        ]
      });
    }
  }
  class q extends u {
    constructor(r) {
      super({
        id: "P384",
        ossl: "secp384r1",
        type: "short",
        endian: "be",
        hash: "SHA384",
        prime: null,
        // 2^384 - 2^128 - 2^96 + 2^32 - 1 (= 3 mod 4)
        p: [
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff ffffffff fffffffe",
          "ffffffff 00000000 00000000 ffffffff"
        ],
        // -3 mod p
        a: [
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff ffffffff fffffffe",
          "ffffffff 00000000 00000000 fffffffc"
        ],
        b: [
          "b3312fa7 e23ee7e4 988e056b e3f82d19",
          "181d9c6e fe814112 0314088f 5013875a",
          "c656398d 8a2ed19d 2a85c8ed d3ec2aef"
        ],
        n: [
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff c7634d81 f4372ddf",
          "581a0db2 48b0a77a ecec196a ccc52973"
        ],
        h: "1",
        // Icart
        z: "-c",
        g: [
          [
            "aa87ca22 be8b0537 8eb1c71e f320ad74",
            "6e1d3b62 8ba79b98 59f741e0 82542a38",
            "5502f25d bf55296c 3a545e38 72760ab7"
          ],
          [
            "3617de4a 96262c6f 5d9e98bf 9292dc29",
            "f8f41dbd 289a147c e9da3113 b5f0b8c0",
            "0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
          ],
          r
        ]
      });
    }
  }
  class _ extends u {
    constructor(r) {
      super({
        id: "P521",
        ossl: "secp521r1",
        type: "short",
        endian: "be",
        hash: "SHA512",
        prime: "p521",
        // 2^521 - 1 (= 3 mod 4)
        p: [
          "000001ff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff"
        ],
        // -3 mod p
        a: [
          "000001ff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff ffffffff ffffffff",
          "fffffffc"
        ],
        b: [
          "00000051 953eb961 8e1c9a1f 929a21a0",
          "b68540ee a2da725b 99b315f3 b8b48991",
          "8ef109e1 56193951 ec7e937b 1652c0bd",
          "3bb1bf07 3573df88 3d2c34f1 ef451fd4",
          "6b503f00"
        ],
        n: [
          "000001ff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff ffffffff ffffffff",
          "fffffffa 51868783 bf2f966b 7fcc0148",
          "f709a5d0 3bb5c9b8 899c47ae bb6fb71e",
          "91386409"
        ],
        h: "1",
        // SSWU
        z: "-4",
        g: [
          [
            "000000c6 858e06b7 0404e9cd 9e3ecb66",
            "2395b442 9c648139 053fb521 f828af60",
            "6b4d3dba a14b5e77 efe75928 fe1dc127",
            "a2ffa8de 3348b3c1 856a429b f97e7e31",
            "c2e5bd66"
          ],
          [
            "00000118 39296a78 9a3bc004 5c8a5fb4",
            "2c7d1bd9 98f54449 579b4468 17afbd17",
            "273e662c 97ee7299 5ef42640 c550b901",
            "3fad0761 353c7086 a272c240 88be9476",
            "9fd16650"
          ],
          r
        ]
      });
    }
  }
  class F extends u {
    constructor(r) {
      super({
        id: "SECP256K1",
        ossl: "secp256k1",
        type: "short",
        endian: "be",
        hash: "SHA256",
        prime: "k256",
        // 2^256 - 2^32 - 977 (= 3 mod 4)
        p: [
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff fffffffe fffffc2f"
        ],
        a: "0",
        b: "7",
        n: [
          "ffffffff ffffffff ffffffff fffffffe",
          "baaedce6 af48a03b bfd25e8c d0364141"
        ],
        h: "1",
        // SVDW
        z: "1",
        // sqrt(-3)
        c: [
          "0a2d2ba9 3507f1df 233770c2 a797962c",
          "c61f6d15 da14ecd4 7d8d27ae 1cd5f852"
        ],
        g: [
          [
            "79be667e f9dcbbac 55a06295 ce870b07",
            "029bfcdb 2dce28d9 59f2815b 16f81798"
          ],
          [
            "483ada77 26a3c465 5da4fbfc 0e1108a8",
            "fd17b448 a6855419 9c47d08f fb10d4b8"
          ],
          r
        ],
        // Precomputed endomorphism.
        endo: {
          beta: [
            "7ae96a2b 657c0710 6e64479e ac3434e9",
            "9cf04975 12f58995 c1396c28 719501ee"
          ],
          lambda: [
            "5363ad4c c05c30e0 a5261c02 8812645a",
            "122e22ea 20816678 df02967c 1b23bd72"
          ],
          basis: [
            {
              a: "3086d221a7d46bcde86c90e49284eb15",
              b: "-e4437ed6010e88286f547fa90abfe4c3"
            },
            {
              a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
              b: "3086d221a7d46bcde86c90e49284eb15"
            }
          ],
          pre: [
            384,
            [
              "3086d221 a7d46bcd e86c90e4 9284eb15",
              "3daa8a14 71e8ca7f e893209a 45dbb031"
            ],
            [
              "-",
              "e4437ed6 010e8828 6f547fa9 0abfe4c4",
              "221208ac 9df506c6 1571b4ae 8ac47f71"
            ]
          ]
        }
      });
    }
  }
  class R extends u {
    constructor(r) {
      super({
        id: "BRAINPOOLP256",
        ossl: "brainpoolP256r1",
        type: "short",
        endian: "be",
        hash: "SHA256",
        prime: null,
        // (= 3 mod 4)
        p: [
          "a9fb57db a1eea9bc 3e660a90 9d838d72",
          "6e3bf623 d5262028 2013481d 1f6e5377"
        ],
        a: [
          "7d5a0975 fc2c3057 eef67530 417affe7",
          "fb8055c1 26dc5c6c e94a4b44 f330b5d9"
        ],
        b: [
          "26dc5c6c e94a4b44 f330b5d9 bbd77cbf",
          "95841629 5cf7e1ce 6bccdc18 ff8c07b6"
        ],
        n: [
          "a9fb57db a1eea9bc 3e660a90 9d838d71",
          "8c397aa3 b561a6f7 901e0e82 974856a7"
        ],
        h: "1",
        // Icart
        z: "-2",
        g: [
          [
            "8bd2aeb9 cb7e57cb 2c4b482f fc81b7af",
            "b9de27e1 e3bd23c2 3a4453bd 9ace3262"
          ],
          [
            "547ef835 c3dac4fd 97f8461a 14611dc9",
            "c2774513 2ded8e54 5c1d54c7 2f046997"
          ],
          r
        ]
      });
    }
  }
  class L extends u {
    constructor(r) {
      super({
        id: "BRAINPOOLP384",
        ossl: "brainpoolP384r1",
        type: "short",
        endian: "be",
        hash: "SHA384",
        prime: null,
        // (= 3 mod 4)
        p: [
          "8cb91e82 a3386d28 0f5d6f7e 50e641df",
          "152f7109 ed5456b4 12b1da19 7fb71123",
          "acd3a729 901d1a71 87470013 3107ec53"
        ],
        a: [
          "7bc382c6 3d8c150c 3c72080a ce05afa0",
          "c2bea28e 4fb22787 139165ef ba91f90f",
          "8aa5814a 503ad4eb 04a8c7dd 22ce2826"
        ],
        b: [
          "04a8c7dd 22ce2826 8b39b554 16f0447c",
          "2fb77de1 07dcd2a6 2e880ea5 3eeb62d5",
          "7cb43902 95dbc994 3ab78696 fa504c11"
        ],
        n: [
          "8cb91e82 a3386d28 0f5d6f7e 50e641df",
          "152f7109 ed5456b3 1f166e6c ac0425a7",
          "cf3ab6af 6b7fc310 3b883202 e9046565"
        ],
        h: "1",
        // SSWU
        z: "-5",
        g: [
          [
            "1d1c64f0 68cf45ff a2a63a81 b7c13f6b",
            "8847a3e7 7ef14fe3 db7fcafe 0cbd10e8",
            "e826e034 36d646aa ef87b2e2 47d4af1e"
          ],
          [
            "8abe1d75 20f9c2a4 5cb1eb8e 95cfd552",
            "62b70b29 feec5864 e19c054f f9912928",
            "0e464621 77918111 42820341 263c5315"
          ],
          r
        ]
      });
    }
  }
  class fe extends u {
    constructor(r) {
      super({
        id: "BRAINPOOLP512",
        ossl: "brainpoolP512r1",
        type: "short",
        endian: "be",
        hash: "SHA512",
        prime: null,
        // (= 3 mod 4)
        p: [
          "aadd9db8 dbe9c48b 3fd4e6ae 33c9fc07",
          "cb308db3 b3c9d20e d6639cca 70330871",
          "7d4d9b00 9bc66842 aecda12a e6a380e6",
          "2881ff2f 2d82c685 28aa6056 583a48f3"
        ],
        a: [
          "7830a331 8b603b89 e2327145 ac234cc5",
          "94cbdd8d 3df91610 a83441ca ea9863bc",
          "2ded5d5a a8253aa1 0a2ef1c9 8b9ac8b5",
          "7f1117a7 2bf2c7b9 e7c1ac4d 77fc94ca"
        ],
        b: [
          "3df91610 a83441ca ea9863bc 2ded5d5a",
          "a8253aa1 0a2ef1c9 8b9ac8b5 7f1117a7",
          "2bf2c7b9 e7c1ac4d 77fc94ca dc083e67",
          "984050b7 5ebae5dd 2809bd63 8016f723"
        ],
        n: [
          "aadd9db8 dbe9c48b 3fd4e6ae 33c9fc07",
          "cb308db3 b3c9d20e d6639cca 70330870",
          "553e5c41 4ca92619 41866119 7fac1047",
          "1db1d381 085ddadd b5879682 9ca90069"
        ],
        h: "1",
        // Icart
        z: "7",
        g: [
          [
            "81aee4bd d82ed964 5a21322e 9c4c6a93",
            "85ed9f70 b5d916c1 b43b62ee f4d0098e",
            "ff3b1f78 e2d0d48d 50d1687b 93b97d5f",
            "7c6d5047 406a5e68 8b352209 bcb9f822"
          ],
          [
            "7dde385d 566332ec c0eabfa9 cf7822fd",
            "f209f700 24a57b1a a000c55b 881f8111",
            "b2dcde49 4a5f485e 5bca4bd8 8a2763ae",
            "d1ca2b2f a8f05406 78cd1e0f 3ad80892"
          ],
          r
        ]
      });
    }
  }
  class ue extends i {
    constructor() {
      super({
        id: "X25519",
        ossl: "X25519",
        type: "mont",
        endian: "le",
        hash: "SHA512",
        prime: "p25519",
        // 2^255 - 19 (= 5 mod 8)
        p: [
          "7fffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff ffffffff ffffffed"
        ],
        // 486662
        a: "76d06",
        b: "1",
        n: [
          "10000000 00000000 00000000 00000000",
          "14def9de a2f79cd6 5812631a 5cf5d3ed"
        ],
        h: "8",
        // Elligator 2
        z: "2",
        g: [
          [
            "00000000 00000000 00000000 00000000",
            "00000000 00000000 00000000 00000009"
          ],
          // See: https://www.rfc-editor.org/errata/eid4730
          [
            "5f51e65e 475f794b 1fe122d3 88b72eb3",
            "6dc2b281 92839e4d d6163a5d 81312c14"
          ]
        ],
        torsion: [
          [],
          [
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000"
            ],
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000"
            ]
          ],
          [
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000001"
            ],
            [
              "6be4f497 f9a9c2af c21fa77a d7f4a6ef",
              "635a11c7 284a9363 e9a248ef 9c884415"
            ]
          ],
          [
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000001"
            ],
            [
              "141b0b68 06563d50 3de05885 280b5910",
              "9ca5ee38 d7b56c9c 165db710 6377bbd8"
            ]
          ],
          [
            [
              "57119fd0 dd4e22d8 868e1c58 c45c4404",
              "5bef839c 55b1d0b1 248c50a3 bc959c5f"
            ],
            [
              "68c59389 3d458e64 31c6ca00 45fb5015",
              "20a44346 8eaa68dd 0f103842 048065b7"
            ]
          ],
          [
            [
              "57119fd0 dd4e22d8 868e1c58 c45c4404",
              "5bef839c 55b1d0b1 248c50a3 bc959c5f"
            ],
            [
              "173a6c76 c2ba719b ce3935ff ba04afea",
              "df5bbcb9 71559722 f0efc7bd fb7f9a36"
            ]
          ],
          [
            [
              "00b8495f 16056286 fdb1329c eb8d09da",
              "6ac49ff1 fae35616 aeb8413b 7c7aebe0"
            ],
            [
              "3931c129 569e83a5 29482c14 e628b457",
              "933bfc29 ed801b4d 68871483 92507b1a"
            ]
          ],
          [
            [
              "00b8495f 16056286 fdb1329c eb8d09da",
              "6ac49ff1 fae35616 aeb8413b 7c7aebe0"
            ],
            [
              "46ce3ed6 a9617c5a d6b7d3eb 19d74ba8",
              "6cc403d6 127fe4b2 9778eb7c 6daf84d3"
            ]
          ]
        ]
      });
    }
  }
  class ae extends i {
    constructor() {
      super({
        id: "X448",
        ossl: "X448",
        type: "mont",
        endian: "le",
        hash: "SHAKE256",
        prime: "p448",
        // 2^448 - 2^224 - 1 (= 3 mod 4)
        p: [
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff fffffffe ffffffff",
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff"
        ],
        // 156326
        a: "262a6",
        b: "1",
        n: [
          "3fffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff ffffffff 7cca23e9",
          "c44edb49 aed63690 216cc272 8dc58f55",
          "2378c292 ab5844f3"
        ],
        h: "4",
        // Elligator 2
        z: "-1",
        g: [
          [
            "00000000 00000000 00000000 00000000",
            "00000000 00000000 00000000 00000000",
            "00000000 00000000 00000000 00000000",
            "00000000 00000005"
          ],
          [
            "7d235d12 95f5b1f6 6c98ab6e 58326fce",
            "cbae5d34 f55545d0 60f75dc2 8df3f6ed",
            "b8027e23 46430d21 1312c4b1 50677af7",
            "6fd7223d 457b5b1a"
          ]
        ],
        torsion: [
          [],
          [
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000"
            ],
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000"
            ]
          ],
          [
            [
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff ffffffff fffffffe ffffffff",
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff fffffffe"
            ],
            [
              "ba4d3a08 29b6112f 8812e51b a0bb2abe",
              "bc1cb08e b48e5569 36ba50fd d2e7d68a",
              "f8cb3216 0522425b 3f990812 abbe635a",
              "d37a21e1 7551b193"
            ]
          ],
          [
            [
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff ffffffff fffffffe ffffffff",
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff fffffffe"
            ],
            [
              "45b2c5f7 d649eed0 77ed1ae4 5f44d541",
              "43e34f71 4b71aa96 c945af01 2d182975",
              "0734cde9 faddbda4 c066f7ed 54419ca5",
              "2c85de1e 8aae4e6c"
            ]
          ]
        ]
      });
    }
  }
  class D extends i {
    constructor() {
      super({
        id: "MONT448",
        ossl: null,
        type: "mont",
        endian: "le",
        hash: "SHAKE256",
        prime: "p448",
        // 2^448 - 2^224 - 1 (= 3 mod 4)
        p: [
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff fffffffe ffffffff",
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff"
        ],
        // -78160 / -39082 mod p
        a: [
          "b2cf97d2 d43459a9 31ed36b1 fc4e3cb5",
          "5d93f8d2 22746997 60ccffc6 49961ed6",
          "c5b05fca c24864ed 6fb59697 931b78da",
          "84ddecd8 ca2b5cfb"
        ],
        b: "1",
        n: [
          "3fffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff ffffffff 7cca23e9",
          "c44edb49 aed63690 216cc272 8dc58f55",
          "2378c292 ab5844f3"
        ],
        h: "4",
        // Elligator 2
        z: "-1",
        g: [
          [
            "ac0d24cc c6c75cb0 eb71f81e 7a6edf51",
            "48e88aee 009a2a24 e795687e c28e125a",
            "3e6730a6 0d46367b aa7fe99d 152128dc",
            "41321bc7 7817f059"
          ],
          [
            "5a4437f6 80c0d0db 9b061276 d5d0ffcc",
            "e786ff33 b6a53d30 98746425 82e66f09",
            "4433dae7 7244a6e2 6b11e905 7228f483",
            "556c41a5 913f55fe"
          ]
        ],
        torsion: [
          [],
          [
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000"
            ],
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000"
            ]
          ],
          [
            [
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff ffffffff fffffffe ffffffff",
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff fffffffe"
            ],
            [
              "bec92fd0 6da2acf2 b4e261e8 7cef0d34",
              "22e75c18 3c589857 b71924e5 73c2f9ce",
              "e18da5f2 466e2f39 3c2eedf0 f105a60a",
              "b40c717d 4f1e1fd7"
            ]
          ],
          [
            [
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff ffffffff fffffffe ffffffff",
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff fffffffe"
            ],
            [
              "4136d02f 925d530d 4b1d9e17 8310f2cb",
              "dd18a3e7 c3a767a8 48e6db19 8c3d0631",
              "1e725a0d b991d0c6 c3d1120f 0efa59f5",
              "4bf38e82 b0e1e028"
            ]
          ]
        ]
      });
    }
  }
  class Q extends S {
    constructor(r) {
      super({
        id: "ED25519",
        ossl: "ED25519",
        type: "edwards",
        endian: "le",
        hash: "SHA512",
        prefix: "SigEd25519 no Ed25519 collisions",
        context: !1,
        prime: "p25519",
        // 2^255 - 19 (= 5 mod 8)
        p: [
          "7fffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff ffffffff ffffffed"
        ],
        a: "-1",
        // -121665 / 121666 mod p
        d: [
          "52036cee 2b6ffe73 8cc74079 7779e898",
          "00700a4d 4141d8ab 75eb4dca 135978a3"
        ],
        n: [
          "10000000 00000000 00000000 00000000",
          "14def9de a2f79cd6 5812631a 5cf5d3ed"
        ],
        h: "8",
        // Elligator 2
        z: "2",
        g: [
          [
            "216936d3 cd6e53fe c0a4e231 fdd6dc5c",
            "692cc760 9525a7b2 c9562d60 8f25d51a"
          ],
          // 4/5
          [
            "66666666 66666666 66666666 66666666",
            "66666666 66666666 66666666 66666658"
          ],
          r
        ],
        torsion: [
          [
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000"
            ],
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000001"
            ]
          ],
          [
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000"
            ],
            [
              "7fffffff ffffffff ffffffff ffffffff",
              "ffffffff ffffffff ffffffff ffffffec"
            ]
          ],
          [
            [
              "2b832480 4fc1df0b 2b4d0099 3dfbd7a7",
              "2f431806 ad2fe478 c4ee1b27 4a0ea0b0"
            ],
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000"
            ]
          ],
          [
            [
              "547cdb7f b03e20f4 d4b2ff66 c2042858",
              "d0bce7f9 52d01b87 3b11e4d8 b5f15f3d"
            ],
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000"
            ]
          ],
          [
            [
              "1fd5b9a0 06394a28 e9339932 38de4abb",
              "5c193c70 13e5e238 dea14646 c545d14a"
            ],
            [
              "05fc536d 880238b1 3933c6d3 05acdfd5",
              "f098eff2 89f4c345 b027b2c2 8f95e826"
            ]
          ],
          [
            [
              "602a465f f9c6b5d7 16cc66cd c721b544",
              "a3e6c38f ec1a1dc7 215eb9b9 3aba2ea3"
            ],
            [
              "05fc536d 880238b1 3933c6d3 05acdfd5",
              "f098eff2 89f4c345 b027b2c2 8f95e826"
            ]
          ],
          [
            [
              "1fd5b9a0 06394a28 e9339932 38de4abb",
              "5c193c70 13e5e238 dea14646 c545d14a"
            ],
            [
              "7a03ac92 77fdc74e c6cc392c fa53202a",
              "0f67100d 760b3cba 4fd84d3d 706a17c7"
            ]
          ],
          [
            [
              "602a465f f9c6b5d7 16cc66cd c721b544",
              "a3e6c38f ec1a1dc7 215eb9b9 3aba2ea3"
            ],
            [
              "7a03ac92 77fdc74e c6cc392c fa53202a",
              "0f67100d 760b3cba 4fd84d3d 706a17c7"
            ]
          ]
        ]
      });
    }
  }
  class W extends S {
    constructor(r) {
      super({
        id: "ISO448",
        ossl: null,
        type: "edwards",
        endian: "le",
        hash: "SHAKE256",
        prefix: "SigEd448",
        context: !0,
        prime: "p448",
        // 2^448 - 2^224 - 1 (= 3 mod 4)
        p: [
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff fffffffe ffffffff",
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff"
        ],
        a: "1",
        // 39082 / 39081 mod p
        d: [
          "d78b4bdc 7f0daf19 f24f38c2 9373a2cc",
          "ad461572 42a50f37 809b1da3 412a12e7",
          "9ccc9c81 264cfe9a d0809970 58fb61c4",
          "243cc32d baa156b9"
        ],
        n: [
          "3fffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff ffffffff 7cca23e9",
          "c44edb49 aed63690 216cc272 8dc58f55",
          "2378c292 ab5844f3"
        ],
        h: "4",
        // Elligator 2
        z: "-1",
        g: [
          [
            "79a70b2b 70400553 ae7c9df4 16c792c6",
            "1128751a c9296924 0c25a07d 728bdc93",
            "e21f7787 ed697224 9de732f3 8496cd11",
            "69871309 3e9c04fc"
          ],
          // Note: the RFC has this wrong.
          [
            "7fffffff ffffffff ffffffff ffffffff",
            "ffffffff ffffffff ffffffff 80000000",
            "00000000 00000000 00000000 00000000",
            "00000000 00000001"
          ],
          r
        ],
        torsion: [
          [
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000"
            ],
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000001"
            ]
          ],
          [
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000"
            ],
            [
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff ffffffff fffffffe ffffffff",
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff fffffffe"
            ]
          ],
          [
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000001"
            ],
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000"
            ]
          ],
          [
            [
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff ffffffff fffffffe ffffffff",
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff fffffffe"
            ],
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000"
            ]
          ]
        ]
      });
    }
  }
  class oe extends S {
    constructor(r) {
      super({
        id: "ED448",
        ossl: "ED448",
        type: "edwards",
        endian: "le",
        hash: "SHAKE256",
        prefix: "SigEd448",
        context: !0,
        prime: "p448",
        // 2^448 - 2^224 - 1 (= 3 mod 4)
        p: [
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff fffffffe ffffffff",
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff"
        ],
        a: "1",
        // -39081 mod p
        d: [
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff fffffffe ffffffff",
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffff6756"
        ],
        n: [
          "3fffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff ffffffff 7cca23e9",
          "c44edb49 aed63690 216cc272 8dc58f55",
          "2378c292 ab5844f3"
        ],
        h: "4",
        // Elligator 2
        z: "-1",
        g: [
          [
            "4f1970c6 6bed0ded 221d15a6 22bf36da",
            "9e146570 470f1767 ea6de324 a3d3a464",
            "12ae1af7 2ab66511 433b80e1 8b00938e",
            "2626a82b c70cc05e"
          ],
          [
            "693f4671 6eb6bc24 88762037 56c9c762",
            "4bea7373 6ca39840 87789c1e 05a0c2d7",
            "3ad3ff1c e67c39c4 fdbd132c 4ed7c8ad",
            "9808795b f230fa14"
          ],
          r
        ],
        torsion: [
          [
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000"
            ],
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000001"
            ]
          ],
          [
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000"
            ],
            [
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff ffffffff fffffffe ffffffff",
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff fffffffe"
            ]
          ],
          [
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000001"
            ],
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000"
            ]
          ],
          [
            [
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff ffffffff fffffffe ffffffff",
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff fffffffe"
            ],
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000"
            ]
          ]
        ]
      });
    }
  }
  const v = {
    __proto__: null,
    P192: N,
    P224: T,
    P256: A,
    P384: q,
    P521: _,
    SECP256K1: F,
    BRAINPOOLP256: R,
    BRAINPOOLP384: L,
    BRAINPOOLP512: fe,
    X25519: ue,
    X448: ae,
    MONT448: D,
    ED25519: Q,
    ISO448: W,
    ED448: oe
  }, Y = {
    __proto__: null,
    P192: null,
    P224: null,
    P256: null,
    P384: null,
    P521: null,
    SECP256K1: null,
    BRAINPOOLP256: null,
    BRAINPOOLP384: null,
    BRAINPOOLP512: null,
    X25519: null,
    X448: null,
    MONT448: null,
    ED25519: null,
    ISO448: null,
    ED448: null
  };
  function he($, ...r) {
    I(typeof $ == "string");
    const x = $.toUpperCase();
    let O = Y[x];
    if (!O) {
      const K = v[x];
      if (!K)
        throw new Error(`Curve not found: "${$}".`);
      O = new K(...r), Y[x] = O;
    }
    return O;
  }
  function le($, r) {
    I(typeof $ == "string"), I(typeof r == "function");
    const x = $.toUpperCase();
    if (v[x])
      throw new Error(`Curve already registered: "${$}".`);
    v[x] = r, Y[x] = null;
  }
  function ge($, r, x) {
    I($ instanceof c), I(!$.red), I(r >>> 0 === r), I(x >>> 0 === x);
    const O = new Array(x), K = $.bitLength() + 1, X = $.sign() | 1;
    I(K <= x);
    for (let ce = 0; ce < x; ce++)
      O[ce] = 0;
    let P = 0, V = 0, re;
    for (; P < K; ) {
      if ($.bit(P) === V) {
        P += 1;
        continue;
      }
      re = $.bits(P, r) + V, V = re >> r - 1 & 1, re -= V << r, O[P] = X * re, P += r;
    }
    return I(V === 0), O;
  }
  function Ee($, r, x, O) {
    I(O >>> 0 === O);
    const K = ge($, r, x), X = Math.ceil(K.length / O), P = new Array(X);
    let V = 0;
    for (let re = 0; re < K.length; re += O) {
      let ce = 0;
      for (let de = re + O - 1; de >= re; de--)
        ce = (ce << 1) + K[de];
      P[V++] = ce;
    }
    return I(V === X), P;
  }
  function we($, r, x) {
    I($ instanceof c), I(r instanceof c), I(!$.red), I(!r.red), I(x >>> 0 === x);
    const O = [new Array(x), new Array(x)], K = Math.max($.bitLength(), r.bitLength()) + 1, X = $.sign() | 1, P = r.sign() | 1;
    I(K <= x);
    let V = 0, re = 0;
    for (let ce = 0; ce < K; ce++) {
      const de = $.bits(ce, 3), pe = r.bits(ce, 3);
      let se = (de & 3) + V & 3, Z = (pe & 3) + re & 3, ee = 0, me = 0;
      if (se === 3 && (se = -1), Z === 3 && (Z = -1), se & 1) {
        const Ae = (de & 7) + V & 7;
        (Ae === 3 || Ae === 5) && Z === 2 ? ee = -se : ee = se;
      }
      if (Z & 1) {
        const Ae = (pe & 7) + re & 7;
        (Ae === 3 || Ae === 5) && se === 2 ? me = -Z : me = Z;
      }
      O[0][ce] = ee * X, O[1][ce] = me * P, 2 * V === 1 + ee && (V = 1 - V), 2 * re === 1 + me && (re = 1 - re);
    }
    for (let ce = K; ce < x; ce++)
      O[0][ce] = 0, O[1][ce] = 0;
    return O;
  }
  function z($, r, x) {
    const O = we($, r, x), K = new Array(x);
    for (let X = 0; X < x; X++) {
      const P = O[0][X], V = O[1][X];
      K[X] = w[(P + 1) * 3 + (V + 1)];
    }
    return K;
  }
  function I($, r) {
    if (!$) {
      const x = new Error(r || "Assertion failed");
      throw Error.captureStackTrace && Error.captureStackTrace(x, I), x;
    }
  }
  function ne($) {
    I(typeof $ == "function");
    try {
      return $();
    } catch (r) {
      throw r.message === "X is not a square mod P." || r.message === "Not invertible." ? new Error("Invalid point.") : r;
    }
  }
  function t($, r) {
    let x = $ % r;
    return x < 0 && (x += r), x;
  }
  function d($) {
    I($ instanceof c), I($.red);
    const r = $.red.m;
    if (r.cmpn(3) <= 0)
      return $.clone();
    if (r.modrn(3) === 2) {
      const O = r.ushln(1).isubn(1).idivn(3);
      return $.redPow(O);
    }
    const x = r.modrn(9);
    if (x === 4) {
      const O = r.ushln(1).iaddn(1).idivn(9), K = $.redPow(O);
      if (!K.redSqr().redMul(K).eq($))
        throw new Error("X is not a cube mod P.");
      return K;
    }
    if (x === 7) {
      const O = r.addn(2).idivn(9), K = $.redPow(O);
      if (!K.redSqr().redMul(K).eq($))
        throw new Error("X is not a cube mod P.");
      return K;
    }
    throw new Error("Not implemented.");
  }
  function B($) {
    const r = d($);
    if ($.red.m.modrn(3) === 1) {
      const x = new c(2).toRed($.red), O = new c(3).toRed($.red), K = x.redInvert(), X = O.redNeg().redSqrt().redMul(K), P = X.redNeg(), V = X.redSub(K), re = P.redSub(K), ce = r.redMul(V), de = r.redMul(re);
      return [r, ce, de];
    }
    return [r];
  }
  function U($) {
    for (const r of B($))
      if (r.redJacobi() >= 0)
        return r;
    throw new Error("X^(1/3) is not a square mod P.");
  }
  function J($) {
    return c.randomBits($, 32).toNumber();
  }
  function C($, r) {
    const x = /* @__PURE__ */ new WeakMap();
    return function(K, X) {
      const P = X & 1, V = x.get(K);
      if (V && V[P] !== null)
        return V[P];
      const re = $.call(r, K, X);
      return x.has(K) || x.set(K, [null, null]), x.get(K)[P] = re, re;
    };
  }
  function M($, r) {
    I($ instanceof c), I(r >>> 0 === r), r & 7 && (r += 8 - (r & 7));
    const x = $.toString(16, r), O = [], K = [];
    I((x.length & 7) === 0);
    for (let X = 0; X < x.length; X += 8)
      O.push(x.slice(X, X + 8));
    for (let X = 0; X < O.length; X += 4)
      K.push(O.slice(X, X + 4).join(" "));
    return K;
  }
  return tr.Curve = f, tr.Point = n, tr.ShortCurve = u, tr.ShortPoint = o, tr.JPoint = s, tr.MontCurve = i, tr.MontPoint = p, tr.XPoint = g, tr.EdwardsCurve = S, tr.EdwardsPoint = y, tr.curves = v, tr.curve = he, tr.register = le, tr;
}
var yu, a3;
function as() {
  if (a3) return yu;
  a3 = 1;
  const e = Nt(), c = Xr(), l = yi(), w = Op(), m = Zw(), f = Rp(), n = Qw();
  class u {
    constructor(s, i, p, g) {
      e(typeof s == "string"), e(i), e(p), this.id = s, this.type = "ecdsa", this.hash = i, this.xof = p, this.native = 0, this._pre = g || null, this._curve = null, this._schnorr = null;
    }
    get curve() {
      return this._curve || (this._curve = n.curve(this.id, this._pre), this._curve.precompute(l), this._pre = null), this._curve;
    }
    get schnorr() {
      return this._schnorr || (this._schnorr = new m(this.curve, this.xof)), this._schnorr;
    }
    get size() {
      return this.curve.fieldSize;
    }
    get bits() {
      return this.curve.fieldBits;
    }
    privateKeyGenerate() {
      const s = this.curve.randomScalar(l);
      return this.curve.encodeScalar(s);
    }
    privateKeyVerify(s) {
      e(k.isBuffer(s));
      let i;
      try {
        i = this.curve.decodeScalar(s);
      } catch {
        return !1;
      }
      return !i.isZero() && i.cmp(this.curve.n) < 0;
    }
    privateKeyExport(s) {
      const i = this.publicKeyCreate(s, !1), { x: p, y: g } = this.publicKeyExport(i);
      return {
        d: k.from(s),
        x: p,
        y: g
      };
    }
    privateKeyImport(s) {
      e(s && typeof s == "object");
      const i = c.decode(s.d, this.curve.endian);
      if (i.isZero() || i.cmp(this.curve.n) >= 0)
        throw new Error("Invalid private key.");
      return this.curve.encodeScalar(i);
    }
    privateKeyTweakAdd(s, i) {
      const p = this.curve.decodeScalar(i);
      if (p.cmp(this.curve.n) >= 0)
        throw new Error("Invalid scalar.");
      const g = this.curve.decodeScalar(s);
      if (g.isZero() || g.cmp(this.curve.n) >= 0)
        throw new Error("Invalid private key.");
      const S = g.add(p).imod(this.curve.n);
      if (S.isZero())
        throw new Error("Invalid private key.");
      return this.curve.encodeScalar(S);
    }
    privateKeyTweakMul(s, i) {
      const p = this.curve.decodeScalar(i);
      if (p.isZero() || p.cmp(this.curve.n) >= 0)
        throw new Error("Invalid scalar.");
      const g = this.curve.decodeScalar(s);
      if (g.isZero() || g.cmp(this.curve.n) >= 0)
        throw new Error("Invalid private key.");
      const S = g.mul(p).imod(this.curve.n);
      if (S.isZero())
        throw new Error("Invalid private key.");
      return this.curve.encodeScalar(S);
    }
    privateKeyNegate(s) {
      const i = this.curve.decodeScalar(s);
      if (i.isZero() || i.cmp(this.curve.n) >= 0)
        throw new Error("Invalid private key.");
      const p = i.neg().imod(this.curve.n);
      return this.curve.encodeScalar(p);
    }
    privateKeyInvert(s) {
      const i = this.curve.decodeScalar(s);
      if (i.isZero() || i.cmp(this.curve.n) >= 0)
        throw new Error("Invalid private key.");
      const p = i.invert(this.curve.n);
      return this.curve.encodeScalar(p);
    }
    publicKeyCreate(s, i) {
      const p = this.curve.decodeScalar(s);
      if (p.isZero() || p.cmp(this.curve.n) >= 0)
        throw new Error("Invalid private key.");
      return this.curve.g.mulBlind(p).encode(i);
    }
    publicKeyConvert(s, i) {
      return this.curve.decodePoint(s).encode(i);
    }
    publicKeyFromUniform(s, i) {
      const p = this.curve.decodeUniform(s);
      return this.curve.pointFromUniform(p).encode(i);
    }
    publicKeyToUniform(s, i = l.randomInt()) {
      const p = this.curve.decodePoint(s), g = this.curve.pointToUniform(p, i);
      return this.curve.encodeUniform(g, i >>> 8);
    }
    publicKeyFromHash(s, i) {
      return this.curve.pointFromHash(s).encode(i);
    }
    publicKeyToHash(s) {
      const i = this.curve.decodePoint(s);
      return this.curve.pointToHash(i, 0, l);
    }
    publicKeyVerify(s) {
      e(k.isBuffer(s));
      try {
        this.curve.decodePoint(s);
      } catch {
        return !1;
      }
      return !0;
    }
    publicKeyExport(s) {
      const { x: i, y: p } = this.curve.decodePoint(s);
      return {
        x: this.curve.encodeField(i.fromRed()),
        y: this.curve.encodeField(p.fromRed())
      };
    }
    publicKeyImport(s, i) {
      e(s && typeof s == "object");
      const p = c.decode(s.x, this.curve.endian);
      if (p.cmp(this.curve.p) >= 0)
        throw new Error("Invalid point.");
      if (s.y != null) {
        const S = c.decode(s.y, this.curve.endian);
        if (S.cmp(this.curve.p) >= 0)
          throw new Error("Invalid point.");
        const y = this.curve.point(p, S);
        if (!y.validate())
          throw new Error("Invalid point.");
        return y.encode(i);
      }
      return this.curve.pointFromX(p, s.sign).encode(i);
    }
    publicKeyTweakAdd(s, i, p) {
      const g = this.curve.decodeScalar(i);
      if (g.cmp(this.curve.n) >= 0)
        throw new Error("Invalid scalar.");
      const S = this.curve.decodePoint(s);
      return this.curve.g.jmul(g).add(S).encode(p);
    }
    publicKeyTweakMul(s, i, p) {
      const g = this.curve.decodeScalar(i);
      if (g.isZero() || g.cmp(this.curve.n) >= 0)
        throw new Error("Invalid scalar.");
      return this.curve.decodePoint(s).mul(g).encode(p);
    }
    publicKeyCombine(s, i) {
      e(Array.isArray(s));
      let p = this.curve.jpoint();
      for (const g of s) {
        const S = this.curve.decodePoint(g);
        p = p.add(S);
      }
      return p.encode(i);
    }
    publicKeyNegate(s, i) {
      return this.curve.decodePoint(s).neg().encode(i);
    }
    signatureNormalize(s) {
      const [i, p] = this._decodeCompact(s);
      return p.cmp(this.curve.nh) > 0 && p.ineg().imod(this.curve.n), this._encodeCompact(i, p);
    }
    signatureNormalizeDER(s) {
      const [i, p] = this._decodeDER(s, !1);
      return p.cmp(this.curve.nh) > 0 && p.ineg().imod(this.curve.n), this._encodeDER(i, p);
    }
    signatureExport(s) {
      const [i, p] = this._decodeCompact(s);
      return this._encodeDER(i, p);
    }
    signatureImport(s) {
      const [i, p] = this._decodeDER(s, !1);
      return this._encodeCompact(i, p);
    }
    isLowS(s) {
      e(k.isBuffer(s));
      let i;
      try {
        [, i] = this._decodeCompact(s);
      } catch {
        return !1;
      }
      return i.cmp(this.curve.nh) <= 0;
    }
    isLowDER(s) {
      e(k.isBuffer(s));
      let i;
      try {
        [, i] = this._decodeDER(s, !1);
      } catch {
        return !1;
      }
      return i.cmp(this.curve.nh) <= 0;
    }
    sign(s, i) {
      const [p, g] = this._sign(s, i);
      return this._encodeCompact(p, g);
    }
    signRecoverable(s, i) {
      const [p, g, S] = this._sign(s, i);
      return [this._encodeCompact(p, g), S];
    }
    signDER(s, i) {
      const [p, g] = this._sign(s, i);
      return this._encodeDER(p, g);
    }
    signRecoverableDER(s, i) {
      const [p, g, S] = this._sign(s, i);
      return [this._encodeDER(p, g), S];
    }
    _sign(s, i) {
      const { n: p, nh: g } = this.curve, S = this.curve.g, y = this.curve.decodeScalar(i);
      if (y.isZero() || y.cmp(p) >= 0)
        throw new Error("Invalid private key.");
      const b = this._reduce(s), h = this.curve.encodeScalar(b), a = new f(this.hash, i, h);
      for (; ; ) {
        const E = a.generate(this.curve.scalarSize), H = this._truncate(E);
        if (H.isZero() || H.cmp(p) >= 0)
          continue;
        const j = S.mulBlind(H);
        if (j.isInfinity())
          continue;
        const G = j.getX(), N = G.mod(p);
        if (N.isZero())
          continue;
        const T = this.curve.randomScalar(l), A = H.mul(T).fermat(p), q = y.mul(T).imod(p), _ = b.mul(T).imod(p), R = N.mul(q).iadd(_).imod(p).mul(A).imod(p);
        if (R.isZero())
          continue;
        let L = j.isOdd() | !G.eq(N) << 1;
        return R.cmp(g) > 0 && (R.ineg().imod(p), L ^= 1), [N, R, L];
      }
    }
    verify(s, i, p) {
      e(k.isBuffer(s)), e(k.isBuffer(i)), e(k.isBuffer(p));
      let g, S;
      try {
        [g, S] = this._decodeCompact(i);
      } catch {
        return !1;
      }
      try {
        return this._verify(s, g, S, p);
      } catch {
        return !1;
      }
    }
    verifyDER(s, i, p) {
      e(k.isBuffer(s)), e(k.isBuffer(i)), e(k.isBuffer(p));
      let g, S;
      try {
        [g, S] = this._decodeDER(i, !1);
      } catch {
        return !1;
      }
      try {
        return this._verify(s, g, S, p);
      } catch {
        return !1;
      }
    }
    _verify(s, i, p, g) {
      const { n: S } = this.curve, y = this.curve.g, b = this._reduce(s), h = this.curve.decodePoint(g);
      if (i.isZero() || i.cmp(S) >= 0 || p.isZero() || p.cmp(S) >= 0)
        return !1;
      const a = p.invert(S), E = b.mul(a).imod(S), H = i.mul(a).imod(S);
      return y.jmulAdd(E, h, H).eqR(i);
    }
    recover(s, i, p, g) {
      e(k.isBuffer(s)), e(k.isBuffer(i)), e(p >>> 0 === p), e((p & 3) === p, "The recovery param is more than two bits.");
      let S, y;
      try {
        [S, y] = this._decodeCompact(i);
      } catch {
        return null;
      }
      let b;
      try {
        b = this._recover(s, S, y, p);
      } catch {
        return null;
      }
      return b.encode(g);
    }
    recoverDER(s, i, p, g) {
      e(k.isBuffer(s)), e(k.isBuffer(i)), e(p >>> 0 === p), e((p & 3) === p, "The recovery param is more than two bits.");
      let S, y;
      try {
        [S, y] = this._decodeDER(i, !1);
      } catch {
        return null;
      }
      let b;
      try {
        b = this._recover(s, S, y, p);
      } catch {
        return null;
      }
      return b.encode(g);
    }
    _recover(s, i, p, g) {
      const { n: S, pmodn: y } = this.curve, b = this.curve.g, h = this._reduce(s);
      if (i.isZero() || i.cmp(S) >= 0)
        throw new Error("Invalid R value.");
      if (p.isZero() || p.cmp(S) >= 0)
        throw new Error("Invalid S value.");
      const a = (g & 1) !== 0, E = g >>> 1;
      let H = i;
      if (E) {
        if (this.curve.highOrder)
          throw new Error("Invalid high bit.");
        if (H.cmp(y) >= 0)
          throw new Error("Invalid R value.");
        H = H.add(S);
      }
      const j = this.curve.pointFromX(H, a), G = i.invert(S), N = h.mul(G).ineg().imod(S), T = p.mul(G).imod(S), A = b.mulAdd(N, j, T);
      if (A.isInfinity())
        throw new Error("Invalid point.");
      return A;
    }
    derive(s, i, p) {
      const g = this.curve.decodePoint(s), S = this.curve.decodeScalar(i);
      if (S.isZero() || S.cmp(this.curve.n) >= 0)
        throw new Error("Invalid private key.");
      if (this.curve.h.cmpn(1) > 0 && g.isSmall())
        throw new Error("Invalid point.");
      return g.mulBlind(S, l).encode(p);
    }
    /*
     * Schnorr
     */
    schnorrSign(s, i) {
      return this.schnorr.sign(s, i);
    }
    schnorrVerify(s, i, p) {
      return this.schnorr.verify(s, i, p);
    }
    schnorrVerifyBatch(s) {
      return this.schnorr.verifyBatch(s);
    }
    /*
     * Helpers
     */
    _encodeCompact(s, i) {
      return k.concat([
        this.curve.encodeScalar(s),
        this.curve.encodeScalar(i)
      ]);
    }
    _decodeCompact(s) {
      e(k.isBuffer(s));
      const { n: i } = this.curve, p = this.curve.scalarSize;
      if (s.length !== p * 2)
        throw new Error("Invalid signature size.");
      const g = s.slice(0, p), S = s.slice(p, p * 2), y = this.curve.decodeScalar(g), b = this.curve.decodeScalar(S);
      if (y.cmp(i) >= 0 || b.cmp(i) >= 0)
        throw new Error("Invalid signature.");
      return [y, b];
    }
    _encodeDER(s, i) {
      const p = w.sizeInt(s) + w.sizeInt(i), g = k.alloc(w.sizeSeq(p));
      let S = 0;
      return S = w.writeSeq(g, S, p), S = w.writeInt(g, S, s), S = w.writeInt(g, S, i), e(S === g.length), g;
    }
    _decodeDER(s, i) {
      e(k.isBuffer(s)), e(typeof i == "boolean");
      const { n: p } = this.curve;
      let g = 0, S, y;
      if (g = w.readSeq(s, g, i), [S, g] = w.readInt(s, g, i), [y, g] = w.readInt(s, g, i), i && g !== s.length)
        throw new Error("Trailing bytes.");
      if (S.cmp(p) >= 0 || y.cmp(p) >= 0)
        throw new Error("Invalid signature.");
      return [S, y];
    }
    _truncate(s) {
      e(k.isBuffer(s));
      const i = this.curve.n.bitLength(), p = i + 7 >>> 3;
      s.length > p && (s = s.slice(0, p));
      const g = c.decode(s, this.curve.endian), S = s.length * 8 - i;
      return S > 0 && g.iushrn(S), g;
    }
    _reduce(s) {
      return this._truncate(s).imod(this.curve.n);
    }
  }
  return yu = u, yu;
}
const ey = /* @__PURE__ */ JSON.parse('{"width":9,"points":[["f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9","388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"],["2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4","d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"],["5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc","6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"],["acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe","cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"],["774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb","d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"],["f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8","0ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"],["d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e","581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"],["defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34","4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"],["2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c","85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"],["352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5","321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"],["2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f","02de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"],["9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714","73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"],["daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729","a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"],["c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db","2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"],["6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4","e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"],["1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5","b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"],["605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479","02972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"],["62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d","80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"],["80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f","1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"],["7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb","0d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"],["d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9","eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"],["049370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963","758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"],["77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74","958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"],["f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530","e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"],["463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b","5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"],["f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247","cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"],["caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1","cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"],["2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120","4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"],["7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435","091b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"],["754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18","0673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"],["e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8","59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"],["186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb","3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"],["df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f","55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"],["5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143","efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"],["290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba","e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"],["af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45","f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"],["766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a","744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"],["59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e","c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"],["f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8","e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"],["7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c","30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"],["948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519","e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"],["7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab","100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"],["3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca","ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"],["d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf","8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"],["1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610","68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"],["733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4","f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"],["15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c","d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"],["a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940","edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"],["e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980","0a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"],["311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3","66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"],["34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf","09414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"],["f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63","4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"],["d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448","fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"],["32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf","5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"],["7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5","8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"],["ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6","8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"],["16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5","5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"],["eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99","f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"],["078c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51","f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"],["494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5","42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"],["a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5","204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"],["c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997","04f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"],["841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881","073867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"],["5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5","39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"],["36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66","d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"],["0336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726","ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"],["8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede","6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"],["1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94","060660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"],["85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31","3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"],["29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51","0b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"],["a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252","ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"],["04e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5","cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"],["d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b","6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"],["ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4","322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"],["af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f","6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"],["e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889","2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"],["591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246","b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"],["11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984","998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"],["3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a","b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"],["cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030","bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"],["c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197","6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"],["0c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593","c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"],["a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef","021ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"],["347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38","60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"],["da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a","49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"],["c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111","5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"],["4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502","7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"],["3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea","be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"],["cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26","8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"],["b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986","39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"],["d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e","62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"],["48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4","25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"],["dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda","ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"],["6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859","cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"],["e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f","f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"],["eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c","6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"],["13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942","fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"],["ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a","1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"],["b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80","5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"],["ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d","438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"],["8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1","cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"],["52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63","0c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"],["e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352","6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"],["7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193","ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"],["5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00","09731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"],["32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58","ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"],["e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7","d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"],["8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8","c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"],["4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e","67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"],["3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d","0cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"],["674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b","299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"],["d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f","f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"],["30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6","462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"],["be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297","62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"],["93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a","7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"],["b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c","ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"],["d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52","4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"],["d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb","bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"],["463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065","bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"],["7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917","603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"],["74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9","cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"],["30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3","553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"],["9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57","0712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"],["176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66","ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"],["75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8","9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"],["809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721","9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"],["1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180","4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"]]}'), ty = { step: 4, points: [["e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a", "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"], ["8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508", "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"], ["175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739", "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"], ["363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640", "04e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"], ["8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c", "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"], ["723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda", "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"], ["eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa", "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"], ["100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0", "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"], ["e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d", "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"], ["feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d", "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"], ["da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1", "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"], ["53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0", "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"], ["8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047", "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"], ["385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862", "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"], ["06f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7", "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"], ["3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd", "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"], ["85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83", "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"], ["0948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a", "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"], ["6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8", "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"], ["e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d", "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"], ["e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725", "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"], ["213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754", "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"], ["4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c", "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"], ["fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6", "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"], ["76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39", "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"], ["c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891", "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"], ["d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b", "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"], ["b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03", "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"], ["e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d", "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"], ["a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070", "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"], ["90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4", "0e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"], ["8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da", "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"], ["e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11", "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"], ["8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e", "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"], ["e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41", "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"], ["b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef", "067c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"], ["d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8", "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"], ["324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d", "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"], ["4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96", "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"], ["9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd", "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"], ["6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5", "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"], ["a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266", "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"], ["7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71", "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"], ["0928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac", "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"], ["85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751", "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"], ["ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e", "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"], ["827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241", "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"], ["eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3", "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"], ["e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f", "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"], ["1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19", "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"], ["146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be", "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"], ["fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9", "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"], ["da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2", "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"], ["a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13", "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"], ["174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c", "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"], ["959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba", "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"], ["d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151", "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"], ["64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073", "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"], ["8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458", "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"], ["13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b", "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"], ["bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366", "0d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"], ["8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa", "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"], ["08ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0", "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"], ["dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787", "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"], ["f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e", "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"]] }, ry = {
  naf: ey,
  doubles: ty
};
/*!
 * secp256k1.js - secp256k1 for bcrypto
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var vu, f3;
function zr() {
  if (f3) return vu;
  f3 = 1;
  const e = as(), c = Ar(), l = ry;
  return vu = new e("SECP256K1", c, c, l), vu;
}
var c3;
function iy() {
  return c3 || (c3 = 1, function(e) {
    const c = Xe(), l = At(), w = mr(), m = zr(), f = e;
    f.MAGIC_STRING = `eCash Signed Message:
`, f.magicHash = (n, u = f.MAGIC_STRING) => {
      c(typeof u == "string", "prefix must be a string."), c(typeof n == "string", "message must be a string");
      const o = l.write();
      return o.writeVarString(u), o.writeVarString(n, "utf8"), w.digest(o.render());
    }, f.sign = (n, u, o) => {
      c(u.getPrivateKey(), "Cannot sign without private key.");
      const s = f.magicHash(n, o), i = u.getPublicKey().readInt8(0) !== 4, [
        p,
        g
      ] = m.signRecoverable(s, u.getPrivateKey()), S = l.write();
      return S.writeI8(g + 27 + (i ? 4 : 0)), S.writeBytes(p), S.render();
    }, f.recover = (n, u, o) => {
      c(typeof n == "string", "msg must be a string"), c(k.isBuffer(u), "sig must be a buffer");
      const s = f.magicHash(n, o);
      c.strictEqual(u.length, 65, "Invalid signature length");
      const i = u.readUInt8(0) - 27;
      c(i < 8, "Invalid signature parameter");
      const p = !!(i & 4), g = i & 3;
      return m.recover(s, u.slice(1), g, p);
    }, f.verify = (n, u, o, s) => {
      const i = f.recover(n, u);
      return c(k.isBuffer(o), "publicKey must be a buffer"), k.compare(o, i) !== 0 ? !1 : m.verify(
        f.magicHash(n, s),
        u.slice(1),
        o
      );
    };
  }(au)), au;
}
/*!
 * utils/index.js - utils for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var u3;
function Kt() {
  if (u3) return _i;
  u3 = 1, _i.binary = yo(), _i.fixed = yp(), _i.util = Qt(), _i.message = iy();
  const { inspect: { custom: e } } = Ci();
  return _i.inspectSymbol = e || "inspect", _i;
}
var Su, h3;
function Gr() {
  if (h3) return Su;
  h3 = 1;
  const e = Xe(), c = At(), { base58: l, cashaddr: w } = gn(), m = M8(), f = Xi(), n = mr(), u = Or(), o = Lt(), { inspectSymbol: s } = Kt(), i = k.alloc(20, 0);
  class p {
    /**
     * Create an address.
     * @constructor
     * @param {Object?} options
     */
    constructor(y, b) {
      this.type = p.types.PUBKEYHASH, this.hash = i, y && this.fromOptions(y, b);
    }
    /**
     * Inject properties from options object.
     * @private
     * @param {Object} options
     */
    fromOptions(y, b) {
      if (typeof y == "string")
        return this.fromString(y, b);
      e(y);
      const { hash: h, type: a } = y;
      return this.fromHash(h, a);
    }
    /**
     * Insantiate address from options.
     * @param {Object} options
     * @returns {Address}
     */
    static fromOptions(y, b) {
      return new this().fromOptions(y, b);
    }
    /**
     * Get the address hash.
     * @param {String?} enc - Can be `"hex"` or `null`.
     * @returns {Hash|Buffer}
     */
    getHash(y) {
      return y === "hex" ? this.hash.toString("hex") : this.hash;
    }
    /**
     * Test whether the address is null.
     * @returns {Boolean}
     */
    isNull() {
      if (this.hash.length === 20)
        return this.hash.equals(i);
      if (this.hash.length === 32)
        return this.hash.equals(o.ZERO_HASH);
      for (let y = 0; y < this.hash.length; y++)
        if (this.hash[y] !== 0)
          return !1;
      return !0;
    }
    /**
     * Test equality against another address.
     * @param {Address} addr
     * @returns {Boolean}
     */
    equals(y) {
      return e(y instanceof p), this.type === y.type && this.hash.equals(y.hash);
    }
    /**
     * Get the address type as a string.
     * @returns {String}
     */
    getType() {
      return p.typesByVal[this.type].toLowerCase();
    }
    /**
     * Get a network address prefix for the address.
     * @param {Network?} network
     * @returns {Number}
     */
    getPrefix(y) {
      y = u.get(y);
      const b = y.addressPrefix;
      switch (this.type) {
        case p.types.PUBKEYHASH:
          return b.pubkeyhash;
        case p.types.SCRIPTHASH:
          return b.scripthash;
      }
      return -1;
    }
    /**
     * Calculate size of serialized address.
     * @returns {Number}
     */
    getSize() {
      return 5 + this.hash.length;
    }
    /**
     * Compile the address object to its raw serialization.
     * @param {{NetworkType|Network)?} network
     * @returns {Buffer}
     * @throws Error on bad hash/prefix.
     */
    toRaw(y) {
      const b = this.getSize(), h = c.write(b), a = this.getPrefix(y);
      return e(a !== -1, "Not a valid address prefix."), h.writeU8(a), h.writeBytes(this.hash), h.writeChecksum(n.digest), h.render();
    }
    /**
     * Compile the address object to a base58 address.
     * @param {{NetworkType|Network)?} network
     * @returns {AddressString}
     * @throws Error on bad hash/prefix.
     */
    toBase58(y) {
      return l.encode(this.toRaw(y));
    }
    /**
     * Compile the address object to a cashaddr address.
     * @param {{NetworkType|Network)?} network
     * @returns {String}
     * @throws Error on bad hash/prefix.
     */
    toCashAddr(y) {
      const b = this.type, h = this.hash;
      y = u.get(y);
      const a = y.addressPrefix.cashaddr;
      return w.encode(a, b, h);
    }
    /**
     * Inject properties from string.
     * @private
     * @param {String} addr
     * @param {(Network|NetworkType)?} network
     * @returns {Address}
     */
    fromString(y, b) {
      if (e(typeof y == "string"), e(y.length > 0), e(y.length <= 100), g(y))
        return this.fromBase58(y, b);
      try {
        return this.fromCashAddr(y, b);
      } catch {
        return this.fromBase58(y, b);
      }
    }
    /**
     * Instantiate address from string.
     * @param {String} addr
     * @param {(Network|NetworkType)?} network
     * @returns {Address}
     */
    static fromString(y, b) {
      return new this().fromString(y, b);
    }
    /**
     * Return cashaddr by default
     * @param {(Network|NetworkType)?} network
     * @returns {AddressString}
     */
    toString(y) {
      return this.toCashAddr(y);
    }
    /**
     * Inspect the Address.
     * @returns {Object}
     */
    [s]() {
      return `<Address: type=${this.getType()} str=${this.toString()}>`;
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     * @throws Parse error
     */
    fromRaw(y, b) {
      const h = c.read(y, !0), a = h.readU8();
      b = u.fromAddress(a, b);
      const E = p.getType(a, b);
      if (y.length !== 25)
        throw new Error("Address is too long.");
      const H = h.readBytes(h.left() - 4);
      return h.verifyChecksum(n.digest), this.fromHash(H, E);
    }
    /**
     * Create an address object from a serialized address.
     * @param {Buffer} data
     * @returns {Address}
     * @throws Parse error.
     */
    static fromRaw(y, b) {
      return new this().fromRaw(y, b);
    }
    /**
     * Inject properties from base58 address.
     * @private
     * @param {AddressString} data
     * @param {Network?} network
     * @throws Parse error
     */
    fromBase58(y, b) {
      if (e(typeof y == "string"), y.length > 55)
        throw new Error("Address is too long.");
      return this.fromRaw(l.decode(y), b);
    }
    /**
     * Create an address object from a base58 address.
     * @param {AddressString} data
     * @param {Network?} network
     * @returns {Address}
     * @throws Parse error.
     */
    static fromBase58(y, b) {
      return new this().fromBase58(y, b);
    }
    /**
     * Inject properties from cashaddr address.
     * @private
     * @param {String} data
     * @param {Network?} network
     * @throws Parse error
     */
    fromCashAddr(y, b) {
      e(typeof y == "string"), b = u.get(b), b.addressPrefix.cashaddr;
      const h = m.decode(y);
      return h.type = h.type === "P2PKH" ? "PUBKEYHASH" : "SCRIPTHASH", u.fromCashAddr(h.prefix, b), this.fromHash(k.from(h.hash), h.type);
    }
    /**
     * Create an address object from a cashaddr address.
     * @param {String} data
     * @param {Network?} network
     * @returns {Address}
     * @throws Parse error.
     */
    static fromCashAddr(y, b) {
      return new this().fromCashAddr(y, b);
    }
    /**
     * Inject properties from output script.
     * @private
     * @param {Script} script
     */
    fromScript(y) {
      const b = y.getPubkey();
      if (b)
        return this.hash = f.digest(b), this.type = p.types.PUBKEYHASH, this;
      const h = y.getPubkeyhash();
      if (h)
        return this.hash = h, this.type = p.types.PUBKEYHASH, this;
      const a = y.getScripthash();
      return a ? (this.hash = a, this.type = p.types.SCRIPTHASH, this) : y.isMultisig() ? (this.hash = y.hash160(), this.type = p.types.SCRIPTHASH, this) : null;
    }
    /**
     * Inject properties from input script.
     * @private
     * @param {Script} script
     */
    fromInputScript(y) {
      const [, b] = y.getPubkeyhashInput();
      if (b)
        return this.hash = f.digest(b), this.type = p.types.PUBKEYHASH, this;
      const h = y.getScripthashInput();
      return h ? (this.hash = f.digest(h), this.type = p.types.SCRIPTHASH, this) : null;
    }
    /**
     * Create an Address from an input script.
     * Attempt to extract address
     * properties from an input script.
     * @param {Script}
     * @returns {Address|null}
     */
    static fromInputScript(y) {
      return new this().fromInputScript(y);
    }
    /**
     * Create an Address from an output script.
     * Parse an output script and extract address
     * properties. Converts pubkey and multisig
     * scripts to pubkeyhash and scripthash addresses.
     * @param {Script}
     * @returns {Address|null}
     */
    static fromScript(y) {
      return new this().fromScript(y);
    }
    /**
     * Inject properties from a hash.
     * @private
     * @param {Buffer|Hash} hash
     * @param {AddressPrefix} type
     * @throws on bad hash size
     */
    fromHash(y, b) {
      return typeof b == "string" && (b = p.types[b.toUpperCase()], e(b != null, "Not a valid address type.")), b == null && (b = p.types.PUBKEYHASH), e(k.isBuffer(y)), e(b >>> 0 === b), e(
        b >= p.types.PUBKEYHASH && b <= p.types.SCRIPTHASH,
        "Not a valid address type."
      ), e(y.length === 20, "Hash is the wrong size."), this.hash = y, this.type = b, this;
    }
    /**
     * Create a naked address from hash/type.
     * @param {Hash} hash
     * @param {AddressPrefix} type
     * @returns {Address}
     * @throws on bad hash size
     */
    static fromHash(y, b) {
      return new this().fromHash(y, b);
    }
    /**
     * Inject properties from pubkeyhash.
     * @private
     * @param {Buffer} hash
     * @returns {Address}
     */
    fromPubkeyhash(y) {
      const b = p.types.PUBKEYHASH;
      return e(y.length === 20, "P2PKH must be 20 bytes."), this.fromHash(y, b, -1);
    }
    /**
     * Instantiate address from pubkeyhash.
     * @param {Buffer} hash
     * @returns {Address}
     */
    static fromPubkeyhash(y) {
      return new this().fromPubkeyhash(y);
    }
    /**
     * Inject properties from scripthash.
     * @private
     * @param {Buffer} hash
     * @returns {Address}
     */
    fromScripthash(y) {
      const b = p.types.SCRIPTHASH;
      return e(y && y.length === 20, "P2SH must be 20 bytes."), this.fromHash(y, b, -1);
    }
    /**
     * Instantiate address from scripthash.
     * @param {Buffer} hash
     * @returns {Address}
     */
    static fromScripthash(y) {
      return new this().fromScripthash(y);
    }
    /**
     * Test whether the address is pubkeyhash.
     * @returns {Boolean}
     */
    isPubkeyhash() {
      return this.type === p.types.PUBKEYHASH;
    }
    /**
     * Test whether the address is scripthash.
     * @returns {Boolean}
     */
    isScripthash() {
      return this.type === p.types.SCRIPTHASH;
    }
    /**
     * Get the hash of a base58 address or address-related object.
     * @param {Address|Hash} data
     * @param {String?} enc - Can be `"hex"` or `null`.
     * @returns {Hash}
     */
    static getHash(y, b) {
      if (!y)
        throw new Error("Object is not an address.");
      let h;
      if (k.isBuffer(y)) {
        if (y.length !== 20)
          throw new Error("Object is not an address.");
        h = y;
      } else if (y instanceof p)
        h = y.hash;
      else
        throw new Error("Object is not an address.");
      return b === "hex" ? h.toString("hex") : h;
    }
    /**
     * Get an address type for a specified network address prefix.
     * @param {Number} prefix
     * @param {Network} network
     * @returns {AddressType}
     */
    static getType(y, b) {
      const h = b.addressPrefix;
      switch (y) {
        case h.pubkeyhash:
          return p.types.PUBKEYHASH;
        case h.scripthash:
          return p.types.SCRIPTHASH;
        default:
          throw new Error("Unknown address prefix.");
      }
    }
  }
  p.types = {
    PUBKEYHASH: 0,
    SCRIPTHASH: 1
  }, p.typesByVal = [
    "PUBKEYHASH",
    "SCRIPTHASH"
  ];
  function g(S) {
    let y = !1, b = !1;
    for (let h = 0; h < S.length; h++) {
      const a = S.charCodeAt(h);
      if (!(a >= 48 && a <= 57) && a !== 58 && (a & 32 ? (e(a >= 97 && a <= 122), y = !0) : (e(a >= 65 && a <= 90), b = !0), y && b))
        return !0;
    }
    return !1;
  }
  return Su = p, Su;
}
var Eu, l3;
function Pp() {
  if (l3) return Eu;
  l3 = 1;
  const e = Xe(), c = Gr(), l = wi();
  class w {
    /**
     * Create a bitcoin URI.
     * @alias module:btc.URI
     * @constructor
     * @param {Object|String} options
     */
    constructor(s) {
      this.address = new c(), this.amount = -1, this.label = null, this.message = null, this.request = null, s && this.fromOptions(s);
    }
    /**
     * Inject properties from options object.
     * @private
     * @param {Object|String} options
     * @returns {URI}
     */
    fromOptions(s) {
      return typeof s == "string" ? this.fromString(s) : (s.address && this.address.fromOptions(s.address), s.amount != null && (e(
        Number.isSafeInteger(s.amount) && s.amount >= 0,
        "Amount must be a uint64."
      ), this.amount = s.amount), s.label && (e(typeof s.label == "string", "Label must be a string."), this.label = s.label), s.message && (e(typeof s.message == "string", "Message must be a string."), this.message = s.message), s.request && (e(typeof s.request == "string", "Request must be a string."), this.request = s.request), this);
    }
    /**
     * Instantiate URI from options.
     * @param {Object|String} options
     * @returns {URI}
     */
    static fromOptions(s) {
      return new this().fromOptions(s);
    }
    /**
     * Parse and inject properties from string.
     * @private
     * @param {String} str
     * @param {Network?} network
     * @returns {URI}
     */
    fromString(s, i) {
      e(typeof s == "string"), e(s.length > 8, "Not a bitcoin URI.");
      const p = s.substring(0, 8);
      e(p === "bitcoin:", "Not a bitcoin URI."), s = s.substring(8);
      const g = s.indexOf("?");
      let S, y;
      if (g === -1 ? S = s : (S = s.substring(0, g), y = s.substring(g + 1)), this.address.fromString(S, i), !y)
        return this;
      const b = f(y);
      return b.amount && (e(b.amount.length > 0, "Value is empty."), e(b.amount[0] !== "-", "Value is negative."), this.amount = l.value(b.amount)), b.label && (this.label = b.label), b.message && (this.message = b.message), b.r && (this.request = b.r), this;
    }
    /**
     * Instantiate uri from string.
     * @param {String} str
     * @param {Network?} network
     * @returns {URI}
     */
    static fromString(s, i) {
      return new this().fromString(s, i);
    }
    /**
     * Serialize uri to a string.
     * @returns {String}
     */
    toString() {
      let s = "bitcoin:";
      s += this.address.toString();
      const i = [];
      return this.amount !== -1 && i.push(`amount=${l.btc(this.amount)}`), this.label && i.push(`label=${u(this.label)}`), this.message && i.push(`message=${u(this.message)}`), this.request && i.push(`r=${u(this.request)}`), i.length > 0 && (s += "?" + i.join("&")), s;
    }
    /**
     * Inspect bitcoin uri.
     * @returns {String}
     */
    inspect() {
      return `<URI: ${this.toString()}>`;
    }
  }
  class m {
    constructor() {
      this.amount = null, this.label = null, this.message = null, this.r = null;
    }
  }
  function f(o) {
    const s = o.split("&"), i = new m();
    let p = 0;
    for (const g of s) {
      const S = g.indexOf("=");
      let y, b;
      if (S === -1 ? (y = g, b = "") : (y = g.substring(0, S), b = g.substring(S + 1)), y.length === 0) {
        e(b.length === 0, "Empty key in querystring.");
        continue;
      }
      switch (e(p < 4, "Too many keys in querystring."), y) {
        case "amount":
          e(i.amount == null, "Duplicate key in querystring (amount)."), i.amount = n(b);
          break;
        case "label":
          e(i.label == null, "Duplicate key in querystring (label)."), i.label = n(b);
          break;
        case "message":
          e(i.message == null, "Duplicate key in querystring (message)."), i.message = n(b);
          break;
        case "r":
          e(i.r == null, "Duplicate key in querystring (r)."), i.r = n(b);
          break;
        default:
          e(!1, `Unknown querystring key: ${b}.`);
          break;
      }
      p += 1;
    }
    return i;
  }
  function n(o) {
    try {
      o = decodeURIComponent(o), o = o.replace(/\+/g, " ");
    } catch {
      throw new Error("Malformed URI.");
    }
    if (o.indexOf("\0") !== -1)
      throw new Error("Malformed URI.");
    return o;
  }
  function u(o) {
    return o = encodeURIComponent(o), o = o.replace(/%20/g, "+"), o;
  }
  return Eu = w, Eu;
}
/*!
 * btc/index.js - high-level btc objects for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var d3;
function ny() {
  return d3 || (d3 = 1, Os.Amount = wi(), Os.URI = Pp()), Os;
}
var en = {}, Iu, b3;
function kp() {
  if (b3) return Iu;
  b3 = 1;
  const e = Nt(), c = fi(), l = -1, w = k.alloc(8, 0), m = k.alloc(64, 0);
  m[0] = 128;
  const f = new Uint32Array([
    1518500249,
    1859775393,
    2400959708,
    3395469782
  ]);
  class n {
    constructor() {
      this.state = new Uint32Array(5), this.msg = new Uint32Array(80), this.block = k.alloc(64), this.size = l;
    }
    init() {
      return this.state[0] = 1732584193, this.state[1] = 4023233417, this.state[2] = 2562383102, this.state[3] = 271733878, this.state[4] = 3285377520, this.size = 0, this;
    }
    update(b) {
      return e(k.isBuffer(b)), this._update(b, b.length), this;
    }
    final() {
      return this._final(k.alloc(20));
    }
    _update(b, h) {
      e(this.size !== l, "Context is not initialized.");
      let a = this.size & 63, E = 0;
      if (this.size += h, a > 0) {
        let H = 64 - a;
        if (H > h && (H = h), b.copy(this.block, a, E, E + H), a += H, h -= H, E += H, a < 64)
          return;
        this._transform(this.block, 0);
      }
      for (; h >= 64; )
        this._transform(b, E), E += 64, h -= 64;
      h > 0 && b.copy(this.block, 0, E, E + h);
    }
    _final(b) {
      e(this.size !== l, "Context is not initialized.");
      const h = this.size & 63, a = this.size * 8;
      S(w, a * (1 / 4294967296) >>> 0, 0), S(w, a >>> 0, 4), this._update(m, 1 + (119 - h & 63)), this._update(w, 8);
      for (let E = 0; E < 5; E++)
        S(b, this.state[E], E * 4), this.state[E] = 0;
      for (let E = 0; E < 80; E++)
        this.msg[E] = 0;
      for (let E = 0; E < 64; E++)
        this.block[E] = 0;
      return this.size = l, b;
    }
    _transform(b, h) {
      const a = this.msg;
      let E = this.state[0], H = this.state[1], j = this.state[2], G = this.state[3], N = this.state[4], T = 0;
      for (; T < 16; T++)
        a[T] = g(b, h + T * 4);
      for (; T < 80; T++)
        a[T] = u(a[T - 3] ^ a[T - 8] ^ a[T - 14] ^ a[T - 16], 1);
      for (T = 0; T < 80; T++) {
        const A = T / 20 | 0, q = u(E, 5) + o(A, H, j, G) + N + a[T] + f[A];
        N = G, G = j, j = u(H, 30), H = E, E = q >>> 0;
      }
      this.state[0] += E, this.state[1] += H, this.state[2] += j, this.state[3] += G, this.state[4] += N;
    }
    static hash() {
      return new n();
    }
    static hmac() {
      return new c(n, 64);
    }
    static digest(b) {
      return n.ctx.init().update(b).final();
    }
    static root(b, h) {
      return e(k.isBuffer(b) && b.length === 20), e(k.isBuffer(h) && h.length === 20), n.ctx.init().update(b).update(h).final();
    }
    static multi(b, h, a) {
      const { ctx: E } = n;
      return E.init(), E.update(b), E.update(h), a && E.update(a), E.final();
    }
    static mac(b, h) {
      return n.hmac().init(h).update(b).final();
    }
  }
  n.native = 0, n.id = "SHA1", n.size = 20, n.bits = 160, n.blockSize = 64, n.zero = k.alloc(20, 0), n.ctx = new n();
  function u(y, b) {
    return y << b | y >>> 32 - b;
  }
  function o(y, b, h, a) {
    return y === 0 ? s(b, h, a) : y === 1 || y === 3 ? p(b, h, a) : y === 2 ? i(b, h, a) : 0;
  }
  function s(y, b, h) {
    return y & b ^ ~y & h;
  }
  function i(y, b, h) {
    return y & b ^ y & h ^ b & h;
  }
  function p(y, b, h) {
    return y ^ b ^ h;
  }
  function g(y, b) {
    return y[b++] * 16777216 + y[b++] * 65536 + y[b++] * 256 + y[b];
  }
  function S(y, b, h) {
    return y[h++] = b >>> 24, y[h++] = b >>> 16, y[h++] = b >>> 8, y[h++] = b, h;
  }
  return Iu = n, Iu;
}
var Au = {};
/*!
 * policy.js - bitcoin constants for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var p3;
function vi() {
  return p3 || (p3 = 1, function(e) {
    const c = Xe(), l = Lt();
    e.MAX_TX_VERSION = l.MAX_TX_VERSION, e.MAX_TX_SIZE = l.MAX_TX_SIZE / 10, e.MAX_TX_SIGOPS = l.MAX_TX_SIGOPS / 5, e.BYTES_PER_SIGOP = 20, e.MIN_RELAY = 1e3, e.BARE_MULTISIG = !0, e.FREE_THRESHOLD = l.COIN * 144 / 250, e.MAX_P2SH_SIGOPS = 15, e.MAX_OP_RETURN_BYTES = 223, e.MAX_OP_RETURN = 220, e.MAX_P2WSH_STACK = 100, e.MAX_P2WSH_PUSH = 80, e.MAX_P2WSH_SIZE = 3600, e.MEMPOOL_MAX_ANCESTORS = 50, e.MEMPOOL_MAX_SIZE = 100 * 1e6, e.MEMPOOL_EXPIRY_TIME = 4320 * 60, e.MEMPOOL_MAX_ORPHANS = 100, e.MIN_BLOCK_SIZE = 0, e.MAX_BLOCK_SIZE = l.MAX_FORK_BLOCK_SIZE, e.BLOCK_PRIORITY_SIZE = 0, e.BLOCK_PRIORITY_THRESHOLD = e.FREE_THRESHOLD, e.getMinFee = function(m, f) {
      if (f == null && (f = e.MIN_RELAY), c(m >= 0), c(f >= 0), m === 0)
        return 0;
      let n = Math.floor(f * m / 1e3);
      return n === 0 && f > 0 && (n = f), n;
    }, e.getRoundFee = function(m, f) {
      if (f == null && (f = e.MIN_RELAY), c(m >= 0), c(f >= 0), m === 0)
        return 0;
      let n = f * Math.ceil(m / 1e3);
      return n === 0 && f > 0 && (n = f), n;
    }, e.getRate = function(m, f) {
      return c(m >= 0), c(f >= 0), m === 0 ? 0 : Math.floor(f * 1e3 / m);
    };
  }(Au)), Au;
}
/*!
 * scripterror.js - script error for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var Ou, m3;
function So() {
  if (m3) return Ou;
  m3 = 1;
  class e extends Error {
    /**
     * Create an error.
     * @constructor
     * @param {String} code - Error code.
     * @param {Opcode} op - Opcode.
     * @param {Number?} ip - Instruction pointer.
     */
    constructor(l, w, m) {
      super(), this.type = "ScriptError", this.code = l, this.message = l, this.op = -1, this.ip = -1, typeof w == "string" ? this.message = w : w && (this.message = `${l} (op=${w.toSymbol()}, ip=${m})`, this.op = w.value, this.ip = m), Error.captureStackTrace && Error.captureStackTrace(this, e);
    }
  }
  return Ou = e, Ou;
}
var _u, g3;
function Gi() {
  if (g3) return _u;
  g3 = 1;
  const e = Xe(), { I64: c } = ul(), l = So(), w = k.alloc(0);
  class m extends c {
    /**
     * Create a script number.
     * @constructor
     * @param {(Number|String|Buffer|Object)?} num
     * @param {(String|Number)?} base
     */
    constructor(n, u) {
      super(n, u);
    }
    /**
     * Cast to int32.
     * @returns {Number}
     */
    getInt() {
      return this.lt(c.INT32_MIN) ? c.LONG_MIN : this.gt(c.INT32_MAX) ? c.LONG_MAX : this.toInt();
    }
    /**
     * Serialize script number.
     * @returns {Buffer}
     */
    toRaw() {
      let n = this;
      if (n.isZero())
        return w;
      let u = !1;
      n.isNeg() && (n = n.neg(), u = !0);
      const o = n.byteLength();
      let s = 0;
      n.testn(o * 8 - 1) && (s = 1);
      const i = k.allocUnsafe(o + s);
      switch (o) {
        case 8:
          i[7] = n.hi >>> 24 & 255;
        case 7:
          i[6] = n.hi >> 16 & 255;
        case 6:
          i[5] = n.hi >> 8 & 255;
        case 5:
          i[4] = n.hi & 255;
        case 4:
          i[3] = n.lo >>> 24 & 255;
        case 3:
          i[2] = n.lo >> 16 & 255;
        case 2:
          i[1] = n.lo >> 8 & 255;
        case 1:
          i[0] = n.lo & 255;
      }
      return i[o - 1] & 128 ? (e(s === 1), e(i.length === o + s), i[o] = u ? 128 : 0) : u ? (e(s === 0), e(i.length === o), i[o - 1] |= 128) : (e(s === 0), e(i.length === o)), i;
    }
    /**
     * Instantiate script number from serialized data.
     * @private
     * @param {Buffer} data
     * @returns {ScriptNum}
     */
    fromRaw(n) {
      if (e(k.isBuffer(n)), n.length === 0)
        return this;
      switch (n.length) {
        case 8:
          this.hi |= n[7] << 24;
        case 7:
          this.hi |= n[6] << 16;
        case 6:
          this.hi |= n[5] << 8;
        case 5:
          this.hi |= n[4];
        case 4:
          this.lo |= n[3] << 24;
        case 3:
          this.lo |= n[2] << 16;
        case 2:
          this.lo |= n[1] << 8;
        case 1:
          this.lo |= n[0];
          break;
        default:
          for (let u = 0; u < n.length; u++)
            this.orb(u, n[u]);
          break;
      }
      return n[n.length - 1] & 128 && (this.setn(n.length * 8 - 1, 0), this.ineg()), this;
    }
    /**
     * Serialize script number.
     * @returns {Buffer}
     */
    encode() {
      return this.toRaw();
    }
    /**
     * Decode and verify script number.
     * @private
     * @param {Buffer} data
     * @param {Boolean?} minimal - Require minimal encoding.
     * @param {Number?} limit - Size limit.
     * @returns {ScriptNum}
     */
    decode(n, u, o) {
      if (e(k.isBuffer(n)), o != null && n.length > o)
        throw new l("UNKNOWN_ERROR", "Script number overflow.");
      if (u && !m.isMinimal(n))
        throw new l("UNKNOWN_ERROR", "Non-minimal script number.");
      return this.fromRaw(n);
    }
    /**
     * Inspect script number.
     * @returns {String}
     */
    inspect() {
      return `<ScriptNum: ${this.toString(10)}>`;
    }
    /**
     * Test wether a serialized script
     * number is in its most minimal form.
     * @param {Buffer} data
     * @returns {Boolean}
     */
    static isMinimal(n) {
      return e(k.isBuffer(n)), n.length === 0 ? !0 : !((n[n.length - 1] & 127) === 0 && (n.length === 1 || (n[n.length - 2] & 128) === 0));
    }
    /**
     * Encode serialized script number in its most minimal form.
     * @param {Buffer} data
     * @returns {Buffer} minimal encoded data
     */
    static toMinimal(n) {
      if (e(k.isBuffer(n)), this.isMinimal(n))
        return n;
      const u = n[n.length - 1];
      for (let o = n.length - 1; o > 0; o--)
        if (n[o - 1] !== 0)
          return n[o - 1] & 128 ? n[o++] = u : n[o - 1] |= u, n = n.slice(0, o), n;
      return n = k.alloc(0), n;
    }
    /**
     * Decode and verify script number.
     * @param {Buffer} data
     * @param {Boolean?} minimal - Require minimal encoding.
     * @param {Number?} limit - Size limit.
     * @returns {ScriptNum}
     */
    static decode(n, u, o) {
      return new this().decode(n, u, o);
    }
    /**
     * Test whether object is a script number.
     * @param {Object} obj
     * @returns {Boolean}
     */
    static isScriptNum(n) {
      return n instanceof m;
    }
  }
  return _u = m, _u;
}
var Ru = {}, x3;
function fs() {
  return x3 || (x3 = 1, function(e) {
    const c = Xe(), l = zr(), w = Gi();
    e.opcodes = {
      // Push
      OP_0: 0,
      OP_PUSHDATA1: 76,
      OP_PUSHDATA2: 77,
      OP_PUSHDATA4: 78,
      OP_1NEGATE: 79,
      OP_RESERVED: 80,
      OP_1: 81,
      OP_2: 82,
      OP_3: 83,
      OP_4: 84,
      OP_5: 85,
      OP_6: 86,
      OP_7: 87,
      OP_8: 88,
      OP_9: 89,
      OP_10: 90,
      OP_11: 91,
      OP_12: 92,
      OP_13: 93,
      OP_14: 94,
      OP_15: 95,
      OP_16: 96,
      // Control
      OP_NOP: 97,
      OP_VER: 98,
      OP_IF: 99,
      OP_NOTIF: 100,
      OP_VERIF: 101,
      OP_VERNOTIF: 102,
      OP_ELSE: 103,
      OP_ENDIF: 104,
      OP_VERIFY: 105,
      OP_RETURN: 106,
      // Stack
      OP_TOALTSTACK: 107,
      OP_FROMALTSTACK: 108,
      OP_2DROP: 109,
      OP_2DUP: 110,
      OP_3DUP: 111,
      OP_2OVER: 112,
      OP_2ROT: 113,
      OP_2SWAP: 114,
      OP_IFDUP: 115,
      OP_DEPTH: 116,
      OP_DROP: 117,
      OP_DUP: 118,
      OP_NIP: 119,
      OP_OVER: 120,
      OP_PICK: 121,
      OP_ROLL: 122,
      OP_ROT: 123,
      OP_SWAP: 124,
      OP_TUCK: 125,
      // Splice
      OP_CAT: 126,
      OP_SPLIT: 127,
      OP_NUM2BIN: 128,
      OP_BIN2NUM: 129,
      OP_SIZE: 130,
      // Bit
      OP_INVERT: 131,
      OP_AND: 132,
      OP_OR: 133,
      OP_XOR: 134,
      OP_EQUAL: 135,
      OP_EQUALVERIFY: 136,
      OP_RESERVED1: 137,
      OP_RESERVED2: 138,
      // Numeric
      OP_1ADD: 139,
      OP_1SUB: 140,
      OP_2MUL: 141,
      OP_2DIV: 142,
      OP_NEGATE: 143,
      OP_ABS: 144,
      OP_NOT: 145,
      OP_0NOTEQUAL: 146,
      OP_ADD: 147,
      OP_SUB: 148,
      OP_MUL: 149,
      OP_DIV: 150,
      OP_MOD: 151,
      OP_LSHIFT: 152,
      OP_RSHIFT: 153,
      OP_BOOLAND: 154,
      OP_BOOLOR: 155,
      OP_NUMEQUAL: 156,
      OP_NUMEQUALVERIFY: 157,
      OP_NUMNOTEQUAL: 158,
      OP_LESSTHAN: 159,
      OP_GREATERTHAN: 160,
      OP_LESSTHANOREQUAL: 161,
      OP_GREATERTHANOREQUAL: 162,
      OP_MIN: 163,
      OP_MAX: 164,
      OP_WITHIN: 165,
      // Crypto
      OP_RIPEMD160: 166,
      OP_SHA1: 167,
      OP_SHA256: 168,
      OP_HASH160: 169,
      OP_HASH256: 170,
      OP_CODESEPARATOR: 171,
      OP_CHECKSIG: 172,
      OP_CHECKSIGVERIFY: 173,
      OP_CHECKMULTISIG: 174,
      OP_CHECKMULTISIGVERIFY: 175,
      // Expansion
      OP_NOP1: 176,
      OP_CHECKLOCKTIMEVERIFY: 177,
      OP_CHECKSEQUENCEVERIFY: 178,
      OP_NOP4: 179,
      OP_NOP5: 180,
      OP_NOP6: 181,
      OP_NOP7: 182,
      OP_NOP8: 183,
      OP_NOP9: 184,
      OP_NOP10: 185,
      // More Crypto
      OP_CHECKDATASIG: 186,
      OP_CHECKDATASIGVERIFY: 187,
      // additional byte-string operations
      OP_REVERSEBYTES: 188,
      // Custom
      OP_INVALIDOPCODE: 255
    }, e.opcodesByVal = {
      // Push
      0: "OP_0",
      76: "OP_PUSHDATA1",
      77: "OP_PUSHDATA2",
      78: "OP_PUSHDATA4",
      79: "OP_1NEGATE",
      80: "OP_RESERVED",
      81: "OP_1",
      82: "OP_2",
      83: "OP_3",
      84: "OP_4",
      85: "OP_5",
      86: "OP_6",
      87: "OP_7",
      88: "OP_8",
      89: "OP_9",
      90: "OP_10",
      91: "OP_11",
      92: "OP_12",
      93: "OP_13",
      94: "OP_14",
      95: "OP_15",
      96: "OP_16",
      // Control
      97: "OP_NOP",
      98: "OP_VER",
      99: "OP_IF",
      100: "OP_NOTIF",
      101: "OP_VERIF",
      102: "OP_VERNOTIF",
      103: "OP_ELSE",
      104: "OP_ENDIF",
      105: "OP_VERIFY",
      106: "OP_RETURN",
      // Stack
      107: "OP_TOALTSTACK",
      108: "OP_FROMALTSTACK",
      109: "OP_2DROP",
      110: "OP_2DUP",
      111: "OP_3DUP",
      112: "OP_2OVER",
      113: "OP_2ROT",
      114: "OP_2SWAP",
      115: "OP_IFDUP",
      116: "OP_DEPTH",
      117: "OP_DROP",
      118: "OP_DUP",
      119: "OP_NIP",
      120: "OP_OVER",
      121: "OP_PICK",
      122: "OP_ROLL",
      123: "OP_ROT",
      124: "OP_SWAP",
      125: "OP_TUCK",
      // Splice
      126: "OP_CAT",
      127: "OP_SPLIT",
      128: "OP_NUM2BIN",
      129: "OP_BIN2NUM",
      130: "OP_SIZE",
      // Bit
      131: "OP_INVERT",
      132: "OP_AND",
      133: "OP_OR",
      134: "OP_XOR",
      135: "OP_EQUAL",
      136: "OP_EQUALVERIFY",
      137: "OP_RESERVED1",
      138: "OP_RESERVED2",
      // Numeric
      139: "OP_1ADD",
      140: "OP_1SUB",
      141: "OP_2MUL",
      142: "OP_2DIV",
      143: "OP_NEGATE",
      144: "OP_ABS",
      145: "OP_NOT",
      146: "OP_0NOTEQUAL",
      147: "OP_ADD",
      148: "OP_SUB",
      149: "OP_MUL",
      150: "OP_DIV",
      151: "OP_MOD",
      152: "OP_LSHIFT",
      153: "OP_RSHIFT",
      154: "OP_BOOLAND",
      155: "OP_BOOLOR",
      156: "OP_NUMEQUAL",
      157: "OP_NUMEQUALVERIFY",
      158: "OP_NUMNOTEQUAL",
      159: "OP_LESSTHAN",
      160: "OP_GREATERTHAN",
      161: "OP_LESSTHANOREQUAL",
      162: "OP_GREATERTHANOREQUAL",
      163: "OP_MIN",
      164: "OP_MAX",
      165: "OP_WITHIN",
      // Crypto
      166: "OP_RIPEMD160",
      167: "OP_SHA1",
      168: "OP_SHA256",
      169: "OP_HASH160",
      170: "OP_HASH256",
      171: "OP_CODESEPARATOR",
      172: "OP_CHECKSIG",
      173: "OP_CHECKSIGVERIFY",
      174: "OP_CHECKMULTISIG",
      175: "OP_CHECKMULTISIGVERIFY",
      // Expansion
      176: "OP_NOP1",
      177: "OP_CHECKLOCKTIMEVERIFY",
      178: "OP_CHECKSEQUENCEVERIFY",
      179: "OP_NOP4",
      180: "OP_NOP5",
      181: "OP_NOP6",
      182: "OP_NOP7",
      183: "OP_NOP8",
      184: "OP_NOP9",
      185: "OP_NOP10",
      // More Crypto
      186: "OP_CHECKDATASIG",
      187: "OP_CHECKDATASIGVERIFY",
      // Additional byte-string operation
      188: "OP_REVERSEBYTES",
      // Custom
      255: "OP_INVALIDOPCODE"
    }, e.small = [
      k.from([129]),
      k.from([]),
      k.from([1]),
      k.from([2]),
      k.from([3]),
      k.from([4]),
      k.from([5]),
      k.from([6]),
      k.from([7]),
      k.from([8]),
      k.from([9]),
      k.from([10]),
      k.from([11]),
      k.from([12]),
      k.from([13]),
      k.from([14]),
      k.from([15]),
      k.from([16])
    ], e.flags = {
      VERIFY_NONE: 0,
      VERIFY_P2SH: 1,
      VERIFY_STRICTENC: 2,
      VERIFY_DERSIG: 4,
      VERIFY_LOW_S: 8,
      VERIFY_SIGPUSHONLY: 32,
      VERIFY_MINIMALDATA: 64,
      VERIFY_DISCOURAGE_UPGRADABLE_NOPS: 128,
      VERIFY_CLEANSTACK: 256,
      VERIFY_CHECKLOCKTIMEVERIFY: 512,
      VERIFY_CHECKSEQUENCEVERIFY: 1024,
      VERIFY_MINIMALIF: 8192,
      VERIFY_NULLFAIL: 16384,
      VERIFY_COMPRESSED_PUBKEYTYPE: 32768,
      VERIFY_SIGHASH_FORKID: 65536,
      VERIFY_REPLAY_PROTECTION: 1 << 17,
      VERIFY_CHECKDATASIG: 1 << 18,
      VERIFY_SCHNORR: 1 << 19,
      VERIFY_DISALLOW_SEGWIT_RECOVERY: 1 << 20,
      VERIFY_SCHNORR_MULTISIG: 1 << 21,
      VERIFY_INPUT_SIGCHECKS: 1 << 22,
      VERIFY_REVERSEBYTES: 1 << 23,
      VERIFY_ZERO_SIGOPS: 1 << 30,
      REPORT_SIGCHECKS: 1 << 31
    }, e.flags.MANDATORY_VERIFY_FLAGS = e.flags.VERIFY_P2SH, e.flags.STANDARD_VERIFY_FLAGS = 0 | e.flags.MANDATORY_VERIFY_FLAGS | e.flags.VERIFY_DERSIG | e.flags.VERIFY_STRICTENC | e.flags.VERIFY_MINIMALDATA | e.flags.VERIFY_SIGPUSHONLY | e.flags.VERIFY_DISCOURAGE_UPGRADABLE_NOPS | e.flags.VERIFY_CLEANSTACK | e.flags.VERIFY_MINIMALIF | e.flags.VERIFY_NULLFAIL | e.flags.VERIFY_CHECKLOCKTIMEVERIFY | e.flags.VERIFY_CHECKSEQUENCEVERIFY | e.flags.VERIFY_LOW_S | e.flags.VERIFY_SIGHASH_FORKID | e.flags.VERIFY_CHECKDATASIG | e.flags.VERIFY_DISALLOW_SEGWIT_RECOVERY | e.flags.VERIFY_SCHNORR_MULTISIG, e.flags.ONLY_STANDARD_VERIFY_FLAGS = e.flags.STANDARD_VERIFY_FLAGS & ~e.flags.MANDATORY_VERIFY_FLAGS, e.hashType = {
      /*
       * Sign all outputs.
       */
      ALL: 1,
      /*
       * Do not sign outputs (zero sequences).
       */
      NONE: 2,
      /*
       * Sign output at the same index (zero sequences).
       */
      SINGLE: 3,
      /*
       * Sighash fork ID.
       */
      SIGHASH_FORKID: 64,
      /*
       * Sign only the current input (mask).
       */
      ANYONECANPAY: 128
    }, e.hashTypeByVal = {
      1: "ALL",
      2: "NONE",
      3: "SINGLE",
      128: "ANYONECANPAY"
    }, e.types = {
      NONSTANDARD: 0,
      PUBKEY: 1,
      PUBKEYHASH: 2,
      SCRIPTHASH: 3,
      MULTISIG: 4,
      NULLDATA: 5
    }, e.typesByVal = {
      0: "NONSTANDARD",
      1: "PUBKEY",
      2: "PUBKEYHASH",
      3: "SCRIPTHASH",
      4: "MULTISIG",
      5: "NULLDATA"
    }, e.isHashType = function(f) {
      if (c(k.isBuffer(f)), f.length === 0)
        return !1;
      const n = f[f.length - 1] & ~(e.hashType.ANYONECANPAY | e.hashType.SIGHASH_FORKID);
      return !(n < e.hashType.ALL || n > e.hashType.SINGLE);
    }, e.countBits = function(f) {
      return f = f - (f >> 1 & 1431655765), f = (f & 858993459) + (f >> 2 & 858993459), (f + (f >> 4) & 252645135) * 16843009 >> 24;
    }, e.isSchnorr = function(f) {
      return c(k.isBuffer(f)), f.length === 64;
    }, e.isLowDER = function(f) {
      return e.isDERSignatureEncoding(f) ? l.isLowDER(f) : !1;
    }, e.isKeyEncoding = function(f) {
      if (c(k.isBuffer(f)), f.length < 33)
        return !1;
      if (f[0] === 4) {
        if (f.length !== 65)
          return !1;
      } else if (f[0] === 2 || f[0] === 3) {
        if (f.length !== 33)
          return !1;
      } else
        return !1;
      return !0;
    }, e.isCompressedEncoding = function(f) {
      return c(k.isBuffer(f)), !(f.length !== 33 || f[0] !== 2 && f[0] !== 3);
    }, e.isDERSignatureEncoding = function(f) {
      if (c(k.isBuffer(f)), f.length < 8 || f.length > 72 || f[0] !== 48 || f[1] !== f.length - 2)
        return !1;
      const n = f[3];
      if (5 + n >= f.length)
        return !1;
      const u = f[5 + n];
      return !(n + u + 6 !== f.length || f[2] !== 2 || n === 0 || f[4] & 128 || n > 1 && f[4] === 0 && !(f[5] & 128) || f[n + 4] !== 2 || u === 0 || f[n + 6] & 128 || u > 1 && f[n + 6] === 0 && !(f[n + 7] & 128));
    }, e.toASM = function(f, n) {
      if (f.length <= 4)
        return w.decode(f).toString(10);
      if (n && e.isDERSignatureEncoding(f.slice(0, -1))) {
        const u = f[f.length - 1];
        let o = e.hashTypeByVal[u & 31] || "";
        return o && (u & e.hashType.ANYONECANPAY && (o += "|ANYONECANPAY"), o = `[${o}]`), f.slice(0, -1).toString("hex") + o;
      }
      return f.toString("hex");
    }, e.hashTypeWithForkValue = function(f, n) {
      return n << 8 | f & 255;
    }, e.getHashTypeForkValue = function(f) {
      return f >>> 8;
    };
  }(Ru)), Ru;
}
var Pu, w3;
function a1() {
  if (w3) return Pu;
  w3 = 1;
  const e = Xe(), c = At(), l = Gi(), w = fs(), m = w.opcodes, f = [];
  let n = null;
  class u {
    /**
     * Create an opcode.
     * Note: this should not be called directly.
     * @constructor
     * @param {Number} value - Opcode.
     * @param {Buffer?} data - Pushdata buffer.
     */
    constructor(i, p) {
      this.value = i || 0, this.data = p || null;
    }
    /**
     * Test whether a pushdata abides by minimaldata.
     * @returns {Boolean}
     */
    isMinimal() {
      return e(0 <= this.value && this.value <= m.OP_PUSHDATA4), this.data ? this.data.length === 1 && (this.data[0] === 129 || this.data[0] >= 1 && this.data[0] <= 16) ? !1 : this.data.length <= 75 ? this.value === this.data.length : this.data.length <= 255 ? this.value === m.OP_PUSHDATA1 : this.data.length <= 65535 ? this.value === m.OP_PUSHDATA2 : !0 : !0;
    }
    /**
     * Test whether opcode is a disabled opcode.
     * @param {Number?} flags - Script standard flags.
     * @returns {Boolean}
     */
    isDisabled(i) {
      switch (this.value) {
        case m.OP_INVERT:
        case m.OP_2MUL:
        case m.OP_2DIV:
        case m.OP_MUL:
        case m.OP_LSHIFT:
        case m.OP_RSHIFT:
          return !0;
      }
      return !1;
    }
    /**
     * Test whether opcode is a branch (if/else/endif).
     * @returns {Boolean}
     */
    isBranch() {
      return this.value >= m.OP_IF && this.value <= m.OP_ENDIF;
    }
    /**
     * Test opcode equality.
     * @param {Opcode} op
     * @returns {Boolean}
     */
    equals(i) {
      return e(u.isOpcode(i)), this.value !== i.value ? !1 : this.data ? (e(i.data), this.data.equals(i.data)) : (e(!i.data), !0);
    }
    /**
     * Convert Opcode to opcode value.
     * @returns {Number}
     */
    toOp() {
      return this.value;
    }
    /**
     * Covert opcode to data push.
     * @returns {Buffer|null}
     */
    toData() {
      return this.data;
    }
    /**
     * Covert opcode to data length.
     * @returns {Number}
     */
    toLength() {
      return this.data ? this.data.length : -1;
    }
    /**
     * Covert and _cast_ opcode to data push.
     * @returns {Buffer|null}
     */
    toPush() {
      return this.value === m.OP_0 ? w.small[1] : this.value === m.OP_1NEGATE ? w.small[0] : this.value >= m.OP_1 && this.value <= m.OP_16 ? w.small[this.value - 80 + 1] : this.toData();
    }
    /**
     * Get string for opcode.
     * @param {String?} enc
     * @returns {Buffer|null}
     */
    toString(i) {
      const p = this.toPush();
      return p ? p.toString(i || "utf8") : null;
    }
    /**
     * Convert opcode to small integer.
     * @returns {Number}
     */
    toSmall() {
      return this.value === m.OP_0 ? 0 : this.value >= m.OP_1 && this.value <= m.OP_16 ? this.value - 80 : -1;
    }
    /**
     * Convert opcode to script number.
     * @param {Boolean?} minimal
     * @param {Number?} limit
     * @returns {ScriptNum|null}
     */
    toNum(i, p) {
      return this.value === m.OP_0 ? l.fromInt(0) : this.value === m.OP_1NEGATE ? l.fromInt(-1) : this.value >= m.OP_1 && this.value <= m.OP_16 ? l.fromInt(this.value - 80) : this.data ? l.decode(this.data, i, p) : null;
    }
    /**
     * Convert opcode to integer.
     * @param {Boolean?} minimal
     * @param {Number?} limit
     * @returns {Number}
     */
    toInt(i, p) {
      const g = this.toNum(i, p);
      return g ? g.getInt() : -1;
    }
    /**
     * Convert opcode to boolean.
     * @returns {Boolean}
     */
    toBool() {
      const i = this.toSmall();
      return i === -1 ? !1 : i === 1;
    }
    /**
     * Convert opcode to its symbolic representation.
     * @returns {String}
     */
    toSymbol() {
      if (this.value === -1)
        return "OP_INVALIDOPCODE";
      const i = w.opcodesByVal[this.value];
      return i || `0x${o(this.value)}`;
    }
    /**
     * Calculate opcode size.
     * @returns {Number}
     */
    getSize() {
      if (!this.data)
        return 1;
      switch (this.value) {
        case m.OP_PUSHDATA1:
          return 2 + this.data.length;
        case m.OP_PUSHDATA2:
          return 3 + this.data.length;
        case m.OP_PUSHDATA4:
          return 5 + this.data.length;
        default:
          return 1 + this.data.length;
      }
    }
    /**
     * Encode the opcode to a buffer writer.
     * @param {BufferWriter} bw
     */
    toWriter(i) {
      if (this.value === -1)
        throw new Error("Cannot reserialize a parse error.");
      if (!this.data)
        return i.writeU8(this.value), i;
      switch (this.value) {
        case m.OP_PUSHDATA1:
          i.writeU8(this.value), i.writeU8(this.data.length), i.writeBytes(this.data);
          break;
        case m.OP_PUSHDATA2:
          i.writeU8(this.value), i.writeU16(this.data.length), i.writeBytes(this.data);
          break;
        case m.OP_PUSHDATA4:
          i.writeU8(this.value), i.writeU32(this.data.length), i.writeBytes(this.data);
          break;
        default:
          e(this.value === this.data.length), i.writeU8(this.value), i.writeBytes(this.data);
          break;
      }
      return i;
    }
    /**
     * Encode the opcode.
     * @returns {Buffer}
     */
    toRaw() {
      const i = this.getSize();
      return this.toWriter(c.write(i)).render();
    }
    /**
     * Convert the opcode to a bitcoind test string.
     * @returns {String} Human-readable script code.
     */
    toFormat() {
      if (this.value === -1)
        return "0x01";
      if (this.data) {
        if (this.data.length <= 4) {
          const b = this.toNum();
          if (this.equals(u.fromNum(b)))
            return b.toString(10);
        }
        const g = w.opcodesByVal[this.value], S = this.data.toString("hex");
        if (!g)
          return `0x${o(this.value)} 0x${S}`;
        let y = this.data.length.toString(16);
        for (; y.length % 2 !== 0; )
          y = "0" + y;
        return `${g} 0x${y} 0x${S}`;
      }
      const i = w.opcodesByVal[this.value];
      return i || `0x${o(this.value)}`;
    }
    /**
     * Format the opcode as bitcoind asm.
     * @param {Boolean?} decode - Attempt to decode hash types.
     * @returns {String} Human-readable script.
     */
    toASM(i) {
      return this.value === -1 ? "[error]" : this.data ? w.toASM(this.data, i) : w.opcodesByVal[this.value] || "OP_UNKNOWN";
    }
    /**
     * Instantiate an opcode from a number opcode.
     * @param {Number} op
     * @returns {Opcode}
     */
    static fromOp(i) {
      e(typeof i == "number");
      const p = f[i];
      return e(p, "Bad opcode."), p;
    }
    /**
     * Instantiate a pushdata opcode from
     * a buffer (will encode minimaldata).
     * @param {Buffer} data
     * @returns {Opcode}
     */
    static fromData(i) {
      if (e(k.isBuffer(i)), i.length === 1) {
        if (i[0] === 129)
          return this.fromOp(m.OP_1NEGATE);
        if (i[0] >= 1 && i[0] <= 16)
          return this.fromOp(i[0] + 80);
      }
      return this.fromPush(i);
    }
    /**
     * Instantiate a pushdata opcode from a
     * buffer (this differs from fromData in
     * that it will _always_ be a pushdata op).
     * @param {Buffer} data
     * @returns {Opcode}
     */
    static fromPush(i) {
      if (e(k.isBuffer(i)), i.length === 0)
        return this.fromOp(m.OP_0);
      if (i.length <= 75)
        return new this(i.length, i);
      if (i.length <= 255)
        return new this(m.OP_PUSHDATA1, i);
      if (i.length <= 65535)
        return new this(m.OP_PUSHDATA2, i);
      if (i.length <= 4294967295)
        return new this(m.OP_PUSHDATA4, i);
      throw new Error("Pushdata size too large.");
    }
    /**
     * Instantiate a pushdata opcode from a string.
     * @param {String} str
     * @param {String} [enc=utf8]
     * @returns {Opcode}
     */
    static fromString(i, p) {
      e(typeof i == "string");
      const g = k.from(i, p || "utf8");
      return this.fromData(g);
    }
    /**
     * Instantiate an opcode from a small number.
     * @param {Number} num
     * @returns {Opcode}
     */
    static fromSmall(i) {
      return e((i & 255) === i && i >= 0 && i <= 16), this.fromOp(i === 0 ? 0 : i + 80);
    }
    /**
     * Instantiate an opcode from a ScriptNum.
     * @param {ScriptNumber} num
     * @returns {Opcode}
     */
    static fromNum(i) {
      return e(l.isScriptNum(i)), this.fromData(i.encode());
    }
    /**
     * Instantiate an opcode from a Number.
     * @param {Number} num
     * @returns {Opcode}
     */
    static fromInt(i) {
      return e(Number.isSafeInteger(i)), i === 0 ? this.fromOp(m.OP_0) : i === -1 ? this.fromOp(m.OP_1NEGATE) : i >= 1 && i <= 16 ? this.fromOp(i + 80) : this.fromNum(l.fromNumber(i));
    }
    /**
     * Instantiate an opcode from a Number.
     * @param {Boolean} value
     * @returns {Opcode}
     */
    static fromBool(i) {
      return e(typeof i == "boolean"), this.fromSmall(i ? 1 : 0);
    }
    /**
     * Instantiate a pushdata opcode from symbolic name.
     * @example
     *   Opcode.fromSymbol('checksequenceverify')
     * @param {String} name
     * @returns {Opcode}
     */
    static fromSymbol(i) {
      e(typeof i == "string"), e(i.length > 0), i.charCodeAt(0) & 32 && (i = i.toUpperCase()), /^OP_/.test(i) || (i = `OP_${i}`);
      const p = w.opcodes[i];
      if (p != null)
        return this.fromOp(p);
      e(/^OP_0X/.test(i), "Unknown opcode."), e(i.length === 7, "Unknown opcode.");
      const g = parseInt(i.substring(5), 16);
      return e((g & 255) === g, "Unknown opcode."), this.fromOp(g);
    }
    /**
     * Instantiate opcode from buffer reader.
     * @param {BufferReader} br
     * @returns {Opcode}
     */
    static fromReader(i) {
      const p = i.readU8(), g = f[p];
      if (g)
        return g;
      switch (p) {
        case m.OP_PUSHDATA1: {
          if (i.left() < 1)
            return n;
          const S = i.readU8();
          if (i.left() < S)
            return i.seek(i.left()), n;
          const y = i.readBytes(S);
          return new this(p, y);
        }
        case m.OP_PUSHDATA2: {
          if (i.left() < 2)
            return i.seek(i.left()), n;
          const S = i.readU16();
          if (i.left() < S)
            return i.seek(i.left()), n;
          const y = i.readBytes(S);
          return new this(p, y);
        }
        case m.OP_PUSHDATA4: {
          if (i.left() < 4)
            return i.seek(i.left()), n;
          const S = i.readU32();
          if (i.left() < S)
            return i.seek(i.left()), n;
          const y = i.readBytes(S);
          return new this(p, y);
        }
        default: {
          if (i.left() < p)
            return i.seek(i.left()), n;
          const S = i.readBytes(p);
          return new this(p, S);
        }
      }
    }
    /**
     * Instantiate opcode from serialized data.
     * @param {Buffer} data
     * @returns {Opcode}
     */
    static fromRaw(i) {
      return this.fromReader(c.read(i));
    }
    /**
     * Test whether an object an Opcode.
     * @param {Object} obj
     * @returns {Boolean}
     */
    static isOpcode(i) {
      return i instanceof u;
    }
  }
  function o(s) {
    return s <= 15 ? "0" + s.toString(16) : s.toString(16);
  }
  n = Object.freeze(new u(-1));
  for (let s = 0; s <= 255; s++) {
    if (s >= 1 && s <= 78) {
      f.push(null);
      continue;
    }
    const i = new u(s);
    f.push(Object.freeze(i));
  }
  return Pu = u, Pu;
}
var ku, y3;
function Eo() {
  if (y3) return ku;
  y3 = 1;
  const e = Xe(), c = fs(), l = Gi();
  class w {
    /**
     * Create a stack.
     * @constructor
     * @param {Buffer[]?} items - Stack items.
     */
    constructor(f) {
      this.items = f || [];
    }
    /**
     * Get length.
     * @returns {Number}
     */
    get length() {
      return this.items.length;
    }
    /**
     * Set length.
     * @param {Number} value
     */
    set length(f) {
      this.items.length = f;
    }
    /**
     * Instantiate a value-only iterator.
     * @returns {StackIterator}
     */
    [Symbol.iterator]() {
      return this.items[Symbol.iterator]();
    }
    /**
     * Instantiate a value-only iterator.
     * @returns {StackIterator}
     */
    values() {
      return this.items.values();
    }
    /**
     * Instantiate a key and value iterator.
     * @returns {StackIterator}
     */
    entries() {
      return this.items.entries();
    }
    /**
     * Inspect the stack.
     * @returns {String} Human-readable stack.
     */
    inspect() {
      return `<Stack: ${this.toString()}>`;
    }
    /**
     * Convert the stack to a string.
     * @returns {String} Human-readable stack.
     */
    toString() {
      const f = [];
      for (const n of this.items)
        f.push(n.toString("hex"));
      return f.join(" ");
    }
    /**
     * Format the stack as bitcoind asm.
     * @param {Boolean?} decode - Attempt to decode hash types.
     * @returns {String} Human-readable script.
     */
    toASM(f) {
      const n = [];
      for (const u of this.items)
        n.push(c.toASM(u, f));
      return n.join(" ");
    }
    /**
     * Clone the stack.
     * @returns {Stack} Cloned stack.
     */
    clone() {
      return new this.constructor(this.items.slice());
    }
    /**
     * Clear the stack.
     * @returns {Stack}
     */
    clear() {
      return this.items.length = 0, this;
    }
    /**
     * Get a stack item by index.
     * @param {Number} index
     * @returns {Buffer|null}
     */
    get(f) {
      return f < 0 && (f += this.items.length), f < 0 || f >= this.items.length ? null : this.items[f];
    }
    /**
     * Pop a stack item.
     * @see Array#pop
     * @returns {Buffer|null}
     */
    pop() {
      return this.items.pop() || null;
    }
    /**
     * Shift a stack item.
     * @see Array#shift
     * @returns {Buffer|null}
     */
    shift() {
      return this.items.shift() || null;
    }
    /**
     * Remove an item.
     * @param {Number} index
     * @returns {Buffer}
     */
    remove(f) {
      if (f < 0 && (f += this.items.length), f < 0 || f >= this.items.length)
        return null;
      const n = this.items.splice(f, 1);
      return n.length === 0 ? null : n[0];
    }
    /**
     * Set stack item at index.
     * @param {Number} index
     * @param {Buffer} value
     * @returns {Buffer}
     */
    set(f, n) {
      return f < 0 && (f += this.items.length), e(k.isBuffer(n)), e(f >= 0 && f <= this.items.length), this.items[f] = n, this;
    }
    /**
     * Push item onto stack.
     * @see Array#push
     * @param {Buffer} item
     * @returns {Number} Stack size.
     */
    push(f) {
      return e(k.isBuffer(f)), this.items.push(f), this;
    }
    /**
     * Unshift item from stack.
     * @see Array#unshift
     * @param {Buffer} item
     * @returns {Number}
     */
    unshift(f) {
      return e(k.isBuffer(f)), this.items.unshift(f), this;
    }
    /**
     * Insert an item.
     * @param {Number} index
     * @param {Buffer} item
     * @returns {Buffer}
     */
    insert(f, n) {
      return f < 0 && (f += this.items.length), e(k.isBuffer(n)), e(f >= 0 && f <= this.items.length), this.items.splice(f, 0, n), this;
    }
    /**
     * Erase stack items.
     * @param {Number} start
     * @param {Number} end
     * @returns {Buffer[]}
     */
    erase(f, n) {
      f < 0 && (f = this.items.length + f), n < 0 && (n = this.items.length + n), this.items.splice(f, n - f);
    }
    /**
     * Swap stack values.
     * @param {Number} i1 - Index 1.
     * @param {Number} i2 - Index 2.
     */
    swap(f, n) {
      f < 0 && (f = this.items.length + f), n < 0 && (n = this.items.length + n);
      const u = this.items[f], o = this.items[n];
      this.items[f] = o, this.items[n] = u;
    }
    /*
     * Data
     */
    getData(f) {
      return this.get(f);
    }
    popData() {
      return this.pop();
    }
    shiftData() {
      return this.shift();
    }
    removeData(f) {
      return this.remove(f);
    }
    setData(f, n) {
      return this.set(f, n);
    }
    pushData(f) {
      return this.push(f);
    }
    unshiftData(f) {
      return this.unshift(f);
    }
    insertData(f, n) {
      return this.insert(f, n);
    }
    /*
     * Length
     */
    getLength(f) {
      const n = this.get(f);
      return n ? n.length : -1;
    }
    /*
     * String
     */
    getString(f, n) {
      const u = this.get(f);
      return u ? w.toString(u, n) : null;
    }
    popString(f) {
      const n = this.pop();
      return n ? w.toString(n, f) : null;
    }
    shiftString(f) {
      const n = this.shift();
      return n ? w.toString(n, f) : null;
    }
    removeString(f, n) {
      const u = this.remove(f);
      return u ? w.toString(u, n) : null;
    }
    setString(f, n, u) {
      return this.set(f, w.fromString(n, u));
    }
    pushString(f, n) {
      return this.push(w.fromString(f, n));
    }
    unshiftString(f, n) {
      return this.unshift(w.fromString(f, n));
    }
    insertString(f, n, u) {
      return this.insert(f, w.fromString(n, u));
    }
    /*
     * Num
     */
    getNum(f, n, u) {
      const o = this.get(f);
      return o ? w.toNum(o, n, u) : null;
    }
    popNum(f, n) {
      const u = this.pop();
      return u ? w.toNum(u, f, n) : null;
    }
    shiftNum(f, n) {
      const u = this.shift();
      return u ? w.toNum(u, f, n) : null;
    }
    removeNum(f, n, u) {
      const o = this.remove(f);
      return o ? w.toNum(o, n, u) : null;
    }
    setNum(f, n) {
      return this.set(f, w.fromNum(n));
    }
    pushNum(f) {
      return this.push(w.fromNum(f));
    }
    unshiftNum(f) {
      return this.unshift(w.fromNum(f));
    }
    insertNum(f, n) {
      return this.insert(f, w.fromNum(n));
    }
    /*
     * Int
     */
    getInt(f, n, u) {
      const o = this.get(f);
      return o ? w.toInt(o, n, u) : -1;
    }
    popInt(f, n) {
      const u = this.pop();
      return u ? w.toInt(u, f, n) : -1;
    }
    shiftInt(f, n) {
      const u = this.shift();
      return u ? w.toInt(u, f, n) : -1;
    }
    removeInt(f, n, u) {
      const o = this.remove(f);
      return o ? w.toInt(o, n, u) : -1;
    }
    setInt(f, n) {
      return this.set(f, w.fromInt(n));
    }
    pushInt(f) {
      return this.push(w.fromInt(f));
    }
    unshiftInt(f) {
      return this.unshift(w.fromInt(f));
    }
    insertInt(f, n) {
      return this.insert(f, w.fromInt(n));
    }
    /*
     * Bool
     */
    getBool(f) {
      const n = this.get(f);
      return n ? w.toBool(n) : !1;
    }
    popBool() {
      const f = this.pop();
      return f ? w.toBool(f) : !1;
    }
    shiftBool() {
      const f = this.shift();
      return f ? w.toBool(f) : !1;
    }
    removeBool(f) {
      const n = this.remove(f);
      return n ? w.toBool(n) : !1;
    }
    setBool(f, n) {
      return this.set(f, w.fromBool(n));
    }
    pushBool(f) {
      return this.push(w.fromBool(f));
    }
    unshiftBool(f) {
      return this.unshift(w.fromBool(f));
    }
    insertBool(f, n) {
      return this.insert(f, w.fromBool(n));
    }
    /**
     * Test an object to see if it is a Stack.
     * @param {Object} obj
     * @returns {Boolean}
     */
    static isStack(f) {
      return f instanceof w;
    }
    /*
     * Encoding
     */
    static toString(f, n) {
      return e(k.isBuffer(f)), f.toString(n || "utf8");
    }
    static fromString(f, n) {
      return e(typeof f == "string"), k.from(f, n || "utf8");
    }
    static toNum(f, n, u) {
      return l.decode(f, n, u);
    }
    static fromNum(f) {
      return e(l.isScriptNum(f)), f.encode();
    }
    static toInt(f, n, u) {
      return w.toNum(f, n, u).getInt();
    }
    static fromInt(f) {
      if (e(typeof f == "number"), f >= -1 && f <= 16)
        return c.small[f + 1];
      const n = l.fromNumber(f);
      return w.fromNum(n);
    }
    static toBool(f) {
      e(k.isBuffer(f));
      for (let n = 0; n < f.length; n++)
        if (f[n] !== 0)
          return !(n === f.length - 1 && f[n] === 128);
      return !1;
    }
    static fromBool(f) {
      return e(typeof f == "boolean"), w.fromInt(f ? 1 : 0);
    }
  }
  return ku = w, ku;
}
var Bu, v3;
function Bp() {
  if (v3) return Bu;
  v3 = 1, Xe();
  class e {
    constructor(l) {
      this.sigchecks = l || 0, this.init();
    }
    init() {
      return this.sigchecks;
    }
  }
  return Bu = e, Bu;
}
var Mu, S3;
function Cr() {
  if (S3) return Mu;
  S3 = 1;
  const e = Xe(), c = At(), l = s1(), w = kp(), m = Ar(), f = Xi(), n = mr(), u = zr(), o = Lt(), s = vi(), i = a1(), p = Eo(), g = So(), S = Gi(), y = fs(), b = Gr(), h = Bp(), a = y.opcodes, E = y.types, H = y.countBits, { encoding: j } = c, G = k.alloc(0), N = new h();
  class T {
    /**
     * Create a script.
     * @constructor
     * @param {Buffer|Array|Object} code
     */
    constructor(v) {
      this.raw = G, this.code = [], v && this.fromOptions(v);
    }
    /**
     * Get length.
     * @returns {Number}
     */
    get length() {
      return this.code.length;
    }
    /**
     * Set length.
     * @param {Number} value
     */
    set length(v) {
      this.code.length = v;
    }
    /**
     * Inject properties from options object.
     * @private
     * @param {Object} options
     */
    fromOptions(v) {
      if (e(v, "Script data is required."), k.isBuffer(v))
        return this.fromRaw(v);
      if (Array.isArray(v))
        return this.fromArray(v);
      if (v.raw) {
        if (!v.code)
          return this.fromRaw(v.raw);
        e(k.isBuffer(v.raw), "Raw must be a Buffer."), this.raw = v.raw;
      }
      if (v.code) {
        if (!v.raw)
          return this.fromArray(v.code);
        e(Array.isArray(v.code), "Code must be an array."), this.code = v.code;
      }
      return this;
    }
    /**
     * Insantiate script from options object.
     * @param {Object} options
     * @returns {Script}
     */
    static fromOptions(v) {
      return new this().fromOptions(v);
    }
    /**
     * Instantiate a value-only iterator.
     * @returns {ScriptIterator}
     */
    values() {
      return this.code.values();
    }
    /**
     * Instantiate a key and value iterator.
     * @returns {ScriptIterator}
     */
    entries() {
      return this.code.entries();
    }
    /**
     * Instantiate a value-only iterator.
     * @returns {ScriptIterator}
     */
    [Symbol.iterator]() {
      return this.code[Symbol.iterator]();
    }
    /**
     * Convert the script to an array of
     * Buffers (pushdatas) and Numbers
     * (opcodes).
     * @returns {Array}
     */
    toArray() {
      return this.code.slice();
    }
    /**
     * Inject properties from an array of
     * of buffers and numbers.
     * @private
     * @param {Array} code
     * @returns {Script}
     */
    fromArray(v) {
      e(Array.isArray(v)), this.clear();
      for (const Y of v)
        this.push(Y);
      return this.compile();
    }
    /**
     * Instantiate script from an array
     * of buffers and numbers.
     * @param {Array} code
     * @returns {Script}
     */
    static fromArray(v) {
      return new this().fromArray(v);
    }
    /**
     * Convert script to stack items.
     * @returns {Buffer[]}
     */
    toItems() {
      const v = [];
      for (const Y of this.code) {
        const he = Y.toPush();
        if (!he)
          throw new Error("Non-push opcode in script.");
        v.push(he);
      }
      return v;
    }
    /**
     * Inject data from stack items.
     * @private
     * @param {Buffer[]} items
     * @returns {Script}
     */
    fromItems(v) {
      e(Array.isArray(v)), this.clear();
      for (const Y of v)
        this.pushData(Y);
      return this.compile();
    }
    /**
     * Instantiate script from stack items.
     * @param {Buffer[]} items
     * @returns {Script}
     */
    static fromItems(v) {
      return new this().fromItems(v);
    }
    /**
     * Convert script to stack.
     * @returns {Stack}
     */
    toStack() {
      return new p(this.toItems());
    }
    /**
     * Inject data from stack.
     * @private
     * @param {Stack} stack
     * @returns {Script}
     */
    fromStack(v) {
      return this.fromItems(v.items);
    }
    /**
     * Instantiate script from stack.
     * @param {Stack} stack
     * @returns {Script}
     */
    static fromStack(v) {
      return new this().fromStack(v);
    }
    /**
     * Clone the script.
     * @returns {Script} Cloned script.
     */
    clone() {
      return new this.constructor().inject(this);
    }
    /**
     * Inject properties from script.
     * Used for cloning.
     * @private
     * @param {Script} script
     * @returns {Script}
     */
    inject(v) {
      return this.raw = v.raw, this.code = v.code.slice(), this;
    }
    /**
     * Test equality against script.
     * @param {Script} script
     * @returns {Boolean}
     */
    equals(v) {
      return e(T.isScript(v)), this.raw.equals(v.raw);
    }
    /**
     * Compare against another script.
     * @param {Script} script
     * @returns {Number}
     */
    compare(v) {
      return e(T.isScript(v)), this.raw.compare(v.raw);
    }
    /**
     * Clear the script.
     * @returns {Script}
     */
    clear() {
      return this.raw = G, this.code.length = 0, this;
    }
    /**
     * Inspect the script.
     * @returns {String} Human-readable script code.
     */
    inspect() {
      return `<Script: ${this.toString()}>`;
    }
    /**
     * Convert the script to a bitcoind test string.
     * @returns {String} Human-readable script code.
     */
    toString() {
      const v = [];
      for (const Y of this.code)
        v.push(Y.toFormat());
      return v.join(" ");
    }
    /**
     * Format the script as bitcoind asm.
     * @param {Boolean?} decode - Attempt to decode hash types.
     * @returns {String} Human-readable script.
     */
    toASM(v) {
      this.isNulldata() && (v = !1);
      const Y = [];
      for (const he of this.code)
        Y.push(he.toASM(v));
      return Y.join(" ");
    }
    /**
     * Re-encode the script internally. Useful if you
     * changed something manually in the `code` array.
     * @returns {Script}
     */
    compile() {
      if (this.code.length === 0)
        return this.clear();
      let v = 0;
      for (const he of this.code)
        v += he.getSize();
      const Y = c.write(v);
      for (const he of this.code)
        he.toWriter(Y);
      return this.raw = Y.render(), this;
    }
    /**
     * Write the script to a buffer writer.
     * @param {BufferWriter} bw
     */
    toWriter(v) {
      return v.writeVarBytes(this.raw), v;
    }
    /**
     * Encode the script to a Buffer. See {@link Script#encode}.
     * @param {String} enc - Encoding, either `'hex'` or `null`.
     * @returns {Buffer|String} Serialized script.
     */
    toRaw() {
      return this.raw;
    }
    /**
     * Convert script to a hex string.
     * @returns {String}
     */
    toJSON() {
      return this.toRaw().toString("hex");
    }
    /**
     * Inject properties from json object.
     * @private
     * @param {String} json
     */
    fromJSON(v) {
      return e(typeof v == "string", "Code must be a string."), this.fromRaw(k.from(v, "hex"));
    }
    /**
     * Instantiate script from a hex string.
     * @params {String} json
     * @returns {Script}
     */
    static fromJSON(v) {
      return new this().fromJSON(v);
    }
    /**
     * Get the script's "subscript" starting at a separator.
     * @param {Number} index - The last separator to sign/verify beyond.
     * @returns {Script} Subscript.
     */
    getSubscript(v) {
      if (v === 0)
        return this.clone();
      const Y = new T();
      for (let he = v; he < this.code.length; he++) {
        const le = this.code[he];
        if (le.value === -1)
          break;
        Y.code.push(le);
      }
      return Y.compile();
    }
    /**
     * Get the script's "subscript" starting at a separator.
     * Remove all OP_CODESEPARATORs if present. This bizarre
     * behavior is necessary for signing and verification when
     * code separators are present.
     * @returns {Script} Subscript.
     */
    removeSeparators() {
      let v = !1;
      for (const he of this.code) {
        if (he.value === -1)
          break;
        if (he.value === a.OP_CODESEPARATOR) {
          v = !0;
          break;
        }
      }
      if (!v)
        return this;
      const Y = new T();
      for (const he of this.code) {
        if (he.value === -1)
          break;
        he.value !== a.OP_CODESEPARATOR && Y.code.push(he);
      }
      return Y.compile();
    }
    /**
     * Get the value of the checkBits while calculated as little endian.
     * @param {Buffer} abkam - Stack depth of the dummy element.
     * @param {Number?} nKeysCount - Stack depth of the top pubkeys.
     * @returns {Number}
     */
    bitcalculator(v, Y) {
      let he = 0;
      const le = (Y + 7) / 8;
      for (let ge = 0; ge < le; ge++)
        he |= v[ge] << 8 * ge;
      return he;
    }
    /**
     * Execute and interpret the script.
     * @param {Stack} stack - Script execution stack.
     * @param {Number?} flags - Script standard flags.
     * @param {TX?} tx - Transaction being verified.
     * @param {Number?} index - Index of input being verified.
     * @param {Amount?} value - Previous output value.
     * @param {Number?} sigchecks
     * @throws {ScriptError} Will be thrown on VERIFY failures.
     */
    execute(v, Y, he, le, ge, Ee) {
      if (Y == null && (Y = T.flags.STANDARD_VERIFY_FLAGS), this.getSize() > o.MAX_SCRIPT_SIZE)
        throw new g("SCRIPT_SIZE");
      const we = [], z = [];
      let I = 0, ne = 0, t = 0, d, B = !1;
      Y & T.flags.VERIFY_MINIMALDATA && (B = !0);
      for (let U = 0; U < this.code.length; U++) {
        const J = this.code[U];
        if (J.value === -1)
          throw new g("BAD_OPCODE", J, U);
        if (J.data && J.data.length > o.MAX_SCRIPT_PUSH)
          throw new g("PUSH_SIZE", J, U);
        if (J.value > a.OP_16 && ++ne > o.MAX_SCRIPT_OPS)
          throw new g("OP_COUNT", J, U);
        if (J.isDisabled(Y))
          throw new g("DISABLED_OPCODE", J, U);
        if (t && !J.isBranch()) {
          if (v.length + z.length > o.MAX_SCRIPT_STACK)
            throw new g("STACK_SIZE", J, U);
          continue;
        }
        if (J.data && 0 <= J.value <= a.OP_PUSHDATA4) {
          if (B && !J.isMinimal())
            throw new g("MINIMALDATA", J, U);
          if (v.push(J.data), v.length + z.length > o.MAX_SCRIPT_STACK)
            throw new g("STACK_SIZE", J, U);
          continue;
        }
        switch (J.value) {
          case a.OP_0: {
            v.pushInt(0);
            break;
          }
          case a.OP_1NEGATE: {
            v.pushInt(-1);
            break;
          }
          case a.OP_1:
          case a.OP_2:
          case a.OP_3:
          case a.OP_4:
          case a.OP_5:
          case a.OP_6:
          case a.OP_7:
          case a.OP_8:
          case a.OP_9:
          case a.OP_10:
          case a.OP_11:
          case a.OP_12:
          case a.OP_13:
          case a.OP_14:
          case a.OP_15:
          case a.OP_16: {
            v.pushInt(J.value - 80);
            break;
          }
          case a.OP_NOP:
            break;
          case a.OP_CHECKLOCKTIMEVERIFY: {
            if (!(Y & T.flags.VERIFY_CHECKLOCKTIMEVERIFY)) {
              if (Y & T.flags.VERIFY_DISCOURAGE_UPGRADABLE_NOPS)
                throw new g("DISCOURAGE_UPGRADABLE_NOPS", J, U);
              break;
            }
            if (!he)
              throw new g("UNKNOWN_ERROR", "No TX passed in.");
            if (v.length === 0)
              throw new g("INVALID_STACK_OPERATION", J, U);
            const C = v.getNum(-1, B, 5);
            if (C.isNeg())
              throw new g("NEGATIVE_LOCKTIME", J, U);
            const M = C.toDouble();
            if (!he.verifyLocktime(le, M))
              throw new g("UNSATISFIED_LOCKTIME", J, U);
            break;
          }
          case a.OP_CHECKSEQUENCEVERIFY: {
            if (!(Y & T.flags.VERIFY_CHECKSEQUENCEVERIFY)) {
              if (Y & T.flags.VERIFY_DISCOURAGE_UPGRADABLE_NOPS)
                throw new g("DISCOURAGE_UPGRADABLE_NOPS", J, U);
              break;
            }
            if (!he)
              throw new g("UNKNOWN_ERROR", "No TX passed in.");
            if (v.length === 0)
              throw new g("INVALID_STACK_OPERATION", J, U);
            const C = v.getNum(-1, B, 5);
            if (C.isNeg())
              throw new g("NEGATIVE_LOCKTIME", J, U);
            const M = C.toDouble();
            if (!he.verifySequence(le, M))
              throw new g("UNSATISFIED_LOCKTIME", J, U);
            break;
          }
          case a.OP_NOP1:
          case a.OP_NOP4:
          case a.OP_NOP5:
          case a.OP_NOP6:
          case a.OP_NOP7:
          case a.OP_NOP8:
          case a.OP_NOP9:
          case a.OP_NOP10: {
            if (Y & T.flags.VERIFY_DISCOURAGE_UPGRADABLE_NOPS)
              throw new g("DISCOURAGE_UPGRADABLE_NOPS", J, U);
            break;
          }
          case a.OP_IF:
          case a.OP_NOTIF: {
            let C = !1;
            if (!t) {
              if (v.length < 1)
                throw new g("UNBALANCED_CONDITIONAL", J, U);
              if (Y & T.flags.VERIFY_MINIMALIF) {
                const M = v.get(-1);
                if (M.length > 1)
                  throw new g("MINIMALIF");
                if (M.length === 1 && M[0] !== 1)
                  throw new g("MINIMALIF");
              }
              C = v.getBool(-1), J.value === a.OP_NOTIF && (C = !C), v.pop();
            }
            we.push(C), C || (t += 1);
            break;
          }
          case a.OP_ELSE: {
            if (we.length === 0)
              throw new g("UNBALANCED_CONDITIONAL", J, U);
            we[we.length - 1] = !we[we.length - 1], we[we.length - 1] ? t -= 1 : t += 1;
            break;
          }
          case a.OP_ENDIF: {
            if (we.length === 0)
              throw new g("UNBALANCED_CONDITIONAL", J, U);
            we.pop() || (t -= 1);
            break;
          }
          case a.OP_VERIFY: {
            if (v.length === 0)
              throw new g("INVALID_STACK_OPERATION", J, U);
            if (!v.getBool(-1))
              throw new g("VERIFY", J, U);
            v.pop();
            break;
          }
          case a.OP_RETURN:
            throw new g("OP_RETURN", J, U);
          case a.OP_TOALTSTACK: {
            if (v.length === 0)
              throw new g("INVALID_STACK_OPERATION", J, U);
            z.push(v.pop());
            break;
          }
          case a.OP_FROMALTSTACK: {
            if (z.length === 0)
              throw new g("INVALID_ALTSTACK_OPERATION", J, U);
            v.push(z.pop());
            break;
          }
          case a.OP_2DROP: {
            if (v.length < 2)
              throw new g("INVALID_STACK_OPERATION", J, U);
            v.pop(), v.pop();
            break;
          }
          case a.OP_2DUP: {
            if (v.length < 2)
              throw new g("INVALID_STACK_OPERATION", J, U);
            const C = v.get(-2), M = v.get(-1);
            v.push(C), v.push(M);
            break;
          }
          case a.OP_3DUP: {
            if (v.length < 3)
              throw new g("INVALID_STACK_OPERATION", J, U);
            const C = v.get(-3), M = v.get(-2), $ = v.get(-1);
            v.push(C), v.push(M), v.push($);
            break;
          }
          case a.OP_2OVER: {
            if (v.length < 4)
              throw new g("INVALID_STACK_OPERATION", J, U);
            const C = v.get(-4), M = v.get(-3);
            v.push(C), v.push(M);
            break;
          }
          case a.OP_2ROT: {
            if (v.length < 6)
              throw new g("INVALID_STACK_OPERATION", J, U);
            const C = v.get(-6), M = v.get(-5);
            v.erase(-6, -4), v.push(C), v.push(M);
            break;
          }
          case a.OP_2SWAP: {
            if (v.length < 4)
              throw new g("INVALID_STACK_OPERATION", J, U);
            v.swap(-4, -2), v.swap(-3, -1);
            break;
          }
          case a.OP_IFDUP: {
            if (v.length === 0)
              throw new g("INVALID_STACK_OPERATION", J, U);
            if (v.getBool(-1)) {
              const C = v.get(-1);
              v.push(C);
            }
            break;
          }
          case a.OP_DEPTH: {
            v.pushInt(v.length);
            break;
          }
          case a.OP_DROP: {
            if (v.length === 0)
              throw new g("INVALID_STACK_OPERATION", J, U);
            v.pop();
            break;
          }
          case a.OP_DUP: {
            if (v.length === 0)
              throw new g("INVALID_STACK_OPERATION", J, U);
            v.push(v.get(-1));
            break;
          }
          case a.OP_NIP: {
            if (v.length < 2)
              throw new g("INVALID_STACK_OPERATION", J, U);
            v.remove(-2);
            break;
          }
          case a.OP_OVER: {
            if (v.length < 2)
              throw new g("INVALID_STACK_OPERATION", J, U);
            v.push(v.get(-2));
            break;
          }
          case a.OP_PICK:
          case a.OP_ROLL: {
            if (v.length < 2)
              throw new g("INVALID_STACK_OPERATION", J, U);
            const C = v.getInt(-1, B, 4);
            if (v.pop(), C < 0 || C >= v.length)
              throw new g("INVALID_STACK_OPERATION", J, U);
            const M = v.get(-C - 1);
            J.value === a.OP_ROLL && v.remove(-C - 1), v.push(M);
            break;
          }
          case a.OP_ROT: {
            if (v.length < 3)
              throw new g("INVALID_STACK_OPERATION", J, U);
            v.swap(-3, -2), v.swap(-2, -1);
            break;
          }
          case a.OP_SWAP: {
            if (v.length < 2)
              throw new g("INVALID_STACK_OPERATION", J, U);
            v.swap(-2, -1);
            break;
          }
          case a.OP_TUCK: {
            if (v.length < 2)
              throw new g("INVALID_STACK_OPERATION", J, U);
            v.insert(-2, v.get(-1));
            break;
          }
          case a.OP_SIZE: {
            if (v.length < 1)
              throw new g("INVALID_STACK_OPERATION", J, U);
            v.pushInt(v.get(-1).length);
            break;
          }
          case a.OP_EQUAL:
          case a.OP_EQUALVERIFY: {
            if (v.length < 2)
              throw new g("INVALID_STACK_OPERATION", J, U);
            const C = v.get(-2), M = v.get(-1), $ = C.equals(M);
            if (v.pop(), v.pop(), v.pushBool($), J.value === a.OP_EQUALVERIFY) {
              if (!$)
                throw new g("EQUALVERIFY", J, U);
              v.pop();
            }
            break;
          }
          case a.OP_1ADD:
          case a.OP_1SUB:
          case a.OP_NEGATE:
          case a.OP_ABS:
          case a.OP_NOT:
          case a.OP_0NOTEQUAL: {
            if (v.length < 1)
              throw new g("INVALID_STACK_OPERATION", J, U);
            let C = v.getNum(-1, B, 4), M;
            switch (J.value) {
              case a.OP_1ADD:
                C.iaddn(1);
                break;
              case a.OP_1SUB:
                C.isubn(1);
                break;
              case a.OP_NEGATE:
                C.ineg();
                break;
              case a.OP_ABS:
                C.iabs();
                break;
              case a.OP_NOT:
                M = C.isZero(), C = S.fromBool(M);
                break;
              case a.OP_0NOTEQUAL:
                M = !C.isZero(), C = S.fromBool(M);
                break;
              default:
                e(!1, "Fatal script error.");
                break;
            }
            v.pop(), v.pushNum(C);
            break;
          }
          case a.OP_ADD:
          case a.OP_SUB:
          case a.OP_DIV:
          case a.OP_MOD:
          case a.OP_BOOLAND:
          case a.OP_BOOLOR:
          case a.OP_NUMEQUAL:
          case a.OP_NUMEQUALVERIFY:
          case a.OP_NUMNOTEQUAL:
          case a.OP_LESSTHAN:
          case a.OP_GREATERTHAN:
          case a.OP_LESSTHANOREQUAL:
          case a.OP_GREATERTHANOREQUAL:
          case a.OP_MIN:
          case a.OP_MAX: {
            if (v.length < 2)
              throw new g("INVALID_STACK_OPERATION", J, U);
            const C = v.getNum(-2, B, 4), M = v.getNum(-1, B, 4);
            let $, r;
            switch (J.value) {
              case a.OP_ADD:
                $ = C.iadd(M);
                break;
              case a.OP_SUB:
                $ = C.isub(M);
                break;
              case a.OP_DIV:
                if (M.isZero())
                  throw new g("DIV_BY_ZERO", J, U);
                $ = C.div(M);
                break;
              case a.OP_MOD:
                if (M.isZero())
                  throw new g("MOD_BY_ZERO", J, U);
                $ = C.mod(M);
                break;
              case a.OP_BOOLAND:
                r = C.toBool() && M.toBool(), $ = S.fromBool(r);
                break;
              case a.OP_BOOLOR:
                r = C.toBool() || M.toBool(), $ = S.fromBool(r);
                break;
              case a.OP_NUMEQUAL:
                r = C.eq(M), $ = S.fromBool(r);
                break;
              case a.OP_NUMEQUALVERIFY:
                r = C.eq(M), $ = S.fromBool(r);
                break;
              case a.OP_NUMNOTEQUAL:
                r = !C.eq(M), $ = S.fromBool(r);
                break;
              case a.OP_LESSTHAN:
                r = C.lt(M), $ = S.fromBool(r);
                break;
              case a.OP_GREATERTHAN:
                r = C.gt(M), $ = S.fromBool(r);
                break;
              case a.OP_LESSTHANOREQUAL:
                r = C.lte(M), $ = S.fromBool(r);
                break;
              case a.OP_GREATERTHANOREQUAL:
                r = C.gte(M), $ = S.fromBool(r);
                break;
              case a.OP_MIN:
                $ = S.min(C, M);
                break;
              case a.OP_MAX:
                $ = S.max(C, M);
                break;
              default:
                e(!1, "Fatal script error.");
                break;
            }
            if (v.pop(), v.pop(), v.pushNum($), J.value === a.OP_NUMEQUALVERIFY) {
              if (!v.getBool(-1))
                throw new g("NUMEQUALVERIFY", J, U);
              v.pop();
            }
            break;
          }
          case a.OP_WITHIN: {
            if (v.length < 3)
              throw new g("INVALID_STACK_OPERATION", J, U);
            const C = v.getNum(-3, B, 4), M = v.getNum(-2, B, 4), $ = v.getNum(-1, B, 4), r = M.lte(C) && C.lt($);
            v.pop(), v.pop(), v.pop(), v.pushBool(r);
            break;
          }
          case a.OP_RIPEMD160: {
            if (v.length === 0)
              throw new g("INVALID_STACK_OPERATION", J, U);
            v.push(l.digest(v.pop()));
            break;
          }
          case a.OP_SHA1: {
            if (v.length === 0)
              throw new g("INVALID_STACK_OPERATION", J, U);
            v.push(w.digest(v.pop()));
            break;
          }
          case a.OP_SHA256: {
            if (v.length === 0)
              throw new g("INVALID_STACK_OPERATION", J, U);
            v.push(m.digest(v.pop()));
            break;
          }
          case a.OP_HASH160: {
            if (v.length === 0)
              throw new g("INVALID_STACK_OPERATION", J, U);
            v.push(f.digest(v.pop()));
            break;
          }
          case a.OP_HASH256: {
            if (v.length === 0)
              throw new g("INVALID_STACK_OPERATION", J, U);
            v.push(n.digest(v.pop()));
            break;
          }
          case a.OP_CODESEPARATOR: {
            I = U + 1;
            break;
          }
          case a.OP_CHECKSIG:
          case a.OP_CHECKSIGVERIFY: {
            if (!he)
              throw new g("UNKNOWN_ERROR", "No TX passed in.");
            if (v.length < 2)
              throw new g("INVALID_STACK_OPERATION", J, U);
            const C = v.get(-2), M = v.get(-1), $ = this.getSubscript(I);
            (!(Y & T.flags.VERIFY_SIGHASH_FORKID) || !(C[C.length - 1] & T.hashType.SIGHASH_FORKID)) && $.findAndDelete(C), R(C, Y), q(M, Y);
            let r = !1;
            if (C.length > 0) {
              const x = C[C.length - 1], O = he.signatureHash(
                le,
                $,
                ge,
                x,
                Y
              );
              r = Q(O, C.slice(0, -1), M, Y), N.sigchecks += 1, N.sigchecks;
            }
            if (!r && Y & T.flags.VERIFY_NULLFAIL && C.length !== 0)
              throw new g("NULLFAIL", J, U);
            if (v.pop(), v.pop(), v.pushBool(r), J.value === a.OP_CHECKSIGVERIFY) {
              if (!r)
                throw new g("CHECKSIGVERIFY", J, U);
              v.pop();
            }
            break;
          }
          case a.OP_CHECKDATASIG:
          case a.OP_CHECKDATASIGVERIFY: {
            if (v.length < 3)
              throw new g("INVALID_STACK_OPERATION", J, U);
            const C = v.get(-3), M = v.get(-2), $ = v.get(-1);
            ue(C, Y), q($, Y);
            let r = !1;
            if (C.length > 0) {
              const x = m.digest(M);
              r = Q(x, C, $, Y), N.sigchecks += 1, N.sigchecks;
            }
            if (!r && Y & T.flags.VERIFY_NULLFAIL && C.length !== 0)
              throw new g("NULLFAIL", J, U);
            if (v.pop(), v.pop(), v.pop(), v.pushBool(r), J.value === a.OP_CHECKDATASIGVERIFY) {
              if (!r)
                throw new g("CHECKDATASIGVERIFY", J, U);
              v.pop();
            }
            break;
          }
          case a.OP_CHECKMULTISIG:
          case a.OP_CHECKMULTISIGVERIFY: {
            if (!he)
              throw new g("UNKNOWN_ERROR", "No TX passed in.");
            let C = 1, M = 0, $, r;
            if (v.length < C)
              throw new g("INVALID_STACK_OPERATION", J, U);
            let x = v.getInt(-C, B, 4), O = x + 2, K, X;
            if (x < 0 || x > o.MAX_MULTISIG_PUBKEYS)
              throw new g("PUBKEY_COUNT", J, U);
            if (ne += x, ne > o.MAX_SCRIPT_OPS)
              throw new g("OP_COUNT", J, U);
            if (C += 1, $ = C, M = $ + x, K = C, C += x, v.length < M)
              throw new g("INVALID_STACK_OPERATION", J, U);
            let P = v.getInt(-M, B, 4);
            if (P < 0 || P > x)
              throw new g("SIG_COUNT", J, U);
            r = M + 1;
            const V = r + P;
            if (v.length < V)
              throw new g("INVALID_STACK_OPERATION", J, U);
            C += 1, X = C, C += P;
            const re = this.getSubscript(I);
            let ce = !0;
            if (Y & T.flags.VERIFY_SCHNORR_MULTISIG && v.get(-V).length !== 0) {
              if (e(o.MAX_MULTISIG_PUBKEYS < 32), x > 32)
                throw new g("INVALID_BITFIELD_SIZE", J, U);
              const de = Math.floor((x + 7) / 8), pe = v.get(-V);
              if (pe.length !== de)
                throw new g("BITFIELD_SIZE", J, U);
              d = this.bitcalculator(pe, x);
              const se = (1 << x) - 1, Z = H(d);
              if ((d & se) !== d)
                throw new g("BIT_RANGE", J, U);
              if (Z !== P)
                throw new g("INVALID_BIT_COUNT", J, U);
              const ee = $ + x - 1, me = r + P - 1;
              let Ae = 0;
              for (let Oe = 0; Oe < P; Oe++, Ae++) {
                if (d >> Ae === 0)
                  throw new g("INVALID_BIT_RANGE", J, U);
                for (; (d >> Ae & 1) === 0; )
                  Ae++;
                if (Ae >= x)
                  throw new g("PUBKEY_COUNT", J, U);
                const ye = v.get(-me + Oe), _e = v.get(-ee + Ae);
                if (ye) {
                  if (L(ye, Y), q(_e, Y), ye.length > 0) {
                    const ke = ye[ye.length - 1], Me = he.signatureHash(
                      le,
                      re,
                      ge,
                      ke,
                      Y
                    );
                    ce = Q(Me, ye.slice(0, -1), _e, Y), N.sigchecks += 1, N.sigchecks;
                  }
                  for (; C > 1; ) {
                    if (!ce && Y & T.flags.VERIFY_NULLFAIL && O === 0 && v.get(-1).length !== 0)
                      throw new g("NULLFAIL", J, U);
                    O > 0 && (O -= 1), v.pop(), C -= 1;
                  }
                }
              }
              if (d >> Ae !== 0)
                throw new g("INVALID_BIT_COUNT", J, U);
              v.pop(), v.pushBool(ce);
            } else {
              for (let de = 0; de < P; de++) {
                const pe = v.get(-r - de);
                (!(Y & T.flags.VERIFY_SIGHASH_FORKID) || !(pe[pe.length - 1] & T.hashType.SIGHASH_FORKID)) && re.findAndDelete(pe, Y);
              }
              for (; ce && P > 0; ) {
                const de = v.get(-X), pe = v.get(-K);
                if (fe(de, Y), q(pe, Y), de.length > 0) {
                  const se = de[de.length - 1], Z = he.signatureHash(
                    le,
                    re,
                    ge,
                    se,
                    Y
                  );
                  W(Z, de, pe) && (X += 1, P -= 1);
                }
                K += 1, x -= 1, P > x && (ce = !1);
              }
              for (; C > 1; ) {
                if (!ce && Y & T.flags.VERIFY_NULLFAIL && O === 0 && v.get(-1).length !== 0)
                  throw new g("NULLFAIL", J, U);
                O > 0 && (O -= 1), v.pop(), C -= 1;
              }
              if (v.length < 1)
                throw new g("INVALID_STACK_OPERATION", J, U);
              if (v.pop(), v.pushBool(ce), J.value === a.OP_CHECKMULTISIGVERIFY) {
                if (!ce)
                  throw new g("CHECKMULTISIGVERIFY", J, U);
                v.pop();
              }
            }
            break;
          }
          //
          // Byte string operations
          //
          case a.OP_CAT: {
            if (v.length < 2)
              throw new g("INVALID_STACK_OPERATION", J, U);
            const C = v.get(-2), M = v.get(-1);
            if (C.length + M.length > o.MAX_SCRIPT_PUSH)
              throw new g("PUSH_SIZE", J, U);
            v.pop(), v.pop(), v.push(k.concat([C, M]));
            break;
          }
          case a.OP_SPLIT: {
            if (v.length < 2)
              throw new g("INVALID_STACK_OPERATION", J, U);
            const C = v.get(-2), M = v.getInt(-1, B, 4);
            if (M < 0 || M > C.length)
              throw new g("INVALID_SPLIT_RANGE", J, U);
            const $ = C.slice(0, M), r = C.slice(M);
            v.set(-2, $), v.set(-1, r);
            break;
          }
          case a.OP_REVERSEBYTES: {
            if (v.length < 1)
              throw new g("INVALID_STACK_OPERATION", J, U);
            v.get(-1).reverse();
            break;
          }
          //
          // Bitwise logic
          //
          case a.OP_AND:
          case a.OP_OR:
          case a.OP_XOR: {
            if (v.length < 2)
              throw new g("INVALID_STACK_OPERATION", J, U);
            const C = v.get(-2), M = v.get(-1);
            if (C.length !== M.length)
              throw new g("INVALID_OPERAND_SIZE", J, U);
            const $ = k.alloc(C.length);
            switch (J.value) {
              case a.OP_AND:
                for (let r = 0; r < C.length; r++)
                  $[r] = C[r] & M[r];
                break;
              case a.OP_OR:
                for (let r = 0; r < C.length; r++)
                  $[r] = C[r] | M[r];
                break;
              case a.OP_XOR:
                for (let r = 0; r < C.length; r++)
                  $[r] = C[r] ^ M[r];
                break;
            }
            v.pop(), v.pop(), v.push($);
            break;
          }
          //
          // Conversion operations
          //
          case a.OP_NUM2BIN: {
            if (v.length < 2)
              throw new g("INVALID_STACK_OPERATION", J, U);
            const C = v.getInt(-1, B, 4);
            if (C < 0 || C > o.MAX_SCRIPT_PUSH)
              throw new g("PUSH_SIZE", J, U);
            v.pop();
            const M = v.get(-1), $ = S.toMinimal(k.from(M));
            if ($.length > C)
              throw new g("IMPOSSIBLE_ENCODING", J, U);
            if ($.length === C) {
              v.pop(), v.push($);
              break;
            }
            const r = k.alloc(C);
            $.copy(r);
            let x = 0;
            $.length > 0 && (x = $[$.length - 1] & 128, r[$.length - 1] &= 127), r[C - 1] = x, v.pop(), v.push(r);
            break;
          }
          case a.OP_BIN2NUM: {
            if (v.length < 1)
              throw new g("INVALID_STACK_OPERATION", J, U);
            const C = v.get(-1), M = S.toMinimal(k.from(C));
            if (v.pop(), v.push(M), !S.isMinimal(M) || M.length > 4)
              throw new g("INVALID_NUMBER_RANGE", J, U);
            break;
          }
          default:
            throw new g("BAD_OPCODE", J, U);
        }
      }
      if (v.length + z.length > o.MAX_SCRIPT_STACK)
        throw new g("STACK_SIZE");
      if (we.length !== 0)
        throw new g("UNBALANCED_CONDITIONAL");
    }
    /**
     * Remove all matched data elements from
     * a script's code (used to remove signatures
     * before verification). Note that this
     * compares and removes data on the _byte level_.
     * It also reserializes the data to a single
     * script with minimaldata encoding beforehand.
     * A signature will _not_ be removed if it is
     * not minimaldata.
     * @see https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2014-November/006878.html
     * @see https://test.webbtc.com/tx/19aa42fee0fa57c45d3b16488198b27caaacc4ff5794510d0c17f173f05587ff
     * @param {Buffer} data - Data element to match against.
     * @returns {Number} Total.
     */
    findAndDelete(v) {
      const Y = i.fromPush(v);
      if (this.raw.length < Y.getSize())
        return 0;
      let he = !1;
      for (const Ee of this.code) {
        if (Ee.value === -1)
          break;
        if (Ee.equals(Y)) {
          he = !0;
          break;
        }
      }
      if (!he)
        return 0;
      const le = [];
      let ge = 0;
      for (const Ee of this.code) {
        if (Ee.value === -1)
          break;
        if (Ee.equals(Y)) {
          ge += 1;
          continue;
        }
        le.push(Ee);
      }
      return this.code = le, this.compile(), ge;
    }
    /**
     * Find a data element in a script.
     * @param {Buffer} data - Data element to match against.
     * @returns {Number} Index (`-1` if not present).
     */
    indexOf(v) {
      for (let Y = 0; Y < this.code.length; Y++) {
        const he = this.code[Y];
        if (he.value === -1)
          break;
        if (he.data && he.data.equals(v))
          return Y;
      }
      return -1;
    }
    /**
     * Test a script to see if it is likely
     * to be script code (no weird opcodes).
     * @param {Number?} flags - Script standard flags.
     * @returns {Boolean}
     */
    isCode(v) {
      v == null && (v = T.flags.STANDARD_VERIFY_FLAGS);
      for (const Y of this.code) {
        if (Y.value === -1 || Y.isDisabled(v))
          return !1;
        switch (Y.value) {
          case a.OP_RESERVED:
          case a.OP_NOP:
          case a.OP_VER:
          case a.OP_VERIF:
          case a.OP_VERNOTIF:
          case a.OP_RESERVED1:
          case a.OP_RESERVED2:
          case a.OP_NOP1:
            return !1;
        }
        if (Y.value > a.OP_CHECKSEQUENCEVERIFY)
          return !1;
      }
      return !0;
    }
    /**
     * Inject properties from a pay-to-pubkey script.
     * @private
     * @param {Buffer} key
     */
    fromPubkey(v) {
      return e(k.isBuffer(v) && (v.length === 33 || v.length === 65)), this.raw = k.allocUnsafe(1 + v.length + 1), this.raw[0] = v.length, v.copy(this.raw, 1), this.raw[1 + v.length] = a.OP_CHECKSIG, v = this.raw.slice(1, 1 + v.length), this.code.length = 0, this.code.push(i.fromPush(v)), this.code.push(i.fromOp(a.OP_CHECKSIG)), this;
    }
    /**
     * Create a pay-to-pubkey script.
     * @param {Buffer} key
     * @returns {Script}
     */
    static fromPubkey(v) {
      return new this().fromPubkey(v);
    }
    /**
     * Inject properties from a pay-to-pubkeyhash script.
     * @private
     * @param {Buffer} hash
     */
    fromPubkeyhash(v) {
      return e(k.isBuffer(v) && v.length === 20), this.raw = k.allocUnsafe(25), this.raw[0] = a.OP_DUP, this.raw[1] = a.OP_HASH160, this.raw[2] = 20, v.copy(this.raw, 3), this.raw[23] = a.OP_EQUALVERIFY, this.raw[24] = a.OP_CHECKSIG, v = this.raw.slice(3, 23), this.code.length = 0, this.code.push(i.fromOp(a.OP_DUP)), this.code.push(i.fromOp(a.OP_HASH160)), this.code.push(i.fromPush(v)), this.code.push(i.fromOp(a.OP_EQUALVERIFY)), this.code.push(i.fromOp(a.OP_CHECKSIG)), this;
    }
    /**
     * Create a pay-to-pubkeyhash script.
     * @param {Buffer} hash
     * @returns {Script}
     */
    static fromPubkeyhash(v) {
      return new this().fromPubkeyhash(v);
    }
    /**
     * Inject properties from pay-to-multisig script.
     * @private
     * @param {Number} m
     * @param {Number} n
     * @param {Buffer[]} keys
     */
    fromMultisig(v, Y, he) {
      e((v & 255) === v && (Y & 255) === Y), e(Array.isArray(he)), e(he.length === Y, "`n` keys are required for multisig."), e(v >= 1 && v <= Y), e(Y >= 1 && Y <= 15), this.clear(), this.pushSmall(v);
      for (const le of A(he))
        this.pushData(le);
      return this.pushSmall(Y), this.pushOp(a.OP_CHECKMULTISIG), this.compile();
    }
    /**
     * Create a pay-to-multisig script.
     * @param {Number} m
     * @param {Number} n
     * @param {Buffer[]} keys
     * @returns {Script}
     */
    static fromMultisig(v, Y, he) {
      return new this().fromMultisig(v, Y, he);
    }
    /**
     * Inject properties from a pay-to-scripthash script.
     * @private
     * @param {Buffer} hash
     */
    fromScripthash(v) {
      return e(k.isBuffer(v) && v.length === 20), this.raw = k.allocUnsafe(23), this.raw[0] = a.OP_HASH160, this.raw[1] = 20, v.copy(this.raw, 2), this.raw[22] = a.OP_EQUAL, v = this.raw.slice(2, 22), this.code.length = 0, this.code.push(i.fromOp(a.OP_HASH160)), this.code.push(i.fromPush(v)), this.code.push(i.fromOp(a.OP_EQUAL)), this;
    }
    /**
     * Create a pay-to-scripthash script.
     * @param {Buffer} hash
     * @returns {Script}
     */
    static fromScripthash(v) {
      return new this().fromScripthash(v);
    }
    /**
     * Inject properties from a nulldata/opreturn script.
     * @private
     * @param {Buffer} flags
     */
    fromNulldata(v) {
      return e(k.isBuffer(v)), e(v.length <= s.MAX_OP_RETURN, "Nulldata too large."), this.clear(), this.pushOp(a.OP_RETURN), this.pushData(v), this.compile();
    }
    /**
     * Create a nulldata/opreturn script.
     * @param {Buffer} flags
     * @returns {Script}
     */
    static fromNulldata(v) {
      return new this().fromNulldata(v);
    }
    /**
     * Inject properties from an address.
     * @private
     * @param {Address|AddressString} address
     */
    fromAddress(v) {
      if (typeof v == "string" && (v = b.fromString(v)), e(v instanceof b, "Not an address."), v.isPubkeyhash())
        return this.fromPubkeyhash(v.hash);
      if (v.isScripthash())
        return this.fromScripthash(v.hash);
      throw new Error("Unknown address type.");
    }
    /**
     * Create an output script from an address.
     * @param {Address|AddressString} address
     * @returns {Script}
     */
    static fromAddress(v) {
      return new this().fromAddress(v);
    }
    /**
     * Grab and deserialize the redeem script.
     * @returns {Script|null} Redeem script.
     */
    getRedeem() {
      let v = null;
      for (const Y of this.code) {
        if (Y.value === -1 || Y.value > a.OP_16)
          return null;
        v = Y.data;
      }
      return v ? T.fromRaw(v) : null;
    }
    /**
     * Get the standard script type.
     * @returns {ScriptType}
     */
    getType() {
      return this.isPubkey() ? E.PUBKEY : this.isPubkeyhash() ? E.PUBKEYHASH : this.isScripthash() ? E.SCRIPTHASH : this.isMultisig() ? E.MULTISIG : this.isNulldata() ? E.NULLDATA : E.NONSTANDARD;
    }
    /**
     * Test whether a script is of an unknown/non-standard type.
     * @returns {Boolean}
     */
    isUnknown() {
      return this.getType() === E.NONSTANDARD;
    }
    /**
     * Test whether the script is standard by policy standards.
     * @returns {Boolean}
     */
    isStandard() {
      const [v, Y] = this.getMultisig();
      return v !== -1 ? !(Y < 1 || Y > 3 || v < 1 || v > Y) : this.isNulldata() ? this.raw.length <= s.MAX_OP_RETURN_BYTES : this.getType() !== E.NONSTANDARD;
    }
    /**
     * Calculate the size of the script
     * excluding the varint size bytes.
     * @returns {Number}
     */
    getSize() {
      return this.raw.length;
    }
    /**
     * Calculate the size of the script
     * including the varint size bytes.
     * @returns {Number}
     */
    getVarSize() {
      return j.sizeVarBytes(this.raw);
    }
    /**
     * "Guess" the address of the input script.
     * This method is not 100% reliable.
     * @returns {Address|null}
     */
    getInputAddress() {
      return b.fromInputScript(this);
    }
    /**
     * Get the address of the script if present. Note that
     * pubkey and multisig scripts will be treated as though
     * they are pubkeyhash and scripthashes respectively.
     * @returns {Address|null}
     */
    getAddress() {
      return b.fromScript(this);
    }
    /**
     * Get the hash160 of the raw script.
     * @param {String?} enc
     * @returns {Hash}
     */
    hash160(v) {
      let Y = f.digest(this.toRaw());
      return v === "hex" && (Y = Y.toString("hex")), Y;
    }
    /**
     * Get the sha256 of the raw script.
     * @param {String?} enc
     * @returns {Hash}
     */
    sha256(v) {
      let Y = m.digest(this.toRaw());
      return v === "hex" && (Y = Y.toString("hex")), Y;
    }
    /**
     * Test whether the output script is pay-to-pubkey.
     * @param {Boolean} [minimal=false] - Minimaldata only.
     * @returns {Boolean}
     */
    isPubkey(v) {
      if (v)
        return this.raw.length >= 35 && (this.raw[0] === 33 || this.raw[0] === 65) && this.raw[0] + 2 === this.raw.length && this.raw[this.raw.length - 1] === a.OP_CHECKSIG;
      if (this.code.length !== 2)
        return !1;
      const Y = this.getLength(0);
      return (Y === 33 || Y === 65) && this.getOp(1) === a.OP_CHECKSIG;
    }
    /**
     * Get P2PK key if present.
     * @param {Boolean} [minimal=false] - Minimaldata only.
     * @returns {Buffer|null}
     */
    getPubkey(v) {
      return this.isPubkey(v) ? v ? this.raw.slice(1, 1 + this.raw[0]) : this.getData(0) : null;
    }
    /**
     * Test whether the output script is pay-to-pubkeyhash.
     * @param {Boolean} [minimal=false] - Minimaldata only.
     * @returns {Boolean}
     */
    isPubkeyhash(v) {
      return v || this.raw.length === 25 ? this.raw.length === 25 && this.raw[0] === a.OP_DUP && this.raw[1] === a.OP_HASH160 && this.raw[2] === 20 && this.raw[23] === a.OP_EQUALVERIFY && this.raw[24] === a.OP_CHECKSIG : this.code.length !== 5 ? !1 : this.getOp(0) === a.OP_DUP && this.getOp(1) === a.OP_HASH160 && this.getLength(2) === 20 && this.getOp(3) === a.OP_EQUALVERIFY && this.getOp(4) === a.OP_CHECKSIG;
    }
    /**
     * Get P2PKH hash if present.
     * @param {Boolean} [minimal=false] - Minimaldata only.
     * @returns {Buffer|null}
     */
    getPubkeyhash(v) {
      return this.isPubkeyhash(v) ? v ? this.raw.slice(3, 23) : this.getData(2) : null;
    }
    /**
       * Test whether the output script is pay-to-multisig.
       * @param {Boolean} [minimal=true] - Minimaldata only.
       * @returns {Boolean}
       */
    isMultisig(v) {
      if (this.code.length < 4 || this.code.length > 19 || this.getOp(-1) !== a.OP_CHECKMULTISIG)
        return !1;
      const Y = this.getSmall(0);
      if (Y < 1)
        return !1;
      const he = this.getSmall(-2);
      if (he < 1 || Y > he || this.code.length !== he + 3)
        return !1;
      for (let le = 1; le < he + 1; le++) {
        const ge = this.code[le], Ee = ge.toLength();
        if (Ee !== 33 && Ee !== 65 || v && !ge.isMinimal())
          return !1;
      }
      return !0;
    }
    /**
     * Get multisig m and n values if present.
     * @param {Boolean} [minimal=false] - Minimaldata only.
     * @returns {Array} [m, n]
     */
    getMultisig(v) {
      return this.isMultisig(v) ? [this.getSmall(0), this.getSmall(-2)] : [-1, -1];
    }
    /**
     * Test whether the output script is pay-to-scripthash. Note that
     * bitcoin itself requires scripthashes to be in strict minimaldata
     * encoding. Using `OP_HASH160 OP_PUSHDATA1 [hash] OP_EQUAL` will
     * _not_ be recognized as a scripthash.
     * @returns {Boolean}
     */
    isScripthash() {
      return this.raw.length === 23 && this.raw[0] === a.OP_HASH160 && this.raw[1] === 20 && this.raw[22] === a.OP_EQUAL;
    }
    /**
     * Get P2SH hash if present.
     * @returns {Buffer|null}
     */
    getScripthash() {
      return this.isScripthash() ? this.getData(1) : null;
    }
    /**
     * Test whether the output script is nulldata/opreturn.
     * @param {Boolean} [minimal=false] - Minimaldata only.
     * @returns {Boolean}
     */
    isNulldata(v) {
      if (this.code.length === 0 || this.getOp(0) !== a.OP_RETURN)
        return !1;
      if (this.code.length === 1)
        return !0;
      if (v && this.raw.length > s.MAX_OP_RETURN_BYTES)
        return !1;
      for (let Y = 1; Y < this.code.length; Y++) {
        const he = this.code[Y];
        if (he.value === -1 || he.value > a.OP_16 || v && !he.isMinimal())
          return !1;
      }
      return !0;
    }
    /**
     * Get OP_RETURN data if present.
     * @param {Boolean} [minimal=false] - Minimaldata only.
     * @returns {Buffer|null}
     */
    getNulldata(v) {
      if (!this.isNulldata(v))
        return null;
      for (let Y = 1; Y < this.code.length; Y++) {
        const le = this.code[Y].toPush();
        if (le)
          return le;
      }
      return G;
    }
    /**
     * Test whether the output script is a witness program.
     * Note that this will return true even for malformed
     * witness v0 programs.
     * @returns {Boolean}
     */
    isProgram() {
      return !(this.raw.length < 4 || this.raw.length > 42 || this.raw[0] !== a.OP_0 && (this.raw[0] < a.OP_1 || this.raw[0] > a.OP_16) || this.raw[1] + 2 !== this.raw.length);
    }
    /**
     * Test whether the output script is unspendable.
     * @returns {Boolean}
     */
    isUnspendable() {
      return this.raw.length > o.MAX_SCRIPT_SIZE ? !0 : this.raw.length > 0 && this.raw[0] === a.OP_RETURN;
    }
    /**
     * "Guess" the type of the input script.
     * This method is not 100% reliable.
     * @returns {ScriptType}
     */
    getInputType() {
      return this.isPubkeyInput() ? E.PUBKEY : this.isPubkeyhashInput() ? E.PUBKEYHASH : this.isScripthashInput() ? E.SCRIPTHASH : this.isMultisigInput() ? E.MULTISIG : E.NONSTANDARD;
    }
    /**
     * "Guess" whether the input script is an unknown/non-standard type.
     * This method is not 100% reliable.
     * @returns {Boolean}
     */
    isUnknownInput() {
      return this.getInputType() === E.NONSTANDARD;
    }
    /**
     * "Guess" whether the input script is pay-to-pubkey.
     * This method is not 100% reliable.
     * @returns {Boolean}
     */
    isPubkeyInput() {
      if (this.code.length !== 1)
        return !1;
      const v = this.getLength(0);
      return v >= 9 && v <= 73;
    }
    /**
     * Get P2PK signature if present.
     * @returns {Buffer|null}
     */
    getPubkeyInput() {
      return this.isPubkeyInput() ? this.getData(0) : null;
    }
    /**
     * "Guess" whether the input script is pay-to-pubkeyhash.
     * This method is not 100% reliable.
     * @returns {Boolean}
     */
    isPubkeyhashInput() {
      if (this.code.length !== 2)
        return !1;
      const v = this.getLength(0), Y = this.getLength(1);
      return v >= 9 && v <= 73 && (Y === 33 || Y === 65);
    }
    /**
     * Get P2PKH signature and key if present.
     * @returns {Array} [sig, key]
     */
    getPubkeyhashInput() {
      return this.isPubkeyhashInput() ? [this.getData(0), this.getData(1)] : [null, null];
    }
    /**
     * "Guess" whether the input script is pay-to-multisig.
     * This method is not 100% reliable.
     * @returns {Boolean}
     */
    isMultisigInput() {
      if (this.code.length < 2 || this.getOp(0) !== a.OP_0 || this.getOp(1) > a.OP_PUSHDATA4 || this.isScripthashInput())
        return !1;
      for (let v = 1; v < this.code.length; v++) {
        const Y = this.getLength(v);
        if (Y < 9 || Y > 73)
          return !1;
      }
      return !0;
    }
    /**
     * Get multisig signatures if present.
     * @returns {Buffer[]|null}
     */
    getMultisigInput() {
      if (!this.isMultisigInput())
        return null;
      const v = [];
      for (let Y = 1; Y < this.code.length; Y++)
        v.push(this.getData(Y));
      return v;
    }
    /**
     * "Guess" whether the input script is pay-to-scripthash.
     * This method is not 100% reliable.
     * @returns {Boolean}
     */
    isScripthashInput() {
      if (this.code.length < 1)
        return !1;
      const v = this.getData(-1);
      if (!v || v.length === 0 || y.isDERSignatureEncoding(v.slice(0, -1)) || y.isKeyEncoding(v))
        return !1;
      const Y = T.fromRaw(v);
      return !(!Y.isCode() || Y.isUnspendable() || !this.isPushOnly());
    }
    /**
     * Get P2SH redeem script if present.
     * @returns {Buffer|null}
     */
    getScripthashInput() {
      return this.isScripthashInput() ? this.getData(-1) : null;
    }
    /**
     * Get coinbase height.
     * @returns {Number} `-1` if not present.
     */
    getCoinbaseHeight() {
      return T.getCoinbaseHeight(this.raw);
    }
    /**
     * Get coinbase height.
     * @param {Buffer} raw - Raw script.
     * @returns {Number} `-1` if not present.
     */
    static getCoinbaseHeight(v) {
      if (v.length === 0)
        return -1;
      if (v[0] >= a.OP_1 && v[0] <= a.OP_16)
        return v[0] - 80;
      if (v[0] > 6)
        return -1;
      const Y = i.fromRaw(v), he = Y.toNum();
      return he ? he.isNeg() || !Y.equals(i.fromNum(he)) ? -1 : he.toDouble() : 1;
    }
    /**
     * Test the script against a bloom filter.
     * @param {Bloom} filter
     * @returns {Boolean}
     */
    test(v) {
      for (const Y of this.code) {
        if (Y.value === -1)
          break;
        if (!(!Y.data || Y.data.length === 0) && v.test(Y.data))
          return !0;
      }
      return !1;
    }
    /**
     * Test the script to see if it contains only push ops.
     * Push ops are: OP_1NEGATE, OP_0-OP_16 and all PUSHDATAs.
     * @returns {Boolean}
     */
    isPushOnly() {
      for (const v of this.code)
        if (v.value === -1 || v.value > a.OP_16)
          return !1;
      return !0;
    }
    /**
     * Count the sigops in the script.
     * @param {Boolean} accurate - Whether to enable accurate counting. This will
     * take into account the `n` value for OP_CHECKMULTISIG(VERIFY).
     * @returns {Number} sigop count
     */
    getSigops(v, Y) {
      if (Y & T.flags.VERIFY_ZERO_SIGOPS)
        return 0;
      let he = 0, le = -1;
      for (const ge of this.code) {
        if (ge.value === -1)
          break;
        switch (ge.value) {
          case a.OP_CHECKSIG:
          case a.OP_CHECKSIGVERIFY:
            he += 1;
            break;
          case a.OP_CHECKSDATAIG:
          case a.OP_CHECKDATASIGVERIFY:
            Y & T.flags.VERIFY_CHECKDATASIG && (he += 1);
            break;
          case a.OP_CHECKMULTISIG:
          case a.OP_CHECKMULTISIGVERIFY:
            v && le >= a.OP_1 && le <= a.OP_16 ? he += le - 80 : he += o.MAX_MULTISIG_PUBKEYS;
            break;
        }
        le = ge.value;
      }
      return he;
    }
    /**
     * Count the sigops in the script, taking into account redeem scripts.
     * @param {Script} input - Input script, needed for access to redeem script.
     * @param {VerifyFlags} flags
     * @returns {Number} sigop count
     */
    getScripthashSigops(v, Y) {
      if (!this.isScripthash())
        return this.getSigops(!0, Y);
      const he = v.getRedeem();
      return he ? he.getSigops(!0, Y) : 0;
    }
    /*
     * Mutation
     */
    get(v) {
      return v < 0 && (v += this.code.length), v < 0 || v >= this.code.length ? null : this.code[v];
    }
    pop() {
      return this.code.pop() || null;
    }
    shift() {
      return this.code.shift() || null;
    }
    remove(v) {
      if (v < 0 && (v += this.code.length), v < 0 || v >= this.code.length)
        return null;
      const Y = this.code.splice(v, 1);
      return Y.length === 0 ? null : Y[0];
    }
    set(v, Y) {
      return v < 0 && (v += this.code.length), e(i.isOpcode(Y)), e(v >= 0 && v <= this.code.length), this.code[v] = Y, this;
    }
    push(v) {
      return e(i.isOpcode(v)), this.code.push(v), this;
    }
    unshift(v) {
      return e(i.isOpcode(v)), this.code.unshift(v), this;
    }
    insert(v, Y) {
      return v < 0 && (v += this.code.length), e(i.isOpcode(Y)), e(v >= 0 && v <= this.code.length), this.code.splice(v, 0, Y), this;
    }
    /*
     * Op
     */
    getOp(v) {
      const Y = this.get(v);
      return Y ? Y.value : -1;
    }
    popOp() {
      const v = this.pop();
      return v ? v.value : -1;
    }
    shiftOp() {
      const v = this.shift();
      return v ? v.value : -1;
    }
    removeOp(v) {
      const Y = this.remove(v);
      return Y ? Y.value : -1;
    }
    setOp(v, Y) {
      return this.set(v, i.fromOp(Y));
    }
    pushOp(v) {
      return this.push(i.fromOp(v));
    }
    unshiftOp(v) {
      return this.unshift(i.fromOp(v));
    }
    insertOp(v, Y) {
      return this.insert(v, i.fromOp(Y));
    }
    /*
     * Data
     */
    getData(v) {
      const Y = this.get(v);
      return Y ? Y.data : null;
    }
    popData() {
      const v = this.pop();
      return v ? v.data : null;
    }
    shiftData() {
      const v = this.shift();
      return v ? v.data : null;
    }
    removeData(v) {
      const Y = this.remove(v);
      return Y ? Y.data : null;
    }
    setData(v, Y) {
      return this.set(v, i.fromData(Y));
    }
    pushData(v) {
      return this.push(i.fromData(v));
    }
    unshiftData(v) {
      return this.unshift(i.fromData(v));
    }
    insertData(v, Y) {
      return this.insert(v, i.fromData(Y));
    }
    /*
     * Length
     */
    getLength(v) {
      const Y = this.get(v);
      return Y ? Y.toLength() : -1;
    }
    /*
     * Push
     */
    getPush(v) {
      const Y = this.get(v);
      return Y ? Y.toPush() : null;
    }
    popPush() {
      const v = this.pop();
      return v ? v.toPush() : null;
    }
    shiftPush() {
      const v = this.shift();
      return v ? v.toPush() : null;
    }
    removePush(v) {
      const Y = this.remove(v);
      return Y ? Y.toPush() : null;
    }
    setPush(v, Y) {
      return this.set(v, i.fromPush(Y));
    }
    pushPush(v) {
      return this.push(i.fromPush(v));
    }
    unshiftPush(v) {
      return this.unshift(i.fromPush(v));
    }
    insertPush(v, Y) {
      return this.insert(v, i.fromPush(Y));
    }
    /*
     * String
     */
    getString(v, Y) {
      const he = this.get(v);
      return he ? he.toString(Y) : null;
    }
    popString(v) {
      const Y = this.pop();
      return Y ? Y.toString(v) : null;
    }
    shiftString(v) {
      const Y = this.shift();
      return Y ? Y.toString(v) : null;
    }
    removeString(v, Y) {
      const he = this.remove(v);
      return he ? he.toString(Y) : null;
    }
    setString(v, Y, he) {
      return this.set(v, i.fromString(Y, he));
    }
    pushString(v, Y) {
      return this.push(i.fromString(v, Y));
    }
    unshiftString(v, Y) {
      return this.unshift(i.fromString(v, Y));
    }
    insertString(v, Y, he) {
      return this.insert(v, i.fromString(Y, he));
    }
    /*
     * Small
     */
    getSmall(v) {
      const Y = this.get(v);
      return Y ? Y.toSmall() : -1;
    }
    popSmall() {
      const v = this.pop();
      return v ? v.toSmall() : -1;
    }
    shiftSmall() {
      const v = this.shift();
      return v ? v.toSmall() : -1;
    }
    removeSmall(v) {
      const Y = this.remove(v);
      return Y ? Y.toSmall() : -1;
    }
    setSmall(v, Y) {
      return this.set(v, i.fromSmall(Y));
    }
    pushSmall(v) {
      return this.push(i.fromSmall(v));
    }
    unshiftSmall(v) {
      return this.unshift(i.fromSmall(v));
    }
    insertSmall(v, Y) {
      return this.insert(v, i.fromSmall(Y));
    }
    /*
     * Num
     */
    getNum(v, Y, he) {
      const le = this.get(v);
      return le ? le.toNum(Y, he) : null;
    }
    popNum(v, Y) {
      const he = this.pop();
      return he ? he.toNum(v, Y) : null;
    }
    shiftNum(v, Y) {
      const he = this.shift();
      return he ? he.toNum(v, Y) : null;
    }
    removeNum(v, Y, he) {
      const le = this.remove(v);
      return le ? le.toNum(Y, he) : null;
    }
    setNum(v, Y) {
      return this.set(v, i.fromNum(Y));
    }
    pushNum(v) {
      return this.push(i.fromNum(v));
    }
    unshiftNum(v) {
      return this.unshift(i.fromNum(v));
    }
    insertNum(v, Y) {
      return this.insert(v, i.fromNum(Y));
    }
    /*
     * Int
     */
    getInt(v, Y, he) {
      const le = this.get(v);
      return le ? le.toInt(Y, he) : -1;
    }
    popInt(v, Y) {
      const he = this.pop();
      return he ? he.toInt(v, Y) : -1;
    }
    shiftInt(v, Y) {
      const he = this.shift();
      return he ? he.toInt(v, Y) : -1;
    }
    removeInt(v, Y, he) {
      const le = this.remove(v);
      return le ? le.toInt(Y, he) : -1;
    }
    setInt(v, Y) {
      return this.set(v, i.fromInt(Y));
    }
    pushInt(v) {
      return this.push(i.fromInt(v));
    }
    unshiftInt(v) {
      return this.unshift(i.fromInt(v));
    }
    insertInt(v, Y) {
      return this.insert(v, i.fromInt(Y));
    }
    /*
     * Bool
     */
    getBool(v) {
      const Y = this.get(v);
      return Y ? Y.toBool() : !1;
    }
    popBool() {
      const v = this.pop();
      return v ? v.toBool() : !1;
    }
    shiftBool() {
      const v = this.shift();
      return v ? v.toBool() : !1;
    }
    removeBool(v) {
      const Y = this.remove(v);
      return Y ? Y.toBool() : !1;
    }
    setBool(v, Y) {
      return this.set(v, i.fromBool(Y));
    }
    pushBool(v) {
      return this.push(i.fromBool(v));
    }
    unshiftBool(v) {
      return this.unshift(i.fromBool(v));
    }
    insertBool(v, Y) {
      return this.insert(v, i.fromBool(Y));
    }
    /*
     * Symbol
     */
    getSym(v) {
      const Y = this.get(v);
      return Y ? Y.toSymbol() : null;
    }
    popSym() {
      const v = this.pop();
      return v ? v.toSymbol() : null;
    }
    shiftSym() {
      const v = this.shift();
      return v ? v.toSymbol() : null;
    }
    removeSym(v) {
      const Y = this.remove(v);
      return Y ? Y.toSymbol() : null;
    }
    setSym(v, Y) {
      return this.set(v, i.fromSymbol(Y));
    }
    pushSym(v) {
      return this.push(i.fromSymbol(v));
    }
    unshiftSym(v) {
      return this.unshift(i.fromSymbol(v));
    }
    insertSym(v, Y) {
      return this.insert(v, i.fromSymbol(Y));
    }
    /**
     * Inject properties from bitcoind test string.
     * @private
     * @param {String} items - Script string.
     * @throws Parse error.
     */
    fromString(v) {
      if (e(typeof v == "string"), v = v.trim(), v.length === 0)
        return this;
      const Y = v.split(/\s+/), he = c.write();
      for (const le of Y) {
        let ge = le;
        ge.charCodeAt(0) & 32 && (ge = ge.toUpperCase()), /^OP_/.test(ge) || (ge = `OP_${ge}`);
        const Ee = a[ge];
        if (Ee == null) {
          if (le[0] === "'") {
            e(le[le.length - 1] === "'", "Invalid string.");
            const I = le.slice(1, -1), ne = i.fromString(I);
            he.writeBytes(ne.toRaw());
            continue;
          }
          if (/^-?\d+$/.test(le)) {
            const I = S.fromString(le, 10), ne = i.fromNum(I);
            he.writeBytes(ne.toRaw());
            continue;
          }
          e(le.indexOf("0x") === 0, "Unknown opcode.");
          const we = le.substring(2), z = k.from(we, "hex");
          e(z.length === we.length / 2, "Invalid hex string."), he.writeBytes(z);
          continue;
        }
        he.writeU8(Ee);
      }
      return this.fromRaw(he.render());
    }
    /**
     * Parse a bitcoind test script
     * string into a script object.
     * @param {String} items - Script string.
     * @returns {Script}
     * @throws Parse error.
     */
    static fromString(v) {
      return new this().fromString(v);
    }
    /**
     * Verify an input and output script, and a witness if present.
     * @param {Script} input
     * @param {Null} witness
     * @param {Script} output
     * @param {TX} tx
     * @param {Number} index
     * @param {Amount} value
     * @param {VerifyFlags} flags
     * @param {Number?} sigchecks
     * @throws {ScriptError}
     */
    static verify(v, Y, he, le, ge, Ee, we, z) {
      if (we == null && (we = T.flags.STANDARD_VERIFY_FLAGS), we & T.flags.VERIFY_SIGPUSHONLY && !v.isPushOnly())
        throw new g("SIG_PUSHONLY");
      we & T.flags.VERIFY_SIGHASH_FORKID && (we |= T.flags.VERIFY_STRICTENC);
      let I = new p();
      v.execute(I, we, le, ge, Ee, N.sigchecks);
      let ne;
      if (we & T.flags.VERIFY_P2SH && (ne = I.clone()), he.execute(I, we, le, ge, Ee, N.sigchecks), I.length === 0 || !I.getBool(-1))
        throw new g("EVAL_FALSE");
      if (we & T.flags.VERIFY_P2SH && he.isScripthash()) {
        if (!v.isPushOnly())
          throw new g("SIG_PUSHONLY");
        if (I = ne, I.length === 0)
          throw new g("EVAL_FALSE");
        const t = I.pop(), d = T.fromRaw(t);
        if ((we & T.flags.VERIFY_DISALLOW_SEGWIT_RECOVERY) === 0 && I.length === 0 && d.isProgram()) {
          we & T.flags.REPORT_SIGCHECKS || (N.sigchecks = 0);
          return;
        }
        if (d.execute(I, we, le, ge, Ee, 0, N.sigchecks), I.length === 0 || !I.getBool(-1))
          throw new g("EVAL_FALSE");
      }
      if (we & T.flags.VERIFY_CLEANSTACK && (e((we & T.flags.VERIFY_P2SH) !== 0), I.length !== 1))
        throw new g("CLEANSTACK");
      if (we & T.flags.VERIFY_INPUT_SIGCHECKS && v.getSize() < N.sigchecks * 43 - 60)
        throw new g("INPUT_SIGCHECKS");
      we & T.flags.REPORT_SIGCHECKS || (N.sigchecks = 0);
    }
    /**
     * Inject properties from buffer reader.
     * @private
     * @param {BufferReader} br
     */
    fromReader(v) {
      return this.fromRaw(v.readVarBytes());
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer}
     */
    fromRaw(v) {
      const Y = c.read(v);
      for (this.raw = v; Y.left(); )
        this.code.push(i.fromReader(Y));
      return this;
    }
    /**
     * Create a script from buffer reader.
     * @param {BufferReader} br
     * @param {String?} enc - Either `"hex"` or `null`.
     * @returns {Script}
     */
    static fromReader(v) {
      return new this().fromReader(v);
    }
    /**
     * Create a script from a serialized buffer.
     * @param {Buffer|String} data - Serialized script.
     * @param {String?} enc - Either `"hex"` or `null`.
     * @returns {Script}
     */
    static fromRaw(v, Y) {
      return typeof v == "string" && (v = k.from(v, Y)), new this().fromRaw(v);
    }
    /**
     * Test whether an object a Script.
     * @param {Object} obj
     * @returns {Boolean}
     */
    static isScript(v) {
      return v instanceof T;
    }
  }
  T.opcodes = y.opcodes, T.opcodesByVal = y.opcodesByVal, T.flags = y.flags, T.hashType = y.hashType, T.hashTypeByVal = y.hashTypeByVal, T.types = y.types, T.typesByVal = y.typesByVal;
  function A(oe) {
    return oe.slice().sort((v, Y) => v.compare(Y));
  }
  function q(oe, v) {
    if (e(k.isBuffer(oe)), e(typeof v == "number"), v & T.flags.VERIFY_STRICTENC && !y.isKeyEncoding(oe))
      throw new g("PUBKEYTYPE");
    if (v & T.flags.VERIFY_COMPRESSED_PUBKEYTYPE && !y.isCompressedEncoding(oe))
      throw new g("NONCOMPRESSED_PUBKEY");
    return !0;
  }
  function _(oe, v) {
    if (e(k.isBuffer(oe)), e(typeof v == "number"), y.isSchnorr(oe))
      throw new g("SIG_BADLENGTH");
    if ((v & T.flags.VERIFY_DERSIG || v & T.flags.VERIFY_LOW_S || v & T.flags.VERIFY_STRICTENC) && !y.isDERSignatureEncoding(oe))
      throw new g("SIG_DER");
    if (v & T.flags.VERIFY_LOW_S && !y.isLowDER(oe))
      throw new g("SIG_HIGH_S");
    return !0;
  }
  function F(oe, v) {
    if (e(k.isBuffer(oe)), e(typeof v == "number"), v & T.flags.VERIFY_STRICTENC) {
      if (!y.isHashType(oe))
        throw new g("SIG_HASHTYPE");
      const Y = oe[oe.length - 1] & T.hashType.SIGHASH_FORKID, he = v & T.flags.VERIFY_SIGHASH_FORKID;
      if (!he && Y)
        throw new g("ILLEGAL_FORKID");
      if (he && !Y)
        throw new g("MUST_USE_FORKID");
    }
    return !0;
  }
  function R(oe, v) {
    return e(k.isBuffer(oe)), e(typeof v == "number"), oe.length === 0 ? !0 : (ae(oe.slice(0, -1), v), F(oe, v));
  }
  function L(oe, v) {
    return e(k.isBuffer(oe)), e(typeof v == "number"), oe.length === 0 ? !0 : D(oe.slice(0, -1), v) ? F(oe, v) : _(oe.slice(0, -1), v);
  }
  function fe(oe, v) {
    return e(k.isBuffer(oe)), e(typeof v == "number"), oe.length === 0 ? !0 : (_(oe.slice(0, -1), v), F(oe, v));
  }
  function ue(oe, v) {
    return e(k.isBuffer(oe)), e(typeof v == "number"), oe.length === 0 ? !0 : ae(oe.slice(0, oe.length), v);
  }
  function ae(oe, v) {
    return e(k.isBuffer(oe)), e(typeof v == "number"), y.isSchnorr(oe) ? !0 : _(oe, v);
  }
  function D(oe, v) {
    if (e(k.isBuffer(oe)), e(typeof v == "number"), y.isSchnorr(oe))
      return !0;
    throw new g("SIG_NONSCHNORR");
  }
  function Q(oe, v, Y, he) {
    e(k.isBuffer(oe)), e(k.isBuffer(v)), e(k.isBuffer(Y)), e(typeof he == "number");
    let le = !1;
    return v.length === 64 ? le = u.schnorrVerify(oe, v, Y, he) : le = u.verifyDER(oe, v, Y, he), le;
  }
  function W(oe, v, Y) {
    return u.verifyDER(oe, v.slice(0, -1), Y);
  }
  return Mu = T, Mu;
}
var Nu, E3;
function Io() {
  if (E3) return Nu;
  E3 = 1;
  const e = Xe(), c = At(), { U64: l } = ul();
  Lt();
  const w = Cr();
  Gi();
  const m = {
    GENESIS: 0,
    MINT: 1,
    SEND: 2,
    BATON: 3,
    BURN: 4
  };
  class f {
    /**
     * Create a record of SLP data for a given coin.
     * @param {Buffer?} hash the output hash of the coin
     * @param {Number?} vout the output index of the coin
     * @param {Buffer?} tokenId 32 byte txid
     * @param {Buffer?} tokenIndex 4 byte unsigned integer (index of tx hash in db)
     * @param {Buffer} value big endian value of token base units
     * @param {String} type GENESIS | MINT | SEND | BURN | BATON
     * @param {Number?} version token type
     * @constructor
     */
    constructor(s = {}) {
      this.hash = s.hash, this.vout = s.vout, this.tokenId = s.tokenId, this.tokenIndex = s.tokenIndex, this.value = s.value, this.type = s.type, this.version = s.version;
    }
    /**
     * Get the value as 64 bit big-endian buffer
     * @private
     * @returns {Buffer}
     */
    getValueUInt64BE() {
      e(this.value.length <= 8, "value buffer must be 8 bytes or less");
      const s = k.alloc(8 - this.value.length);
      return k.concat([s, this.value]);
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     */
    fromDbData(s) {
      const i = c.read(s);
      this.tokenIndex = i.readBytes(4);
      const p = i.readVarBytes(), g = k.alloc(8 - p.length);
      this.value = k.concat([g, p]), this.type = Object.keys(m)[i.readU8()];
      try {
        this.version = i.readU8();
      } catch (S) {
        if (S.code === "ERR_ENCODING")
          this.version = 1;
        else throw S;
      }
      return e(this.version >= 1 && this.version <= 2), e(Object.keys(m).includes(this.type)), this;
    }
    /**
     * Instantiate SLP record from serialized data.
     * @param {Buffer} data
     * @returns {SlpCoinRecord}
     */
    static fromDbData(s) {
      return new this().fromDbData(s);
    }
    /**
     * Serialize the SLP record.
     * @returns {Buffer}
     */
    toDbData() {
      e(this.tokenIndex, "Missing tokenIndex"), e(this.tokenIndex.length == 4, "tokenId must be a sha256 hash"), e(this.value.byteLength, "Token amount must be a buffer"), e(Object.keys(m).includes(this.type), "Type must be GENESIS | MINT | SEND | BATON | BURN");
      for (let i = 0; i < this.value.length; i++)
        if (this.value[i] != 0) {
          this.value = this.value.slice(i);
          break;
        }
      const s = c.write();
      return s.writeBytes(this.tokenIndex), s.writeVarBytes(this.value), s.writeU8(m[this.type]), s.writeU8(this.version || 1), s.render();
    }
    /**
     * Convert object to JSON.
     * @returns {Object}
     */
    getJSON() {
      return e(this.tokenId, "tokenId must be defined"), {
        hash: this.hash ? k.from(this.hash).reverse().toString("hex") : void 0,
        vout: this.vout,
        tokenId: this.tokenId.toString("hex"),
        value: l.fromBE(this.value).toString(10),
        type: this.type,
        version: this.version || 1
      };
    }
    /**
     * Convert from JSON to Object.
     * @param {Object} json
     * @returns {SlpCoinRecord}
     */
    fromJSON(s) {
      return this.hash = k.from(s.hash, "hex").reverse(), this.vout = s.vout, this.tokenId = k.from(s.tokenId, "hex"), this.value = l.fromString(s.value).toBE(k), this.type = s.type, this.version = s.version || 1, this;
    }
    /**
     * Convert from JSON to Object.
     * @param {Object} json
     * @returns {TokenRecord}
     */
    static fromJSON(s) {
      return new this().fromJSON(s);
    }
  }
  class n {
    /**
     * Create a token record.
     * @constructor
     * @param {Buffer?} tokenId
     * @param {Buffer?} tokenIndex
     * @param {String?} ticker
     * @param {String?} name
     * @param {String?} uri
     * @param {String?} hash
     * @param {Number} decimals
     * @param {Number?} version
     * @param {Buffer?} vaultScriptHash
     */
    constructor(s = {}) {
      this.tokenId = s.tokenId, this.tokenIndex = s.tokenIndex, this.ticker = s.ticker || "", this.name = s.name || "", this.uri = s.uri || "", this.hash = s.hash || "", this.decimals = s.decimals, this.version = s.version, this.version === 2 && (this.vaultScriptHash = s.vaultScriptHash);
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     */
    fromDbData(s) {
      const i = c.read(s);
      this.tokenId = i.readHash(), this.ticker = i.readVarString("utf8"), this.name = i.readVarString("utf8"), this.uri = i.readVarString("utf8"), this.hash = i.readVarString("hex"), this.decimals = i.readU8();
      try {
        this.version = i.readU8();
      } catch (p) {
        if (p.code === "ERR_ENCODING")
          this.version = 1;
        else throw p;
      }
      return this.version === 2 && (this.vaultScriptHash = i.readBytes(20)), e(this.version >= 1 && this.version <= 2), this;
    }
    /**
     * Instantiate token record from serialized data.
     * @param {Buffer} data
     * @returns {TokenRecord}
     */
    static fromDbData(s) {
      return new this().fromDbData(s);
    }
    /**
     * Serialize the token record.
     * @returns {Buffer}
     */
    toDbData() {
      const s = c.write(), i = c.encoding;
      return s.writeHash(this.tokenId), s.writeVarString(this.ticker, "utf8"), this.ticker.length === 0 && (s.offset += i.sizeVarint(0)), s.writeVarString(this.name, "utf8"), this.name.length === 0 && (s.offset += i.sizeVarint(0)), s.writeVarString(this.uri, "utf8"), this.uri.length === 0 && (s.offset += i.sizeVarint(0)), s.writeVarString(this.hash, "hex"), this.hash.length === 0 && (s.offset += i.sizeVarint(0)), s.writeU8(this.decimals), s.writeU8(this.version || 1), this.version === 2 && s.writeBytes(this.vaultScriptHash), s.render();
    }
    /**
     * Convert object to JSON.
     * @returns {Object}
     */
    getJSON() {
      e(this.tokenId, "tokenId must be defined");
      const s = {
        tokenId: this.tokenId.toString("hex"),
        ticker: this.ticker,
        name: this.name,
        uri: this.uri,
        hash: this.hash,
        decimals: this.decimals,
        version: this.version || 1
      };
      return s.version === 2 && this.vaultScriptHash && (s.vaultScriptHash = this.vaultScriptHash.toString("hex")), s;
    }
    /**
     * Convert from JSON to Object.
     * @param {Object} json
     * @returns {SlpCoinRecord}
     */
    fromJSON(s) {
      return this.tokenId = k.from(s.tokenId, "hex"), this.ticker = s.ticker, this.name = s.name, this.uri = s.uri, this.hash = s.hash, this.decimals = s.decimals, this.version = s.version, s.version === 2 && s.vaultScriptHash && (this.vaultScriptHash = k.from(s.vaultScriptHash, "hex")), this;
    }
    /**
     * Convert from JSON to Object.
     * @param {Object} json
     * @returns {TokenRecord}
     */
    static fromJSON(s) {
      return new this().fromJSON(s);
    }
  }
  class u extends w {
    /**
     * Create an SLP script.
     * @constructor
     * @param {Buffer|Array|Object} code
     */
    constructor(s) {
      super(s), this.valid = null;
    }
    /**
     * Is SLP script is of valid construction?
     * Use this as opposed to calling property this.isValid
     * @private
     * @returns {Boolean}
     */
    isValidSlp() {
      return this.valid === null && (this.valid = this.verifySlp()), this.valid;
    }
    /**
     * Test whether SLP script is of valid construction
     * (Does not test if transaction is valid SLP transaction)
     * @private
     * @param {Script?} script
     * @returns {Boolean}
     */
    verifySlp(s) {
      if (s == null && (s = this), s.getSym(0) != "OP_RETURN" || s.getString(1, "hex") != "534c5000")
        return !1;
      const i = s.getString(2, "hex");
      if (i != "01" && i != "02")
        return !1;
      switch (s.getType()) {
        case "GENESIS": {
          if (s.code.length != 11 || !s.getData(7) || s.getData(7).length != 0 && s.getData(7).length != 32 || !s.getData(8) || s.getData(8).length != 1 || s.getInt(8) > 9)
            return !1;
          if (i == "01") {
            if (!s.getData(9) || s.getData(9).length > 1 || s.getData(9).length == 1 && s.getInt(9) < 2)
              return !1;
          } else if (i == "02" && (!s.getData(9) || s.getData(9).length != 20))
            return !1;
          if (s.getData(10).length != 8)
            return !1;
          break;
        }
        case "MINT": {
          if (i == "01" && s.code.length != 7 || i == "02" && s.code.length < 6 || s.getData(4).length != 32)
            return !1;
          if (i == "01") {
            if (!s.getData(5) || s.getData(5).length > 1 || s.getData(5).length == 1 && s.getInt(5) < 2 || s.getData(6).length != 8)
              return !1;
          } else if (i == "02") {
            const g = s.code.slice(5);
            for (let S = 0; S < g.length; S++)
              if (g[S].data.length != 8)
                return !1;
          }
          break;
        }
        case "SEND": {
          if (s.code.length < 6 || s.getData(4).length != 32)
            return !1;
          const g = s.code.slice(5);
          for (let S = 0; S < g.length; S++)
            if (g[S].data.length != 8)
              return !1;
          break;
        }
        case "BURN": {
          if (s.code.length != 6 || s.getData(4).length != 32 || s.getData(5).length != 8)
            return !1;
          break;
        }
        default:
          return !1;
      }
      return !0;
    }
    /**
     * Test whether script is of valid construction
     * (Does not test if transaction is valid SLP transaction)
     * @param {Script?} script
     * @returns {Boolean}
     */
    static verifySlp(s) {
      return new this().verifySlp(s);
    }
    /**
     * Inject properties from a script
     * @private
     * @param {Script} code
     * @returns {SLP}
     */
    fromScript(s) {
      return this.inject(s), this;
    }
    /**
     * Inject properties from a script
     * @param {Script} code
     * @returns {SLP}
     */
    static fromScript(s) {
      return new this().fromScript(s);
    }
    /**
     * Get token ID for this script
     * @private
     * @returns {Hash}
     */
    getTokenId() {
      e(this.verifySlp(), "This is not a valid SLP script");
      const s = this.getType();
      return e(s != "GENESIS", "Cannot derive the tokenID from GENESIS script"), this.getData(4);
    }
    /**
     * Get records for a this script
     * @private
     * @param {Buffer?} txId The txid of the transaction containing this script
     * @returns {(SlpCoinRecord | TokenRecord)[]}
     */
    getRecords(s) {
      e(this.isValidSlp(), "Must be a valid SLP Script");
      const i = this.getType();
      switch (e(Object.keys(m).includes(i) && i != "BATON", "Type must be GENESIS | MINT | SEND | BURN"), e(s.byteLength, "tokenId must be a buffer"), e(s.length == 32, "tokenId must be a sha256 hash"), i) {
        case "GENESIS":
          return this.getGenesisRecords(s);
        case "MINT":
          return this.getMintRecords(s);
        case "SEND":
          return this.getSendRecords(s);
        case "BURN":
          return this.getBurnRecords(s);
        default:
          return null;
      }
    }
    /**
     * Get records for a GENESIS script
     * @private
     * @param {Buffer} tokenId The tokenId of the transaction containing this script
     * @returns {(SlpCoinRecord | TokenRecord)[]}
     */
    getGenesisRecords(s) {
      e(s.byteLength, "tokenId must be a buffer"), e(s.byteLength == 32, "tokenId must be a sha256 hash");
      const i = this.getType();
      e(i == "GENESIS", "This is not a GENESIS transaction");
      const p = this.getInt(2), g = [];
      if (g.push(this.constructor.TokenRecord({
        tokenId: s,
        version: p,
        ticker: this.getString(4, "utf-8"),
        name: this.getString(5, "utf-8"),
        uri: this.getString(6, "utf-8"),
        hash: this.getString(7, "hex"),
        decimals: this.getInt(8),
        vaultScriptHash: p === 2 ? this.getData(9) : void 0
      })), g.push(this.constructor.SlpCoinRecord({
        hash: k.from(s).reverse(),
        vout: 1,
        tokenId: s,
        value: this.getData(10),
        type: i,
        version: this.getInt(2)
      })), p === 1 && this.getInt(9) >= 2) {
        const S = k.alloc(1);
        S.writeInt8(1), g.push(this.constructor.SlpCoinRecord({
          hash: k.from(s).reverse(),
          vout: this.getInt(9),
          tokenId: s,
          value: S,
          type: "BATON",
          version: this.getInt(2)
        }));
      }
      return g;
    }
    /**
     * Get records for a MINT script
     * @private
     * @param {Buffer} txId The txHash of the transaction containing this script
     * @returns {SlpCoinRecord[]}
     */
    getMintRecords(s) {
      e(s.byteLength, "txId must be a buffer"), e(s.byteLength == 32, "txId must be a sha256 hash");
      const i = this.getType();
      e(i == "MINT", "This is not a MINT transaction");
      const p = this.getInt(2), g = [];
      if (p === 1) {
        if (g.push(this.constructor.SlpCoinRecord({
          hash: k.from(s).reverse(),
          vout: 1,
          tokenId: this.getData(4),
          value: this.getData(6),
          type: i,
          version: p
        })), this.getInt(5) >= 2) {
          const S = l.fromInt(1).toBE(k);
          g.push(this.constructor.SlpCoinRecord({
            hash: k.from(s).reverse(),
            vout: this.getInt(5),
            tokenId: this.getData(4),
            value: S,
            type: "BATON",
            version: p
          }));
        }
      } else if (p === 2) {
        const S = this.code.slice(5);
        for (let y = 0; y < S.length; y++) {
          const b = S[y].toData(), h = y + 1;
          g.push(this.constructor.SlpCoinRecord({
            hash: k.from(s).reverse(),
            vout: h,
            tokenId: this.getData(4),
            value: b,
            type: i,
            version: this.getInt(2)
          }));
        }
      }
      return g;
    }
    /**
     * Get records for a SEND script
     * @private
     * @param {Buffer} txId The txHash of the transaction containing this script
     * @param {Boolean} nonStandardOuts OP_RETURN is located at an index other than 0
     * @returns {SlpCoinRecord[]}
     */
    getSendRecords(s, i = !1) {
      e(s.byteLength, "txId must be a buffer"), e(s.byteLength == 32, "txId must be a sha256 hash");
      const p = this.getType();
      e(p == "SEND", "This is not a SEND transaction");
      const g = [], S = this.code.slice(5);
      for (let y = 0; y < S.length; y++) {
        const b = S[y].toData(), h = i ? y : y + 1;
        g.push(this.constructor.SlpCoinRecord({
          hash: k.from(s).reverse(),
          vout: h,
          tokenId: this.getData(4),
          value: b,
          type: p,
          version: this.getInt(2)
        }));
      }
      return g;
    }
    getBurnRecords(s, i = !1) {
      e(s.byteLength, "txId must be a buffer"), e(s.byteLength == 32, "txId must be a sha256 hash");
      const p = this.getType();
      e(p == "BURN", "This is not a BURN transaction");
      const g = [], S = this.code[5].toData();
      return g.push(this.constructor.SlpCoinRecord({
        hash: k.from(s).reverse(),
        vout: 0,
        tokenId: this.getData(4),
        value: S,
        type: p,
        version: this.getInt(2)
      })), g;
    }
    /**
     * Re-encode the script internally. Useful if you
     * changed something manually in the `code` array.
     * @returns {Script}
     */
    compile() {
      super.compile(), this.valid = null, this.isValidSlp();
    }
    /**
     * Inspect the script.
     * @returns {String} Human-readable script code.
     */
    inspect() {
      return `<SLP: ${this.toString()}>`;
    }
    getType() {
      return this.getString(3);
    }
    /**
     * Create a new TokenRecord
     * @param {Buffer?} tokenId
     * @param {Buffer?} tokenIndex
     * @param {String?} ticker
     * @param {String?} name
     * @param {String?} uri
     * @param {String?} hash
     * @param {Number} decimals
     * @param {Number?} version
     * @returns {TokenRecord}
     */
    static TokenRecord(s = {}) {
      return new n(s);
    }
    /**
     * Create a new SlpCoinRecord
     * @param {Buffer?} hash the output hash of the coin
     * @param {Number?} vout the output index of the coin
     * @param {Buffer?} tokenId 32 byte txid
     * @param {Buffer?} tokenIndex 4 byte unsigned integer (index of tx hash in db)
     * @param {Number} value
     * @param {String} type GENESIS | MINT | SEND | BATON
     * @param {Number?} version
     * @returns {SlpCoinRecord}
     */
    static SlpCoinRecord(s = {}) {
      return new f(s);
    }
  }
  return Nu = u, Nu;
}
var qu, I3;
function Si() {
  if (I3) return qu;
  I3 = 1;
  const e = Xe(), c = At(), l = wi(), w = Or(), m = Gr(), f = Cr(), n = Io(), u = vi(), { inspectSymbol: o } = Kt();
  class s {
    /**
     * Create an output.
     * @constructor
     * @param {Object?} options
     */
    constructor(p) {
      this.value = 0, this.script = new f(), p && this.fromOptions(p);
    }
    /**
     * Inject properties from options object.
     * @private
     * @param {Object} options
     */
    fromOptions(p) {
      return e(p, "Output data is required."), p.value && (e(
        Number.isSafeInteger(p.value) && p.value >= 0,
        "Value must be a uint64."
      ), this.value = p.value), p.script && this.script.fromOptions(p.script), p.address && this.script.fromAddress(p.address), p.slp && p.slp.constructor === n.SlpCoinRecord().constructor && (this.slp = p.slp), this;
    }
    /**
     * Instantiate output from options object.
     * @param {Object} options
     * @returns {Output}
     */
    static fromOptions(p) {
      return new this().fromOptions(p);
    }
    /**
     * Inject properties from script/value pair.
     * @private
     * @param {Script|Address} script
     * @param {Amount} value
     * @returns {Output}
     */
    fromScript(p, g) {
      return typeof p == "string" && (p = m.fromString(p)), p instanceof m && (p = f.fromAddress(p)), e(p instanceof f, "Script must be a Script."), e(
        Number.isSafeInteger(g) && g >= 0,
        "Value must be a uint64."
      ), this.script = p, this.value = g, this;
    }
    /**
     * Instantiate output from script/value pair.
     * @param {Script|Address} script
     * @param {Amount} value
     * @returns {Output}
     */
    static fromScript(p, g) {
      return new this().fromScript(p, g);
    }
    /**
     * Clone the output.
     * @returns {Output}
     */
    clone() {
      const p = new this.constructor();
      return p.value = this.value, p.script.inject(this.script), p;
    }
    /**
     * Test equality against another output.
     * @param {Output} output
     * @returns {Boolean}
     */
    equals(p) {
      return e(s.isOutput(p)), this.value === p.value && this.script.equals(p.script);
    }
    /**
     * Compare against another output (BIP69).
     * @param {Output} output
     * @returns {Number}
     */
    compare(p) {
      e(s.isOutput(p));
      const g = this.value - p.value;
      return g !== 0 ? g : this.script.compare(p.script);
    }
    /**
     * Get the script type as a string.
     * @returns {ScriptType} type
     */
    getType() {
      return f.typesByVal[this.script.getType()].toLowerCase();
    }
    /**
     * Get the address.
     * @returns {Address} address
     */
    getAddress() {
      return this.script.getAddress();
    }
    /**
     * Get the address hash.
     * @param {String?} enc
     * @returns {Hash} hash
     */
    getHash(p) {
      const g = this.getAddress();
      return g ? g.getHash(p) : null;
    }
    /**
     * Convert the input to a more user-friendly object.
     * @returns {Object}
     */
    [o]() {
      const p = {
        type: this.getType(),
        value: l.btc(this.value),
        script: this.script,
        address: this.getAddress()
      };
      return this.slp ? {
        ...p,
        slp: this.slp
      } : p;
    }
    /**
     * Convert the output to an object suitable
     * for JSON serialization.
     * @returns {Object}
     */
    toJSON() {
      return this.getJSON();
    }
    /**
     * Convert the output to an object suitable
     * for JSON serialization.
     * @param {Network} network
     * @returns {Object}
     */
    getJSON(p) {
      let g = this.getAddress();
      p = w.get(p), g && (g = g.toString(p));
      const S = {
        value: this.value,
        script: this.script.toJSON(),
        address: g
      };
      return this.slp ? {
        ...S,
        slp: this.slp.getJSON()
      } : S;
    }
    /**
     * Calculate the dust threshold for this
     * output, based on serialize size and rate.
     * @param {Rate?} rate
     * @returns {Amount}
     */
    getDustThreshold(p) {
      if (this.script.isUnspendable())
        return 0;
      let g = this.getSize();
      return g += 148, 3 * u.getMinFee(g, p);
    }
    /**
     * Calculate size of serialized output.
     * @returns {Number}
     */
    getSize() {
      return 8 + this.script.getVarSize();
    }
    /**
     * Test whether the output should be considered dust.
     * @param {Rate?} rate
     * @returns {Boolean}
     */
    isDust(p) {
      return this.value < this.getDustThreshold(p);
    }
    /**
     * Inject properties from a JSON object.
     * @private
     * @param {Object} json
     */
    fromJSON(p) {
      return e(p, "Output data is required."), e(
        Number.isSafeInteger(p.value) && p.value >= 0,
        "Value must be a uint64."
      ), this.value = p.value, this.script.fromJSON(p.script), p.slp && (this.slp = n.SlpCoinRecord().fromJSON(p.slp)), this;
    }
    /**
     * Instantiate an Output from a jsonified output object.
     * @param {Object} json - The jsonified output object.
     * @returns {Output}
     */
    static fromJSON(p) {
      return new this().fromJSON(p);
    }
    /**
     * Write the output to a buffer writer.
     * @param {BufferWriter} bw
     */
    toWriter(p) {
      return p.writeI64(this.value), p.writeVarBytes(this.script.toRaw()), p;
    }
    /**
     * Serialize the output.
     * @param {String?} enc - Encoding, can be `'hex'` or null.
     * @returns {Buffer|String}
     */
    toRaw() {
      const p = this.getSize();
      return this.toWriter(c.write(p)).render();
    }
    /**
     * Inject properties from buffer reader.
     * @private
     * @param {BufferReader} br
     */
    fromReader(p) {
      return this.value = p.readI64(), this.script.fromRaw(p.readVarBytes()), this;
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     */
    fromRaw(p) {
      return this.fromReader(c.read(p));
    }
    /**
     * Instantiate an output from a buffer reader.
     * @param {BufferReader} br
     * @returns {Output}
     */
    static fromReader(p) {
      return new this().fromReader(p);
    }
    /**
     * Instantiate an output from a serialized Buffer.
     * @param {Buffer} data
     * @param {String?} enc - Encoding, can be `'hex'` or null.
     * @returns {Output}
     */
    static fromRaw(p, g) {
      return typeof p == "string" && (p = k.from(p, g)), new this().fromRaw(p);
    }
    /**
     * Test an object to see if it is an Output.
     * @param {Object} obj
     * @returns {Boolean}
     */
    static isOutput(p) {
      return p instanceof s;
    }
  }
  return qu = s, qu;
}
var Tu, A3;
function Ei() {
  if (A3) return Tu;
  A3 = 1;
  const e = Xe(), c = At(), l = Qt(), w = Lt(), { inspectSymbol: m } = Kt();
  class f {
    /**
     * Create an outpoint.
     * @constructor
     * @param {Hash?} hash
     * @param {Number?} index
     */
    constructor(o, s) {
      this.hash = w.ZERO_HASH, this.index = 4294967295, o != null && (e(k.isBuffer(o)), e(s >>> 0 === s, "Index must be a uint32."), this.hash = o, this.index = s);
    }
    /**
     * Inject properties from options object.
     * @private
     * @param {Object} options
     */
    fromOptions(o) {
      return e(o, "Outpoint data is required."), e(k.isBuffer(o.hash)), e(o.index >>> 0 === o.index, "Index must be a uint32."), this.hash = o.hash, this.index = o.index, this;
    }
    /**
     * Instantate outpoint from options object.
     * @param {Object} options
     * @returns {Outpoint}
     */
    static fromOptions(o) {
      return new this().fromOptions(o);
    }
    /**
     * Clone the outpoint.
     * @returns {Outpoint}
     */
    clone() {
      const o = new this.constructor();
      return o.hash = this.hash, o.index = this.index, o;
    }
    /**
     * Test equality against another outpoint.
     * @param {Outpoint} prevout
     * @returns {Boolean}
     */
    equals(o) {
      return e(f.isOutpoint(o)), this.hash.equals(o.hash) && this.index === o.index;
    }
    /**
     * Compare against another outpoint (BIP69).
     * @param {Outpoint} prevout
     * @returns {Number}
     */
    compare(o) {
      e(f.isOutpoint(o));
      const s = n(this.txid(), o.txid());
      return s !== 0 ? s : this.index - o.index;
    }
    /**
     * Test whether the outpoint is null (hash of zeroes
     * with max-u32 index). Used to detect coinbases.
     * @returns {Boolean}
     */
    isNull() {
      return this.index === 4294967295 && this.hash.equals(w.ZERO_HASH);
    }
    /**
     * Get little-endian hash.
     * @returns {Hash}
     */
    rhash() {
      return l.revHex(this.hash);
    }
    /**
     * Get little-endian hash.
     * @returns {Hash}
     */
    txid() {
      return this.rhash();
    }
    /**
     * Serialize outpoint to a key
     * suitable for a hash table.
     * @returns {String}
     */
    toKey() {
      return this.toRaw();
    }
    /**
     * Inject properties from hash table key.
     * @private
     * @param {String} key
     * @returns {Outpoint}
     */
    fromKey(o) {
      return this.hash = o.slice(0, 32), this.index = c.readU32(o, 32), this;
    }
    /**
     * Instantiate outpoint from hash table key.
     * @param {String} key
     * @returns {Outpoint}
     */
    static fromKey(o) {
      return new this().fromKey(o);
    }
    /**
     * Write outpoint to a buffer writer.
     * @param {BufferWriter} bw
     */
    toWriter(o) {
      return o.writeHash(this.hash), o.writeU32(this.index), o;
    }
    /**
     * Calculate size of outpoint.
     * @returns {Number}
     */
    getSize() {
      return 36;
    }
    /**
     * Serialize outpoint.
     * @returns {Buffer}
     */
    toRaw() {
      return this.toWriter(c.write(36)).render();
    }
    /**
     * Inject properties from buffer reader.
     * @private
     * @param {BufferReader} br
     */
    fromReader(o) {
      return this.hash = o.readHash(), this.index = o.readU32(), this;
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     */
    fromRaw(o) {
      return this.fromReader(c.read(o));
    }
    /**
     * Instantiate outpoint from a buffer reader.
     * @param {BufferReader} br
     * @returns {Outpoint}
     */
    static fromReader(o) {
      return new this().fromReader(o);
    }
    /**
     * Instantiate outpoint from serialized data.
     * @param {Buffer} data
     * @returns {Outpoint}
     */
    static fromRaw(o) {
      return new this().fromRaw(o);
    }
    /**
     * Inject properties from json object.
     * @private
     * @params {Object} json
     */
    fromJSON(o) {
      return e(o, "Outpoint data is required."), e(typeof o.hash == "string", "Hash must be a string."), e(o.index >>> 0 === o.index, "Index must be a uint32."), this.hash = l.fromRev(o.hash), this.index = o.index, this;
    }
    /**
     * Convert the outpoint to an object suitable
     * for JSON serialization. Note that the hash
     * will be reversed to abide by bitcoind's legacy
     * of little-endian uint256s.
     * @returns {Object}
     */
    toJSON() {
      return {
        hash: l.revHex(this.hash),
        index: this.index
      };
    }
    /**
     * Instantiate outpoint from json object.
     * @param {Object} json
     * @returns {Outpoint}
     */
    static fromJSON(o) {
      return new this().fromJSON(o);
    }
    /**
     * Inject properties from tx.
     * @private
     * @param {TX} tx
     * @param {Number} index
     */
    fromTX(o, s) {
      return e(o), e(typeof s == "number"), e(s >= 0), this.hash = o.hash(), this.index = s, this;
    }
    /**
     * Instantiate outpoint from tx.
     * @param {TX} tx
     * @param {Number} index
     * @returns {Outpoint}
     */
    static fromTX(o, s) {
      return new this().fromTX(o, s);
    }
    /**
     * Serialize outpoint to a key
     * suitable for a hash table.
     * @param {Hash} hash
     * @param {Number} index
     * @returns {String}
     */
    static toKey(o, s) {
      return new f(o, s).toKey();
    }
    /**
     * Convert the outpoint to a user-friendly string.
     * @returns {String}
     */
    [m]() {
      return `<Outpoint: ${this.rhash()}/${this.index}>`;
    }
    /**
     * Test an object to see if it is an outpoint.
     * @param {Object} obj
     * @returns {Boolean}
     */
    static isOutpoint(o) {
      return o instanceof f;
    }
  }
  function n(u, o) {
    const s = Math.min(u.length, o.length);
    for (let i = 0; i < s; i++) {
      if (u[i] < o[i])
        return -1;
      if (u[i] > o[i])
        return 1;
    }
    return u.length < o.length ? -1 : u.length > o.length ? 1 : 0;
  }
  return Tu = f, Tu;
}
var zu, O3;
function cs() {
  if (O3) return zu;
  O3 = 1;
  const e = Xe(), c = At(), l = Qt(), w = wi(), m = Si(), f = Or(), n = Lt(), u = Ei(), o = Io(), { inspectSymbol: s } = Kt();
  class i extends m {
    /**
     * Create a coin.
     * @constructor
     * @param {Object} options
     */
    constructor(g) {
      super(), this.version = 1, this.height = -1, this.coinbase = !1, this.hash = n.ZERO_HASH, this.index = 0, g && this.fromOptions(g);
    }
    /**
     * Inject options into coin.
     * @private
     * @param {Object} options
     */
    fromOptions(g) {
      return e(g, "Coin data is required."), g.version != null && (e(
        g.version >>> 0 === g.version,
        "Version must be a uint32."
      ), this.version = g.version), g.height != null && (g.height !== -1 ? (e(
        g.height >>> 0 === g.height,
        "Height must be a uint32."
      ), this.height = g.height) : this.height = -1), g.value != null && (e(
        Number.isSafeInteger(g.value) && g.value >= 0,
        "Value must be a uint64."
      ), this.value = g.value), g.script && this.script.fromOptions(g.script), g.coinbase != null && (e(
        typeof g.coinbase == "boolean",
        "Coinbase must be a boolean."
      ), this.coinbase = g.coinbase), g.hash != null && (e(k.isBuffer(g.hash)), this.hash = g.hash), g.index != null && (e(
        g.index >>> 0 === g.index,
        "Index must be a uint32."
      ), this.index = g.index), this;
    }
    /**
     * Instantiate Coin from options object.
     * @private
     * @param {Object} options
     */
    static fromOptions(g) {
      return new this().fromOptions(g);
    }
    /**
     * Clone the coin.
     * @private
     * @returns {Coin}
     */
    clone() {
      e(!1, "Coins are not cloneable.");
    }
    /**
     * Calculate number of confirmations since coin was created.
     * @param {Number?} height - Current chain height. Network
     * height is used if not passed in.
     * @return {Number}
     */
    getDepth(g) {
      return e(typeof g == "number", "Must pass a height."), this.height === -1 || g === -1 || g < this.height ? 0 : g - this.height + 1;
    }
    /**
     * Serialize coin to a key
     * suitable for a hash table.
     * @returns {String}
     */
    toKey() {
      return u.toKey(this.hash, this.index);
    }
    /**
     * Inject properties from hash table key.
     * @private
     * @param {String} key
     * @returns {Coin}
     */
    fromKey(g) {
      const { hash: S, index: y } = u.fromKey(g);
      return this.hash = S, this.index = y, this;
    }
    /**
     * Instantiate coin from hash table key.
     * @param {String} key
     * @returns {Coin}
     */
    static fromKey(g) {
      return new this().fromKey(g);
    }
    /**
     * Get little-endian hash.
     * @returns {Hash}
     */
    rhash() {
      return l.revHex(this.hash);
    }
    /**
     * Get little-endian hash.
     * @returns {Hash}
     */
    txid() {
      return this.rhash();
    }
    /**
     * Convert the coin to a more user-friendly object.
     * @returns {Object}
     */
    [s]() {
      const g = {
        type: this.getType(),
        version: this.version,
        height: this.height,
        value: w.btc(this.value),
        script: this.script,
        coinbase: this.coinbase,
        hash: this.hash ? l.revHex(this.hash) : null,
        index: this.index,
        address: this.getAddress()
      };
      return this.slp ? {
        ...g,
        slp: this.slp
      } : g;
    }
    /**
     * Convert the coin to an object suitable
     * for JSON serialization.
     * @returns {Object}
     */
    toJSON() {
      return this.getJSON();
    }
    /**
     * Convert the coin to an object suitable
     * for JSON serialization. Note that the hash
     * will be reversed to abide by bitcoind's legacy
     * of little-endian uint256s.
     * @param {Network} network
     * @param {Boolean} minimal
     * @returns {Object}
     */
    getJSON(g, S) {
      let y = this.getAddress();
      g = f.get(g), y && (y = y.toString(g));
      const b = {
        version: this.version,
        height: this.height,
        value: this.value,
        script: this.script.toJSON(),
        address: y,
        coinbase: this.coinbase,
        hash: S ? void 0 : this.rhash(),
        index: S ? void 0 : this.index
      };
      return this.slp ? {
        ...b,
        slp: this.slp.getJSON()
      } : b;
    }
    /**
     * Inject JSON properties into coin.
     * @private
     * @param {Object} json
     */
    fromJSON(g) {
      return e(g, "Coin data required."), e(g.version >>> 0 === g.version, "Version must be a uint32."), e(
        g.height === -1 || g.height >>> 0 === g.height,
        "Height must be a uint32."
      ), e(
        Number.isSafeInteger(g.value) && g.value >= 0,
        "Value must be a uint64."
      ), e(typeof g.coinbase == "boolean", "Coinbase must be a boolean."), this.version = g.version, this.height = g.height, this.value = g.value, this.script.fromJSON(g.script), this.coinbase = g.coinbase, g.hash != null && (e(typeof g.hash == "string", "Hash must be a string."), e(g.hash.length === 64, "Hash must be a string."), e(g.index >>> 0 === g.index, "Index must be a uint32."), this.hash = l.fromRev(g.hash), this.index = g.index), g.slp && (g.slp.hash = g.hash, this.slp = o.SlpCoinRecord().fromJSON(g.slp)), this;
    }
    /**
     * Instantiate an Coin from a jsonified coin object.
     * @param {Object} json - The jsonified coin object.
     * @returns {Coin}
     */
    static fromJSON(g) {
      return new this().fromJSON(g);
    }
    /**
     * Calculate size of coin.
     * @returns {Number}
     */
    getSize() {
      return 17 + this.script.getVarSize();
    }
    /**
     * Write the coin to a buffer writer.
     * @param {BufferWriter} bw
     */
    toWriter(g) {
      let S = this.height;
      return S === -1 && (S = 2147483647), g.writeU32(this.version), g.writeU32(S), g.writeI64(this.value), g.writeVarBytes(this.script.toRaw()), g.writeU8(this.coinbase ? 1 : 0), g;
    }
    /**
     * Serialize the coin.
     * @returns {Buffer|String}
     */
    toRaw() {
      const g = this.getSize();
      return this.toWriter(c.write(g)).render();
    }
    /**
     * Inject properties from serialized buffer writer.
     * @private
     * @param {BufferReader} br
     */
    fromReader(g) {
      return this.version = g.readU32(), this.height = g.readU32(), this.value = g.readI64(), this.script.fromRaw(g.readVarBytes()), this.coinbase = g.readU8() === 1, this.height === 2147483647 && (this.height = -1), this;
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     */
    fromRaw(g) {
      return this.fromReader(c.read(g));
    }
    /**
     * Instantiate a coin from a buffer reader.
     * @param {BufferReader} br
     * @returns {Coin}
     */
    static fromReader(g) {
      return new this().fromReader(g);
    }
    /**
     * Instantiate a coin from a serialized Buffer.
     * @param {Buffer} data
     * @param {String?} enc - Encoding, can be `'hex'` or null.
     * @returns {Coin}
     */
    static fromRaw(g, S) {
      return typeof g == "string" && (g = k.from(g, S)), new this().fromRaw(g);
    }
    /**
     * Inject properties from TX.
     * @param {TX} tx
     * @param {Number} index
     */
    fromTX(g, S, y) {
      return e(typeof S == "number"), e(typeof y == "number"), e(S >= 0 && S < g.outputs.length), this.version = g.version, this.height = y, this.value = g.outputs[S].value, this.script = g.outputs[S].script, this.coinbase = g.isCoinbase(), this.hash = g.hash(), this.index = S, this;
    }
    /**
     * Instantiate a coin from a TX
     * @param {TX} tx
     * @param {Number} index - Output index.
     * @returns {Coin}
     */
    static fromTX(g, S, y) {
      return new this().fromTX(g, S, y);
    }
    /**
     * Test an object to see if it is a Coin.
     * @param {Object} obj
     * @returns {Boolean}
     */
    static isCoin(g) {
      return g instanceof i;
    }
  }
  return zu = i, zu;
}
var Fn = {}, _3;
function Mp() {
  if (_3) return Fn;
  _3 = 1;
  const e = Xe(), { encoding: c } = At(), l = zr(), w = Lt(), m = 6, f = k.alloc(0);
  function n(b, h) {
    const a = b.getPubkeyhash(!0);
    if (a)
      return h.writeU8(0), h.writeBytes(a), h;
    const E = b.getScripthash();
    if (E)
      return h.writeU8(1), h.writeBytes(E), h;
    const H = b.getPubkey(!0);
    if (H && g(H)) {
      const j = S(H);
      return h.writeBytes(j), h;
    }
    return h.writeVarint(b.raw.length + m), h.writeBytes(b.raw), h;
  }
  function u(b, h) {
    switch (h.readU8()) {
      case 0: {
        const a = h.readBytes(20, !0);
        b.fromPubkeyhash(a);
        break;
      }
      case 1: {
        const a = h.readBytes(20, !0);
        b.fromScripthash(a);
        break;
      }
      case 2:
      case 3:
      case 4:
      case 5: {
        h.offset -= 1;
        const a = h.readBytes(33, !0), E = y(a);
        b.fromPubkey(E);
        break;
      }
      default: {
        h.offset -= 1;
        const a = h.readVarint() - m;
        if (a > w.MAX_SCRIPT_SIZE)
          b.fromNulldata(f), h.seek(a);
        else {
          const E = h.readBytes(a);
          b.fromRaw(E);
        }
        break;
      }
    }
    return b;
  }
  function o(b) {
    if (b.isPubkeyhash(!0) || b.isScripthash())
      return 21;
    const h = b.getPubkey(!0);
    if (h && g(h))
      return 33;
    let a = 0;
    return a += c.sizeVarint(b.raw.length + m), a += b.raw.length, a;
  }
  function s(b, h) {
    return h.writeVarint(b.value), n(b.script, h), h;
  }
  function i(b, h) {
    return b.value = h.readVarint(), u(b.script, h), b;
  }
  function p(b) {
    let h = 0;
    return h += c.sizeVarint(b.value), h += o(b.script), h;
  }
  function g(b) {
    if (b.length === 0)
      return !1;
    switch (b[0]) {
      case 2:
      case 3:
        return b.length === 33;
      case 4:
        return b.length !== 65 ? !1 : l.publicKeyVerify(b);
      default:
        return !1;
    }
  }
  function S(b) {
    let h;
    switch (b[0]) {
      case 2:
      case 3:
        h = b;
        break;
      case 4:
        h = l.publicKeyConvert(b, !0), h[0] = 4 | b[64] & 1;
        break;
      default:
        throw new Error("Bad point format.");
    }
    return e(h.length === 33), h;
  }
  function y(b) {
    const h = b[0];
    switch (e(b.length === 33), h) {
      case 2:
      case 3:
        return b;
      case 4:
        b[0] = 2;
        break;
      case 5:
        b[0] = 3;
        break;
      default:
        throw new Error("Bad point format.");
    }
    const a = l.publicKeyConvert(b, !1);
    return b[0] = h, a;
  }
  return Fn.pack = s, Fn.unpack = i, Fn.size = p, Fn;
}
/*!
 * coinentry.js - coin entry object for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var Cu, R3;
function Ao() {
  if (R3) return Cu;
  R3 = 1;
  const e = Xe(), c = At(), l = cs(), w = Si(), m = Mp(), { encoding: f } = c, n = 1, u = (1 << 32 - n >>> 0) - 1;
  class o {
    /**
     * Create a coin entry.
     * @constructor
     */
    constructor() {
      this.version = 1, this.height = -1, this.coinbase = !1, this.output = new w(), this.spent = !1, this.raw = null;
    }
    /**
     * Convert coin entry to an output.
     * @returns {Output}
     */
    toOutput() {
      return this.output;
    }
    /**
     * Convert coin entry to a coin.
     * @param {Outpoint} prevout
     * @returns {Coin}
     */
    toCoin(i) {
      const p = new l();
      return p.version = this.version, p.height = this.height, p.coinbase = this.coinbase, p.script = this.output.script, p.value = this.output.value, p.hash = i.hash, p.index = i.index, p;
    }
    /**
     * Inject properties from TX.
     * @param {TX} tx
     * @param {Number} index
     */
    fromOutput(i) {
      return this.output = i, this;
    }
    /**
     * Instantiate a coin from a TX
     * @param {TX} tx
     * @param {Number} index - Output index.
     * @returns {CoinEntry}
     */
    static fromOutput(i) {
      return new this().fromOutput(i);
    }
    /**
     * Inject properties from TX.
     * @param {TX} tx
     * @param {Number} index
     */
    fromCoin(i) {
      return this.version = i.version, this.height = i.height, this.coinbase = i.coinbase, this.output.script = i.script, this.output.value = i.value, this;
    }
    /**
     * Instantiate a coin from a TX
     * @param {TX} tx
     * @param {Number} index - Output index.
     * @returns {CoinEntry}
     */
    static fromCoin(i) {
      return new this().fromCoin(i);
    }
    /**
     * Inject properties from TX.
     * @param {TX} tx
     * @param {Number} index
     */
    fromTX(i, p, g) {
      return e(typeof p == "number"), e(typeof g == "number"), e(p >= 0 && p < i.outputs.length), this.version = i.version, this.height = g, this.coinbase = i.isCoinbase(), this.output = i.outputs[p], this;
    }
    /**
     * Instantiate a coin from a TX
     * @param {TX} tx
     * @param {Number} index - Output index.
     * @returns {CoinEntry}
     */
    static fromTX(i, p, g) {
      return new this().fromTX(i, p, g);
    }
    /**
     * Calculate size of coin.
     * @returns {Number}
     */
    getSize() {
      if (this.raw)
        return this.raw.length;
      let i = 0;
      return i += f.sizeVarint(this.version), i += 4, i += m.size(this.output), i;
    }
    /**
     * Write the coin to a buffer writer.
     * @param {BufferWriter} bw
     */
    toWriter(i) {
      if (this.raw)
        return i.writeBytes(this.raw), i;
      let p = this.height, g = 0;
      return this.coinbase && (g |= 1), p === -1 && (p = u), g |= p << n, i.writeVarint(this.version), i.writeU32(g), m.pack(this.output, i), i;
    }
    /**
     * Serialize the coin.
     * @returns {Buffer}
     */
    toRaw() {
      if (this.raw)
        return this.raw;
      const i = this.getSize(), p = c.write(i);
      return this.toWriter(p), this.raw = p.render(), this.raw;
    }
    /**
     * Inject properties from serialized buffer writer.
     * @private
     * @param {BufferReader} br
     */
    fromReader(i) {
      const p = i.readVarint(), g = i.readU32();
      let S = g >>> n;
      return S === u && (S = -1), this.version = p, this.coinbase = (g & 1) !== 0, this.height = S, m.unpack(this.output, i), this;
    }
    /**
     * Instantiate a coin from a serialized Buffer.
     * @param {Buffer} data
     * @returns {CoinEntry}
     */
    static fromReader(i) {
      return new this().fromReader(i);
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     */
    fromRaw(i) {
      return this.fromReader(c.read(i)), this.raw = i, this;
    }
    /**
     * Instantiate a coin from a serialized Buffer.
     * @param {Buffer} data
     * @returns {CoinEntry}
     */
    static fromRaw(i) {
      return new this().fromRaw(i);
    }
  }
  return Cu = o, Cu;
}
/*!
 * coins.js - coins object for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var Du, P3;
function f1() {
  if (P3) return Du;
  P3 = 1;
  const e = Xe(), c = Ao();
  class l {
    /**
     * Create coins.
     * @constructor
     */
    constructor() {
      this.outputs = /* @__PURE__ */ new Map();
    }
    /**
     * Add a single entry to the collection.
     * @param {Number} index
     * @param {CoinEntry} coin
     * @returns {CoinEntry}
     */
    add(m, f) {
      return e(m >>> 0 === m), e(f), this.outputs.set(m, f), f;
    }
    /**
     * Add a single output to the collection.
     * @param {Number} index
     * @param {Output} output
     * @returns {CoinEntry}
     */
    addOutput(m, f) {
      return this.add(m, c.fromOutput(f));
    }
    /**
     * Add an output to the collection by output index.
     * @param {TX} tx
     * @param {Number} index
     * @param {Number} height
     * @returns {CoinEntry}
     */
    addIndex(m, f, n) {
      return this.add(f, c.fromTX(m, f, n));
    }
    /**
     * Add a single coin to the collection.
     * @param {Coin} coin
     * @returns {CoinEntry}
     */
    addCoin(m) {
      return this.add(m.index, c.fromCoin(m));
    }
    /**
     * Test whether the collection has a coin.
     * @param {Number} index
     * @returns {Boolean}
     */
    has(m) {
      return this.outputs.has(m);
    }
    /**
     * Test whether the collection has an unspent coin.
     * @param {Number} index
     * @returns {Boolean}
     */
    isUnspent(m) {
      const f = this.outputs.get(m);
      return !(!f || f.spent);
    }
    /**
     * Get a coin entry.
     * @param {Number} index
     * @returns {CoinEntry|null}
     */
    get(m) {
      return this.outputs.get(m) || null;
    }
    /**
     * Get an output.
     * @param {Number} index
     * @returns {Output|null}
     */
    getOutput(m) {
      const f = this.outputs.get(m);
      return f ? f.output : null;
    }
    /**
     * Get a coin.
     * @param {Outpoint} prevout
     * @returns {Coin|null}
     */
    getCoin(m) {
      const f = this.outputs.get(m.index);
      return f ? f.toCoin(m) : null;
    }
    /**
     * Spend a coin entry and return it.
     * @param {Number} index
     * @returns {CoinEntry|null}
     */
    spend(m) {
      const f = this.get(m);
      return !f || f.spent ? null : (f.spent = !0, f);
    }
    /**
     * Remove a coin entry and return it.
     * @param {Number} index
     * @returns {CoinEntry|null}
     */
    remove(m) {
      const f = this.get(m);
      return f ? (this.outputs.delete(m), f) : null;
    }
    /**
     * Test whether the coins are fully spent.
     * @returns {Boolean}
     */
    isEmpty() {
      return this.outputs.size === 0;
    }
    /**
     * Inject properties from tx.
     * @private
     * @param {TX} tx
     * @param {Number} height
     * @returns {Coins}
     */
    fromTX(m, f) {
      e(typeof f == "number");
      for (let n = 0; n < m.outputs.length; n++) {
        if (m.outputs[n].script.isUnspendable())
          continue;
        const o = c.fromTX(m, n, f);
        this.outputs.set(n, o);
      }
      return this;
    }
    /**
     * Instantiate a coins object from a transaction.
     * @param {TX} tx
     * @param {Number} height
     * @returns {Coins}
     */
    static fromTX(m, f) {
      return new this().fromTX(m, f);
    }
  }
  return Du = l, Du;
}
/*!
 * undocoins.js - undocoins object for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var Uu, k3;
function Np() {
  if (k3) return Uu;
  k3 = 1;
  const e = Xe(), c = At(), l = Ao();
  class w {
    /**
     * Create undo coins.
     * @constructor
     */
    constructor() {
      this.items = [];
    }
    /**
     * Push coin entry onto undo coin array.
     * @param {CoinEntry}
     * @returns {Number}
     */
    push(f) {
      return this.items.push(f);
    }
    /**
     * Calculate undo coins size.
     * @returns {Number}
     */
    getSize() {
      let f = 0;
      f += 4;
      for (const n of this.items)
        f += n.getSize();
      return f;
    }
    /**
     * Serialize all undo coins.
     * @returns {Buffer}
     */
    toRaw() {
      const f = this.getSize(), n = c.write(f);
      n.writeU32(this.items.length);
      for (const u of this.items)
        u.toWriter(n);
      return n.render();
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     * @returns {UndoCoins}
     */
    fromRaw(f) {
      const n = c.read(f), u = n.readU32();
      for (let o = 0; o < u; o++)
        this.items.push(l.fromReader(n));
      return this;
    }
    /**
     * Instantiate undo coins from serialized data.
     * @param {Buffer} data
     * @returns {UndoCoins}
     */
    static fromRaw(f) {
      return new this().fromRaw(f);
    }
    /**
     * Test whether the undo coins have any members.
     * @returns {Boolean}
     */
    isEmpty() {
      return this.items.length === 0;
    }
    /**
     * Render the undo coins.
     * @returns {Buffer}
     */
    commit() {
      const f = this.toRaw();
      return this.items.length = 0, f;
    }
    /**
     * Re-apply undo coins to a view, effectively unspending them.
     * @param {CoinView} view
     * @param {Outpoint} prevout
     */
    apply(f, n) {
      const u = this.items.pop();
      e(u), f.addEntry(n, u);
    }
  }
  return Uu = w, Uu;
}
/*!
 * coinview.js - coin viewpoint object for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var Fu, B3;
function Oo() {
  if (B3) return Fu;
  B3 = 1;
  const { BufferMap: e } = $r(), c = f1(), l = Np(), w = Ao();
  class m {
    /**
     * Create a coin view.
     * @constructor
     */
    constructor() {
      this.map = new e(), this.undo = new l();
    }
    /**
     * Get coins.
     * @param {Hash} hash
     * @returns {Coins} coins
     */
    get(n) {
      return this.map.get(n);
    }
    /**
     * Test whether the view has an entry.
     * @param {Hash} hash
     * @returns {Boolean}
     */
    has(n) {
      return this.map.has(n);
    }
    /**
     * Add coins to the collection.
     * @param {Hash} hash
     * @param {Coins} coins
     * @returns {Coins}
     */
    add(n, u) {
      return this.map.set(n, u), u;
    }
    /**
     * Ensure existence of coins object in the collection.
     * @param {Hash} hash
     * @returns {Coins}
     */
    ensure(n) {
      const u = this.map.get(n);
      return u || this.add(n, new c());
    }
    /**
     * Remove coins from the collection.
     * @param {Coins} coins
     * @returns {Coins|null}
     */
    remove(n) {
      const u = this.map.get(n);
      return u ? (this.map.delete(n), u) : null;
    }
    /**
     * Add a tx to the collection.
     * @param {TX} tx
     * @param {Number} height
     * @returns {Coins}
     */
    addTX(n, u) {
      const o = n.hash(), s = c.fromTX(n, u);
      return this.add(o, s);
    }
    /**
     * Remove a tx from the collection.
     * @param {TX} tx
     * @param {Number} height
     * @returns {Coins}
     */
    removeTX(n, u) {
      const o = n.hash(), s = c.fromTX(n, u);
      for (const i of s.outputs.values())
        i.spent = !0;
      return this.add(o, s);
    }
    /**
     * Add an entry to the collection.
     * @param {Outpoint} prevout
     * @param {CoinEntry} coin
     * @returns {CoinEntry|null}
     */
    addEntry(n, u) {
      const { hash: o, index: s } = n;
      return this.ensure(o).add(s, u);
    }
    /**
     * Add a coin to the collection.
     * @param {Coin} coin
     * @returns {CoinEntry|null}
     */
    addCoin(n) {
      return this.ensure(n.hash).addCoin(n);
    }
    /**
     * Add an output to the collection.
     * @param {Outpoint} prevout
     * @param {Output} output
     * @returns {CoinEntry|null}
     */
    addOutput(n, u) {
      const { hash: o, index: s } = n;
      return this.ensure(o).addOutput(s, u);
    }
    /**
     * Add an output to the collection by output index.
     * @param {TX} tx
     * @param {Number} index
     * @param {Number} height
     * @returns {CoinEntry|null}
     */
    addIndex(n, u, o) {
      const s = n.hash();
      return this.ensure(s).addIndex(n, u, o);
    }
    /**
     * Spend an output.
     * @param {Outpoint} prevout
     * @returns {CoinEntry|null}
     */
    spendEntry(n) {
      const { hash: u, index: o } = n, s = this.get(u);
      if (!s)
        return null;
      const i = s.spend(o);
      return i ? (this.undo.push(i), i) : null;
    }
    /**
     * Remove an output.
     * @param {Outpoint} prevout
     * @returns {CoinEntry|null}
     */
    removeEntry(n) {
      const { hash: u, index: o } = n, s = this.get(u);
      return s ? s.remove(o) : null;
    }
    /**
     * Test whether the view has an entry by prevout.
     * @param {Outpoint} prevout
     * @returns {Boolean}
     */
    hasEntry(n) {
      const { hash: u, index: o } = n, s = this.get(u);
      return s ? s.has(o) : !1;
    }
    /**
     * Get a single entry by prevout.
     * @param {Outpoint} prevout
     * @returns {CoinEntry|null}
     */
    getEntry(n) {
      const { hash: u, index: o } = n, s = this.get(u);
      return s ? s.get(o) : null;
    }
    /**
     * Test whether an entry has been spent by prevout.
     * @param {Outpoint} prevout
     * @returns {Boolean}
     */
    isUnspent(n) {
      const { hash: u, index: o } = n, s = this.get(u);
      return s ? s.isUnspent(o) : !1;
    }
    /**
     * Get a single coin by prevout.
     * @param {Outpoint} prevout
     * @returns {Coin|null}
     */
    getCoin(n) {
      const u = this.get(n.hash);
      return u ? u.getCoin(n) : null;
    }
    /**
     * Get a single output by prevout.
     * @param {Outpoint} prevout
     * @returns {Output|null}
     */
    getOutput(n) {
      const { hash: u, index: o } = n, s = this.get(u);
      return s ? s.getOutput(o) : null;
    }
    /**
     * Get coins height by prevout.
     * @param {Outpoint} prevout
     * @returns {Number}
     */
    getHeight(n) {
      const u = this.getEntry(n);
      return u ? u.height : -1;
    }
    /**
     * Get coins coinbase flag by prevout.
     * @param {Outpoint} prevout
     * @returns {Boolean}
     */
    isCoinbase(n) {
      const u = this.getEntry(n);
      return u ? u.coinbase : !1;
    }
    /**
     * Test whether the view has an entry by input.
     * @param {Input} input
     * @returns {Boolean}
     */
    hasEntryFor(n) {
      return this.hasEntry(n.prevout);
    }
    /**
     * Get a single entry by input.
     * @param {Input} input
     * @returns {CoinEntry|null}
     */
    getEntryFor(n) {
      return this.getEntry(n.prevout);
    }
    /**
     * Test whether an entry has been spent by input.
     * @param {Input} input
     * @returns {Boolean}
     */
    isUnspentFor(n) {
      return this.isUnspent(n.prevout);
    }
    /**
     * Get a single coin by input.
     * @param {Input} input
     * @returns {Coin|null}
     */
    getCoinFor(n) {
      return this.getCoin(n.prevout);
    }
    /**
     * Get a single output by input.
     * @param {Input} input
     * @returns {Output|null}
     */
    getOutputFor(n) {
      return this.getOutput(n.prevout);
    }
    /**
     * Get coins height by input.
     * @param {Input} input
     * @returns {Number}
     */
    getHeightFor(n) {
      return this.getHeight(n.prevout);
    }
    /**
     * Get coins coinbase flag by input.
     * @param {Input} input
     * @returns {Boolean}
     */
    isCoinbaseFor(n) {
      return this.isCoinbase(n.prevout);
    }
    /**
     * Retrieve coins from database.
     * @method
     * @param {ChainDB} db
     * @param {Outpoint} prevout
     * @returns {Promise} - Returns {@link CoinEntry}.
     */
    async readCoin(n, u) {
      const o = this.getEntry(u);
      if (o)
        return o;
      const s = await n.readCoin(u);
      return s ? this.addEntry(u, s) : null;
    }
    /**
     * Read all input coins into unspent map.
     * @method
     * @param {ChainDB} db
     * @param {TX} tx
     * @returns {Promise} - Returns {Boolean}.
     */
    async readInputs(n, u) {
      let o = !0;
      for (const { prevout: s } of u.inputs)
        await this.readCoin(n, s) || (o = !1);
      return o;
    }
    /**
     * Spend coins for transaction.
     * @method
     * @param {ChainDB} db
     * @param {TX} tx
     * @returns {Promise} - Returns {Boolean}.
     */
    async spendInputs(n, u) {
      let o = 0;
      for (; o < u.inputs.length; ) {
        const s = Math.min(o + 4, u.inputs.length), i = [];
        for (; o < s; o++) {
          const { prevout: g } = u.inputs[o];
          i.push(this.readCoin(n, g));
        }
        const p = await Promise.all(i);
        for (const g of p) {
          if (!g || g.spent)
            return !1;
          g.spent = !0, this.undo.push(g);
        }
      }
      return !0;
    }
    /**
     * Calculate serialization size.
     * @returns {Number}
     */
    getSize(n) {
      let u = 0;
      u += n.inputs.length;
      for (const { prevout: o } of n.inputs) {
        const s = this.getEntry(o);
        s && (u += s.getSize());
      }
      return u;
    }
    /**
     * Write coin data to buffer writer
     * as it pertains to a transaction.
     * @param {BufferWriter} bw
     * @param {TX} tx
     */
    toWriter(n, u) {
      for (const { prevout: o } of u.inputs) {
        const s = this.getEntry(o);
        if (!s) {
          n.writeU8(0);
          continue;
        }
        n.writeU8(1), s.toWriter(n);
      }
      return n;
    }
    /**
     * Read serialized view data from a buffer
     * reader as it pertains to a transaction.
     * @private
     * @param {BufferReader} br
     * @param {TX} tx
     */
    fromReader(n, u) {
      for (const { prevout: o } of u.inputs) {
        if (n.readU8() === 0)
          continue;
        const s = w.fromReader(n);
        this.addEntry(o, s);
      }
      return this;
    }
    /**
     * Read serialized view data from a buffer
     * reader as it pertains to a transaction.
     * @param {BufferReader} br
     * @param {TX} tx
     * @returns {CoinView}
     */
    static fromReader(n, u) {
      return new this().fromReader(n, u);
    }
  }
  return Fu = m, Fu;
}
/*!
 * coins/index.js - utxo management for bcoin
 * Copyright (c) 2016-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var M3;
function sy() {
  return M3 || (M3 = 1, en.Coins = f1(), en.CoinView = Oo(), en.compress = Mp(), en.UndoCoins = Np()), en;
}
var Hu = {}, Lu = {}, N3;
function _o() {
  return N3 || (N3 = 1, function(e) {
    const c = Xe(), l = T8(), w = e;
    w.HARDENED = 2147483648, w.MIN_ENTROPY = 128, w.MAX_ENTROPY = 512, w.cache = new l(500), w.parsePath = function(f, n) {
      c(typeof f == "string"), c(typeof n == "boolean"), c(f.length >= 1), c(f.length <= 3062);
      const u = f.split("/"), o = u[0];
      if (o !== "m" && o !== "M" && o !== "m'" && o !== "M'")
        throw new Error("Invalid path root.");
      const s = [];
      for (let i = 1; i < u.length; i++) {
        let p = u[i];
        const g = p[p.length - 1] === "'";
        if (g && (p = p.slice(0, -1)), p.length > 10)
          throw new Error("Path index too large.");
        if (!/^\d+$/.test(p))
          throw new Error("Path index is non-numeric.");
        let S = parseInt(p, 10);
        if (S >>> 0 !== S)
          throw new Error("Path index out of range.");
        if (g && (S |= w.HARDENED, S >>>= 0), !n && S & w.HARDENED)
          throw new Error("Path index cannot be hardened.");
        s.push(S);
      }
      return s;
    }, w.isMaster = function(f) {
      return f.depth === 0 && f.childIndex === 0 && f.parentFingerPrint === 0;
    }, w.isAccount = function(f, n) {
      if (n != null) {
        const u = (w.HARDENED | n) >>> 0;
        if (f.childIndex !== u)
          return !1;
      }
      return f.depth === 3 && (f.childIndex & w.HARDENED) !== 0;
    }, w.ZERO_KEY = k.alloc(33, 0);
  }(Lu)), Lu;
}
var Ku, q3;
function Sn() {
  if (q3) return Ku;
  q3 = 1;
  const e = Nt(), c = yi();
  function l(w) {
    e(k.isBuffer(w)), c.randomFill(w, 0, w.length);
  }
  return l.native = 0, Ku = l, Ku;
}
var Hn = {}, T3;
function Ro() {
  if (T3) return Hn;
  T3 = 1;
  const e = Nt(), l = (Ft.crypto || Ft.msCrypto || {}).subtle || {};
  function w(n, u, o, s, i) {
    typeof u == "string" && (u = k.from(u, "utf8")), typeof o == "string" && (o = k.from(o, "utf8")), o == null && (o = k.alloc(0)), e(n && typeof n.id == "string"), e(k.isBuffer(u)), e(k.isBuffer(o)), e(s >>> 0 === s), e(i >>> 0 === i);
    const p = n.size, g = Math.ceil(i / p), S = k.alloc(g * p), y = k.alloc(o.length + 4);
    o.copy(y, 0), u.length > n.blockSize && (u = n.digest(u), e(u.length <= n.blockSize));
    for (let b = 0; b < g; b++) {
      const h = b + 1;
      y[o.length + 0] = h >>> 24, y[o.length + 1] = h >>> 16, y[o.length + 2] = h >>> 8, y[o.length + 3] = h;
      const a = n.mac(y, u);
      let E = a;
      for (let H = 1; H < s; H++) {
        E = n.mac(E, u);
        for (let j = 0; j < p; j++)
          a[j] ^= E[j];
      }
      a.copy(S, b * p);
    }
    return S.slice(0, i);
  }
  async function m(n, u, o, s, i) {
    typeof u == "string" && (u = k.from(u, "utf8")), typeof o == "string" && (o = k.from(o, "utf8")), o == null && (o = k.alloc(0)), e(n && typeof n.id == "string"), e(k.isBuffer(u)), e(k.isBuffer(o)), e(s >>> 0 === s), e(i >>> 0 === i);
    const p = f(n);
    if (!l.importKey || !l.deriveBits || !p)
      return w(n, u, o, s, i);
    const g = { name: "PBKDF2" }, S = ["deriveBits"], y = {
      name: "PBKDF2",
      salt: o,
      iterations: s,
      hash: p
    }, b = await l.importKey("raw", u, g, !1, S), h = await l.deriveBits(y, b, i * 8);
    return k.from(h);
  }
  function f(n) {
    switch (n.id) {
      case "SHA1":
        return "SHA-1";
      case "SHA256":
        return "SHA-256";
      case "SHA384":
        return "SHA-384";
      case "SHA512":
        return "SHA-512";
      default:
        return null;
    }
  }
  return Hn.native = 0, Hn.derive = w, Hn.deriveAsync = m, Hn;
}
var Vu, z3;
function En() {
  if (z3) return Vu;
  z3 = 1;
  const e = Nt(), c = fi(), l = -1, w = k.alloc(16, 0), m = k.alloc(128, 0);
  m[0] = 128;
  const f = new Uint32Array([
    1116352408,
    3609767458,
    1899447441,
    602891725,
    3049323471,
    3964484399,
    3921009573,
    2173295548,
    961987163,
    4081628472,
    1508970993,
    3053834265,
    2453635748,
    2937671579,
    2870763221,
    3664609560,
    3624381080,
    2734883394,
    310598401,
    1164996542,
    607225278,
    1323610764,
    1426881987,
    3590304994,
    1925078388,
    4068182383,
    2162078206,
    991336113,
    2614888103,
    633803317,
    3248222580,
    3479774868,
    3835390401,
    2666613458,
    4022224774,
    944711139,
    264347078,
    2341262773,
    604807628,
    2007800933,
    770255983,
    1495990901,
    1249150122,
    1856431235,
    1555081692,
    3175218132,
    1996064986,
    2198950837,
    2554220882,
    3999719339,
    2821834349,
    766784016,
    2952996808,
    2566594879,
    3210313671,
    3203337956,
    3336571891,
    1034457026,
    3584528711,
    2466948901,
    113926993,
    3758326383,
    338241895,
    168717936,
    666307205,
    1188179964,
    773529912,
    1546045734,
    1294757372,
    1522805485,
    1396182291,
    2643833823,
    1695183700,
    2343527390,
    1986661051,
    1014477480,
    2177026350,
    1206759142,
    2456956037,
    344077627,
    2730485921,
    1290863460,
    2820302411,
    3158454273,
    3259730800,
    3505952657,
    3345764771,
    106217008,
    3516065817,
    3606008344,
    3600352804,
    1432725776,
    4094571909,
    1467031594,
    275423344,
    851169720,
    430227734,
    3100823752,
    506948616,
    1363258195,
    659060556,
    3750685593,
    883997877,
    3785050280,
    958139571,
    3318307427,
    1322822218,
    3812723403,
    1537002063,
    2003034995,
    1747873779,
    3602036899,
    1955562222,
    1575990012,
    2024104815,
    1125592928,
    2227730452,
    2716904306,
    2361852424,
    442776044,
    2428436474,
    593698344,
    2756734187,
    3733110249,
    3204031479,
    2999351573,
    3329325298,
    3815920427,
    3391569614,
    3928383900,
    3515267271,
    566280711,
    3940187606,
    3454069534,
    4118630271,
    4000239992,
    116418474,
    1914138554,
    174292421,
    2731055270,
    289380356,
    3203993006,
    460393269,
    320620315,
    685471733,
    587496836,
    852142971,
    1086792851,
    1017036298,
    365543100,
    1126000580,
    2618297676,
    1288033470,
    3409855158,
    1501505948,
    4234509866,
    1607167915,
    987167468,
    1816402316,
    1246189591
  ]);
  class n {
    constructor() {
      this.state = new Uint32Array(16), this.msg = new Uint32Array(160), this.block = k.alloc(128), this.size = l;
    }
    init() {
      return this.state[0] = 1779033703, this.state[1] = 4089235720, this.state[2] = 3144134277, this.state[3] = 2227873595, this.state[4] = 1013904242, this.state[5] = 4271175723, this.state[6] = 2773480762, this.state[7] = 1595750129, this.state[8] = 1359893119, this.state[9] = 2917565137, this.state[10] = 2600822924, this.state[11] = 725511199, this.state[12] = 528734635, this.state[13] = 4215389547, this.state[14] = 1541459225, this.state[15] = 327033209, this.size = 0, this;
    }
    update(D) {
      return e(k.isBuffer(D)), this._update(D, D.length), this;
    }
    final() {
      return this._final(k.alloc(64));
    }
    _update(D, Q) {
      e(this.size !== l, "Context is not initialized.");
      let W = this.size & 127, oe = 0;
      if (this.size += Q, W > 0) {
        let v = 128 - W;
        if (v > Q && (v = Q), D.copy(this.block, W, oe, oe + v), W += v, Q -= v, oe += v, W < 128)
          return;
        this._transform(this.block, 0);
      }
      for (; Q >= 128; )
        this._transform(D, oe), oe += 128, Q -= 128;
      Q > 0 && D.copy(this.block, 0, oe, oe + Q);
    }
    /**
     * Finalize SHA512 context.
     * @private
     * @param {Buffer} out
     * @returns {Buffer}
     */
    _final(D) {
      e(this.size !== l, "Context is not initialized.");
      const Q = this.size & 127, W = this.size * 8;
      ue(w, W * (1 / 4294967296) >>> 0, 8), ue(w, W >>> 0, 12), this._update(m, 1 + (239 - Q & 127)), this._update(w, 16);
      for (let oe = 0; oe < 16; oe++)
        ue(D, this.state[oe], oe * 4), this.state[oe] = 0;
      for (let oe = 0; oe < 160; oe++)
        this.msg[oe] = 0;
      for (let oe = 0; oe < 128; oe++)
        this.block[oe] = 0;
      return this.size = l, D;
    }
    _prepare(D, Q) {
      const W = this.msg;
      let oe = 0;
      for (; oe < 32; oe++)
        W[oe] = fe(D, Q + oe * 4);
      for (; oe < 160; oe += 2) {
        const v = R(W[oe - 4], W[oe - 3]), Y = L(W[oe - 4], W[oe - 3]), he = W[oe - 14], le = W[oe - 13], ge = _(W[oe - 30], W[oe - 29]), Ee = F(W[oe - 30], W[oe - 29]), we = W[oe - 32], z = W[oe - 31];
        W[oe + 0] = i(
          v,
          Y,
          he,
          le,
          ge,
          Ee,
          we,
          z
        ), W[oe + 1] = p(
          v,
          Y,
          he,
          le,
          ge,
          Ee,
          we,
          z
        );
      }
    }
    _transform(D, Q) {
      const W = this.msg;
      this._prepare(D, Q);
      let oe = this.state[0], v = this.state[1], Y = this.state[2], he = this.state[3], le = this.state[4], ge = this.state[5], Ee = this.state[6], we = this.state[7], z = this.state[8], I = this.state[9], ne = this.state[10], t = this.state[11], d = this.state[12], B = this.state[13], U = this.state[14], J = this.state[15];
      for (let C = 0; C < W.length; C += 2) {
        let M = U, $ = J, r = A(z, I), x = q(z, I);
        const O = E(z, I, ne, t, d), K = H(z, I, ne, t, d, B), X = f[C + 0], P = f[C + 1], V = W[C + 0], re = W[C + 1], ce = g(
          M,
          $,
          r,
          x,
          O,
          K,
          X,
          P,
          V,
          re
        ), de = S(
          M,
          $,
          r,
          x,
          O,
          K,
          X,
          P,
          V,
          re
        );
        M = N(oe, v), $ = T(oe, v), r = j(oe, v, Y, he, le), x = G(oe, v, Y, he, le, ge);
        const pe = o(M, $, r, x), se = s(M, $, r, x);
        U = d, J = B, d = ne, B = t, ne = z, t = I, z = o(Ee, we, ce, de), I = s(we, we, ce, de), Ee = le, we = ge, le = Y, ge = he, Y = oe, he = v, oe = o(ce, de, pe, se), v = s(ce, de, pe, se);
      }
      u(this.state, 0, oe, v), u(this.state, 2, Y, he), u(this.state, 4, le, ge), u(this.state, 6, Ee, we), u(this.state, 8, z, I), u(this.state, 10, ne, t), u(this.state, 12, d, B), u(this.state, 14, U, J);
    }
    static hash() {
      return new n();
    }
    static hmac() {
      return new c(n, 128);
    }
    static digest(D) {
      return n.ctx.init().update(D).final();
    }
    static root(D, Q) {
      return e(k.isBuffer(D) && D.length === 64), e(k.isBuffer(Q) && Q.length === 64), n.ctx.init().update(D).update(Q).final();
    }
    static multi(D, Q, W) {
      const { ctx: oe } = n;
      return oe.init(), oe.update(D), oe.update(Q), W && oe.update(W), oe.final();
    }
    static mac(D, Q) {
      return n.hmac().init(Q).update(D).final();
    }
  }
  n.native = 0, n.id = "SHA512", n.size = 64, n.bits = 512, n.blockSize = 128, n.zero = k.alloc(64, 0), n.ctx = new n();
  function u(ae, D, Q, W) {
    const oe = ae[D + 0], v = ae[D + 1], Y = W + v >>> 0, he = (Y < W) + Q + oe;
    ae[D + 0] = he >>> 0, ae[D + 1] = Y;
  }
  function o(ae, D, Q, W) {
    return (D + W >>> 0 < D) + ae + Q >>> 0;
  }
  function s(ae, D, Q, W) {
    return D + W >>> 0;
  }
  function i(ae, D, Q, W, oe, v, Y, he) {
    let le = 0, ge = D;
    return ge = ge + W >>> 0, le += ge < D, ge = ge + v >>> 0, le += ge < v, ge = ge + he >>> 0, le += ge < he, ae + Q + oe + Y + le >>> 0;
  }
  function p(ae, D, Q, W, oe, v, Y, he) {
    return D + W + v + he >>> 0;
  }
  function g(ae, D, Q, W, oe, v, Y, he, le, ge) {
    let Ee = 0, we = D;
    return we = we + W >>> 0, Ee += we < D, we = we + v >>> 0, Ee += we < v, we = we + he >>> 0, Ee += we < he, we = we + ge >>> 0, Ee += we < ge, ae + Q + oe + Y + le + Ee >>> 0;
  }
  function S(ae, D, Q, W, oe, v, Y, he, le, ge) {
    return D + W + v + he + ge >>> 0;
  }
  function y(ae, D, Q) {
    return (D << 32 - Q | ae >>> Q) >>> 0;
  }
  function b(ae, D, Q) {
    return (ae << 32 - Q | D >>> Q) >>> 0;
  }
  function h(ae, D, Q) {
    return ae >>> Q;
  }
  function a(ae, D, Q) {
    return (ae << 32 - Q | D >>> Q) >>> 0;
  }
  function E(ae, D, Q, W, oe, v) {
    return (ae & Q ^ ~ae & oe) >>> 0;
  }
  function H(ae, D, Q, W, oe, v) {
    return (D & W ^ ~D & v) >>> 0;
  }
  function j(ae, D, Q, W, oe, v) {
    return (ae & Q ^ ae & oe ^ Q & oe) >>> 0;
  }
  function G(ae, D, Q, W, oe, v) {
    return (D & W ^ D & v ^ W & v) >>> 0;
  }
  function N(ae, D) {
    const Q = y(ae, D, 28), W = y(D, ae, 2), oe = y(D, ae, 7);
    return (Q ^ W ^ oe) >>> 0;
  }
  function T(ae, D) {
    const Q = b(ae, D, 28), W = b(D, ae, 2), oe = b(D, ae, 7);
    return (Q ^ W ^ oe) >>> 0;
  }
  function A(ae, D) {
    const Q = y(ae, D, 14), W = y(ae, D, 18), oe = y(D, ae, 9);
    return (Q ^ W ^ oe) >>> 0;
  }
  function q(ae, D) {
    const Q = b(ae, D, 14), W = b(ae, D, 18), oe = b(D, ae, 9);
    return (Q ^ W ^ oe) >>> 0;
  }
  function _(ae, D) {
    const Q = y(ae, D, 1), W = y(ae, D, 8), oe = h(ae, D, 7);
    return (Q ^ W ^ oe) >>> 0;
  }
  function F(ae, D) {
    const Q = b(ae, D, 1), W = b(ae, D, 8), oe = a(ae, D, 7);
    return (Q ^ W ^ oe) >>> 0;
  }
  function R(ae, D) {
    const Q = y(ae, D, 19), W = y(D, ae, 29), oe = h(ae, D, 6);
    return (Q ^ W ^ oe) >>> 0;
  }
  function L(ae, D) {
    const Q = b(ae, D, 19), W = b(D, ae, 29), oe = a(ae, D, 6);
    return (Q ^ W ^ oe) >>> 0;
  }
  function fe(ae, D) {
    return ae[D++] * 16777216 + ae[D++] * 65536 + ae[D++] * 256 + ae[D];
  }
  function ue(ae, D, Q) {
    return ae[Q++] = D >>> 24, ae[Q++] = D >>> 16, ae[Q++] = D >>> 8, ae[Q++] = D, Q;
  }
  return Vu = n, Vu;
}
var $u = {}, di = {}, ju, C3;
function oy() {
  return C3 || (C3 = 1, ju = [
    "的",
    "一",
    "是",
    "在",
    "不",
    "了",
    "有",
    "和",
    "人",
    "这",
    "中",
    "大",
    "为",
    "上",
    "个",
    "国",
    "我",
    "以",
    "要",
    "他",
    "时",
    "来",
    "用",
    "们",
    "生",
    "到",
    "作",
    "地",
    "于",
    "出",
    "就",
    "分",
    "对",
    "成",
    "会",
    "可",
    "主",
    "发",
    "年",
    "动",
    "同",
    "工",
    "也",
    "能",
    "下",
    "过",
    "子",
    "说",
    "产",
    "种",
    "面",
    "而",
    "方",
    "后",
    "多",
    "定",
    "行",
    "学",
    "法",
    "所",
    "民",
    "得",
    "经",
    "十",
    "三",
    "之",
    "进",
    "着",
    "等",
    "部",
    "度",
    "家",
    "电",
    "力",
    "里",
    "如",
    "水",
    "化",
    "高",
    "自",
    "二",
    "理",
    "起",
    "小",
    "物",
    "现",
    "实",
    "加",
    "量",
    "都",
    "两",
    "体",
    "制",
    "机",
    "当",
    "使",
    "点",
    "从",
    "业",
    "本",
    "去",
    "把",
    "性",
    "好",
    "应",
    "开",
    "它",
    "合",
    "还",
    "因",
    "由",
    "其",
    "些",
    "然",
    "前",
    "外",
    "天",
    "政",
    "四",
    "日",
    "那",
    "社",
    "义",
    "事",
    "平",
    "形",
    "相",
    "全",
    "表",
    "间",
    "样",
    "与",
    "关",
    "各",
    "重",
    "新",
    "线",
    "内",
    "数",
    "正",
    "心",
    "反",
    "你",
    "明",
    "看",
    "原",
    "又",
    "么",
    "利",
    "比",
    "或",
    "但",
    "质",
    "气",
    "第",
    "向",
    "道",
    "命",
    "此",
    "变",
    "条",
    "只",
    "没",
    "结",
    "解",
    "问",
    "意",
    "建",
    "月",
    "公",
    "无",
    "系",
    "军",
    "很",
    "情",
    "者",
    "最",
    "立",
    "代",
    "想",
    "已",
    "通",
    "并",
    "提",
    "直",
    "题",
    "党",
    "程",
    "展",
    "五",
    "果",
    "料",
    "象",
    "员",
    "革",
    "位",
    "入",
    "常",
    "文",
    "总",
    "次",
    "品",
    "式",
    "活",
    "设",
    "及",
    "管",
    "特",
    "件",
    "长",
    "求",
    "老",
    "头",
    "基",
    "资",
    "边",
    "流",
    "路",
    "级",
    "少",
    "图",
    "山",
    "统",
    "接",
    "知",
    "较",
    "将",
    "组",
    "见",
    "计",
    "别",
    "她",
    "手",
    "角",
    "期",
    "根",
    "论",
    "运",
    "农",
    "指",
    "几",
    "九",
    "区",
    "强",
    "放",
    "决",
    "西",
    "被",
    "干",
    "做",
    "必",
    "战",
    "先",
    "回",
    "则",
    "任",
    "取",
    "据",
    "处",
    "队",
    "南",
    "给",
    "色",
    "光",
    "门",
    "即",
    "保",
    "治",
    "北",
    "造",
    "百",
    "规",
    "热",
    "领",
    "七",
    "海",
    "口",
    "东",
    "导",
    "器",
    "压",
    "志",
    "世",
    "金",
    "增",
    "争",
    "济",
    "阶",
    "油",
    "思",
    "术",
    "极",
    "交",
    "受",
    "联",
    "什",
    "认",
    "六",
    "共",
    "权",
    "收",
    "证",
    "改",
    "清",
    "美",
    "再",
    "采",
    "转",
    "更",
    "单",
    "风",
    "切",
    "打",
    "白",
    "教",
    "速",
    "花",
    "带",
    "安",
    "场",
    "身",
    "车",
    "例",
    "真",
    "务",
    "具",
    "万",
    "每",
    "目",
    "至",
    "达",
    "走",
    "积",
    "示",
    "议",
    "声",
    "报",
    "斗",
    "完",
    "类",
    "八",
    "离",
    "华",
    "名",
    "确",
    "才",
    "科",
    "张",
    "信",
    "马",
    "节",
    "话",
    "米",
    "整",
    "空",
    "元",
    "况",
    "今",
    "集",
    "温",
    "传",
    "土",
    "许",
    "步",
    "群",
    "广",
    "石",
    "记",
    "需",
    "段",
    "研",
    "界",
    "拉",
    "林",
    "律",
    "叫",
    "且",
    "究",
    "观",
    "越",
    "织",
    "装",
    "影",
    "算",
    "低",
    "持",
    "音",
    "众",
    "书",
    "布",
    "复",
    "容",
    "儿",
    "须",
    "际",
    "商",
    "非",
    "验",
    "连",
    "断",
    "深",
    "难",
    "近",
    "矿",
    "千",
    "周",
    "委",
    "素",
    "技",
    "备",
    "半",
    "办",
    "青",
    "省",
    "列",
    "习",
    "响",
    "约",
    "支",
    "般",
    "史",
    "感",
    "劳",
    "便",
    "团",
    "往",
    "酸",
    "历",
    "市",
    "克",
    "何",
    "除",
    "消",
    "构",
    "府",
    "称",
    "太",
    "准",
    "精",
    "值",
    "号",
    "率",
    "族",
    "维",
    "划",
    "选",
    "标",
    "写",
    "存",
    "候",
    "毛",
    "亲",
    "快",
    "效",
    "斯",
    "院",
    "查",
    "江",
    "型",
    "眼",
    "王",
    "按",
    "格",
    "养",
    "易",
    "置",
    "派",
    "层",
    "片",
    "始",
    "却",
    "专",
    "状",
    "育",
    "厂",
    "京",
    "识",
    "适",
    "属",
    "圆",
    "包",
    "火",
    "住",
    "调",
    "满",
    "县",
    "局",
    "照",
    "参",
    "红",
    "细",
    "引",
    "听",
    "该",
    "铁",
    "价",
    "严",
    "首",
    "底",
    "液",
    "官",
    "德",
    "随",
    "病",
    "苏",
    "失",
    "尔",
    "死",
    "讲",
    "配",
    "女",
    "黄",
    "推",
    "显",
    "谈",
    "罪",
    "神",
    "艺",
    "呢",
    "席",
    "含",
    "企",
    "望",
    "密",
    "批",
    "营",
    "项",
    "防",
    "举",
    "球",
    "英",
    "氧",
    "势",
    "告",
    "李",
    "台",
    "落",
    "木",
    "帮",
    "轮",
    "破",
    "亚",
    "师",
    "围",
    "注",
    "远",
    "字",
    "材",
    "排",
    "供",
    "河",
    "态",
    "封",
    "另",
    "施",
    "减",
    "树",
    "溶",
    "怎",
    "止",
    "案",
    "言",
    "士",
    "均",
    "武",
    "固",
    "叶",
    "鱼",
    "波",
    "视",
    "仅",
    "费",
    "紧",
    "爱",
    "左",
    "章",
    "早",
    "朝",
    "害",
    "续",
    "轻",
    "服",
    "试",
    "食",
    "充",
    "兵",
    "源",
    "判",
    "护",
    "司",
    "足",
    "某",
    "练",
    "差",
    "致",
    "板",
    "田",
    "降",
    "黑",
    "犯",
    "负",
    "击",
    "范",
    "继",
    "兴",
    "似",
    "余",
    "坚",
    "曲",
    "输",
    "修",
    "故",
    "城",
    "夫",
    "够",
    "送",
    "笔",
    "船",
    "占",
    "右",
    "财",
    "吃",
    "富",
    "春",
    "职",
    "觉",
    "汉",
    "画",
    "功",
    "巴",
    "跟",
    "虽",
    "杂",
    "飞",
    "检",
    "吸",
    "助",
    "升",
    "阳",
    "互",
    "初",
    "创",
    "抗",
    "考",
    "投",
    "坏",
    "策",
    "古",
    "径",
    "换",
    "未",
    "跑",
    "留",
    "钢",
    "曾",
    "端",
    "责",
    "站",
    "简",
    "述",
    "钱",
    "副",
    "尽",
    "帝",
    "射",
    "草",
    "冲",
    "承",
    "独",
    "令",
    "限",
    "阿",
    "宣",
    "环",
    "双",
    "请",
    "超",
    "微",
    "让",
    "控",
    "州",
    "良",
    "轴",
    "找",
    "否",
    "纪",
    "益",
    "依",
    "优",
    "顶",
    "础",
    "载",
    "倒",
    "房",
    "突",
    "坐",
    "粉",
    "敌",
    "略",
    "客",
    "袁",
    "冷",
    "胜",
    "绝",
    "析",
    "块",
    "剂",
    "测",
    "丝",
    "协",
    "诉",
    "念",
    "陈",
    "仍",
    "罗",
    "盐",
    "友",
    "洋",
    "错",
    "苦",
    "夜",
    "刑",
    "移",
    "频",
    "逐",
    "靠",
    "混",
    "母",
    "短",
    "皮",
    "终",
    "聚",
    "汽",
    "村",
    "云",
    "哪",
    "既",
    "距",
    "卫",
    "停",
    "烈",
    "央",
    "察",
    "烧",
    "迅",
    "境",
    "若",
    "印",
    "洲",
    "刻",
    "括",
    "激",
    "孔",
    "搞",
    "甚",
    "室",
    "待",
    "核",
    "校",
    "散",
    "侵",
    "吧",
    "甲",
    "游",
    "久",
    "菜",
    "味",
    "旧",
    "模",
    "湖",
    "货",
    "损",
    "预",
    "阻",
    "毫",
    "普",
    "稳",
    "乙",
    "妈",
    "植",
    "息",
    "扩",
    "银",
    "语",
    "挥",
    "酒",
    "守",
    "拿",
    "序",
    "纸",
    "医",
    "缺",
    "雨",
    "吗",
    "针",
    "刘",
    "啊",
    "急",
    "唱",
    "误",
    "训",
    "愿",
    "审",
    "附",
    "获",
    "茶",
    "鲜",
    "粮",
    "斤",
    "孩",
    "脱",
    "硫",
    "肥",
    "善",
    "龙",
    "演",
    "父",
    "渐",
    "血",
    "欢",
    "械",
    "掌",
    "歌",
    "沙",
    "刚",
    "攻",
    "谓",
    "盾",
    "讨",
    "晚",
    "粒",
    "乱",
    "燃",
    "矛",
    "乎",
    "杀",
    "药",
    "宁",
    "鲁",
    "贵",
    "钟",
    "煤",
    "读",
    "班",
    "伯",
    "香",
    "介",
    "迫",
    "句",
    "丰",
    "培",
    "握",
    "兰",
    "担",
    "弦",
    "蛋",
    "沉",
    "假",
    "穿",
    "执",
    "答",
    "乐",
    "谁",
    "顺",
    "烟",
    "缩",
    "征",
    "脸",
    "喜",
    "松",
    "脚",
    "困",
    "异",
    "免",
    "背",
    "星",
    "福",
    "买",
    "染",
    "井",
    "概",
    "慢",
    "怕",
    "磁",
    "倍",
    "祖",
    "皇",
    "促",
    "静",
    "补",
    "评",
    "翻",
    "肉",
    "践",
    "尼",
    "衣",
    "宽",
    "扬",
    "棉",
    "希",
    "伤",
    "操",
    "垂",
    "秋",
    "宜",
    "氢",
    "套",
    "督",
    "振",
    "架",
    "亮",
    "末",
    "宪",
    "庆",
    "编",
    "牛",
    "触",
    "映",
    "雷",
    "销",
    "诗",
    "座",
    "居",
    "抓",
    "裂",
    "胞",
    "呼",
    "娘",
    "景",
    "威",
    "绿",
    "晶",
    "厚",
    "盟",
    "衡",
    "鸡",
    "孙",
    "延",
    "危",
    "胶",
    "屋",
    "乡",
    "临",
    "陆",
    "顾",
    "掉",
    "呀",
    "灯",
    "岁",
    "措",
    "束",
    "耐",
    "剧",
    "玉",
    "赵",
    "跳",
    "哥",
    "季",
    "课",
    "凯",
    "胡",
    "额",
    "款",
    "绍",
    "卷",
    "齐",
    "伟",
    "蒸",
    "殖",
    "永",
    "宗",
    "苗",
    "川",
    "炉",
    "岩",
    "弱",
    "零",
    "杨",
    "奏",
    "沿",
    "露",
    "杆",
    "探",
    "滑",
    "镇",
    "饭",
    "浓",
    "航",
    "怀",
    "赶",
    "库",
    "夺",
    "伊",
    "灵",
    "税",
    "途",
    "灭",
    "赛",
    "归",
    "召",
    "鼓",
    "播",
    "盘",
    "裁",
    "险",
    "康",
    "唯",
    "录",
    "菌",
    "纯",
    "借",
    "糖",
    "盖",
    "横",
    "符",
    "私",
    "努",
    "堂",
    "域",
    "枪",
    "润",
    "幅",
    "哈",
    "竟",
    "熟",
    "虫",
    "泽",
    "脑",
    "壤",
    "碳",
    "欧",
    "遍",
    "侧",
    "寨",
    "敢",
    "彻",
    "虑",
    "斜",
    "薄",
    "庭",
    "纳",
    "弹",
    "饲",
    "伸",
    "折",
    "麦",
    "湿",
    "暗",
    "荷",
    "瓦",
    "塞",
    "床",
    "筑",
    "恶",
    "户",
    "访",
    "塔",
    "奇",
    "透",
    "梁",
    "刀",
    "旋",
    "迹",
    "卡",
    "氯",
    "遇",
    "份",
    "毒",
    "泥",
    "退",
    "洗",
    "摆",
    "灰",
    "彩",
    "卖",
    "耗",
    "夏",
    "择",
    "忙",
    "铜",
    "献",
    "硬",
    "予",
    "繁",
    "圈",
    "雪",
    "函",
    "亦",
    "抽",
    "篇",
    "阵",
    "阴",
    "丁",
    "尺",
    "追",
    "堆",
    "雄",
    "迎",
    "泛",
    "爸",
    "楼",
    "避",
    "谋",
    "吨",
    "野",
    "猪",
    "旗",
    "累",
    "偏",
    "典",
    "馆",
    "索",
    "秦",
    "脂",
    "潮",
    "爷",
    "豆",
    "忽",
    "托",
    "惊",
    "塑",
    "遗",
    "愈",
    "朱",
    "替",
    "纤",
    "粗",
    "倾",
    "尚",
    "痛",
    "楚",
    "谢",
    "奋",
    "购",
    "磨",
    "君",
    "池",
    "旁",
    "碎",
    "骨",
    "监",
    "捕",
    "弟",
    "暴",
    "割",
    "贯",
    "殊",
    "释",
    "词",
    "亡",
    "壁",
    "顿",
    "宝",
    "午",
    "尘",
    "闻",
    "揭",
    "炮",
    "残",
    "冬",
    "桥",
    "妇",
    "警",
    "综",
    "招",
    "吴",
    "付",
    "浮",
    "遭",
    "徐",
    "您",
    "摇",
    "谷",
    "赞",
    "箱",
    "隔",
    "订",
    "男",
    "吹",
    "园",
    "纷",
    "唐",
    "败",
    "宋",
    "玻",
    "巨",
    "耕",
    "坦",
    "荣",
    "闭",
    "湾",
    "键",
    "凡",
    "驻",
    "锅",
    "救",
    "恩",
    "剥",
    "凝",
    "碱",
    "齿",
    "截",
    "炼",
    "麻",
    "纺",
    "禁",
    "废",
    "盛",
    "版",
    "缓",
    "净",
    "睛",
    "昌",
    "婚",
    "涉",
    "筒",
    "嘴",
    "插",
    "岸",
    "朗",
    "庄",
    "街",
    "藏",
    "姑",
    "贸",
    "腐",
    "奴",
    "啦",
    "惯",
    "乘",
    "伙",
    "恢",
    "匀",
    "纱",
    "扎",
    "辩",
    "耳",
    "彪",
    "臣",
    "亿",
    "璃",
    "抵",
    "脉",
    "秀",
    "萨",
    "俄",
    "网",
    "舞",
    "店",
    "喷",
    "纵",
    "寸",
    "汗",
    "挂",
    "洪",
    "贺",
    "闪",
    "柬",
    "爆",
    "烯",
    "津",
    "稻",
    "墙",
    "软",
    "勇",
    "像",
    "滚",
    "厘",
    "蒙",
    "芳",
    "肯",
    "坡",
    "柱",
    "荡",
    "腿",
    "仪",
    "旅",
    "尾",
    "轧",
    "冰",
    "贡",
    "登",
    "黎",
    "削",
    "钻",
    "勒",
    "逃",
    "障",
    "氨",
    "郭",
    "峰",
    "币",
    "港",
    "伏",
    "轨",
    "亩",
    "毕",
    "擦",
    "莫",
    "刺",
    "浪",
    "秘",
    "援",
    "株",
    "健",
    "售",
    "股",
    "岛",
    "甘",
    "泡",
    "睡",
    "童",
    "铸",
    "汤",
    "阀",
    "休",
    "汇",
    "舍",
    "牧",
    "绕",
    "炸",
    "哲",
    "磷",
    "绩",
    "朋",
    "淡",
    "尖",
    "启",
    "陷",
    "柴",
    "呈",
    "徒",
    "颜",
    "泪",
    "稍",
    "忘",
    "泵",
    "蓝",
    "拖",
    "洞",
    "授",
    "镜",
    "辛",
    "壮",
    "锋",
    "贫",
    "虚",
    "弯",
    "摩",
    "泰",
    "幼",
    "廷",
    "尊",
    "窗",
    "纲",
    "弄",
    "隶",
    "疑",
    "氏",
    "宫",
    "姐",
    "震",
    "瑞",
    "怪",
    "尤",
    "琴",
    "循",
    "描",
    "膜",
    "违",
    "夹",
    "腰",
    "缘",
    "珠",
    "穷",
    "森",
    "枝",
    "竹",
    "沟",
    "催",
    "绳",
    "忆",
    "邦",
    "剩",
    "幸",
    "浆",
    "栏",
    "拥",
    "牙",
    "贮",
    "礼",
    "滤",
    "钠",
    "纹",
    "罢",
    "拍",
    "咱",
    "喊",
    "袖",
    "埃",
    "勤",
    "罚",
    "焦",
    "潜",
    "伍",
    "墨",
    "欲",
    "缝",
    "姓",
    "刊",
    "饱",
    "仿",
    "奖",
    "铝",
    "鬼",
    "丽",
    "跨",
    "默",
    "挖",
    "链",
    "扫",
    "喝",
    "袋",
    "炭",
    "污",
    "幕",
    "诸",
    "弧",
    "励",
    "梅",
    "奶",
    "洁",
    "灾",
    "舟",
    "鉴",
    "苯",
    "讼",
    "抱",
    "毁",
    "懂",
    "寒",
    "智",
    "埔",
    "寄",
    "届",
    "跃",
    "渡",
    "挑",
    "丹",
    "艰",
    "贝",
    "碰",
    "拔",
    "爹",
    "戴",
    "码",
    "梦",
    "芽",
    "熔",
    "赤",
    "渔",
    "哭",
    "敬",
    "颗",
    "奔",
    "铅",
    "仲",
    "虎",
    "稀",
    "妹",
    "乏",
    "珍",
    "申",
    "桌",
    "遵",
    "允",
    "隆",
    "螺",
    "仓",
    "魏",
    "锐",
    "晓",
    "氮",
    "兼",
    "隐",
    "碍",
    "赫",
    "拨",
    "忠",
    "肃",
    "缸",
    "牵",
    "抢",
    "博",
    "巧",
    "壳",
    "兄",
    "杜",
    "讯",
    "诚",
    "碧",
    "祥",
    "柯",
    "页",
    "巡",
    "矩",
    "悲",
    "灌",
    "龄",
    "伦",
    "票",
    "寻",
    "桂",
    "铺",
    "圣",
    "恐",
    "恰",
    "郑",
    "趣",
    "抬",
    "荒",
    "腾",
    "贴",
    "柔",
    "滴",
    "猛",
    "阔",
    "辆",
    "妻",
    "填",
    "撤",
    "储",
    "签",
    "闹",
    "扰",
    "紫",
    "砂",
    "递",
    "戏",
    "吊",
    "陶",
    "伐",
    "喂",
    "疗",
    "瓶",
    "婆",
    "抚",
    "臂",
    "摸",
    "忍",
    "虾",
    "蜡",
    "邻",
    "胸",
    "巩",
    "挤",
    "偶",
    "弃",
    "槽",
    "劲",
    "乳",
    "邓",
    "吉",
    "仁",
    "烂",
    "砖",
    "租",
    "乌",
    "舰",
    "伴",
    "瓜",
    "浅",
    "丙",
    "暂",
    "燥",
    "橡",
    "柳",
    "迷",
    "暖",
    "牌",
    "秧",
    "胆",
    "详",
    "簧",
    "踏",
    "瓷",
    "谱",
    "呆",
    "宾",
    "糊",
    "洛",
    "辉",
    "愤",
    "竞",
    "隙",
    "怒",
    "粘",
    "乃",
    "绪",
    "肩",
    "籍",
    "敏",
    "涂",
    "熙",
    "皆",
    "侦",
    "悬",
    "掘",
    "享",
    "纠",
    "醒",
    "狂",
    "锁",
    "淀",
    "恨",
    "牲",
    "霸",
    "爬",
    "赏",
    "逆",
    "玩",
    "陵",
    "祝",
    "秒",
    "浙",
    "貌",
    "役",
    "彼",
    "悉",
    "鸭",
    "趋",
    "凤",
    "晨",
    "畜",
    "辈",
    "秩",
    "卵",
    "署",
    "梯",
    "炎",
    "滩",
    "棋",
    "驱",
    "筛",
    "峡",
    "冒",
    "啥",
    "寿",
    "译",
    "浸",
    "泉",
    "帽",
    "迟",
    "硅",
    "疆",
    "贷",
    "漏",
    "稿",
    "冠",
    "嫩",
    "胁",
    "芯",
    "牢",
    "叛",
    "蚀",
    "奥",
    "鸣",
    "岭",
    "羊",
    "凭",
    "串",
    "塘",
    "绘",
    "酵",
    "融",
    "盆",
    "锡",
    "庙",
    "筹",
    "冻",
    "辅",
    "摄",
    "袭",
    "筋",
    "拒",
    "僚",
    "旱",
    "钾",
    "鸟",
    "漆",
    "沈",
    "眉",
    "疏",
    "添",
    "棒",
    "穗",
    "硝",
    "韩",
    "逼",
    "扭",
    "侨",
    "凉",
    "挺",
    "碗",
    "栽",
    "炒",
    "杯",
    "患",
    "馏",
    "劝",
    "豪",
    "辽",
    "勃",
    "鸿",
    "旦",
    "吏",
    "拜",
    "狗",
    "埋",
    "辊",
    "掩",
    "饮",
    "搬",
    "骂",
    "辞",
    "勾",
    "扣",
    "估",
    "蒋",
    "绒",
    "雾",
    "丈",
    "朵",
    "姆",
    "拟",
    "宇",
    "辑",
    "陕",
    "雕",
    "偿",
    "蓄",
    "崇",
    "剪",
    "倡",
    "厅",
    "咬",
    "驶",
    "薯",
    "刷",
    "斥",
    "番",
    "赋",
    "奉",
    "佛",
    "浇",
    "漫",
    "曼",
    "扇",
    "钙",
    "桃",
    "扶",
    "仔",
    "返",
    "俗",
    "亏",
    "腔",
    "鞋",
    "棱",
    "覆",
    "框",
    "悄",
    "叔",
    "撞",
    "骗",
    "勘",
    "旺",
    "沸",
    "孤",
    "吐",
    "孟",
    "渠",
    "屈",
    "疾",
    "妙",
    "惜",
    "仰",
    "狠",
    "胀",
    "谐",
    "抛",
    "霉",
    "桑",
    "岗",
    "嘛",
    "衰",
    "盗",
    "渗",
    "脏",
    "赖",
    "涌",
    "甜",
    "曹",
    "阅",
    "肌",
    "哩",
    "厉",
    "烃",
    "纬",
    "毅",
    "昨",
    "伪",
    "症",
    "煮",
    "叹",
    "钉",
    "搭",
    "茎",
    "笼",
    "酷",
    "偷",
    "弓",
    "锥",
    "恒",
    "杰",
    "坑",
    "鼻",
    "翼",
    "纶",
    "叙",
    "狱",
    "逮",
    "罐",
    "络",
    "棚",
    "抑",
    "膨",
    "蔬",
    "寺",
    "骤",
    "穆",
    "冶",
    "枯",
    "册",
    "尸",
    "凸",
    "绅",
    "坯",
    "牺",
    "焰",
    "轰",
    "欣",
    "晋",
    "瘦",
    "御",
    "锭",
    "锦",
    "丧",
    "旬",
    "锻",
    "垄",
    "搜",
    "扑",
    "邀",
    "亭",
    "酯",
    "迈",
    "舒",
    "脆",
    "酶",
    "闲",
    "忧",
    "酚",
    "顽",
    "羽",
    "涨",
    "卸",
    "仗",
    "陪",
    "辟",
    "惩",
    "杭",
    "姚",
    "肚",
    "捉",
    "飘",
    "漂",
    "昆",
    "欺",
    "吾",
    "郎",
    "烷",
    "汁",
    "呵",
    "饰",
    "萧",
    "雅",
    "邮",
    "迁",
    "燕",
    "撒",
    "姻",
    "赴",
    "宴",
    "烦",
    "债",
    "帐",
    "斑",
    "铃",
    "旨",
    "醇",
    "董",
    "饼",
    "雏",
    "姿",
    "拌",
    "傅",
    "腹",
    "妥",
    "揉",
    "贤",
    "拆",
    "歪",
    "葡",
    "胺",
    "丢",
    "浩",
    "徽",
    "昂",
    "垫",
    "挡",
    "览",
    "贪",
    "慰",
    "缴",
    "汪",
    "慌",
    "冯",
    "诺",
    "姜",
    "谊",
    "凶",
    "劣",
    "诬",
    "耀",
    "昏",
    "躺",
    "盈",
    "骑",
    "乔",
    "溪",
    "丛",
    "卢",
    "抹",
    "闷",
    "咨",
    "刮",
    "驾",
    "缆",
    "悟",
    "摘",
    "铒",
    "掷",
    "颇",
    "幻",
    "柄",
    "惠",
    "惨",
    "佳",
    "仇",
    "腊",
    "窝",
    "涤",
    "剑",
    "瞧",
    "堡",
    "泼",
    "葱",
    "罩",
    "霍",
    "捞",
    "胎",
    "苍",
    "滨",
    "俩",
    "捅",
    "湘",
    "砍",
    "霞",
    "邵",
    "萄",
    "疯",
    "淮",
    "遂",
    "熊",
    "粪",
    "烘",
    "宿",
    "档",
    "戈",
    "驳",
    "嫂",
    "裕",
    "徙",
    "箭",
    "捐",
    "肠",
    "撑",
    "晒",
    "辨",
    "殿",
    "莲",
    "摊",
    "搅",
    "酱",
    "屏",
    "疫",
    "哀",
    "蔡",
    "堵",
    "沫",
    "皱",
    "畅",
    "叠",
    "阁",
    "莱",
    "敲",
    "辖",
    "钩",
    "痕",
    "坝",
    "巷",
    "饿",
    "祸",
    "丘",
    "玄",
    "溜",
    "曰",
    "逻",
    "彭",
    "尝",
    "卿",
    "妨",
    "艇",
    "吞",
    "韦",
    "怨",
    "矮",
    "歇"
  ]), ju;
}
var Yu, D3;
function ay() {
  return D3 || (D3 = 1, Yu = [
    "的",
    "一",
    "是",
    "在",
    "不",
    "了",
    "有",
    "和",
    "人",
    "這",
    "中",
    "大",
    "為",
    "上",
    "個",
    "國",
    "我",
    "以",
    "要",
    "他",
    "時",
    "來",
    "用",
    "們",
    "生",
    "到",
    "作",
    "地",
    "於",
    "出",
    "就",
    "分",
    "對",
    "成",
    "會",
    "可",
    "主",
    "發",
    "年",
    "動",
    "同",
    "工",
    "也",
    "能",
    "下",
    "過",
    "子",
    "說",
    "產",
    "種",
    "面",
    "而",
    "方",
    "後",
    "多",
    "定",
    "行",
    "學",
    "法",
    "所",
    "民",
    "得",
    "經",
    "十",
    "三",
    "之",
    "進",
    "著",
    "等",
    "部",
    "度",
    "家",
    "電",
    "力",
    "裡",
    "如",
    "水",
    "化",
    "高",
    "自",
    "二",
    "理",
    "起",
    "小",
    "物",
    "現",
    "實",
    "加",
    "量",
    "都",
    "兩",
    "體",
    "制",
    "機",
    "當",
    "使",
    "點",
    "從",
    "業",
    "本",
    "去",
    "把",
    "性",
    "好",
    "應",
    "開",
    "它",
    "合",
    "還",
    "因",
    "由",
    "其",
    "些",
    "然",
    "前",
    "外",
    "天",
    "政",
    "四",
    "日",
    "那",
    "社",
    "義",
    "事",
    "平",
    "形",
    "相",
    "全",
    "表",
    "間",
    "樣",
    "與",
    "關",
    "各",
    "重",
    "新",
    "線",
    "內",
    "數",
    "正",
    "心",
    "反",
    "你",
    "明",
    "看",
    "原",
    "又",
    "麼",
    "利",
    "比",
    "或",
    "但",
    "質",
    "氣",
    "第",
    "向",
    "道",
    "命",
    "此",
    "變",
    "條",
    "只",
    "沒",
    "結",
    "解",
    "問",
    "意",
    "建",
    "月",
    "公",
    "無",
    "系",
    "軍",
    "很",
    "情",
    "者",
    "最",
    "立",
    "代",
    "想",
    "已",
    "通",
    "並",
    "提",
    "直",
    "題",
    "黨",
    "程",
    "展",
    "五",
    "果",
    "料",
    "象",
    "員",
    "革",
    "位",
    "入",
    "常",
    "文",
    "總",
    "次",
    "品",
    "式",
    "活",
    "設",
    "及",
    "管",
    "特",
    "件",
    "長",
    "求",
    "老",
    "頭",
    "基",
    "資",
    "邊",
    "流",
    "路",
    "級",
    "少",
    "圖",
    "山",
    "統",
    "接",
    "知",
    "較",
    "將",
    "組",
    "見",
    "計",
    "別",
    "她",
    "手",
    "角",
    "期",
    "根",
    "論",
    "運",
    "農",
    "指",
    "幾",
    "九",
    "區",
    "強",
    "放",
    "決",
    "西",
    "被",
    "幹",
    "做",
    "必",
    "戰",
    "先",
    "回",
    "則",
    "任",
    "取",
    "據",
    "處",
    "隊",
    "南",
    "給",
    "色",
    "光",
    "門",
    "即",
    "保",
    "治",
    "北",
    "造",
    "百",
    "規",
    "熱",
    "領",
    "七",
    "海",
    "口",
    "東",
    "導",
    "器",
    "壓",
    "志",
    "世",
    "金",
    "增",
    "爭",
    "濟",
    "階",
    "油",
    "思",
    "術",
    "極",
    "交",
    "受",
    "聯",
    "什",
    "認",
    "六",
    "共",
    "權",
    "收",
    "證",
    "改",
    "清",
    "美",
    "再",
    "採",
    "轉",
    "更",
    "單",
    "風",
    "切",
    "打",
    "白",
    "教",
    "速",
    "花",
    "帶",
    "安",
    "場",
    "身",
    "車",
    "例",
    "真",
    "務",
    "具",
    "萬",
    "每",
    "目",
    "至",
    "達",
    "走",
    "積",
    "示",
    "議",
    "聲",
    "報",
    "鬥",
    "完",
    "類",
    "八",
    "離",
    "華",
    "名",
    "確",
    "才",
    "科",
    "張",
    "信",
    "馬",
    "節",
    "話",
    "米",
    "整",
    "空",
    "元",
    "況",
    "今",
    "集",
    "溫",
    "傳",
    "土",
    "許",
    "步",
    "群",
    "廣",
    "石",
    "記",
    "需",
    "段",
    "研",
    "界",
    "拉",
    "林",
    "律",
    "叫",
    "且",
    "究",
    "觀",
    "越",
    "織",
    "裝",
    "影",
    "算",
    "低",
    "持",
    "音",
    "眾",
    "書",
    "布",
    "复",
    "容",
    "兒",
    "須",
    "際",
    "商",
    "非",
    "驗",
    "連",
    "斷",
    "深",
    "難",
    "近",
    "礦",
    "千",
    "週",
    "委",
    "素",
    "技",
    "備",
    "半",
    "辦",
    "青",
    "省",
    "列",
    "習",
    "響",
    "約",
    "支",
    "般",
    "史",
    "感",
    "勞",
    "便",
    "團",
    "往",
    "酸",
    "歷",
    "市",
    "克",
    "何",
    "除",
    "消",
    "構",
    "府",
    "稱",
    "太",
    "準",
    "精",
    "值",
    "號",
    "率",
    "族",
    "維",
    "劃",
    "選",
    "標",
    "寫",
    "存",
    "候",
    "毛",
    "親",
    "快",
    "效",
    "斯",
    "院",
    "查",
    "江",
    "型",
    "眼",
    "王",
    "按",
    "格",
    "養",
    "易",
    "置",
    "派",
    "層",
    "片",
    "始",
    "卻",
    "專",
    "狀",
    "育",
    "廠",
    "京",
    "識",
    "適",
    "屬",
    "圓",
    "包",
    "火",
    "住",
    "調",
    "滿",
    "縣",
    "局",
    "照",
    "參",
    "紅",
    "細",
    "引",
    "聽",
    "該",
    "鐵",
    "價",
    "嚴",
    "首",
    "底",
    "液",
    "官",
    "德",
    "隨",
    "病",
    "蘇",
    "失",
    "爾",
    "死",
    "講",
    "配",
    "女",
    "黃",
    "推",
    "顯",
    "談",
    "罪",
    "神",
    "藝",
    "呢",
    "席",
    "含",
    "企",
    "望",
    "密",
    "批",
    "營",
    "項",
    "防",
    "舉",
    "球",
    "英",
    "氧",
    "勢",
    "告",
    "李",
    "台",
    "落",
    "木",
    "幫",
    "輪",
    "破",
    "亞",
    "師",
    "圍",
    "注",
    "遠",
    "字",
    "材",
    "排",
    "供",
    "河",
    "態",
    "封",
    "另",
    "施",
    "減",
    "樹",
    "溶",
    "怎",
    "止",
    "案",
    "言",
    "士",
    "均",
    "武",
    "固",
    "葉",
    "魚",
    "波",
    "視",
    "僅",
    "費",
    "緊",
    "愛",
    "左",
    "章",
    "早",
    "朝",
    "害",
    "續",
    "輕",
    "服",
    "試",
    "食",
    "充",
    "兵",
    "源",
    "判",
    "護",
    "司",
    "足",
    "某",
    "練",
    "差",
    "致",
    "板",
    "田",
    "降",
    "黑",
    "犯",
    "負",
    "擊",
    "范",
    "繼",
    "興",
    "似",
    "餘",
    "堅",
    "曲",
    "輸",
    "修",
    "故",
    "城",
    "夫",
    "夠",
    "送",
    "筆",
    "船",
    "佔",
    "右",
    "財",
    "吃",
    "富",
    "春",
    "職",
    "覺",
    "漢",
    "畫",
    "功",
    "巴",
    "跟",
    "雖",
    "雜",
    "飛",
    "檢",
    "吸",
    "助",
    "昇",
    "陽",
    "互",
    "初",
    "創",
    "抗",
    "考",
    "投",
    "壞",
    "策",
    "古",
    "徑",
    "換",
    "未",
    "跑",
    "留",
    "鋼",
    "曾",
    "端",
    "責",
    "站",
    "簡",
    "述",
    "錢",
    "副",
    "盡",
    "帝",
    "射",
    "草",
    "衝",
    "承",
    "獨",
    "令",
    "限",
    "阿",
    "宣",
    "環",
    "雙",
    "請",
    "超",
    "微",
    "讓",
    "控",
    "州",
    "良",
    "軸",
    "找",
    "否",
    "紀",
    "益",
    "依",
    "優",
    "頂",
    "礎",
    "載",
    "倒",
    "房",
    "突",
    "坐",
    "粉",
    "敵",
    "略",
    "客",
    "袁",
    "冷",
    "勝",
    "絕",
    "析",
    "塊",
    "劑",
    "測",
    "絲",
    "協",
    "訴",
    "念",
    "陳",
    "仍",
    "羅",
    "鹽",
    "友",
    "洋",
    "錯",
    "苦",
    "夜",
    "刑",
    "移",
    "頻",
    "逐",
    "靠",
    "混",
    "母",
    "短",
    "皮",
    "終",
    "聚",
    "汽",
    "村",
    "雲",
    "哪",
    "既",
    "距",
    "衛",
    "停",
    "烈",
    "央",
    "察",
    "燒",
    "迅",
    "境",
    "若",
    "印",
    "洲",
    "刻",
    "括",
    "激",
    "孔",
    "搞",
    "甚",
    "室",
    "待",
    "核",
    "校",
    "散",
    "侵",
    "吧",
    "甲",
    "遊",
    "久",
    "菜",
    "味",
    "舊",
    "模",
    "湖",
    "貨",
    "損",
    "預",
    "阻",
    "毫",
    "普",
    "穩",
    "乙",
    "媽",
    "植",
    "息",
    "擴",
    "銀",
    "語",
    "揮",
    "酒",
    "守",
    "拿",
    "序",
    "紙",
    "醫",
    "缺",
    "雨",
    "嗎",
    "針",
    "劉",
    "啊",
    "急",
    "唱",
    "誤",
    "訓",
    "願",
    "審",
    "附",
    "獲",
    "茶",
    "鮮",
    "糧",
    "斤",
    "孩",
    "脫",
    "硫",
    "肥",
    "善",
    "龍",
    "演",
    "父",
    "漸",
    "血",
    "歡",
    "械",
    "掌",
    "歌",
    "沙",
    "剛",
    "攻",
    "謂",
    "盾",
    "討",
    "晚",
    "粒",
    "亂",
    "燃",
    "矛",
    "乎",
    "殺",
    "藥",
    "寧",
    "魯",
    "貴",
    "鐘",
    "煤",
    "讀",
    "班",
    "伯",
    "香",
    "介",
    "迫",
    "句",
    "豐",
    "培",
    "握",
    "蘭",
    "擔",
    "弦",
    "蛋",
    "沉",
    "假",
    "穿",
    "執",
    "答",
    "樂",
    "誰",
    "順",
    "煙",
    "縮",
    "徵",
    "臉",
    "喜",
    "松",
    "腳",
    "困",
    "異",
    "免",
    "背",
    "星",
    "福",
    "買",
    "染",
    "井",
    "概",
    "慢",
    "怕",
    "磁",
    "倍",
    "祖",
    "皇",
    "促",
    "靜",
    "補",
    "評",
    "翻",
    "肉",
    "踐",
    "尼",
    "衣",
    "寬",
    "揚",
    "棉",
    "希",
    "傷",
    "操",
    "垂",
    "秋",
    "宜",
    "氫",
    "套",
    "督",
    "振",
    "架",
    "亮",
    "末",
    "憲",
    "慶",
    "編",
    "牛",
    "觸",
    "映",
    "雷",
    "銷",
    "詩",
    "座",
    "居",
    "抓",
    "裂",
    "胞",
    "呼",
    "娘",
    "景",
    "威",
    "綠",
    "晶",
    "厚",
    "盟",
    "衡",
    "雞",
    "孫",
    "延",
    "危",
    "膠",
    "屋",
    "鄉",
    "臨",
    "陸",
    "顧",
    "掉",
    "呀",
    "燈",
    "歲",
    "措",
    "束",
    "耐",
    "劇",
    "玉",
    "趙",
    "跳",
    "哥",
    "季",
    "課",
    "凱",
    "胡",
    "額",
    "款",
    "紹",
    "卷",
    "齊",
    "偉",
    "蒸",
    "殖",
    "永",
    "宗",
    "苗",
    "川",
    "爐",
    "岩",
    "弱",
    "零",
    "楊",
    "奏",
    "沿",
    "露",
    "桿",
    "探",
    "滑",
    "鎮",
    "飯",
    "濃",
    "航",
    "懷",
    "趕",
    "庫",
    "奪",
    "伊",
    "靈",
    "稅",
    "途",
    "滅",
    "賽",
    "歸",
    "召",
    "鼓",
    "播",
    "盤",
    "裁",
    "險",
    "康",
    "唯",
    "錄",
    "菌",
    "純",
    "借",
    "糖",
    "蓋",
    "橫",
    "符",
    "私",
    "努",
    "堂",
    "域",
    "槍",
    "潤",
    "幅",
    "哈",
    "竟",
    "熟",
    "蟲",
    "澤",
    "腦",
    "壤",
    "碳",
    "歐",
    "遍",
    "側",
    "寨",
    "敢",
    "徹",
    "慮",
    "斜",
    "薄",
    "庭",
    "納",
    "彈",
    "飼",
    "伸",
    "折",
    "麥",
    "濕",
    "暗",
    "荷",
    "瓦",
    "塞",
    "床",
    "築",
    "惡",
    "戶",
    "訪",
    "塔",
    "奇",
    "透",
    "梁",
    "刀",
    "旋",
    "跡",
    "卡",
    "氯",
    "遇",
    "份",
    "毒",
    "泥",
    "退",
    "洗",
    "擺",
    "灰",
    "彩",
    "賣",
    "耗",
    "夏",
    "擇",
    "忙",
    "銅",
    "獻",
    "硬",
    "予",
    "繁",
    "圈",
    "雪",
    "函",
    "亦",
    "抽",
    "篇",
    "陣",
    "陰",
    "丁",
    "尺",
    "追",
    "堆",
    "雄",
    "迎",
    "泛",
    "爸",
    "樓",
    "避",
    "謀",
    "噸",
    "野",
    "豬",
    "旗",
    "累",
    "偏",
    "典",
    "館",
    "索",
    "秦",
    "脂",
    "潮",
    "爺",
    "豆",
    "忽",
    "托",
    "驚",
    "塑",
    "遺",
    "愈",
    "朱",
    "替",
    "纖",
    "粗",
    "傾",
    "尚",
    "痛",
    "楚",
    "謝",
    "奮",
    "購",
    "磨",
    "君",
    "池",
    "旁",
    "碎",
    "骨",
    "監",
    "捕",
    "弟",
    "暴",
    "割",
    "貫",
    "殊",
    "釋",
    "詞",
    "亡",
    "壁",
    "頓",
    "寶",
    "午",
    "塵",
    "聞",
    "揭",
    "炮",
    "殘",
    "冬",
    "橋",
    "婦",
    "警",
    "綜",
    "招",
    "吳",
    "付",
    "浮",
    "遭",
    "徐",
    "您",
    "搖",
    "谷",
    "贊",
    "箱",
    "隔",
    "訂",
    "男",
    "吹",
    "園",
    "紛",
    "唐",
    "敗",
    "宋",
    "玻",
    "巨",
    "耕",
    "坦",
    "榮",
    "閉",
    "灣",
    "鍵",
    "凡",
    "駐",
    "鍋",
    "救",
    "恩",
    "剝",
    "凝",
    "鹼",
    "齒",
    "截",
    "煉",
    "麻",
    "紡",
    "禁",
    "廢",
    "盛",
    "版",
    "緩",
    "淨",
    "睛",
    "昌",
    "婚",
    "涉",
    "筒",
    "嘴",
    "插",
    "岸",
    "朗",
    "莊",
    "街",
    "藏",
    "姑",
    "貿",
    "腐",
    "奴",
    "啦",
    "慣",
    "乘",
    "夥",
    "恢",
    "勻",
    "紗",
    "扎",
    "辯",
    "耳",
    "彪",
    "臣",
    "億",
    "璃",
    "抵",
    "脈",
    "秀",
    "薩",
    "俄",
    "網",
    "舞",
    "店",
    "噴",
    "縱",
    "寸",
    "汗",
    "掛",
    "洪",
    "賀",
    "閃",
    "柬",
    "爆",
    "烯",
    "津",
    "稻",
    "牆",
    "軟",
    "勇",
    "像",
    "滾",
    "厘",
    "蒙",
    "芳",
    "肯",
    "坡",
    "柱",
    "盪",
    "腿",
    "儀",
    "旅",
    "尾",
    "軋",
    "冰",
    "貢",
    "登",
    "黎",
    "削",
    "鑽",
    "勒",
    "逃",
    "障",
    "氨",
    "郭",
    "峰",
    "幣",
    "港",
    "伏",
    "軌",
    "畝",
    "畢",
    "擦",
    "莫",
    "刺",
    "浪",
    "秘",
    "援",
    "株",
    "健",
    "售",
    "股",
    "島",
    "甘",
    "泡",
    "睡",
    "童",
    "鑄",
    "湯",
    "閥",
    "休",
    "匯",
    "舍",
    "牧",
    "繞",
    "炸",
    "哲",
    "磷",
    "績",
    "朋",
    "淡",
    "尖",
    "啟",
    "陷",
    "柴",
    "呈",
    "徒",
    "顏",
    "淚",
    "稍",
    "忘",
    "泵",
    "藍",
    "拖",
    "洞",
    "授",
    "鏡",
    "辛",
    "壯",
    "鋒",
    "貧",
    "虛",
    "彎",
    "摩",
    "泰",
    "幼",
    "廷",
    "尊",
    "窗",
    "綱",
    "弄",
    "隸",
    "疑",
    "氏",
    "宮",
    "姐",
    "震",
    "瑞",
    "怪",
    "尤",
    "琴",
    "循",
    "描",
    "膜",
    "違",
    "夾",
    "腰",
    "緣",
    "珠",
    "窮",
    "森",
    "枝",
    "竹",
    "溝",
    "催",
    "繩",
    "憶",
    "邦",
    "剩",
    "幸",
    "漿",
    "欄",
    "擁",
    "牙",
    "貯",
    "禮",
    "濾",
    "鈉",
    "紋",
    "罷",
    "拍",
    "咱",
    "喊",
    "袖",
    "埃",
    "勤",
    "罰",
    "焦",
    "潛",
    "伍",
    "墨",
    "欲",
    "縫",
    "姓",
    "刊",
    "飽",
    "仿",
    "獎",
    "鋁",
    "鬼",
    "麗",
    "跨",
    "默",
    "挖",
    "鏈",
    "掃",
    "喝",
    "袋",
    "炭",
    "污",
    "幕",
    "諸",
    "弧",
    "勵",
    "梅",
    "奶",
    "潔",
    "災",
    "舟",
    "鑑",
    "苯",
    "訟",
    "抱",
    "毀",
    "懂",
    "寒",
    "智",
    "埔",
    "寄",
    "屆",
    "躍",
    "渡",
    "挑",
    "丹",
    "艱",
    "貝",
    "碰",
    "拔",
    "爹",
    "戴",
    "碼",
    "夢",
    "芽",
    "熔",
    "赤",
    "漁",
    "哭",
    "敬",
    "顆",
    "奔",
    "鉛",
    "仲",
    "虎",
    "稀",
    "妹",
    "乏",
    "珍",
    "申",
    "桌",
    "遵",
    "允",
    "隆",
    "螺",
    "倉",
    "魏",
    "銳",
    "曉",
    "氮",
    "兼",
    "隱",
    "礙",
    "赫",
    "撥",
    "忠",
    "肅",
    "缸",
    "牽",
    "搶",
    "博",
    "巧",
    "殼",
    "兄",
    "杜",
    "訊",
    "誠",
    "碧",
    "祥",
    "柯",
    "頁",
    "巡",
    "矩",
    "悲",
    "灌",
    "齡",
    "倫",
    "票",
    "尋",
    "桂",
    "鋪",
    "聖",
    "恐",
    "恰",
    "鄭",
    "趣",
    "抬",
    "荒",
    "騰",
    "貼",
    "柔",
    "滴",
    "猛",
    "闊",
    "輛",
    "妻",
    "填",
    "撤",
    "儲",
    "簽",
    "鬧",
    "擾",
    "紫",
    "砂",
    "遞",
    "戲",
    "吊",
    "陶",
    "伐",
    "餵",
    "療",
    "瓶",
    "婆",
    "撫",
    "臂",
    "摸",
    "忍",
    "蝦",
    "蠟",
    "鄰",
    "胸",
    "鞏",
    "擠",
    "偶",
    "棄",
    "槽",
    "勁",
    "乳",
    "鄧",
    "吉",
    "仁",
    "爛",
    "磚",
    "租",
    "烏",
    "艦",
    "伴",
    "瓜",
    "淺",
    "丙",
    "暫",
    "燥",
    "橡",
    "柳",
    "迷",
    "暖",
    "牌",
    "秧",
    "膽",
    "詳",
    "簧",
    "踏",
    "瓷",
    "譜",
    "呆",
    "賓",
    "糊",
    "洛",
    "輝",
    "憤",
    "競",
    "隙",
    "怒",
    "粘",
    "乃",
    "緒",
    "肩",
    "籍",
    "敏",
    "塗",
    "熙",
    "皆",
    "偵",
    "懸",
    "掘",
    "享",
    "糾",
    "醒",
    "狂",
    "鎖",
    "淀",
    "恨",
    "牲",
    "霸",
    "爬",
    "賞",
    "逆",
    "玩",
    "陵",
    "祝",
    "秒",
    "浙",
    "貌",
    "役",
    "彼",
    "悉",
    "鴨",
    "趨",
    "鳳",
    "晨",
    "畜",
    "輩",
    "秩",
    "卵",
    "署",
    "梯",
    "炎",
    "灘",
    "棋",
    "驅",
    "篩",
    "峽",
    "冒",
    "啥",
    "壽",
    "譯",
    "浸",
    "泉",
    "帽",
    "遲",
    "矽",
    "疆",
    "貸",
    "漏",
    "稿",
    "冠",
    "嫩",
    "脅",
    "芯",
    "牢",
    "叛",
    "蝕",
    "奧",
    "鳴",
    "嶺",
    "羊",
    "憑",
    "串",
    "塘",
    "繪",
    "酵",
    "融",
    "盆",
    "錫",
    "廟",
    "籌",
    "凍",
    "輔",
    "攝",
    "襲",
    "筋",
    "拒",
    "僚",
    "旱",
    "鉀",
    "鳥",
    "漆",
    "沈",
    "眉",
    "疏",
    "添",
    "棒",
    "穗",
    "硝",
    "韓",
    "逼",
    "扭",
    "僑",
    "涼",
    "挺",
    "碗",
    "栽",
    "炒",
    "杯",
    "患",
    "餾",
    "勸",
    "豪",
    "遼",
    "勃",
    "鴻",
    "旦",
    "吏",
    "拜",
    "狗",
    "埋",
    "輥",
    "掩",
    "飲",
    "搬",
    "罵",
    "辭",
    "勾",
    "扣",
    "估",
    "蔣",
    "絨",
    "霧",
    "丈",
    "朵",
    "姆",
    "擬",
    "宇",
    "輯",
    "陝",
    "雕",
    "償",
    "蓄",
    "崇",
    "剪",
    "倡",
    "廳",
    "咬",
    "駛",
    "薯",
    "刷",
    "斥",
    "番",
    "賦",
    "奉",
    "佛",
    "澆",
    "漫",
    "曼",
    "扇",
    "鈣",
    "桃",
    "扶",
    "仔",
    "返",
    "俗",
    "虧",
    "腔",
    "鞋",
    "棱",
    "覆",
    "框",
    "悄",
    "叔",
    "撞",
    "騙",
    "勘",
    "旺",
    "沸",
    "孤",
    "吐",
    "孟",
    "渠",
    "屈",
    "疾",
    "妙",
    "惜",
    "仰",
    "狠",
    "脹",
    "諧",
    "拋",
    "黴",
    "桑",
    "崗",
    "嘛",
    "衰",
    "盜",
    "滲",
    "臟",
    "賴",
    "湧",
    "甜",
    "曹",
    "閱",
    "肌",
    "哩",
    "厲",
    "烴",
    "緯",
    "毅",
    "昨",
    "偽",
    "症",
    "煮",
    "嘆",
    "釘",
    "搭",
    "莖",
    "籠",
    "酷",
    "偷",
    "弓",
    "錐",
    "恆",
    "傑",
    "坑",
    "鼻",
    "翼",
    "綸",
    "敘",
    "獄",
    "逮",
    "罐",
    "絡",
    "棚",
    "抑",
    "膨",
    "蔬",
    "寺",
    "驟",
    "穆",
    "冶",
    "枯",
    "冊",
    "屍",
    "凸",
    "紳",
    "坯",
    "犧",
    "焰",
    "轟",
    "欣",
    "晉",
    "瘦",
    "禦",
    "錠",
    "錦",
    "喪",
    "旬",
    "鍛",
    "壟",
    "搜",
    "撲",
    "邀",
    "亭",
    "酯",
    "邁",
    "舒",
    "脆",
    "酶",
    "閒",
    "憂",
    "酚",
    "頑",
    "羽",
    "漲",
    "卸",
    "仗",
    "陪",
    "闢",
    "懲",
    "杭",
    "姚",
    "肚",
    "捉",
    "飄",
    "漂",
    "昆",
    "欺",
    "吾",
    "郎",
    "烷",
    "汁",
    "呵",
    "飾",
    "蕭",
    "雅",
    "郵",
    "遷",
    "燕",
    "撒",
    "姻",
    "赴",
    "宴",
    "煩",
    "債",
    "帳",
    "斑",
    "鈴",
    "旨",
    "醇",
    "董",
    "餅",
    "雛",
    "姿",
    "拌",
    "傅",
    "腹",
    "妥",
    "揉",
    "賢",
    "拆",
    "歪",
    "葡",
    "胺",
    "丟",
    "浩",
    "徽",
    "昂",
    "墊",
    "擋",
    "覽",
    "貪",
    "慰",
    "繳",
    "汪",
    "慌",
    "馮",
    "諾",
    "姜",
    "誼",
    "兇",
    "劣",
    "誣",
    "耀",
    "昏",
    "躺",
    "盈",
    "騎",
    "喬",
    "溪",
    "叢",
    "盧",
    "抹",
    "悶",
    "諮",
    "刮",
    "駕",
    "纜",
    "悟",
    "摘",
    "鉺",
    "擲",
    "頗",
    "幻",
    "柄",
    "惠",
    "慘",
    "佳",
    "仇",
    "臘",
    "窩",
    "滌",
    "劍",
    "瞧",
    "堡",
    "潑",
    "蔥",
    "罩",
    "霍",
    "撈",
    "胎",
    "蒼",
    "濱",
    "倆",
    "捅",
    "湘",
    "砍",
    "霞",
    "邵",
    "萄",
    "瘋",
    "淮",
    "遂",
    "熊",
    "糞",
    "烘",
    "宿",
    "檔",
    "戈",
    "駁",
    "嫂",
    "裕",
    "徙",
    "箭",
    "捐",
    "腸",
    "撐",
    "曬",
    "辨",
    "殿",
    "蓮",
    "攤",
    "攪",
    "醬",
    "屏",
    "疫",
    "哀",
    "蔡",
    "堵",
    "沫",
    "皺",
    "暢",
    "疊",
    "閣",
    "萊",
    "敲",
    "轄",
    "鉤",
    "痕",
    "壩",
    "巷",
    "餓",
    "禍",
    "丘",
    "玄",
    "溜",
    "曰",
    "邏",
    "彭",
    "嘗",
    "卿",
    "妨",
    "艇",
    "吞",
    "韋",
    "怨",
    "矮",
    "歇"
  ]), Yu;
}
var Xu, U3;
function fy() {
  return U3 || (U3 = 1, Xu = [
    "abandon",
    "ability",
    "able",
    "about",
    "above",
    "absent",
    "absorb",
    "abstract",
    "absurd",
    "abuse",
    "access",
    "accident",
    "account",
    "accuse",
    "achieve",
    "acid",
    "acoustic",
    "acquire",
    "across",
    "act",
    "action",
    "actor",
    "actress",
    "actual",
    "adapt",
    "add",
    "addict",
    "address",
    "adjust",
    "admit",
    "adult",
    "advance",
    "advice",
    "aerobic",
    "affair",
    "afford",
    "afraid",
    "again",
    "age",
    "agent",
    "agree",
    "ahead",
    "aim",
    "air",
    "airport",
    "aisle",
    "alarm",
    "album",
    "alcohol",
    "alert",
    "alien",
    "all",
    "alley",
    "allow",
    "almost",
    "alone",
    "alpha",
    "already",
    "also",
    "alter",
    "always",
    "amateur",
    "amazing",
    "among",
    "amount",
    "amused",
    "analyst",
    "anchor",
    "ancient",
    "anger",
    "angle",
    "angry",
    "animal",
    "ankle",
    "announce",
    "annual",
    "another",
    "answer",
    "antenna",
    "antique",
    "anxiety",
    "any",
    "apart",
    "apology",
    "appear",
    "apple",
    "approve",
    "april",
    "arch",
    "arctic",
    "area",
    "arena",
    "argue",
    "arm",
    "armed",
    "armor",
    "army",
    "around",
    "arrange",
    "arrest",
    "arrive",
    "arrow",
    "art",
    "artefact",
    "artist",
    "artwork",
    "ask",
    "aspect",
    "assault",
    "asset",
    "assist",
    "assume",
    "asthma",
    "athlete",
    "atom",
    "attack",
    "attend",
    "attitude",
    "attract",
    "auction",
    "audit",
    "august",
    "aunt",
    "author",
    "auto",
    "autumn",
    "average",
    "avocado",
    "avoid",
    "awake",
    "aware",
    "away",
    "awesome",
    "awful",
    "awkward",
    "axis",
    "baby",
    "bachelor",
    "bacon",
    "badge",
    "bag",
    "balance",
    "balcony",
    "ball",
    "bamboo",
    "banana",
    "banner",
    "bar",
    "barely",
    "bargain",
    "barrel",
    "base",
    "basic",
    "basket",
    "battle",
    "beach",
    "bean",
    "beauty",
    "because",
    "become",
    "beef",
    "before",
    "begin",
    "behave",
    "behind",
    "believe",
    "below",
    "belt",
    "bench",
    "benefit",
    "best",
    "betray",
    "better",
    "between",
    "beyond",
    "bicycle",
    "bid",
    "bike",
    "bind",
    "biology",
    "bird",
    "birth",
    "bitter",
    "black",
    "blade",
    "blame",
    "blanket",
    "blast",
    "bleak",
    "bless",
    "blind",
    "blood",
    "blossom",
    "blouse",
    "blue",
    "blur",
    "blush",
    "board",
    "boat",
    "body",
    "boil",
    "bomb",
    "bone",
    "bonus",
    "book",
    "boost",
    "border",
    "boring",
    "borrow",
    "boss",
    "bottom",
    "bounce",
    "box",
    "boy",
    "bracket",
    "brain",
    "brand",
    "brass",
    "brave",
    "bread",
    "breeze",
    "brick",
    "bridge",
    "brief",
    "bright",
    "bring",
    "brisk",
    "broccoli",
    "broken",
    "bronze",
    "broom",
    "brother",
    "brown",
    "brush",
    "bubble",
    "buddy",
    "budget",
    "buffalo",
    "build",
    "bulb",
    "bulk",
    "bullet",
    "bundle",
    "bunker",
    "burden",
    "burger",
    "burst",
    "bus",
    "business",
    "busy",
    "butter",
    "buyer",
    "buzz",
    "cabbage",
    "cabin",
    "cable",
    "cactus",
    "cage",
    "cake",
    "call",
    "calm",
    "camera",
    "camp",
    "can",
    "canal",
    "cancel",
    "candy",
    "cannon",
    "canoe",
    "canvas",
    "canyon",
    "capable",
    "capital",
    "captain",
    "car",
    "carbon",
    "card",
    "cargo",
    "carpet",
    "carry",
    "cart",
    "case",
    "cash",
    "casino",
    "castle",
    "casual",
    "cat",
    "catalog",
    "catch",
    "category",
    "cattle",
    "caught",
    "cause",
    "caution",
    "cave",
    "ceiling",
    "celery",
    "cement",
    "census",
    "century",
    "cereal",
    "certain",
    "chair",
    "chalk",
    "champion",
    "change",
    "chaos",
    "chapter",
    "charge",
    "chase",
    "chat",
    "cheap",
    "check",
    "cheese",
    "chef",
    "cherry",
    "chest",
    "chicken",
    "chief",
    "child",
    "chimney",
    "choice",
    "choose",
    "chronic",
    "chuckle",
    "chunk",
    "churn",
    "cigar",
    "cinnamon",
    "circle",
    "citizen",
    "city",
    "civil",
    "claim",
    "clap",
    "clarify",
    "claw",
    "clay",
    "clean",
    "clerk",
    "clever",
    "click",
    "client",
    "cliff",
    "climb",
    "clinic",
    "clip",
    "clock",
    "clog",
    "close",
    "cloth",
    "cloud",
    "clown",
    "club",
    "clump",
    "cluster",
    "clutch",
    "coach",
    "coast",
    "coconut",
    "code",
    "coffee",
    "coil",
    "coin",
    "collect",
    "color",
    "column",
    "combine",
    "come",
    "comfort",
    "comic",
    "common",
    "company",
    "concert",
    "conduct",
    "confirm",
    "congress",
    "connect",
    "consider",
    "control",
    "convince",
    "cook",
    "cool",
    "copper",
    "copy",
    "coral",
    "core",
    "corn",
    "correct",
    "cost",
    "cotton",
    "couch",
    "country",
    "couple",
    "course",
    "cousin",
    "cover",
    "coyote",
    "crack",
    "cradle",
    "craft",
    "cram",
    "crane",
    "crash",
    "crater",
    "crawl",
    "crazy",
    "cream",
    "credit",
    "creek",
    "crew",
    "cricket",
    "crime",
    "crisp",
    "critic",
    "crop",
    "cross",
    "crouch",
    "crowd",
    "crucial",
    "cruel",
    "cruise",
    "crumble",
    "crunch",
    "crush",
    "cry",
    "crystal",
    "cube",
    "culture",
    "cup",
    "cupboard",
    "curious",
    "current",
    "curtain",
    "curve",
    "cushion",
    "custom",
    "cute",
    "cycle",
    "dad",
    "damage",
    "damp",
    "dance",
    "danger",
    "daring",
    "dash",
    "daughter",
    "dawn",
    "day",
    "deal",
    "debate",
    "debris",
    "decade",
    "december",
    "decide",
    "decline",
    "decorate",
    "decrease",
    "deer",
    "defense",
    "define",
    "defy",
    "degree",
    "delay",
    "deliver",
    "demand",
    "demise",
    "denial",
    "dentist",
    "deny",
    "depart",
    "depend",
    "deposit",
    "depth",
    "deputy",
    "derive",
    "describe",
    "desert",
    "design",
    "desk",
    "despair",
    "destroy",
    "detail",
    "detect",
    "develop",
    "device",
    "devote",
    "diagram",
    "dial",
    "diamond",
    "diary",
    "dice",
    "diesel",
    "diet",
    "differ",
    "digital",
    "dignity",
    "dilemma",
    "dinner",
    "dinosaur",
    "direct",
    "dirt",
    "disagree",
    "discover",
    "disease",
    "dish",
    "dismiss",
    "disorder",
    "display",
    "distance",
    "divert",
    "divide",
    "divorce",
    "dizzy",
    "doctor",
    "document",
    "dog",
    "doll",
    "dolphin",
    "domain",
    "donate",
    "donkey",
    "donor",
    "door",
    "dose",
    "double",
    "dove",
    "draft",
    "dragon",
    "drama",
    "drastic",
    "draw",
    "dream",
    "dress",
    "drift",
    "drill",
    "drink",
    "drip",
    "drive",
    "drop",
    "drum",
    "dry",
    "duck",
    "dumb",
    "dune",
    "during",
    "dust",
    "dutch",
    "duty",
    "dwarf",
    "dynamic",
    "eager",
    "eagle",
    "early",
    "earn",
    "earth",
    "easily",
    "east",
    "easy",
    "echo",
    "ecology",
    "economy",
    "edge",
    "edit",
    "educate",
    "effort",
    "egg",
    "eight",
    "either",
    "elbow",
    "elder",
    "electric",
    "elegant",
    "element",
    "elephant",
    "elevator",
    "elite",
    "else",
    "embark",
    "embody",
    "embrace",
    "emerge",
    "emotion",
    "employ",
    "empower",
    "empty",
    "enable",
    "enact",
    "end",
    "endless",
    "endorse",
    "enemy",
    "energy",
    "enforce",
    "engage",
    "engine",
    "enhance",
    "enjoy",
    "enlist",
    "enough",
    "enrich",
    "enroll",
    "ensure",
    "enter",
    "entire",
    "entry",
    "envelope",
    "episode",
    "equal",
    "equip",
    "era",
    "erase",
    "erode",
    "erosion",
    "error",
    "erupt",
    "escape",
    "essay",
    "essence",
    "estate",
    "eternal",
    "ethics",
    "evidence",
    "evil",
    "evoke",
    "evolve",
    "exact",
    "example",
    "excess",
    "exchange",
    "excite",
    "exclude",
    "excuse",
    "execute",
    "exercise",
    "exhaust",
    "exhibit",
    "exile",
    "exist",
    "exit",
    "exotic",
    "expand",
    "expect",
    "expire",
    "explain",
    "expose",
    "express",
    "extend",
    "extra",
    "eye",
    "eyebrow",
    "fabric",
    "face",
    "faculty",
    "fade",
    "faint",
    "faith",
    "fall",
    "false",
    "fame",
    "family",
    "famous",
    "fan",
    "fancy",
    "fantasy",
    "farm",
    "fashion",
    "fat",
    "fatal",
    "father",
    "fatigue",
    "fault",
    "favorite",
    "feature",
    "february",
    "federal",
    "fee",
    "feed",
    "feel",
    "female",
    "fence",
    "festival",
    "fetch",
    "fever",
    "few",
    "fiber",
    "fiction",
    "field",
    "figure",
    "file",
    "film",
    "filter",
    "final",
    "find",
    "fine",
    "finger",
    "finish",
    "fire",
    "firm",
    "first",
    "fiscal",
    "fish",
    "fit",
    "fitness",
    "fix",
    "flag",
    "flame",
    "flash",
    "flat",
    "flavor",
    "flee",
    "flight",
    "flip",
    "float",
    "flock",
    "floor",
    "flower",
    "fluid",
    "flush",
    "fly",
    "foam",
    "focus",
    "fog",
    "foil",
    "fold",
    "follow",
    "food",
    "foot",
    "force",
    "forest",
    "forget",
    "fork",
    "fortune",
    "forum",
    "forward",
    "fossil",
    "foster",
    "found",
    "fox",
    "fragile",
    "frame",
    "frequent",
    "fresh",
    "friend",
    "fringe",
    "frog",
    "front",
    "frost",
    "frown",
    "frozen",
    "fruit",
    "fuel",
    "fun",
    "funny",
    "furnace",
    "fury",
    "future",
    "gadget",
    "gain",
    "galaxy",
    "gallery",
    "game",
    "gap",
    "garage",
    "garbage",
    "garden",
    "garlic",
    "garment",
    "gas",
    "gasp",
    "gate",
    "gather",
    "gauge",
    "gaze",
    "general",
    "genius",
    "genre",
    "gentle",
    "genuine",
    "gesture",
    "ghost",
    "giant",
    "gift",
    "giggle",
    "ginger",
    "giraffe",
    "girl",
    "give",
    "glad",
    "glance",
    "glare",
    "glass",
    "glide",
    "glimpse",
    "globe",
    "gloom",
    "glory",
    "glove",
    "glow",
    "glue",
    "goat",
    "goddess",
    "gold",
    "good",
    "goose",
    "gorilla",
    "gospel",
    "gossip",
    "govern",
    "gown",
    "grab",
    "grace",
    "grain",
    "grant",
    "grape",
    "grass",
    "gravity",
    "great",
    "green",
    "grid",
    "grief",
    "grit",
    "grocery",
    "group",
    "grow",
    "grunt",
    "guard",
    "guess",
    "guide",
    "guilt",
    "guitar",
    "gun",
    "gym",
    "habit",
    "hair",
    "half",
    "hammer",
    "hamster",
    "hand",
    "happy",
    "harbor",
    "hard",
    "harsh",
    "harvest",
    "hat",
    "have",
    "hawk",
    "hazard",
    "head",
    "health",
    "heart",
    "heavy",
    "hedgehog",
    "height",
    "hello",
    "helmet",
    "help",
    "hen",
    "hero",
    "hidden",
    "high",
    "hill",
    "hint",
    "hip",
    "hire",
    "history",
    "hobby",
    "hockey",
    "hold",
    "hole",
    "holiday",
    "hollow",
    "home",
    "honey",
    "hood",
    "hope",
    "horn",
    "horror",
    "horse",
    "hospital",
    "host",
    "hotel",
    "hour",
    "hover",
    "hub",
    "huge",
    "human",
    "humble",
    "humor",
    "hundred",
    "hungry",
    "hunt",
    "hurdle",
    "hurry",
    "hurt",
    "husband",
    "hybrid",
    "ice",
    "icon",
    "idea",
    "identify",
    "idle",
    "ignore",
    "ill",
    "illegal",
    "illness",
    "image",
    "imitate",
    "immense",
    "immune",
    "impact",
    "impose",
    "improve",
    "impulse",
    "inch",
    "include",
    "income",
    "increase",
    "index",
    "indicate",
    "indoor",
    "industry",
    "infant",
    "inflict",
    "inform",
    "inhale",
    "inherit",
    "initial",
    "inject",
    "injury",
    "inmate",
    "inner",
    "innocent",
    "input",
    "inquiry",
    "insane",
    "insect",
    "inside",
    "inspire",
    "install",
    "intact",
    "interest",
    "into",
    "invest",
    "invite",
    "involve",
    "iron",
    "island",
    "isolate",
    "issue",
    "item",
    "ivory",
    "jacket",
    "jaguar",
    "jar",
    "jazz",
    "jealous",
    "jeans",
    "jelly",
    "jewel",
    "job",
    "join",
    "joke",
    "journey",
    "joy",
    "judge",
    "juice",
    "jump",
    "jungle",
    "junior",
    "junk",
    "just",
    "kangaroo",
    "keen",
    "keep",
    "ketchup",
    "key",
    "kick",
    "kid",
    "kidney",
    "kind",
    "kingdom",
    "kiss",
    "kit",
    "kitchen",
    "kite",
    "kitten",
    "kiwi",
    "knee",
    "knife",
    "knock",
    "know",
    "lab",
    "label",
    "labor",
    "ladder",
    "lady",
    "lake",
    "lamp",
    "language",
    "laptop",
    "large",
    "later",
    "latin",
    "laugh",
    "laundry",
    "lava",
    "law",
    "lawn",
    "lawsuit",
    "layer",
    "lazy",
    "leader",
    "leaf",
    "learn",
    "leave",
    "lecture",
    "left",
    "leg",
    "legal",
    "legend",
    "leisure",
    "lemon",
    "lend",
    "length",
    "lens",
    "leopard",
    "lesson",
    "letter",
    "level",
    "liar",
    "liberty",
    "library",
    "license",
    "life",
    "lift",
    "light",
    "like",
    "limb",
    "limit",
    "link",
    "lion",
    "liquid",
    "list",
    "little",
    "live",
    "lizard",
    "load",
    "loan",
    "lobster",
    "local",
    "lock",
    "logic",
    "lonely",
    "long",
    "loop",
    "lottery",
    "loud",
    "lounge",
    "love",
    "loyal",
    "lucky",
    "luggage",
    "lumber",
    "lunar",
    "lunch",
    "luxury",
    "lyrics",
    "machine",
    "mad",
    "magic",
    "magnet",
    "maid",
    "mail",
    "main",
    "major",
    "make",
    "mammal",
    "man",
    "manage",
    "mandate",
    "mango",
    "mansion",
    "manual",
    "maple",
    "marble",
    "march",
    "margin",
    "marine",
    "market",
    "marriage",
    "mask",
    "mass",
    "master",
    "match",
    "material",
    "math",
    "matrix",
    "matter",
    "maximum",
    "maze",
    "meadow",
    "mean",
    "measure",
    "meat",
    "mechanic",
    "medal",
    "media",
    "melody",
    "melt",
    "member",
    "memory",
    "mention",
    "menu",
    "mercy",
    "merge",
    "merit",
    "merry",
    "mesh",
    "message",
    "metal",
    "method",
    "middle",
    "midnight",
    "milk",
    "million",
    "mimic",
    "mind",
    "minimum",
    "minor",
    "minute",
    "miracle",
    "mirror",
    "misery",
    "miss",
    "mistake",
    "mix",
    "mixed",
    "mixture",
    "mobile",
    "model",
    "modify",
    "mom",
    "moment",
    "monitor",
    "monkey",
    "monster",
    "month",
    "moon",
    "moral",
    "more",
    "morning",
    "mosquito",
    "mother",
    "motion",
    "motor",
    "mountain",
    "mouse",
    "move",
    "movie",
    "much",
    "muffin",
    "mule",
    "multiply",
    "muscle",
    "museum",
    "mushroom",
    "music",
    "must",
    "mutual",
    "myself",
    "mystery",
    "myth",
    "naive",
    "name",
    "napkin",
    "narrow",
    "nasty",
    "nation",
    "nature",
    "near",
    "neck",
    "need",
    "negative",
    "neglect",
    "neither",
    "nephew",
    "nerve",
    "nest",
    "net",
    "network",
    "neutral",
    "never",
    "news",
    "next",
    "nice",
    "night",
    "noble",
    "noise",
    "nominee",
    "noodle",
    "normal",
    "north",
    "nose",
    "notable",
    "note",
    "nothing",
    "notice",
    "novel",
    "now",
    "nuclear",
    "number",
    "nurse",
    "nut",
    "oak",
    "obey",
    "object",
    "oblige",
    "obscure",
    "observe",
    "obtain",
    "obvious",
    "occur",
    "ocean",
    "october",
    "odor",
    "off",
    "offer",
    "office",
    "often",
    "oil",
    "okay",
    "old",
    "olive",
    "olympic",
    "omit",
    "once",
    "one",
    "onion",
    "online",
    "only",
    "open",
    "opera",
    "opinion",
    "oppose",
    "option",
    "orange",
    "orbit",
    "orchard",
    "order",
    "ordinary",
    "organ",
    "orient",
    "original",
    "orphan",
    "ostrich",
    "other",
    "outdoor",
    "outer",
    "output",
    "outside",
    "oval",
    "oven",
    "over",
    "own",
    "owner",
    "oxygen",
    "oyster",
    "ozone",
    "pact",
    "paddle",
    "page",
    "pair",
    "palace",
    "palm",
    "panda",
    "panel",
    "panic",
    "panther",
    "paper",
    "parade",
    "parent",
    "park",
    "parrot",
    "party",
    "pass",
    "patch",
    "path",
    "patient",
    "patrol",
    "pattern",
    "pause",
    "pave",
    "payment",
    "peace",
    "peanut",
    "pear",
    "peasant",
    "pelican",
    "pen",
    "penalty",
    "pencil",
    "people",
    "pepper",
    "perfect",
    "permit",
    "person",
    "pet",
    "phone",
    "photo",
    "phrase",
    "physical",
    "piano",
    "picnic",
    "picture",
    "piece",
    "pig",
    "pigeon",
    "pill",
    "pilot",
    "pink",
    "pioneer",
    "pipe",
    "pistol",
    "pitch",
    "pizza",
    "place",
    "planet",
    "plastic",
    "plate",
    "play",
    "please",
    "pledge",
    "pluck",
    "plug",
    "plunge",
    "poem",
    "poet",
    "point",
    "polar",
    "pole",
    "police",
    "pond",
    "pony",
    "pool",
    "popular",
    "portion",
    "position",
    "possible",
    "post",
    "potato",
    "pottery",
    "poverty",
    "powder",
    "power",
    "practice",
    "praise",
    "predict",
    "prefer",
    "prepare",
    "present",
    "pretty",
    "prevent",
    "price",
    "pride",
    "primary",
    "print",
    "priority",
    "prison",
    "private",
    "prize",
    "problem",
    "process",
    "produce",
    "profit",
    "program",
    "project",
    "promote",
    "proof",
    "property",
    "prosper",
    "protect",
    "proud",
    "provide",
    "public",
    "pudding",
    "pull",
    "pulp",
    "pulse",
    "pumpkin",
    "punch",
    "pupil",
    "puppy",
    "purchase",
    "purity",
    "purpose",
    "purse",
    "push",
    "put",
    "puzzle",
    "pyramid",
    "quality",
    "quantum",
    "quarter",
    "question",
    "quick",
    "quit",
    "quiz",
    "quote",
    "rabbit",
    "raccoon",
    "race",
    "rack",
    "radar",
    "radio",
    "rail",
    "rain",
    "raise",
    "rally",
    "ramp",
    "ranch",
    "random",
    "range",
    "rapid",
    "rare",
    "rate",
    "rather",
    "raven",
    "raw",
    "razor",
    "ready",
    "real",
    "reason",
    "rebel",
    "rebuild",
    "recall",
    "receive",
    "recipe",
    "record",
    "recycle",
    "reduce",
    "reflect",
    "reform",
    "refuse",
    "region",
    "regret",
    "regular",
    "reject",
    "relax",
    "release",
    "relief",
    "rely",
    "remain",
    "remember",
    "remind",
    "remove",
    "render",
    "renew",
    "rent",
    "reopen",
    "repair",
    "repeat",
    "replace",
    "report",
    "require",
    "rescue",
    "resemble",
    "resist",
    "resource",
    "response",
    "result",
    "retire",
    "retreat",
    "return",
    "reunion",
    "reveal",
    "review",
    "reward",
    "rhythm",
    "rib",
    "ribbon",
    "rice",
    "rich",
    "ride",
    "ridge",
    "rifle",
    "right",
    "rigid",
    "ring",
    "riot",
    "ripple",
    "risk",
    "ritual",
    "rival",
    "river",
    "road",
    "roast",
    "robot",
    "robust",
    "rocket",
    "romance",
    "roof",
    "rookie",
    "room",
    "rose",
    "rotate",
    "rough",
    "round",
    "route",
    "royal",
    "rubber",
    "rude",
    "rug",
    "rule",
    "run",
    "runway",
    "rural",
    "sad",
    "saddle",
    "sadness",
    "safe",
    "sail",
    "salad",
    "salmon",
    "salon",
    "salt",
    "salute",
    "same",
    "sample",
    "sand",
    "satisfy",
    "satoshi",
    "sauce",
    "sausage",
    "save",
    "say",
    "scale",
    "scan",
    "scare",
    "scatter",
    "scene",
    "scheme",
    "school",
    "science",
    "scissors",
    "scorpion",
    "scout",
    "scrap",
    "screen",
    "script",
    "scrub",
    "sea",
    "search",
    "season",
    "seat",
    "second",
    "secret",
    "section",
    "security",
    "seed",
    "seek",
    "segment",
    "select",
    "sell",
    "seminar",
    "senior",
    "sense",
    "sentence",
    "series",
    "service",
    "session",
    "settle",
    "setup",
    "seven",
    "shadow",
    "shaft",
    "shallow",
    "share",
    "shed",
    "shell",
    "sheriff",
    "shield",
    "shift",
    "shine",
    "ship",
    "shiver",
    "shock",
    "shoe",
    "shoot",
    "shop",
    "short",
    "shoulder",
    "shove",
    "shrimp",
    "shrug",
    "shuffle",
    "shy",
    "sibling",
    "sick",
    "side",
    "siege",
    "sight",
    "sign",
    "silent",
    "silk",
    "silly",
    "silver",
    "similar",
    "simple",
    "since",
    "sing",
    "siren",
    "sister",
    "situate",
    "six",
    "size",
    "skate",
    "sketch",
    "ski",
    "skill",
    "skin",
    "skirt",
    "skull",
    "slab",
    "slam",
    "sleep",
    "slender",
    "slice",
    "slide",
    "slight",
    "slim",
    "slogan",
    "slot",
    "slow",
    "slush",
    "small",
    "smart",
    "smile",
    "smoke",
    "smooth",
    "snack",
    "snake",
    "snap",
    "sniff",
    "snow",
    "soap",
    "soccer",
    "social",
    "sock",
    "soda",
    "soft",
    "solar",
    "soldier",
    "solid",
    "solution",
    "solve",
    "someone",
    "song",
    "soon",
    "sorry",
    "sort",
    "soul",
    "sound",
    "soup",
    "source",
    "south",
    "space",
    "spare",
    "spatial",
    "spawn",
    "speak",
    "special",
    "speed",
    "spell",
    "spend",
    "sphere",
    "spice",
    "spider",
    "spike",
    "spin",
    "spirit",
    "split",
    "spoil",
    "sponsor",
    "spoon",
    "sport",
    "spot",
    "spray",
    "spread",
    "spring",
    "spy",
    "square",
    "squeeze",
    "squirrel",
    "stable",
    "stadium",
    "staff",
    "stage",
    "stairs",
    "stamp",
    "stand",
    "start",
    "state",
    "stay",
    "steak",
    "steel",
    "stem",
    "step",
    "stereo",
    "stick",
    "still",
    "sting",
    "stock",
    "stomach",
    "stone",
    "stool",
    "story",
    "stove",
    "strategy",
    "street",
    "strike",
    "strong",
    "struggle",
    "student",
    "stuff",
    "stumble",
    "style",
    "subject",
    "submit",
    "subway",
    "success",
    "such",
    "sudden",
    "suffer",
    "sugar",
    "suggest",
    "suit",
    "summer",
    "sun",
    "sunny",
    "sunset",
    "super",
    "supply",
    "supreme",
    "sure",
    "surface",
    "surge",
    "surprise",
    "surround",
    "survey",
    "suspect",
    "sustain",
    "swallow",
    "swamp",
    "swap",
    "swarm",
    "swear",
    "sweet",
    "swift",
    "swim",
    "swing",
    "switch",
    "sword",
    "symbol",
    "symptom",
    "syrup",
    "system",
    "table",
    "tackle",
    "tag",
    "tail",
    "talent",
    "talk",
    "tank",
    "tape",
    "target",
    "task",
    "taste",
    "tattoo",
    "taxi",
    "teach",
    "team",
    "tell",
    "ten",
    "tenant",
    "tennis",
    "tent",
    "term",
    "test",
    "text",
    "thank",
    "that",
    "theme",
    "then",
    "theory",
    "there",
    "they",
    "thing",
    "this",
    "thought",
    "three",
    "thrive",
    "throw",
    "thumb",
    "thunder",
    "ticket",
    "tide",
    "tiger",
    "tilt",
    "timber",
    "time",
    "tiny",
    "tip",
    "tired",
    "tissue",
    "title",
    "toast",
    "tobacco",
    "today",
    "toddler",
    "toe",
    "together",
    "toilet",
    "token",
    "tomato",
    "tomorrow",
    "tone",
    "tongue",
    "tonight",
    "tool",
    "tooth",
    "top",
    "topic",
    "topple",
    "torch",
    "tornado",
    "tortoise",
    "toss",
    "total",
    "tourist",
    "toward",
    "tower",
    "town",
    "toy",
    "track",
    "trade",
    "traffic",
    "tragic",
    "train",
    "transfer",
    "trap",
    "trash",
    "travel",
    "tray",
    "treat",
    "tree",
    "trend",
    "trial",
    "tribe",
    "trick",
    "trigger",
    "trim",
    "trip",
    "trophy",
    "trouble",
    "truck",
    "true",
    "truly",
    "trumpet",
    "trust",
    "truth",
    "try",
    "tube",
    "tuition",
    "tumble",
    "tuna",
    "tunnel",
    "turkey",
    "turn",
    "turtle",
    "twelve",
    "twenty",
    "twice",
    "twin",
    "twist",
    "two",
    "type",
    "typical",
    "ugly",
    "umbrella",
    "unable",
    "unaware",
    "uncle",
    "uncover",
    "under",
    "undo",
    "unfair",
    "unfold",
    "unhappy",
    "uniform",
    "unique",
    "unit",
    "universe",
    "unknown",
    "unlock",
    "until",
    "unusual",
    "unveil",
    "update",
    "upgrade",
    "uphold",
    "upon",
    "upper",
    "upset",
    "urban",
    "urge",
    "usage",
    "use",
    "used",
    "useful",
    "useless",
    "usual",
    "utility",
    "vacant",
    "vacuum",
    "vague",
    "valid",
    "valley",
    "valve",
    "van",
    "vanish",
    "vapor",
    "various",
    "vast",
    "vault",
    "vehicle",
    "velvet",
    "vendor",
    "venture",
    "venue",
    "verb",
    "verify",
    "version",
    "very",
    "vessel",
    "veteran",
    "viable",
    "vibrant",
    "vicious",
    "victory",
    "video",
    "view",
    "village",
    "vintage",
    "violin",
    "virtual",
    "virus",
    "visa",
    "visit",
    "visual",
    "vital",
    "vivid",
    "vocal",
    "voice",
    "void",
    "volcano",
    "volume",
    "vote",
    "voyage",
    "wage",
    "wagon",
    "wait",
    "walk",
    "wall",
    "walnut",
    "want",
    "warfare",
    "warm",
    "warrior",
    "wash",
    "wasp",
    "waste",
    "water",
    "wave",
    "way",
    "wealth",
    "weapon",
    "wear",
    "weasel",
    "weather",
    "web",
    "wedding",
    "weekend",
    "weird",
    "welcome",
    "west",
    "wet",
    "whale",
    "what",
    "wheat",
    "wheel",
    "when",
    "where",
    "whip",
    "whisper",
    "wide",
    "width",
    "wife",
    "wild",
    "will",
    "win",
    "window",
    "wine",
    "wing",
    "wink",
    "winner",
    "winter",
    "wire",
    "wisdom",
    "wise",
    "wish",
    "witness",
    "wolf",
    "woman",
    "wonder",
    "wood",
    "wool",
    "word",
    "work",
    "world",
    "worry",
    "worth",
    "wrap",
    "wreck",
    "wrestle",
    "wrist",
    "write",
    "wrong",
    "yard",
    "year",
    "yellow",
    "you",
    "young",
    "youth",
    "zebra",
    "zero",
    "zone",
    "zoo"
  ]), Xu;
}
var Gu, F3;
function cy() {
  return F3 || (F3 = 1, Gu = [
    "abaisser",
    "abandon",
    "abdiquer",
    "abeille",
    "abolir",
    "aborder",
    "aboutir",
    "aboyer",
    "abrasif",
    "abreuver",
    "abriter",
    "abroger",
    "abrupt",
    "absence",
    "absolu",
    "absurde",
    "abusif",
    "abyssal",
    "académie",
    "acajou",
    "acarien",
    "accabler",
    "accepter",
    "acclamer",
    "accolade",
    "accroche",
    "accuser",
    "acerbe",
    "achat",
    "acheter",
    "aciduler",
    "acier",
    "acompte",
    "acquérir",
    "acronyme",
    "acteur",
    "actif",
    "actuel",
    "adepte",
    "adéquat",
    "adhésif",
    "adjectif",
    "adjuger",
    "admettre",
    "admirer",
    "adopter",
    "adorer",
    "adoucir",
    "adresse",
    "adroit",
    "adulte",
    "adverbe",
    "aérer",
    "aéronef",
    "affaire",
    "affecter",
    "affiche",
    "affreux",
    "affubler",
    "agacer",
    "agencer",
    "agile",
    "agiter",
    "agrafer",
    "agréable",
    "agrume",
    "aider",
    "aiguille",
    "ailier",
    "aimable",
    "aisance",
    "ajouter",
    "ajuster",
    "alarmer",
    "alchimie",
    "alerte",
    "algèbre",
    "algue",
    "aliéner",
    "aliment",
    "alléger",
    "alliage",
    "allouer",
    "allumer",
    "alourdir",
    "alpaga",
    "altesse",
    "alvéole",
    "amateur",
    "ambigu",
    "ambre",
    "aménager",
    "amertume",
    "amidon",
    "amiral",
    "amorcer",
    "amour",
    "amovible",
    "amphibie",
    "ampleur",
    "amusant",
    "analyse",
    "anaphore",
    "anarchie",
    "anatomie",
    "ancien",
    "anéantir",
    "angle",
    "angoisse",
    "anguleux",
    "animal",
    "annexer",
    "annonce",
    "annuel",
    "anodin",
    "anomalie",
    "anonyme",
    "anormal",
    "antenne",
    "antidote",
    "anxieux",
    "apaiser",
    "apéritif",
    "aplanir",
    "apologie",
    "appareil",
    "appeler",
    "apporter",
    "appuyer",
    "aquarium",
    "aqueduc",
    "arbitre",
    "arbuste",
    "ardeur",
    "ardoise",
    "argent",
    "arlequin",
    "armature",
    "armement",
    "armoire",
    "armure",
    "arpenter",
    "arracher",
    "arriver",
    "arroser",
    "arsenic",
    "artériel",
    "article",
    "aspect",
    "asphalte",
    "aspirer",
    "assaut",
    "asservir",
    "assiette",
    "associer",
    "assurer",
    "asticot",
    "astre",
    "astuce",
    "atelier",
    "atome",
    "atrium",
    "atroce",
    "attaque",
    "attentif",
    "attirer",
    "attraper",
    "aubaine",
    "auberge",
    "audace",
    "audible",
    "augurer",
    "aurore",
    "automne",
    "autruche",
    "avaler",
    "avancer",
    "avarice",
    "avenir",
    "averse",
    "aveugle",
    "aviateur",
    "avide",
    "avion",
    "aviser",
    "avoine",
    "avouer",
    "avril",
    "axial",
    "axiome",
    "badge",
    "bafouer",
    "bagage",
    "baguette",
    "baignade",
    "balancer",
    "balcon",
    "baleine",
    "balisage",
    "bambin",
    "bancaire",
    "bandage",
    "banlieue",
    "bannière",
    "banquier",
    "barbier",
    "baril",
    "baron",
    "barque",
    "barrage",
    "bassin",
    "bastion",
    "bataille",
    "bateau",
    "batterie",
    "baudrier",
    "bavarder",
    "belette",
    "bélier",
    "belote",
    "bénéfice",
    "berceau",
    "berger",
    "berline",
    "bermuda",
    "besace",
    "besogne",
    "bétail",
    "beurre",
    "biberon",
    "bicycle",
    "bidule",
    "bijou",
    "bilan",
    "bilingue",
    "billard",
    "binaire",
    "biologie",
    "biopsie",
    "biotype",
    "biscuit",
    "bison",
    "bistouri",
    "bitume",
    "bizarre",
    "blafard",
    "blague",
    "blanchir",
    "blessant",
    "blinder",
    "blond",
    "bloquer",
    "blouson",
    "bobard",
    "bobine",
    "boire",
    "boiser",
    "bolide",
    "bonbon",
    "bondir",
    "bonheur",
    "bonifier",
    "bonus",
    "bordure",
    "borne",
    "botte",
    "boucle",
    "boueux",
    "bougie",
    "boulon",
    "bouquin",
    "bourse",
    "boussole",
    "boutique",
    "boxeur",
    "branche",
    "brasier",
    "brave",
    "brebis",
    "brèche",
    "breuvage",
    "bricoler",
    "brigade",
    "brillant",
    "brioche",
    "brique",
    "brochure",
    "broder",
    "bronzer",
    "brousse",
    "broyeur",
    "brume",
    "brusque",
    "brutal",
    "bruyant",
    "buffle",
    "buisson",
    "bulletin",
    "bureau",
    "burin",
    "bustier",
    "butiner",
    "butoir",
    "buvable",
    "buvette",
    "cabanon",
    "cabine",
    "cachette",
    "cadeau",
    "cadre",
    "caféine",
    "caillou",
    "caisson",
    "calculer",
    "calepin",
    "calibre",
    "calmer",
    "calomnie",
    "calvaire",
    "camarade",
    "caméra",
    "camion",
    "campagne",
    "canal",
    "caneton",
    "canon",
    "cantine",
    "canular",
    "capable",
    "caporal",
    "caprice",
    "capsule",
    "capter",
    "capuche",
    "carabine",
    "carbone",
    "caresser",
    "caribou",
    "carnage",
    "carotte",
    "carreau",
    "carton",
    "cascade",
    "casier",
    "casque",
    "cassure",
    "causer",
    "caution",
    "cavalier",
    "caverne",
    "caviar",
    "cédille",
    "ceinture",
    "céleste",
    "cellule",
    "cendrier",
    "censurer",
    "central",
    "cercle",
    "cérébral",
    "cerise",
    "cerner",
    "cerveau",
    "cesser",
    "chagrin",
    "chaise",
    "chaleur",
    "chambre",
    "chance",
    "chapitre",
    "charbon",
    "chasseur",
    "chaton",
    "chausson",
    "chavirer",
    "chemise",
    "chenille",
    "chéquier",
    "chercher",
    "cheval",
    "chien",
    "chiffre",
    "chignon",
    "chimère",
    "chiot",
    "chlorure",
    "chocolat",
    "choisir",
    "chose",
    "chouette",
    "chrome",
    "chute",
    "cigare",
    "cigogne",
    "cimenter",
    "cinéma",
    "cintrer",
    "circuler",
    "cirer",
    "cirque",
    "citerne",
    "citoyen",
    "citron",
    "civil",
    "clairon",
    "clameur",
    "claquer",
    "classe",
    "clavier",
    "client",
    "cligner",
    "climat",
    "clivage",
    "cloche",
    "clonage",
    "cloporte",
    "cobalt",
    "cobra",
    "cocasse",
    "cocotier",
    "coder",
    "codifier",
    "coffre",
    "cogner",
    "cohésion",
    "coiffer",
    "coincer",
    "colère",
    "colibri",
    "colline",
    "colmater",
    "colonel",
    "combat",
    "comédie",
    "commande",
    "compact",
    "concert",
    "conduire",
    "confier",
    "congeler",
    "connoter",
    "consonne",
    "contact",
    "convexe",
    "copain",
    "copie",
    "corail",
    "corbeau",
    "cordage",
    "corniche",
    "corpus",
    "correct",
    "cortège",
    "cosmique",
    "costume",
    "coton",
    "coude",
    "coupure",
    "courage",
    "couteau",
    "couvrir",
    "coyote",
    "crabe",
    "crainte",
    "cravate",
    "crayon",
    "créature",
    "créditer",
    "crémeux",
    "creuser",
    "crevette",
    "cribler",
    "crier",
    "cristal",
    "critère",
    "croire",
    "croquer",
    "crotale",
    "crucial",
    "cruel",
    "crypter",
    "cubique",
    "cueillir",
    "cuillère",
    "cuisine",
    "cuivre",
    "culminer",
    "cultiver",
    "cumuler",
    "cupide",
    "curatif",
    "curseur",
    "cyanure",
    "cycle",
    "cylindre",
    "cynique",
    "daigner",
    "damier",
    "danger",
    "danseur",
    "dauphin",
    "débattre",
    "débiter",
    "déborder",
    "débrider",
    "débutant",
    "décaler",
    "décembre",
    "déchirer",
    "décider",
    "déclarer",
    "décorer",
    "décrire",
    "décupler",
    "dédale",
    "déductif",
    "déesse",
    "défensif",
    "défiler",
    "défrayer",
    "dégager",
    "dégivrer",
    "déglutir",
    "dégrafer",
    "déjeuner",
    "délice",
    "déloger",
    "demander",
    "demeurer",
    "démolir",
    "dénicher",
    "dénouer",
    "dentelle",
    "dénuder",
    "départ",
    "dépenser",
    "déphaser",
    "déplacer",
    "déposer",
    "déranger",
    "dérober",
    "désastre",
    "descente",
    "désert",
    "désigner",
    "désobéir",
    "dessiner",
    "destrier",
    "détacher",
    "détester",
    "détourer",
    "détresse",
    "devancer",
    "devenir",
    "deviner",
    "devoir",
    "diable",
    "dialogue",
    "diamant",
    "dicter",
    "différer",
    "digérer",
    "digital",
    "digne",
    "diluer",
    "dimanche",
    "diminuer",
    "dioxyde",
    "directif",
    "diriger",
    "discuter",
    "disposer",
    "dissiper",
    "distance",
    "divertir",
    "diviser",
    "docile",
    "docteur",
    "dogme",
    "doigt",
    "domaine",
    "domicile",
    "dompter",
    "donateur",
    "donjon",
    "donner",
    "dopamine",
    "dortoir",
    "dorure",
    "dosage",
    "doseur",
    "dossier",
    "dotation",
    "douanier",
    "double",
    "douceur",
    "douter",
    "doyen",
    "dragon",
    "draper",
    "dresser",
    "dribbler",
    "droiture",
    "duperie",
    "duplexe",
    "durable",
    "durcir",
    "dynastie",
    "éblouir",
    "écarter",
    "écharpe",
    "échelle",
    "éclairer",
    "éclipse",
    "éclore",
    "écluse",
    "école",
    "économie",
    "écorce",
    "écouter",
    "écraser",
    "écrémer",
    "écrivain",
    "écrou",
    "écume",
    "écureuil",
    "édifier",
    "éduquer",
    "effacer",
    "effectif",
    "effigie",
    "effort",
    "effrayer",
    "effusion",
    "égaliser",
    "égarer",
    "éjecter",
    "élaborer",
    "élargir",
    "électron",
    "élégant",
    "éléphant",
    "élève",
    "éligible",
    "élitisme",
    "éloge",
    "élucider",
    "éluder",
    "emballer",
    "embellir",
    "embryon",
    "émeraude",
    "émission",
    "emmener",
    "émotion",
    "émouvoir",
    "empereur",
    "employer",
    "emporter",
    "emprise",
    "émulsion",
    "encadrer",
    "enchère",
    "enclave",
    "encoche",
    "endiguer",
    "endosser",
    "endroit",
    "enduire",
    "énergie",
    "enfance",
    "enfermer",
    "enfouir",
    "engager",
    "engin",
    "englober",
    "énigme",
    "enjamber",
    "enjeu",
    "enlever",
    "ennemi",
    "ennuyeux",
    "enrichir",
    "enrobage",
    "enseigne",
    "entasser",
    "entendre",
    "entier",
    "entourer",
    "entraver",
    "énumérer",
    "envahir",
    "enviable",
    "envoyer",
    "enzyme",
    "éolien",
    "épaissir",
    "épargne",
    "épatant",
    "épaule",
    "épicerie",
    "épidémie",
    "épier",
    "épilogue",
    "épine",
    "épisode",
    "épitaphe",
    "époque",
    "épreuve",
    "éprouver",
    "épuisant",
    "équerre",
    "équipe",
    "ériger",
    "érosion",
    "erreur",
    "éruption",
    "escalier",
    "espadon",
    "espèce",
    "espiègle",
    "espoir",
    "esprit",
    "esquiver",
    "essayer",
    "essence",
    "essieu",
    "essorer",
    "estime",
    "estomac",
    "estrade",
    "étagère",
    "étaler",
    "étanche",
    "étatique",
    "éteindre",
    "étendoir",
    "éternel",
    "éthanol",
    "éthique",
    "ethnie",
    "étirer",
    "étoffer",
    "étoile",
    "étonnant",
    "étourdir",
    "étrange",
    "étroit",
    "étude",
    "euphorie",
    "évaluer",
    "évasion",
    "éventail",
    "évidence",
    "éviter",
    "évolutif",
    "évoquer",
    "exact",
    "exagérer",
    "exaucer",
    "exceller",
    "excitant",
    "exclusif",
    "excuse",
    "exécuter",
    "exemple",
    "exercer",
    "exhaler",
    "exhorter",
    "exigence",
    "exiler",
    "exister",
    "exotique",
    "expédier",
    "explorer",
    "exposer",
    "exprimer",
    "exquis",
    "extensif",
    "extraire",
    "exulter",
    "fable",
    "fabuleux",
    "facette",
    "facile",
    "facture",
    "faiblir",
    "falaise",
    "fameux",
    "famille",
    "farceur",
    "farfelu",
    "farine",
    "farouche",
    "fasciner",
    "fatal",
    "fatigue",
    "faucon",
    "fautif",
    "faveur",
    "favori",
    "fébrile",
    "féconder",
    "fédérer",
    "félin",
    "femme",
    "fémur",
    "fendoir",
    "féodal",
    "fermer",
    "féroce",
    "ferveur",
    "festival",
    "feuille",
    "feutre",
    "février",
    "fiasco",
    "ficeler",
    "fictif",
    "fidèle",
    "figure",
    "filature",
    "filetage",
    "filière",
    "filleul",
    "filmer",
    "filou",
    "filtrer",
    "financer",
    "finir",
    "fiole",
    "firme",
    "fissure",
    "fixer",
    "flairer",
    "flamme",
    "flasque",
    "flatteur",
    "fléau",
    "flèche",
    "fleur",
    "flexion",
    "flocon",
    "flore",
    "fluctuer",
    "fluide",
    "fluvial",
    "folie",
    "fonderie",
    "fongible",
    "fontaine",
    "forcer",
    "forgeron",
    "formuler",
    "fortune",
    "fossile",
    "foudre",
    "fougère",
    "fouiller",
    "foulure",
    "fourmi",
    "fragile",
    "fraise",
    "franchir",
    "frapper",
    "frayeur",
    "frégate",
    "freiner",
    "frelon",
    "frémir",
    "frénésie",
    "frère",
    "friable",
    "friction",
    "frisson",
    "frivole",
    "froid",
    "fromage",
    "frontal",
    "frotter",
    "fruit",
    "fugitif",
    "fuite",
    "fureur",
    "furieux",
    "furtif",
    "fusion",
    "futur",
    "gagner",
    "galaxie",
    "galerie",
    "gambader",
    "garantir",
    "gardien",
    "garnir",
    "garrigue",
    "gazelle",
    "gazon",
    "géant",
    "gélatine",
    "gélule",
    "gendarme",
    "général",
    "génie",
    "genou",
    "gentil",
    "géologie",
    "géomètre",
    "géranium",
    "germe",
    "gestuel",
    "geyser",
    "gibier",
    "gicler",
    "girafe",
    "givre",
    "glace",
    "glaive",
    "glisser",
    "globe",
    "gloire",
    "glorieux",
    "golfeur",
    "gomme",
    "gonfler",
    "gorge",
    "gorille",
    "goudron",
    "gouffre",
    "goulot",
    "goupille",
    "gourmand",
    "goutte",
    "graduel",
    "graffiti",
    "graine",
    "grand",
    "grappin",
    "gratuit",
    "gravir",
    "grenat",
    "griffure",
    "griller",
    "grimper",
    "grogner",
    "gronder",
    "grotte",
    "groupe",
    "gruger",
    "grutier",
    "gruyère",
    "guépard",
    "guerrier",
    "guide",
    "guimauve",
    "guitare",
    "gustatif",
    "gymnaste",
    "gyrostat",
    "habitude",
    "hachoir",
    "halte",
    "hameau",
    "hangar",
    "hanneton",
    "haricot",
    "harmonie",
    "harpon",
    "hasard",
    "hélium",
    "hématome",
    "herbe",
    "hérisson",
    "hermine",
    "héron",
    "hésiter",
    "heureux",
    "hiberner",
    "hibou",
    "hilarant",
    "histoire",
    "hiver",
    "homard",
    "hommage",
    "homogène",
    "honneur",
    "honorer",
    "honteux",
    "horde",
    "horizon",
    "horloge",
    "hormone",
    "horrible",
    "houleux",
    "housse",
    "hublot",
    "huileux",
    "humain",
    "humble",
    "humide",
    "humour",
    "hurler",
    "hydromel",
    "hygiène",
    "hymne",
    "hypnose",
    "idylle",
    "ignorer",
    "iguane",
    "illicite",
    "illusion",
    "image",
    "imbiber",
    "imiter",
    "immense",
    "immobile",
    "immuable",
    "impact",
    "impérial",
    "implorer",
    "imposer",
    "imprimer",
    "imputer",
    "incarner",
    "incendie",
    "incident",
    "incliner",
    "incolore",
    "indexer",
    "indice",
    "inductif",
    "inédit",
    "ineptie",
    "inexact",
    "infini",
    "infliger",
    "informer",
    "infusion",
    "ingérer",
    "inhaler",
    "inhiber",
    "injecter",
    "injure",
    "innocent",
    "inoculer",
    "inonder",
    "inscrire",
    "insecte",
    "insigne",
    "insolite",
    "inspirer",
    "instinct",
    "insulter",
    "intact",
    "intense",
    "intime",
    "intrigue",
    "intuitif",
    "inutile",
    "invasion",
    "inventer",
    "inviter",
    "invoquer",
    "ironique",
    "irradier",
    "irréel",
    "irriter",
    "isoler",
    "ivoire",
    "ivresse",
    "jaguar",
    "jaillir",
    "jambe",
    "janvier",
    "jardin",
    "jauger",
    "jaune",
    "javelot",
    "jetable",
    "jeton",
    "jeudi",
    "jeunesse",
    "joindre",
    "joncher",
    "jongler",
    "joueur",
    "jouissif",
    "journal",
    "jovial",
    "joyau",
    "joyeux",
    "jubiler",
    "jugement",
    "junior",
    "jupon",
    "juriste",
    "justice",
    "juteux",
    "juvénile",
    "kayak",
    "kimono",
    "kiosque",
    "label",
    "labial",
    "labourer",
    "lacérer",
    "lactose",
    "lagune",
    "laine",
    "laisser",
    "laitier",
    "lambeau",
    "lamelle",
    "lampe",
    "lanceur",
    "langage",
    "lanterne",
    "lapin",
    "largeur",
    "larme",
    "laurier",
    "lavabo",
    "lavoir",
    "lecture",
    "légal",
    "léger",
    "légume",
    "lessive",
    "lettre",
    "levier",
    "lexique",
    "lézard",
    "liasse",
    "libérer",
    "libre",
    "licence",
    "licorne",
    "liège",
    "lièvre",
    "ligature",
    "ligoter",
    "ligue",
    "limer",
    "limite",
    "limonade",
    "limpide",
    "linéaire",
    "lingot",
    "lionceau",
    "liquide",
    "lisière",
    "lister",
    "lithium",
    "litige",
    "littoral",
    "livreur",
    "logique",
    "lointain",
    "loisir",
    "lombric",
    "loterie",
    "louer",
    "lourd",
    "loutre",
    "louve",
    "loyal",
    "lubie",
    "lucide",
    "lucratif",
    "lueur",
    "lugubre",
    "luisant",
    "lumière",
    "lunaire",
    "lundi",
    "luron",
    "lutter",
    "luxueux",
    "machine",
    "magasin",
    "magenta",
    "magique",
    "maigre",
    "maillon",
    "maintien",
    "mairie",
    "maison",
    "majorer",
    "malaxer",
    "maléfice",
    "malheur",
    "malice",
    "mallette",
    "mammouth",
    "mandater",
    "maniable",
    "manquant",
    "manteau",
    "manuel",
    "marathon",
    "marbre",
    "marchand",
    "mardi",
    "maritime",
    "marqueur",
    "marron",
    "marteler",
    "mascotte",
    "massif",
    "matériel",
    "matière",
    "matraque",
    "maudire",
    "maussade",
    "mauve",
    "maximal",
    "méchant",
    "méconnu",
    "médaille",
    "médecin",
    "méditer",
    "méduse",
    "meilleur",
    "mélange",
    "mélodie",
    "membre",
    "mémoire",
    "menacer",
    "mener",
    "menhir",
    "mensonge",
    "mentor",
    "mercredi",
    "mérite",
    "merle",
    "messager",
    "mesure",
    "métal",
    "météore",
    "méthode",
    "métier",
    "meuble",
    "miauler",
    "microbe",
    "miette",
    "mignon",
    "migrer",
    "milieu",
    "million",
    "mimique",
    "mince",
    "minéral",
    "minimal",
    "minorer",
    "minute",
    "miracle",
    "miroiter",
    "missile",
    "mixte",
    "mobile",
    "moderne",
    "moelleux",
    "mondial",
    "moniteur",
    "monnaie",
    "monotone",
    "monstre",
    "montagne",
    "monument",
    "moqueur",
    "morceau",
    "morsure",
    "mortier",
    "moteur",
    "motif",
    "mouche",
    "moufle",
    "moulin",
    "mousson",
    "mouton",
    "mouvant",
    "multiple",
    "munition",
    "muraille",
    "murène",
    "murmure",
    "muscle",
    "muséum",
    "musicien",
    "mutation",
    "muter",
    "mutuel",
    "myriade",
    "myrtille",
    "mystère",
    "mythique",
    "nageur",
    "nappe",
    "narquois",
    "narrer",
    "natation",
    "nation",
    "nature",
    "naufrage",
    "nautique",
    "navire",
    "nébuleux",
    "nectar",
    "néfaste",
    "négation",
    "négliger",
    "négocier",
    "neige",
    "nerveux",
    "nettoyer",
    "neurone",
    "neutron",
    "neveu",
    "niche",
    "nickel",
    "nitrate",
    "niveau",
    "noble",
    "nocif",
    "nocturne",
    "noirceur",
    "noisette",
    "nomade",
    "nombreux",
    "nommer",
    "normatif",
    "notable",
    "notifier",
    "notoire",
    "nourrir",
    "nouveau",
    "novateur",
    "novembre",
    "novice",
    "nuage",
    "nuancer",
    "nuire",
    "nuisible",
    "numéro",
    "nuptial",
    "nuque",
    "nutritif",
    "obéir",
    "objectif",
    "obliger",
    "obscur",
    "observer",
    "obstacle",
    "obtenir",
    "obturer",
    "occasion",
    "occuper",
    "océan",
    "octobre",
    "octroyer",
    "octupler",
    "oculaire",
    "odeur",
    "odorant",
    "offenser",
    "officier",
    "offrir",
    "ogive",
    "oiseau",
    "oisillon",
    "olfactif",
    "olivier",
    "ombrage",
    "omettre",
    "onctueux",
    "onduler",
    "onéreux",
    "onirique",
    "opale",
    "opaque",
    "opérer",
    "opinion",
    "opportun",
    "opprimer",
    "opter",
    "optique",
    "orageux",
    "orange",
    "orbite",
    "ordonner",
    "oreille",
    "organe",
    "orgueil",
    "orifice",
    "ornement",
    "orque",
    "ortie",
    "osciller",
    "osmose",
    "ossature",
    "otarie",
    "ouragan",
    "ourson",
    "outil",
    "outrager",
    "ouvrage",
    "ovation",
    "oxyde",
    "oxygène",
    "ozone",
    "paisible",
    "palace",
    "palmarès",
    "palourde",
    "palper",
    "panache",
    "panda",
    "pangolin",
    "paniquer",
    "panneau",
    "panorama",
    "pantalon",
    "papaye",
    "papier",
    "papoter",
    "papyrus",
    "paradoxe",
    "parcelle",
    "paresse",
    "parfumer",
    "parler",
    "parole",
    "parrain",
    "parsemer",
    "partager",
    "parure",
    "parvenir",
    "passion",
    "pastèque",
    "paternel",
    "patience",
    "patron",
    "pavillon",
    "pavoiser",
    "payer",
    "paysage",
    "peigne",
    "peintre",
    "pelage",
    "pélican",
    "pelle",
    "pelouse",
    "peluche",
    "pendule",
    "pénétrer",
    "pénible",
    "pensif",
    "pénurie",
    "pépite",
    "péplum",
    "perdrix",
    "perforer",
    "période",
    "permuter",
    "perplexe",
    "persil",
    "perte",
    "peser",
    "pétale",
    "petit",
    "pétrir",
    "peuple",
    "pharaon",
    "phobie",
    "phoque",
    "photon",
    "phrase",
    "physique",
    "piano",
    "pictural",
    "pièce",
    "pierre",
    "pieuvre",
    "pilote",
    "pinceau",
    "pipette",
    "piquer",
    "pirogue",
    "piscine",
    "piston",
    "pivoter",
    "pixel",
    "pizza",
    "placard",
    "plafond",
    "plaisir",
    "planer",
    "plaque",
    "plastron",
    "plateau",
    "pleurer",
    "plexus",
    "pliage",
    "plomb",
    "plonger",
    "pluie",
    "plumage",
    "pochette",
    "poésie",
    "poète",
    "pointe",
    "poirier",
    "poisson",
    "poivre",
    "polaire",
    "policier",
    "pollen",
    "polygone",
    "pommade",
    "pompier",
    "ponctuel",
    "pondérer",
    "poney",
    "portique",
    "position",
    "posséder",
    "posture",
    "potager",
    "poteau",
    "potion",
    "pouce",
    "poulain",
    "poumon",
    "pourpre",
    "poussin",
    "pouvoir",
    "prairie",
    "pratique",
    "précieux",
    "prédire",
    "préfixe",
    "prélude",
    "prénom",
    "présence",
    "prétexte",
    "prévoir",
    "primitif",
    "prince",
    "prison",
    "priver",
    "problème",
    "procéder",
    "prodige",
    "profond",
    "progrès",
    "proie",
    "projeter",
    "prologue",
    "promener",
    "propre",
    "prospère",
    "protéger",
    "prouesse",
    "proverbe",
    "prudence",
    "pruneau",
    "psychose",
    "public",
    "puceron",
    "puiser",
    "pulpe",
    "pulsar",
    "punaise",
    "punitif",
    "pupitre",
    "purifier",
    "puzzle",
    "pyramide",
    "quasar",
    "querelle",
    "question",
    "quiétude",
    "quitter",
    "quotient",
    "racine",
    "raconter",
    "radieux",
    "ragondin",
    "raideur",
    "raisin",
    "ralentir",
    "rallonge",
    "ramasser",
    "rapide",
    "rasage",
    "ratisser",
    "ravager",
    "ravin",
    "rayonner",
    "réactif",
    "réagir",
    "réaliser",
    "réanimer",
    "recevoir",
    "réciter",
    "réclamer",
    "récolter",
    "recruter",
    "reculer",
    "recycler",
    "rédiger",
    "redouter",
    "refaire",
    "réflexe",
    "réformer",
    "refrain",
    "refuge",
    "régalien",
    "région",
    "réglage",
    "régulier",
    "réitérer",
    "rejeter",
    "rejouer",
    "relatif",
    "relever",
    "relief",
    "remarque",
    "remède",
    "remise",
    "remonter",
    "remplir",
    "remuer",
    "renard",
    "renfort",
    "renifler",
    "renoncer",
    "rentrer",
    "renvoi",
    "replier",
    "reporter",
    "reprise",
    "reptile",
    "requin",
    "réserve",
    "résineux",
    "résoudre",
    "respect",
    "rester",
    "résultat",
    "rétablir",
    "retenir",
    "réticule",
    "retomber",
    "retracer",
    "réunion",
    "réussir",
    "revanche",
    "revivre",
    "révolte",
    "révulsif",
    "richesse",
    "rideau",
    "rieur",
    "rigide",
    "rigoler",
    "rincer",
    "riposter",
    "risible",
    "risque",
    "rituel",
    "rival",
    "rivière",
    "rocheux",
    "romance",
    "rompre",
    "ronce",
    "rondin",
    "roseau",
    "rosier",
    "rotatif",
    "rotor",
    "rotule",
    "rouge",
    "rouille",
    "rouleau",
    "routine",
    "royaume",
    "ruban",
    "rubis",
    "ruche",
    "ruelle",
    "rugueux",
    "ruiner",
    "ruisseau",
    "ruser",
    "rustique",
    "rythme",
    "sabler",
    "saboter",
    "sabre",
    "sacoche",
    "safari",
    "sagesse",
    "saisir",
    "salade",
    "salive",
    "salon",
    "saluer",
    "samedi",
    "sanction",
    "sanglier",
    "sarcasme",
    "sardine",
    "saturer",
    "saugrenu",
    "saumon",
    "sauter",
    "sauvage",
    "savant",
    "savonner",
    "scalpel",
    "scandale",
    "scélérat",
    "scénario",
    "sceptre",
    "schéma",
    "science",
    "scinder",
    "score",
    "scrutin",
    "sculpter",
    "séance",
    "sécable",
    "sécher",
    "secouer",
    "sécréter",
    "sédatif",
    "séduire",
    "seigneur",
    "séjour",
    "sélectif",
    "semaine",
    "sembler",
    "semence",
    "séminal",
    "sénateur",
    "sensible",
    "sentence",
    "séparer",
    "séquence",
    "serein",
    "sergent",
    "sérieux",
    "serrure",
    "sérum",
    "service",
    "sésame",
    "sévir",
    "sevrage",
    "sextuple",
    "sidéral",
    "siècle",
    "siéger",
    "siffler",
    "sigle",
    "signal",
    "silence",
    "silicium",
    "simple",
    "sincère",
    "sinistre",
    "siphon",
    "sirop",
    "sismique",
    "situer",
    "skier",
    "social",
    "socle",
    "sodium",
    "soigneux",
    "soldat",
    "soleil",
    "solitude",
    "soluble",
    "sombre",
    "sommeil",
    "somnoler",
    "sonde",
    "songeur",
    "sonnette",
    "sonore",
    "sorcier",
    "sortir",
    "sosie",
    "sottise",
    "soucieux",
    "soudure",
    "souffle",
    "soulever",
    "soupape",
    "source",
    "soutirer",
    "souvenir",
    "spacieux",
    "spatial",
    "spécial",
    "sphère",
    "spiral",
    "stable",
    "station",
    "sternum",
    "stimulus",
    "stipuler",
    "strict",
    "studieux",
    "stupeur",
    "styliste",
    "sublime",
    "substrat",
    "subtil",
    "subvenir",
    "succès",
    "sucre",
    "suffixe",
    "suggérer",
    "suiveur",
    "sulfate",
    "superbe",
    "supplier",
    "surface",
    "suricate",
    "surmener",
    "surprise",
    "sursaut",
    "survie",
    "suspect",
    "syllabe",
    "symbole",
    "symétrie",
    "synapse",
    "syntaxe",
    "système",
    "tabac",
    "tablier",
    "tactile",
    "tailler",
    "talent",
    "talisman",
    "talonner",
    "tambour",
    "tamiser",
    "tangible",
    "tapis",
    "taquiner",
    "tarder",
    "tarif",
    "tartine",
    "tasse",
    "tatami",
    "tatouage",
    "taupe",
    "taureau",
    "taxer",
    "témoin",
    "temporel",
    "tenaille",
    "tendre",
    "teneur",
    "tenir",
    "tension",
    "terminer",
    "terne",
    "terrible",
    "tétine",
    "texte",
    "thème",
    "théorie",
    "thérapie",
    "thorax",
    "tibia",
    "tiède",
    "timide",
    "tirelire",
    "tiroir",
    "tissu",
    "titane",
    "titre",
    "tituber",
    "toboggan",
    "tolérant",
    "tomate",
    "tonique",
    "tonneau",
    "toponyme",
    "torche",
    "tordre",
    "tornade",
    "torpille",
    "torrent",
    "torse",
    "tortue",
    "totem",
    "toucher",
    "tournage",
    "tousser",
    "toxine",
    "traction",
    "trafic",
    "tragique",
    "trahir",
    "train",
    "trancher",
    "travail",
    "trèfle",
    "tremper",
    "trésor",
    "treuil",
    "triage",
    "tribunal",
    "tricoter",
    "trilogie",
    "triomphe",
    "tripler",
    "triturer",
    "trivial",
    "trombone",
    "tronc",
    "tropical",
    "troupeau",
    "tuile",
    "tulipe",
    "tumulte",
    "tunnel",
    "turbine",
    "tuteur",
    "tutoyer",
    "tuyau",
    "tympan",
    "typhon",
    "typique",
    "tyran",
    "ubuesque",
    "ultime",
    "ultrason",
    "unanime",
    "unifier",
    "union",
    "unique",
    "unitaire",
    "univers",
    "uranium",
    "urbain",
    "urticant",
    "usage",
    "usine",
    "usuel",
    "usure",
    "utile",
    "utopie",
    "vacarme",
    "vaccin",
    "vagabond",
    "vague",
    "vaillant",
    "vaincre",
    "vaisseau",
    "valable",
    "valise",
    "vallon",
    "valve",
    "vampire",
    "vanille",
    "vapeur",
    "varier",
    "vaseux",
    "vassal",
    "vaste",
    "vecteur",
    "vedette",
    "végétal",
    "véhicule",
    "veinard",
    "véloce",
    "vendredi",
    "vénérer",
    "venger",
    "venimeux",
    "ventouse",
    "verdure",
    "vérin",
    "vernir",
    "verrou",
    "verser",
    "vertu",
    "veston",
    "vétéran",
    "vétuste",
    "vexant",
    "vexer",
    "viaduc",
    "viande",
    "victoire",
    "vidange",
    "vidéo",
    "vignette",
    "vigueur",
    "vilain",
    "village",
    "vinaigre",
    "violon",
    "vipère",
    "virement",
    "virtuose",
    "virus",
    "visage",
    "viseur",
    "vision",
    "visqueux",
    "visuel",
    "vital",
    "vitesse",
    "viticole",
    "vitrine",
    "vivace",
    "vivipare",
    "vocation",
    "voguer",
    "voile",
    "voisin",
    "voiture",
    "volaille",
    "volcan",
    "voltiger",
    "volume",
    "vorace",
    "vortex",
    "voter",
    "vouloir",
    "voyage",
    "voyelle",
    "wagon",
    "xénon",
    "yacht",
    "zèbre",
    "zénith",
    "zeste",
    "zoologie"
  ]), Gu;
}
var Ju, H3;
function uy() {
  return H3 || (H3 = 1, Ju = [
    "abaco",
    "abbaglio",
    "abbinato",
    "abete",
    "abisso",
    "abolire",
    "abrasivo",
    "abrogato",
    "accadere",
    "accenno",
    "accusato",
    "acetone",
    "achille",
    "acido",
    "acqua",
    "acre",
    "acrilico",
    "acrobata",
    "acuto",
    "adagio",
    "addebito",
    "addome",
    "adeguato",
    "aderire",
    "adipe",
    "adottare",
    "adulare",
    "affabile",
    "affetto",
    "affisso",
    "affranto",
    "aforisma",
    "afoso",
    "africano",
    "agave",
    "agente",
    "agevole",
    "aggancio",
    "agire",
    "agitare",
    "agonismo",
    "agricolo",
    "agrumeto",
    "aguzzo",
    "alabarda",
    "alato",
    "albatro",
    "alberato",
    "albo",
    "albume",
    "alce",
    "alcolico",
    "alettone",
    "alfa",
    "algebra",
    "aliante",
    "alibi",
    "alimento",
    "allagato",
    "allegro",
    "allievo",
    "allodola",
    "allusivo",
    "almeno",
    "alogeno",
    "alpaca",
    "alpestre",
    "altalena",
    "alterno",
    "alticcio",
    "altrove",
    "alunno",
    "alveolo",
    "alzare",
    "amalgama",
    "amanita",
    "amarena",
    "ambito",
    "ambrato",
    "ameba",
    "america",
    "ametista",
    "amico",
    "ammasso",
    "ammenda",
    "ammirare",
    "ammonito",
    "amore",
    "ampio",
    "ampliare",
    "amuleto",
    "anacardo",
    "anagrafe",
    "analista",
    "anarchia",
    "anatra",
    "anca",
    "ancella",
    "ancora",
    "andare",
    "andrea",
    "anello",
    "angelo",
    "angolare",
    "angusto",
    "anima",
    "annegare",
    "annidato",
    "anno",
    "annuncio",
    "anonimo",
    "anticipo",
    "anzi",
    "apatico",
    "apertura",
    "apode",
    "apparire",
    "appetito",
    "appoggio",
    "approdo",
    "appunto",
    "aprile",
    "arabica",
    "arachide",
    "aragosta",
    "araldica",
    "arancio",
    "aratura",
    "arazzo",
    "arbitro",
    "archivio",
    "ardito",
    "arenile",
    "argento",
    "argine",
    "arguto",
    "aria",
    "armonia",
    "arnese",
    "arredato",
    "arringa",
    "arrosto",
    "arsenico",
    "arso",
    "artefice",
    "arzillo",
    "asciutto",
    "ascolto",
    "asepsi",
    "asettico",
    "asfalto",
    "asino",
    "asola",
    "aspirato",
    "aspro",
    "assaggio",
    "asse",
    "assoluto",
    "assurdo",
    "asta",
    "astenuto",
    "astice",
    "astratto",
    "atavico",
    "ateismo",
    "atomico",
    "atono",
    "attesa",
    "attivare",
    "attorno",
    "attrito",
    "attuale",
    "ausilio",
    "austria",
    "autista",
    "autonomo",
    "autunno",
    "avanzato",
    "avere",
    "avvenire",
    "avviso",
    "avvolgere",
    "azione",
    "azoto",
    "azzimo",
    "azzurro",
    "babele",
    "baccano",
    "bacino",
    "baco",
    "badessa",
    "badilata",
    "bagnato",
    "baita",
    "balcone",
    "baldo",
    "balena",
    "ballata",
    "balzano",
    "bambino",
    "bandire",
    "baraonda",
    "barbaro",
    "barca",
    "baritono",
    "barlume",
    "barocco",
    "basilico",
    "basso",
    "batosta",
    "battuto",
    "baule",
    "bava",
    "bavosa",
    "becco",
    "beffa",
    "belgio",
    "belva",
    "benda",
    "benevole",
    "benigno",
    "benzina",
    "bere",
    "berlina",
    "beta",
    "bibita",
    "bici",
    "bidone",
    "bifido",
    "biga",
    "bilancia",
    "bimbo",
    "binocolo",
    "biologo",
    "bipede",
    "bipolare",
    "birbante",
    "birra",
    "biscotto",
    "bisesto",
    "bisnonno",
    "bisonte",
    "bisturi",
    "bizzarro",
    "blando",
    "blatta",
    "bollito",
    "bonifico",
    "bordo",
    "bosco",
    "botanico",
    "bottino",
    "bozzolo",
    "braccio",
    "bradipo",
    "brama",
    "branca",
    "bravura",
    "bretella",
    "brevetto",
    "brezza",
    "briglia",
    "brillante",
    "brindare",
    "broccolo",
    "brodo",
    "bronzina",
    "brullo",
    "bruno",
    "bubbone",
    "buca",
    "budino",
    "buffone",
    "buio",
    "bulbo",
    "buono",
    "burlone",
    "burrasca",
    "bussola",
    "busta",
    "cadetto",
    "caduco",
    "calamaro",
    "calcolo",
    "calesse",
    "calibro",
    "calmo",
    "caloria",
    "cambusa",
    "camerata",
    "camicia",
    "cammino",
    "camola",
    "campale",
    "canapa",
    "candela",
    "cane",
    "canino",
    "canotto",
    "cantina",
    "capace",
    "capello",
    "capitolo",
    "capogiro",
    "cappero",
    "capra",
    "capsula",
    "carapace",
    "carcassa",
    "cardo",
    "carisma",
    "carovana",
    "carretto",
    "cartolina",
    "casaccio",
    "cascata",
    "caserma",
    "caso",
    "cassone",
    "castello",
    "casuale",
    "catasta",
    "catena",
    "catrame",
    "cauto",
    "cavillo",
    "cedibile",
    "cedrata",
    "cefalo",
    "celebre",
    "cellulare",
    "cena",
    "cenone",
    "centesimo",
    "ceramica",
    "cercare",
    "certo",
    "cerume",
    "cervello",
    "cesoia",
    "cespo",
    "ceto",
    "chela",
    "chiaro",
    "chicca",
    "chiedere",
    "chimera",
    "china",
    "chirurgo",
    "chitarra",
    "ciao",
    "ciclismo",
    "cifrare",
    "cigno",
    "cilindro",
    "ciottolo",
    "circa",
    "cirrosi",
    "citrico",
    "cittadino",
    "ciuffo",
    "civetta",
    "civile",
    "classico",
    "clinica",
    "cloro",
    "cocco",
    "codardo",
    "codice",
    "coerente",
    "cognome",
    "collare",
    "colmato",
    "colore",
    "colposo",
    "coltivato",
    "colza",
    "coma",
    "cometa",
    "commando",
    "comodo",
    "computer",
    "comune",
    "conciso",
    "condurre",
    "conferma",
    "congelare",
    "coniuge",
    "connesso",
    "conoscere",
    "consumo",
    "continuo",
    "convegno",
    "coperto",
    "copione",
    "coppia",
    "copricapo",
    "corazza",
    "cordata",
    "coricato",
    "cornice",
    "corolla",
    "corpo",
    "corredo",
    "corsia",
    "cortese",
    "cosmico",
    "costante",
    "cottura",
    "covato",
    "cratere",
    "cravatta",
    "creato",
    "credere",
    "cremoso",
    "crescita",
    "creta",
    "criceto",
    "crinale",
    "crisi",
    "critico",
    "croce",
    "cronaca",
    "crostata",
    "cruciale",
    "crusca",
    "cucire",
    "cuculo",
    "cugino",
    "cullato",
    "cupola",
    "curatore",
    "cursore",
    "curvo",
    "cuscino",
    "custode",
    "dado",
    "daino",
    "dalmata",
    "damerino",
    "daniela",
    "dannoso",
    "danzare",
    "datato",
    "davanti",
    "davvero",
    "debutto",
    "decennio",
    "deciso",
    "declino",
    "decollo",
    "decreto",
    "dedicato",
    "definito",
    "deforme",
    "degno",
    "delegare",
    "delfino",
    "delirio",
    "delta",
    "demenza",
    "denotato",
    "dentro",
    "deposito",
    "derapata",
    "derivare",
    "deroga",
    "descritto",
    "deserto",
    "desiderio",
    "desumere",
    "detersivo",
    "devoto",
    "diametro",
    "dicembre",
    "diedro",
    "difeso",
    "diffuso",
    "digerire",
    "digitale",
    "diluvio",
    "dinamico",
    "dinnanzi",
    "dipinto",
    "diploma",
    "dipolo",
    "diradare",
    "dire",
    "dirotto",
    "dirupo",
    "disagio",
    "discreto",
    "disfare",
    "disgelo",
    "disposto",
    "distanza",
    "disumano",
    "dito",
    "divano",
    "divelto",
    "dividere",
    "divorato",
    "doblone",
    "docente",
    "doganale",
    "dogma",
    "dolce",
    "domato",
    "domenica",
    "dominare",
    "dondolo",
    "dono",
    "dormire",
    "dote",
    "dottore",
    "dovuto",
    "dozzina",
    "drago",
    "druido",
    "dubbio",
    "dubitare",
    "ducale",
    "duna",
    "duomo",
    "duplice",
    "duraturo",
    "ebano",
    "eccesso",
    "ecco",
    "eclissi",
    "economia",
    "edera",
    "edicola",
    "edile",
    "editoria",
    "educare",
    "egemonia",
    "egli",
    "egoismo",
    "egregio",
    "elaborato",
    "elargire",
    "elegante",
    "elencato",
    "eletto",
    "elevare",
    "elfico",
    "elica",
    "elmo",
    "elsa",
    "eluso",
    "emanato",
    "emblema",
    "emesso",
    "emiro",
    "emotivo",
    "emozione",
    "empirico",
    "emulo",
    "endemico",
    "enduro",
    "energia",
    "enfasi",
    "enoteca",
    "entrare",
    "enzima",
    "epatite",
    "epilogo",
    "episodio",
    "epocale",
    "eppure",
    "equatore",
    "erario",
    "erba",
    "erboso",
    "erede",
    "eremita",
    "erigere",
    "ermetico",
    "eroe",
    "erosivo",
    "errante",
    "esagono",
    "esame",
    "esanime",
    "esaudire",
    "esca",
    "esempio",
    "esercito",
    "esibito",
    "esigente",
    "esistere",
    "esito",
    "esofago",
    "esortato",
    "esoso",
    "espanso",
    "espresso",
    "essenza",
    "esso",
    "esteso",
    "estimare",
    "estonia",
    "estroso",
    "esultare",
    "etilico",
    "etnico",
    "etrusco",
    "etto",
    "euclideo",
    "europa",
    "evaso",
    "evidenza",
    "evitato",
    "evoluto",
    "evviva",
    "fabbrica",
    "faccenda",
    "fachiro",
    "falco",
    "famiglia",
    "fanale",
    "fanfara",
    "fango",
    "fantasma",
    "fare",
    "farfalla",
    "farinoso",
    "farmaco",
    "fascia",
    "fastoso",
    "fasullo",
    "faticare",
    "fato",
    "favoloso",
    "febbre",
    "fecola",
    "fede",
    "fegato",
    "felpa",
    "feltro",
    "femmina",
    "fendere",
    "fenomeno",
    "fermento",
    "ferro",
    "fertile",
    "fessura",
    "festivo",
    "fetta",
    "feudo",
    "fiaba",
    "fiducia",
    "fifa",
    "figurato",
    "filo",
    "finanza",
    "finestra",
    "finire",
    "fiore",
    "fiscale",
    "fisico",
    "fiume",
    "flacone",
    "flamenco",
    "flebo",
    "flemma",
    "florido",
    "fluente",
    "fluoro",
    "fobico",
    "focaccia",
    "focoso",
    "foderato",
    "foglio",
    "folata",
    "folclore",
    "folgore",
    "fondente",
    "fonetico",
    "fonia",
    "fontana",
    "forbito",
    "forchetta",
    "foresta",
    "formica",
    "fornaio",
    "foro",
    "fortezza",
    "forzare",
    "fosfato",
    "fosso",
    "fracasso",
    "frana",
    "frassino",
    "fratello",
    "freccetta",
    "frenata",
    "fresco",
    "frigo",
    "frollino",
    "fronde",
    "frugale",
    "frutta",
    "fucilata",
    "fucsia",
    "fuggente",
    "fulmine",
    "fulvo",
    "fumante",
    "fumetto",
    "fumoso",
    "fune",
    "funzione",
    "fuoco",
    "furbo",
    "furgone",
    "furore",
    "fuso",
    "futile",
    "gabbiano",
    "gaffe",
    "galateo",
    "gallina",
    "galoppo",
    "gambero",
    "gamma",
    "garanzia",
    "garbo",
    "garofano",
    "garzone",
    "gasdotto",
    "gasolio",
    "gastrico",
    "gatto",
    "gaudio",
    "gazebo",
    "gazzella",
    "geco",
    "gelatina",
    "gelso",
    "gemello",
    "gemmato",
    "gene",
    "genitore",
    "gennaio",
    "genotipo",
    "gergo",
    "ghepardo",
    "ghiaccio",
    "ghisa",
    "giallo",
    "gilda",
    "ginepro",
    "giocare",
    "gioiello",
    "giorno",
    "giove",
    "girato",
    "girone",
    "gittata",
    "giudizio",
    "giurato",
    "giusto",
    "globulo",
    "glutine",
    "gnomo",
    "gobba",
    "golf",
    "gomito",
    "gommone",
    "gonfio",
    "gonna",
    "governo",
    "gracile",
    "grado",
    "grafico",
    "grammo",
    "grande",
    "grattare",
    "gravoso",
    "grazia",
    "greca",
    "gregge",
    "grifone",
    "grigio",
    "grinza",
    "grotta",
    "gruppo",
    "guadagno",
    "guaio",
    "guanto",
    "guardare",
    "gufo",
    "guidare",
    "ibernato",
    "icona",
    "identico",
    "idillio",
    "idolo",
    "idra",
    "idrico",
    "idrogeno",
    "igiene",
    "ignaro",
    "ignorato",
    "ilare",
    "illeso",
    "illogico",
    "illudere",
    "imballo",
    "imbevuto",
    "imbocco",
    "imbuto",
    "immane",
    "immerso",
    "immolato",
    "impacco",
    "impeto",
    "impiego",
    "importo",
    "impronta",
    "inalare",
    "inarcare",
    "inattivo",
    "incanto",
    "incendio",
    "inchino",
    "incisivo",
    "incluso",
    "incontro",
    "incrocio",
    "incubo",
    "indagine",
    "india",
    "indole",
    "inedito",
    "infatti",
    "infilare",
    "inflitto",
    "ingaggio",
    "ingegno",
    "inglese",
    "ingordo",
    "ingrosso",
    "innesco",
    "inodore",
    "inoltrare",
    "inondato",
    "insano",
    "insetto",
    "insieme",
    "insonnia",
    "insulina",
    "intasato",
    "intero",
    "intonaco",
    "intuito",
    "inumidire",
    "invalido",
    "invece",
    "invito",
    "iperbole",
    "ipnotico",
    "ipotesi",
    "ippica",
    "iride",
    "irlanda",
    "ironico",
    "irrigato",
    "irrorare",
    "isolato",
    "isotopo",
    "isterico",
    "istituto",
    "istrice",
    "italia",
    "iterare",
    "labbro",
    "labirinto",
    "lacca",
    "lacerato",
    "lacrima",
    "lacuna",
    "laddove",
    "lago",
    "lampo",
    "lancetta",
    "lanterna",
    "lardoso",
    "larga",
    "laringe",
    "lastra",
    "latenza",
    "latino",
    "lattuga",
    "lavagna",
    "lavoro",
    "legale",
    "leggero",
    "lembo",
    "lentezza",
    "lenza",
    "leone",
    "lepre",
    "lesivo",
    "lessato",
    "lesto",
    "letterale",
    "leva",
    "levigato",
    "libero",
    "lido",
    "lievito",
    "lilla",
    "limatura",
    "limitare",
    "limpido",
    "lineare",
    "lingua",
    "liquido",
    "lira",
    "lirica",
    "lisca",
    "lite",
    "litigio",
    "livrea",
    "locanda",
    "lode",
    "logica",
    "lombare",
    "londra",
    "longevo",
    "loquace",
    "lorenzo",
    "loto",
    "lotteria",
    "luce",
    "lucidato",
    "lumaca",
    "luminoso",
    "lungo",
    "lupo",
    "luppolo",
    "lusinga",
    "lusso",
    "lutto",
    "macabro",
    "macchina",
    "macero",
    "macinato",
    "madama",
    "magico",
    "maglia",
    "magnete",
    "magro",
    "maiolica",
    "malafede",
    "malgrado",
    "malinteso",
    "malsano",
    "malto",
    "malumore",
    "mana",
    "mancia",
    "mandorla",
    "mangiare",
    "manifesto",
    "mannaro",
    "manovra",
    "mansarda",
    "mantide",
    "manubrio",
    "mappa",
    "maratona",
    "marcire",
    "maretta",
    "marmo",
    "marsupio",
    "maschera",
    "massaia",
    "mastino",
    "materasso",
    "matricola",
    "mattone",
    "maturo",
    "mazurca",
    "meandro",
    "meccanico",
    "mecenate",
    "medesimo",
    "meditare",
    "mega",
    "melassa",
    "melis",
    "melodia",
    "meninge",
    "meno",
    "mensola",
    "mercurio",
    "merenda",
    "merlo",
    "meschino",
    "mese",
    "messere",
    "mestolo",
    "metallo",
    "metodo",
    "mettere",
    "miagolare",
    "mica",
    "micelio",
    "michele",
    "microbo",
    "midollo",
    "miele",
    "migliore",
    "milano",
    "milite",
    "mimosa",
    "minerale",
    "mini",
    "minore",
    "mirino",
    "mirtillo",
    "miscela",
    "missiva",
    "misto",
    "misurare",
    "mitezza",
    "mitigare",
    "mitra",
    "mittente",
    "mnemonico",
    "modello",
    "modifica",
    "modulo",
    "mogano",
    "mogio",
    "mole",
    "molosso",
    "monastero",
    "monco",
    "mondina",
    "monetario",
    "monile",
    "monotono",
    "monsone",
    "montato",
    "monviso",
    "mora",
    "mordere",
    "morsicato",
    "mostro",
    "motivato",
    "motosega",
    "motto",
    "movenza",
    "movimento",
    "mozzo",
    "mucca",
    "mucosa",
    "muffa",
    "mughetto",
    "mugnaio",
    "mulatto",
    "mulinello",
    "multiplo",
    "mummia",
    "munto",
    "muovere",
    "murale",
    "musa",
    "muscolo",
    "musica",
    "mutevole",
    "muto",
    "nababbo",
    "nafta",
    "nanometro",
    "narciso",
    "narice",
    "narrato",
    "nascere",
    "nastrare",
    "naturale",
    "nautica",
    "naviglio",
    "nebulosa",
    "necrosi",
    "negativo",
    "negozio",
    "nemmeno",
    "neofita",
    "neretto",
    "nervo",
    "nessuno",
    "nettuno",
    "neutrale",
    "neve",
    "nevrotico",
    "nicchia",
    "ninfa",
    "nitido",
    "nobile",
    "nocivo",
    "nodo",
    "nome",
    "nomina",
    "nordico",
    "normale",
    "norvegese",
    "nostrano",
    "notare",
    "notizia",
    "notturno",
    "novella",
    "nucleo",
    "nulla",
    "numero",
    "nuovo",
    "nutrire",
    "nuvola",
    "nuziale",
    "oasi",
    "obbedire",
    "obbligo",
    "obelisco",
    "oblio",
    "obolo",
    "obsoleto",
    "occasione",
    "occhio",
    "occidente",
    "occorrere",
    "occultare",
    "ocra",
    "oculato",
    "odierno",
    "odorare",
    "offerta",
    "offrire",
    "offuscato",
    "oggetto",
    "oggi",
    "ognuno",
    "olandese",
    "olfatto",
    "oliato",
    "oliva",
    "ologramma",
    "oltre",
    "omaggio",
    "ombelico",
    "ombra",
    "omega",
    "omissione",
    "ondoso",
    "onere",
    "onice",
    "onnivoro",
    "onorevole",
    "onta",
    "operato",
    "opinione",
    "opposto",
    "oracolo",
    "orafo",
    "ordine",
    "orecchino",
    "orefice",
    "orfano",
    "organico",
    "origine",
    "orizzonte",
    "orma",
    "ormeggio",
    "ornativo",
    "orologio",
    "orrendo",
    "orribile",
    "ortensia",
    "ortica",
    "orzata",
    "orzo",
    "osare",
    "oscurare",
    "osmosi",
    "ospedale",
    "ospite",
    "ossa",
    "ossidare",
    "ostacolo",
    "oste",
    "otite",
    "otre",
    "ottagono",
    "ottimo",
    "ottobre",
    "ovale",
    "ovest",
    "ovino",
    "oviparo",
    "ovocito",
    "ovunque",
    "ovviare",
    "ozio",
    "pacchetto",
    "pace",
    "pacifico",
    "padella",
    "padrone",
    "paese",
    "paga",
    "pagina",
    "palazzina",
    "palesare",
    "pallido",
    "palo",
    "palude",
    "pandoro",
    "pannello",
    "paolo",
    "paonazzo",
    "paprica",
    "parabola",
    "parcella",
    "parere",
    "pargolo",
    "pari",
    "parlato",
    "parola",
    "partire",
    "parvenza",
    "parziale",
    "passivo",
    "pasticca",
    "patacca",
    "patologia",
    "pattume",
    "pavone",
    "peccato",
    "pedalare",
    "pedonale",
    "peggio",
    "peloso",
    "penare",
    "pendice",
    "penisola",
    "pennuto",
    "penombra",
    "pensare",
    "pentola",
    "pepe",
    "pepita",
    "perbene",
    "percorso",
    "perdonato",
    "perforare",
    "pergamena",
    "periodo",
    "permesso",
    "perno",
    "perplesso",
    "persuaso",
    "pertugio",
    "pervaso",
    "pesatore",
    "pesista",
    "peso",
    "pestifero",
    "petalo",
    "pettine",
    "petulante",
    "pezzo",
    "piacere",
    "pianta",
    "piattino",
    "piccino",
    "picozza",
    "piega",
    "pietra",
    "piffero",
    "pigiama",
    "pigolio",
    "pigro",
    "pila",
    "pilifero",
    "pillola",
    "pilota",
    "pimpante",
    "pineta",
    "pinna",
    "pinolo",
    "pioggia",
    "piombo",
    "piramide",
    "piretico",
    "pirite",
    "pirolisi",
    "pitone",
    "pizzico",
    "placebo",
    "planare",
    "plasma",
    "platano",
    "plenario",
    "pochezza",
    "poderoso",
    "podismo",
    "poesia",
    "poggiare",
    "polenta",
    "poligono",
    "pollice",
    "polmonite",
    "polpetta",
    "polso",
    "poltrona",
    "polvere",
    "pomice",
    "pomodoro",
    "ponte",
    "popoloso",
    "porfido",
    "poroso",
    "porpora",
    "porre",
    "portata",
    "posa",
    "positivo",
    "possesso",
    "postulato",
    "potassio",
    "potere",
    "pranzo",
    "prassi",
    "pratica",
    "precluso",
    "predica",
    "prefisso",
    "pregiato",
    "prelievo",
    "premere",
    "prenotare",
    "preparato",
    "presenza",
    "pretesto",
    "prevalso",
    "prima",
    "principe",
    "privato",
    "problema",
    "procura",
    "produrre",
    "profumo",
    "progetto",
    "prolunga",
    "promessa",
    "pronome",
    "proposta",
    "proroga",
    "proteso",
    "prova",
    "prudente",
    "prugna",
    "prurito",
    "psiche",
    "pubblico",
    "pudica",
    "pugilato",
    "pugno",
    "pulce",
    "pulito",
    "pulsante",
    "puntare",
    "pupazzo",
    "pupilla",
    "puro",
    "quadro",
    "qualcosa",
    "quasi",
    "querela",
    "quota",
    "raccolto",
    "raddoppio",
    "radicale",
    "radunato",
    "raffica",
    "ragazzo",
    "ragione",
    "ragno",
    "ramarro",
    "ramingo",
    "ramo",
    "randagio",
    "rantolare",
    "rapato",
    "rapina",
    "rappreso",
    "rasatura",
    "raschiato",
    "rasente",
    "rassegna",
    "rastrello",
    "rata",
    "ravveduto",
    "reale",
    "recepire",
    "recinto",
    "recluta",
    "recondito",
    "recupero",
    "reddito",
    "redimere",
    "regalato",
    "registro",
    "regola",
    "regresso",
    "relazione",
    "remare",
    "remoto",
    "renna",
    "replica",
    "reprimere",
    "reputare",
    "resa",
    "residente",
    "responso",
    "restauro",
    "rete",
    "retina",
    "retorica",
    "rettifica",
    "revocato",
    "riassunto",
    "ribadire",
    "ribelle",
    "ribrezzo",
    "ricarica",
    "ricco",
    "ricevere",
    "riciclato",
    "ricordo",
    "ricreduto",
    "ridicolo",
    "ridurre",
    "rifasare",
    "riflesso",
    "riforma",
    "rifugio",
    "rigare",
    "rigettato",
    "righello",
    "rilassato",
    "rilevato",
    "rimanere",
    "rimbalzo",
    "rimedio",
    "rimorchio",
    "rinascita",
    "rincaro",
    "rinforzo",
    "rinnovo",
    "rinomato",
    "rinsavito",
    "rintocco",
    "rinuncia",
    "rinvenire",
    "riparato",
    "ripetuto",
    "ripieno",
    "riportare",
    "ripresa",
    "ripulire",
    "risata",
    "rischio",
    "riserva",
    "risibile",
    "riso",
    "rispetto",
    "ristoro",
    "risultato",
    "risvolto",
    "ritardo",
    "ritegno",
    "ritmico",
    "ritrovo",
    "riunione",
    "riva",
    "riverso",
    "rivincita",
    "rivolto",
    "rizoma",
    "roba",
    "robotico",
    "robusto",
    "roccia",
    "roco",
    "rodaggio",
    "rodere",
    "roditore",
    "rogito",
    "rollio",
    "romantico",
    "rompere",
    "ronzio",
    "rosolare",
    "rospo",
    "rotante",
    "rotondo",
    "rotula",
    "rovescio",
    "rubizzo",
    "rubrica",
    "ruga",
    "rullino",
    "rumine",
    "rumoroso",
    "ruolo",
    "rupe",
    "russare",
    "rustico",
    "sabato",
    "sabbiare",
    "sabotato",
    "sagoma",
    "salasso",
    "saldatura",
    "salgemma",
    "salivare",
    "salmone",
    "salone",
    "saltare",
    "saluto",
    "salvo",
    "sapere",
    "sapido",
    "saporito",
    "saraceno",
    "sarcasmo",
    "sarto",
    "sassoso",
    "satellite",
    "satira",
    "satollo",
    "saturno",
    "savana",
    "savio",
    "saziato",
    "sbadiglio",
    "sbalzo",
    "sbancato",
    "sbarra",
    "sbattere",
    "sbavare",
    "sbendare",
    "sbirciare",
    "sbloccato",
    "sbocciato",
    "sbrinare",
    "sbruffone",
    "sbuffare",
    "scabroso",
    "scadenza",
    "scala",
    "scambiare",
    "scandalo",
    "scapola",
    "scarso",
    "scatenare",
    "scavato",
    "scelto",
    "scenico",
    "scettro",
    "scheda",
    "schiena",
    "sciarpa",
    "scienza",
    "scindere",
    "scippo",
    "sciroppo",
    "scivolo",
    "sclerare",
    "scodella",
    "scolpito",
    "scomparto",
    "sconforto",
    "scoprire",
    "scorta",
    "scossone",
    "scozzese",
    "scriba",
    "scrollare",
    "scrutinio",
    "scuderia",
    "scultore",
    "scuola",
    "scuro",
    "scusare",
    "sdebitare",
    "sdoganare",
    "seccatura",
    "secondo",
    "sedano",
    "seggiola",
    "segnalato",
    "segregato",
    "seguito",
    "selciato",
    "selettivo",
    "sella",
    "selvaggio",
    "semaforo",
    "sembrare",
    "seme",
    "seminato",
    "sempre",
    "senso",
    "sentire",
    "sepolto",
    "sequenza",
    "serata",
    "serbato",
    "sereno",
    "serio",
    "serpente",
    "serraglio",
    "servire",
    "sestina",
    "setola",
    "settimana",
    "sfacelo",
    "sfaldare",
    "sfamato",
    "sfarzoso",
    "sfaticato",
    "sfera",
    "sfida",
    "sfilato",
    "sfinge",
    "sfocato",
    "sfoderare",
    "sfogo",
    "sfoltire",
    "sforzato",
    "sfratto",
    "sfruttato",
    "sfuggito",
    "sfumare",
    "sfuso",
    "sgabello",
    "sgarbato",
    "sgonfiare",
    "sgorbio",
    "sgrassato",
    "sguardo",
    "sibilo",
    "siccome",
    "sierra",
    "sigla",
    "signore",
    "silenzio",
    "sillaba",
    "simbolo",
    "simpatico",
    "simulato",
    "sinfonia",
    "singolo",
    "sinistro",
    "sino",
    "sintesi",
    "sinusoide",
    "sipario",
    "sisma",
    "sistole",
    "situato",
    "slitta",
    "slogatura",
    "sloveno",
    "smarrito",
    "smemorato",
    "smentito",
    "smeraldo",
    "smilzo",
    "smontare",
    "smottato",
    "smussato",
    "snellire",
    "snervato",
    "snodo",
    "sobbalzo",
    "sobrio",
    "soccorso",
    "sociale",
    "sodale",
    "soffitto",
    "sogno",
    "soldato",
    "solenne",
    "solido",
    "sollazzo",
    "solo",
    "solubile",
    "solvente",
    "somatico",
    "somma",
    "sonda",
    "sonetto",
    "sonnifero",
    "sopire",
    "soppeso",
    "sopra",
    "sorgere",
    "sorpasso",
    "sorriso",
    "sorso",
    "sorteggio",
    "sorvolato",
    "sospiro",
    "sosta",
    "sottile",
    "spada",
    "spalla",
    "spargere",
    "spatola",
    "spavento",
    "spazzola",
    "specie",
    "spedire",
    "spegnere",
    "spelatura",
    "speranza",
    "spessore",
    "spettrale",
    "spezzato",
    "spia",
    "spigoloso",
    "spillato",
    "spinoso",
    "spirale",
    "splendido",
    "sportivo",
    "sposo",
    "spranga",
    "sprecare",
    "spronato",
    "spruzzo",
    "spuntino",
    "squillo",
    "sradicare",
    "srotolato",
    "stabile",
    "stacco",
    "staffa",
    "stagnare",
    "stampato",
    "stantio",
    "starnuto",
    "stasera",
    "statuto",
    "stelo",
    "steppa",
    "sterzo",
    "stiletto",
    "stima",
    "stirpe",
    "stivale",
    "stizzoso",
    "stonato",
    "storico",
    "strappo",
    "stregato",
    "stridulo",
    "strozzare",
    "strutto",
    "stuccare",
    "stufo",
    "stupendo",
    "subentro",
    "succoso",
    "sudore",
    "suggerito",
    "sugo",
    "sultano",
    "suonare",
    "superbo",
    "supporto",
    "surgelato",
    "surrogato",
    "sussurro",
    "sutura",
    "svagare",
    "svedese",
    "sveglio",
    "svelare",
    "svenuto",
    "svezia",
    "sviluppo",
    "svista",
    "svizzera",
    "svolta",
    "svuotare",
    "tabacco",
    "tabulato",
    "tacciare",
    "taciturno",
    "tale",
    "talismano",
    "tampone",
    "tannino",
    "tara",
    "tardivo",
    "targato",
    "tariffa",
    "tarpare",
    "tartaruga",
    "tasto",
    "tattico",
    "taverna",
    "tavolata",
    "tazza",
    "teca",
    "tecnico",
    "telefono",
    "temerario",
    "tempo",
    "temuto",
    "tendone",
    "tenero",
    "tensione",
    "tentacolo",
    "teorema",
    "terme",
    "terrazzo",
    "terzetto",
    "tesi",
    "tesserato",
    "testato",
    "tetro",
    "tettoia",
    "tifare",
    "tigella",
    "timbro",
    "tinto",
    "tipico",
    "tipografo",
    "tiraggio",
    "tiro",
    "titanio",
    "titolo",
    "titubante",
    "tizio",
    "tizzone",
    "toccare",
    "tollerare",
    "tolto",
    "tombola",
    "tomo",
    "tonfo",
    "tonsilla",
    "topazio",
    "topologia",
    "toppa",
    "torba",
    "tornare",
    "torrone",
    "tortora",
    "toscano",
    "tossire",
    "tostatura",
    "totano",
    "trabocco",
    "trachea",
    "trafila",
    "tragedia",
    "tralcio",
    "tramonto",
    "transito",
    "trapano",
    "trarre",
    "trasloco",
    "trattato",
    "trave",
    "treccia",
    "tremolio",
    "trespolo",
    "tributo",
    "tricheco",
    "trifoglio",
    "trillo",
    "trincea",
    "trio",
    "tristezza",
    "triturato",
    "trivella",
    "tromba",
    "trono",
    "troppo",
    "trottola",
    "trovare",
    "truccato",
    "tubatura",
    "tuffato",
    "tulipano",
    "tumulto",
    "tunisia",
    "turbare",
    "turchino",
    "tuta",
    "tutela",
    "ubicato",
    "uccello",
    "uccisore",
    "udire",
    "uditivo",
    "uffa",
    "ufficio",
    "uguale",
    "ulisse",
    "ultimato",
    "umano",
    "umile",
    "umorismo",
    "uncinetto",
    "ungere",
    "ungherese",
    "unicorno",
    "unificato",
    "unisono",
    "unitario",
    "unte",
    "uovo",
    "upupa",
    "uragano",
    "urgenza",
    "urlo",
    "usanza",
    "usato",
    "uscito",
    "usignolo",
    "usuraio",
    "utensile",
    "utilizzo",
    "utopia",
    "vacante",
    "vaccinato",
    "vagabondo",
    "vagliato",
    "valanga",
    "valgo",
    "valico",
    "valletta",
    "valoroso",
    "valutare",
    "valvola",
    "vampata",
    "vangare",
    "vanitoso",
    "vano",
    "vantaggio",
    "vanvera",
    "vapore",
    "varano",
    "varcato",
    "variante",
    "vasca",
    "vedetta",
    "vedova",
    "veduto",
    "vegetale",
    "veicolo",
    "velcro",
    "velina",
    "velluto",
    "veloce",
    "venato",
    "vendemmia",
    "vento",
    "verace",
    "verbale",
    "vergogna",
    "verifica",
    "vero",
    "verruca",
    "verticale",
    "vescica",
    "vessillo",
    "vestale",
    "veterano",
    "vetrina",
    "vetusto",
    "viandante",
    "vibrante",
    "vicenda",
    "vichingo",
    "vicinanza",
    "vidimare",
    "vigilia",
    "vigneto",
    "vigore",
    "vile",
    "villano",
    "vimini",
    "vincitore",
    "viola",
    "vipera",
    "virgola",
    "virologo",
    "virulento",
    "viscoso",
    "visione",
    "vispo",
    "vissuto",
    "visura",
    "vita",
    "vitello",
    "vittima",
    "vivanda",
    "vivido",
    "viziare",
    "voce",
    "voga",
    "volatile",
    "volere",
    "volpe",
    "voragine",
    "vulcano",
    "zampogna",
    "zanna",
    "zappato",
    "zattera",
    "zavorra",
    "zefiro",
    "zelante",
    "zelo",
    "zenzero",
    "zerbino",
    "zibetto",
    "zinco",
    "zircone",
    "zitto",
    "zolla",
    "zotico",
    "zucchero",
    "zufolo",
    "zulu",
    "zuppa"
  ]), Ju;
}
var Wu, L3;
function hy() {
  return L3 || (L3 = 1, Wu = [
    "あいこくしん",
    "あいさつ",
    "あいだ",
    "あおぞら",
    "あかちゃん",
    "あきる",
    "あけがた",
    "あける",
    "あこがれる",
    "あさい",
    "あさひ",
    "あしあと",
    "あじわう",
    "あずかる",
    "あずき",
    "あそぶ",
    "あたえる",
    "あたためる",
    "あたりまえ",
    "あたる",
    "あつい",
    "あつかう",
    "あっしゅく",
    "あつまり",
    "あつめる",
    "あてな",
    "あてはまる",
    "あひる",
    "あぶら",
    "あぶる",
    "あふれる",
    "あまい",
    "あまど",
    "あまやかす",
    "あまり",
    "あみもの",
    "あめりか",
    "あやまる",
    "あゆむ",
    "あらいぐま",
    "あらし",
    "あらすじ",
    "あらためる",
    "あらゆる",
    "あらわす",
    "ありがとう",
    "あわせる",
    "あわてる",
    "あんい",
    "あんがい",
    "あんこ",
    "あんぜん",
    "あんてい",
    "あんない",
    "あんまり",
    "いいだす",
    "いおん",
    "いがい",
    "いがく",
    "いきおい",
    "いきなり",
    "いきもの",
    "いきる",
    "いくじ",
    "いくぶん",
    "いけばな",
    "いけん",
    "いこう",
    "いこく",
    "いこつ",
    "いさましい",
    "いさん",
    "いしき",
    "いじゅう",
    "いじょう",
    "いじわる",
    "いずみ",
    "いずれ",
    "いせい",
    "いせえび",
    "いせかい",
    "いせき",
    "いぜん",
    "いそうろう",
    "いそがしい",
    "いだい",
    "いだく",
    "いたずら",
    "いたみ",
    "いたりあ",
    "いちおう",
    "いちじ",
    "いちど",
    "いちば",
    "いちぶ",
    "いちりゅう",
    "いつか",
    "いっしゅん",
    "いっせい",
    "いっそう",
    "いったん",
    "いっち",
    "いってい",
    "いっぽう",
    "いてざ",
    "いてん",
    "いどう",
    "いとこ",
    "いない",
    "いなか",
    "いねむり",
    "いのち",
    "いのる",
    "いはつ",
    "いばる",
    "いはん",
    "いびき",
    "いひん",
    "いふく",
    "いへん",
    "いほう",
    "いみん",
    "いもうと",
    "いもたれ",
    "いもり",
    "いやがる",
    "いやす",
    "いよかん",
    "いよく",
    "いらい",
    "いらすと",
    "いりぐち",
    "いりょう",
    "いれい",
    "いれもの",
    "いれる",
    "いろえんぴつ",
    "いわい",
    "いわう",
    "いわかん",
    "いわば",
    "いわゆる",
    "いんげんまめ",
    "いんさつ",
    "いんしょう",
    "いんよう",
    "うえき",
    "うえる",
    "うおざ",
    "うがい",
    "うかぶ",
    "うかべる",
    "うきわ",
    "うくらいな",
    "うくれれ",
    "うけたまわる",
    "うけつけ",
    "うけとる",
    "うけもつ",
    "うける",
    "うごかす",
    "うごく",
    "うこん",
    "うさぎ",
    "うしなう",
    "うしろがみ",
    "うすい",
    "うすぎ",
    "うすぐらい",
    "うすめる",
    "うせつ",
    "うちあわせ",
    "うちがわ",
    "うちき",
    "うちゅう",
    "うっかり",
    "うつくしい",
    "うったえる",
    "うつる",
    "うどん",
    "うなぎ",
    "うなじ",
    "うなずく",
    "うなる",
    "うねる",
    "うのう",
    "うぶげ",
    "うぶごえ",
    "うまれる",
    "うめる",
    "うもう",
    "うやまう",
    "うよく",
    "うらがえす",
    "うらぐち",
    "うらない",
    "うりあげ",
    "うりきれ",
    "うるさい",
    "うれしい",
    "うれゆき",
    "うれる",
    "うろこ",
    "うわき",
    "うわさ",
    "うんこう",
    "うんちん",
    "うんてん",
    "うんどう",
    "えいえん",
    "えいが",
    "えいきょう",
    "えいご",
    "えいせい",
    "えいぶん",
    "えいよう",
    "えいわ",
    "えおり",
    "えがお",
    "えがく",
    "えきたい",
    "えくせる",
    "えしゃく",
    "えすて",
    "えつらん",
    "えのぐ",
    "えほうまき",
    "えほん",
    "えまき",
    "えもじ",
    "えもの",
    "えらい",
    "えらぶ",
    "えりあ",
    "えんえん",
    "えんかい",
    "えんぎ",
    "えんげき",
    "えんしゅう",
    "えんぜつ",
    "えんそく",
    "えんちょう",
    "えんとつ",
    "おいかける",
    "おいこす",
    "おいしい",
    "おいつく",
    "おうえん",
    "おうさま",
    "おうじ",
    "おうせつ",
    "おうたい",
    "おうふく",
    "おうべい",
    "おうよう",
    "おえる",
    "おおい",
    "おおう",
    "おおどおり",
    "おおや",
    "おおよそ",
    "おかえり",
    "おかず",
    "おがむ",
    "おかわり",
    "おぎなう",
    "おきる",
    "おくさま",
    "おくじょう",
    "おくりがな",
    "おくる",
    "おくれる",
    "おこす",
    "おこなう",
    "おこる",
    "おさえる",
    "おさない",
    "おさめる",
    "おしいれ",
    "おしえる",
    "おじぎ",
    "おじさん",
    "おしゃれ",
    "おそらく",
    "おそわる",
    "おたがい",
    "おたく",
    "おだやか",
    "おちつく",
    "おっと",
    "おつり",
    "おでかけ",
    "おとしもの",
    "おとなしい",
    "おどり",
    "おどろかす",
    "おばさん",
    "おまいり",
    "おめでとう",
    "おもいで",
    "おもう",
    "おもたい",
    "おもちゃ",
    "おやつ",
    "おやゆび",
    "およぼす",
    "おらんだ",
    "おろす",
    "おんがく",
    "おんけい",
    "おんしゃ",
    "おんせん",
    "おんだん",
    "おんちゅう",
    "おんどけい",
    "かあつ",
    "かいが",
    "がいき",
    "がいけん",
    "がいこう",
    "かいさつ",
    "かいしゃ",
    "かいすいよく",
    "かいぜん",
    "かいぞうど",
    "かいつう",
    "かいてん",
    "かいとう",
    "かいふく",
    "がいへき",
    "かいほう",
    "かいよう",
    "がいらい",
    "かいわ",
    "かえる",
    "かおり",
    "かかえる",
    "かがく",
    "かがし",
    "かがみ",
    "かくご",
    "かくとく",
    "かざる",
    "がぞう",
    "かたい",
    "かたち",
    "がちょう",
    "がっきゅう",
    "がっこう",
    "がっさん",
    "がっしょう",
    "かなざわし",
    "かのう",
    "がはく",
    "かぶか",
    "かほう",
    "かほご",
    "かまう",
    "かまぼこ",
    "かめれおん",
    "かゆい",
    "かようび",
    "からい",
    "かるい",
    "かろう",
    "かわく",
    "かわら",
    "がんか",
    "かんけい",
    "かんこう",
    "かんしゃ",
    "かんそう",
    "かんたん",
    "かんち",
    "がんばる",
    "きあい",
    "きあつ",
    "きいろ",
    "ぎいん",
    "きうい",
    "きうん",
    "きえる",
    "きおう",
    "きおく",
    "きおち",
    "きおん",
    "きかい",
    "きかく",
    "きかんしゃ",
    "ききて",
    "きくばり",
    "きくらげ",
    "きけんせい",
    "きこう",
    "きこえる",
    "きこく",
    "きさい",
    "きさく",
    "きさま",
    "きさらぎ",
    "ぎじかがく",
    "ぎしき",
    "ぎじたいけん",
    "ぎじにってい",
    "ぎじゅつしゃ",
    "きすう",
    "きせい",
    "きせき",
    "きせつ",
    "きそう",
    "きぞく",
    "きぞん",
    "きたえる",
    "きちょう",
    "きつえん",
    "ぎっちり",
    "きつつき",
    "きつね",
    "きてい",
    "きどう",
    "きどく",
    "きない",
    "きなが",
    "きなこ",
    "きぬごし",
    "きねん",
    "きのう",
    "きのした",
    "きはく",
    "きびしい",
    "きひん",
    "きふく",
    "きぶん",
    "きぼう",
    "きほん",
    "きまる",
    "きみつ",
    "きむずかしい",
    "きめる",
    "きもだめし",
    "きもち",
    "きもの",
    "きゃく",
    "きやく",
    "ぎゅうにく",
    "きよう",
    "きょうりゅう",
    "きらい",
    "きらく",
    "きりん",
    "きれい",
    "きれつ",
    "きろく",
    "ぎろん",
    "きわめる",
    "ぎんいろ",
    "きんかくじ",
    "きんじょ",
    "きんようび",
    "ぐあい",
    "くいず",
    "くうかん",
    "くうき",
    "くうぐん",
    "くうこう",
    "ぐうせい",
    "くうそう",
    "ぐうたら",
    "くうふく",
    "くうぼ",
    "くかん",
    "くきょう",
    "くげん",
    "ぐこう",
    "くさい",
    "くさき",
    "くさばな",
    "くさる",
    "くしゃみ",
    "くしょう",
    "くすのき",
    "くすりゆび",
    "くせげ",
    "くせん",
    "ぐたいてき",
    "くださる",
    "くたびれる",
    "くちこみ",
    "くちさき",
    "くつした",
    "ぐっすり",
    "くつろぐ",
    "くとうてん",
    "くどく",
    "くなん",
    "くねくね",
    "くのう",
    "くふう",
    "くみあわせ",
    "くみたてる",
    "くめる",
    "くやくしょ",
    "くらす",
    "くらべる",
    "くるま",
    "くれる",
    "くろう",
    "くわしい",
    "ぐんかん",
    "ぐんしょく",
    "ぐんたい",
    "ぐんて",
    "けあな",
    "けいかく",
    "けいけん",
    "けいこ",
    "けいさつ",
    "げいじゅつ",
    "けいたい",
    "げいのうじん",
    "けいれき",
    "けいろ",
    "けおとす",
    "けおりもの",
    "げきか",
    "げきげん",
    "げきだん",
    "げきちん",
    "げきとつ",
    "げきは",
    "げきやく",
    "げこう",
    "げこくじょう",
    "げざい",
    "けさき",
    "げざん",
    "けしき",
    "けしごむ",
    "けしょう",
    "げすと",
    "けたば",
    "けちゃっぷ",
    "けちらす",
    "けつあつ",
    "けつい",
    "けつえき",
    "けっこん",
    "けつじょ",
    "けっせき",
    "けってい",
    "けつまつ",
    "げつようび",
    "げつれい",
    "けつろん",
    "げどく",
    "けとばす",
    "けとる",
    "けなげ",
    "けなす",
    "けなみ",
    "けぬき",
    "げねつ",
    "けねん",
    "けはい",
    "げひん",
    "けぶかい",
    "げぼく",
    "けまり",
    "けみかる",
    "けむし",
    "けむり",
    "けもの",
    "けらい",
    "けろけろ",
    "けわしい",
    "けんい",
    "けんえつ",
    "けんお",
    "けんか",
    "げんき",
    "けんげん",
    "けんこう",
    "けんさく",
    "けんしゅう",
    "けんすう",
    "げんそう",
    "けんちく",
    "けんてい",
    "けんとう",
    "けんない",
    "けんにん",
    "げんぶつ",
    "けんま",
    "けんみん",
    "けんめい",
    "けんらん",
    "けんり",
    "こあくま",
    "こいぬ",
    "こいびと",
    "ごうい",
    "こうえん",
    "こうおん",
    "こうかん",
    "ごうきゅう",
    "ごうけい",
    "こうこう",
    "こうさい",
    "こうじ",
    "こうすい",
    "ごうせい",
    "こうそく",
    "こうたい",
    "こうちゃ",
    "こうつう",
    "こうてい",
    "こうどう",
    "こうない",
    "こうはい",
    "ごうほう",
    "ごうまん",
    "こうもく",
    "こうりつ",
    "こえる",
    "こおり",
    "ごかい",
    "ごがつ",
    "ごかん",
    "こくご",
    "こくさい",
    "こくとう",
    "こくない",
    "こくはく",
    "こぐま",
    "こけい",
    "こける",
    "ここのか",
    "こころ",
    "こさめ",
    "こしつ",
    "こすう",
    "こせい",
    "こせき",
    "こぜん",
    "こそだて",
    "こたい",
    "こたえる",
    "こたつ",
    "こちょう",
    "こっか",
    "こつこつ",
    "こつばん",
    "こつぶ",
    "こてい",
    "こてん",
    "ことがら",
    "ことし",
    "ことば",
    "ことり",
    "こなごな",
    "こねこね",
    "このまま",
    "このみ",
    "このよ",
    "ごはん",
    "こひつじ",
    "こふう",
    "こふん",
    "こぼれる",
    "ごまあぶら",
    "こまかい",
    "ごますり",
    "こまつな",
    "こまる",
    "こむぎこ",
    "こもじ",
    "こもち",
    "こもの",
    "こもん",
    "こやく",
    "こやま",
    "こゆう",
    "こゆび",
    "こよい",
    "こよう",
    "こりる",
    "これくしょん",
    "ころっけ",
    "こわもて",
    "こわれる",
    "こんいん",
    "こんかい",
    "こんき",
    "こんしゅう",
    "こんすい",
    "こんだて",
    "こんとん",
    "こんなん",
    "こんびに",
    "こんぽん",
    "こんまけ",
    "こんや",
    "こんれい",
    "こんわく",
    "ざいえき",
    "さいかい",
    "さいきん",
    "ざいげん",
    "ざいこ",
    "さいしょ",
    "さいせい",
    "ざいたく",
    "ざいちゅう",
    "さいてき",
    "ざいりょう",
    "さうな",
    "さかいし",
    "さがす",
    "さかな",
    "さかみち",
    "さがる",
    "さぎょう",
    "さくし",
    "さくひん",
    "さくら",
    "さこく",
    "さこつ",
    "さずかる",
    "ざせき",
    "さたん",
    "さつえい",
    "ざつおん",
    "ざっか",
    "ざつがく",
    "さっきょく",
    "ざっし",
    "さつじん",
    "ざっそう",
    "さつたば",
    "さつまいも",
    "さてい",
    "さといも",
    "さとう",
    "さとおや",
    "さとし",
    "さとる",
    "さのう",
    "さばく",
    "さびしい",
    "さべつ",
    "さほう",
    "さほど",
    "さます",
    "さみしい",
    "さみだれ",
    "さむけ",
    "さめる",
    "さやえんどう",
    "さゆう",
    "さよう",
    "さよく",
    "さらだ",
    "ざるそば",
    "さわやか",
    "さわる",
    "さんいん",
    "さんか",
    "さんきゃく",
    "さんこう",
    "さんさい",
    "ざんしょ",
    "さんすう",
    "さんせい",
    "さんそ",
    "さんち",
    "さんま",
    "さんみ",
    "さんらん",
    "しあい",
    "しあげ",
    "しあさって",
    "しあわせ",
    "しいく",
    "しいん",
    "しうち",
    "しえい",
    "しおけ",
    "しかい",
    "しかく",
    "じかん",
    "しごと",
    "しすう",
    "じだい",
    "したうけ",
    "したぎ",
    "したて",
    "したみ",
    "しちょう",
    "しちりん",
    "しっかり",
    "しつじ",
    "しつもん",
    "してい",
    "してき",
    "してつ",
    "じてん",
    "じどう",
    "しなぎれ",
    "しなもの",
    "しなん",
    "しねま",
    "しねん",
    "しのぐ",
    "しのぶ",
    "しはい",
    "しばかり",
    "しはつ",
    "しはらい",
    "しはん",
    "しひょう",
    "しふく",
    "じぶん",
    "しへい",
    "しほう",
    "しほん",
    "しまう",
    "しまる",
    "しみん",
    "しむける",
    "じむしょ",
    "しめい",
    "しめる",
    "しもん",
    "しゃいん",
    "しゃうん",
    "しゃおん",
    "じゃがいも",
    "しやくしょ",
    "しゃくほう",
    "しゃけん",
    "しゃこ",
    "しゃざい",
    "しゃしん",
    "しゃせん",
    "しゃそう",
    "しゃたい",
    "しゃちょう",
    "しゃっきん",
    "じゃま",
    "しゃりん",
    "しゃれい",
    "じゆう",
    "じゅうしょ",
    "しゅくはく",
    "じゅしん",
    "しゅっせき",
    "しゅみ",
    "しゅらば",
    "じゅんばん",
    "しょうかい",
    "しょくたく",
    "しょっけん",
    "しょどう",
    "しょもつ",
    "しらせる",
    "しらべる",
    "しんか",
    "しんこう",
    "じんじゃ",
    "しんせいじ",
    "しんちく",
    "しんりん",
    "すあげ",
    "すあし",
    "すあな",
    "ずあん",
    "すいえい",
    "すいか",
    "すいとう",
    "ずいぶん",
    "すいようび",
    "すうがく",
    "すうじつ",
    "すうせん",
    "すおどり",
    "すきま",
    "すくう",
    "すくない",
    "すける",
    "すごい",
    "すこし",
    "ずさん",
    "すずしい",
    "すすむ",
    "すすめる",
    "すっかり",
    "ずっしり",
    "ずっと",
    "すてき",
    "すてる",
    "すねる",
    "すのこ",
    "すはだ",
    "すばらしい",
    "ずひょう",
    "ずぶぬれ",
    "すぶり",
    "すふれ",
    "すべて",
    "すべる",
    "ずほう",
    "すぼん",
    "すまい",
    "すめし",
    "すもう",
    "すやき",
    "すらすら",
    "するめ",
    "すれちがう",
    "すろっと",
    "すわる",
    "すんぜん",
    "すんぽう",
    "せあぶら",
    "せいかつ",
    "せいげん",
    "せいじ",
    "せいよう",
    "せおう",
    "せかいかん",
    "せきにん",
    "せきむ",
    "せきゆ",
    "せきらんうん",
    "せけん",
    "せこう",
    "せすじ",
    "せたい",
    "せたけ",
    "せっかく",
    "せっきゃく",
    "ぜっく",
    "せっけん",
    "せっこつ",
    "せっさたくま",
    "せつぞく",
    "せつだん",
    "せつでん",
    "せっぱん",
    "せつび",
    "せつぶん",
    "せつめい",
    "せつりつ",
    "せなか",
    "せのび",
    "せはば",
    "せびろ",
    "せぼね",
    "せまい",
    "せまる",
    "せめる",
    "せもたれ",
    "せりふ",
    "ぜんあく",
    "せんい",
    "せんえい",
    "せんか",
    "せんきょ",
    "せんく",
    "せんげん",
    "ぜんご",
    "せんさい",
    "せんしゅ",
    "せんすい",
    "せんせい",
    "せんぞ",
    "せんたく",
    "せんちょう",
    "せんてい",
    "せんとう",
    "せんぬき",
    "せんねん",
    "せんぱい",
    "ぜんぶ",
    "ぜんぽう",
    "せんむ",
    "せんめんじょ",
    "せんもん",
    "せんやく",
    "せんゆう",
    "せんよう",
    "ぜんら",
    "ぜんりゃく",
    "せんれい",
    "せんろ",
    "そあく",
    "そいとげる",
    "そいね",
    "そうがんきょう",
    "そうき",
    "そうご",
    "そうしん",
    "そうだん",
    "そうなん",
    "そうび",
    "そうめん",
    "そうり",
    "そえもの",
    "そえん",
    "そがい",
    "そげき",
    "そこう",
    "そこそこ",
    "そざい",
    "そしな",
    "そせい",
    "そせん",
    "そそぐ",
    "そだてる",
    "そつう",
    "そつえん",
    "そっかん",
    "そつぎょう",
    "そっけつ",
    "そっこう",
    "そっせん",
    "そっと",
    "そとがわ",
    "そとづら",
    "そなえる",
    "そなた",
    "そふぼ",
    "そぼく",
    "そぼろ",
    "そまつ",
    "そまる",
    "そむく",
    "そむりえ",
    "そめる",
    "そもそも",
    "そよかぜ",
    "そらまめ",
    "そろう",
    "そんかい",
    "そんけい",
    "そんざい",
    "そんしつ",
    "そんぞく",
    "そんちょう",
    "ぞんび",
    "ぞんぶん",
    "そんみん",
    "たあい",
    "たいいん",
    "たいうん",
    "たいえき",
    "たいおう",
    "だいがく",
    "たいき",
    "たいぐう",
    "たいけん",
    "たいこ",
    "たいざい",
    "だいじょうぶ",
    "だいすき",
    "たいせつ",
    "たいそう",
    "だいたい",
    "たいちょう",
    "たいてい",
    "だいどころ",
    "たいない",
    "たいねつ",
    "たいのう",
    "たいはん",
    "だいひょう",
    "たいふう",
    "たいへん",
    "たいほ",
    "たいまつばな",
    "たいみんぐ",
    "たいむ",
    "たいめん",
    "たいやき",
    "たいよう",
    "たいら",
    "たいりょく",
    "たいる",
    "たいわん",
    "たうえ",
    "たえる",
    "たおす",
    "たおる",
    "たおれる",
    "たかい",
    "たかね",
    "たきび",
    "たくさん",
    "たこく",
    "たこやき",
    "たさい",
    "たしざん",
    "だじゃれ",
    "たすける",
    "たずさわる",
    "たそがれ",
    "たたかう",
    "たたく",
    "ただしい",
    "たたみ",
    "たちばな",
    "だっかい",
    "だっきゃく",
    "だっこ",
    "だっしゅつ",
    "だったい",
    "たてる",
    "たとえる",
    "たなばた",
    "たにん",
    "たぬき",
    "たのしみ",
    "たはつ",
    "たぶん",
    "たべる",
    "たぼう",
    "たまご",
    "たまる",
    "だむる",
    "ためいき",
    "ためす",
    "ためる",
    "たもつ",
    "たやすい",
    "たよる",
    "たらす",
    "たりきほんがん",
    "たりょう",
    "たりる",
    "たると",
    "たれる",
    "たれんと",
    "たろっと",
    "たわむれる",
    "だんあつ",
    "たんい",
    "たんおん",
    "たんか",
    "たんき",
    "たんけん",
    "たんご",
    "たんさん",
    "たんじょうび",
    "だんせい",
    "たんそく",
    "たんたい",
    "だんち",
    "たんてい",
    "たんとう",
    "だんな",
    "たんにん",
    "だんねつ",
    "たんのう",
    "たんぴん",
    "だんぼう",
    "たんまつ",
    "たんめい",
    "だんれつ",
    "だんろ",
    "だんわ",
    "ちあい",
    "ちあん",
    "ちいき",
    "ちいさい",
    "ちえん",
    "ちかい",
    "ちから",
    "ちきゅう",
    "ちきん",
    "ちけいず",
    "ちけん",
    "ちこく",
    "ちさい",
    "ちしき",
    "ちしりょう",
    "ちせい",
    "ちそう",
    "ちたい",
    "ちたん",
    "ちちおや",
    "ちつじょ",
    "ちてき",
    "ちてん",
    "ちぬき",
    "ちぬり",
    "ちのう",
    "ちひょう",
    "ちへいせん",
    "ちほう",
    "ちまた",
    "ちみつ",
    "ちみどろ",
    "ちめいど",
    "ちゃんこなべ",
    "ちゅうい",
    "ちゆりょく",
    "ちょうし",
    "ちょさくけん",
    "ちらし",
    "ちらみ",
    "ちりがみ",
    "ちりょう",
    "ちるど",
    "ちわわ",
    "ちんたい",
    "ちんもく",
    "ついか",
    "ついたち",
    "つうか",
    "つうじょう",
    "つうはん",
    "つうわ",
    "つかう",
    "つかれる",
    "つくね",
    "つくる",
    "つけね",
    "つける",
    "つごう",
    "つたえる",
    "つづく",
    "つつじ",
    "つつむ",
    "つとめる",
    "つながる",
    "つなみ",
    "つねづね",
    "つのる",
    "つぶす",
    "つまらない",
    "つまる",
    "つみき",
    "つめたい",
    "つもり",
    "つもる",
    "つよい",
    "つるぼ",
    "つるみく",
    "つわもの",
    "つわり",
    "てあし",
    "てあて",
    "てあみ",
    "ていおん",
    "ていか",
    "ていき",
    "ていけい",
    "ていこく",
    "ていさつ",
    "ていし",
    "ていせい",
    "ていたい",
    "ていど",
    "ていねい",
    "ていひょう",
    "ていへん",
    "ていぼう",
    "てうち",
    "ておくれ",
    "てきとう",
    "てくび",
    "でこぼこ",
    "てさぎょう",
    "てさげ",
    "てすり",
    "てそう",
    "てちがい",
    "てちょう",
    "てつがく",
    "てつづき",
    "でっぱ",
    "てつぼう",
    "てつや",
    "でぬかえ",
    "てぬき",
    "てぬぐい",
    "てのひら",
    "てはい",
    "てぶくろ",
    "てふだ",
    "てほどき",
    "てほん",
    "てまえ",
    "てまきずし",
    "てみじか",
    "てみやげ",
    "てらす",
    "てれび",
    "てわけ",
    "てわたし",
    "でんあつ",
    "てんいん",
    "てんかい",
    "てんき",
    "てんぐ",
    "てんけん",
    "てんごく",
    "てんさい",
    "てんし",
    "てんすう",
    "でんち",
    "てんてき",
    "てんとう",
    "てんない",
    "てんぷら",
    "てんぼうだい",
    "てんめつ",
    "てんらんかい",
    "でんりょく",
    "でんわ",
    "どあい",
    "といれ",
    "どうかん",
    "とうきゅう",
    "どうぐ",
    "とうし",
    "とうむぎ",
    "とおい",
    "とおか",
    "とおく",
    "とおす",
    "とおる",
    "とかい",
    "とかす",
    "ときおり",
    "ときどき",
    "とくい",
    "とくしゅう",
    "とくてん",
    "とくに",
    "とくべつ",
    "とけい",
    "とける",
    "とこや",
    "とさか",
    "としょかん",
    "とそう",
    "とたん",
    "とちゅう",
    "とっきゅう",
    "とっくん",
    "とつぜん",
    "とつにゅう",
    "とどける",
    "ととのえる",
    "とない",
    "となえる",
    "となり",
    "とのさま",
    "とばす",
    "どぶがわ",
    "とほう",
    "とまる",
    "とめる",
    "ともだち",
    "ともる",
    "どようび",
    "とらえる",
    "とんかつ",
    "どんぶり",
    "ないかく",
    "ないこう",
    "ないしょ",
    "ないす",
    "ないせん",
    "ないそう",
    "なおす",
    "ながい",
    "なくす",
    "なげる",
    "なこうど",
    "なさけ",
    "なたでここ",
    "なっとう",
    "なつやすみ",
    "ななおし",
    "なにごと",
    "なにもの",
    "なにわ",
    "なのか",
    "なふだ",
    "なまいき",
    "なまえ",
    "なまみ",
    "なみだ",
    "なめらか",
    "なめる",
    "なやむ",
    "ならう",
    "ならび",
    "ならぶ",
    "なれる",
    "なわとび",
    "なわばり",
    "にあう",
    "にいがた",
    "にうけ",
    "におい",
    "にかい",
    "にがて",
    "にきび",
    "にくしみ",
    "にくまん",
    "にげる",
    "にさんかたんそ",
    "にしき",
    "にせもの",
    "にちじょう",
    "にちようび",
    "にっか",
    "にっき",
    "にっけい",
    "にっこう",
    "にっさん",
    "にっしょく",
    "にっすう",
    "にっせき",
    "にってい",
    "になう",
    "にほん",
    "にまめ",
    "にもつ",
    "にやり",
    "にゅういん",
    "にりんしゃ",
    "にわとり",
    "にんい",
    "にんか",
    "にんき",
    "にんげん",
    "にんしき",
    "にんずう",
    "にんそう",
    "にんたい",
    "にんち",
    "にんてい",
    "にんにく",
    "にんぷ",
    "にんまり",
    "にんむ",
    "にんめい",
    "にんよう",
    "ぬいくぎ",
    "ぬかす",
    "ぬぐいとる",
    "ぬぐう",
    "ぬくもり",
    "ぬすむ",
    "ぬまえび",
    "ぬめり",
    "ぬらす",
    "ぬんちゃく",
    "ねあげ",
    "ねいき",
    "ねいる",
    "ねいろ",
    "ねぐせ",
    "ねくたい",
    "ねくら",
    "ねこぜ",
    "ねこむ",
    "ねさげ",
    "ねすごす",
    "ねそべる",
    "ねだん",
    "ねつい",
    "ねっしん",
    "ねつぞう",
    "ねったいぎょ",
    "ねぶそく",
    "ねふだ",
    "ねぼう",
    "ねほりはほり",
    "ねまき",
    "ねまわし",
    "ねみみ",
    "ねむい",
    "ねむたい",
    "ねもと",
    "ねらう",
    "ねわざ",
    "ねんいり",
    "ねんおし",
    "ねんかん",
    "ねんきん",
    "ねんぐ",
    "ねんざ",
    "ねんし",
    "ねんちゃく",
    "ねんど",
    "ねんぴ",
    "ねんぶつ",
    "ねんまつ",
    "ねんりょう",
    "ねんれい",
    "のいず",
    "のおづま",
    "のがす",
    "のきなみ",
    "のこぎり",
    "のこす",
    "のこる",
    "のせる",
    "のぞく",
    "のぞむ",
    "のたまう",
    "のちほど",
    "のっく",
    "のばす",
    "のはら",
    "のべる",
    "のぼる",
    "のみもの",
    "のやま",
    "のらいぬ",
    "のらねこ",
    "のりもの",
    "のりゆき",
    "のれん",
    "のんき",
    "ばあい",
    "はあく",
    "ばあさん",
    "ばいか",
    "ばいく",
    "はいけん",
    "はいご",
    "はいしん",
    "はいすい",
    "はいせん",
    "はいそう",
    "はいち",
    "ばいばい",
    "はいれつ",
    "はえる",
    "はおる",
    "はかい",
    "ばかり",
    "はかる",
    "はくしゅ",
    "はけん",
    "はこぶ",
    "はさみ",
    "はさん",
    "はしご",
    "ばしょ",
    "はしる",
    "はせる",
    "ぱそこん",
    "はそん",
    "はたん",
    "はちみつ",
    "はつおん",
    "はっかく",
    "はづき",
    "はっきり",
    "はっくつ",
    "はっけん",
    "はっこう",
    "はっさん",
    "はっしん",
    "はったつ",
    "はっちゅう",
    "はってん",
    "はっぴょう",
    "はっぽう",
    "はなす",
    "はなび",
    "はにかむ",
    "はぶらし",
    "はみがき",
    "はむかう",
    "はめつ",
    "はやい",
    "はやし",
    "はらう",
    "はろうぃん",
    "はわい",
    "はんい",
    "はんえい",
    "はんおん",
    "はんかく",
    "はんきょう",
    "ばんぐみ",
    "はんこ",
    "はんしゃ",
    "はんすう",
    "はんだん",
    "ぱんち",
    "ぱんつ",
    "はんてい",
    "はんとし",
    "はんのう",
    "はんぱ",
    "はんぶん",
    "はんぺん",
    "はんぼうき",
    "はんめい",
    "はんらん",
    "はんろん",
    "ひいき",
    "ひうん",
    "ひえる",
    "ひかく",
    "ひかり",
    "ひかる",
    "ひかん",
    "ひくい",
    "ひけつ",
    "ひこうき",
    "ひこく",
    "ひさい",
    "ひさしぶり",
    "ひさん",
    "びじゅつかん",
    "ひしょ",
    "ひそか",
    "ひそむ",
    "ひたむき",
    "ひだり",
    "ひたる",
    "ひつぎ",
    "ひっこし",
    "ひっし",
    "ひつじゅひん",
    "ひっす",
    "ひつぜん",
    "ぴったり",
    "ぴっちり",
    "ひつよう",
    "ひてい",
    "ひとごみ",
    "ひなまつり",
    "ひなん",
    "ひねる",
    "ひはん",
    "ひびく",
    "ひひょう",
    "ひほう",
    "ひまわり",
    "ひまん",
    "ひみつ",
    "ひめい",
    "ひめじし",
    "ひやけ",
    "ひやす",
    "ひよう",
    "びょうき",
    "ひらがな",
    "ひらく",
    "ひりつ",
    "ひりょう",
    "ひるま",
    "ひるやすみ",
    "ひれい",
    "ひろい",
    "ひろう",
    "ひろき",
    "ひろゆき",
    "ひんかく",
    "ひんけつ",
    "ひんこん",
    "ひんしゅ",
    "ひんそう",
    "ぴんち",
    "ひんぱん",
    "びんぼう",
    "ふあん",
    "ふいうち",
    "ふうけい",
    "ふうせん",
    "ぷうたろう",
    "ふうとう",
    "ふうふ",
    "ふえる",
    "ふおん",
    "ふかい",
    "ふきん",
    "ふくざつ",
    "ふくぶくろ",
    "ふこう",
    "ふさい",
    "ふしぎ",
    "ふじみ",
    "ふすま",
    "ふせい",
    "ふせぐ",
    "ふそく",
    "ぶたにく",
    "ふたん",
    "ふちょう",
    "ふつう",
    "ふつか",
    "ふっかつ",
    "ふっき",
    "ふっこく",
    "ぶどう",
    "ふとる",
    "ふとん",
    "ふのう",
    "ふはい",
    "ふひょう",
    "ふへん",
    "ふまん",
    "ふみん",
    "ふめつ",
    "ふめん",
    "ふよう",
    "ふりこ",
    "ふりる",
    "ふるい",
    "ふんいき",
    "ぶんがく",
    "ぶんぐ",
    "ふんしつ",
    "ぶんせき",
    "ふんそう",
    "ぶんぽう",
    "へいあん",
    "へいおん",
    "へいがい",
    "へいき",
    "へいげん",
    "へいこう",
    "へいさ",
    "へいしゃ",
    "へいせつ",
    "へいそ",
    "へいたく",
    "へいてん",
    "へいねつ",
    "へいわ",
    "へきが",
    "へこむ",
    "べにいろ",
    "べにしょうが",
    "へらす",
    "へんかん",
    "べんきょう",
    "べんごし",
    "へんさい",
    "へんたい",
    "べんり",
    "ほあん",
    "ほいく",
    "ぼうぎょ",
    "ほうこく",
    "ほうそう",
    "ほうほう",
    "ほうもん",
    "ほうりつ",
    "ほえる",
    "ほおん",
    "ほかん",
    "ほきょう",
    "ぼきん",
    "ほくろ",
    "ほけつ",
    "ほけん",
    "ほこう",
    "ほこる",
    "ほしい",
    "ほしつ",
    "ほしゅ",
    "ほしょう",
    "ほせい",
    "ほそい",
    "ほそく",
    "ほたて",
    "ほたる",
    "ぽちぶくろ",
    "ほっきょく",
    "ほっさ",
    "ほったん",
    "ほとんど",
    "ほめる",
    "ほんい",
    "ほんき",
    "ほんけ",
    "ほんしつ",
    "ほんやく",
    "まいにち",
    "まかい",
    "まかせる",
    "まがる",
    "まける",
    "まこと",
    "まさつ",
    "まじめ",
    "ますく",
    "まぜる",
    "まつり",
    "まとめ",
    "まなぶ",
    "まぬけ",
    "まねく",
    "まほう",
    "まもる",
    "まゆげ",
    "まよう",
    "まろやか",
    "まわす",
    "まわり",
    "まわる",
    "まんが",
    "まんきつ",
    "まんぞく",
    "まんなか",
    "みいら",
    "みうち",
    "みえる",
    "みがく",
    "みかた",
    "みかん",
    "みけん",
    "みこん",
    "みじかい",
    "みすい",
    "みすえる",
    "みせる",
    "みっか",
    "みつかる",
    "みつける",
    "みてい",
    "みとめる",
    "みなと",
    "みなみかさい",
    "みねらる",
    "みのう",
    "みのがす",
    "みほん",
    "みもと",
    "みやげ",
    "みらい",
    "みりょく",
    "みわく",
    "みんか",
    "みんぞく",
    "むいか",
    "むえき",
    "むえん",
    "むかい",
    "むかう",
    "むかえ",
    "むかし",
    "むぎちゃ",
    "むける",
    "むげん",
    "むさぼる",
    "むしあつい",
    "むしば",
    "むじゅん",
    "むしろ",
    "むすう",
    "むすこ",
    "むすぶ",
    "むすめ",
    "むせる",
    "むせん",
    "むちゅう",
    "むなしい",
    "むのう",
    "むやみ",
    "むよう",
    "むらさき",
    "むりょう",
    "むろん",
    "めいあん",
    "めいうん",
    "めいえん",
    "めいかく",
    "めいきょく",
    "めいさい",
    "めいし",
    "めいそう",
    "めいぶつ",
    "めいれい",
    "めいわく",
    "めぐまれる",
    "めざす",
    "めした",
    "めずらしい",
    "めだつ",
    "めまい",
    "めやす",
    "めんきょ",
    "めんせき",
    "めんどう",
    "もうしあげる",
    "もうどうけん",
    "もえる",
    "もくし",
    "もくてき",
    "もくようび",
    "もちろん",
    "もどる",
    "もらう",
    "もんく",
    "もんだい",
    "やおや",
    "やける",
    "やさい",
    "やさしい",
    "やすい",
    "やすたろう",
    "やすみ",
    "やせる",
    "やそう",
    "やたい",
    "やちん",
    "やっと",
    "やっぱり",
    "やぶる",
    "やめる",
    "ややこしい",
    "やよい",
    "やわらかい",
    "ゆうき",
    "ゆうびんきょく",
    "ゆうべ",
    "ゆうめい",
    "ゆけつ",
    "ゆしゅつ",
    "ゆせん",
    "ゆそう",
    "ゆたか",
    "ゆちゃく",
    "ゆでる",
    "ゆにゅう",
    "ゆびわ",
    "ゆらい",
    "ゆれる",
    "ようい",
    "ようか",
    "ようきゅう",
    "ようじ",
    "ようす",
    "ようちえん",
    "よかぜ",
    "よかん",
    "よきん",
    "よくせい",
    "よくぼう",
    "よけい",
    "よごれる",
    "よさん",
    "よしゅう",
    "よそう",
    "よそく",
    "よっか",
    "よてい",
    "よどがわく",
    "よねつ",
    "よやく",
    "よゆう",
    "よろこぶ",
    "よろしい",
    "らいう",
    "らくがき",
    "らくご",
    "らくさつ",
    "らくだ",
    "らしんばん",
    "らせん",
    "らぞく",
    "らたい",
    "らっか",
    "られつ",
    "りえき",
    "りかい",
    "りきさく",
    "りきせつ",
    "りくぐん",
    "りくつ",
    "りけん",
    "りこう",
    "りせい",
    "りそう",
    "りそく",
    "りてん",
    "りねん",
    "りゆう",
    "りゅうがく",
    "りよう",
    "りょうり",
    "りょかん",
    "りょくちゃ",
    "りょこう",
    "りりく",
    "りれき",
    "りろん",
    "りんご",
    "るいけい",
    "るいさい",
    "るいじ",
    "るいせき",
    "るすばん",
    "るりがわら",
    "れいかん",
    "れいぎ",
    "れいせい",
    "れいぞうこ",
    "れいとう",
    "れいぼう",
    "れきし",
    "れきだい",
    "れんあい",
    "れんけい",
    "れんこん",
    "れんさい",
    "れんしゅう",
    "れんぞく",
    "れんらく",
    "ろうか",
    "ろうご",
    "ろうじん",
    "ろうそく",
    "ろくが",
    "ろこつ",
    "ろじうら",
    "ろしゅつ",
    "ろせん",
    "ろてん",
    "ろめん",
    "ろれつ",
    "ろんぎ",
    "ろんぱ",
    "ろんぶん",
    "ろんり",
    "わかす",
    "わかめ",
    "わかやま",
    "わかれる",
    "わしつ",
    "わじまし",
    "わすれもの",
    "わらう",
    "われる"
  ]), Wu;
}
var Zu, K3;
function ly() {
  return K3 || (K3 = 1, Zu = [
    "ábaco",
    "abdomen",
    "abeja",
    "abierto",
    "abogado",
    "abono",
    "aborto",
    "abrazo",
    "abrir",
    "abuelo",
    "abuso",
    "acabar",
    "academia",
    "acceso",
    "acción",
    "aceite",
    "acelga",
    "acento",
    "aceptar",
    "ácido",
    "aclarar",
    "acné",
    "acoger",
    "acoso",
    "activo",
    "acto",
    "actriz",
    "actuar",
    "acudir",
    "acuerdo",
    "acusar",
    "adicto",
    "admitir",
    "adoptar",
    "adorno",
    "aduana",
    "adulto",
    "aéreo",
    "afectar",
    "afición",
    "afinar",
    "afirmar",
    "ágil",
    "agitar",
    "agonía",
    "agosto",
    "agotar",
    "agregar",
    "agrio",
    "agua",
    "agudo",
    "águila",
    "aguja",
    "ahogo",
    "ahorro",
    "aire",
    "aislar",
    "ajedrez",
    "ajeno",
    "ajuste",
    "alacrán",
    "alambre",
    "alarma",
    "alba",
    "álbum",
    "alcalde",
    "aldea",
    "alegre",
    "alejar",
    "alerta",
    "aleta",
    "alfiler",
    "alga",
    "algodón",
    "aliado",
    "aliento",
    "alivio",
    "alma",
    "almeja",
    "almíbar",
    "altar",
    "alteza",
    "altivo",
    "alto",
    "altura",
    "alumno",
    "alzar",
    "amable",
    "amante",
    "amapola",
    "amargo",
    "amasar",
    "ámbar",
    "ámbito",
    "ameno",
    "amigo",
    "amistad",
    "amor",
    "amparo",
    "amplio",
    "ancho",
    "anciano",
    "ancla",
    "andar",
    "andén",
    "anemia",
    "ángulo",
    "anillo",
    "ánimo",
    "anís",
    "anotar",
    "antena",
    "antiguo",
    "antojo",
    "anual",
    "anular",
    "anuncio",
    "añadir",
    "añejo",
    "año",
    "apagar",
    "aparato",
    "apetito",
    "apio",
    "aplicar",
    "apodo",
    "aporte",
    "apoyo",
    "aprender",
    "aprobar",
    "apuesta",
    "apuro",
    "arado",
    "araña",
    "arar",
    "árbitro",
    "árbol",
    "arbusto",
    "archivo",
    "arco",
    "arder",
    "ardilla",
    "arduo",
    "área",
    "árido",
    "aries",
    "armonía",
    "arnés",
    "aroma",
    "arpa",
    "arpón",
    "arreglo",
    "arroz",
    "arruga",
    "arte",
    "artista",
    "asa",
    "asado",
    "asalto",
    "ascenso",
    "asegurar",
    "aseo",
    "asesor",
    "asiento",
    "asilo",
    "asistir",
    "asno",
    "asombro",
    "áspero",
    "astilla",
    "astro",
    "astuto",
    "asumir",
    "asunto",
    "atajo",
    "ataque",
    "atar",
    "atento",
    "ateo",
    "ático",
    "atleta",
    "átomo",
    "atraer",
    "atroz",
    "atún",
    "audaz",
    "audio",
    "auge",
    "aula",
    "aumento",
    "ausente",
    "autor",
    "aval",
    "avance",
    "avaro",
    "ave",
    "avellana",
    "avena",
    "avestruz",
    "avión",
    "aviso",
    "ayer",
    "ayuda",
    "ayuno",
    "azafrán",
    "azar",
    "azote",
    "azúcar",
    "azufre",
    "azul",
    "baba",
    "babor",
    "bache",
    "bahía",
    "baile",
    "bajar",
    "balanza",
    "balcón",
    "balde",
    "bambú",
    "banco",
    "banda",
    "baño",
    "barba",
    "barco",
    "barniz",
    "barro",
    "báscula",
    "bastón",
    "basura",
    "batalla",
    "batería",
    "batir",
    "batuta",
    "baúl",
    "bazar",
    "bebé",
    "bebida",
    "bello",
    "besar",
    "beso",
    "bestia",
    "bicho",
    "bien",
    "bingo",
    "blanco",
    "bloque",
    "blusa",
    "boa",
    "bobina",
    "bobo",
    "boca",
    "bocina",
    "boda",
    "bodega",
    "boina",
    "bola",
    "bolero",
    "bolsa",
    "bomba",
    "bondad",
    "bonito",
    "bono",
    "bonsái",
    "borde",
    "borrar",
    "bosque",
    "bote",
    "botín",
    "bóveda",
    "bozal",
    "bravo",
    "brazo",
    "brecha",
    "breve",
    "brillo",
    "brinco",
    "brisa",
    "broca",
    "broma",
    "bronce",
    "brote",
    "bruja",
    "brusco",
    "bruto",
    "buceo",
    "bucle",
    "bueno",
    "buey",
    "bufanda",
    "bufón",
    "búho",
    "buitre",
    "bulto",
    "burbuja",
    "burla",
    "burro",
    "buscar",
    "butaca",
    "buzón",
    "caballo",
    "cabeza",
    "cabina",
    "cabra",
    "cacao",
    "cadáver",
    "cadena",
    "caer",
    "café",
    "caída",
    "caimán",
    "caja",
    "cajón",
    "cal",
    "calamar",
    "calcio",
    "caldo",
    "calidad",
    "calle",
    "calma",
    "calor",
    "calvo",
    "cama",
    "cambio",
    "camello",
    "camino",
    "campo",
    "cáncer",
    "candil",
    "canela",
    "canguro",
    "canica",
    "canto",
    "caña",
    "cañón",
    "caoba",
    "caos",
    "capaz",
    "capitán",
    "capote",
    "captar",
    "capucha",
    "cara",
    "carbón",
    "cárcel",
    "careta",
    "carga",
    "cariño",
    "carne",
    "carpeta",
    "carro",
    "carta",
    "casa",
    "casco",
    "casero",
    "caspa",
    "castor",
    "catorce",
    "catre",
    "caudal",
    "causa",
    "cazo",
    "cebolla",
    "ceder",
    "cedro",
    "celda",
    "célebre",
    "celoso",
    "célula",
    "cemento",
    "ceniza",
    "centro",
    "cerca",
    "cerdo",
    "cereza",
    "cero",
    "cerrar",
    "certeza",
    "césped",
    "cetro",
    "chacal",
    "chaleco",
    "champú",
    "chancla",
    "chapa",
    "charla",
    "chico",
    "chiste",
    "chivo",
    "choque",
    "choza",
    "chuleta",
    "chupar",
    "ciclón",
    "ciego",
    "cielo",
    "cien",
    "cierto",
    "cifra",
    "cigarro",
    "cima",
    "cinco",
    "cine",
    "cinta",
    "ciprés",
    "circo",
    "ciruela",
    "cisne",
    "cita",
    "ciudad",
    "clamor",
    "clan",
    "claro",
    "clase",
    "clave",
    "cliente",
    "clima",
    "clínica",
    "cobre",
    "cocción",
    "cochino",
    "cocina",
    "coco",
    "código",
    "codo",
    "cofre",
    "coger",
    "cohete",
    "cojín",
    "cojo",
    "cola",
    "colcha",
    "colegio",
    "colgar",
    "colina",
    "collar",
    "colmo",
    "columna",
    "combate",
    "comer",
    "comida",
    "cómodo",
    "compra",
    "conde",
    "conejo",
    "conga",
    "conocer",
    "consejo",
    "contar",
    "copa",
    "copia",
    "corazón",
    "corbata",
    "corcho",
    "cordón",
    "corona",
    "correr",
    "coser",
    "cosmos",
    "costa",
    "cráneo",
    "cráter",
    "crear",
    "crecer",
    "creído",
    "crema",
    "cría",
    "crimen",
    "cripta",
    "crisis",
    "cromo",
    "crónica",
    "croqueta",
    "crudo",
    "cruz",
    "cuadro",
    "cuarto",
    "cuatro",
    "cubo",
    "cubrir",
    "cuchara",
    "cuello",
    "cuento",
    "cuerda",
    "cuesta",
    "cueva",
    "cuidar",
    "culebra",
    "culpa",
    "culto",
    "cumbre",
    "cumplir",
    "cuna",
    "cuneta",
    "cuota",
    "cupón",
    "cúpula",
    "curar",
    "curioso",
    "curso",
    "curva",
    "cutis",
    "dama",
    "danza",
    "dar",
    "dardo",
    "dátil",
    "deber",
    "débil",
    "década",
    "decir",
    "dedo",
    "defensa",
    "definir",
    "dejar",
    "delfín",
    "delgado",
    "delito",
    "demora",
    "denso",
    "dental",
    "deporte",
    "derecho",
    "derrota",
    "desayuno",
    "deseo",
    "desfile",
    "desnudo",
    "destino",
    "desvío",
    "detalle",
    "detener",
    "deuda",
    "día",
    "diablo",
    "diadema",
    "diamante",
    "diana",
    "diario",
    "dibujo",
    "dictar",
    "diente",
    "dieta",
    "diez",
    "difícil",
    "digno",
    "dilema",
    "diluir",
    "dinero",
    "directo",
    "dirigir",
    "disco",
    "diseño",
    "disfraz",
    "diva",
    "divino",
    "doble",
    "doce",
    "dolor",
    "domingo",
    "don",
    "donar",
    "dorado",
    "dormir",
    "dorso",
    "dos",
    "dosis",
    "dragón",
    "droga",
    "ducha",
    "duda",
    "duelo",
    "dueño",
    "dulce",
    "dúo",
    "duque",
    "durar",
    "dureza",
    "duro",
    "ébano",
    "ebrio",
    "echar",
    "eco",
    "ecuador",
    "edad",
    "edición",
    "edificio",
    "editor",
    "educar",
    "efecto",
    "eficaz",
    "eje",
    "ejemplo",
    "elefante",
    "elegir",
    "elemento",
    "elevar",
    "elipse",
    "élite",
    "elixir",
    "elogio",
    "eludir",
    "embudo",
    "emitir",
    "emoción",
    "empate",
    "empeño",
    "empleo",
    "empresa",
    "enano",
    "encargo",
    "enchufe",
    "encía",
    "enemigo",
    "enero",
    "enfado",
    "enfermo",
    "engaño",
    "enigma",
    "enlace",
    "enorme",
    "enredo",
    "ensayo",
    "enseñar",
    "entero",
    "entrar",
    "envase",
    "envío",
    "época",
    "equipo",
    "erizo",
    "escala",
    "escena",
    "escolar",
    "escribir",
    "escudo",
    "esencia",
    "esfera",
    "esfuerzo",
    "espada",
    "espejo",
    "espía",
    "esposa",
    "espuma",
    "esquí",
    "estar",
    "este",
    "estilo",
    "estufa",
    "etapa",
    "eterno",
    "ética",
    "etnia",
    "evadir",
    "evaluar",
    "evento",
    "evitar",
    "exacto",
    "examen",
    "exceso",
    "excusa",
    "exento",
    "exigir",
    "exilio",
    "existir",
    "éxito",
    "experto",
    "explicar",
    "exponer",
    "extremo",
    "fábrica",
    "fábula",
    "fachada",
    "fácil",
    "factor",
    "faena",
    "faja",
    "falda",
    "fallo",
    "falso",
    "faltar",
    "fama",
    "familia",
    "famoso",
    "faraón",
    "farmacia",
    "farol",
    "farsa",
    "fase",
    "fatiga",
    "fauna",
    "favor",
    "fax",
    "febrero",
    "fecha",
    "feliz",
    "feo",
    "feria",
    "feroz",
    "fértil",
    "fervor",
    "festín",
    "fiable",
    "fianza",
    "fiar",
    "fibra",
    "ficción",
    "ficha",
    "fideo",
    "fiebre",
    "fiel",
    "fiera",
    "fiesta",
    "figura",
    "fijar",
    "fijo",
    "fila",
    "filete",
    "filial",
    "filtro",
    "fin",
    "finca",
    "fingir",
    "finito",
    "firma",
    "flaco",
    "flauta",
    "flecha",
    "flor",
    "flota",
    "fluir",
    "flujo",
    "flúor",
    "fobia",
    "foca",
    "fogata",
    "fogón",
    "folio",
    "folleto",
    "fondo",
    "forma",
    "forro",
    "fortuna",
    "forzar",
    "fosa",
    "foto",
    "fracaso",
    "frágil",
    "franja",
    "frase",
    "fraude",
    "freír",
    "freno",
    "fresa",
    "frío",
    "frito",
    "fruta",
    "fuego",
    "fuente",
    "fuerza",
    "fuga",
    "fumar",
    "función",
    "funda",
    "furgón",
    "furia",
    "fusil",
    "fútbol",
    "futuro",
    "gacela",
    "gafas",
    "gaita",
    "gajo",
    "gala",
    "galería",
    "gallo",
    "gamba",
    "ganar",
    "gancho",
    "ganga",
    "ganso",
    "garaje",
    "garza",
    "gasolina",
    "gastar",
    "gato",
    "gavilán",
    "gemelo",
    "gemir",
    "gen",
    "género",
    "genio",
    "gente",
    "geranio",
    "gerente",
    "germen",
    "gesto",
    "gigante",
    "gimnasio",
    "girar",
    "giro",
    "glaciar",
    "globo",
    "gloria",
    "gol",
    "golfo",
    "goloso",
    "golpe",
    "goma",
    "gordo",
    "gorila",
    "gorra",
    "gota",
    "goteo",
    "gozar",
    "grada",
    "gráfico",
    "grano",
    "grasa",
    "gratis",
    "grave",
    "grieta",
    "grillo",
    "gripe",
    "gris",
    "grito",
    "grosor",
    "grúa",
    "grueso",
    "grumo",
    "grupo",
    "guante",
    "guapo",
    "guardia",
    "guerra",
    "guía",
    "guiño",
    "guion",
    "guiso",
    "guitarra",
    "gusano",
    "gustar",
    "haber",
    "hábil",
    "hablar",
    "hacer",
    "hacha",
    "hada",
    "hallar",
    "hamaca",
    "harina",
    "haz",
    "hazaña",
    "hebilla",
    "hebra",
    "hecho",
    "helado",
    "helio",
    "hembra",
    "herir",
    "hermano",
    "héroe",
    "hervir",
    "hielo",
    "hierro",
    "hígado",
    "higiene",
    "hijo",
    "himno",
    "historia",
    "hocico",
    "hogar",
    "hoguera",
    "hoja",
    "hombre",
    "hongo",
    "honor",
    "honra",
    "hora",
    "hormiga",
    "horno",
    "hostil",
    "hoyo",
    "hueco",
    "huelga",
    "huerta",
    "hueso",
    "huevo",
    "huida",
    "huir",
    "humano",
    "húmedo",
    "humilde",
    "humo",
    "hundir",
    "huracán",
    "hurto",
    "icono",
    "ideal",
    "idioma",
    "ídolo",
    "iglesia",
    "iglú",
    "igual",
    "ilegal",
    "ilusión",
    "imagen",
    "imán",
    "imitar",
    "impar",
    "imperio",
    "imponer",
    "impulso",
    "incapaz",
    "índice",
    "inerte",
    "infiel",
    "informe",
    "ingenio",
    "inicio",
    "inmenso",
    "inmune",
    "innato",
    "insecto",
    "instante",
    "interés",
    "íntimo",
    "intuir",
    "inútil",
    "invierno",
    "ira",
    "iris",
    "ironía",
    "isla",
    "islote",
    "jabalí",
    "jabón",
    "jamón",
    "jarabe",
    "jardín",
    "jarra",
    "jaula",
    "jazmín",
    "jefe",
    "jeringa",
    "jinete",
    "jornada",
    "joroba",
    "joven",
    "joya",
    "juerga",
    "jueves",
    "juez",
    "jugador",
    "jugo",
    "juguete",
    "juicio",
    "junco",
    "jungla",
    "junio",
    "juntar",
    "júpiter",
    "jurar",
    "justo",
    "juvenil",
    "juzgar",
    "kilo",
    "koala",
    "labio",
    "lacio",
    "lacra",
    "lado",
    "ladrón",
    "lagarto",
    "lágrima",
    "laguna",
    "laico",
    "lamer",
    "lámina",
    "lámpara",
    "lana",
    "lancha",
    "langosta",
    "lanza",
    "lápiz",
    "largo",
    "larva",
    "lástima",
    "lata",
    "látex",
    "latir",
    "laurel",
    "lavar",
    "lazo",
    "leal",
    "lección",
    "leche",
    "lector",
    "leer",
    "legión",
    "legumbre",
    "lejano",
    "lengua",
    "lento",
    "leña",
    "león",
    "leopardo",
    "lesión",
    "letal",
    "letra",
    "leve",
    "leyenda",
    "libertad",
    "libro",
    "licor",
    "líder",
    "lidiar",
    "lienzo",
    "liga",
    "ligero",
    "lima",
    "límite",
    "limón",
    "limpio",
    "lince",
    "lindo",
    "línea",
    "lingote",
    "lino",
    "linterna",
    "líquido",
    "liso",
    "lista",
    "litera",
    "litio",
    "litro",
    "llaga",
    "llama",
    "llanto",
    "llave",
    "llegar",
    "llenar",
    "llevar",
    "llorar",
    "llover",
    "lluvia",
    "lobo",
    "loción",
    "loco",
    "locura",
    "lógica",
    "logro",
    "lombriz",
    "lomo",
    "lonja",
    "lote",
    "lucha",
    "lucir",
    "lugar",
    "lujo",
    "luna",
    "lunes",
    "lupa",
    "lustro",
    "luto",
    "luz",
    "maceta",
    "macho",
    "madera",
    "madre",
    "maduro",
    "maestro",
    "mafia",
    "magia",
    "mago",
    "maíz",
    "maldad",
    "maleta",
    "malla",
    "malo",
    "mamá",
    "mambo",
    "mamut",
    "manco",
    "mando",
    "manejar",
    "manga",
    "maniquí",
    "manjar",
    "mano",
    "manso",
    "manta",
    "mañana",
    "mapa",
    "máquina",
    "mar",
    "marco",
    "marea",
    "marfil",
    "margen",
    "marido",
    "mármol",
    "marrón",
    "martes",
    "marzo",
    "masa",
    "máscara",
    "masivo",
    "matar",
    "materia",
    "matiz",
    "matriz",
    "máximo",
    "mayor",
    "mazorca",
    "mecha",
    "medalla",
    "medio",
    "médula",
    "mejilla",
    "mejor",
    "melena",
    "melón",
    "memoria",
    "menor",
    "mensaje",
    "mente",
    "menú",
    "mercado",
    "merengue",
    "mérito",
    "mes",
    "mesón",
    "meta",
    "meter",
    "método",
    "metro",
    "mezcla",
    "miedo",
    "miel",
    "miembro",
    "miga",
    "mil",
    "milagro",
    "militar",
    "millón",
    "mimo",
    "mina",
    "minero",
    "mínimo",
    "minuto",
    "miope",
    "mirar",
    "misa",
    "miseria",
    "misil",
    "mismo",
    "mitad",
    "mito",
    "mochila",
    "moción",
    "moda",
    "modelo",
    "moho",
    "mojar",
    "molde",
    "moler",
    "molino",
    "momento",
    "momia",
    "monarca",
    "moneda",
    "monja",
    "monto",
    "moño",
    "morada",
    "morder",
    "moreno",
    "morir",
    "morro",
    "morsa",
    "mortal",
    "mosca",
    "mostrar",
    "motivo",
    "mover",
    "móvil",
    "mozo",
    "mucho",
    "mudar",
    "mueble",
    "muela",
    "muerte",
    "muestra",
    "mugre",
    "mujer",
    "mula",
    "muleta",
    "multa",
    "mundo",
    "muñeca",
    "mural",
    "muro",
    "músculo",
    "museo",
    "musgo",
    "música",
    "muslo",
    "nácar",
    "nación",
    "nadar",
    "naipe",
    "naranja",
    "nariz",
    "narrar",
    "nasal",
    "natal",
    "nativo",
    "natural",
    "náusea",
    "naval",
    "nave",
    "navidad",
    "necio",
    "néctar",
    "negar",
    "negocio",
    "negro",
    "neón",
    "nervio",
    "neto",
    "neutro",
    "nevar",
    "nevera",
    "nicho",
    "nido",
    "niebla",
    "nieto",
    "niñez",
    "niño",
    "nítido",
    "nivel",
    "nobleza",
    "noche",
    "nómina",
    "noria",
    "norma",
    "norte",
    "nota",
    "noticia",
    "novato",
    "novela",
    "novio",
    "nube",
    "nuca",
    "núcleo",
    "nudillo",
    "nudo",
    "nuera",
    "nueve",
    "nuez",
    "nulo",
    "número",
    "nutria",
    "oasis",
    "obeso",
    "obispo",
    "objeto",
    "obra",
    "obrero",
    "observar",
    "obtener",
    "obvio",
    "oca",
    "ocaso",
    "océano",
    "ochenta",
    "ocho",
    "ocio",
    "ocre",
    "octavo",
    "octubre",
    "oculto",
    "ocupar",
    "ocurrir",
    "odiar",
    "odio",
    "odisea",
    "oeste",
    "ofensa",
    "oferta",
    "oficio",
    "ofrecer",
    "ogro",
    "oído",
    "oír",
    "ojo",
    "ola",
    "oleada",
    "olfato",
    "olivo",
    "olla",
    "olmo",
    "olor",
    "olvido",
    "ombligo",
    "onda",
    "onza",
    "opaco",
    "opción",
    "ópera",
    "opinar",
    "oponer",
    "optar",
    "óptica",
    "opuesto",
    "oración",
    "orador",
    "oral",
    "órbita",
    "orca",
    "orden",
    "oreja",
    "órgano",
    "orgía",
    "orgullo",
    "oriente",
    "origen",
    "orilla",
    "oro",
    "orquesta",
    "oruga",
    "osadía",
    "oscuro",
    "osezno",
    "oso",
    "ostra",
    "otoño",
    "otro",
    "oveja",
    "óvulo",
    "óxido",
    "oxígeno",
    "oyente",
    "ozono",
    "pacto",
    "padre",
    "paella",
    "página",
    "pago",
    "país",
    "pájaro",
    "palabra",
    "palco",
    "paleta",
    "pálido",
    "palma",
    "paloma",
    "palpar",
    "pan",
    "panal",
    "pánico",
    "pantera",
    "pañuelo",
    "papá",
    "papel",
    "papilla",
    "paquete",
    "parar",
    "parcela",
    "pared",
    "parir",
    "paro",
    "párpado",
    "parque",
    "párrafo",
    "parte",
    "pasar",
    "paseo",
    "pasión",
    "paso",
    "pasta",
    "pata",
    "patio",
    "patria",
    "pausa",
    "pauta",
    "pavo",
    "payaso",
    "peatón",
    "pecado",
    "pecera",
    "pecho",
    "pedal",
    "pedir",
    "pegar",
    "peine",
    "pelar",
    "peldaño",
    "pelea",
    "peligro",
    "pellejo",
    "pelo",
    "peluca",
    "pena",
    "pensar",
    "peñón",
    "peón",
    "peor",
    "pepino",
    "pequeño",
    "pera",
    "percha",
    "perder",
    "pereza",
    "perfil",
    "perico",
    "perla",
    "permiso",
    "perro",
    "persona",
    "pesa",
    "pesca",
    "pésimo",
    "pestaña",
    "pétalo",
    "petróleo",
    "pez",
    "pezuña",
    "picar",
    "pichón",
    "pie",
    "piedra",
    "pierna",
    "pieza",
    "pijama",
    "pilar",
    "piloto",
    "pimienta",
    "pino",
    "pintor",
    "pinza",
    "piña",
    "piojo",
    "pipa",
    "pirata",
    "pisar",
    "piscina",
    "piso",
    "pista",
    "pitón",
    "pizca",
    "placa",
    "plan",
    "plata",
    "playa",
    "plaza",
    "pleito",
    "pleno",
    "plomo",
    "pluma",
    "plural",
    "pobre",
    "poco",
    "poder",
    "podio",
    "poema",
    "poesía",
    "poeta",
    "polen",
    "policía",
    "pollo",
    "polvo",
    "pomada",
    "pomelo",
    "pomo",
    "pompa",
    "poner",
    "porción",
    "portal",
    "posada",
    "poseer",
    "posible",
    "poste",
    "potencia",
    "potro",
    "pozo",
    "prado",
    "precoz",
    "pregunta",
    "premio",
    "prensa",
    "preso",
    "previo",
    "primo",
    "príncipe",
    "prisión",
    "privar",
    "proa",
    "probar",
    "proceso",
    "producto",
    "proeza",
    "profesor",
    "programa",
    "prole",
    "promesa",
    "pronto",
    "propio",
    "próximo",
    "prueba",
    "público",
    "puchero",
    "pudor",
    "pueblo",
    "puerta",
    "puesto",
    "pulga",
    "pulir",
    "pulmón",
    "pulpo",
    "pulso",
    "puma",
    "punto",
    "puñal",
    "puño",
    "pupa",
    "pupila",
    "puré",
    "quedar",
    "queja",
    "quemar",
    "querer",
    "queso",
    "quieto",
    "química",
    "quince",
    "quitar",
    "rábano",
    "rabia",
    "rabo",
    "ración",
    "radical",
    "raíz",
    "rama",
    "rampa",
    "rancho",
    "rango",
    "rapaz",
    "rápido",
    "rapto",
    "rasgo",
    "raspa",
    "rato",
    "rayo",
    "raza",
    "razón",
    "reacción",
    "realidad",
    "rebaño",
    "rebote",
    "recaer",
    "receta",
    "rechazo",
    "recoger",
    "recreo",
    "recto",
    "recurso",
    "red",
    "redondo",
    "reducir",
    "reflejo",
    "reforma",
    "refrán",
    "refugio",
    "regalo",
    "regir",
    "regla",
    "regreso",
    "rehén",
    "reino",
    "reír",
    "reja",
    "relato",
    "relevo",
    "relieve",
    "relleno",
    "reloj",
    "remar",
    "remedio",
    "remo",
    "rencor",
    "rendir",
    "renta",
    "reparto",
    "repetir",
    "reposo",
    "reptil",
    "res",
    "rescate",
    "resina",
    "respeto",
    "resto",
    "resumen",
    "retiro",
    "retorno",
    "retrato",
    "reunir",
    "revés",
    "revista",
    "rey",
    "rezar",
    "rico",
    "riego",
    "rienda",
    "riesgo",
    "rifa",
    "rígido",
    "rigor",
    "rincón",
    "riñón",
    "río",
    "riqueza",
    "risa",
    "ritmo",
    "rito",
    "rizo",
    "roble",
    "roce",
    "rociar",
    "rodar",
    "rodeo",
    "rodilla",
    "roer",
    "rojizo",
    "rojo",
    "romero",
    "romper",
    "ron",
    "ronco",
    "ronda",
    "ropa",
    "ropero",
    "rosa",
    "rosca",
    "rostro",
    "rotar",
    "rubí",
    "rubor",
    "rudo",
    "rueda",
    "rugir",
    "ruido",
    "ruina",
    "ruleta",
    "rulo",
    "rumbo",
    "rumor",
    "ruptura",
    "ruta",
    "rutina",
    "sábado",
    "saber",
    "sabio",
    "sable",
    "sacar",
    "sagaz",
    "sagrado",
    "sala",
    "saldo",
    "salero",
    "salir",
    "salmón",
    "salón",
    "salsa",
    "salto",
    "salud",
    "salvar",
    "samba",
    "sanción",
    "sandía",
    "sanear",
    "sangre",
    "sanidad",
    "sano",
    "santo",
    "sapo",
    "saque",
    "sardina",
    "sartén",
    "sastre",
    "satán",
    "sauna",
    "saxofón",
    "sección",
    "seco",
    "secreto",
    "secta",
    "sed",
    "seguir",
    "seis",
    "sello",
    "selva",
    "semana",
    "semilla",
    "senda",
    "sensor",
    "señal",
    "señor",
    "separar",
    "sepia",
    "sequía",
    "ser",
    "serie",
    "sermón",
    "servir",
    "sesenta",
    "sesión",
    "seta",
    "setenta",
    "severo",
    "sexo",
    "sexto",
    "sidra",
    "siesta",
    "siete",
    "siglo",
    "signo",
    "sílaba",
    "silbar",
    "silencio",
    "silla",
    "símbolo",
    "simio",
    "sirena",
    "sistema",
    "sitio",
    "situar",
    "sobre",
    "socio",
    "sodio",
    "sol",
    "solapa",
    "soldado",
    "soledad",
    "sólido",
    "soltar",
    "solución",
    "sombra",
    "sondeo",
    "sonido",
    "sonoro",
    "sonrisa",
    "sopa",
    "soplar",
    "soporte",
    "sordo",
    "sorpresa",
    "sorteo",
    "sostén",
    "sótano",
    "suave",
    "subir",
    "suceso",
    "sudor",
    "suegra",
    "suelo",
    "sueño",
    "suerte",
    "sufrir",
    "sujeto",
    "sultán",
    "sumar",
    "superar",
    "suplir",
    "suponer",
    "supremo",
    "sur",
    "surco",
    "sureño",
    "surgir",
    "susto",
    "sutil",
    "tabaco",
    "tabique",
    "tabla",
    "tabú",
    "taco",
    "tacto",
    "tajo",
    "talar",
    "talco",
    "talento",
    "talla",
    "talón",
    "tamaño",
    "tambor",
    "tango",
    "tanque",
    "tapa",
    "tapete",
    "tapia",
    "tapón",
    "taquilla",
    "tarde",
    "tarea",
    "tarifa",
    "tarjeta",
    "tarot",
    "tarro",
    "tarta",
    "tatuaje",
    "tauro",
    "taza",
    "tazón",
    "teatro",
    "techo",
    "tecla",
    "técnica",
    "tejado",
    "tejer",
    "tejido",
    "tela",
    "teléfono",
    "tema",
    "temor",
    "templo",
    "tenaz",
    "tender",
    "tener",
    "tenis",
    "tenso",
    "teoría",
    "terapia",
    "terco",
    "término",
    "ternura",
    "terror",
    "tesis",
    "tesoro",
    "testigo",
    "tetera",
    "texto",
    "tez",
    "tibio",
    "tiburón",
    "tiempo",
    "tienda",
    "tierra",
    "tieso",
    "tigre",
    "tijera",
    "tilde",
    "timbre",
    "tímido",
    "timo",
    "tinta",
    "tío",
    "típico",
    "tipo",
    "tira",
    "tirón",
    "titán",
    "títere",
    "título",
    "tiza",
    "toalla",
    "tobillo",
    "tocar",
    "tocino",
    "todo",
    "toga",
    "toldo",
    "tomar",
    "tono",
    "tonto",
    "topar",
    "tope",
    "toque",
    "tórax",
    "torero",
    "tormenta",
    "torneo",
    "toro",
    "torpedo",
    "torre",
    "torso",
    "tortuga",
    "tos",
    "tosco",
    "toser",
    "tóxico",
    "trabajo",
    "tractor",
    "traer",
    "tráfico",
    "trago",
    "traje",
    "tramo",
    "trance",
    "trato",
    "trauma",
    "trazar",
    "trébol",
    "tregua",
    "treinta",
    "tren",
    "trepar",
    "tres",
    "tribu",
    "trigo",
    "tripa",
    "triste",
    "triunfo",
    "trofeo",
    "trompa",
    "tronco",
    "tropa",
    "trote",
    "trozo",
    "truco",
    "trueno",
    "trufa",
    "tubería",
    "tubo",
    "tuerto",
    "tumba",
    "tumor",
    "túnel",
    "túnica",
    "turbina",
    "turismo",
    "turno",
    "tutor",
    "ubicar",
    "úlcera",
    "umbral",
    "unidad",
    "unir",
    "universo",
    "uno",
    "untar",
    "uña",
    "urbano",
    "urbe",
    "urgente",
    "urna",
    "usar",
    "usuario",
    "útil",
    "utopía",
    "uva",
    "vaca",
    "vacío",
    "vacuna",
    "vagar",
    "vago",
    "vaina",
    "vajilla",
    "vale",
    "válido",
    "valle",
    "valor",
    "válvula",
    "vampiro",
    "vara",
    "variar",
    "varón",
    "vaso",
    "vecino",
    "vector",
    "vehículo",
    "veinte",
    "vejez",
    "vela",
    "velero",
    "veloz",
    "vena",
    "vencer",
    "venda",
    "veneno",
    "vengar",
    "venir",
    "venta",
    "venus",
    "ver",
    "verano",
    "verbo",
    "verde",
    "vereda",
    "verja",
    "verso",
    "verter",
    "vía",
    "viaje",
    "vibrar",
    "vicio",
    "víctima",
    "vida",
    "vídeo",
    "vidrio",
    "viejo",
    "viernes",
    "vigor",
    "vil",
    "villa",
    "vinagre",
    "vino",
    "viñedo",
    "violín",
    "viral",
    "virgo",
    "virtud",
    "visor",
    "víspera",
    "vista",
    "vitamina",
    "viudo",
    "vivaz",
    "vivero",
    "vivir",
    "vivo",
    "volcán",
    "volumen",
    "volver",
    "voraz",
    "votar",
    "voto",
    "voz",
    "vuelo",
    "vulgar",
    "yacer",
    "yate",
    "yegua",
    "yema",
    "yerno",
    "yeso",
    "yodo",
    "yoga",
    "yogur",
    "zafiro",
    "zanja",
    "zapato",
    "zarza",
    "zona",
    "zorro",
    "zumo",
    "zurdo"
  ]), Zu;
}
/*!
 * index.js - wordlists for bcoin
 * Copyright (c) 2015-2016, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var V3;
function dy() {
  return V3 || (V3 = 1, di.chinese = {
    simplified: oy(),
    traditional: ay()
  }, di.english = fy(), di.french = cy(), di.italian = uy(), di.japanese = hy(), di.spanish = ly()), di;
}
/*!
 * wordlist.js - wordlists for bcoin
 * Copyright (c) 2015-2016, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var $3;
function qp() {
  if ($3) return $u;
  $3 = 1;
  const e = dy();
  return $u.get = function(l) {
    switch (l) {
      case "simplified chinese":
        return e.chinese.simplified;
      case "traditional chinese":
        return e.chinese.traditional;
      case "english":
        return e.english;
      case "french":
        return e.french;
      case "italian":
        return e.italian;
      case "japanese":
        return e.japanese;
      case "spanish":
        return e.spanish;
      default:
        throw new Error(`Unknown language: ${l}.`);
    }
  }, $u;
}
var tn = {};
const by = {
  0: { 60: [null, null, { 824: 8814 }], 61: [null, null, { 824: 8800 }], 62: [null, null, { 824: 8815 }], 65: [null, null, { 768: 192, 769: 193, 770: 194, 771: 195, 772: 256, 774: 258, 775: 550, 776: 196, 777: 7842, 778: 197, 780: 461, 783: 512, 785: 514, 803: 7840, 805: 7680, 808: 260 }], 66: [null, null, { 775: 7682, 803: 7684, 817: 7686 }], 67: [null, null, { 769: 262, 770: 264, 775: 266, 780: 268, 807: 199 }], 68: [null, null, { 775: 7690, 780: 270, 803: 7692, 807: 7696, 813: 7698, 817: 7694 }], 69: [null, null, { 768: 200, 769: 201, 770: 202, 771: 7868, 772: 274, 774: 276, 775: 278, 776: 203, 777: 7866, 780: 282, 783: 516, 785: 518, 803: 7864, 807: 552, 808: 280, 813: 7704, 816: 7706 }], 70: [null, null, { 775: 7710 }], 71: [null, null, { 769: 500, 770: 284, 772: 7712, 774: 286, 775: 288, 780: 486, 807: 290 }], 72: [null, null, { 770: 292, 775: 7714, 776: 7718, 780: 542, 803: 7716, 807: 7720, 814: 7722 }], 73: [null, null, { 768: 204, 769: 205, 770: 206, 771: 296, 772: 298, 774: 300, 775: 304, 776: 207, 777: 7880, 780: 463, 783: 520, 785: 522, 803: 7882, 808: 302, 816: 7724 }], 74: [null, null, { 770: 308 }], 75: [null, null, { 769: 7728, 780: 488, 803: 7730, 807: 310, 817: 7732 }], 76: [null, null, { 769: 313, 780: 317, 803: 7734, 807: 315, 813: 7740, 817: 7738 }], 77: [null, null, { 769: 7742, 775: 7744, 803: 7746 }], 78: [null, null, { 768: 504, 769: 323, 771: 209, 775: 7748, 780: 327, 803: 7750, 807: 325, 813: 7754, 817: 7752 }], 79: [null, null, { 768: 210, 769: 211, 770: 212, 771: 213, 772: 332, 774: 334, 775: 558, 776: 214, 777: 7886, 779: 336, 780: 465, 783: 524, 785: 526, 795: 416, 803: 7884, 808: 490 }], 80: [null, null, { 769: 7764, 775: 7766 }], 82: [null, null, { 769: 340, 775: 7768, 780: 344, 783: 528, 785: 530, 803: 7770, 807: 342, 817: 7774 }], 83: [null, null, { 769: 346, 770: 348, 775: 7776, 780: 352, 803: 7778, 806: 536, 807: 350 }], 84: [null, null, { 775: 7786, 780: 356, 803: 7788, 806: 538, 807: 354, 813: 7792, 817: 7790 }], 85: [null, null, { 768: 217, 769: 218, 770: 219, 771: 360, 772: 362, 774: 364, 776: 220, 777: 7910, 778: 366, 779: 368, 780: 467, 783: 532, 785: 534, 795: 431, 803: 7908, 804: 7794, 808: 370, 813: 7798, 816: 7796 }], 86: [null, null, { 771: 7804, 803: 7806 }], 87: [null, null, { 768: 7808, 769: 7810, 770: 372, 775: 7814, 776: 7812, 803: 7816 }], 88: [null, null, { 775: 7818, 776: 7820 }], 89: [null, null, { 768: 7922, 769: 221, 770: 374, 771: 7928, 772: 562, 775: 7822, 776: 376, 777: 7926, 803: 7924 }], 90: [null, null, { 769: 377, 770: 7824, 775: 379, 780: 381, 803: 7826, 817: 7828 }], 97: [null, null, { 768: 224, 769: 225, 770: 226, 771: 227, 772: 257, 774: 259, 775: 551, 776: 228, 777: 7843, 778: 229, 780: 462, 783: 513, 785: 515, 803: 7841, 805: 7681, 808: 261 }], 98: [null, null, { 775: 7683, 803: 7685, 817: 7687 }], 99: [null, null, { 769: 263, 770: 265, 775: 267, 780: 269, 807: 231 }], 100: [null, null, { 775: 7691, 780: 271, 803: 7693, 807: 7697, 813: 7699, 817: 7695 }], 101: [null, null, { 768: 232, 769: 233, 770: 234, 771: 7869, 772: 275, 774: 277, 775: 279, 776: 235, 777: 7867, 780: 283, 783: 517, 785: 519, 803: 7865, 807: 553, 808: 281, 813: 7705, 816: 7707 }], 102: [null, null, { 775: 7711 }], 103: [null, null, { 769: 501, 770: 285, 772: 7713, 774: 287, 775: 289, 780: 487, 807: 291 }], 104: [null, null, { 770: 293, 775: 7715, 776: 7719, 780: 543, 803: 7717, 807: 7721, 814: 7723, 817: 7830 }], 105: [null, null, { 768: 236, 769: 237, 770: 238, 771: 297, 772: 299, 774: 301, 776: 239, 777: 7881, 780: 464, 783: 521, 785: 523, 803: 7883, 808: 303, 816: 7725 }], 106: [null, null, { 770: 309, 780: 496 }], 107: [null, null, { 769: 7729, 780: 489, 803: 7731, 807: 311, 817: 7733 }], 108: [null, null, { 769: 314, 780: 318, 803: 7735, 807: 316, 813: 7741, 817: 7739 }], 109: [null, null, { 769: 7743, 775: 7745, 803: 7747 }], 110: [null, null, { 768: 505, 769: 324, 771: 241, 775: 7749, 780: 328, 803: 7751, 807: 326, 813: 7755, 817: 7753 }], 111: [null, null, { 768: 242, 769: 243, 770: 244, 771: 245, 772: 333, 774: 335, 775: 559, 776: 246, 777: 7887, 779: 337, 780: 466, 783: 525, 785: 527, 795: 417, 803: 7885, 808: 491 }], 112: [null, null, { 769: 7765, 775: 7767 }], 114: [null, null, { 769: 341, 775: 7769, 780: 345, 783: 529, 785: 531, 803: 7771, 807: 343, 817: 7775 }], 115: [null, null, { 769: 347, 770: 349, 775: 7777, 780: 353, 803: 7779, 806: 537, 807: 351 }], 116: [null, null, { 775: 7787, 776: 7831, 780: 357, 803: 7789, 806: 539, 807: 355, 813: 7793, 817: 7791 }], 117: [null, null, { 768: 249, 769: 250, 770: 251, 771: 361, 772: 363, 774: 365, 776: 252, 777: 7911, 778: 367, 779: 369, 780: 468, 783: 533, 785: 535, 795: 432, 803: 7909, 804: 7795, 808: 371, 813: 7799, 816: 7797 }], 118: [null, null, { 771: 7805, 803: 7807 }], 119: [null, null, { 768: 7809, 769: 7811, 770: 373, 775: 7815, 776: 7813, 778: 7832, 803: 7817 }], 120: [null, null, { 775: 7819, 776: 7821 }], 121: [null, null, { 768: 7923, 769: 253, 770: 375, 771: 7929, 772: 563, 775: 7823, 776: 255, 777: 7927, 778: 7833, 803: 7925 }], 122: [null, null, { 769: 378, 770: 7825, 775: 380, 780: 382, 803: 7827, 817: 7829 }], 160: [[32], 256], 168: [[32, 776], 256, { 768: 8173, 769: 901, 834: 8129 }], 170: [[97], 256], 175: [[32, 772], 256], 178: [[50], 256], 179: [[51], 256], 180: [[32, 769], 256], 181: [[956], 256], 184: [[32, 807], 256], 185: [[49], 256], 186: [[111], 256], 188: [[49, 8260, 52], 256], 189: [[49, 8260, 50], 256], 190: [[51, 8260, 52], 256], 192: [[65, 768]], 193: [[65, 769]], 194: [[65, 770], null, { 768: 7846, 769: 7844, 771: 7850, 777: 7848 }], 195: [[65, 771]], 196: [[65, 776], null, { 772: 478 }], 197: [[65, 778], null, { 769: 506 }], 198: [null, null, { 769: 508, 772: 482 }], 199: [[67, 807], null, { 769: 7688 }], 200: [[69, 768]], 201: [[69, 769]], 202: [[69, 770], null, { 768: 7872, 769: 7870, 771: 7876, 777: 7874 }], 203: [[69, 776]], 204: [[73, 768]], 205: [[73, 769]], 206: [[73, 770]], 207: [[73, 776], null, { 769: 7726 }], 209: [[78, 771]], 210: [[79, 768]], 211: [[79, 769]], 212: [[79, 770], null, { 768: 7890, 769: 7888, 771: 7894, 777: 7892 }], 213: [[79, 771], null, { 769: 7756, 772: 556, 776: 7758 }], 214: [[79, 776], null, { 772: 554 }], 216: [null, null, { 769: 510 }], 217: [[85, 768]], 218: [[85, 769]], 219: [[85, 770]], 220: [[85, 776], null, { 768: 475, 769: 471, 772: 469, 780: 473 }], 221: [[89, 769]], 224: [[97, 768]], 225: [[97, 769]], 226: [[97, 770], null, { 768: 7847, 769: 7845, 771: 7851, 777: 7849 }], 227: [[97, 771]], 228: [[97, 776], null, { 772: 479 }], 229: [[97, 778], null, { 769: 507 }], 230: [null, null, { 769: 509, 772: 483 }], 231: [[99, 807], null, { 769: 7689 }], 232: [[101, 768]], 233: [[101, 769]], 234: [[101, 770], null, { 768: 7873, 769: 7871, 771: 7877, 777: 7875 }], 235: [[101, 776]], 236: [[105, 768]], 237: [[105, 769]], 238: [[105, 770]], 239: [[105, 776], null, { 769: 7727 }], 241: [[110, 771]], 242: [[111, 768]], 243: [[111, 769]], 244: [[111, 770], null, { 768: 7891, 769: 7889, 771: 7895, 777: 7893 }], 245: [[111, 771], null, { 769: 7757, 772: 557, 776: 7759 }], 246: [[111, 776], null, { 772: 555 }], 248: [null, null, { 769: 511 }], 249: [[117, 768]], 250: [[117, 769]], 251: [[117, 770]], 252: [[117, 776], null, { 768: 476, 769: 472, 772: 470, 780: 474 }], 253: [[121, 769]], 255: [[121, 776]] },
  256: { 256: [[65, 772]], 257: [[97, 772]], 258: [[65, 774], null, { 768: 7856, 769: 7854, 771: 7860, 777: 7858 }], 259: [[97, 774], null, { 768: 7857, 769: 7855, 771: 7861, 777: 7859 }], 260: [[65, 808]], 261: [[97, 808]], 262: [[67, 769]], 263: [[99, 769]], 264: [[67, 770]], 265: [[99, 770]], 266: [[67, 775]], 267: [[99, 775]], 268: [[67, 780]], 269: [[99, 780]], 270: [[68, 780]], 271: [[100, 780]], 274: [[69, 772], null, { 768: 7700, 769: 7702 }], 275: [[101, 772], null, { 768: 7701, 769: 7703 }], 276: [[69, 774]], 277: [[101, 774]], 278: [[69, 775]], 279: [[101, 775]], 280: [[69, 808]], 281: [[101, 808]], 282: [[69, 780]], 283: [[101, 780]], 284: [[71, 770]], 285: [[103, 770]], 286: [[71, 774]], 287: [[103, 774]], 288: [[71, 775]], 289: [[103, 775]], 290: [[71, 807]], 291: [[103, 807]], 292: [[72, 770]], 293: [[104, 770]], 296: [[73, 771]], 297: [[105, 771]], 298: [[73, 772]], 299: [[105, 772]], 300: [[73, 774]], 301: [[105, 774]], 302: [[73, 808]], 303: [[105, 808]], 304: [[73, 775]], 306: [[73, 74], 256], 307: [[105, 106], 256], 308: [[74, 770]], 309: [[106, 770]], 310: [[75, 807]], 311: [[107, 807]], 313: [[76, 769]], 314: [[108, 769]], 315: [[76, 807]], 316: [[108, 807]], 317: [[76, 780]], 318: [[108, 780]], 319: [[76, 183], 256], 320: [[108, 183], 256], 323: [[78, 769]], 324: [[110, 769]], 325: [[78, 807]], 326: [[110, 807]], 327: [[78, 780]], 328: [[110, 780]], 329: [[700, 110], 256], 332: [[79, 772], null, { 768: 7760, 769: 7762 }], 333: [[111, 772], null, { 768: 7761, 769: 7763 }], 334: [[79, 774]], 335: [[111, 774]], 336: [[79, 779]], 337: [[111, 779]], 340: [[82, 769]], 341: [[114, 769]], 342: [[82, 807]], 343: [[114, 807]], 344: [[82, 780]], 345: [[114, 780]], 346: [[83, 769], null, { 775: 7780 }], 347: [[115, 769], null, { 775: 7781 }], 348: [[83, 770]], 349: [[115, 770]], 350: [[83, 807]], 351: [[115, 807]], 352: [[83, 780], null, { 775: 7782 }], 353: [[115, 780], null, { 775: 7783 }], 354: [[84, 807]], 355: [[116, 807]], 356: [[84, 780]], 357: [[116, 780]], 360: [[85, 771], null, { 769: 7800 }], 361: [[117, 771], null, { 769: 7801 }], 362: [[85, 772], null, { 776: 7802 }], 363: [[117, 772], null, { 776: 7803 }], 364: [[85, 774]], 365: [[117, 774]], 366: [[85, 778]], 367: [[117, 778]], 368: [[85, 779]], 369: [[117, 779]], 370: [[85, 808]], 371: [[117, 808]], 372: [[87, 770]], 373: [[119, 770]], 374: [[89, 770]], 375: [[121, 770]], 376: [[89, 776]], 377: [[90, 769]], 378: [[122, 769]], 379: [[90, 775]], 380: [[122, 775]], 381: [[90, 780]], 382: [[122, 780]], 383: [[115], 256, { 775: 7835 }], 416: [[79, 795], null, { 768: 7900, 769: 7898, 771: 7904, 777: 7902, 803: 7906 }], 417: [[111, 795], null, { 768: 7901, 769: 7899, 771: 7905, 777: 7903, 803: 7907 }], 431: [[85, 795], null, { 768: 7914, 769: 7912, 771: 7918, 777: 7916, 803: 7920 }], 432: [[117, 795], null, { 768: 7915, 769: 7913, 771: 7919, 777: 7917, 803: 7921 }], 439: [null, null, { 780: 494 }], 452: [[68, 381], 256], 453: [[68, 382], 256], 454: [[100, 382], 256], 455: [[76, 74], 256], 456: [[76, 106], 256], 457: [[108, 106], 256], 458: [[78, 74], 256], 459: [[78, 106], 256], 460: [[110, 106], 256], 461: [[65, 780]], 462: [[97, 780]], 463: [[73, 780]], 464: [[105, 780]], 465: [[79, 780]], 466: [[111, 780]], 467: [[85, 780]], 468: [[117, 780]], 469: [[220, 772]], 470: [[252, 772]], 471: [[220, 769]], 472: [[252, 769]], 473: [[220, 780]], 474: [[252, 780]], 475: [[220, 768]], 476: [[252, 768]], 478: [[196, 772]], 479: [[228, 772]], 480: [[550, 772]], 481: [[551, 772]], 482: [[198, 772]], 483: [[230, 772]], 486: [[71, 780]], 487: [[103, 780]], 488: [[75, 780]], 489: [[107, 780]], 490: [[79, 808], null, { 772: 492 }], 491: [[111, 808], null, { 772: 493 }], 492: [[490, 772]], 493: [[491, 772]], 494: [[439, 780]], 495: [[658, 780]], 496: [[106, 780]], 497: [[68, 90], 256], 498: [[68, 122], 256], 499: [[100, 122], 256], 500: [[71, 769]], 501: [[103, 769]], 504: [[78, 768]], 505: [[110, 768]], 506: [[197, 769]], 507: [[229, 769]], 508: [[198, 769]], 509: [[230, 769]], 510: [[216, 769]], 511: [[248, 769]], 66045: [null, 220] },
  512: { 512: [[65, 783]], 513: [[97, 783]], 514: [[65, 785]], 515: [[97, 785]], 516: [[69, 783]], 517: [[101, 783]], 518: [[69, 785]], 519: [[101, 785]], 520: [[73, 783]], 521: [[105, 783]], 522: [[73, 785]], 523: [[105, 785]], 524: [[79, 783]], 525: [[111, 783]], 526: [[79, 785]], 527: [[111, 785]], 528: [[82, 783]], 529: [[114, 783]], 530: [[82, 785]], 531: [[114, 785]], 532: [[85, 783]], 533: [[117, 783]], 534: [[85, 785]], 535: [[117, 785]], 536: [[83, 806]], 537: [[115, 806]], 538: [[84, 806]], 539: [[116, 806]], 542: [[72, 780]], 543: [[104, 780]], 550: [[65, 775], null, { 772: 480 }], 551: [[97, 775], null, { 772: 481 }], 552: [[69, 807], null, { 774: 7708 }], 553: [[101, 807], null, { 774: 7709 }], 554: [[214, 772]], 555: [[246, 772]], 556: [[213, 772]], 557: [[245, 772]], 558: [[79, 775], null, { 772: 560 }], 559: [[111, 775], null, { 772: 561 }], 560: [[558, 772]], 561: [[559, 772]], 562: [[89, 772]], 563: [[121, 772]], 658: [null, null, { 780: 495 }], 688: [[104], 256], 689: [[614], 256], 690: [[106], 256], 691: [[114], 256], 692: [[633], 256], 693: [[635], 256], 694: [[641], 256], 695: [[119], 256], 696: [[121], 256], 728: [[32, 774], 256], 729: [[32, 775], 256], 730: [[32, 778], 256], 731: [[32, 808], 256], 732: [[32, 771], 256], 733: [[32, 779], 256], 736: [[611], 256], 737: [[108], 256], 738: [[115], 256], 739: [[120], 256], 740: [[661], 256], 66272: [null, 220] },
  768: { 768: [null, 230], 769: [null, 230], 770: [null, 230], 771: [null, 230], 772: [null, 230], 773: [null, 230], 774: [null, 230], 775: [null, 230], 776: [null, 230, { 769: 836 }], 777: [null, 230], 778: [null, 230], 779: [null, 230], 780: [null, 230], 781: [null, 230], 782: [null, 230], 783: [null, 230], 784: [null, 230], 785: [null, 230], 786: [null, 230], 787: [null, 230], 788: [null, 230], 789: [null, 232], 790: [null, 220], 791: [null, 220], 792: [null, 220], 793: [null, 220], 794: [null, 232], 795: [null, 216], 796: [null, 220], 797: [null, 220], 798: [null, 220], 799: [null, 220], 800: [null, 220], 801: [null, 202], 802: [null, 202], 803: [null, 220], 804: [null, 220], 805: [null, 220], 806: [null, 220], 807: [null, 202], 808: [null, 202], 809: [null, 220], 810: [null, 220], 811: [null, 220], 812: [null, 220], 813: [null, 220], 814: [null, 220], 815: [null, 220], 816: [null, 220], 817: [null, 220], 818: [null, 220], 819: [null, 220], 820: [null, 1], 821: [null, 1], 822: [null, 1], 823: [null, 1], 824: [null, 1], 825: [null, 220], 826: [null, 220], 827: [null, 220], 828: [null, 220], 829: [null, 230], 830: [null, 230], 831: [null, 230], 832: [[768], 230], 833: [[769], 230], 834: [null, 230], 835: [[787], 230], 836: [[776, 769], 230], 837: [null, 240], 838: [null, 230], 839: [null, 220], 840: [null, 220], 841: [null, 220], 842: [null, 230], 843: [null, 230], 844: [null, 230], 845: [null, 220], 846: [null, 220], 848: [null, 230], 849: [null, 230], 850: [null, 230], 851: [null, 220], 852: [null, 220], 853: [null, 220], 854: [null, 220], 855: [null, 230], 856: [null, 232], 857: [null, 220], 858: [null, 220], 859: [null, 230], 860: [null, 233], 861: [null, 234], 862: [null, 234], 863: [null, 233], 864: [null, 234], 865: [null, 234], 866: [null, 233], 867: [null, 230], 868: [null, 230], 869: [null, 230], 870: [null, 230], 871: [null, 230], 872: [null, 230], 873: [null, 230], 874: [null, 230], 875: [null, 230], 876: [null, 230], 877: [null, 230], 878: [null, 230], 879: [null, 230], 884: [[697]], 890: [[32, 837], 256], 894: [[59]], 900: [[32, 769], 256], 901: [[168, 769]], 902: [[913, 769]], 903: [[183]], 904: [[917, 769]], 905: [[919, 769]], 906: [[921, 769]], 908: [[927, 769]], 910: [[933, 769]], 911: [[937, 769]], 912: [[970, 769]], 913: [null, null, { 768: 8122, 769: 902, 772: 8121, 774: 8120, 787: 7944, 788: 7945, 837: 8124 }], 917: [null, null, { 768: 8136, 769: 904, 787: 7960, 788: 7961 }], 919: [null, null, { 768: 8138, 769: 905, 787: 7976, 788: 7977, 837: 8140 }], 921: [null, null, { 768: 8154, 769: 906, 772: 8153, 774: 8152, 776: 938, 787: 7992, 788: 7993 }], 927: [null, null, { 768: 8184, 769: 908, 787: 8008, 788: 8009 }], 929: [null, null, { 788: 8172 }], 933: [null, null, { 768: 8170, 769: 910, 772: 8169, 774: 8168, 776: 939, 788: 8025 }], 937: [null, null, { 768: 8186, 769: 911, 787: 8040, 788: 8041, 837: 8188 }], 938: [[921, 776]], 939: [[933, 776]], 940: [[945, 769], null, { 837: 8116 }], 941: [[949, 769]], 942: [[951, 769], null, { 837: 8132 }], 943: [[953, 769]], 944: [[971, 769]], 945: [null, null, { 768: 8048, 769: 940, 772: 8113, 774: 8112, 787: 7936, 788: 7937, 834: 8118, 837: 8115 }], 949: [null, null, { 768: 8050, 769: 941, 787: 7952, 788: 7953 }], 951: [null, null, { 768: 8052, 769: 942, 787: 7968, 788: 7969, 834: 8134, 837: 8131 }], 953: [null, null, { 768: 8054, 769: 943, 772: 8145, 774: 8144, 776: 970, 787: 7984, 788: 7985, 834: 8150 }], 959: [null, null, { 768: 8056, 769: 972, 787: 8e3, 788: 8001 }], 961: [null, null, { 787: 8164, 788: 8165 }], 965: [null, null, { 768: 8058, 769: 973, 772: 8161, 774: 8160, 776: 971, 787: 8016, 788: 8017, 834: 8166 }], 969: [null, null, { 768: 8060, 769: 974, 787: 8032, 788: 8033, 834: 8182, 837: 8179 }], 970: [[953, 776], null, { 768: 8146, 769: 912, 834: 8151 }], 971: [[965, 776], null, { 768: 8162, 769: 944, 834: 8167 }], 972: [[959, 769]], 973: [[965, 769]], 974: [[969, 769], null, { 837: 8180 }], 976: [[946], 256], 977: [[952], 256], 978: [[933], 256, { 769: 979, 776: 980 }], 979: [[978, 769]], 980: [[978, 776]], 981: [[966], 256], 982: [[960], 256], 1008: [[954], 256], 1009: [[961], 256], 1010: [[962], 256], 1012: [[920], 256], 1013: [[949], 256], 1017: [[931], 256], 66422: [null, 230], 66423: [null, 230], 66424: [null, 230], 66425: [null, 230], 66426: [null, 230] },
  1024: { 1024: [[1045, 768]], 1025: [[1045, 776]], 1027: [[1043, 769]], 1030: [null, null, { 776: 1031 }], 1031: [[1030, 776]], 1036: [[1050, 769]], 1037: [[1048, 768]], 1038: [[1059, 774]], 1040: [null, null, { 774: 1232, 776: 1234 }], 1043: [null, null, { 769: 1027 }], 1045: [null, null, { 768: 1024, 774: 1238, 776: 1025 }], 1046: [null, null, { 774: 1217, 776: 1244 }], 1047: [null, null, { 776: 1246 }], 1048: [null, null, { 768: 1037, 772: 1250, 774: 1049, 776: 1252 }], 1049: [[1048, 774]], 1050: [null, null, { 769: 1036 }], 1054: [null, null, { 776: 1254 }], 1059: [null, null, { 772: 1262, 774: 1038, 776: 1264, 779: 1266 }], 1063: [null, null, { 776: 1268 }], 1067: [null, null, { 776: 1272 }], 1069: [null, null, { 776: 1260 }], 1072: [null, null, { 774: 1233, 776: 1235 }], 1075: [null, null, { 769: 1107 }], 1077: [null, null, { 768: 1104, 774: 1239, 776: 1105 }], 1078: [null, null, { 774: 1218, 776: 1245 }], 1079: [null, null, { 776: 1247 }], 1080: [null, null, { 768: 1117, 772: 1251, 774: 1081, 776: 1253 }], 1081: [[1080, 774]], 1082: [null, null, { 769: 1116 }], 1086: [null, null, { 776: 1255 }], 1091: [null, null, { 772: 1263, 774: 1118, 776: 1265, 779: 1267 }], 1095: [null, null, { 776: 1269 }], 1099: [null, null, { 776: 1273 }], 1101: [null, null, { 776: 1261 }], 1104: [[1077, 768]], 1105: [[1077, 776]], 1107: [[1075, 769]], 1110: [null, null, { 776: 1111 }], 1111: [[1110, 776]], 1116: [[1082, 769]], 1117: [[1080, 768]], 1118: [[1091, 774]], 1140: [null, null, { 783: 1142 }], 1141: [null, null, { 783: 1143 }], 1142: [[1140, 783]], 1143: [[1141, 783]], 1155: [null, 230], 1156: [null, 230], 1157: [null, 230], 1158: [null, 230], 1159: [null, 230], 1217: [[1046, 774]], 1218: [[1078, 774]], 1232: [[1040, 774]], 1233: [[1072, 774]], 1234: [[1040, 776]], 1235: [[1072, 776]], 1238: [[1045, 774]], 1239: [[1077, 774]], 1240: [null, null, { 776: 1242 }], 1241: [null, null, { 776: 1243 }], 1242: [[1240, 776]], 1243: [[1241, 776]], 1244: [[1046, 776]], 1245: [[1078, 776]], 1246: [[1047, 776]], 1247: [[1079, 776]], 1250: [[1048, 772]], 1251: [[1080, 772]], 1252: [[1048, 776]], 1253: [[1080, 776]], 1254: [[1054, 776]], 1255: [[1086, 776]], 1256: [null, null, { 776: 1258 }], 1257: [null, null, { 776: 1259 }], 1258: [[1256, 776]], 1259: [[1257, 776]], 1260: [[1069, 776]], 1261: [[1101, 776]], 1262: [[1059, 772]], 1263: [[1091, 772]], 1264: [[1059, 776]], 1265: [[1091, 776]], 1266: [[1059, 779]], 1267: [[1091, 779]], 1268: [[1063, 776]], 1269: [[1095, 776]], 1272: [[1067, 776]], 1273: [[1099, 776]] },
  1280: { 1415: [[1381, 1410], 256], 1425: [null, 220], 1426: [null, 230], 1427: [null, 230], 1428: [null, 230], 1429: [null, 230], 1430: [null, 220], 1431: [null, 230], 1432: [null, 230], 1433: [null, 230], 1434: [null, 222], 1435: [null, 220], 1436: [null, 230], 1437: [null, 230], 1438: [null, 230], 1439: [null, 230], 1440: [null, 230], 1441: [null, 230], 1442: [null, 220], 1443: [null, 220], 1444: [null, 220], 1445: [null, 220], 1446: [null, 220], 1447: [null, 220], 1448: [null, 230], 1449: [null, 230], 1450: [null, 220], 1451: [null, 230], 1452: [null, 230], 1453: [null, 222], 1454: [null, 228], 1455: [null, 230], 1456: [null, 10], 1457: [null, 11], 1458: [null, 12], 1459: [null, 13], 1460: [null, 14], 1461: [null, 15], 1462: [null, 16], 1463: [null, 17], 1464: [null, 18], 1465: [null, 19], 1466: [null, 19], 1467: [null, 20], 1468: [null, 21], 1469: [null, 22], 1471: [null, 23], 1473: [null, 24], 1474: [null, 25], 1476: [null, 230], 1477: [null, 220], 1479: [null, 18] },
  1536: { 1552: [null, 230], 1553: [null, 230], 1554: [null, 230], 1555: [null, 230], 1556: [null, 230], 1557: [null, 230], 1558: [null, 230], 1559: [null, 230], 1560: [null, 30], 1561: [null, 31], 1562: [null, 32], 1570: [[1575, 1619]], 1571: [[1575, 1620]], 1572: [[1608, 1620]], 1573: [[1575, 1621]], 1574: [[1610, 1620]], 1575: [null, null, { 1619: 1570, 1620: 1571, 1621: 1573 }], 1608: [null, null, { 1620: 1572 }], 1610: [null, null, { 1620: 1574 }], 1611: [null, 27], 1612: [null, 28], 1613: [null, 29], 1614: [null, 30], 1615: [null, 31], 1616: [null, 32], 1617: [null, 33], 1618: [null, 34], 1619: [null, 230], 1620: [null, 230], 1621: [null, 220], 1622: [null, 220], 1623: [null, 230], 1624: [null, 230], 1625: [null, 230], 1626: [null, 230], 1627: [null, 230], 1628: [null, 220], 1629: [null, 230], 1630: [null, 230], 1631: [null, 220], 1648: [null, 35], 1653: [[1575, 1652], 256], 1654: [[1608, 1652], 256], 1655: [[1735, 1652], 256], 1656: [[1610, 1652], 256], 1728: [[1749, 1620]], 1729: [null, null, { 1620: 1730 }], 1730: [[1729, 1620]], 1746: [null, null, { 1620: 1747 }], 1747: [[1746, 1620]], 1749: [null, null, { 1620: 1728 }], 1750: [null, 230], 1751: [null, 230], 1752: [null, 230], 1753: [null, 230], 1754: [null, 230], 1755: [null, 230], 1756: [null, 230], 1759: [null, 230], 1760: [null, 230], 1761: [null, 230], 1762: [null, 230], 1763: [null, 220], 1764: [null, 230], 1767: [null, 230], 1768: [null, 230], 1770: [null, 220], 1771: [null, 230], 1772: [null, 230], 1773: [null, 220] },
  1792: { 1809: [null, 36], 1840: [null, 230], 1841: [null, 220], 1842: [null, 230], 1843: [null, 230], 1844: [null, 220], 1845: [null, 230], 1846: [null, 230], 1847: [null, 220], 1848: [null, 220], 1849: [null, 220], 1850: [null, 230], 1851: [null, 220], 1852: [null, 220], 1853: [null, 230], 1854: [null, 220], 1855: [null, 230], 1856: [null, 230], 1857: [null, 230], 1858: [null, 220], 1859: [null, 230], 1860: [null, 220], 1861: [null, 230], 1862: [null, 220], 1863: [null, 230], 1864: [null, 220], 1865: [null, 230], 1866: [null, 230], 2027: [null, 230], 2028: [null, 230], 2029: [null, 230], 2030: [null, 230], 2031: [null, 230], 2032: [null, 230], 2033: [null, 230], 2034: [null, 220], 2035: [null, 230] },
  2048: { 2070: [null, 230], 2071: [null, 230], 2072: [null, 230], 2073: [null, 230], 2075: [null, 230], 2076: [null, 230], 2077: [null, 230], 2078: [null, 230], 2079: [null, 230], 2080: [null, 230], 2081: [null, 230], 2082: [null, 230], 2083: [null, 230], 2085: [null, 230], 2086: [null, 230], 2087: [null, 230], 2089: [null, 230], 2090: [null, 230], 2091: [null, 230], 2092: [null, 230], 2093: [null, 230], 2137: [null, 220], 2138: [null, 220], 2139: [null, 220], 2276: [null, 230], 2277: [null, 230], 2278: [null, 220], 2279: [null, 230], 2280: [null, 230], 2281: [null, 220], 2282: [null, 230], 2283: [null, 230], 2284: [null, 230], 2285: [null, 220], 2286: [null, 220], 2287: [null, 220], 2288: [null, 27], 2289: [null, 28], 2290: [null, 29], 2291: [null, 230], 2292: [null, 230], 2293: [null, 230], 2294: [null, 220], 2295: [null, 230], 2296: [null, 230], 2297: [null, 220], 2298: [null, 220], 2299: [null, 230], 2300: [null, 230], 2301: [null, 230], 2302: [null, 230], 2303: [null, 230] },
  2304: { 2344: [null, null, { 2364: 2345 }], 2345: [[2344, 2364]], 2352: [null, null, { 2364: 2353 }], 2353: [[2352, 2364]], 2355: [null, null, { 2364: 2356 }], 2356: [[2355, 2364]], 2364: [null, 7], 2381: [null, 9], 2385: [null, 230], 2386: [null, 220], 2387: [null, 230], 2388: [null, 230], 2392: [[2325, 2364], 512], 2393: [[2326, 2364], 512], 2394: [[2327, 2364], 512], 2395: [[2332, 2364], 512], 2396: [[2337, 2364], 512], 2397: [[2338, 2364], 512], 2398: [[2347, 2364], 512], 2399: [[2351, 2364], 512], 2492: [null, 7], 2503: [null, null, { 2494: 2507, 2519: 2508 }], 2507: [[2503, 2494]], 2508: [[2503, 2519]], 2509: [null, 9], 2524: [[2465, 2492], 512], 2525: [[2466, 2492], 512], 2527: [[2479, 2492], 512] },
  2560: { 2611: [[2610, 2620], 512], 2614: [[2616, 2620], 512], 2620: [null, 7], 2637: [null, 9], 2649: [[2582, 2620], 512], 2650: [[2583, 2620], 512], 2651: [[2588, 2620], 512], 2654: [[2603, 2620], 512], 2748: [null, 7], 2765: [null, 9], 68109: [null, 220], 68111: [null, 230], 68152: [null, 230], 68153: [null, 1], 68154: [null, 220], 68159: [null, 9], 68325: [null, 230], 68326: [null, 220] },
  2816: { 2876: [null, 7], 2887: [null, null, { 2878: 2891, 2902: 2888, 2903: 2892 }], 2888: [[2887, 2902]], 2891: [[2887, 2878]], 2892: [[2887, 2903]], 2893: [null, 9], 2908: [[2849, 2876], 512], 2909: [[2850, 2876], 512], 2962: [null, null, { 3031: 2964 }], 2964: [[2962, 3031]], 3014: [null, null, { 3006: 3018, 3031: 3020 }], 3015: [null, null, { 3006: 3019 }], 3018: [[3014, 3006]], 3019: [[3015, 3006]], 3020: [[3014, 3031]], 3021: [null, 9] },
  3072: { 3142: [null, null, { 3158: 3144 }], 3144: [[3142, 3158]], 3149: [null, 9], 3157: [null, 84], 3158: [null, 91], 3260: [null, 7], 3263: [null, null, { 3285: 3264 }], 3264: [[3263, 3285]], 3270: [null, null, { 3266: 3274, 3285: 3271, 3286: 3272 }], 3271: [[3270, 3285]], 3272: [[3270, 3286]], 3274: [[3270, 3266], null, { 3285: 3275 }], 3275: [[3274, 3285]], 3277: [null, 9] },
  3328: { 3398: [null, null, { 3390: 3402, 3415: 3404 }], 3399: [null, null, { 3390: 3403 }], 3402: [[3398, 3390]], 3403: [[3399, 3390]], 3404: [[3398, 3415]], 3405: [null, 9], 3530: [null, 9], 3545: [null, null, { 3530: 3546, 3535: 3548, 3551: 3550 }], 3546: [[3545, 3530]], 3548: [[3545, 3535], null, { 3530: 3549 }], 3549: [[3548, 3530]], 3550: [[3545, 3551]] },
  3584: { 3635: [[3661, 3634], 256], 3640: [null, 103], 3641: [null, 103], 3642: [null, 9], 3656: [null, 107], 3657: [null, 107], 3658: [null, 107], 3659: [null, 107], 3763: [[3789, 3762], 256], 3768: [null, 118], 3769: [null, 118], 3784: [null, 122], 3785: [null, 122], 3786: [null, 122], 3787: [null, 122], 3804: [[3755, 3737], 256], 3805: [[3755, 3745], 256] },
  3840: { 3852: [[3851], 256], 3864: [null, 220], 3865: [null, 220], 3893: [null, 220], 3895: [null, 220], 3897: [null, 216], 3907: [[3906, 4023], 512], 3917: [[3916, 4023], 512], 3922: [[3921, 4023], 512], 3927: [[3926, 4023], 512], 3932: [[3931, 4023], 512], 3945: [[3904, 4021], 512], 3953: [null, 129], 3954: [null, 130], 3955: [[3953, 3954], 512], 3956: [null, 132], 3957: [[3953, 3956], 512], 3958: [[4018, 3968], 512], 3959: [[4018, 3969], 256], 3960: [[4019, 3968], 512], 3961: [[4019, 3969], 256], 3962: [null, 130], 3963: [null, 130], 3964: [null, 130], 3965: [null, 130], 3968: [null, 130], 3969: [[3953, 3968], 512], 3970: [null, 230], 3971: [null, 230], 3972: [null, 9], 3974: [null, 230], 3975: [null, 230], 3987: [[3986, 4023], 512], 3997: [[3996, 4023], 512], 4002: [[4001, 4023], 512], 4007: [[4006, 4023], 512], 4012: [[4011, 4023], 512], 4025: [[3984, 4021], 512], 4038: [null, 220] },
  4096: { 4133: [null, null, { 4142: 4134 }], 4134: [[4133, 4142]], 4151: [null, 7], 4153: [null, 9], 4154: [null, 9], 4237: [null, 220], 4348: [[4316], 256], 69702: [null, 9], 69759: [null, 9], 69785: [null, null, { 69818: 69786 }], 69786: [[69785, 69818]], 69787: [null, null, { 69818: 69788 }], 69788: [[69787, 69818]], 69797: [null, null, { 69818: 69803 }], 69803: [[69797, 69818]], 69817: [null, 9], 69818: [null, 7] },
  4352: { 69888: [null, 230], 69889: [null, 230], 69890: [null, 230], 69934: [[69937, 69927]], 69935: [[69938, 69927]], 69937: [null, null, { 69927: 69934 }], 69938: [null, null, { 69927: 69935 }], 69939: [null, 9], 69940: [null, 9], 70003: [null, 7], 70080: [null, 9] },
  4608: { 70197: [null, 9], 70198: [null, 7], 70377: [null, 7], 70378: [null, 9] },
  4864: { 4957: [null, 230], 4958: [null, 230], 4959: [null, 230], 70460: [null, 7], 70471: [null, null, { 70462: 70475, 70487: 70476 }], 70475: [[70471, 70462]], 70476: [[70471, 70487]], 70477: [null, 9], 70502: [null, 230], 70503: [null, 230], 70504: [null, 230], 70505: [null, 230], 70506: [null, 230], 70507: [null, 230], 70508: [null, 230], 70512: [null, 230], 70513: [null, 230], 70514: [null, 230], 70515: [null, 230], 70516: [null, 230] },
  5120: { 70841: [null, null, { 70832: 70844, 70842: 70843, 70845: 70846 }], 70843: [[70841, 70842]], 70844: [[70841, 70832]], 70846: [[70841, 70845]], 70850: [null, 9], 70851: [null, 7] },
  5376: { 71096: [null, null, { 71087: 71098 }], 71097: [null, null, { 71087: 71099 }], 71098: [[71096, 71087]], 71099: [[71097, 71087]], 71103: [null, 9], 71104: [null, 7] },
  5632: { 71231: [null, 9], 71350: [null, 9], 71351: [null, 7] },
  5888: { 5908: [null, 9], 5940: [null, 9], 6098: [null, 9], 6109: [null, 230] },
  6144: { 6313: [null, 228] },
  6400: { 6457: [null, 222], 6458: [null, 230], 6459: [null, 220] },
  6656: { 6679: [null, 230], 6680: [null, 220], 6752: [null, 9], 6773: [null, 230], 6774: [null, 230], 6775: [null, 230], 6776: [null, 230], 6777: [null, 230], 6778: [null, 230], 6779: [null, 230], 6780: [null, 230], 6783: [null, 220], 6832: [null, 230], 6833: [null, 230], 6834: [null, 230], 6835: [null, 230], 6836: [null, 230], 6837: [null, 220], 6838: [null, 220], 6839: [null, 220], 6840: [null, 220], 6841: [null, 220], 6842: [null, 220], 6843: [null, 230], 6844: [null, 230], 6845: [null, 220] },
  6912: { 6917: [null, null, { 6965: 6918 }], 6918: [[6917, 6965]], 6919: [null, null, { 6965: 6920 }], 6920: [[6919, 6965]], 6921: [null, null, { 6965: 6922 }], 6922: [[6921, 6965]], 6923: [null, null, { 6965: 6924 }], 6924: [[6923, 6965]], 6925: [null, null, { 6965: 6926 }], 6926: [[6925, 6965]], 6929: [null, null, { 6965: 6930 }], 6930: [[6929, 6965]], 6964: [null, 7], 6970: [null, null, { 6965: 6971 }], 6971: [[6970, 6965]], 6972: [null, null, { 6965: 6973 }], 6973: [[6972, 6965]], 6974: [null, null, { 6965: 6976 }], 6975: [null, null, { 6965: 6977 }], 6976: [[6974, 6965]], 6977: [[6975, 6965]], 6978: [null, null, { 6965: 6979 }], 6979: [[6978, 6965]], 6980: [null, 9], 7019: [null, 230], 7020: [null, 220], 7021: [null, 230], 7022: [null, 230], 7023: [null, 230], 7024: [null, 230], 7025: [null, 230], 7026: [null, 230], 7027: [null, 230], 7082: [null, 9], 7083: [null, 9], 7142: [null, 7], 7154: [null, 9], 7155: [null, 9] },
  7168: { 7223: [null, 7], 7376: [null, 230], 7377: [null, 230], 7378: [null, 230], 7380: [null, 1], 7381: [null, 220], 7382: [null, 220], 7383: [null, 220], 7384: [null, 220], 7385: [null, 220], 7386: [null, 230], 7387: [null, 230], 7388: [null, 220], 7389: [null, 220], 7390: [null, 220], 7391: [null, 220], 7392: [null, 230], 7394: [null, 1], 7395: [null, 1], 7396: [null, 1], 7397: [null, 1], 7398: [null, 1], 7399: [null, 1], 7400: [null, 1], 7405: [null, 220], 7412: [null, 230], 7416: [null, 230], 7417: [null, 230] },
  7424: { 7468: [[65], 256], 7469: [[198], 256], 7470: [[66], 256], 7472: [[68], 256], 7473: [[69], 256], 7474: [[398], 256], 7475: [[71], 256], 7476: [[72], 256], 7477: [[73], 256], 7478: [[74], 256], 7479: [[75], 256], 7480: [[76], 256], 7481: [[77], 256], 7482: [[78], 256], 7484: [[79], 256], 7485: [[546], 256], 7486: [[80], 256], 7487: [[82], 256], 7488: [[84], 256], 7489: [[85], 256], 7490: [[87], 256], 7491: [[97], 256], 7492: [[592], 256], 7493: [[593], 256], 7494: [[7426], 256], 7495: [[98], 256], 7496: [[100], 256], 7497: [[101], 256], 7498: [[601], 256], 7499: [[603], 256], 7500: [[604], 256], 7501: [[103], 256], 7503: [[107], 256], 7504: [[109], 256], 7505: [[331], 256], 7506: [[111], 256], 7507: [[596], 256], 7508: [[7446], 256], 7509: [[7447], 256], 7510: [[112], 256], 7511: [[116], 256], 7512: [[117], 256], 7513: [[7453], 256], 7514: [[623], 256], 7515: [[118], 256], 7516: [[7461], 256], 7517: [[946], 256], 7518: [[947], 256], 7519: [[948], 256], 7520: [[966], 256], 7521: [[967], 256], 7522: [[105], 256], 7523: [[114], 256], 7524: [[117], 256], 7525: [[118], 256], 7526: [[946], 256], 7527: [[947], 256], 7528: [[961], 256], 7529: [[966], 256], 7530: [[967], 256], 7544: [[1085], 256], 7579: [[594], 256], 7580: [[99], 256], 7581: [[597], 256], 7582: [[240], 256], 7583: [[604], 256], 7584: [[102], 256], 7585: [[607], 256], 7586: [[609], 256], 7587: [[613], 256], 7588: [[616], 256], 7589: [[617], 256], 7590: [[618], 256], 7591: [[7547], 256], 7592: [[669], 256], 7593: [[621], 256], 7594: [[7557], 256], 7595: [[671], 256], 7596: [[625], 256], 7597: [[624], 256], 7598: [[626], 256], 7599: [[627], 256], 7600: [[628], 256], 7601: [[629], 256], 7602: [[632], 256], 7603: [[642], 256], 7604: [[643], 256], 7605: [[427], 256], 7606: [[649], 256], 7607: [[650], 256], 7608: [[7452], 256], 7609: [[651], 256], 7610: [[652], 256], 7611: [[122], 256], 7612: [[656], 256], 7613: [[657], 256], 7614: [[658], 256], 7615: [[952], 256], 7616: [null, 230], 7617: [null, 230], 7618: [null, 220], 7619: [null, 230], 7620: [null, 230], 7621: [null, 230], 7622: [null, 230], 7623: [null, 230], 7624: [null, 230], 7625: [null, 230], 7626: [null, 220], 7627: [null, 230], 7628: [null, 230], 7629: [null, 234], 7630: [null, 214], 7631: [null, 220], 7632: [null, 202], 7633: [null, 230], 7634: [null, 230], 7635: [null, 230], 7636: [null, 230], 7637: [null, 230], 7638: [null, 230], 7639: [null, 230], 7640: [null, 230], 7641: [null, 230], 7642: [null, 230], 7643: [null, 230], 7644: [null, 230], 7645: [null, 230], 7646: [null, 230], 7647: [null, 230], 7648: [null, 230], 7649: [null, 230], 7650: [null, 230], 7651: [null, 230], 7652: [null, 230], 7653: [null, 230], 7654: [null, 230], 7655: [null, 230], 7656: [null, 230], 7657: [null, 230], 7658: [null, 230], 7659: [null, 230], 7660: [null, 230], 7661: [null, 230], 7662: [null, 230], 7663: [null, 230], 7664: [null, 230], 7665: [null, 230], 7666: [null, 230], 7667: [null, 230], 7668: [null, 230], 7669: [null, 230], 7676: [null, 233], 7677: [null, 220], 7678: [null, 230], 7679: [null, 220] },
  7680: { 7680: [[65, 805]], 7681: [[97, 805]], 7682: [[66, 775]], 7683: [[98, 775]], 7684: [[66, 803]], 7685: [[98, 803]], 7686: [[66, 817]], 7687: [[98, 817]], 7688: [[199, 769]], 7689: [[231, 769]], 7690: [[68, 775]], 7691: [[100, 775]], 7692: [[68, 803]], 7693: [[100, 803]], 7694: [[68, 817]], 7695: [[100, 817]], 7696: [[68, 807]], 7697: [[100, 807]], 7698: [[68, 813]], 7699: [[100, 813]], 7700: [[274, 768]], 7701: [[275, 768]], 7702: [[274, 769]], 7703: [[275, 769]], 7704: [[69, 813]], 7705: [[101, 813]], 7706: [[69, 816]], 7707: [[101, 816]], 7708: [[552, 774]], 7709: [[553, 774]], 7710: [[70, 775]], 7711: [[102, 775]], 7712: [[71, 772]], 7713: [[103, 772]], 7714: [[72, 775]], 7715: [[104, 775]], 7716: [[72, 803]], 7717: [[104, 803]], 7718: [[72, 776]], 7719: [[104, 776]], 7720: [[72, 807]], 7721: [[104, 807]], 7722: [[72, 814]], 7723: [[104, 814]], 7724: [[73, 816]], 7725: [[105, 816]], 7726: [[207, 769]], 7727: [[239, 769]], 7728: [[75, 769]], 7729: [[107, 769]], 7730: [[75, 803]], 7731: [[107, 803]], 7732: [[75, 817]], 7733: [[107, 817]], 7734: [[76, 803], null, { 772: 7736 }], 7735: [[108, 803], null, { 772: 7737 }], 7736: [[7734, 772]], 7737: [[7735, 772]], 7738: [[76, 817]], 7739: [[108, 817]], 7740: [[76, 813]], 7741: [[108, 813]], 7742: [[77, 769]], 7743: [[109, 769]], 7744: [[77, 775]], 7745: [[109, 775]], 7746: [[77, 803]], 7747: [[109, 803]], 7748: [[78, 775]], 7749: [[110, 775]], 7750: [[78, 803]], 7751: [[110, 803]], 7752: [[78, 817]], 7753: [[110, 817]], 7754: [[78, 813]], 7755: [[110, 813]], 7756: [[213, 769]], 7757: [[245, 769]], 7758: [[213, 776]], 7759: [[245, 776]], 7760: [[332, 768]], 7761: [[333, 768]], 7762: [[332, 769]], 7763: [[333, 769]], 7764: [[80, 769]], 7765: [[112, 769]], 7766: [[80, 775]], 7767: [[112, 775]], 7768: [[82, 775]], 7769: [[114, 775]], 7770: [[82, 803], null, { 772: 7772 }], 7771: [[114, 803], null, { 772: 7773 }], 7772: [[7770, 772]], 7773: [[7771, 772]], 7774: [[82, 817]], 7775: [[114, 817]], 7776: [[83, 775]], 7777: [[115, 775]], 7778: [[83, 803], null, { 775: 7784 }], 7779: [[115, 803], null, { 775: 7785 }], 7780: [[346, 775]], 7781: [[347, 775]], 7782: [[352, 775]], 7783: [[353, 775]], 7784: [[7778, 775]], 7785: [[7779, 775]], 7786: [[84, 775]], 7787: [[116, 775]], 7788: [[84, 803]], 7789: [[116, 803]], 7790: [[84, 817]], 7791: [[116, 817]], 7792: [[84, 813]], 7793: [[116, 813]], 7794: [[85, 804]], 7795: [[117, 804]], 7796: [[85, 816]], 7797: [[117, 816]], 7798: [[85, 813]], 7799: [[117, 813]], 7800: [[360, 769]], 7801: [[361, 769]], 7802: [[362, 776]], 7803: [[363, 776]], 7804: [[86, 771]], 7805: [[118, 771]], 7806: [[86, 803]], 7807: [[118, 803]], 7808: [[87, 768]], 7809: [[119, 768]], 7810: [[87, 769]], 7811: [[119, 769]], 7812: [[87, 776]], 7813: [[119, 776]], 7814: [[87, 775]], 7815: [[119, 775]], 7816: [[87, 803]], 7817: [[119, 803]], 7818: [[88, 775]], 7819: [[120, 775]], 7820: [[88, 776]], 7821: [[120, 776]], 7822: [[89, 775]], 7823: [[121, 775]], 7824: [[90, 770]], 7825: [[122, 770]], 7826: [[90, 803]], 7827: [[122, 803]], 7828: [[90, 817]], 7829: [[122, 817]], 7830: [[104, 817]], 7831: [[116, 776]], 7832: [[119, 778]], 7833: [[121, 778]], 7834: [[97, 702], 256], 7835: [[383, 775]], 7840: [[65, 803], null, { 770: 7852, 774: 7862 }], 7841: [[97, 803], null, { 770: 7853, 774: 7863 }], 7842: [[65, 777]], 7843: [[97, 777]], 7844: [[194, 769]], 7845: [[226, 769]], 7846: [[194, 768]], 7847: [[226, 768]], 7848: [[194, 777]], 7849: [[226, 777]], 7850: [[194, 771]], 7851: [[226, 771]], 7852: [[7840, 770]], 7853: [[7841, 770]], 7854: [[258, 769]], 7855: [[259, 769]], 7856: [[258, 768]], 7857: [[259, 768]], 7858: [[258, 777]], 7859: [[259, 777]], 7860: [[258, 771]], 7861: [[259, 771]], 7862: [[7840, 774]], 7863: [[7841, 774]], 7864: [[69, 803], null, { 770: 7878 }], 7865: [[101, 803], null, { 770: 7879 }], 7866: [[69, 777]], 7867: [[101, 777]], 7868: [[69, 771]], 7869: [[101, 771]], 7870: [[202, 769]], 7871: [[234, 769]], 7872: [[202, 768]], 7873: [[234, 768]], 7874: [[202, 777]], 7875: [[234, 777]], 7876: [[202, 771]], 7877: [[234, 771]], 7878: [[7864, 770]], 7879: [[7865, 770]], 7880: [[73, 777]], 7881: [[105, 777]], 7882: [[73, 803]], 7883: [[105, 803]], 7884: [[79, 803], null, { 770: 7896 }], 7885: [[111, 803], null, { 770: 7897 }], 7886: [[79, 777]], 7887: [[111, 777]], 7888: [[212, 769]], 7889: [[244, 769]], 7890: [[212, 768]], 7891: [[244, 768]], 7892: [[212, 777]], 7893: [[244, 777]], 7894: [[212, 771]], 7895: [[244, 771]], 7896: [[7884, 770]], 7897: [[7885, 770]], 7898: [[416, 769]], 7899: [[417, 769]], 7900: [[416, 768]], 7901: [[417, 768]], 7902: [[416, 777]], 7903: [[417, 777]], 7904: [[416, 771]], 7905: [[417, 771]], 7906: [[416, 803]], 7907: [[417, 803]], 7908: [[85, 803]], 7909: [[117, 803]], 7910: [[85, 777]], 7911: [[117, 777]], 7912: [[431, 769]], 7913: [[432, 769]], 7914: [[431, 768]], 7915: [[432, 768]], 7916: [[431, 777]], 7917: [[432, 777]], 7918: [[431, 771]], 7919: [[432, 771]], 7920: [[431, 803]], 7921: [[432, 803]], 7922: [[89, 768]], 7923: [[121, 768]], 7924: [[89, 803]], 7925: [[121, 803]], 7926: [[89, 777]], 7927: [[121, 777]], 7928: [[89, 771]], 7929: [[121, 771]] },
  7936: { 7936: [[945, 787], null, { 768: 7938, 769: 7940, 834: 7942, 837: 8064 }], 7937: [[945, 788], null, { 768: 7939, 769: 7941, 834: 7943, 837: 8065 }], 7938: [[7936, 768], null, { 837: 8066 }], 7939: [[7937, 768], null, { 837: 8067 }], 7940: [[7936, 769], null, { 837: 8068 }], 7941: [[7937, 769], null, { 837: 8069 }], 7942: [[7936, 834], null, { 837: 8070 }], 7943: [[7937, 834], null, { 837: 8071 }], 7944: [[913, 787], null, { 768: 7946, 769: 7948, 834: 7950, 837: 8072 }], 7945: [[913, 788], null, { 768: 7947, 769: 7949, 834: 7951, 837: 8073 }], 7946: [[7944, 768], null, { 837: 8074 }], 7947: [[7945, 768], null, { 837: 8075 }], 7948: [[7944, 769], null, { 837: 8076 }], 7949: [[7945, 769], null, { 837: 8077 }], 7950: [[7944, 834], null, { 837: 8078 }], 7951: [[7945, 834], null, { 837: 8079 }], 7952: [[949, 787], null, { 768: 7954, 769: 7956 }], 7953: [[949, 788], null, { 768: 7955, 769: 7957 }], 7954: [[7952, 768]], 7955: [[7953, 768]], 7956: [[7952, 769]], 7957: [[7953, 769]], 7960: [[917, 787], null, { 768: 7962, 769: 7964 }], 7961: [[917, 788], null, { 768: 7963, 769: 7965 }], 7962: [[7960, 768]], 7963: [[7961, 768]], 7964: [[7960, 769]], 7965: [[7961, 769]], 7968: [[951, 787], null, { 768: 7970, 769: 7972, 834: 7974, 837: 8080 }], 7969: [[951, 788], null, { 768: 7971, 769: 7973, 834: 7975, 837: 8081 }], 7970: [[7968, 768], null, { 837: 8082 }], 7971: [[7969, 768], null, { 837: 8083 }], 7972: [[7968, 769], null, { 837: 8084 }], 7973: [[7969, 769], null, { 837: 8085 }], 7974: [[7968, 834], null, { 837: 8086 }], 7975: [[7969, 834], null, { 837: 8087 }], 7976: [[919, 787], null, { 768: 7978, 769: 7980, 834: 7982, 837: 8088 }], 7977: [[919, 788], null, { 768: 7979, 769: 7981, 834: 7983, 837: 8089 }], 7978: [[7976, 768], null, { 837: 8090 }], 7979: [[7977, 768], null, { 837: 8091 }], 7980: [[7976, 769], null, { 837: 8092 }], 7981: [[7977, 769], null, { 837: 8093 }], 7982: [[7976, 834], null, { 837: 8094 }], 7983: [[7977, 834], null, { 837: 8095 }], 7984: [[953, 787], null, { 768: 7986, 769: 7988, 834: 7990 }], 7985: [[953, 788], null, { 768: 7987, 769: 7989, 834: 7991 }], 7986: [[7984, 768]], 7987: [[7985, 768]], 7988: [[7984, 769]], 7989: [[7985, 769]], 7990: [[7984, 834]], 7991: [[7985, 834]], 7992: [[921, 787], null, { 768: 7994, 769: 7996, 834: 7998 }], 7993: [[921, 788], null, { 768: 7995, 769: 7997, 834: 7999 }], 7994: [[7992, 768]], 7995: [[7993, 768]], 7996: [[7992, 769]], 7997: [[7993, 769]], 7998: [[7992, 834]], 7999: [[7993, 834]], 8e3: [[959, 787], null, { 768: 8002, 769: 8004 }], 8001: [[959, 788], null, { 768: 8003, 769: 8005 }], 8002: [[8e3, 768]], 8003: [[8001, 768]], 8004: [[8e3, 769]], 8005: [[8001, 769]], 8008: [[927, 787], null, { 768: 8010, 769: 8012 }], 8009: [[927, 788], null, { 768: 8011, 769: 8013 }], 8010: [[8008, 768]], 8011: [[8009, 768]], 8012: [[8008, 769]], 8013: [[8009, 769]], 8016: [[965, 787], null, { 768: 8018, 769: 8020, 834: 8022 }], 8017: [[965, 788], null, { 768: 8019, 769: 8021, 834: 8023 }], 8018: [[8016, 768]], 8019: [[8017, 768]], 8020: [[8016, 769]], 8021: [[8017, 769]], 8022: [[8016, 834]], 8023: [[8017, 834]], 8025: [[933, 788], null, { 768: 8027, 769: 8029, 834: 8031 }], 8027: [[8025, 768]], 8029: [[8025, 769]], 8031: [[8025, 834]], 8032: [[969, 787], null, { 768: 8034, 769: 8036, 834: 8038, 837: 8096 }], 8033: [[969, 788], null, { 768: 8035, 769: 8037, 834: 8039, 837: 8097 }], 8034: [[8032, 768], null, { 837: 8098 }], 8035: [[8033, 768], null, { 837: 8099 }], 8036: [[8032, 769], null, { 837: 8100 }], 8037: [[8033, 769], null, { 837: 8101 }], 8038: [[8032, 834], null, { 837: 8102 }], 8039: [[8033, 834], null, { 837: 8103 }], 8040: [[937, 787], null, { 768: 8042, 769: 8044, 834: 8046, 837: 8104 }], 8041: [[937, 788], null, { 768: 8043, 769: 8045, 834: 8047, 837: 8105 }], 8042: [[8040, 768], null, { 837: 8106 }], 8043: [[8041, 768], null, { 837: 8107 }], 8044: [[8040, 769], null, { 837: 8108 }], 8045: [[8041, 769], null, { 837: 8109 }], 8046: [[8040, 834], null, { 837: 8110 }], 8047: [[8041, 834], null, { 837: 8111 }], 8048: [[945, 768], null, { 837: 8114 }], 8049: [[940]], 8050: [[949, 768]], 8051: [[941]], 8052: [[951, 768], null, { 837: 8130 }], 8053: [[942]], 8054: [[953, 768]], 8055: [[943]], 8056: [[959, 768]], 8057: [[972]], 8058: [[965, 768]], 8059: [[973]], 8060: [[969, 768], null, { 837: 8178 }], 8061: [[974]], 8064: [[7936, 837]], 8065: [[7937, 837]], 8066: [[7938, 837]], 8067: [[7939, 837]], 8068: [[7940, 837]], 8069: [[7941, 837]], 8070: [[7942, 837]], 8071: [[7943, 837]], 8072: [[7944, 837]], 8073: [[7945, 837]], 8074: [[7946, 837]], 8075: [[7947, 837]], 8076: [[7948, 837]], 8077: [[7949, 837]], 8078: [[7950, 837]], 8079: [[7951, 837]], 8080: [[7968, 837]], 8081: [[7969, 837]], 8082: [[7970, 837]], 8083: [[7971, 837]], 8084: [[7972, 837]], 8085: [[7973, 837]], 8086: [[7974, 837]], 8087: [[7975, 837]], 8088: [[7976, 837]], 8089: [[7977, 837]], 8090: [[7978, 837]], 8091: [[7979, 837]], 8092: [[7980, 837]], 8093: [[7981, 837]], 8094: [[7982, 837]], 8095: [[7983, 837]], 8096: [[8032, 837]], 8097: [[8033, 837]], 8098: [[8034, 837]], 8099: [[8035, 837]], 8100: [[8036, 837]], 8101: [[8037, 837]], 8102: [[8038, 837]], 8103: [[8039, 837]], 8104: [[8040, 837]], 8105: [[8041, 837]], 8106: [[8042, 837]], 8107: [[8043, 837]], 8108: [[8044, 837]], 8109: [[8045, 837]], 8110: [[8046, 837]], 8111: [[8047, 837]], 8112: [[945, 774]], 8113: [[945, 772]], 8114: [[8048, 837]], 8115: [[945, 837]], 8116: [[940, 837]], 8118: [[945, 834], null, { 837: 8119 }], 8119: [[8118, 837]], 8120: [[913, 774]], 8121: [[913, 772]], 8122: [[913, 768]], 8123: [[902]], 8124: [[913, 837]], 8125: [[32, 787], 256], 8126: [[953]], 8127: [[32, 787], 256, { 768: 8141, 769: 8142, 834: 8143 }], 8128: [[32, 834], 256], 8129: [[168, 834]], 8130: [[8052, 837]], 8131: [[951, 837]], 8132: [[942, 837]], 8134: [[951, 834], null, { 837: 8135 }], 8135: [[8134, 837]], 8136: [[917, 768]], 8137: [[904]], 8138: [[919, 768]], 8139: [[905]], 8140: [[919, 837]], 8141: [[8127, 768]], 8142: [[8127, 769]], 8143: [[8127, 834]], 8144: [[953, 774]], 8145: [[953, 772]], 8146: [[970, 768]], 8147: [[912]], 8150: [[953, 834]], 8151: [[970, 834]], 8152: [[921, 774]], 8153: [[921, 772]], 8154: [[921, 768]], 8155: [[906]], 8157: [[8190, 768]], 8158: [[8190, 769]], 8159: [[8190, 834]], 8160: [[965, 774]], 8161: [[965, 772]], 8162: [[971, 768]], 8163: [[944]], 8164: [[961, 787]], 8165: [[961, 788]], 8166: [[965, 834]], 8167: [[971, 834]], 8168: [[933, 774]], 8169: [[933, 772]], 8170: [[933, 768]], 8171: [[910]], 8172: [[929, 788]], 8173: [[168, 768]], 8174: [[901]], 8175: [[96]], 8178: [[8060, 837]], 8179: [[969, 837]], 8180: [[974, 837]], 8182: [[969, 834], null, { 837: 8183 }], 8183: [[8182, 837]], 8184: [[927, 768]], 8185: [[908]], 8186: [[937, 768]], 8187: [[911]], 8188: [[937, 837]], 8189: [[180]], 8190: [[32, 788], 256, { 768: 8157, 769: 8158, 834: 8159 }] },
  8192: { 8192: [[8194]], 8193: [[8195]], 8194: [[32], 256], 8195: [[32], 256], 8196: [[32], 256], 8197: [[32], 256], 8198: [[32], 256], 8199: [[32], 256], 8200: [[32], 256], 8201: [[32], 256], 8202: [[32], 256], 8209: [[8208], 256], 8215: [[32, 819], 256], 8228: [[46], 256], 8229: [[46, 46], 256], 8230: [[46, 46, 46], 256], 8239: [[32], 256], 8243: [[8242, 8242], 256], 8244: [[8242, 8242, 8242], 256], 8246: [[8245, 8245], 256], 8247: [[8245, 8245, 8245], 256], 8252: [[33, 33], 256], 8254: [[32, 773], 256], 8263: [[63, 63], 256], 8264: [[63, 33], 256], 8265: [[33, 63], 256], 8279: [[8242, 8242, 8242, 8242], 256], 8287: [[32], 256], 8304: [[48], 256], 8305: [[105], 256], 8308: [[52], 256], 8309: [[53], 256], 8310: [[54], 256], 8311: [[55], 256], 8312: [[56], 256], 8313: [[57], 256], 8314: [[43], 256], 8315: [[8722], 256], 8316: [[61], 256], 8317: [[40], 256], 8318: [[41], 256], 8319: [[110], 256], 8320: [[48], 256], 8321: [[49], 256], 8322: [[50], 256], 8323: [[51], 256], 8324: [[52], 256], 8325: [[53], 256], 8326: [[54], 256], 8327: [[55], 256], 8328: [[56], 256], 8329: [[57], 256], 8330: [[43], 256], 8331: [[8722], 256], 8332: [[61], 256], 8333: [[40], 256], 8334: [[41], 256], 8336: [[97], 256], 8337: [[101], 256], 8338: [[111], 256], 8339: [[120], 256], 8340: [[601], 256], 8341: [[104], 256], 8342: [[107], 256], 8343: [[108], 256], 8344: [[109], 256], 8345: [[110], 256], 8346: [[112], 256], 8347: [[115], 256], 8348: [[116], 256], 8360: [[82, 115], 256], 8400: [null, 230], 8401: [null, 230], 8402: [null, 1], 8403: [null, 1], 8404: [null, 230], 8405: [null, 230], 8406: [null, 230], 8407: [null, 230], 8408: [null, 1], 8409: [null, 1], 8410: [null, 1], 8411: [null, 230], 8412: [null, 230], 8417: [null, 230], 8421: [null, 1], 8422: [null, 1], 8423: [null, 230], 8424: [null, 220], 8425: [null, 230], 8426: [null, 1], 8427: [null, 1], 8428: [null, 220], 8429: [null, 220], 8430: [null, 220], 8431: [null, 220], 8432: [null, 230] },
  8448: { 8448: [[97, 47, 99], 256], 8449: [[97, 47, 115], 256], 8450: [[67], 256], 8451: [[176, 67], 256], 8453: [[99, 47, 111], 256], 8454: [[99, 47, 117], 256], 8455: [[400], 256], 8457: [[176, 70], 256], 8458: [[103], 256], 8459: [[72], 256], 8460: [[72], 256], 8461: [[72], 256], 8462: [[104], 256], 8463: [[295], 256], 8464: [[73], 256], 8465: [[73], 256], 8466: [[76], 256], 8467: [[108], 256], 8469: [[78], 256], 8470: [[78, 111], 256], 8473: [[80], 256], 8474: [[81], 256], 8475: [[82], 256], 8476: [[82], 256], 8477: [[82], 256], 8480: [[83, 77], 256], 8481: [[84, 69, 76], 256], 8482: [[84, 77], 256], 8484: [[90], 256], 8486: [[937]], 8488: [[90], 256], 8490: [[75]], 8491: [[197]], 8492: [[66], 256], 8493: [[67], 256], 8495: [[101], 256], 8496: [[69], 256], 8497: [[70], 256], 8499: [[77], 256], 8500: [[111], 256], 8501: [[1488], 256], 8502: [[1489], 256], 8503: [[1490], 256], 8504: [[1491], 256], 8505: [[105], 256], 8507: [[70, 65, 88], 256], 8508: [[960], 256], 8509: [[947], 256], 8510: [[915], 256], 8511: [[928], 256], 8512: [[8721], 256], 8517: [[68], 256], 8518: [[100], 256], 8519: [[101], 256], 8520: [[105], 256], 8521: [[106], 256], 8528: [[49, 8260, 55], 256], 8529: [[49, 8260, 57], 256], 8530: [[49, 8260, 49, 48], 256], 8531: [[49, 8260, 51], 256], 8532: [[50, 8260, 51], 256], 8533: [[49, 8260, 53], 256], 8534: [[50, 8260, 53], 256], 8535: [[51, 8260, 53], 256], 8536: [[52, 8260, 53], 256], 8537: [[49, 8260, 54], 256], 8538: [[53, 8260, 54], 256], 8539: [[49, 8260, 56], 256], 8540: [[51, 8260, 56], 256], 8541: [[53, 8260, 56], 256], 8542: [[55, 8260, 56], 256], 8543: [[49, 8260], 256], 8544: [[73], 256], 8545: [[73, 73], 256], 8546: [[73, 73, 73], 256], 8547: [[73, 86], 256], 8548: [[86], 256], 8549: [[86, 73], 256], 8550: [[86, 73, 73], 256], 8551: [[86, 73, 73, 73], 256], 8552: [[73, 88], 256], 8553: [[88], 256], 8554: [[88, 73], 256], 8555: [[88, 73, 73], 256], 8556: [[76], 256], 8557: [[67], 256], 8558: [[68], 256], 8559: [[77], 256], 8560: [[105], 256], 8561: [[105, 105], 256], 8562: [[105, 105, 105], 256], 8563: [[105, 118], 256], 8564: [[118], 256], 8565: [[118, 105], 256], 8566: [[118, 105, 105], 256], 8567: [[118, 105, 105, 105], 256], 8568: [[105, 120], 256], 8569: [[120], 256], 8570: [[120, 105], 256], 8571: [[120, 105, 105], 256], 8572: [[108], 256], 8573: [[99], 256], 8574: [[100], 256], 8575: [[109], 256], 8585: [[48, 8260, 51], 256], 8592: [null, null, { 824: 8602 }], 8594: [null, null, { 824: 8603 }], 8596: [null, null, { 824: 8622 }], 8602: [[8592, 824]], 8603: [[8594, 824]], 8622: [[8596, 824]], 8653: [[8656, 824]], 8654: [[8660, 824]], 8655: [[8658, 824]], 8656: [null, null, { 824: 8653 }], 8658: [null, null, { 824: 8655 }], 8660: [null, null, { 824: 8654 }] },
  8704: { 8707: [null, null, { 824: 8708 }], 8708: [[8707, 824]], 8712: [null, null, { 824: 8713 }], 8713: [[8712, 824]], 8715: [null, null, { 824: 8716 }], 8716: [[8715, 824]], 8739: [null, null, { 824: 8740 }], 8740: [[8739, 824]], 8741: [null, null, { 824: 8742 }], 8742: [[8741, 824]], 8748: [[8747, 8747], 256], 8749: [[8747, 8747, 8747], 256], 8751: [[8750, 8750], 256], 8752: [[8750, 8750, 8750], 256], 8764: [null, null, { 824: 8769 }], 8769: [[8764, 824]], 8771: [null, null, { 824: 8772 }], 8772: [[8771, 824]], 8773: [null, null, { 824: 8775 }], 8775: [[8773, 824]], 8776: [null, null, { 824: 8777 }], 8777: [[8776, 824]], 8781: [null, null, { 824: 8813 }], 8800: [[61, 824]], 8801: [null, null, { 824: 8802 }], 8802: [[8801, 824]], 8804: [null, null, { 824: 8816 }], 8805: [null, null, { 824: 8817 }], 8813: [[8781, 824]], 8814: [[60, 824]], 8815: [[62, 824]], 8816: [[8804, 824]], 8817: [[8805, 824]], 8818: [null, null, { 824: 8820 }], 8819: [null, null, { 824: 8821 }], 8820: [[8818, 824]], 8821: [[8819, 824]], 8822: [null, null, { 824: 8824 }], 8823: [null, null, { 824: 8825 }], 8824: [[8822, 824]], 8825: [[8823, 824]], 8826: [null, null, { 824: 8832 }], 8827: [null, null, { 824: 8833 }], 8828: [null, null, { 824: 8928 }], 8829: [null, null, { 824: 8929 }], 8832: [[8826, 824]], 8833: [[8827, 824]], 8834: [null, null, { 824: 8836 }], 8835: [null, null, { 824: 8837 }], 8836: [[8834, 824]], 8837: [[8835, 824]], 8838: [null, null, { 824: 8840 }], 8839: [null, null, { 824: 8841 }], 8840: [[8838, 824]], 8841: [[8839, 824]], 8849: [null, null, { 824: 8930 }], 8850: [null, null, { 824: 8931 }], 8866: [null, null, { 824: 8876 }], 8872: [null, null, { 824: 8877 }], 8873: [null, null, { 824: 8878 }], 8875: [null, null, { 824: 8879 }], 8876: [[8866, 824]], 8877: [[8872, 824]], 8878: [[8873, 824]], 8879: [[8875, 824]], 8882: [null, null, { 824: 8938 }], 8883: [null, null, { 824: 8939 }], 8884: [null, null, { 824: 8940 }], 8885: [null, null, { 824: 8941 }], 8928: [[8828, 824]], 8929: [[8829, 824]], 8930: [[8849, 824]], 8931: [[8850, 824]], 8938: [[8882, 824]], 8939: [[8883, 824]], 8940: [[8884, 824]], 8941: [[8885, 824]] },
  8960: { 9001: [[12296]], 9002: [[12297]] },
  9216: { 9312: [[49], 256], 9313: [[50], 256], 9314: [[51], 256], 9315: [[52], 256], 9316: [[53], 256], 9317: [[54], 256], 9318: [[55], 256], 9319: [[56], 256], 9320: [[57], 256], 9321: [[49, 48], 256], 9322: [[49, 49], 256], 9323: [[49, 50], 256], 9324: [[49, 51], 256], 9325: [[49, 52], 256], 9326: [[49, 53], 256], 9327: [[49, 54], 256], 9328: [[49, 55], 256], 9329: [[49, 56], 256], 9330: [[49, 57], 256], 9331: [[50, 48], 256], 9332: [[40, 49, 41], 256], 9333: [[40, 50, 41], 256], 9334: [[40, 51, 41], 256], 9335: [[40, 52, 41], 256], 9336: [[40, 53, 41], 256], 9337: [[40, 54, 41], 256], 9338: [[40, 55, 41], 256], 9339: [[40, 56, 41], 256], 9340: [[40, 57, 41], 256], 9341: [[40, 49, 48, 41], 256], 9342: [[40, 49, 49, 41], 256], 9343: [[40, 49, 50, 41], 256], 9344: [[40, 49, 51, 41], 256], 9345: [[40, 49, 52, 41], 256], 9346: [[40, 49, 53, 41], 256], 9347: [[40, 49, 54, 41], 256], 9348: [[40, 49, 55, 41], 256], 9349: [[40, 49, 56, 41], 256], 9350: [[40, 49, 57, 41], 256], 9351: [[40, 50, 48, 41], 256], 9352: [[49, 46], 256], 9353: [[50, 46], 256], 9354: [[51, 46], 256], 9355: [[52, 46], 256], 9356: [[53, 46], 256], 9357: [[54, 46], 256], 9358: [[55, 46], 256], 9359: [[56, 46], 256], 9360: [[57, 46], 256], 9361: [[49, 48, 46], 256], 9362: [[49, 49, 46], 256], 9363: [[49, 50, 46], 256], 9364: [[49, 51, 46], 256], 9365: [[49, 52, 46], 256], 9366: [[49, 53, 46], 256], 9367: [[49, 54, 46], 256], 9368: [[49, 55, 46], 256], 9369: [[49, 56, 46], 256], 9370: [[49, 57, 46], 256], 9371: [[50, 48, 46], 256], 9372: [[40, 97, 41], 256], 9373: [[40, 98, 41], 256], 9374: [[40, 99, 41], 256], 9375: [[40, 100, 41], 256], 9376: [[40, 101, 41], 256], 9377: [[40, 102, 41], 256], 9378: [[40, 103, 41], 256], 9379: [[40, 104, 41], 256], 9380: [[40, 105, 41], 256], 9381: [[40, 106, 41], 256], 9382: [[40, 107, 41], 256], 9383: [[40, 108, 41], 256], 9384: [[40, 109, 41], 256], 9385: [[40, 110, 41], 256], 9386: [[40, 111, 41], 256], 9387: [[40, 112, 41], 256], 9388: [[40, 113, 41], 256], 9389: [[40, 114, 41], 256], 9390: [[40, 115, 41], 256], 9391: [[40, 116, 41], 256], 9392: [[40, 117, 41], 256], 9393: [[40, 118, 41], 256], 9394: [[40, 119, 41], 256], 9395: [[40, 120, 41], 256], 9396: [[40, 121, 41], 256], 9397: [[40, 122, 41], 256], 9398: [[65], 256], 9399: [[66], 256], 9400: [[67], 256], 9401: [[68], 256], 9402: [[69], 256], 9403: [[70], 256], 9404: [[71], 256], 9405: [[72], 256], 9406: [[73], 256], 9407: [[74], 256], 9408: [[75], 256], 9409: [[76], 256], 9410: [[77], 256], 9411: [[78], 256], 9412: [[79], 256], 9413: [[80], 256], 9414: [[81], 256], 9415: [[82], 256], 9416: [[83], 256], 9417: [[84], 256], 9418: [[85], 256], 9419: [[86], 256], 9420: [[87], 256], 9421: [[88], 256], 9422: [[89], 256], 9423: [[90], 256], 9424: [[97], 256], 9425: [[98], 256], 9426: [[99], 256], 9427: [[100], 256], 9428: [[101], 256], 9429: [[102], 256], 9430: [[103], 256], 9431: [[104], 256], 9432: [[105], 256], 9433: [[106], 256], 9434: [[107], 256], 9435: [[108], 256], 9436: [[109], 256], 9437: [[110], 256], 9438: [[111], 256], 9439: [[112], 256], 9440: [[113], 256], 9441: [[114], 256], 9442: [[115], 256], 9443: [[116], 256], 9444: [[117], 256], 9445: [[118], 256], 9446: [[119], 256], 9447: [[120], 256], 9448: [[121], 256], 9449: [[122], 256], 9450: [[48], 256] },
  10752: { 10764: [[8747, 8747, 8747, 8747], 256], 10868: [[58, 58, 61], 256], 10869: [[61, 61], 256], 10870: [[61, 61, 61], 256], 10972: [[10973, 824], 512] },
  11264: { 11388: [[106], 256], 11389: [[86], 256], 11503: [null, 230], 11504: [null, 230], 11505: [null, 230] },
  11520: { 11631: [[11617], 256], 11647: [null, 9], 11744: [null, 230], 11745: [null, 230], 11746: [null, 230], 11747: [null, 230], 11748: [null, 230], 11749: [null, 230], 11750: [null, 230], 11751: [null, 230], 11752: [null, 230], 11753: [null, 230], 11754: [null, 230], 11755: [null, 230], 11756: [null, 230], 11757: [null, 230], 11758: [null, 230], 11759: [null, 230], 11760: [null, 230], 11761: [null, 230], 11762: [null, 230], 11763: [null, 230], 11764: [null, 230], 11765: [null, 230], 11766: [null, 230], 11767: [null, 230], 11768: [null, 230], 11769: [null, 230], 11770: [null, 230], 11771: [null, 230], 11772: [null, 230], 11773: [null, 230], 11774: [null, 230], 11775: [null, 230] },
  11776: { 11935: [[27597], 256], 12019: [[40863], 256] },
  12032: { 12032: [[19968], 256], 12033: [[20008], 256], 12034: [[20022], 256], 12035: [[20031], 256], 12036: [[20057], 256], 12037: [[20101], 256], 12038: [[20108], 256], 12039: [[20128], 256], 12040: [[20154], 256], 12041: [[20799], 256], 12042: [[20837], 256], 12043: [[20843], 256], 12044: [[20866], 256], 12045: [[20886], 256], 12046: [[20907], 256], 12047: [[20960], 256], 12048: [[20981], 256], 12049: [[20992], 256], 12050: [[21147], 256], 12051: [[21241], 256], 12052: [[21269], 256], 12053: [[21274], 256], 12054: [[21304], 256], 12055: [[21313], 256], 12056: [[21340], 256], 12057: [[21353], 256], 12058: [[21378], 256], 12059: [[21430], 256], 12060: [[21448], 256], 12061: [[21475], 256], 12062: [[22231], 256], 12063: [[22303], 256], 12064: [[22763], 256], 12065: [[22786], 256], 12066: [[22794], 256], 12067: [[22805], 256], 12068: [[22823], 256], 12069: [[22899], 256], 12070: [[23376], 256], 12071: [[23424], 256], 12072: [[23544], 256], 12073: [[23567], 256], 12074: [[23586], 256], 12075: [[23608], 256], 12076: [[23662], 256], 12077: [[23665], 256], 12078: [[24027], 256], 12079: [[24037], 256], 12080: [[24049], 256], 12081: [[24062], 256], 12082: [[24178], 256], 12083: [[24186], 256], 12084: [[24191], 256], 12085: [[24308], 256], 12086: [[24318], 256], 12087: [[24331], 256], 12088: [[24339], 256], 12089: [[24400], 256], 12090: [[24417], 256], 12091: [[24435], 256], 12092: [[24515], 256], 12093: [[25096], 256], 12094: [[25142], 256], 12095: [[25163], 256], 12096: [[25903], 256], 12097: [[25908], 256], 12098: [[25991], 256], 12099: [[26007], 256], 12100: [[26020], 256], 12101: [[26041], 256], 12102: [[26080], 256], 12103: [[26085], 256], 12104: [[26352], 256], 12105: [[26376], 256], 12106: [[26408], 256], 12107: [[27424], 256], 12108: [[27490], 256], 12109: [[27513], 256], 12110: [[27571], 256], 12111: [[27595], 256], 12112: [[27604], 256], 12113: [[27611], 256], 12114: [[27663], 256], 12115: [[27668], 256], 12116: [[27700], 256], 12117: [[28779], 256], 12118: [[29226], 256], 12119: [[29238], 256], 12120: [[29243], 256], 12121: [[29247], 256], 12122: [[29255], 256], 12123: [[29273], 256], 12124: [[29275], 256], 12125: [[29356], 256], 12126: [[29572], 256], 12127: [[29577], 256], 12128: [[29916], 256], 12129: [[29926], 256], 12130: [[29976], 256], 12131: [[29983], 256], 12132: [[29992], 256], 12133: [[3e4], 256], 12134: [[30091], 256], 12135: [[30098], 256], 12136: [[30326], 256], 12137: [[30333], 256], 12138: [[30382], 256], 12139: [[30399], 256], 12140: [[30446], 256], 12141: [[30683], 256], 12142: [[30690], 256], 12143: [[30707], 256], 12144: [[31034], 256], 12145: [[31160], 256], 12146: [[31166], 256], 12147: [[31348], 256], 12148: [[31435], 256], 12149: [[31481], 256], 12150: [[31859], 256], 12151: [[31992], 256], 12152: [[32566], 256], 12153: [[32593], 256], 12154: [[32650], 256], 12155: [[32701], 256], 12156: [[32769], 256], 12157: [[32780], 256], 12158: [[32786], 256], 12159: [[32819], 256], 12160: [[32895], 256], 12161: [[32905], 256], 12162: [[33251], 256], 12163: [[33258], 256], 12164: [[33267], 256], 12165: [[33276], 256], 12166: [[33292], 256], 12167: [[33307], 256], 12168: [[33311], 256], 12169: [[33390], 256], 12170: [[33394], 256], 12171: [[33400], 256], 12172: [[34381], 256], 12173: [[34411], 256], 12174: [[34880], 256], 12175: [[34892], 256], 12176: [[34915], 256], 12177: [[35198], 256], 12178: [[35211], 256], 12179: [[35282], 256], 12180: [[35328], 256], 12181: [[35895], 256], 12182: [[35910], 256], 12183: [[35925], 256], 12184: [[35960], 256], 12185: [[35997], 256], 12186: [[36196], 256], 12187: [[36208], 256], 12188: [[36275], 256], 12189: [[36523], 256], 12190: [[36554], 256], 12191: [[36763], 256], 12192: [[36784], 256], 12193: [[36789], 256], 12194: [[37009], 256], 12195: [[37193], 256], 12196: [[37318], 256], 12197: [[37324], 256], 12198: [[37329], 256], 12199: [[38263], 256], 12200: [[38272], 256], 12201: [[38428], 256], 12202: [[38582], 256], 12203: [[38585], 256], 12204: [[38632], 256], 12205: [[38737], 256], 12206: [[38750], 256], 12207: [[38754], 256], 12208: [[38761], 256], 12209: [[38859], 256], 12210: [[38893], 256], 12211: [[38899], 256], 12212: [[38913], 256], 12213: [[39080], 256], 12214: [[39131], 256], 12215: [[39135], 256], 12216: [[39318], 256], 12217: [[39321], 256], 12218: [[39340], 256], 12219: [[39592], 256], 12220: [[39640], 256], 12221: [[39647], 256], 12222: [[39717], 256], 12223: [[39727], 256], 12224: [[39730], 256], 12225: [[39740], 256], 12226: [[39770], 256], 12227: [[40165], 256], 12228: [[40565], 256], 12229: [[40575], 256], 12230: [[40613], 256], 12231: [[40635], 256], 12232: [[40643], 256], 12233: [[40653], 256], 12234: [[40657], 256], 12235: [[40697], 256], 12236: [[40701], 256], 12237: [[40718], 256], 12238: [[40723], 256], 12239: [[40736], 256], 12240: [[40763], 256], 12241: [[40778], 256], 12242: [[40786], 256], 12243: [[40845], 256], 12244: [[40860], 256], 12245: [[40864], 256] },
  12288: { 12288: [[32], 256], 12330: [null, 218], 12331: [null, 228], 12332: [null, 232], 12333: [null, 222], 12334: [null, 224], 12335: [null, 224], 12342: [[12306], 256], 12344: [[21313], 256], 12345: [[21316], 256], 12346: [[21317], 256], 12358: [null, null, { 12441: 12436 }], 12363: [null, null, { 12441: 12364 }], 12364: [[12363, 12441]], 12365: [null, null, { 12441: 12366 }], 12366: [[12365, 12441]], 12367: [null, null, { 12441: 12368 }], 12368: [[12367, 12441]], 12369: [null, null, { 12441: 12370 }], 12370: [[12369, 12441]], 12371: [null, null, { 12441: 12372 }], 12372: [[12371, 12441]], 12373: [null, null, { 12441: 12374 }], 12374: [[12373, 12441]], 12375: [null, null, { 12441: 12376 }], 12376: [[12375, 12441]], 12377: [null, null, { 12441: 12378 }], 12378: [[12377, 12441]], 12379: [null, null, { 12441: 12380 }], 12380: [[12379, 12441]], 12381: [null, null, { 12441: 12382 }], 12382: [[12381, 12441]], 12383: [null, null, { 12441: 12384 }], 12384: [[12383, 12441]], 12385: [null, null, { 12441: 12386 }], 12386: [[12385, 12441]], 12388: [null, null, { 12441: 12389 }], 12389: [[12388, 12441]], 12390: [null, null, { 12441: 12391 }], 12391: [[12390, 12441]], 12392: [null, null, { 12441: 12393 }], 12393: [[12392, 12441]], 12399: [null, null, { 12441: 12400, 12442: 12401 }], 12400: [[12399, 12441]], 12401: [[12399, 12442]], 12402: [null, null, { 12441: 12403, 12442: 12404 }], 12403: [[12402, 12441]], 12404: [[12402, 12442]], 12405: [null, null, { 12441: 12406, 12442: 12407 }], 12406: [[12405, 12441]], 12407: [[12405, 12442]], 12408: [null, null, { 12441: 12409, 12442: 12410 }], 12409: [[12408, 12441]], 12410: [[12408, 12442]], 12411: [null, null, { 12441: 12412, 12442: 12413 }], 12412: [[12411, 12441]], 12413: [[12411, 12442]], 12436: [[12358, 12441]], 12441: [null, 8], 12442: [null, 8], 12443: [[32, 12441], 256], 12444: [[32, 12442], 256], 12445: [null, null, { 12441: 12446 }], 12446: [[12445, 12441]], 12447: [[12424, 12426], 256], 12454: [null, null, { 12441: 12532 }], 12459: [null, null, { 12441: 12460 }], 12460: [[12459, 12441]], 12461: [null, null, { 12441: 12462 }], 12462: [[12461, 12441]], 12463: [null, null, { 12441: 12464 }], 12464: [[12463, 12441]], 12465: [null, null, { 12441: 12466 }], 12466: [[12465, 12441]], 12467: [null, null, { 12441: 12468 }], 12468: [[12467, 12441]], 12469: [null, null, { 12441: 12470 }], 12470: [[12469, 12441]], 12471: [null, null, { 12441: 12472 }], 12472: [[12471, 12441]], 12473: [null, null, { 12441: 12474 }], 12474: [[12473, 12441]], 12475: [null, null, { 12441: 12476 }], 12476: [[12475, 12441]], 12477: [null, null, { 12441: 12478 }], 12478: [[12477, 12441]], 12479: [null, null, { 12441: 12480 }], 12480: [[12479, 12441]], 12481: [null, null, { 12441: 12482 }], 12482: [[12481, 12441]], 12484: [null, null, { 12441: 12485 }], 12485: [[12484, 12441]], 12486: [null, null, { 12441: 12487 }], 12487: [[12486, 12441]], 12488: [null, null, { 12441: 12489 }], 12489: [[12488, 12441]], 12495: [null, null, { 12441: 12496, 12442: 12497 }], 12496: [[12495, 12441]], 12497: [[12495, 12442]], 12498: [null, null, { 12441: 12499, 12442: 12500 }], 12499: [[12498, 12441]], 12500: [[12498, 12442]], 12501: [null, null, { 12441: 12502, 12442: 12503 }], 12502: [[12501, 12441]], 12503: [[12501, 12442]], 12504: [null, null, { 12441: 12505, 12442: 12506 }], 12505: [[12504, 12441]], 12506: [[12504, 12442]], 12507: [null, null, { 12441: 12508, 12442: 12509 }], 12508: [[12507, 12441]], 12509: [[12507, 12442]], 12527: [null, null, { 12441: 12535 }], 12528: [null, null, { 12441: 12536 }], 12529: [null, null, { 12441: 12537 }], 12530: [null, null, { 12441: 12538 }], 12532: [[12454, 12441]], 12535: [[12527, 12441]], 12536: [[12528, 12441]], 12537: [[12529, 12441]], 12538: [[12530, 12441]], 12541: [null, null, { 12441: 12542 }], 12542: [[12541, 12441]], 12543: [[12467, 12488], 256] },
  12544: { 12593: [[4352], 256], 12594: [[4353], 256], 12595: [[4522], 256], 12596: [[4354], 256], 12597: [[4524], 256], 12598: [[4525], 256], 12599: [[4355], 256], 12600: [[4356], 256], 12601: [[4357], 256], 12602: [[4528], 256], 12603: [[4529], 256], 12604: [[4530], 256], 12605: [[4531], 256], 12606: [[4532], 256], 12607: [[4533], 256], 12608: [[4378], 256], 12609: [[4358], 256], 12610: [[4359], 256], 12611: [[4360], 256], 12612: [[4385], 256], 12613: [[4361], 256], 12614: [[4362], 256], 12615: [[4363], 256], 12616: [[4364], 256], 12617: [[4365], 256], 12618: [[4366], 256], 12619: [[4367], 256], 12620: [[4368], 256], 12621: [[4369], 256], 12622: [[4370], 256], 12623: [[4449], 256], 12624: [[4450], 256], 12625: [[4451], 256], 12626: [[4452], 256], 12627: [[4453], 256], 12628: [[4454], 256], 12629: [[4455], 256], 12630: [[4456], 256], 12631: [[4457], 256], 12632: [[4458], 256], 12633: [[4459], 256], 12634: [[4460], 256], 12635: [[4461], 256], 12636: [[4462], 256], 12637: [[4463], 256], 12638: [[4464], 256], 12639: [[4465], 256], 12640: [[4466], 256], 12641: [[4467], 256], 12642: [[4468], 256], 12643: [[4469], 256], 12644: [[4448], 256], 12645: [[4372], 256], 12646: [[4373], 256], 12647: [[4551], 256], 12648: [[4552], 256], 12649: [[4556], 256], 12650: [[4558], 256], 12651: [[4563], 256], 12652: [[4567], 256], 12653: [[4569], 256], 12654: [[4380], 256], 12655: [[4573], 256], 12656: [[4575], 256], 12657: [[4381], 256], 12658: [[4382], 256], 12659: [[4384], 256], 12660: [[4386], 256], 12661: [[4387], 256], 12662: [[4391], 256], 12663: [[4393], 256], 12664: [[4395], 256], 12665: [[4396], 256], 12666: [[4397], 256], 12667: [[4398], 256], 12668: [[4399], 256], 12669: [[4402], 256], 12670: [[4406], 256], 12671: [[4416], 256], 12672: [[4423], 256], 12673: [[4428], 256], 12674: [[4593], 256], 12675: [[4594], 256], 12676: [[4439], 256], 12677: [[4440], 256], 12678: [[4441], 256], 12679: [[4484], 256], 12680: [[4485], 256], 12681: [[4488], 256], 12682: [[4497], 256], 12683: [[4498], 256], 12684: [[4500], 256], 12685: [[4510], 256], 12686: [[4513], 256], 12690: [[19968], 256], 12691: [[20108], 256], 12692: [[19977], 256], 12693: [[22235], 256], 12694: [[19978], 256], 12695: [[20013], 256], 12696: [[19979], 256], 12697: [[30002], 256], 12698: [[20057], 256], 12699: [[19993], 256], 12700: [[19969], 256], 12701: [[22825], 256], 12702: [[22320], 256], 12703: [[20154], 256] },
  12800: { 12800: [[40, 4352, 41], 256], 12801: [[40, 4354, 41], 256], 12802: [[40, 4355, 41], 256], 12803: [[40, 4357, 41], 256], 12804: [[40, 4358, 41], 256], 12805: [[40, 4359, 41], 256], 12806: [[40, 4361, 41], 256], 12807: [[40, 4363, 41], 256], 12808: [[40, 4364, 41], 256], 12809: [[40, 4366, 41], 256], 12810: [[40, 4367, 41], 256], 12811: [[40, 4368, 41], 256], 12812: [[40, 4369, 41], 256], 12813: [[40, 4370, 41], 256], 12814: [[40, 4352, 4449, 41], 256], 12815: [[40, 4354, 4449, 41], 256], 12816: [[40, 4355, 4449, 41], 256], 12817: [[40, 4357, 4449, 41], 256], 12818: [[40, 4358, 4449, 41], 256], 12819: [[40, 4359, 4449, 41], 256], 12820: [[40, 4361, 4449, 41], 256], 12821: [[40, 4363, 4449, 41], 256], 12822: [[40, 4364, 4449, 41], 256], 12823: [[40, 4366, 4449, 41], 256], 12824: [[40, 4367, 4449, 41], 256], 12825: [[40, 4368, 4449, 41], 256], 12826: [[40, 4369, 4449, 41], 256], 12827: [[40, 4370, 4449, 41], 256], 12828: [[40, 4364, 4462, 41], 256], 12829: [[40, 4363, 4457, 4364, 4453, 4523, 41], 256], 12830: [[40, 4363, 4457, 4370, 4462, 41], 256], 12832: [[40, 19968, 41], 256], 12833: [[40, 20108, 41], 256], 12834: [[40, 19977, 41], 256], 12835: [[40, 22235, 41], 256], 12836: [[40, 20116, 41], 256], 12837: [[40, 20845, 41], 256], 12838: [[40, 19971, 41], 256], 12839: [[40, 20843, 41], 256], 12840: [[40, 20061, 41], 256], 12841: [[40, 21313, 41], 256], 12842: [[40, 26376, 41], 256], 12843: [[40, 28779, 41], 256], 12844: [[40, 27700, 41], 256], 12845: [[40, 26408, 41], 256], 12846: [[40, 37329, 41], 256], 12847: [[40, 22303, 41], 256], 12848: [[40, 26085, 41], 256], 12849: [[40, 26666, 41], 256], 12850: [[40, 26377, 41], 256], 12851: [[40, 31038, 41], 256], 12852: [[40, 21517, 41], 256], 12853: [[40, 29305, 41], 256], 12854: [[40, 36001, 41], 256], 12855: [[40, 31069, 41], 256], 12856: [[40, 21172, 41], 256], 12857: [[40, 20195, 41], 256], 12858: [[40, 21628, 41], 256], 12859: [[40, 23398, 41], 256], 12860: [[40, 30435, 41], 256], 12861: [[40, 20225, 41], 256], 12862: [[40, 36039, 41], 256], 12863: [[40, 21332, 41], 256], 12864: [[40, 31085, 41], 256], 12865: [[40, 20241, 41], 256], 12866: [[40, 33258, 41], 256], 12867: [[40, 33267, 41], 256], 12868: [[21839], 256], 12869: [[24188], 256], 12870: [[25991], 256], 12871: [[31631], 256], 12880: [[80, 84, 69], 256], 12881: [[50, 49], 256], 12882: [[50, 50], 256], 12883: [[50, 51], 256], 12884: [[50, 52], 256], 12885: [[50, 53], 256], 12886: [[50, 54], 256], 12887: [[50, 55], 256], 12888: [[50, 56], 256], 12889: [[50, 57], 256], 12890: [[51, 48], 256], 12891: [[51, 49], 256], 12892: [[51, 50], 256], 12893: [[51, 51], 256], 12894: [[51, 52], 256], 12895: [[51, 53], 256], 12896: [[4352], 256], 12897: [[4354], 256], 12898: [[4355], 256], 12899: [[4357], 256], 12900: [[4358], 256], 12901: [[4359], 256], 12902: [[4361], 256], 12903: [[4363], 256], 12904: [[4364], 256], 12905: [[4366], 256], 12906: [[4367], 256], 12907: [[4368], 256], 12908: [[4369], 256], 12909: [[4370], 256], 12910: [[4352, 4449], 256], 12911: [[4354, 4449], 256], 12912: [[4355, 4449], 256], 12913: [[4357, 4449], 256], 12914: [[4358, 4449], 256], 12915: [[4359, 4449], 256], 12916: [[4361, 4449], 256], 12917: [[4363, 4449], 256], 12918: [[4364, 4449], 256], 12919: [[4366, 4449], 256], 12920: [[4367, 4449], 256], 12921: [[4368, 4449], 256], 12922: [[4369, 4449], 256], 12923: [[4370, 4449], 256], 12924: [[4366, 4449, 4535, 4352, 4457], 256], 12925: [[4364, 4462, 4363, 4468], 256], 12926: [[4363, 4462], 256], 12928: [[19968], 256], 12929: [[20108], 256], 12930: [[19977], 256], 12931: [[22235], 256], 12932: [[20116], 256], 12933: [[20845], 256], 12934: [[19971], 256], 12935: [[20843], 256], 12936: [[20061], 256], 12937: [[21313], 256], 12938: [[26376], 256], 12939: [[28779], 256], 12940: [[27700], 256], 12941: [[26408], 256], 12942: [[37329], 256], 12943: [[22303], 256], 12944: [[26085], 256], 12945: [[26666], 256], 12946: [[26377], 256], 12947: [[31038], 256], 12948: [[21517], 256], 12949: [[29305], 256], 12950: [[36001], 256], 12951: [[31069], 256], 12952: [[21172], 256], 12953: [[31192], 256], 12954: [[30007], 256], 12955: [[22899], 256], 12956: [[36969], 256], 12957: [[20778], 256], 12958: [[21360], 256], 12959: [[27880], 256], 12960: [[38917], 256], 12961: [[20241], 256], 12962: [[20889], 256], 12963: [[27491], 256], 12964: [[19978], 256], 12965: [[20013], 256], 12966: [[19979], 256], 12967: [[24038], 256], 12968: [[21491], 256], 12969: [[21307], 256], 12970: [[23447], 256], 12971: [[23398], 256], 12972: [[30435], 256], 12973: [[20225], 256], 12974: [[36039], 256], 12975: [[21332], 256], 12976: [[22812], 256], 12977: [[51, 54], 256], 12978: [[51, 55], 256], 12979: [[51, 56], 256], 12980: [[51, 57], 256], 12981: [[52, 48], 256], 12982: [[52, 49], 256], 12983: [[52, 50], 256], 12984: [[52, 51], 256], 12985: [[52, 52], 256], 12986: [[52, 53], 256], 12987: [[52, 54], 256], 12988: [[52, 55], 256], 12989: [[52, 56], 256], 12990: [[52, 57], 256], 12991: [[53, 48], 256], 12992: [[49, 26376], 256], 12993: [[50, 26376], 256], 12994: [[51, 26376], 256], 12995: [[52, 26376], 256], 12996: [[53, 26376], 256], 12997: [[54, 26376], 256], 12998: [[55, 26376], 256], 12999: [[56, 26376], 256], 13e3: [[57, 26376], 256], 13001: [[49, 48, 26376], 256], 13002: [[49, 49, 26376], 256], 13003: [[49, 50, 26376], 256], 13004: [[72, 103], 256], 13005: [[101, 114, 103], 256], 13006: [[101, 86], 256], 13007: [[76, 84, 68], 256], 13008: [[12450], 256], 13009: [[12452], 256], 13010: [[12454], 256], 13011: [[12456], 256], 13012: [[12458], 256], 13013: [[12459], 256], 13014: [[12461], 256], 13015: [[12463], 256], 13016: [[12465], 256], 13017: [[12467], 256], 13018: [[12469], 256], 13019: [[12471], 256], 13020: [[12473], 256], 13021: [[12475], 256], 13022: [[12477], 256], 13023: [[12479], 256], 13024: [[12481], 256], 13025: [[12484], 256], 13026: [[12486], 256], 13027: [[12488], 256], 13028: [[12490], 256], 13029: [[12491], 256], 13030: [[12492], 256], 13031: [[12493], 256], 13032: [[12494], 256], 13033: [[12495], 256], 13034: [[12498], 256], 13035: [[12501], 256], 13036: [[12504], 256], 13037: [[12507], 256], 13038: [[12510], 256], 13039: [[12511], 256], 13040: [[12512], 256], 13041: [[12513], 256], 13042: [[12514], 256], 13043: [[12516], 256], 13044: [[12518], 256], 13045: [[12520], 256], 13046: [[12521], 256], 13047: [[12522], 256], 13048: [[12523], 256], 13049: [[12524], 256], 13050: [[12525], 256], 13051: [[12527], 256], 13052: [[12528], 256], 13053: [[12529], 256], 13054: [[12530], 256] },
  13056: { 13056: [[12450, 12497, 12540, 12488], 256], 13057: [[12450, 12523, 12501, 12449], 256], 13058: [[12450, 12531, 12506, 12450], 256], 13059: [[12450, 12540, 12523], 256], 13060: [[12452, 12491, 12531, 12464], 256], 13061: [[12452, 12531, 12481], 256], 13062: [[12454, 12457, 12531], 256], 13063: [[12456, 12473, 12463, 12540, 12489], 256], 13064: [[12456, 12540, 12459, 12540], 256], 13065: [[12458, 12531, 12473], 256], 13066: [[12458, 12540, 12512], 256], 13067: [[12459, 12452, 12522], 256], 13068: [[12459, 12521, 12483, 12488], 256], 13069: [[12459, 12525, 12522, 12540], 256], 13070: [[12460, 12525, 12531], 256], 13071: [[12460, 12531, 12510], 256], 13072: [[12462, 12460], 256], 13073: [[12462, 12491, 12540], 256], 13074: [[12461, 12517, 12522, 12540], 256], 13075: [[12462, 12523, 12480, 12540], 256], 13076: [[12461, 12525], 256], 13077: [[12461, 12525, 12464, 12521, 12512], 256], 13078: [[12461, 12525, 12513, 12540, 12488, 12523], 256], 13079: [[12461, 12525, 12527, 12483, 12488], 256], 13080: [[12464, 12521, 12512], 256], 13081: [[12464, 12521, 12512, 12488, 12531], 256], 13082: [[12463, 12523, 12476, 12452, 12525], 256], 13083: [[12463, 12525, 12540, 12493], 256], 13084: [[12465, 12540, 12473], 256], 13085: [[12467, 12523, 12490], 256], 13086: [[12467, 12540, 12509], 256], 13087: [[12469, 12452, 12463, 12523], 256], 13088: [[12469, 12531, 12481, 12540, 12512], 256], 13089: [[12471, 12522, 12531, 12464], 256], 13090: [[12475, 12531, 12481], 256], 13091: [[12475, 12531, 12488], 256], 13092: [[12480, 12540, 12473], 256], 13093: [[12487, 12471], 256], 13094: [[12489, 12523], 256], 13095: [[12488, 12531], 256], 13096: [[12490, 12494], 256], 13097: [[12494, 12483, 12488], 256], 13098: [[12495, 12452, 12484], 256], 13099: [[12497, 12540, 12475, 12531, 12488], 256], 13100: [[12497, 12540, 12484], 256], 13101: [[12496, 12540, 12524, 12523], 256], 13102: [[12500, 12450, 12473, 12488, 12523], 256], 13103: [[12500, 12463, 12523], 256], 13104: [[12500, 12467], 256], 13105: [[12499, 12523], 256], 13106: [[12501, 12449, 12521, 12483, 12489], 256], 13107: [[12501, 12451, 12540, 12488], 256], 13108: [[12502, 12483, 12471, 12455, 12523], 256], 13109: [[12501, 12521, 12531], 256], 13110: [[12504, 12463, 12479, 12540, 12523], 256], 13111: [[12506, 12477], 256], 13112: [[12506, 12491, 12498], 256], 13113: [[12504, 12523, 12484], 256], 13114: [[12506, 12531, 12473], 256], 13115: [[12506, 12540, 12472], 256], 13116: [[12505, 12540, 12479], 256], 13117: [[12509, 12452, 12531, 12488], 256], 13118: [[12508, 12523, 12488], 256], 13119: [[12507, 12531], 256], 13120: [[12509, 12531, 12489], 256], 13121: [[12507, 12540, 12523], 256], 13122: [[12507, 12540, 12531], 256], 13123: [[12510, 12452, 12463, 12525], 256], 13124: [[12510, 12452, 12523], 256], 13125: [[12510, 12483, 12495], 256], 13126: [[12510, 12523, 12463], 256], 13127: [[12510, 12531, 12471, 12519, 12531], 256], 13128: [[12511, 12463, 12525, 12531], 256], 13129: [[12511, 12522], 256], 13130: [[12511, 12522, 12496, 12540, 12523], 256], 13131: [[12513, 12460], 256], 13132: [[12513, 12460, 12488, 12531], 256], 13133: [[12513, 12540, 12488, 12523], 256], 13134: [[12516, 12540, 12489], 256], 13135: [[12516, 12540, 12523], 256], 13136: [[12518, 12450, 12531], 256], 13137: [[12522, 12483, 12488, 12523], 256], 13138: [[12522, 12521], 256], 13139: [[12523, 12500, 12540], 256], 13140: [[12523, 12540, 12502, 12523], 256], 13141: [[12524, 12512], 256], 13142: [[12524, 12531, 12488, 12466, 12531], 256], 13143: [[12527, 12483, 12488], 256], 13144: [[48, 28857], 256], 13145: [[49, 28857], 256], 13146: [[50, 28857], 256], 13147: [[51, 28857], 256], 13148: [[52, 28857], 256], 13149: [[53, 28857], 256], 13150: [[54, 28857], 256], 13151: [[55, 28857], 256], 13152: [[56, 28857], 256], 13153: [[57, 28857], 256], 13154: [[49, 48, 28857], 256], 13155: [[49, 49, 28857], 256], 13156: [[49, 50, 28857], 256], 13157: [[49, 51, 28857], 256], 13158: [[49, 52, 28857], 256], 13159: [[49, 53, 28857], 256], 13160: [[49, 54, 28857], 256], 13161: [[49, 55, 28857], 256], 13162: [[49, 56, 28857], 256], 13163: [[49, 57, 28857], 256], 13164: [[50, 48, 28857], 256], 13165: [[50, 49, 28857], 256], 13166: [[50, 50, 28857], 256], 13167: [[50, 51, 28857], 256], 13168: [[50, 52, 28857], 256], 13169: [[104, 80, 97], 256], 13170: [[100, 97], 256], 13171: [[65, 85], 256], 13172: [[98, 97, 114], 256], 13173: [[111, 86], 256], 13174: [[112, 99], 256], 13175: [[100, 109], 256], 13176: [[100, 109, 178], 256], 13177: [[100, 109, 179], 256], 13178: [[73, 85], 256], 13179: [[24179, 25104], 256], 13180: [[26157, 21644], 256], 13181: [[22823, 27491], 256], 13182: [[26126, 27835], 256], 13183: [[26666, 24335, 20250, 31038], 256], 13184: [[112, 65], 256], 13185: [[110, 65], 256], 13186: [[956, 65], 256], 13187: [[109, 65], 256], 13188: [[107, 65], 256], 13189: [[75, 66], 256], 13190: [[77, 66], 256], 13191: [[71, 66], 256], 13192: [[99, 97, 108], 256], 13193: [[107, 99, 97, 108], 256], 13194: [[112, 70], 256], 13195: [[110, 70], 256], 13196: [[956, 70], 256], 13197: [[956, 103], 256], 13198: [[109, 103], 256], 13199: [[107, 103], 256], 13200: [[72, 122], 256], 13201: [[107, 72, 122], 256], 13202: [[77, 72, 122], 256], 13203: [[71, 72, 122], 256], 13204: [[84, 72, 122], 256], 13205: [[956, 8467], 256], 13206: [[109, 8467], 256], 13207: [[100, 8467], 256], 13208: [[107, 8467], 256], 13209: [[102, 109], 256], 13210: [[110, 109], 256], 13211: [[956, 109], 256], 13212: [[109, 109], 256], 13213: [[99, 109], 256], 13214: [[107, 109], 256], 13215: [[109, 109, 178], 256], 13216: [[99, 109, 178], 256], 13217: [[109, 178], 256], 13218: [[107, 109, 178], 256], 13219: [[109, 109, 179], 256], 13220: [[99, 109, 179], 256], 13221: [[109, 179], 256], 13222: [[107, 109, 179], 256], 13223: [[109, 8725, 115], 256], 13224: [[109, 8725, 115, 178], 256], 13225: [[80, 97], 256], 13226: [[107, 80, 97], 256], 13227: [[77, 80, 97], 256], 13228: [[71, 80, 97], 256], 13229: [[114, 97, 100], 256], 13230: [[114, 97, 100, 8725, 115], 256], 13231: [[114, 97, 100, 8725, 115, 178], 256], 13232: [[112, 115], 256], 13233: [[110, 115], 256], 13234: [[956, 115], 256], 13235: [[109, 115], 256], 13236: [[112, 86], 256], 13237: [[110, 86], 256], 13238: [[956, 86], 256], 13239: [[109, 86], 256], 13240: [[107, 86], 256], 13241: [[77, 86], 256], 13242: [[112, 87], 256], 13243: [[110, 87], 256], 13244: [[956, 87], 256], 13245: [[109, 87], 256], 13246: [[107, 87], 256], 13247: [[77, 87], 256], 13248: [[107, 937], 256], 13249: [[77, 937], 256], 13250: [[97, 46, 109, 46], 256], 13251: [[66, 113], 256], 13252: [[99, 99], 256], 13253: [[99, 100], 256], 13254: [[67, 8725, 107, 103], 256], 13255: [[67, 111, 46], 256], 13256: [[100, 66], 256], 13257: [[71, 121], 256], 13258: [[104, 97], 256], 13259: [[72, 80], 256], 13260: [[105, 110], 256], 13261: [[75, 75], 256], 13262: [[75, 77], 256], 13263: [[107, 116], 256], 13264: [[108, 109], 256], 13265: [[108, 110], 256], 13266: [[108, 111, 103], 256], 13267: [[108, 120], 256], 13268: [[109, 98], 256], 13269: [[109, 105, 108], 256], 13270: [[109, 111, 108], 256], 13271: [[80, 72], 256], 13272: [[112, 46, 109, 46], 256], 13273: [[80, 80, 77], 256], 13274: [[80, 82], 256], 13275: [[115, 114], 256], 13276: [[83, 118], 256], 13277: [[87, 98], 256], 13278: [[86, 8725, 109], 256], 13279: [[65, 8725, 109], 256], 13280: [[49, 26085], 256], 13281: [[50, 26085], 256], 13282: [[51, 26085], 256], 13283: [[52, 26085], 256], 13284: [[53, 26085], 256], 13285: [[54, 26085], 256], 13286: [[55, 26085], 256], 13287: [[56, 26085], 256], 13288: [[57, 26085], 256], 13289: [[49, 48, 26085], 256], 13290: [[49, 49, 26085], 256], 13291: [[49, 50, 26085], 256], 13292: [[49, 51, 26085], 256], 13293: [[49, 52, 26085], 256], 13294: [[49, 53, 26085], 256], 13295: [[49, 54, 26085], 256], 13296: [[49, 55, 26085], 256], 13297: [[49, 56, 26085], 256], 13298: [[49, 57, 26085], 256], 13299: [[50, 48, 26085], 256], 13300: [[50, 49, 26085], 256], 13301: [[50, 50, 26085], 256], 13302: [[50, 51, 26085], 256], 13303: [[50, 52, 26085], 256], 13304: [[50, 53, 26085], 256], 13305: [[50, 54, 26085], 256], 13306: [[50, 55, 26085], 256], 13307: [[50, 56, 26085], 256], 13308: [[50, 57, 26085], 256], 13309: [[51, 48, 26085], 256], 13310: [[51, 49, 26085], 256], 13311: [[103, 97, 108], 256] },
  27136: { 92912: [null, 1], 92913: [null, 1], 92914: [null, 1], 92915: [null, 1], 92916: [null, 1] },
  27392: { 92976: [null, 230], 92977: [null, 230], 92978: [null, 230], 92979: [null, 230], 92980: [null, 230], 92981: [null, 230], 92982: [null, 230] },
  42496: { 42607: [null, 230], 42612: [null, 230], 42613: [null, 230], 42614: [null, 230], 42615: [null, 230], 42616: [null, 230], 42617: [null, 230], 42618: [null, 230], 42619: [null, 230], 42620: [null, 230], 42621: [null, 230], 42652: [[1098], 256], 42653: [[1100], 256], 42655: [null, 230], 42736: [null, 230], 42737: [null, 230] },
  42752: { 42864: [[42863], 256], 43e3: [[294], 256], 43001: [[339], 256] },
  43008: { 43014: [null, 9], 43204: [null, 9], 43232: [null, 230], 43233: [null, 230], 43234: [null, 230], 43235: [null, 230], 43236: [null, 230], 43237: [null, 230], 43238: [null, 230], 43239: [null, 230], 43240: [null, 230], 43241: [null, 230], 43242: [null, 230], 43243: [null, 230], 43244: [null, 230], 43245: [null, 230], 43246: [null, 230], 43247: [null, 230], 43248: [null, 230], 43249: [null, 230] },
  43264: { 43307: [null, 220], 43308: [null, 220], 43309: [null, 220], 43347: [null, 9], 43443: [null, 7], 43456: [null, 9] },
  43520: { 43696: [null, 230], 43698: [null, 230], 43699: [null, 230], 43700: [null, 220], 43703: [null, 230], 43704: [null, 230], 43710: [null, 230], 43711: [null, 230], 43713: [null, 230], 43766: [null, 9] },
  43776: { 43868: [[42791], 256], 43869: [[43831], 256], 43870: [[619], 256], 43871: [[43858], 256], 44013: [null, 9] },
  48128: { 113822: [null, 1] },
  53504: { 119134: [[119127, 119141], 512], 119135: [[119128, 119141], 512], 119136: [[119135, 119150], 512], 119137: [[119135, 119151], 512], 119138: [[119135, 119152], 512], 119139: [[119135, 119153], 512], 119140: [[119135, 119154], 512], 119141: [null, 216], 119142: [null, 216], 119143: [null, 1], 119144: [null, 1], 119145: [null, 1], 119149: [null, 226], 119150: [null, 216], 119151: [null, 216], 119152: [null, 216], 119153: [null, 216], 119154: [null, 216], 119163: [null, 220], 119164: [null, 220], 119165: [null, 220], 119166: [null, 220], 119167: [null, 220], 119168: [null, 220], 119169: [null, 220], 119170: [null, 220], 119173: [null, 230], 119174: [null, 230], 119175: [null, 230], 119176: [null, 230], 119177: [null, 230], 119178: [null, 220], 119179: [null, 220], 119210: [null, 230], 119211: [null, 230], 119212: [null, 230], 119213: [null, 230], 119227: [[119225, 119141], 512], 119228: [[119226, 119141], 512], 119229: [[119227, 119150], 512], 119230: [[119228, 119150], 512], 119231: [[119227, 119151], 512], 119232: [[119228, 119151], 512] },
  53760: { 119362: [null, 230], 119363: [null, 230], 119364: [null, 230] },
  54272: { 119808: [[65], 256], 119809: [[66], 256], 119810: [[67], 256], 119811: [[68], 256], 119812: [[69], 256], 119813: [[70], 256], 119814: [[71], 256], 119815: [[72], 256], 119816: [[73], 256], 119817: [[74], 256], 119818: [[75], 256], 119819: [[76], 256], 119820: [[77], 256], 119821: [[78], 256], 119822: [[79], 256], 119823: [[80], 256], 119824: [[81], 256], 119825: [[82], 256], 119826: [[83], 256], 119827: [[84], 256], 119828: [[85], 256], 119829: [[86], 256], 119830: [[87], 256], 119831: [[88], 256], 119832: [[89], 256], 119833: [[90], 256], 119834: [[97], 256], 119835: [[98], 256], 119836: [[99], 256], 119837: [[100], 256], 119838: [[101], 256], 119839: [[102], 256], 119840: [[103], 256], 119841: [[104], 256], 119842: [[105], 256], 119843: [[106], 256], 119844: [[107], 256], 119845: [[108], 256], 119846: [[109], 256], 119847: [[110], 256], 119848: [[111], 256], 119849: [[112], 256], 119850: [[113], 256], 119851: [[114], 256], 119852: [[115], 256], 119853: [[116], 256], 119854: [[117], 256], 119855: [[118], 256], 119856: [[119], 256], 119857: [[120], 256], 119858: [[121], 256], 119859: [[122], 256], 119860: [[65], 256], 119861: [[66], 256], 119862: [[67], 256], 119863: [[68], 256], 119864: [[69], 256], 119865: [[70], 256], 119866: [[71], 256], 119867: [[72], 256], 119868: [[73], 256], 119869: [[74], 256], 119870: [[75], 256], 119871: [[76], 256], 119872: [[77], 256], 119873: [[78], 256], 119874: [[79], 256], 119875: [[80], 256], 119876: [[81], 256], 119877: [[82], 256], 119878: [[83], 256], 119879: [[84], 256], 119880: [[85], 256], 119881: [[86], 256], 119882: [[87], 256], 119883: [[88], 256], 119884: [[89], 256], 119885: [[90], 256], 119886: [[97], 256], 119887: [[98], 256], 119888: [[99], 256], 119889: [[100], 256], 119890: [[101], 256], 119891: [[102], 256], 119892: [[103], 256], 119894: [[105], 256], 119895: [[106], 256], 119896: [[107], 256], 119897: [[108], 256], 119898: [[109], 256], 119899: [[110], 256], 119900: [[111], 256], 119901: [[112], 256], 119902: [[113], 256], 119903: [[114], 256], 119904: [[115], 256], 119905: [[116], 256], 119906: [[117], 256], 119907: [[118], 256], 119908: [[119], 256], 119909: [[120], 256], 119910: [[121], 256], 119911: [[122], 256], 119912: [[65], 256], 119913: [[66], 256], 119914: [[67], 256], 119915: [[68], 256], 119916: [[69], 256], 119917: [[70], 256], 119918: [[71], 256], 119919: [[72], 256], 119920: [[73], 256], 119921: [[74], 256], 119922: [[75], 256], 119923: [[76], 256], 119924: [[77], 256], 119925: [[78], 256], 119926: [[79], 256], 119927: [[80], 256], 119928: [[81], 256], 119929: [[82], 256], 119930: [[83], 256], 119931: [[84], 256], 119932: [[85], 256], 119933: [[86], 256], 119934: [[87], 256], 119935: [[88], 256], 119936: [[89], 256], 119937: [[90], 256], 119938: [[97], 256], 119939: [[98], 256], 119940: [[99], 256], 119941: [[100], 256], 119942: [[101], 256], 119943: [[102], 256], 119944: [[103], 256], 119945: [[104], 256], 119946: [[105], 256], 119947: [[106], 256], 119948: [[107], 256], 119949: [[108], 256], 119950: [[109], 256], 119951: [[110], 256], 119952: [[111], 256], 119953: [[112], 256], 119954: [[113], 256], 119955: [[114], 256], 119956: [[115], 256], 119957: [[116], 256], 119958: [[117], 256], 119959: [[118], 256], 119960: [[119], 256], 119961: [[120], 256], 119962: [[121], 256], 119963: [[122], 256], 119964: [[65], 256], 119966: [[67], 256], 119967: [[68], 256], 119970: [[71], 256], 119973: [[74], 256], 119974: [[75], 256], 119977: [[78], 256], 119978: [[79], 256], 119979: [[80], 256], 119980: [[81], 256], 119982: [[83], 256], 119983: [[84], 256], 119984: [[85], 256], 119985: [[86], 256], 119986: [[87], 256], 119987: [[88], 256], 119988: [[89], 256], 119989: [[90], 256], 119990: [[97], 256], 119991: [[98], 256], 119992: [[99], 256], 119993: [[100], 256], 119995: [[102], 256], 119997: [[104], 256], 119998: [[105], 256], 119999: [[106], 256], 12e4: [[107], 256], 120001: [[108], 256], 120002: [[109], 256], 120003: [[110], 256], 120005: [[112], 256], 120006: [[113], 256], 120007: [[114], 256], 120008: [[115], 256], 120009: [[116], 256], 120010: [[117], 256], 120011: [[118], 256], 120012: [[119], 256], 120013: [[120], 256], 120014: [[121], 256], 120015: [[122], 256], 120016: [[65], 256], 120017: [[66], 256], 120018: [[67], 256], 120019: [[68], 256], 120020: [[69], 256], 120021: [[70], 256], 120022: [[71], 256], 120023: [[72], 256], 120024: [[73], 256], 120025: [[74], 256], 120026: [[75], 256], 120027: [[76], 256], 120028: [[77], 256], 120029: [[78], 256], 120030: [[79], 256], 120031: [[80], 256], 120032: [[81], 256], 120033: [[82], 256], 120034: [[83], 256], 120035: [[84], 256], 120036: [[85], 256], 120037: [[86], 256], 120038: [[87], 256], 120039: [[88], 256], 120040: [[89], 256], 120041: [[90], 256], 120042: [[97], 256], 120043: [[98], 256], 120044: [[99], 256], 120045: [[100], 256], 120046: [[101], 256], 120047: [[102], 256], 120048: [[103], 256], 120049: [[104], 256], 120050: [[105], 256], 120051: [[106], 256], 120052: [[107], 256], 120053: [[108], 256], 120054: [[109], 256], 120055: [[110], 256], 120056: [[111], 256], 120057: [[112], 256], 120058: [[113], 256], 120059: [[114], 256], 120060: [[115], 256], 120061: [[116], 256], 120062: [[117], 256], 120063: [[118], 256] },
  54528: { 120064: [[119], 256], 120065: [[120], 256], 120066: [[121], 256], 120067: [[122], 256], 120068: [[65], 256], 120069: [[66], 256], 120071: [[68], 256], 120072: [[69], 256], 120073: [[70], 256], 120074: [[71], 256], 120077: [[74], 256], 120078: [[75], 256], 120079: [[76], 256], 120080: [[77], 256], 120081: [[78], 256], 120082: [[79], 256], 120083: [[80], 256], 120084: [[81], 256], 120086: [[83], 256], 120087: [[84], 256], 120088: [[85], 256], 120089: [[86], 256], 120090: [[87], 256], 120091: [[88], 256], 120092: [[89], 256], 120094: [[97], 256], 120095: [[98], 256], 120096: [[99], 256], 120097: [[100], 256], 120098: [[101], 256], 120099: [[102], 256], 120100: [[103], 256], 120101: [[104], 256], 120102: [[105], 256], 120103: [[106], 256], 120104: [[107], 256], 120105: [[108], 256], 120106: [[109], 256], 120107: [[110], 256], 120108: [[111], 256], 120109: [[112], 256], 120110: [[113], 256], 120111: [[114], 256], 120112: [[115], 256], 120113: [[116], 256], 120114: [[117], 256], 120115: [[118], 256], 120116: [[119], 256], 120117: [[120], 256], 120118: [[121], 256], 120119: [[122], 256], 120120: [[65], 256], 120121: [[66], 256], 120123: [[68], 256], 120124: [[69], 256], 120125: [[70], 256], 120126: [[71], 256], 120128: [[73], 256], 120129: [[74], 256], 120130: [[75], 256], 120131: [[76], 256], 120132: [[77], 256], 120134: [[79], 256], 120138: [[83], 256], 120139: [[84], 256], 120140: [[85], 256], 120141: [[86], 256], 120142: [[87], 256], 120143: [[88], 256], 120144: [[89], 256], 120146: [[97], 256], 120147: [[98], 256], 120148: [[99], 256], 120149: [[100], 256], 120150: [[101], 256], 120151: [[102], 256], 120152: [[103], 256], 120153: [[104], 256], 120154: [[105], 256], 120155: [[106], 256], 120156: [[107], 256], 120157: [[108], 256], 120158: [[109], 256], 120159: [[110], 256], 120160: [[111], 256], 120161: [[112], 256], 120162: [[113], 256], 120163: [[114], 256], 120164: [[115], 256], 120165: [[116], 256], 120166: [[117], 256], 120167: [[118], 256], 120168: [[119], 256], 120169: [[120], 256], 120170: [[121], 256], 120171: [[122], 256], 120172: [[65], 256], 120173: [[66], 256], 120174: [[67], 256], 120175: [[68], 256], 120176: [[69], 256], 120177: [[70], 256], 120178: [[71], 256], 120179: [[72], 256], 120180: [[73], 256], 120181: [[74], 256], 120182: [[75], 256], 120183: [[76], 256], 120184: [[77], 256], 120185: [[78], 256], 120186: [[79], 256], 120187: [[80], 256], 120188: [[81], 256], 120189: [[82], 256], 120190: [[83], 256], 120191: [[84], 256], 120192: [[85], 256], 120193: [[86], 256], 120194: [[87], 256], 120195: [[88], 256], 120196: [[89], 256], 120197: [[90], 256], 120198: [[97], 256], 120199: [[98], 256], 120200: [[99], 256], 120201: [[100], 256], 120202: [[101], 256], 120203: [[102], 256], 120204: [[103], 256], 120205: [[104], 256], 120206: [[105], 256], 120207: [[106], 256], 120208: [[107], 256], 120209: [[108], 256], 120210: [[109], 256], 120211: [[110], 256], 120212: [[111], 256], 120213: [[112], 256], 120214: [[113], 256], 120215: [[114], 256], 120216: [[115], 256], 120217: [[116], 256], 120218: [[117], 256], 120219: [[118], 256], 120220: [[119], 256], 120221: [[120], 256], 120222: [[121], 256], 120223: [[122], 256], 120224: [[65], 256], 120225: [[66], 256], 120226: [[67], 256], 120227: [[68], 256], 120228: [[69], 256], 120229: [[70], 256], 120230: [[71], 256], 120231: [[72], 256], 120232: [[73], 256], 120233: [[74], 256], 120234: [[75], 256], 120235: [[76], 256], 120236: [[77], 256], 120237: [[78], 256], 120238: [[79], 256], 120239: [[80], 256], 120240: [[81], 256], 120241: [[82], 256], 120242: [[83], 256], 120243: [[84], 256], 120244: [[85], 256], 120245: [[86], 256], 120246: [[87], 256], 120247: [[88], 256], 120248: [[89], 256], 120249: [[90], 256], 120250: [[97], 256], 120251: [[98], 256], 120252: [[99], 256], 120253: [[100], 256], 120254: [[101], 256], 120255: [[102], 256], 120256: [[103], 256], 120257: [[104], 256], 120258: [[105], 256], 120259: [[106], 256], 120260: [[107], 256], 120261: [[108], 256], 120262: [[109], 256], 120263: [[110], 256], 120264: [[111], 256], 120265: [[112], 256], 120266: [[113], 256], 120267: [[114], 256], 120268: [[115], 256], 120269: [[116], 256], 120270: [[117], 256], 120271: [[118], 256], 120272: [[119], 256], 120273: [[120], 256], 120274: [[121], 256], 120275: [[122], 256], 120276: [[65], 256], 120277: [[66], 256], 120278: [[67], 256], 120279: [[68], 256], 120280: [[69], 256], 120281: [[70], 256], 120282: [[71], 256], 120283: [[72], 256], 120284: [[73], 256], 120285: [[74], 256], 120286: [[75], 256], 120287: [[76], 256], 120288: [[77], 256], 120289: [[78], 256], 120290: [[79], 256], 120291: [[80], 256], 120292: [[81], 256], 120293: [[82], 256], 120294: [[83], 256], 120295: [[84], 256], 120296: [[85], 256], 120297: [[86], 256], 120298: [[87], 256], 120299: [[88], 256], 120300: [[89], 256], 120301: [[90], 256], 120302: [[97], 256], 120303: [[98], 256], 120304: [[99], 256], 120305: [[100], 256], 120306: [[101], 256], 120307: [[102], 256], 120308: [[103], 256], 120309: [[104], 256], 120310: [[105], 256], 120311: [[106], 256], 120312: [[107], 256], 120313: [[108], 256], 120314: [[109], 256], 120315: [[110], 256], 120316: [[111], 256], 120317: [[112], 256], 120318: [[113], 256], 120319: [[114], 256] },
  54784: { 120320: [[115], 256], 120321: [[116], 256], 120322: [[117], 256], 120323: [[118], 256], 120324: [[119], 256], 120325: [[120], 256], 120326: [[121], 256], 120327: [[122], 256], 120328: [[65], 256], 120329: [[66], 256], 120330: [[67], 256], 120331: [[68], 256], 120332: [[69], 256], 120333: [[70], 256], 120334: [[71], 256], 120335: [[72], 256], 120336: [[73], 256], 120337: [[74], 256], 120338: [[75], 256], 120339: [[76], 256], 120340: [[77], 256], 120341: [[78], 256], 120342: [[79], 256], 120343: [[80], 256], 120344: [[81], 256], 120345: [[82], 256], 120346: [[83], 256], 120347: [[84], 256], 120348: [[85], 256], 120349: [[86], 256], 120350: [[87], 256], 120351: [[88], 256], 120352: [[89], 256], 120353: [[90], 256], 120354: [[97], 256], 120355: [[98], 256], 120356: [[99], 256], 120357: [[100], 256], 120358: [[101], 256], 120359: [[102], 256], 120360: [[103], 256], 120361: [[104], 256], 120362: [[105], 256], 120363: [[106], 256], 120364: [[107], 256], 120365: [[108], 256], 120366: [[109], 256], 120367: [[110], 256], 120368: [[111], 256], 120369: [[112], 256], 120370: [[113], 256], 120371: [[114], 256], 120372: [[115], 256], 120373: [[116], 256], 120374: [[117], 256], 120375: [[118], 256], 120376: [[119], 256], 120377: [[120], 256], 120378: [[121], 256], 120379: [[122], 256], 120380: [[65], 256], 120381: [[66], 256], 120382: [[67], 256], 120383: [[68], 256], 120384: [[69], 256], 120385: [[70], 256], 120386: [[71], 256], 120387: [[72], 256], 120388: [[73], 256], 120389: [[74], 256], 120390: [[75], 256], 120391: [[76], 256], 120392: [[77], 256], 120393: [[78], 256], 120394: [[79], 256], 120395: [[80], 256], 120396: [[81], 256], 120397: [[82], 256], 120398: [[83], 256], 120399: [[84], 256], 120400: [[85], 256], 120401: [[86], 256], 120402: [[87], 256], 120403: [[88], 256], 120404: [[89], 256], 120405: [[90], 256], 120406: [[97], 256], 120407: [[98], 256], 120408: [[99], 256], 120409: [[100], 256], 120410: [[101], 256], 120411: [[102], 256], 120412: [[103], 256], 120413: [[104], 256], 120414: [[105], 256], 120415: [[106], 256], 120416: [[107], 256], 120417: [[108], 256], 120418: [[109], 256], 120419: [[110], 256], 120420: [[111], 256], 120421: [[112], 256], 120422: [[113], 256], 120423: [[114], 256], 120424: [[115], 256], 120425: [[116], 256], 120426: [[117], 256], 120427: [[118], 256], 120428: [[119], 256], 120429: [[120], 256], 120430: [[121], 256], 120431: [[122], 256], 120432: [[65], 256], 120433: [[66], 256], 120434: [[67], 256], 120435: [[68], 256], 120436: [[69], 256], 120437: [[70], 256], 120438: [[71], 256], 120439: [[72], 256], 120440: [[73], 256], 120441: [[74], 256], 120442: [[75], 256], 120443: [[76], 256], 120444: [[77], 256], 120445: [[78], 256], 120446: [[79], 256], 120447: [[80], 256], 120448: [[81], 256], 120449: [[82], 256], 120450: [[83], 256], 120451: [[84], 256], 120452: [[85], 256], 120453: [[86], 256], 120454: [[87], 256], 120455: [[88], 256], 120456: [[89], 256], 120457: [[90], 256], 120458: [[97], 256], 120459: [[98], 256], 120460: [[99], 256], 120461: [[100], 256], 120462: [[101], 256], 120463: [[102], 256], 120464: [[103], 256], 120465: [[104], 256], 120466: [[105], 256], 120467: [[106], 256], 120468: [[107], 256], 120469: [[108], 256], 120470: [[109], 256], 120471: [[110], 256], 120472: [[111], 256], 120473: [[112], 256], 120474: [[113], 256], 120475: [[114], 256], 120476: [[115], 256], 120477: [[116], 256], 120478: [[117], 256], 120479: [[118], 256], 120480: [[119], 256], 120481: [[120], 256], 120482: [[121], 256], 120483: [[122], 256], 120484: [[305], 256], 120485: [[567], 256], 120488: [[913], 256], 120489: [[914], 256], 120490: [[915], 256], 120491: [[916], 256], 120492: [[917], 256], 120493: [[918], 256], 120494: [[919], 256], 120495: [[920], 256], 120496: [[921], 256], 120497: [[922], 256], 120498: [[923], 256], 120499: [[924], 256], 120500: [[925], 256], 120501: [[926], 256], 120502: [[927], 256], 120503: [[928], 256], 120504: [[929], 256], 120505: [[1012], 256], 120506: [[931], 256], 120507: [[932], 256], 120508: [[933], 256], 120509: [[934], 256], 120510: [[935], 256], 120511: [[936], 256], 120512: [[937], 256], 120513: [[8711], 256], 120514: [[945], 256], 120515: [[946], 256], 120516: [[947], 256], 120517: [[948], 256], 120518: [[949], 256], 120519: [[950], 256], 120520: [[951], 256], 120521: [[952], 256], 120522: [[953], 256], 120523: [[954], 256], 120524: [[955], 256], 120525: [[956], 256], 120526: [[957], 256], 120527: [[958], 256], 120528: [[959], 256], 120529: [[960], 256], 120530: [[961], 256], 120531: [[962], 256], 120532: [[963], 256], 120533: [[964], 256], 120534: [[965], 256], 120535: [[966], 256], 120536: [[967], 256], 120537: [[968], 256], 120538: [[969], 256], 120539: [[8706], 256], 120540: [[1013], 256], 120541: [[977], 256], 120542: [[1008], 256], 120543: [[981], 256], 120544: [[1009], 256], 120545: [[982], 256], 120546: [[913], 256], 120547: [[914], 256], 120548: [[915], 256], 120549: [[916], 256], 120550: [[917], 256], 120551: [[918], 256], 120552: [[919], 256], 120553: [[920], 256], 120554: [[921], 256], 120555: [[922], 256], 120556: [[923], 256], 120557: [[924], 256], 120558: [[925], 256], 120559: [[926], 256], 120560: [[927], 256], 120561: [[928], 256], 120562: [[929], 256], 120563: [[1012], 256], 120564: [[931], 256], 120565: [[932], 256], 120566: [[933], 256], 120567: [[934], 256], 120568: [[935], 256], 120569: [[936], 256], 120570: [[937], 256], 120571: [[8711], 256], 120572: [[945], 256], 120573: [[946], 256], 120574: [[947], 256], 120575: [[948], 256] },
  55040: { 120576: [[949], 256], 120577: [[950], 256], 120578: [[951], 256], 120579: [[952], 256], 120580: [[953], 256], 120581: [[954], 256], 120582: [[955], 256], 120583: [[956], 256], 120584: [[957], 256], 120585: [[958], 256], 120586: [[959], 256], 120587: [[960], 256], 120588: [[961], 256], 120589: [[962], 256], 120590: [[963], 256], 120591: [[964], 256], 120592: [[965], 256], 120593: [[966], 256], 120594: [[967], 256], 120595: [[968], 256], 120596: [[969], 256], 120597: [[8706], 256], 120598: [[1013], 256], 120599: [[977], 256], 120600: [[1008], 256], 120601: [[981], 256], 120602: [[1009], 256], 120603: [[982], 256], 120604: [[913], 256], 120605: [[914], 256], 120606: [[915], 256], 120607: [[916], 256], 120608: [[917], 256], 120609: [[918], 256], 120610: [[919], 256], 120611: [[920], 256], 120612: [[921], 256], 120613: [[922], 256], 120614: [[923], 256], 120615: [[924], 256], 120616: [[925], 256], 120617: [[926], 256], 120618: [[927], 256], 120619: [[928], 256], 120620: [[929], 256], 120621: [[1012], 256], 120622: [[931], 256], 120623: [[932], 256], 120624: [[933], 256], 120625: [[934], 256], 120626: [[935], 256], 120627: [[936], 256], 120628: [[937], 256], 120629: [[8711], 256], 120630: [[945], 256], 120631: [[946], 256], 120632: [[947], 256], 120633: [[948], 256], 120634: [[949], 256], 120635: [[950], 256], 120636: [[951], 256], 120637: [[952], 256], 120638: [[953], 256], 120639: [[954], 256], 120640: [[955], 256], 120641: [[956], 256], 120642: [[957], 256], 120643: [[958], 256], 120644: [[959], 256], 120645: [[960], 256], 120646: [[961], 256], 120647: [[962], 256], 120648: [[963], 256], 120649: [[964], 256], 120650: [[965], 256], 120651: [[966], 256], 120652: [[967], 256], 120653: [[968], 256], 120654: [[969], 256], 120655: [[8706], 256], 120656: [[1013], 256], 120657: [[977], 256], 120658: [[1008], 256], 120659: [[981], 256], 120660: [[1009], 256], 120661: [[982], 256], 120662: [[913], 256], 120663: [[914], 256], 120664: [[915], 256], 120665: [[916], 256], 120666: [[917], 256], 120667: [[918], 256], 120668: [[919], 256], 120669: [[920], 256], 120670: [[921], 256], 120671: [[922], 256], 120672: [[923], 256], 120673: [[924], 256], 120674: [[925], 256], 120675: [[926], 256], 120676: [[927], 256], 120677: [[928], 256], 120678: [[929], 256], 120679: [[1012], 256], 120680: [[931], 256], 120681: [[932], 256], 120682: [[933], 256], 120683: [[934], 256], 120684: [[935], 256], 120685: [[936], 256], 120686: [[937], 256], 120687: [[8711], 256], 120688: [[945], 256], 120689: [[946], 256], 120690: [[947], 256], 120691: [[948], 256], 120692: [[949], 256], 120693: [[950], 256], 120694: [[951], 256], 120695: [[952], 256], 120696: [[953], 256], 120697: [[954], 256], 120698: [[955], 256], 120699: [[956], 256], 120700: [[957], 256], 120701: [[958], 256], 120702: [[959], 256], 120703: [[960], 256], 120704: [[961], 256], 120705: [[962], 256], 120706: [[963], 256], 120707: [[964], 256], 120708: [[965], 256], 120709: [[966], 256], 120710: [[967], 256], 120711: [[968], 256], 120712: [[969], 256], 120713: [[8706], 256], 120714: [[1013], 256], 120715: [[977], 256], 120716: [[1008], 256], 120717: [[981], 256], 120718: [[1009], 256], 120719: [[982], 256], 120720: [[913], 256], 120721: [[914], 256], 120722: [[915], 256], 120723: [[916], 256], 120724: [[917], 256], 120725: [[918], 256], 120726: [[919], 256], 120727: [[920], 256], 120728: [[921], 256], 120729: [[922], 256], 120730: [[923], 256], 120731: [[924], 256], 120732: [[925], 256], 120733: [[926], 256], 120734: [[927], 256], 120735: [[928], 256], 120736: [[929], 256], 120737: [[1012], 256], 120738: [[931], 256], 120739: [[932], 256], 120740: [[933], 256], 120741: [[934], 256], 120742: [[935], 256], 120743: [[936], 256], 120744: [[937], 256], 120745: [[8711], 256], 120746: [[945], 256], 120747: [[946], 256], 120748: [[947], 256], 120749: [[948], 256], 120750: [[949], 256], 120751: [[950], 256], 120752: [[951], 256], 120753: [[952], 256], 120754: [[953], 256], 120755: [[954], 256], 120756: [[955], 256], 120757: [[956], 256], 120758: [[957], 256], 120759: [[958], 256], 120760: [[959], 256], 120761: [[960], 256], 120762: [[961], 256], 120763: [[962], 256], 120764: [[963], 256], 120765: [[964], 256], 120766: [[965], 256], 120767: [[966], 256], 120768: [[967], 256], 120769: [[968], 256], 120770: [[969], 256], 120771: [[8706], 256], 120772: [[1013], 256], 120773: [[977], 256], 120774: [[1008], 256], 120775: [[981], 256], 120776: [[1009], 256], 120777: [[982], 256], 120778: [[988], 256], 120779: [[989], 256], 120782: [[48], 256], 120783: [[49], 256], 120784: [[50], 256], 120785: [[51], 256], 120786: [[52], 256], 120787: [[53], 256], 120788: [[54], 256], 120789: [[55], 256], 120790: [[56], 256], 120791: [[57], 256], 120792: [[48], 256], 120793: [[49], 256], 120794: [[50], 256], 120795: [[51], 256], 120796: [[52], 256], 120797: [[53], 256], 120798: [[54], 256], 120799: [[55], 256], 120800: [[56], 256], 120801: [[57], 256], 120802: [[48], 256], 120803: [[49], 256], 120804: [[50], 256], 120805: [[51], 256], 120806: [[52], 256], 120807: [[53], 256], 120808: [[54], 256], 120809: [[55], 256], 120810: [[56], 256], 120811: [[57], 256], 120812: [[48], 256], 120813: [[49], 256], 120814: [[50], 256], 120815: [[51], 256], 120816: [[52], 256], 120817: [[53], 256], 120818: [[54], 256], 120819: [[55], 256], 120820: [[56], 256], 120821: [[57], 256], 120822: [[48], 256], 120823: [[49], 256], 120824: [[50], 256], 120825: [[51], 256], 120826: [[52], 256], 120827: [[53], 256], 120828: [[54], 256], 120829: [[55], 256], 120830: [[56], 256], 120831: [[57], 256] },
  59392: { 125136: [null, 220], 125137: [null, 220], 125138: [null, 220], 125139: [null, 220], 125140: [null, 220], 125141: [null, 220], 125142: [null, 220] },
  60928: { 126464: [[1575], 256], 126465: [[1576], 256], 126466: [[1580], 256], 126467: [[1583], 256], 126469: [[1608], 256], 126470: [[1586], 256], 126471: [[1581], 256], 126472: [[1591], 256], 126473: [[1610], 256], 126474: [[1603], 256], 126475: [[1604], 256], 126476: [[1605], 256], 126477: [[1606], 256], 126478: [[1587], 256], 126479: [[1593], 256], 126480: [[1601], 256], 126481: [[1589], 256], 126482: [[1602], 256], 126483: [[1585], 256], 126484: [[1588], 256], 126485: [[1578], 256], 126486: [[1579], 256], 126487: [[1582], 256], 126488: [[1584], 256], 126489: [[1590], 256], 126490: [[1592], 256], 126491: [[1594], 256], 126492: [[1646], 256], 126493: [[1722], 256], 126494: [[1697], 256], 126495: [[1647], 256], 126497: [[1576], 256], 126498: [[1580], 256], 126500: [[1607], 256], 126503: [[1581], 256], 126505: [[1610], 256], 126506: [[1603], 256], 126507: [[1604], 256], 126508: [[1605], 256], 126509: [[1606], 256], 126510: [[1587], 256], 126511: [[1593], 256], 126512: [[1601], 256], 126513: [[1589], 256], 126514: [[1602], 256], 126516: [[1588], 256], 126517: [[1578], 256], 126518: [[1579], 256], 126519: [[1582], 256], 126521: [[1590], 256], 126523: [[1594], 256], 126530: [[1580], 256], 126535: [[1581], 256], 126537: [[1610], 256], 126539: [[1604], 256], 126541: [[1606], 256], 126542: [[1587], 256], 126543: [[1593], 256], 126545: [[1589], 256], 126546: [[1602], 256], 126548: [[1588], 256], 126551: [[1582], 256], 126553: [[1590], 256], 126555: [[1594], 256], 126557: [[1722], 256], 126559: [[1647], 256], 126561: [[1576], 256], 126562: [[1580], 256], 126564: [[1607], 256], 126567: [[1581], 256], 126568: [[1591], 256], 126569: [[1610], 256], 126570: [[1603], 256], 126572: [[1605], 256], 126573: [[1606], 256], 126574: [[1587], 256], 126575: [[1593], 256], 126576: [[1601], 256], 126577: [[1589], 256], 126578: [[1602], 256], 126580: [[1588], 256], 126581: [[1578], 256], 126582: [[1579], 256], 126583: [[1582], 256], 126585: [[1590], 256], 126586: [[1592], 256], 126587: [[1594], 256], 126588: [[1646], 256], 126590: [[1697], 256], 126592: [[1575], 256], 126593: [[1576], 256], 126594: [[1580], 256], 126595: [[1583], 256], 126596: [[1607], 256], 126597: [[1608], 256], 126598: [[1586], 256], 126599: [[1581], 256], 126600: [[1591], 256], 126601: [[1610], 256], 126603: [[1604], 256], 126604: [[1605], 256], 126605: [[1606], 256], 126606: [[1587], 256], 126607: [[1593], 256], 126608: [[1601], 256], 126609: [[1589], 256], 126610: [[1602], 256], 126611: [[1585], 256], 126612: [[1588], 256], 126613: [[1578], 256], 126614: [[1579], 256], 126615: [[1582], 256], 126616: [[1584], 256], 126617: [[1590], 256], 126618: [[1592], 256], 126619: [[1594], 256], 126625: [[1576], 256], 126626: [[1580], 256], 126627: [[1583], 256], 126629: [[1608], 256], 126630: [[1586], 256], 126631: [[1581], 256], 126632: [[1591], 256], 126633: [[1610], 256], 126635: [[1604], 256], 126636: [[1605], 256], 126637: [[1606], 256], 126638: [[1587], 256], 126639: [[1593], 256], 126640: [[1601], 256], 126641: [[1589], 256], 126642: [[1602], 256], 126643: [[1585], 256], 126644: [[1588], 256], 126645: [[1578], 256], 126646: [[1579], 256], 126647: [[1582], 256], 126648: [[1584], 256], 126649: [[1590], 256], 126650: [[1592], 256], 126651: [[1594], 256] },
  61696: { 127232: [[48, 46], 256], 127233: [[48, 44], 256], 127234: [[49, 44], 256], 127235: [[50, 44], 256], 127236: [[51, 44], 256], 127237: [[52, 44], 256], 127238: [[53, 44], 256], 127239: [[54, 44], 256], 127240: [[55, 44], 256], 127241: [[56, 44], 256], 127242: [[57, 44], 256], 127248: [[40, 65, 41], 256], 127249: [[40, 66, 41], 256], 127250: [[40, 67, 41], 256], 127251: [[40, 68, 41], 256], 127252: [[40, 69, 41], 256], 127253: [[40, 70, 41], 256], 127254: [[40, 71, 41], 256], 127255: [[40, 72, 41], 256], 127256: [[40, 73, 41], 256], 127257: [[40, 74, 41], 256], 127258: [[40, 75, 41], 256], 127259: [[40, 76, 41], 256], 127260: [[40, 77, 41], 256], 127261: [[40, 78, 41], 256], 127262: [[40, 79, 41], 256], 127263: [[40, 80, 41], 256], 127264: [[40, 81, 41], 256], 127265: [[40, 82, 41], 256], 127266: [[40, 83, 41], 256], 127267: [[40, 84, 41], 256], 127268: [[40, 85, 41], 256], 127269: [[40, 86, 41], 256], 127270: [[40, 87, 41], 256], 127271: [[40, 88, 41], 256], 127272: [[40, 89, 41], 256], 127273: [[40, 90, 41], 256], 127274: [[12308, 83, 12309], 256], 127275: [[67], 256], 127276: [[82], 256], 127277: [[67, 68], 256], 127278: [[87, 90], 256], 127280: [[65], 256], 127281: [[66], 256], 127282: [[67], 256], 127283: [[68], 256], 127284: [[69], 256], 127285: [[70], 256], 127286: [[71], 256], 127287: [[72], 256], 127288: [[73], 256], 127289: [[74], 256], 127290: [[75], 256], 127291: [[76], 256], 127292: [[77], 256], 127293: [[78], 256], 127294: [[79], 256], 127295: [[80], 256], 127296: [[81], 256], 127297: [[82], 256], 127298: [[83], 256], 127299: [[84], 256], 127300: [[85], 256], 127301: [[86], 256], 127302: [[87], 256], 127303: [[88], 256], 127304: [[89], 256], 127305: [[90], 256], 127306: [[72, 86], 256], 127307: [[77, 86], 256], 127308: [[83, 68], 256], 127309: [[83, 83], 256], 127310: [[80, 80, 86], 256], 127311: [[87, 67], 256], 127338: [[77, 67], 256], 127339: [[77, 68], 256], 127376: [[68, 74], 256] },
  61952: { 127488: [[12411, 12363], 256], 127489: [[12467, 12467], 256], 127490: [[12469], 256], 127504: [[25163], 256], 127505: [[23383], 256], 127506: [[21452], 256], 127507: [[12487], 256], 127508: [[20108], 256], 127509: [[22810], 256], 127510: [[35299], 256], 127511: [[22825], 256], 127512: [[20132], 256], 127513: [[26144], 256], 127514: [[28961], 256], 127515: [[26009], 256], 127516: [[21069], 256], 127517: [[24460], 256], 127518: [[20877], 256], 127519: [[26032], 256], 127520: [[21021], 256], 127521: [[32066], 256], 127522: [[29983], 256], 127523: [[36009], 256], 127524: [[22768], 256], 127525: [[21561], 256], 127526: [[28436], 256], 127527: [[25237], 256], 127528: [[25429], 256], 127529: [[19968], 256], 127530: [[19977], 256], 127531: [[36938], 256], 127532: [[24038], 256], 127533: [[20013], 256], 127534: [[21491], 256], 127535: [[25351], 256], 127536: [[36208], 256], 127537: [[25171], 256], 127538: [[31105], 256], 127539: [[31354], 256], 127540: [[21512], 256], 127541: [[28288], 256], 127542: [[26377], 256], 127543: [[26376], 256], 127544: [[30003], 256], 127545: [[21106], 256], 127546: [[21942], 256], 127552: [[12308, 26412, 12309], 256], 127553: [[12308, 19977, 12309], 256], 127554: [[12308, 20108, 12309], 256], 127555: [[12308, 23433, 12309], 256], 127556: [[12308, 28857, 12309], 256], 127557: [[12308, 25171, 12309], 256], 127558: [[12308, 30423, 12309], 256], 127559: [[12308, 21213, 12309], 256], 127560: [[12308, 25943, 12309], 256], 127568: [[24471], 256], 127569: [[21487], 256] },
  63488: { 194560: [[20029]], 194561: [[20024]], 194562: [[20033]], 194563: [[131362]], 194564: [[20320]], 194565: [[20398]], 194566: [[20411]], 194567: [[20482]], 194568: [[20602]], 194569: [[20633]], 194570: [[20711]], 194571: [[20687]], 194572: [[13470]], 194573: [[132666]], 194574: [[20813]], 194575: [[20820]], 194576: [[20836]], 194577: [[20855]], 194578: [[132380]], 194579: [[13497]], 194580: [[20839]], 194581: [[20877]], 194582: [[132427]], 194583: [[20887]], 194584: [[20900]], 194585: [[20172]], 194586: [[20908]], 194587: [[20917]], 194588: [[168415]], 194589: [[20981]], 194590: [[20995]], 194591: [[13535]], 194592: [[21051]], 194593: [[21062]], 194594: [[21106]], 194595: [[21111]], 194596: [[13589]], 194597: [[21191]], 194598: [[21193]], 194599: [[21220]], 194600: [[21242]], 194601: [[21253]], 194602: [[21254]], 194603: [[21271]], 194604: [[21321]], 194605: [[21329]], 194606: [[21338]], 194607: [[21363]], 194608: [[21373]], 194609: [[21375]], 194610: [[21375]], 194611: [[21375]], 194612: [[133676]], 194613: [[28784]], 194614: [[21450]], 194615: [[21471]], 194616: [[133987]], 194617: [[21483]], 194618: [[21489]], 194619: [[21510]], 194620: [[21662]], 194621: [[21560]], 194622: [[21576]], 194623: [[21608]], 194624: [[21666]], 194625: [[21750]], 194626: [[21776]], 194627: [[21843]], 194628: [[21859]], 194629: [[21892]], 194630: [[21892]], 194631: [[21913]], 194632: [[21931]], 194633: [[21939]], 194634: [[21954]], 194635: [[22294]], 194636: [[22022]], 194637: [[22295]], 194638: [[22097]], 194639: [[22132]], 194640: [[20999]], 194641: [[22766]], 194642: [[22478]], 194643: [[22516]], 194644: [[22541]], 194645: [[22411]], 194646: [[22578]], 194647: [[22577]], 194648: [[22700]], 194649: [[136420]], 194650: [[22770]], 194651: [[22775]], 194652: [[22790]], 194653: [[22810]], 194654: [[22818]], 194655: [[22882]], 194656: [[136872]], 194657: [[136938]], 194658: [[23020]], 194659: [[23067]], 194660: [[23079]], 194661: [[23e3]], 194662: [[23142]], 194663: [[14062]], 194664: [[14076]], 194665: [[23304]], 194666: [[23358]], 194667: [[23358]], 194668: [[137672]], 194669: [[23491]], 194670: [[23512]], 194671: [[23527]], 194672: [[23539]], 194673: [[138008]], 194674: [[23551]], 194675: [[23558]], 194676: [[24403]], 194677: [[23586]], 194678: [[14209]], 194679: [[23648]], 194680: [[23662]], 194681: [[23744]], 194682: [[23693]], 194683: [[138724]], 194684: [[23875]], 194685: [[138726]], 194686: [[23918]], 194687: [[23915]], 194688: [[23932]], 194689: [[24033]], 194690: [[24034]], 194691: [[14383]], 194692: [[24061]], 194693: [[24104]], 194694: [[24125]], 194695: [[24169]], 194696: [[14434]], 194697: [[139651]], 194698: [[14460]], 194699: [[24240]], 194700: [[24243]], 194701: [[24246]], 194702: [[24266]], 194703: [[172946]], 194704: [[24318]], 194705: [[140081]], 194706: [[140081]], 194707: [[33281]], 194708: [[24354]], 194709: [[24354]], 194710: [[14535]], 194711: [[144056]], 194712: [[156122]], 194713: [[24418]], 194714: [[24427]], 194715: [[14563]], 194716: [[24474]], 194717: [[24525]], 194718: [[24535]], 194719: [[24569]], 194720: [[24705]], 194721: [[14650]], 194722: [[14620]], 194723: [[24724]], 194724: [[141012]], 194725: [[24775]], 194726: [[24904]], 194727: [[24908]], 194728: [[24910]], 194729: [[24908]], 194730: [[24954]], 194731: [[24974]], 194732: [[25010]], 194733: [[24996]], 194734: [[25007]], 194735: [[25054]], 194736: [[25074]], 194737: [[25078]], 194738: [[25104]], 194739: [[25115]], 194740: [[25181]], 194741: [[25265]], 194742: [[25300]], 194743: [[25424]], 194744: [[142092]], 194745: [[25405]], 194746: [[25340]], 194747: [[25448]], 194748: [[25475]], 194749: [[25572]], 194750: [[142321]], 194751: [[25634]], 194752: [[25541]], 194753: [[25513]], 194754: [[14894]], 194755: [[25705]], 194756: [[25726]], 194757: [[25757]], 194758: [[25719]], 194759: [[14956]], 194760: [[25935]], 194761: [[25964]], 194762: [[143370]], 194763: [[26083]], 194764: [[26360]], 194765: [[26185]], 194766: [[15129]], 194767: [[26257]], 194768: [[15112]], 194769: [[15076]], 194770: [[20882]], 194771: [[20885]], 194772: [[26368]], 194773: [[26268]], 194774: [[32941]], 194775: [[17369]], 194776: [[26391]], 194777: [[26395]], 194778: [[26401]], 194779: [[26462]], 194780: [[26451]], 194781: [[144323]], 194782: [[15177]], 194783: [[26618]], 194784: [[26501]], 194785: [[26706]], 194786: [[26757]], 194787: [[144493]], 194788: [[26766]], 194789: [[26655]], 194790: [[26900]], 194791: [[15261]], 194792: [[26946]], 194793: [[27043]], 194794: [[27114]], 194795: [[27304]], 194796: [[145059]], 194797: [[27355]], 194798: [[15384]], 194799: [[27425]], 194800: [[145575]], 194801: [[27476]], 194802: [[15438]], 194803: [[27506]], 194804: [[27551]], 194805: [[27578]], 194806: [[27579]], 194807: [[146061]], 194808: [[138507]], 194809: [[146170]], 194810: [[27726]], 194811: [[146620]], 194812: [[27839]], 194813: [[27853]], 194814: [[27751]], 194815: [[27926]] },
  63744: { 63744: [[35912]], 63745: [[26356]], 63746: [[36554]], 63747: [[36040]], 63748: [[28369]], 63749: [[20018]], 63750: [[21477]], 63751: [[40860]], 63752: [[40860]], 63753: [[22865]], 63754: [[37329]], 63755: [[21895]], 63756: [[22856]], 63757: [[25078]], 63758: [[30313]], 63759: [[32645]], 63760: [[34367]], 63761: [[34746]], 63762: [[35064]], 63763: [[37007]], 63764: [[27138]], 63765: [[27931]], 63766: [[28889]], 63767: [[29662]], 63768: [[33853]], 63769: [[37226]], 63770: [[39409]], 63771: [[20098]], 63772: [[21365]], 63773: [[27396]], 63774: [[29211]], 63775: [[34349]], 63776: [[40478]], 63777: [[23888]], 63778: [[28651]], 63779: [[34253]], 63780: [[35172]], 63781: [[25289]], 63782: [[33240]], 63783: [[34847]], 63784: [[24266]], 63785: [[26391]], 63786: [[28010]], 63787: [[29436]], 63788: [[37070]], 63789: [[20358]], 63790: [[20919]], 63791: [[21214]], 63792: [[25796]], 63793: [[27347]], 63794: [[29200]], 63795: [[30439]], 63796: [[32769]], 63797: [[34310]], 63798: [[34396]], 63799: [[36335]], 63800: [[38706]], 63801: [[39791]], 63802: [[40442]], 63803: [[30860]], 63804: [[31103]], 63805: [[32160]], 63806: [[33737]], 63807: [[37636]], 63808: [[40575]], 63809: [[35542]], 63810: [[22751]], 63811: [[24324]], 63812: [[31840]], 63813: [[32894]], 63814: [[29282]], 63815: [[30922]], 63816: [[36034]], 63817: [[38647]], 63818: [[22744]], 63819: [[23650]], 63820: [[27155]], 63821: [[28122]], 63822: [[28431]], 63823: [[32047]], 63824: [[32311]], 63825: [[38475]], 63826: [[21202]], 63827: [[32907]], 63828: [[20956]], 63829: [[20940]], 63830: [[31260]], 63831: [[32190]], 63832: [[33777]], 63833: [[38517]], 63834: [[35712]], 63835: [[25295]], 63836: [[27138]], 63837: [[35582]], 63838: [[20025]], 63839: [[23527]], 63840: [[24594]], 63841: [[29575]], 63842: [[30064]], 63843: [[21271]], 63844: [[30971]], 63845: [[20415]], 63846: [[24489]], 63847: [[19981]], 63848: [[27852]], 63849: [[25976]], 63850: [[32034]], 63851: [[21443]], 63852: [[22622]], 63853: [[30465]], 63854: [[33865]], 63855: [[35498]], 63856: [[27578]], 63857: [[36784]], 63858: [[27784]], 63859: [[25342]], 63860: [[33509]], 63861: [[25504]], 63862: [[30053]], 63863: [[20142]], 63864: [[20841]], 63865: [[20937]], 63866: [[26753]], 63867: [[31975]], 63868: [[33391]], 63869: [[35538]], 63870: [[37327]], 63871: [[21237]], 63872: [[21570]], 63873: [[22899]], 63874: [[24300]], 63875: [[26053]], 63876: [[28670]], 63877: [[31018]], 63878: [[38317]], 63879: [[39530]], 63880: [[40599]], 63881: [[40654]], 63882: [[21147]], 63883: [[26310]], 63884: [[27511]], 63885: [[36706]], 63886: [[24180]], 63887: [[24976]], 63888: [[25088]], 63889: [[25754]], 63890: [[28451]], 63891: [[29001]], 63892: [[29833]], 63893: [[31178]], 63894: [[32244]], 63895: [[32879]], 63896: [[36646]], 63897: [[34030]], 63898: [[36899]], 63899: [[37706]], 63900: [[21015]], 63901: [[21155]], 63902: [[21693]], 63903: [[28872]], 63904: [[35010]], 63905: [[35498]], 63906: [[24265]], 63907: [[24565]], 63908: [[25467]], 63909: [[27566]], 63910: [[31806]], 63911: [[29557]], 63912: [[20196]], 63913: [[22265]], 63914: [[23527]], 63915: [[23994]], 63916: [[24604]], 63917: [[29618]], 63918: [[29801]], 63919: [[32666]], 63920: [[32838]], 63921: [[37428]], 63922: [[38646]], 63923: [[38728]], 63924: [[38936]], 63925: [[20363]], 63926: [[31150]], 63927: [[37300]], 63928: [[38584]], 63929: [[24801]], 63930: [[20102]], 63931: [[20698]], 63932: [[23534]], 63933: [[23615]], 63934: [[26009]], 63935: [[27138]], 63936: [[29134]], 63937: [[30274]], 63938: [[34044]], 63939: [[36988]], 63940: [[40845]], 63941: [[26248]], 63942: [[38446]], 63943: [[21129]], 63944: [[26491]], 63945: [[26611]], 63946: [[27969]], 63947: [[28316]], 63948: [[29705]], 63949: [[30041]], 63950: [[30827]], 63951: [[32016]], 63952: [[39006]], 63953: [[20845]], 63954: [[25134]], 63955: [[38520]], 63956: [[20523]], 63957: [[23833]], 63958: [[28138]], 63959: [[36650]], 63960: [[24459]], 63961: [[24900]], 63962: [[26647]], 63963: [[29575]], 63964: [[38534]], 63965: [[21033]], 63966: [[21519]], 63967: [[23653]], 63968: [[26131]], 63969: [[26446]], 63970: [[26792]], 63971: [[27877]], 63972: [[29702]], 63973: [[30178]], 63974: [[32633]], 63975: [[35023]], 63976: [[35041]], 63977: [[37324]], 63978: [[38626]], 63979: [[21311]], 63980: [[28346]], 63981: [[21533]], 63982: [[29136]], 63983: [[29848]], 63984: [[34298]], 63985: [[38563]], 63986: [[40023]], 63987: [[40607]], 63988: [[26519]], 63989: [[28107]], 63990: [[33256]], 63991: [[31435]], 63992: [[31520]], 63993: [[31890]], 63994: [[29376]], 63995: [[28825]], 63996: [[35672]], 63997: [[20160]], 63998: [[33590]], 63999: [[21050]], 194816: [[27966]], 194817: [[28023]], 194818: [[27969]], 194819: [[28009]], 194820: [[28024]], 194821: [[28037]], 194822: [[146718]], 194823: [[27956]], 194824: [[28207]], 194825: [[28270]], 194826: [[15667]], 194827: [[28363]], 194828: [[28359]], 194829: [[147153]], 194830: [[28153]], 194831: [[28526]], 194832: [[147294]], 194833: [[147342]], 194834: [[28614]], 194835: [[28729]], 194836: [[28702]], 194837: [[28699]], 194838: [[15766]], 194839: [[28746]], 194840: [[28797]], 194841: [[28791]], 194842: [[28845]], 194843: [[132389]], 194844: [[28997]], 194845: [[148067]], 194846: [[29084]], 194847: [[148395]], 194848: [[29224]], 194849: [[29237]], 194850: [[29264]], 194851: [[149e3]], 194852: [[29312]], 194853: [[29333]], 194854: [[149301]], 194855: [[149524]], 194856: [[29562]], 194857: [[29579]], 194858: [[16044]], 194859: [[29605]], 194860: [[16056]], 194861: [[16056]], 194862: [[29767]], 194863: [[29788]], 194864: [[29809]], 194865: [[29829]], 194866: [[29898]], 194867: [[16155]], 194868: [[29988]], 194869: [[150582]], 194870: [[30014]], 194871: [[150674]], 194872: [[30064]], 194873: [[139679]], 194874: [[30224]], 194875: [[151457]], 194876: [[151480]], 194877: [[151620]], 194878: [[16380]], 194879: [[16392]], 194880: [[30452]], 194881: [[151795]], 194882: [[151794]], 194883: [[151833]], 194884: [[151859]], 194885: [[30494]], 194886: [[30495]], 194887: [[30495]], 194888: [[30538]], 194889: [[16441]], 194890: [[30603]], 194891: [[16454]], 194892: [[16534]], 194893: [[152605]], 194894: [[30798]], 194895: [[30860]], 194896: [[30924]], 194897: [[16611]], 194898: [[153126]], 194899: [[31062]], 194900: [[153242]], 194901: [[153285]], 194902: [[31119]], 194903: [[31211]], 194904: [[16687]], 194905: [[31296]], 194906: [[31306]], 194907: [[31311]], 194908: [[153980]], 194909: [[154279]], 194910: [[154279]], 194911: [[31470]], 194912: [[16898]], 194913: [[154539]], 194914: [[31686]], 194915: [[31689]], 194916: [[16935]], 194917: [[154752]], 194918: [[31954]], 194919: [[17056]], 194920: [[31976]], 194921: [[31971]], 194922: [[32e3]], 194923: [[155526]], 194924: [[32099]], 194925: [[17153]], 194926: [[32199]], 194927: [[32258]], 194928: [[32325]], 194929: [[17204]], 194930: [[156200]], 194931: [[156231]], 194932: [[17241]], 194933: [[156377]], 194934: [[32634]], 194935: [[156478]], 194936: [[32661]], 194937: [[32762]], 194938: [[32773]], 194939: [[156890]], 194940: [[156963]], 194941: [[32864]], 194942: [[157096]], 194943: [[32880]], 194944: [[144223]], 194945: [[17365]], 194946: [[32946]], 194947: [[33027]], 194948: [[17419]], 194949: [[33086]], 194950: [[23221]], 194951: [[157607]], 194952: [[157621]], 194953: [[144275]], 194954: [[144284]], 194955: [[33281]], 194956: [[33284]], 194957: [[36766]], 194958: [[17515]], 194959: [[33425]], 194960: [[33419]], 194961: [[33437]], 194962: [[21171]], 194963: [[33457]], 194964: [[33459]], 194965: [[33469]], 194966: [[33510]], 194967: [[158524]], 194968: [[33509]], 194969: [[33565]], 194970: [[33635]], 194971: [[33709]], 194972: [[33571]], 194973: [[33725]], 194974: [[33767]], 194975: [[33879]], 194976: [[33619]], 194977: [[33738]], 194978: [[33740]], 194979: [[33756]], 194980: [[158774]], 194981: [[159083]], 194982: [[158933]], 194983: [[17707]], 194984: [[34033]], 194985: [[34035]], 194986: [[34070]], 194987: [[160714]], 194988: [[34148]], 194989: [[159532]], 194990: [[17757]], 194991: [[17761]], 194992: [[159665]], 194993: [[159954]], 194994: [[17771]], 194995: [[34384]], 194996: [[34396]], 194997: [[34407]], 194998: [[34409]], 194999: [[34473]], 195e3: [[34440]], 195001: [[34574]], 195002: [[34530]], 195003: [[34681]], 195004: [[34600]], 195005: [[34667]], 195006: [[34694]], 195007: [[17879]], 195008: [[34785]], 195009: [[34817]], 195010: [[17913]], 195011: [[34912]], 195012: [[34915]], 195013: [[161383]], 195014: [[35031]], 195015: [[35038]], 195016: [[17973]], 195017: [[35066]], 195018: [[13499]], 195019: [[161966]], 195020: [[162150]], 195021: [[18110]], 195022: [[18119]], 195023: [[35488]], 195024: [[35565]], 195025: [[35722]], 195026: [[35925]], 195027: [[162984]], 195028: [[36011]], 195029: [[36033]], 195030: [[36123]], 195031: [[36215]], 195032: [[163631]], 195033: [[133124]], 195034: [[36299]], 195035: [[36284]], 195036: [[36336]], 195037: [[133342]], 195038: [[36564]], 195039: [[36664]], 195040: [[165330]], 195041: [[165357]], 195042: [[37012]], 195043: [[37105]], 195044: [[37137]], 195045: [[165678]], 195046: [[37147]], 195047: [[37432]], 195048: [[37591]], 195049: [[37592]], 195050: [[37500]], 195051: [[37881]], 195052: [[37909]], 195053: [[166906]], 195054: [[38283]], 195055: [[18837]], 195056: [[38327]], 195057: [[167287]], 195058: [[18918]], 195059: [[38595]], 195060: [[23986]], 195061: [[38691]], 195062: [[168261]], 195063: [[168474]], 195064: [[19054]], 195065: [[19062]], 195066: [[38880]], 195067: [[168970]], 195068: [[19122]], 195069: [[169110]], 195070: [[38923]], 195071: [[38923]] },
  64e3: { 64e3: [[20999]], 64001: [[24230]], 64002: [[25299]], 64003: [[31958]], 64004: [[23429]], 64005: [[27934]], 64006: [[26292]], 64007: [[36667]], 64008: [[34892]], 64009: [[38477]], 64010: [[35211]], 64011: [[24275]], 64012: [[20800]], 64013: [[21952]], 64016: [[22618]], 64018: [[26228]], 64021: [[20958]], 64022: [[29482]], 64023: [[30410]], 64024: [[31036]], 64025: [[31070]], 64026: [[31077]], 64027: [[31119]], 64028: [[38742]], 64029: [[31934]], 64030: [[32701]], 64032: [[34322]], 64034: [[35576]], 64037: [[36920]], 64038: [[37117]], 64042: [[39151]], 64043: [[39164]], 64044: [[39208]], 64045: [[40372]], 64046: [[37086]], 64047: [[38583]], 64048: [[20398]], 64049: [[20711]], 64050: [[20813]], 64051: [[21193]], 64052: [[21220]], 64053: [[21329]], 64054: [[21917]], 64055: [[22022]], 64056: [[22120]], 64057: [[22592]], 64058: [[22696]], 64059: [[23652]], 64060: [[23662]], 64061: [[24724]], 64062: [[24936]], 64063: [[24974]], 64064: [[25074]], 64065: [[25935]], 64066: [[26082]], 64067: [[26257]], 64068: [[26757]], 64069: [[28023]], 64070: [[28186]], 64071: [[28450]], 64072: [[29038]], 64073: [[29227]], 64074: [[29730]], 64075: [[30865]], 64076: [[31038]], 64077: [[31049]], 64078: [[31048]], 64079: [[31056]], 64080: [[31062]], 64081: [[31069]], 64082: [[31117]], 64083: [[31118]], 64084: [[31296]], 64085: [[31361]], 64086: [[31680]], 64087: [[32244]], 64088: [[32265]], 64089: [[32321]], 64090: [[32626]], 64091: [[32773]], 64092: [[33261]], 64093: [[33401]], 64094: [[33401]], 64095: [[33879]], 64096: [[35088]], 64097: [[35222]], 64098: [[35585]], 64099: [[35641]], 64100: [[36051]], 64101: [[36104]], 64102: [[36790]], 64103: [[36920]], 64104: [[38627]], 64105: [[38911]], 64106: [[38971]], 64107: [[24693]], 64108: [[148206]], 64109: [[33304]], 64112: [[20006]], 64113: [[20917]], 64114: [[20840]], 64115: [[20352]], 64116: [[20805]], 64117: [[20864]], 64118: [[21191]], 64119: [[21242]], 64120: [[21917]], 64121: [[21845]], 64122: [[21913]], 64123: [[21986]], 64124: [[22618]], 64125: [[22707]], 64126: [[22852]], 64127: [[22868]], 64128: [[23138]], 64129: [[23336]], 64130: [[24274]], 64131: [[24281]], 64132: [[24425]], 64133: [[24493]], 64134: [[24792]], 64135: [[24910]], 64136: [[24840]], 64137: [[24974]], 64138: [[24928]], 64139: [[25074]], 64140: [[25140]], 64141: [[25540]], 64142: [[25628]], 64143: [[25682]], 64144: [[25942]], 64145: [[26228]], 64146: [[26391]], 64147: [[26395]], 64148: [[26454]], 64149: [[27513]], 64150: [[27578]], 64151: [[27969]], 64152: [[28379]], 64153: [[28363]], 64154: [[28450]], 64155: [[28702]], 64156: [[29038]], 64157: [[30631]], 64158: [[29237]], 64159: [[29359]], 64160: [[29482]], 64161: [[29809]], 64162: [[29958]], 64163: [[30011]], 64164: [[30237]], 64165: [[30239]], 64166: [[30410]], 64167: [[30427]], 64168: [[30452]], 64169: [[30538]], 64170: [[30528]], 64171: [[30924]], 64172: [[31409]], 64173: [[31680]], 64174: [[31867]], 64175: [[32091]], 64176: [[32244]], 64177: [[32574]], 64178: [[32773]], 64179: [[33618]], 64180: [[33775]], 64181: [[34681]], 64182: [[35137]], 64183: [[35206]], 64184: [[35222]], 64185: [[35519]], 64186: [[35576]], 64187: [[35531]], 64188: [[35585]], 64189: [[35582]], 64190: [[35565]], 64191: [[35641]], 64192: [[35722]], 64193: [[36104]], 64194: [[36664]], 64195: [[36978]], 64196: [[37273]], 64197: [[37494]], 64198: [[38524]], 64199: [[38627]], 64200: [[38742]], 64201: [[38875]], 64202: [[38911]], 64203: [[38923]], 64204: [[38971]], 64205: [[39698]], 64206: [[40860]], 64207: [[141386]], 64208: [[141380]], 64209: [[144341]], 64210: [[15261]], 64211: [[16408]], 64212: [[16441]], 64213: [[152137]], 64214: [[154832]], 64215: [[163539]], 64216: [[40771]], 64217: [[40846]], 195072: [[38953]], 195073: [[169398]], 195074: [[39138]], 195075: [[19251]], 195076: [[39209]], 195077: [[39335]], 195078: [[39362]], 195079: [[39422]], 195080: [[19406]], 195081: [[170800]], 195082: [[39698]], 195083: [[4e4]], 195084: [[40189]], 195085: [[19662]], 195086: [[19693]], 195087: [[40295]], 195088: [[172238]], 195089: [[19704]], 195090: [[172293]], 195091: [[172558]], 195092: [[172689]], 195093: [[40635]], 195094: [[19798]], 195095: [[40697]], 195096: [[40702]], 195097: [[40709]], 195098: [[40719]], 195099: [[40726]], 195100: [[40763]], 195101: [[173568]] },
  64256: { 64256: [[102, 102], 256], 64257: [[102, 105], 256], 64258: [[102, 108], 256], 64259: [[102, 102, 105], 256], 64260: [[102, 102, 108], 256], 64261: [[383, 116], 256], 64262: [[115, 116], 256], 64275: [[1396, 1398], 256], 64276: [[1396, 1381], 256], 64277: [[1396, 1387], 256], 64278: [[1406, 1398], 256], 64279: [[1396, 1389], 256], 64285: [[1497, 1460], 512], 64286: [null, 26], 64287: [[1522, 1463], 512], 64288: [[1506], 256], 64289: [[1488], 256], 64290: [[1491], 256], 64291: [[1492], 256], 64292: [[1499], 256], 64293: [[1500], 256], 64294: [[1501], 256], 64295: [[1512], 256], 64296: [[1514], 256], 64297: [[43], 256], 64298: [[1513, 1473], 512], 64299: [[1513, 1474], 512], 64300: [[64329, 1473], 512], 64301: [[64329, 1474], 512], 64302: [[1488, 1463], 512], 64303: [[1488, 1464], 512], 64304: [[1488, 1468], 512], 64305: [[1489, 1468], 512], 64306: [[1490, 1468], 512], 64307: [[1491, 1468], 512], 64308: [[1492, 1468], 512], 64309: [[1493, 1468], 512], 64310: [[1494, 1468], 512], 64312: [[1496, 1468], 512], 64313: [[1497, 1468], 512], 64314: [[1498, 1468], 512], 64315: [[1499, 1468], 512], 64316: [[1500, 1468], 512], 64318: [[1502, 1468], 512], 64320: [[1504, 1468], 512], 64321: [[1505, 1468], 512], 64323: [[1507, 1468], 512], 64324: [[1508, 1468], 512], 64326: [[1510, 1468], 512], 64327: [[1511, 1468], 512], 64328: [[1512, 1468], 512], 64329: [[1513, 1468], 512], 64330: [[1514, 1468], 512], 64331: [[1493, 1465], 512], 64332: [[1489, 1471], 512], 64333: [[1499, 1471], 512], 64334: [[1508, 1471], 512], 64335: [[1488, 1500], 256], 64336: [[1649], 256], 64337: [[1649], 256], 64338: [[1659], 256], 64339: [[1659], 256], 64340: [[1659], 256], 64341: [[1659], 256], 64342: [[1662], 256], 64343: [[1662], 256], 64344: [[1662], 256], 64345: [[1662], 256], 64346: [[1664], 256], 64347: [[1664], 256], 64348: [[1664], 256], 64349: [[1664], 256], 64350: [[1658], 256], 64351: [[1658], 256], 64352: [[1658], 256], 64353: [[1658], 256], 64354: [[1663], 256], 64355: [[1663], 256], 64356: [[1663], 256], 64357: [[1663], 256], 64358: [[1657], 256], 64359: [[1657], 256], 64360: [[1657], 256], 64361: [[1657], 256], 64362: [[1700], 256], 64363: [[1700], 256], 64364: [[1700], 256], 64365: [[1700], 256], 64366: [[1702], 256], 64367: [[1702], 256], 64368: [[1702], 256], 64369: [[1702], 256], 64370: [[1668], 256], 64371: [[1668], 256], 64372: [[1668], 256], 64373: [[1668], 256], 64374: [[1667], 256], 64375: [[1667], 256], 64376: [[1667], 256], 64377: [[1667], 256], 64378: [[1670], 256], 64379: [[1670], 256], 64380: [[1670], 256], 64381: [[1670], 256], 64382: [[1671], 256], 64383: [[1671], 256], 64384: [[1671], 256], 64385: [[1671], 256], 64386: [[1677], 256], 64387: [[1677], 256], 64388: [[1676], 256], 64389: [[1676], 256], 64390: [[1678], 256], 64391: [[1678], 256], 64392: [[1672], 256], 64393: [[1672], 256], 64394: [[1688], 256], 64395: [[1688], 256], 64396: [[1681], 256], 64397: [[1681], 256], 64398: [[1705], 256], 64399: [[1705], 256], 64400: [[1705], 256], 64401: [[1705], 256], 64402: [[1711], 256], 64403: [[1711], 256], 64404: [[1711], 256], 64405: [[1711], 256], 64406: [[1715], 256], 64407: [[1715], 256], 64408: [[1715], 256], 64409: [[1715], 256], 64410: [[1713], 256], 64411: [[1713], 256], 64412: [[1713], 256], 64413: [[1713], 256], 64414: [[1722], 256], 64415: [[1722], 256], 64416: [[1723], 256], 64417: [[1723], 256], 64418: [[1723], 256], 64419: [[1723], 256], 64420: [[1728], 256], 64421: [[1728], 256], 64422: [[1729], 256], 64423: [[1729], 256], 64424: [[1729], 256], 64425: [[1729], 256], 64426: [[1726], 256], 64427: [[1726], 256], 64428: [[1726], 256], 64429: [[1726], 256], 64430: [[1746], 256], 64431: [[1746], 256], 64432: [[1747], 256], 64433: [[1747], 256], 64467: [[1709], 256], 64468: [[1709], 256], 64469: [[1709], 256], 64470: [[1709], 256], 64471: [[1735], 256], 64472: [[1735], 256], 64473: [[1734], 256], 64474: [[1734], 256], 64475: [[1736], 256], 64476: [[1736], 256], 64477: [[1655], 256], 64478: [[1739], 256], 64479: [[1739], 256], 64480: [[1733], 256], 64481: [[1733], 256], 64482: [[1737], 256], 64483: [[1737], 256], 64484: [[1744], 256], 64485: [[1744], 256], 64486: [[1744], 256], 64487: [[1744], 256], 64488: [[1609], 256], 64489: [[1609], 256], 64490: [[1574, 1575], 256], 64491: [[1574, 1575], 256], 64492: [[1574, 1749], 256], 64493: [[1574, 1749], 256], 64494: [[1574, 1608], 256], 64495: [[1574, 1608], 256], 64496: [[1574, 1735], 256], 64497: [[1574, 1735], 256], 64498: [[1574, 1734], 256], 64499: [[1574, 1734], 256], 64500: [[1574, 1736], 256], 64501: [[1574, 1736], 256], 64502: [[1574, 1744], 256], 64503: [[1574, 1744], 256], 64504: [[1574, 1744], 256], 64505: [[1574, 1609], 256], 64506: [[1574, 1609], 256], 64507: [[1574, 1609], 256], 64508: [[1740], 256], 64509: [[1740], 256], 64510: [[1740], 256], 64511: [[1740], 256] },
  64512: { 64512: [[1574, 1580], 256], 64513: [[1574, 1581], 256], 64514: [[1574, 1605], 256], 64515: [[1574, 1609], 256], 64516: [[1574, 1610], 256], 64517: [[1576, 1580], 256], 64518: [[1576, 1581], 256], 64519: [[1576, 1582], 256], 64520: [[1576, 1605], 256], 64521: [[1576, 1609], 256], 64522: [[1576, 1610], 256], 64523: [[1578, 1580], 256], 64524: [[1578, 1581], 256], 64525: [[1578, 1582], 256], 64526: [[1578, 1605], 256], 64527: [[1578, 1609], 256], 64528: [[1578, 1610], 256], 64529: [[1579, 1580], 256], 64530: [[1579, 1605], 256], 64531: [[1579, 1609], 256], 64532: [[1579, 1610], 256], 64533: [[1580, 1581], 256], 64534: [[1580, 1605], 256], 64535: [[1581, 1580], 256], 64536: [[1581, 1605], 256], 64537: [[1582, 1580], 256], 64538: [[1582, 1581], 256], 64539: [[1582, 1605], 256], 64540: [[1587, 1580], 256], 64541: [[1587, 1581], 256], 64542: [[1587, 1582], 256], 64543: [[1587, 1605], 256], 64544: [[1589, 1581], 256], 64545: [[1589, 1605], 256], 64546: [[1590, 1580], 256], 64547: [[1590, 1581], 256], 64548: [[1590, 1582], 256], 64549: [[1590, 1605], 256], 64550: [[1591, 1581], 256], 64551: [[1591, 1605], 256], 64552: [[1592, 1605], 256], 64553: [[1593, 1580], 256], 64554: [[1593, 1605], 256], 64555: [[1594, 1580], 256], 64556: [[1594, 1605], 256], 64557: [[1601, 1580], 256], 64558: [[1601, 1581], 256], 64559: [[1601, 1582], 256], 64560: [[1601, 1605], 256], 64561: [[1601, 1609], 256], 64562: [[1601, 1610], 256], 64563: [[1602, 1581], 256], 64564: [[1602, 1605], 256], 64565: [[1602, 1609], 256], 64566: [[1602, 1610], 256], 64567: [[1603, 1575], 256], 64568: [[1603, 1580], 256], 64569: [[1603, 1581], 256], 64570: [[1603, 1582], 256], 64571: [[1603, 1604], 256], 64572: [[1603, 1605], 256], 64573: [[1603, 1609], 256], 64574: [[1603, 1610], 256], 64575: [[1604, 1580], 256], 64576: [[1604, 1581], 256], 64577: [[1604, 1582], 256], 64578: [[1604, 1605], 256], 64579: [[1604, 1609], 256], 64580: [[1604, 1610], 256], 64581: [[1605, 1580], 256], 64582: [[1605, 1581], 256], 64583: [[1605, 1582], 256], 64584: [[1605, 1605], 256], 64585: [[1605, 1609], 256], 64586: [[1605, 1610], 256], 64587: [[1606, 1580], 256], 64588: [[1606, 1581], 256], 64589: [[1606, 1582], 256], 64590: [[1606, 1605], 256], 64591: [[1606, 1609], 256], 64592: [[1606, 1610], 256], 64593: [[1607, 1580], 256], 64594: [[1607, 1605], 256], 64595: [[1607, 1609], 256], 64596: [[1607, 1610], 256], 64597: [[1610, 1580], 256], 64598: [[1610, 1581], 256], 64599: [[1610, 1582], 256], 64600: [[1610, 1605], 256], 64601: [[1610, 1609], 256], 64602: [[1610, 1610], 256], 64603: [[1584, 1648], 256], 64604: [[1585, 1648], 256], 64605: [[1609, 1648], 256], 64606: [[32, 1612, 1617], 256], 64607: [[32, 1613, 1617], 256], 64608: [[32, 1614, 1617], 256], 64609: [[32, 1615, 1617], 256], 64610: [[32, 1616, 1617], 256], 64611: [[32, 1617, 1648], 256], 64612: [[1574, 1585], 256], 64613: [[1574, 1586], 256], 64614: [[1574, 1605], 256], 64615: [[1574, 1606], 256], 64616: [[1574, 1609], 256], 64617: [[1574, 1610], 256], 64618: [[1576, 1585], 256], 64619: [[1576, 1586], 256], 64620: [[1576, 1605], 256], 64621: [[1576, 1606], 256], 64622: [[1576, 1609], 256], 64623: [[1576, 1610], 256], 64624: [[1578, 1585], 256], 64625: [[1578, 1586], 256], 64626: [[1578, 1605], 256], 64627: [[1578, 1606], 256], 64628: [[1578, 1609], 256], 64629: [[1578, 1610], 256], 64630: [[1579, 1585], 256], 64631: [[1579, 1586], 256], 64632: [[1579, 1605], 256], 64633: [[1579, 1606], 256], 64634: [[1579, 1609], 256], 64635: [[1579, 1610], 256], 64636: [[1601, 1609], 256], 64637: [[1601, 1610], 256], 64638: [[1602, 1609], 256], 64639: [[1602, 1610], 256], 64640: [[1603, 1575], 256], 64641: [[1603, 1604], 256], 64642: [[1603, 1605], 256], 64643: [[1603, 1609], 256], 64644: [[1603, 1610], 256], 64645: [[1604, 1605], 256], 64646: [[1604, 1609], 256], 64647: [[1604, 1610], 256], 64648: [[1605, 1575], 256], 64649: [[1605, 1605], 256], 64650: [[1606, 1585], 256], 64651: [[1606, 1586], 256], 64652: [[1606, 1605], 256], 64653: [[1606, 1606], 256], 64654: [[1606, 1609], 256], 64655: [[1606, 1610], 256], 64656: [[1609, 1648], 256], 64657: [[1610, 1585], 256], 64658: [[1610, 1586], 256], 64659: [[1610, 1605], 256], 64660: [[1610, 1606], 256], 64661: [[1610, 1609], 256], 64662: [[1610, 1610], 256], 64663: [[1574, 1580], 256], 64664: [[1574, 1581], 256], 64665: [[1574, 1582], 256], 64666: [[1574, 1605], 256], 64667: [[1574, 1607], 256], 64668: [[1576, 1580], 256], 64669: [[1576, 1581], 256], 64670: [[1576, 1582], 256], 64671: [[1576, 1605], 256], 64672: [[1576, 1607], 256], 64673: [[1578, 1580], 256], 64674: [[1578, 1581], 256], 64675: [[1578, 1582], 256], 64676: [[1578, 1605], 256], 64677: [[1578, 1607], 256], 64678: [[1579, 1605], 256], 64679: [[1580, 1581], 256], 64680: [[1580, 1605], 256], 64681: [[1581, 1580], 256], 64682: [[1581, 1605], 256], 64683: [[1582, 1580], 256], 64684: [[1582, 1605], 256], 64685: [[1587, 1580], 256], 64686: [[1587, 1581], 256], 64687: [[1587, 1582], 256], 64688: [[1587, 1605], 256], 64689: [[1589, 1581], 256], 64690: [[1589, 1582], 256], 64691: [[1589, 1605], 256], 64692: [[1590, 1580], 256], 64693: [[1590, 1581], 256], 64694: [[1590, 1582], 256], 64695: [[1590, 1605], 256], 64696: [[1591, 1581], 256], 64697: [[1592, 1605], 256], 64698: [[1593, 1580], 256], 64699: [[1593, 1605], 256], 64700: [[1594, 1580], 256], 64701: [[1594, 1605], 256], 64702: [[1601, 1580], 256], 64703: [[1601, 1581], 256], 64704: [[1601, 1582], 256], 64705: [[1601, 1605], 256], 64706: [[1602, 1581], 256], 64707: [[1602, 1605], 256], 64708: [[1603, 1580], 256], 64709: [[1603, 1581], 256], 64710: [[1603, 1582], 256], 64711: [[1603, 1604], 256], 64712: [[1603, 1605], 256], 64713: [[1604, 1580], 256], 64714: [[1604, 1581], 256], 64715: [[1604, 1582], 256], 64716: [[1604, 1605], 256], 64717: [[1604, 1607], 256], 64718: [[1605, 1580], 256], 64719: [[1605, 1581], 256], 64720: [[1605, 1582], 256], 64721: [[1605, 1605], 256], 64722: [[1606, 1580], 256], 64723: [[1606, 1581], 256], 64724: [[1606, 1582], 256], 64725: [[1606, 1605], 256], 64726: [[1606, 1607], 256], 64727: [[1607, 1580], 256], 64728: [[1607, 1605], 256], 64729: [[1607, 1648], 256], 64730: [[1610, 1580], 256], 64731: [[1610, 1581], 256], 64732: [[1610, 1582], 256], 64733: [[1610, 1605], 256], 64734: [[1610, 1607], 256], 64735: [[1574, 1605], 256], 64736: [[1574, 1607], 256], 64737: [[1576, 1605], 256], 64738: [[1576, 1607], 256], 64739: [[1578, 1605], 256], 64740: [[1578, 1607], 256], 64741: [[1579, 1605], 256], 64742: [[1579, 1607], 256], 64743: [[1587, 1605], 256], 64744: [[1587, 1607], 256], 64745: [[1588, 1605], 256], 64746: [[1588, 1607], 256], 64747: [[1603, 1604], 256], 64748: [[1603, 1605], 256], 64749: [[1604, 1605], 256], 64750: [[1606, 1605], 256], 64751: [[1606, 1607], 256], 64752: [[1610, 1605], 256], 64753: [[1610, 1607], 256], 64754: [[1600, 1614, 1617], 256], 64755: [[1600, 1615, 1617], 256], 64756: [[1600, 1616, 1617], 256], 64757: [[1591, 1609], 256], 64758: [[1591, 1610], 256], 64759: [[1593, 1609], 256], 64760: [[1593, 1610], 256], 64761: [[1594, 1609], 256], 64762: [[1594, 1610], 256], 64763: [[1587, 1609], 256], 64764: [[1587, 1610], 256], 64765: [[1588, 1609], 256], 64766: [[1588, 1610], 256], 64767: [[1581, 1609], 256] },
  64768: { 64768: [[1581, 1610], 256], 64769: [[1580, 1609], 256], 64770: [[1580, 1610], 256], 64771: [[1582, 1609], 256], 64772: [[1582, 1610], 256], 64773: [[1589, 1609], 256], 64774: [[1589, 1610], 256], 64775: [[1590, 1609], 256], 64776: [[1590, 1610], 256], 64777: [[1588, 1580], 256], 64778: [[1588, 1581], 256], 64779: [[1588, 1582], 256], 64780: [[1588, 1605], 256], 64781: [[1588, 1585], 256], 64782: [[1587, 1585], 256], 64783: [[1589, 1585], 256], 64784: [[1590, 1585], 256], 64785: [[1591, 1609], 256], 64786: [[1591, 1610], 256], 64787: [[1593, 1609], 256], 64788: [[1593, 1610], 256], 64789: [[1594, 1609], 256], 64790: [[1594, 1610], 256], 64791: [[1587, 1609], 256], 64792: [[1587, 1610], 256], 64793: [[1588, 1609], 256], 64794: [[1588, 1610], 256], 64795: [[1581, 1609], 256], 64796: [[1581, 1610], 256], 64797: [[1580, 1609], 256], 64798: [[1580, 1610], 256], 64799: [[1582, 1609], 256], 64800: [[1582, 1610], 256], 64801: [[1589, 1609], 256], 64802: [[1589, 1610], 256], 64803: [[1590, 1609], 256], 64804: [[1590, 1610], 256], 64805: [[1588, 1580], 256], 64806: [[1588, 1581], 256], 64807: [[1588, 1582], 256], 64808: [[1588, 1605], 256], 64809: [[1588, 1585], 256], 64810: [[1587, 1585], 256], 64811: [[1589, 1585], 256], 64812: [[1590, 1585], 256], 64813: [[1588, 1580], 256], 64814: [[1588, 1581], 256], 64815: [[1588, 1582], 256], 64816: [[1588, 1605], 256], 64817: [[1587, 1607], 256], 64818: [[1588, 1607], 256], 64819: [[1591, 1605], 256], 64820: [[1587, 1580], 256], 64821: [[1587, 1581], 256], 64822: [[1587, 1582], 256], 64823: [[1588, 1580], 256], 64824: [[1588, 1581], 256], 64825: [[1588, 1582], 256], 64826: [[1591, 1605], 256], 64827: [[1592, 1605], 256], 64828: [[1575, 1611], 256], 64829: [[1575, 1611], 256], 64848: [[1578, 1580, 1605], 256], 64849: [[1578, 1581, 1580], 256], 64850: [[1578, 1581, 1580], 256], 64851: [[1578, 1581, 1605], 256], 64852: [[1578, 1582, 1605], 256], 64853: [[1578, 1605, 1580], 256], 64854: [[1578, 1605, 1581], 256], 64855: [[1578, 1605, 1582], 256], 64856: [[1580, 1605, 1581], 256], 64857: [[1580, 1605, 1581], 256], 64858: [[1581, 1605, 1610], 256], 64859: [[1581, 1605, 1609], 256], 64860: [[1587, 1581, 1580], 256], 64861: [[1587, 1580, 1581], 256], 64862: [[1587, 1580, 1609], 256], 64863: [[1587, 1605, 1581], 256], 64864: [[1587, 1605, 1581], 256], 64865: [[1587, 1605, 1580], 256], 64866: [[1587, 1605, 1605], 256], 64867: [[1587, 1605, 1605], 256], 64868: [[1589, 1581, 1581], 256], 64869: [[1589, 1581, 1581], 256], 64870: [[1589, 1605, 1605], 256], 64871: [[1588, 1581, 1605], 256], 64872: [[1588, 1581, 1605], 256], 64873: [[1588, 1580, 1610], 256], 64874: [[1588, 1605, 1582], 256], 64875: [[1588, 1605, 1582], 256], 64876: [[1588, 1605, 1605], 256], 64877: [[1588, 1605, 1605], 256], 64878: [[1590, 1581, 1609], 256], 64879: [[1590, 1582, 1605], 256], 64880: [[1590, 1582, 1605], 256], 64881: [[1591, 1605, 1581], 256], 64882: [[1591, 1605, 1581], 256], 64883: [[1591, 1605, 1605], 256], 64884: [[1591, 1605, 1610], 256], 64885: [[1593, 1580, 1605], 256], 64886: [[1593, 1605, 1605], 256], 64887: [[1593, 1605, 1605], 256], 64888: [[1593, 1605, 1609], 256], 64889: [[1594, 1605, 1605], 256], 64890: [[1594, 1605, 1610], 256], 64891: [[1594, 1605, 1609], 256], 64892: [[1601, 1582, 1605], 256], 64893: [[1601, 1582, 1605], 256], 64894: [[1602, 1605, 1581], 256], 64895: [[1602, 1605, 1605], 256], 64896: [[1604, 1581, 1605], 256], 64897: [[1604, 1581, 1610], 256], 64898: [[1604, 1581, 1609], 256], 64899: [[1604, 1580, 1580], 256], 64900: [[1604, 1580, 1580], 256], 64901: [[1604, 1582, 1605], 256], 64902: [[1604, 1582, 1605], 256], 64903: [[1604, 1605, 1581], 256], 64904: [[1604, 1605, 1581], 256], 64905: [[1605, 1581, 1580], 256], 64906: [[1605, 1581, 1605], 256], 64907: [[1605, 1581, 1610], 256], 64908: [[1605, 1580, 1581], 256], 64909: [[1605, 1580, 1605], 256], 64910: [[1605, 1582, 1580], 256], 64911: [[1605, 1582, 1605], 256], 64914: [[1605, 1580, 1582], 256], 64915: [[1607, 1605, 1580], 256], 64916: [[1607, 1605, 1605], 256], 64917: [[1606, 1581, 1605], 256], 64918: [[1606, 1581, 1609], 256], 64919: [[1606, 1580, 1605], 256], 64920: [[1606, 1580, 1605], 256], 64921: [[1606, 1580, 1609], 256], 64922: [[1606, 1605, 1610], 256], 64923: [[1606, 1605, 1609], 256], 64924: [[1610, 1605, 1605], 256], 64925: [[1610, 1605, 1605], 256], 64926: [[1576, 1582, 1610], 256], 64927: [[1578, 1580, 1610], 256], 64928: [[1578, 1580, 1609], 256], 64929: [[1578, 1582, 1610], 256], 64930: [[1578, 1582, 1609], 256], 64931: [[1578, 1605, 1610], 256], 64932: [[1578, 1605, 1609], 256], 64933: [[1580, 1605, 1610], 256], 64934: [[1580, 1581, 1609], 256], 64935: [[1580, 1605, 1609], 256], 64936: [[1587, 1582, 1609], 256], 64937: [[1589, 1581, 1610], 256], 64938: [[1588, 1581, 1610], 256], 64939: [[1590, 1581, 1610], 256], 64940: [[1604, 1580, 1610], 256], 64941: [[1604, 1605, 1610], 256], 64942: [[1610, 1581, 1610], 256], 64943: [[1610, 1580, 1610], 256], 64944: [[1610, 1605, 1610], 256], 64945: [[1605, 1605, 1610], 256], 64946: [[1602, 1605, 1610], 256], 64947: [[1606, 1581, 1610], 256], 64948: [[1602, 1605, 1581], 256], 64949: [[1604, 1581, 1605], 256], 64950: [[1593, 1605, 1610], 256], 64951: [[1603, 1605, 1610], 256], 64952: [[1606, 1580, 1581], 256], 64953: [[1605, 1582, 1610], 256], 64954: [[1604, 1580, 1605], 256], 64955: [[1603, 1605, 1605], 256], 64956: [[1604, 1580, 1605], 256], 64957: [[1606, 1580, 1581], 256], 64958: [[1580, 1581, 1610], 256], 64959: [[1581, 1580, 1610], 256], 64960: [[1605, 1580, 1610], 256], 64961: [[1601, 1605, 1610], 256], 64962: [[1576, 1581, 1610], 256], 64963: [[1603, 1605, 1605], 256], 64964: [[1593, 1580, 1605], 256], 64965: [[1589, 1605, 1605], 256], 64966: [[1587, 1582, 1610], 256], 64967: [[1606, 1580, 1610], 256], 65008: [[1589, 1604, 1746], 256], 65009: [[1602, 1604, 1746], 256], 65010: [[1575, 1604, 1604, 1607], 256], 65011: [[1575, 1603, 1576, 1585], 256], 65012: [[1605, 1581, 1605, 1583], 256], 65013: [[1589, 1604, 1593, 1605], 256], 65014: [[1585, 1587, 1608, 1604], 256], 65015: [[1593, 1604, 1610, 1607], 256], 65016: [[1608, 1587, 1604, 1605], 256], 65017: [[1589, 1604, 1609], 256], 65018: [[1589, 1604, 1609, 32, 1575, 1604, 1604, 1607, 32, 1593, 1604, 1610, 1607, 32, 1608, 1587, 1604, 1605], 256], 65019: [[1580, 1604, 32, 1580, 1604, 1575, 1604, 1607], 256], 65020: [[1585, 1740, 1575, 1604], 256] },
  65024: { 65040: [[44], 256], 65041: [[12289], 256], 65042: [[12290], 256], 65043: [[58], 256], 65044: [[59], 256], 65045: [[33], 256], 65046: [[63], 256], 65047: [[12310], 256], 65048: [[12311], 256], 65049: [[8230], 256], 65056: [null, 230], 65057: [null, 230], 65058: [null, 230], 65059: [null, 230], 65060: [null, 230], 65061: [null, 230], 65062: [null, 230], 65063: [null, 220], 65064: [null, 220], 65065: [null, 220], 65066: [null, 220], 65067: [null, 220], 65068: [null, 220], 65069: [null, 220], 65072: [[8229], 256], 65073: [[8212], 256], 65074: [[8211], 256], 65075: [[95], 256], 65076: [[95], 256], 65077: [[40], 256], 65078: [[41], 256], 65079: [[123], 256], 65080: [[125], 256], 65081: [[12308], 256], 65082: [[12309], 256], 65083: [[12304], 256], 65084: [[12305], 256], 65085: [[12298], 256], 65086: [[12299], 256], 65087: [[12296], 256], 65088: [[12297], 256], 65089: [[12300], 256], 65090: [[12301], 256], 65091: [[12302], 256], 65092: [[12303], 256], 65095: [[91], 256], 65096: [[93], 256], 65097: [[8254], 256], 65098: [[8254], 256], 65099: [[8254], 256], 65100: [[8254], 256], 65101: [[95], 256], 65102: [[95], 256], 65103: [[95], 256], 65104: [[44], 256], 65105: [[12289], 256], 65106: [[46], 256], 65108: [[59], 256], 65109: [[58], 256], 65110: [[63], 256], 65111: [[33], 256], 65112: [[8212], 256], 65113: [[40], 256], 65114: [[41], 256], 65115: [[123], 256], 65116: [[125], 256], 65117: [[12308], 256], 65118: [[12309], 256], 65119: [[35], 256], 65120: [[38], 256], 65121: [[42], 256], 65122: [[43], 256], 65123: [[45], 256], 65124: [[60], 256], 65125: [[62], 256], 65126: [[61], 256], 65128: [[92], 256], 65129: [[36], 256], 65130: [[37], 256], 65131: [[64], 256], 65136: [[32, 1611], 256], 65137: [[1600, 1611], 256], 65138: [[32, 1612], 256], 65140: [[32, 1613], 256], 65142: [[32, 1614], 256], 65143: [[1600, 1614], 256], 65144: [[32, 1615], 256], 65145: [[1600, 1615], 256], 65146: [[32, 1616], 256], 65147: [[1600, 1616], 256], 65148: [[32, 1617], 256], 65149: [[1600, 1617], 256], 65150: [[32, 1618], 256], 65151: [[1600, 1618], 256], 65152: [[1569], 256], 65153: [[1570], 256], 65154: [[1570], 256], 65155: [[1571], 256], 65156: [[1571], 256], 65157: [[1572], 256], 65158: [[1572], 256], 65159: [[1573], 256], 65160: [[1573], 256], 65161: [[1574], 256], 65162: [[1574], 256], 65163: [[1574], 256], 65164: [[1574], 256], 65165: [[1575], 256], 65166: [[1575], 256], 65167: [[1576], 256], 65168: [[1576], 256], 65169: [[1576], 256], 65170: [[1576], 256], 65171: [[1577], 256], 65172: [[1577], 256], 65173: [[1578], 256], 65174: [[1578], 256], 65175: [[1578], 256], 65176: [[1578], 256], 65177: [[1579], 256], 65178: [[1579], 256], 65179: [[1579], 256], 65180: [[1579], 256], 65181: [[1580], 256], 65182: [[1580], 256], 65183: [[1580], 256], 65184: [[1580], 256], 65185: [[1581], 256], 65186: [[1581], 256], 65187: [[1581], 256], 65188: [[1581], 256], 65189: [[1582], 256], 65190: [[1582], 256], 65191: [[1582], 256], 65192: [[1582], 256], 65193: [[1583], 256], 65194: [[1583], 256], 65195: [[1584], 256], 65196: [[1584], 256], 65197: [[1585], 256], 65198: [[1585], 256], 65199: [[1586], 256], 65200: [[1586], 256], 65201: [[1587], 256], 65202: [[1587], 256], 65203: [[1587], 256], 65204: [[1587], 256], 65205: [[1588], 256], 65206: [[1588], 256], 65207: [[1588], 256], 65208: [[1588], 256], 65209: [[1589], 256], 65210: [[1589], 256], 65211: [[1589], 256], 65212: [[1589], 256], 65213: [[1590], 256], 65214: [[1590], 256], 65215: [[1590], 256], 65216: [[1590], 256], 65217: [[1591], 256], 65218: [[1591], 256], 65219: [[1591], 256], 65220: [[1591], 256], 65221: [[1592], 256], 65222: [[1592], 256], 65223: [[1592], 256], 65224: [[1592], 256], 65225: [[1593], 256], 65226: [[1593], 256], 65227: [[1593], 256], 65228: [[1593], 256], 65229: [[1594], 256], 65230: [[1594], 256], 65231: [[1594], 256], 65232: [[1594], 256], 65233: [[1601], 256], 65234: [[1601], 256], 65235: [[1601], 256], 65236: [[1601], 256], 65237: [[1602], 256], 65238: [[1602], 256], 65239: [[1602], 256], 65240: [[1602], 256], 65241: [[1603], 256], 65242: [[1603], 256], 65243: [[1603], 256], 65244: [[1603], 256], 65245: [[1604], 256], 65246: [[1604], 256], 65247: [[1604], 256], 65248: [[1604], 256], 65249: [[1605], 256], 65250: [[1605], 256], 65251: [[1605], 256], 65252: [[1605], 256], 65253: [[1606], 256], 65254: [[1606], 256], 65255: [[1606], 256], 65256: [[1606], 256], 65257: [[1607], 256], 65258: [[1607], 256], 65259: [[1607], 256], 65260: [[1607], 256], 65261: [[1608], 256], 65262: [[1608], 256], 65263: [[1609], 256], 65264: [[1609], 256], 65265: [[1610], 256], 65266: [[1610], 256], 65267: [[1610], 256], 65268: [[1610], 256], 65269: [[1604, 1570], 256], 65270: [[1604, 1570], 256], 65271: [[1604, 1571], 256], 65272: [[1604, 1571], 256], 65273: [[1604, 1573], 256], 65274: [[1604, 1573], 256], 65275: [[1604, 1575], 256], 65276: [[1604, 1575], 256] },
  65280: { 65281: [[33], 256], 65282: [[34], 256], 65283: [[35], 256], 65284: [[36], 256], 65285: [[37], 256], 65286: [[38], 256], 65287: [[39], 256], 65288: [[40], 256], 65289: [[41], 256], 65290: [[42], 256], 65291: [[43], 256], 65292: [[44], 256], 65293: [[45], 256], 65294: [[46], 256], 65295: [[47], 256], 65296: [[48], 256], 65297: [[49], 256], 65298: [[50], 256], 65299: [[51], 256], 65300: [[52], 256], 65301: [[53], 256], 65302: [[54], 256], 65303: [[55], 256], 65304: [[56], 256], 65305: [[57], 256], 65306: [[58], 256], 65307: [[59], 256], 65308: [[60], 256], 65309: [[61], 256], 65310: [[62], 256], 65311: [[63], 256], 65312: [[64], 256], 65313: [[65], 256], 65314: [[66], 256], 65315: [[67], 256], 65316: [[68], 256], 65317: [[69], 256], 65318: [[70], 256], 65319: [[71], 256], 65320: [[72], 256], 65321: [[73], 256], 65322: [[74], 256], 65323: [[75], 256], 65324: [[76], 256], 65325: [[77], 256], 65326: [[78], 256], 65327: [[79], 256], 65328: [[80], 256], 65329: [[81], 256], 65330: [[82], 256], 65331: [[83], 256], 65332: [[84], 256], 65333: [[85], 256], 65334: [[86], 256], 65335: [[87], 256], 65336: [[88], 256], 65337: [[89], 256], 65338: [[90], 256], 65339: [[91], 256], 65340: [[92], 256], 65341: [[93], 256], 65342: [[94], 256], 65343: [[95], 256], 65344: [[96], 256], 65345: [[97], 256], 65346: [[98], 256], 65347: [[99], 256], 65348: [[100], 256], 65349: [[101], 256], 65350: [[102], 256], 65351: [[103], 256], 65352: [[104], 256], 65353: [[105], 256], 65354: [[106], 256], 65355: [[107], 256], 65356: [[108], 256], 65357: [[109], 256], 65358: [[110], 256], 65359: [[111], 256], 65360: [[112], 256], 65361: [[113], 256], 65362: [[114], 256], 65363: [[115], 256], 65364: [[116], 256], 65365: [[117], 256], 65366: [[118], 256], 65367: [[119], 256], 65368: [[120], 256], 65369: [[121], 256], 65370: [[122], 256], 65371: [[123], 256], 65372: [[124], 256], 65373: [[125], 256], 65374: [[126], 256], 65375: [[10629], 256], 65376: [[10630], 256], 65377: [[12290], 256], 65378: [[12300], 256], 65379: [[12301], 256], 65380: [[12289], 256], 65381: [[12539], 256], 65382: [[12530], 256], 65383: [[12449], 256], 65384: [[12451], 256], 65385: [[12453], 256], 65386: [[12455], 256], 65387: [[12457], 256], 65388: [[12515], 256], 65389: [[12517], 256], 65390: [[12519], 256], 65391: [[12483], 256], 65392: [[12540], 256], 65393: [[12450], 256], 65394: [[12452], 256], 65395: [[12454], 256], 65396: [[12456], 256], 65397: [[12458], 256], 65398: [[12459], 256], 65399: [[12461], 256], 65400: [[12463], 256], 65401: [[12465], 256], 65402: [[12467], 256], 65403: [[12469], 256], 65404: [[12471], 256], 65405: [[12473], 256], 65406: [[12475], 256], 65407: [[12477], 256], 65408: [[12479], 256], 65409: [[12481], 256], 65410: [[12484], 256], 65411: [[12486], 256], 65412: [[12488], 256], 65413: [[12490], 256], 65414: [[12491], 256], 65415: [[12492], 256], 65416: [[12493], 256], 65417: [[12494], 256], 65418: [[12495], 256], 65419: [[12498], 256], 65420: [[12501], 256], 65421: [[12504], 256], 65422: [[12507], 256], 65423: [[12510], 256], 65424: [[12511], 256], 65425: [[12512], 256], 65426: [[12513], 256], 65427: [[12514], 256], 65428: [[12516], 256], 65429: [[12518], 256], 65430: [[12520], 256], 65431: [[12521], 256], 65432: [[12522], 256], 65433: [[12523], 256], 65434: [[12524], 256], 65435: [[12525], 256], 65436: [[12527], 256], 65437: [[12531], 256], 65438: [[12441], 256], 65439: [[12442], 256], 65440: [[12644], 256], 65441: [[12593], 256], 65442: [[12594], 256], 65443: [[12595], 256], 65444: [[12596], 256], 65445: [[12597], 256], 65446: [[12598], 256], 65447: [[12599], 256], 65448: [[12600], 256], 65449: [[12601], 256], 65450: [[12602], 256], 65451: [[12603], 256], 65452: [[12604], 256], 65453: [[12605], 256], 65454: [[12606], 256], 65455: [[12607], 256], 65456: [[12608], 256], 65457: [[12609], 256], 65458: [[12610], 256], 65459: [[12611], 256], 65460: [[12612], 256], 65461: [[12613], 256], 65462: [[12614], 256], 65463: [[12615], 256], 65464: [[12616], 256], 65465: [[12617], 256], 65466: [[12618], 256], 65467: [[12619], 256], 65468: [[12620], 256], 65469: [[12621], 256], 65470: [[12622], 256], 65474: [[12623], 256], 65475: [[12624], 256], 65476: [[12625], 256], 65477: [[12626], 256], 65478: [[12627], 256], 65479: [[12628], 256], 65482: [[12629], 256], 65483: [[12630], 256], 65484: [[12631], 256], 65485: [[12632], 256], 65486: [[12633], 256], 65487: [[12634], 256], 65490: [[12635], 256], 65491: [[12636], 256], 65492: [[12637], 256], 65493: [[12638], 256], 65494: [[12639], 256], 65495: [[12640], 256], 65498: [[12641], 256], 65499: [[12642], 256], 65500: [[12643], 256], 65504: [[162], 256], 65505: [[163], 256], 65506: [[172], 256], 65507: [[175], 256], 65508: [[166], 256], 65509: [[165], 256], 65510: [[8361], 256], 65512: [[9474], 256], 65513: [[8592], 256], 65514: [[8593], 256], 65515: [[8594], 256], 65516: [[8595], 256], 65517: [[9632], 256], 65518: [[9675], 256] }
};
/*!
 * Unorm
 * https://github.com/walling/unorm
 *
 * The software dual licensed under the MIT and GPL licenses. MIT license:
 *
 * Copyright (c) 2008-2013
 * Matsuza <matsuza@gmail.com>,
 * Bjarke Walling <bwp@bwp.dk>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *
 * GPL notice (please read the [full GPL license] online):
 *
 * Copyright (C) 2008-2013
 * Matsuza <matsuza@gmail.com>,
 * Bjarke Walling <bwp@bwp.dk>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 * [full GPL license]: http://www.gnu.org/licenses/gpl-2.0-standalone.html
*/
var j3;
function py() {
  if (j3) return tn;
  j3 = 1;
  const e = by, c = [null, 0, {}], l = 10, w = 44032, m = 4352, f = 4449, n = 4519, u = 19, o = 21, s = 28, i = o * s, p = u * i, g = {}, S = [];
  for (let ae = 0; ae <= 255; ae++)
    S[ae] = 0;
  let y = null;
  class b {
    constructor(D, Q) {
      this.codepoint = D, this.feature = Q;
    }
    static isHighSurrogate(D) {
      return D >= 55296 && D <= 56319;
    }
    static isLowSurrogate(D) {
      return D >= 56320 && D <= 57343;
    }
    prepFeature() {
      this.feature || (this.feature = y(this.codepoint, !0).feature);
    }
    toString() {
      if (this.codepoint < 65536)
        return String.fromCharCode(this.codepoint);
      const D = this.codepoint - 65536;
      return String.fromCharCode(
        Math.floor(D / 1024) + 55296,
        D % 1024 + 56320
      );
    }
    getDecomp() {
      return this.prepFeature(), this.feature[0] || null;
    }
    isCompatibility() {
      return this.prepFeature(), !!this.feature[1] && (this.feature[1] & 256) !== 0;
    }
    isExclude() {
      return this.prepFeature(), !!this.feature[1] && (this.feature[1] & 512) !== 0;
    }
    getCanonicalClass() {
      return this.prepFeature(), this.feature[1] ? this.feature[1] & 255 : 0;
    }
    getComposite(D) {
      if (this.prepFeature(), !this.feature[2])
        return null;
      const Q = this.feature[2][D.codepoint];
      return Q ? y(Q) : null;
    }
  }
  function h(ae, D, Q) {
    let W = g[D];
    return W || (W = ae(D, Q), W.feature && ++S[D >> 8 & 255] > l && (g[D] = W)), W;
  }
  function a(ae, D, Q) {
    const W = D & 65280, v = (e[W] || {})[D];
    return v ? new b(D, v) : new b(D, c);
  }
  function E(ae, D, Q) {
    return Q ? ae(D, Q) : new b(D, null);
  }
  function H(ae, D, Q) {
    if (D < m || m + u <= D && D < w || w + p < D)
      return ae(D, Q);
    if (m <= D && D < m + u) {
      const Y = {}, he = (D - m) * o;
      for (let le = 0; le < o; le++)
        Y[f + le] = w + s * (le + he);
      return new b(D, [null, null, Y]);
    }
    const W = D - w, oe = W % s, v = [];
    if (oe !== 0)
      v[0] = [w + W - oe, n + oe];
    else {
      v[0] = [
        m + Math.floor(W / i),
        f + Math.floor(W % i / s)
      ], v[2] = {};
      for (let Y = 1; Y < s; Y++)
        v[2][n + Y] = D + Y;
    }
    return new b(D, v);
  }
  function j(ae, D, Q) {
    return D < 60 || 13311 < D && D < 42607 ? new b(D, c) : ae(D, Q);
  }
  y = [
    j,
    h,
    E,
    H,
    a
  ].reduceRight((ae, D) => (Q, W) => D(ae, Q, W), null);
  class N {
    constructor(D) {
      this.str = D, this.cursor = 0;
    }
    next() {
      if (this.str && this.cursor < this.str.length) {
        let D = this.str.charCodeAt(this.cursor++);
        if (b.isHighSurrogate(D) && this.cursor < this.str.length) {
          const Q = this.str.charCodeAt(this.cursor);
          b.isLowSurrogate(Q) && (D = (D - 55296) * 1024 + (Q - 56320) + 65536, this.cursor += 1);
        }
        return y(D);
      }
      return this.str = null, null;
    }
  }
  class T {
    constructor(D, Q) {
      this.it = D, this.canonical = Q, this.resBuf = [];
    }
    recursiveDecomp(D) {
      const Q = this.canonical, W = D.getDecomp();
      if (W && !(Q && D.isCompatibility())) {
        let oe = [];
        for (let v = 0; v < W.length; v++) {
          const Y = this.recursiveDecomp(y(W[v]));
          oe = oe.concat(Y);
        }
        return oe;
      }
      return [D];
    }
    next() {
      if (this.resBuf.length === 0) {
        const D = this.it.next();
        if (!D)
          return null;
        this.resBuf = this.recursiveDecomp(D);
      }
      return this.resBuf.shift();
    }
  }
  class A {
    constructor(D) {
      this.it = D, this.resBuf = [];
    }
    next() {
      if (this.resBuf.length === 0)
        for (; ; ) {
          const D = this.it.next();
          if (!D)
            break;
          const Q = D.getCanonicalClass();
          let W = this.resBuf.length;
          if (Q !== 0)
            for (; W > 0 && !(this.resBuf[W - 1].getCanonicalClass() <= Q); )
              W -= 1;
          if (this.resBuf.splice(W, 0, D), Q === 0)
            break;
        }
      return this.resBuf.shift();
    }
  }
  class q {
    constructor(D) {
      this.it = D, this.procBuf = [], this.resBuf = [], this.lastClass = null;
    }
    next() {
      for (; this.resBuf.length === 0; ) {
        const D = this.it.next();
        if (!D) {
          this.resBuf = this.procBuf, this.procBuf = [];
          break;
        }
        if (this.procBuf.length === 0) {
          this.lastClass = D.getCanonicalClass(), this.procBuf.push(D);
          continue;
        }
        const W = this.procBuf[0].getComposite(D), oe = D.getCanonicalClass();
        if (W && (this.lastClass < oe || this.lastClass === 0)) {
          this.procBuf[0] = W;
          continue;
        }
        oe === 0 && (this.resBuf = this.procBuf, this.procBuf = []), this.lastClass = oe, this.procBuf.push(D);
      }
      return this.resBuf.shift();
    }
  }
  function _(ae, D) {
    switch (ae) {
      case "NFD": {
        const Q = new N(D), W = new T(Q, !0);
        return new A(W);
      }
      case "NFKD": {
        const Q = new N(D), W = new T(Q, !1);
        return new A(W);
      }
      case "NFC": {
        const Q = new N(D), W = new T(Q, !0), oe = new A(W);
        return new q(oe);
      }
      case "NFKC": {
        const Q = new N(D), W = new T(Q, !1), oe = new A(W);
        return new q(oe);
      }
    }
    throw new Error(`${ae} is invalid.`);
  }
  function F(ae, D) {
    const Q = _(ae, D);
    let W = "", oe;
    for (; oe = Q.next(), !!oe; )
      W += oe.toString();
    return W;
  }
  function R(ae) {
    return F("NFD", ae);
  }
  function L(ae) {
    return F("NFKD", ae);
  }
  function fe(ae) {
    return F("NFC", ae);
  }
  function ue(ae) {
    return F("NFKC", ae);
  }
  return tn.nfc = fe, tn.nfd = R, tn.nfkc = ue, tn.nfkd = L, tn;
}
/*!
 * nfkd-compat.js - unicode normalization for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var Qu, Y3;
function my() {
  if (Y3) return Qu;
  Y3 = 1;
  const e = py();
  function c(l) {
    return l.normalize ? l.normalize("NFKD") : e.nfkd(l);
  }
  return Qu = c, Qu;
}
var eh, X3;
function Po() {
  if (X3) return eh;
  X3 = 1;
  const e = Xe(), c = At(), l = Ar(), w = Sn(), m = yi(), f = Ro(), n = En(), u = qp(), o = _o(), s = my(), { inspectSymbol: i } = Kt(), p = /* @__PURE__ */ Object.create(null);
  class g {
    /**
     * Create a mnemonic.
     * @constructor
     * @param {Object} options
     * @param {Number?} options.bit - Bits of entropy (Must
     * be a multiple of 8) (default=128).
     * @param {Buffer?} options.entropy - Entropy bytes. Will
     * be generated with `options.bits` bits of entropy
     * if not present.
     * @param {String?} options.phrase - Mnemonic phrase (will
     * be generated if not present).
     * @param {String?} options.language - Language.
     */
    constructor(b) {
      this.bits = o.MIN_ENTROPY, this.language = "english", this.entropy = null, this.phrase = null, b && this.fromOptions(b);
    }
    /**
     * Inject properties from options object.
     * @private
     * @param {Object} options
     */
    fromOptions(b) {
      return typeof b == "string" && (b = { phrase: b }), b.bits != null && (e((b.bits & 65535) === b.bits), e(b.bits >= o.MIN_ENTROPY), e(b.bits <= o.MAX_ENTROPY), e(b.bits % 32 === 0), this.bits = b.bits), b.language && (e(typeof b.language == "string"), e(g.languages.indexOf(b.language) !== -1), this.language = b.language), b.phrase ? (this.fromPhrase(b.phrase), this) : b.entropy ? (this.fromEntropy(b.entropy), this) : this;
    }
    /**
     * Instantiate mnemonic from options.
     * @param {Object} options
     * @returns {Mnemonic}
     */
    static fromOptions(b) {
      return new this().fromOptions(b);
    }
    /**
     * Destroy the mnemonic (zeroes entropy).
     */
    destroy() {
      this.bits = o.MIN_ENTROPY, this.language = "english", this.entropy && (w(this.entropy), this.entropy = null), this.phrase = null;
    }
    /**
     * Generate the seed.
     * @param {String?} passphrase
     * @returns {Buffer} pbkdf2 seed.
     */
    toSeed(b) {
      b || (b = "");
      const h = s(this.getPhrase()), a = s(`mnemonic${b}`);
      return f.derive(
        n,
        k.from(h, "utf8"),
        k.from(a, "utf8"),
        2048,
        64
      );
    }
    /**
     * Get or generate entropy.
     * @returns {Buffer}
     */
    getEntropy() {
      return this.entropy || (this.entropy = m.randomBytes(this.bits / 8)), e(this.bits / 8 === this.entropy.length), this.entropy;
    }
    /**
     * Generate a mnemonic phrase from chosen language.
     * @returns {String}
     */
    getPhrase() {
      if (this.phrase)
        return this.phrase;
      const b = this.bits + this.bits / 32, h = this.getEntropy(), a = l.digest(h), E = Math.ceil(b / 8), H = k.allocUnsafe(E);
      h.copy(H, 0), a.copy(H, h.length);
      const j = g.getWordlist(this.language);
      let G = [];
      for (let N = 0; N < b / 11; N++) {
        let T = 0;
        for (let A = 0; A < 11; A++) {
          const q = N * 11 + A, _ = q % 8, F = (q - _) / 8;
          T <<= 1, T |= H[F] >>> 7 - _ & 1;
        }
        G.push(j.words[T]);
      }
      return this.language === "japanese" ? G = G.join("　") : G = G.join(" "), this.phrase = G, G;
    }
    /**
     * Inject properties from phrase.
     * @private
     * @param {String} phrase
     */
    fromPhrase(b) {
      e(typeof b == "string"), e(b.length <= 1e3);
      const h = b.trim().split(/[\s\u3000]+/), a = h.length * 11, E = a % 32;
      e(E !== 0, "Invalid checksum.");
      const H = a - E;
      e(H >= o.MIN_ENTROPY), e(H <= o.MAX_ENTROPY), e(H % 32 === 0);
      const j = Math.ceil(a / 8), G = k.allocUnsafe(j);
      G.fill(0);
      const N = g.getLanguage(h[0]), T = g.getWordlist(N);
      for (let R = 0; R < h.length; R++) {
        const L = h[R], fe = T.map[L];
        if (fe == null)
          throw new Error("Could not find word.");
        for (let ue = 0; ue < 11; ue++) {
          const ae = R * 11 + ue, D = ae % 8, Q = (ae - D) / 8, W = fe >>> 10 - ue & 1;
          G[Q] |= W << 7 - D;
        }
      }
      const A = Math.ceil(E / 8), q = G.slice(0, G.length - A), _ = G.slice(G.length - A), F = l.digest(q);
      for (let R = 0; R < E; R++) {
        const L = R % 8, fe = (R - L) / 8, ue = _[fe] >>> 7 - L & 1, ae = F[fe] >>> 7 - L & 1;
        if (ue !== ae)
          throw new Error("Invalid checksum.");
      }
      return e(H / 8 === q.length), this.bits = H, this.language = N, this.entropy = q, this.phrase = b, this;
    }
    /**
     * Instantiate mnemonic from a phrase (validates checksum).
     * @param {String} phrase
     * @returns {Mnemonic}
     * @throws on bad checksum
     */
    static fromPhrase(b) {
      return new this().fromPhrase(b);
    }
    /**
     * Inject properties from entropy.
     * @private
     * @param {Buffer} entropy
     * @param {String?} lang
     */
    fromEntropy(b, h) {
      return e(k.isBuffer(b)), e(b.length * 8 >= o.MIN_ENTROPY), e(b.length * 8 <= o.MAX_ENTROPY), e(b.length * 8 % 32 === 0), e(!h || g.languages.indexOf(h) !== -1), this.entropy = b, this.bits = b.length * 8, h && (this.language = h), this;
    }
    /**
     * Instantiate mnemonic from entropy.
     * @param {Buffer} entropy
     * @param {String?} lang
     * @returns {Mnemonic}
     */
    static fromEntropy(b, h) {
      return new this().fromEntropy(b, h);
    }
    /**
     * Determine a single word's language.
     * @param {String} word
     * @returns {String} Language.
     * @throws on not found.
     */
    static getLanguage(b) {
      for (const h of g.languages)
        if (g.getWordlist(h).map[b] != null)
          return h;
      throw new Error("Could not determine language.");
    }
    /**
     * Retrieve the wordlist for a language.
     * @param {String} lang
     * @returns {Object}
     */
    static getWordlist(b) {
      const h = p[b];
      if (h)
        return h;
      const a = u.get(b), E = new S(a);
      return p[b] = E, E;
    }
    /**
     * Convert mnemonic to a json-friendly object.
     * @returns {Object}
     */
    toJSON() {
      return {
        bits: this.bits,
        language: this.language,
        entropy: this.getEntropy().toString("hex"),
        phrase: this.getPhrase()
      };
    }
    /**
     * Inject properties from json object.
     * @private
     * @param {Object} json
     */
    fromJSON(b) {
      return e(b), e((b.bits & 65535) === b.bits), e(typeof b.language == "string"), e(typeof b.entropy == "string"), e(typeof b.phrase == "string"), e(b.bits >= o.MIN_ENTROPY), e(b.bits <= o.MAX_ENTROPY), e(b.bits % 32 === 0), e(b.bits / 8 === b.entropy.length / 2), this.bits = b.bits, this.language = b.language, this.entropy = k.from(b.entropy, "hex"), this.phrase = b.phrase, this;
    }
    /**
     * Instantiate mnemonic from json object.
     * @param {Object} json
     * @returns {Mnemonic}
     */
    static fromJSON(b) {
      return new this().fromJSON(b);
    }
    /**
     * Calculate serialization size.
     * @returns {Number}
     */
    getSize() {
      let b = 0;
      return b += 3, b += this.getEntropy().length, b;
    }
    /**
     * Write the mnemonic to a buffer writer.
     * @params {BufferWriter} bw
     */
    toWriter(b) {
      const h = g.languages.indexOf(this.language);
      return e(h !== -1), b.writeU16(this.bits), b.writeU8(h), b.writeBytes(this.getEntropy()), b;
    }
    /**
     * Serialize mnemonic.
     * @returns {Buffer}
     */
    toRaw(b) {
      const h = this.getSize();
      return this.toWriter(c.write(h)).render();
    }
    /**
     * Inject properties from buffer reader.
     * @private
     * @param {BufferReader} br
     */
    fromReader(b) {
      const h = b.readU16();
      e(h >= o.MIN_ENTROPY), e(h <= o.MAX_ENTROPY), e(h % 32 === 0);
      const a = g.languages[b.readU8()];
      return e(a), this.bits = h, this.language = a, this.entropy = b.readBytes(h / 8), this;
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     */
    fromRaw(b) {
      return this.fromReader(c.read(b));
    }
    /**
     * Instantiate mnemonic from buffer reader.
     * @param {BufferReader} br
     * @returns {Mnemonic}
     */
    static fromReader(b) {
      return new this().fromReader(b);
    }
    /**
     * Instantiate mnemonic from serialized data.
     * @param {Buffer} data
     * @returns {Mnemonic}
     */
    static fromRaw(b) {
      return new this().fromRaw(b);
    }
    /**
     * Convert the mnemonic to a string.
     * @returns {String}
     */
    toString() {
      return this.getPhrase();
    }
    /**
     * Inspect the mnemonic.
     * @returns {String}
     */
    [i]() {
      return `<Mnemonic: ${this.getPhrase()}>`;
    }
    /**
     * Test whether an object is a Mnemonic.
     * @param {Object} obj
     * @returns {Boolean}
     */
    static isMnemonic(b) {
      return b instanceof g;
    }
  }
  g.languages = [
    "simplified chinese",
    "traditional chinese",
    "english",
    "french",
    "italian",
    "japanese",
    "spanish"
  ];
  class S {
    /**
     * Create word list.
     * @constructor
     * @ignore
     * @param {Array} words
     */
    constructor(b) {
      this.words = b, this.map = /* @__PURE__ */ Object.create(null);
      for (let h = 0; h < b.length; h++) {
        const a = b[h];
        this.map[a] = h;
      }
    }
  }
  return eh = g, eh;
}
var th, G3;
function c1() {
  if (G3) return th;
  G3 = 1;
  const e = Xe(), c = At(), { base58: l } = gn(), w = En(), m = Xi(), f = mr(), n = Sn(), u = zr(), o = Or(), s = Lt(), i = _o();
  class p {
    /**
     * Create an HD public key.
     * @constructor
     * @param {Object|Base58String} options
     * @param {Base58String?} options.xkey - Serialized base58 key.
     * @param {Number?} options.depth
     * @param {Number?} options.parentFingerPrint
     * @param {Number?} options.childIndex
     * @param {Buffer?} options.chainCode
     * @param {Buffer?} options.publicKey
     */
    constructor(S) {
      this.depth = 0, this.parentFingerPrint = 0, this.childIndex = 0, this.chainCode = s.ZERO_HASH, this.publicKey = i.ZERO_KEY, this.fingerPrint = -1, S && this.fromOptions(S);
    }
    /**
     * Inject properties from options object.
     * @private
     * @param {Object} options
     */
    fromOptions(S) {
      return e(S, "No options for HDPublicKey"), e((S.depth & 255) === S.depth), e(S.parentFingerPrint >>> 0 === S.parentFingerPrint), e(S.childIndex >>> 0 === S.childIndex), e(k.isBuffer(S.chainCode)), e(k.isBuffer(S.publicKey)), this.depth = S.depth, this.parentFingerPrint = S.parentFingerPrint, this.childIndex = S.childIndex, this.chainCode = S.chainCode, this.publicKey = S.publicKey, this;
    }
    /**
     * Instantiate HD public key from options object.
     * @param {Object} options
     * @returns {HDPublicKey}
     */
    static fromOptions(S) {
      return new this().fromOptions(S);
    }
    /**
     * Get HD public key (self).
     * @returns {HDPublicKey}
     */
    toPublic() {
      return this;
    }
    /**
     * Get cached base58 xprivkey (always null here).
     * @returns {null}
     */
    xprivkey(S) {
      return null;
    }
    /**
     * Get cached base58 xpubkey.
     * @returns {Base58String}
     */
    xpubkey(S) {
      return this.toBase58(S);
    }
    /**
     * Destroy the key (zeroes chain code and pubkey).
     */
    destroy() {
      this.depth = 0, this.childIndex = 0, this.parentFingerPrint = 0, n(this.chainCode), n(this.publicKey), this.fingerPrint = -1;
    }
    /**
     * Derive a child key.
     * @param {Number} index - Derivation index.
     * @param {Boolean?} hardened - Whether the derivation
     * should be hardened (throws if true).
     * @returns {HDPrivateKey}
     * @throws on `hardened`
     */
    derive(S, y) {
      if (e(typeof S == "number"), S >>> 0 !== S)
        throw new Error("Index out of range.");
      if (S & i.HARDENED || y)
        throw new Error("Cannot derive hardened.");
      if (this.depth >= 255)
        throw new Error("Depth too high.");
      const b = this.getID(S), h = i.cache.get(b);
      if (h)
        return h;
      const a = c.pool(37);
      a.writeBytes(this.publicKey), a.writeU32BE(S);
      const E = a.render(), H = w.mac(E, this.chainCode), j = H.slice(0, 32), G = H.slice(32, 64);
      let N;
      try {
        N = u.publicKeyTweakAdd(this.publicKey, j, !0);
      } catch {
        return this.derive(S + 1);
      }
      if (this.fingerPrint === -1) {
        const A = m.digest(this.publicKey);
        this.fingerPrint = A.readUInt32BE(0, !0);
      }
      const T = new this.constructor();
      return T.depth = this.depth + 1, T.parentFingerPrint = this.fingerPrint, T.childIndex = S, T.chainCode = G, T.publicKey = N, i.cache.set(b, T), T;
    }
    /**
     * Unique HD key ID.
     * @private
     * @param {Number} index
     * @returns {String}
     */
    getID(S) {
      return "b" + this.publicKey.toString("hex") + S;
    }
    /**
     * Derive a BIP44 account key (does not derive, only ensures account key).
     * @method
     * @param {Number} purpose
     * @param {Number} type
     * @param {Number} account
     * @returns {HDPublicKey}
     * @throws Error if key is not already an account key.
     */
    deriveAccount(S, y, b) {
      return e(S >>> 0 === S), e(y >>> 0 === y), e(b >>> 0 === b), e(this.isAccount(b), "Cannot derive account index."), this;
    }
    /**
     * Test whether the key is a master key.
     * @method
     * @returns {Boolean}
     */
    isMaster() {
      return i.isMaster(this);
    }
    /**
     * Test whether the key is (most likely) a BIP44 account key.
     * @method
     * @param {Number?} account
     * @returns {Boolean}
     */
    isAccount(S) {
      return i.isAccount(this, S);
    }
    /**
     * Test whether a string is a valid path.
     * @param {String} path
     * @param {Boolean?} hardened
     * @returns {Boolean}
     */
    static isValidPath(S) {
      try {
        return i.parsePath(S, !1), !0;
      } catch {
        return !1;
      }
    }
    /**
     * Derive a key from a derivation path.
     * @param {String} path
     * @returns {HDPublicKey}
     * @throws Error if `path` is not a valid path.
     * @throws Error if hardened.
     */
    derivePath(S) {
      const y = i.parsePath(S, !1);
      let b = this;
      for (const h of y)
        b = b.derive(h);
      return b;
    }
    /**
     * Compare a key against an object.
     * @param {Object} obj
     * @returns {Boolean}
     */
    equals(S) {
      return e(p.isHDPublicKey(S)), this.depth === S.depth && this.parentFingerPrint === S.parentFingerPrint && this.childIndex === S.childIndex && this.chainCode.equals(S.chainCode) && this.publicKey.equals(S.publicKey);
    }
    /**
     * Compare a key against an object.
     * @param {Object} obj
     * @returns {Boolean}
     */
    compare(S) {
      e(p.isHDPublicKey(S));
      let y = this.depth - S.depth;
      return y !== 0 || (y = this.parentFingerPrint - S.parentFingerPrint, y !== 0) || (y = this.childIndex - S.childIndex, y !== 0) || (y = this.chainCode.compare(S.chainCode), y !== 0) || (y = this.publicKey.compare(S.publicKey), y !== 0) ? y : 0;
    }
    /**
     * Convert key to a more json-friendly object.
     * @returns {Object}
     */
    toJSON(S) {
      return {
        xpubkey: this.xpubkey(S)
      };
    }
    /**
     * Inject properties from json object.
     * @private
     * @param {Object} json
     * @param {Network?} network
     */
    fromJSON(S, y) {
      return e(S.xpubkey, "Could not handle HD key JSON."), this.fromBase58(S.xpubkey, y), this;
    }
    /**
     * Instantiate an HDPublicKey from a jsonified key object.
     * @param {Object} json - The jsonified transaction object.
     * @param {Network?} network
     * @returns {HDPrivateKey}
     */
    static fromJSON(S, y) {
      return new this().fromJSON(S, y);
    }
    /**
     * Test whether an object is in the form of a base58 xpubkey.
     * @param {String} data
     * @param {(Network|NetworkType)?} network
     * @returns {Boolean}
     */
    static isBase58(S, y) {
      if (typeof S != "string" || S.length < 4)
        return !1;
      const b = S.substring(0, 4);
      try {
        return o.fromPublic58(b, y), !0;
      } catch {
        return !1;
      }
    }
    /**
     * Test whether a buffer has a valid network prefix.
     * @param {Buffer} data
     * @param {(Network|NetworkType)?} network
     * @returns {NetworkType}
     */
    static isRaw(S, y) {
      if (!k.isBuffer(S) || S.length < 4)
        return !1;
      const b = S.readUInt32BE(0, !0);
      try {
        return o.fromPublic(b, y), !0;
      } catch {
        return !1;
      }
    }
    /**
     * Inject properties from a base58 key.
     * @private
     * @param {Base58String} xkey
     * @param {Network?} network
     */
    fromBase58(S, y) {
      return e(typeof S == "string"), this.fromRaw(l.decode(S), y);
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {BufferReader} br
     * @param {(Network|NetworkType)?} network
     */
    fromReader(S, y) {
      const b = S.readU32BE();
      return o.fromPublic(b, y), this.depth = S.readU8(), this.parentFingerPrint = S.readU32BE(), this.childIndex = S.readU32BE(), this.chainCode = S.readBytes(32), this.publicKey = S.readBytes(33), S.verifyChecksum(f.digest), this;
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     * @param {(Network|NetworkType)?} network
     */
    fromRaw(S, y) {
      return this.fromReader(c.read(S), y);
    }
    /**
     * Serialize key data to base58 extended key.
     * @param {(Network|NetworkType)?} network
     * @returns {Base58String}
     */
    toBase58(S) {
      return l.encode(this.toRaw(S));
    }
    /**
     * Write the key to a buffer writer.
     * @param {BufferWriter} bw
     * @param {(Network|NetworkType)?} network
     */
    toWriter(S, y) {
      return y = o.get(y), S.writeU32BE(y.keyPrefix.xpubkey), S.writeU8(this.depth), S.writeU32BE(this.parentFingerPrint), S.writeU32BE(this.childIndex), S.writeBytes(this.chainCode), S.writeBytes(this.publicKey), S.writeChecksum(f.digest), S;
    }
    /**
     * Calculate serialization size.
     * @returns {Number}
     */
    getSize() {
      return 82;
    }
    /**
     * Serialize the key.
     * @param {(Network|NetworkType)?} network
     * @returns {Buffer}
     */
    toRaw(S) {
      return this.toWriter(c.write(82), S).render();
    }
    /**
     * Instantiate an HD public key from a base58 string.
     * @param {Base58String} xkey
     * @param {Network?} network
     * @returns {HDPublicKey}
     */
    static fromBase58(S, y) {
      return new this().fromBase58(S, y);
    }
    /**
     * Instantiate key from serialized data.
     * @param {BufferReader} br
     * @param {(Network|NetworkType)?} network
     * @returns {HDPublicKey}
     */
    static fromReader(S, y) {
      return new this().fromReader(S, y);
    }
    /**
     * Instantiate key from serialized data.
     * @param {Buffer} data
     * @param {(Network|NetworkType)?} network
     * @returns {HDPublicKey}
     */
    static fromRaw(S, y) {
      return new this().fromRaw(S, y);
    }
    /**
     * Test whether an object is a HDPublicKey.
     * @param {Object} obj
     * @returns {Boolean}
     */
    static isHDPublicKey(S) {
      return S instanceof p;
    }
  }
  return th = p, th;
}
var rh, J3;
function u1() {
  if (J3) return rh;
  J3 = 1;
  const e = Xe(), c = At(), { base58: l } = gn(), w = En(), m = Xi(), f = mr(), n = Sn(), u = yi(), o = zr(), s = Or(), i = Lt(), p = _o(), g = Po(), S = c1(), y = k.from("Bitcoin seed", "ascii");
  class b {
    /**
     * Create an hd private key.
     * @constructor
     * @param {Object|String} options
     * @param {Number?} options.depth
     * @param {Number?} options.parentFingerPrint
     * @param {Number?} options.childIndex
     * @param {Buffer?} options.chainCode
     * @param {Buffer?} options.privateKey
     */
    constructor(a) {
      this.depth = 0, this.parentFingerPrint = 0, this.childIndex = 0, this.chainCode = i.ZERO_HASH, this.privateKey = i.ZERO_HASH, this.publicKey = p.ZERO_KEY, this.fingerPrint = -1, this._hdPublicKey = null, a && this.fromOptions(a);
    }
    /**
     * Inject properties from options object.
     * @private
     * @param {Object} options
     */
    fromOptions(a) {
      return e(a, "No options for HD private key."), e((a.depth & 255) === a.depth), e(a.parentFingerPrint >>> 0 === a.parentFingerPrint), e(a.childIndex >>> 0 === a.childIndex), e(k.isBuffer(a.chainCode)), e(k.isBuffer(a.privateKey)), this.depth = a.depth, this.parentFingerPrint = a.parentFingerPrint, this.childIndex = a.childIndex, this.chainCode = a.chainCode, this.privateKey = a.privateKey, this.publicKey = o.publicKeyCreate(a.privateKey, !0), this;
    }
    /**
     * Instantiate HD private key from options object.
     * @param {Object} options
     * @returns {HDPrivateKey}
     */
    static fromOptions(a) {
      return new this().fromOptions(a);
    }
    /**
     * Get HD public key.
     * @returns {HDPublicKey}
     */
    toPublic() {
      let a = this._hdPublicKey;
      return a || (a = new S(), a.depth = this.depth, a.parentFingerPrint = this.parentFingerPrint, a.childIndex = this.childIndex, a.chainCode = this.chainCode, a.publicKey = this.publicKey, this._hdPublicKey = a), a;
    }
    /**
     * Get cached base58 xprivkey.
     * @returns {Base58String}
     */
    xprivkey(a) {
      return this.toBase58(a);
    }
    /**
     * Get cached base58 xpubkey.
     * @returns {Base58String}
     */
    xpubkey(a) {
      return this.toPublic().xpubkey(a);
    }
    /**
     * Destroy the key (zeroes chain code, privkey, and pubkey).
     * @param {Boolean} pub - Destroy hd public key as well.
     */
    destroy(a) {
      this.depth = 0, this.childIndex = 0, this.parentFingerPrint = 0, n(this.chainCode), n(this.privateKey), n(this.publicKey), this.fingerPrint = -1, this._hdPublicKey && (a && this._hdPublicKey.destroy(), this._hdPublicKey = null);
    }
    /**
     * Derive a child key.
     * @param {Number} index - Derivation index.
     * @param {Boolean?} hardened - Whether the derivation should be hardened.
     * @returns {HDPrivateKey}
     */
    derive(a, E) {
      if (e(typeof a == "number"), a >>> 0 !== a)
        throw new Error("Index out of range.");
      if (this.depth >= 255)
        throw new Error("Depth too high.");
      E && (a |= p.HARDENED, a >>>= 0);
      const H = this.getID(a), j = p.cache.get(H);
      if (j)
        return j;
      const G = c.pool(37);
      a & p.HARDENED ? (G.writeU8(0), G.writeBytes(this.privateKey), G.writeU32BE(a)) : (G.writeBytes(this.publicKey), G.writeU32BE(a));
      const N = G.render(), T = w.mac(N, this.chainCode), A = T.slice(0, 32), q = T.slice(32, 64);
      let _;
      try {
        _ = o.privateKeyTweakAdd(this.privateKey, A);
      } catch {
        return this.derive(a + 1);
      }
      if (this.fingerPrint === -1) {
        const R = m.digest(this.publicKey);
        this.fingerPrint = R.readUInt32BE(0, !0);
      }
      const F = new this.constructor();
      return F.depth = this.depth + 1, F.parentFingerPrint = this.fingerPrint, F.childIndex = a, F.chainCode = q, F.privateKey = _, F.publicKey = o.publicKeyCreate(_, !0), p.cache.set(H, F), F;
    }
    /**
     * Unique HD key ID.
     * @private
     * @param {Number} index
     * @returns {String}
     */
    getID(a) {
      return "v" + this.publicKey.toString("hex") + a;
    }
    /**
     * Derive a BIP44 account key.
     * @param {Number} purpose
     * @param {Number} type
     * @param {Number} account
     * @returns {HDPrivateKey}
     * @throws Error if key is not a master key.
     */
    deriveAccount(a, E, H) {
      return e(a >>> 0 === a, "Purpose must be a number."), e(E >>> 0 === E, "Account index must be a number."), e(H >>> 0 === H, "Account index must be a number."), e(this.isMaster(), "Cannot derive account index."), this.derive(a, !0).derive(E, !0).derive(H, !0);
    }
    /**
     * Test whether the key is a master key.
     * @returns {Boolean}
     */
    isMaster() {
      return p.isMaster(this);
    }
    /**
     * Test whether the key is (most likely) a BIP44 account key.
     * @param {Number?} account
     * @returns {Boolean}
     */
    isAccount(a) {
      return p.isAccount(this, a);
    }
    /**
     * Test whether an object is in the form of a base58 xprivkey.
     * @param {String} data
     * @param {Network?} network
     * @returns {Boolean}
     */
    static isBase58(a, E) {
      if (typeof a != "string" || a.length < 4)
        return !1;
      const H = a.substring(0, 4);
      try {
        return s.fromPrivate58(H, E), !0;
      } catch {
        return !1;
      }
    }
    /**
     * Test whether a buffer has a valid network prefix.
     * @param {Buffer} data
     * @param {Network?} network
     * @returns {Boolean}
     */
    static isRaw(a, E) {
      if (!k.isBuffer(a) || a.length < 4)
        return !1;
      const H = a.readUInt32BE(0, !0);
      try {
        return s.fromPrivate(H, E), !0;
      } catch {
        return !1;
      }
    }
    /**
     * Test whether a string is a valid path.
     * @param {String} path
     * @returns {Boolean}
     */
    static isValidPath(a) {
      try {
        return p.parsePath(a, !0), !0;
      } catch {
        return !1;
      }
    }
    /**
     * Derive a key from a derivation path.
     * @param {String} path
     * @returns {HDPrivateKey}
     * @throws Error if `path` is not a valid path.
     */
    derivePath(a) {
      const E = p.parsePath(a, !0);
      let H = this;
      for (const j of E)
        H = H.derive(j);
      return H;
    }
    /**
     * Compare a key against an object.
     * @param {Object} obj
     * @returns {Boolean}
     */
    equals(a) {
      return e(b.isHDPrivateKey(a)), this.depth === a.depth && this.parentFingerPrint === a.parentFingerPrint && this.childIndex === a.childIndex && this.chainCode.equals(a.chainCode) && this.privateKey.equals(a.privateKey);
    }
    /**
     * Compare a key against an object.
     * @param {Object} obj
     * @returns {Boolean}
     */
    compare(a) {
      e(b.isHDPrivateKey(a));
      let E = this.depth - a.depth;
      return E !== 0 || (E = this.parentFingerPrint - a.parentFingerPrint, E !== 0) || (E = this.childIndex - a.childIndex, E !== 0) || (E = this.chainCode.compare(a.chainCode), E !== 0) || (E = this.privateKey.compare(a.privateKey), E !== 0) ? E : 0;
    }
    /**
     * Inject properties from seed.
     * @private
     * @param {Buffer} seed
     */
    fromSeed(a) {
      if (e(k.isBuffer(a)), a.length * 8 < p.MIN_ENTROPY || a.length * 8 > p.MAX_ENTROPY)
        throw new Error("Entropy not in range.");
      const E = w.mac(a, y), H = E.slice(0, 32), j = E.slice(32, 64);
      if (!o.privateKeyVerify(H))
        throw new Error("Master private key is invalid.");
      return this.depth = 0, this.parentFingerPrint = 0, this.childIndex = 0, this.chainCode = j, this.privateKey = H, this.publicKey = o.publicKeyCreate(H, !0), this;
    }
    /**
     * Instantiate an hd private key from a 512 bit seed.
     * @param {Buffer} seed
     * @returns {HDPrivateKey}
     */
    static fromSeed(a) {
      return new this().fromSeed(a);
    }
    /**
     * Inject properties from a mnemonic.
     * @private
     * @param {Mnemonic} mnemonic
     * @param {String?} passphrase
     */
    fromMnemonic(a, E) {
      return e(a instanceof g), this.fromSeed(a.toSeed(E));
    }
    /**
     * Instantiate an hd private key from a mnemonic.
     * @param {Mnemonic} mnemonic
     * @param {String?} passphrase
     * @returns {HDPrivateKey}
     */
    static fromMnemonic(a, E) {
      return new this().fromMnemonic(a, E);
    }
    /**
     * Inject properties from a mnemonic.
     * @private
     * @param {String} mnemonic
     */
    fromPhrase(a) {
      const E = g.fromPhrase(a);
      return this.fromMnemonic(E), this;
    }
    /**
     * Instantiate an hd private key from a phrase.
     * @param {String} phrase
     * @returns {HDPrivateKey}
     */
    static fromPhrase(a) {
      return new this().fromPhrase(a);
    }
    /**
     * Inject properties from privateKey and entropy.
     * @private
     * @param {Buffer} key
     * @param {Buffer} entropy
     */
    fromKey(a, E) {
      return e(k.isBuffer(a) && a.length === 32), e(k.isBuffer(E) && E.length === 32), this.depth = 0, this.parentFingerPrint = 0, this.childIndex = 0, this.chainCode = E, this.privateKey = a, this.publicKey = o.publicKeyCreate(a, !0), this;
    }
    /**
     * Create an hd private key from a key and entropy bytes.
     * @param {Buffer} key
     * @param {Buffer} entropy
     * @returns {HDPrivateKey}
     */
    static fromKey(a, E) {
      return new this().fromKey(a, E);
    }
    /**
     * Generate an hd private key.
     * @returns {HDPrivateKey}
     */
    static generate() {
      const a = o.privateKeyGenerate(), E = u.randomBytes(32);
      return b.fromKey(a, E);
    }
    /**
     * Inject properties from base58 key.
     * @private
     * @param {Base58String} xkey
     * @param {Network?} network
     */
    fromBase58(a, E) {
      return e(typeof a == "string"), this.fromRaw(l.decode(a), E);
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {BufferReader} br
     * @param {(Network|NetworkType)?} network
     */
    fromReader(a, E) {
      const H = a.readU32BE();
      return s.fromPrivate(H, E), this.depth = a.readU8(), this.parentFingerPrint = a.readU32BE(), this.childIndex = a.readU32BE(), this.chainCode = a.readBytes(32), e(a.readU8() === 0), this.privateKey = a.readBytes(32), this.publicKey = o.publicKeyCreate(this.privateKey, !0), a.verifyChecksum(f.digest), this;
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     * @param {(Network|NetworkType)?} network
     */
    fromRaw(a, E) {
      return this.fromReader(c.read(a), E);
    }
    /**
     * Serialize key to a base58 string.
     * @param {(Network|NetworkType)?} network
     * @returns {Base58String}
     */
    toBase58(a) {
      return l.encode(this.toRaw(a));
    }
    /**
     * Calculate serialization size.
     * @returns {Number}
     */
    getSize() {
      return 82;
    }
    /**
     * Write the key to a buffer writer.
     * @param {BufferWriter} bw
     * @param {(Network|NetworkType)?} network
     */
    toWriter(a, E) {
      return E = s.get(E), a.writeU32BE(E.keyPrefix.xprivkey), a.writeU8(this.depth), a.writeU32BE(this.parentFingerPrint), a.writeU32BE(this.childIndex), a.writeBytes(this.chainCode), a.writeU8(0), a.writeBytes(this.privateKey), a.writeChecksum(f.digest), a;
    }
    /**
     * Serialize the key.
     * @param {(Network|NetworkType)?} network
     * @returns {Buffer}
     */
    toRaw(a) {
      return this.toWriter(c.write(82), a).render();
    }
    /**
     * Instantiate an HD private key from a base58 string.
     * @param {Base58String} xkey
     * @param {Network?} network
     * @returns {HDPrivateKey}
     */
    static fromBase58(a, E) {
      return new this().fromBase58(a, E);
    }
    /**
     * Instantiate key from buffer reader.
     * @param {BufferReader} br
     * @param {(Network|NetworkType)?} network
     * @returns {HDPrivateKey}
     */
    static fromReader(a, E) {
      return new this().fromReader(a, E);
    }
    /**
     * Instantiate key from serialized data.
     * @param {Buffer} data
     * @param {(Network|NetworkType)?} network
     * @returns {HDPrivateKey}
     */
    static fromRaw(a, E) {
      return new this().fromRaw(a, E);
    }
    /**
     * Convert key to a more json-friendly object.
     * @returns {Object}
     */
    toJSON(a) {
      return {
        xprivkey: this.xprivkey(a)
      };
    }
    /**
     * Inject properties from json object.
     * @private
     * @param {Object} json
     * @param {Network?} network
     */
    fromJSON(a, E) {
      return e(a.xprivkey, "Could not handle key JSON."), this.fromBase58(a.xprivkey, E), this;
    }
    /**
     * Instantiate an HDPrivateKey from a jsonified key object.
     * @param {Object} json - The jsonified key object.
     * @param {Network?} network
     * @returns {HDPrivateKey}
     */
    static fromJSON(a, E) {
      return new this().fromJSON(a, E);
    }
    /**
     * Test whether an object is an HDPrivateKey.
     * @param {Object} obj
     * @returns {Boolean}
     */
    static isHDPrivateKey(a) {
      return a instanceof b;
    }
  }
  return rh = b, rh;
}
/*!
 * hd.js - hd keys for bcoin
 * Copyright (c) 2015-2016, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var W3;
function h1() {
  return W3 || (W3 = 1, function(e) {
    const c = Xe(), l = _o(), w = Po(), m = u1(), f = c1(), n = qp(), u = e;
    u.fromBase58 = function(s, i) {
      return m.isBase58(s) ? m.fromBase58(s, i) : f.fromBase58(s, i);
    }, u.generate = function() {
      return m.generate();
    }, u.fromSeed = function(s) {
      return m.fromSeed(s);
    }, u.fromMnemonic = function(s) {
      return m.fromMnemonic(s);
    }, u.fromJSON = function(s, i) {
      return s.xprivkey ? m.fromJSON(s, i) : f.fromJSON(s, i);
    }, u.fromRaw = function(s, i) {
      return m.isRaw(s, i) ? m.fromRaw(s, i) : f.fromRaw(s, i);
    }, u.from = function(s, i) {
      if (c(s, "Options required."), u.isHD(s))
        return s;
      if (u.isBase58(s, i))
        return u.fromBase58(s, i);
      if (u.isRaw(s, i))
        return u.fromRaw(s, i);
      if (s && typeof s == "object")
        return u.fromMnemonic(s);
      throw new Error("Cannot create HD key from bad options.");
    }, u.isBase58 = function(s, i) {
      return m.isBase58(s, i) || f.isBase58(s, i);
    }, u.isRaw = function(s, i) {
      return m.isRaw(s, i) || f.isRaw(s, i);
    }, u.isHD = function(s) {
      return m.isHDPrivateKey(s) || f.isHDPublicKey(s);
    }, u.isPrivate = function(s) {
      return m.isHDPrivateKey(s);
    }, u.isPublic = function(s) {
      return f.isHDPublicKey(s);
    }, u.common = l, u.HD = u, u.Mnemonic = w, u.PrivateKey = m, u.PublicKey = f, u.HDPrivateKey = m, u.HDPublicKey = f, u.wordlist = n;
  }(Hu)), Hu;
}
/*!
 * hd/index.js - hd keys for bcoin
 * Copyright (c) 2014-2016, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var ih, Z3;
function gy() {
  return Z3 || (Z3 = 1, ih = h1()), ih;
}
var Yt = {}, nh, Q3;
function ko() {
  if (Q3) return nh;
  Q3 = 1;
  const e = At(), c = Qt();
  class l {
    /**
     * Create an inv item.
     * @constructor
     * @param {Number} type
     * @param {Hash} hash
     */
    constructor(m, f) {
      this.type = m, this.hash = f;
    }
    /**
     * Write inv item to buffer writer.
     * @param {BufferWriter} bw
     */
    getSize() {
      return 36;
    }
    /**
     * Write inv item to buffer writer.
     * @param {BufferWriter} bw
     */
    toWriter(m) {
      return m.writeU32(this.type), m.writeHash(this.hash), m;
    }
    /**
     * Serialize inv item.
     * @returns {Buffer}
     */
    toRaw() {
      return this.toWriter(e.write(36)).render();
    }
    /**
     * Inject properties from buffer reader.
     * @private
     * @param {BufferReader} br
     */
    fromReader(m) {
      return this.type = m.readU32(), this.hash = m.readHash(), this;
    }
    /**
     * Inject properties from serialized data.
     * @param {Buffer} data
     */
    fromRaw(m) {
      return this.fromReader(e.read(m));
    }
    /**
     * Instantiate inv item from buffer reader.
     * @param {BufferReader} br
     * @returns {InvItem}
     */
    static fromReader(m) {
      return new this().fromReader(m);
    }
    /**
     * Instantiate inv item from serialized data.
     * @param {Buffer} data
     * @param {String?} enc
     * @returns {InvItem}
     */
    static fromRaw(m, f) {
      return typeof m == "string" && (m = k.from(m, f)), new this().fromRaw(m);
    }
    /**
     * Test whether the inv item is a block.
     * @returns {Boolean}
     */
    isBlock() {
      switch (this.type) {
        case l.types.BLOCK:
        case l.types.FILTERED_BLOCK:
        case l.types.CMPCT_BLOCK:
          return !0;
        default:
          return !1;
      }
    }
    /**
     * Test whether the inv item is a tx.
     * @returns {Boolean}
     */
    isTX() {
      switch (this.type) {
        case l.types.TX:
          return !0;
        default:
          return !1;
      }
    }
    /**
     * Get little-endian hash.
     * @returns {Hash}
     */
    rhash() {
      return c.revHex(this.hash);
    }
  }
  return l.types = {
    TX: 1,
    BLOCK: 2,
    FILTERED_BLOCK: 3,
    CMPCT_BLOCK: 4
  }, l.typesByVal = {
    1: "TX",
    2: "BLOCK",
    3: "FILTERED_BLOCK",
    4: "CMPCT_BLOCK"
  }, nh = l, nh;
}
var sh, eb;
function us() {
  if (eb) return sh;
  eb = 1;
  const e = Xe(), c = mr(), l = At(), w = Qt(), m = ko(), f = Lt();
  class n {
    /**
     * Create an abstract block.
     * @constructor
     */
    constructor() {
      this.version = 1, this.prevBlock = f.ZERO_HASH, this.merkleRoot = f.ZERO_HASH, this.time = 0, this.bits = 0, this.nonce = 0, this.mutable = !1, this._hash = null, this._hhash = null;
    }
    /**
     * Inject properties from options object.
     * @private
     * @param {Object} options
     */
    parseOptions(o) {
      return e(o, "Block data is required."), e(o.version >>> 0 === o.version), e(k.isBuffer(o.prevBlock)), e(k.isBuffer(o.merkleRoot)), e(o.time >>> 0 === o.time), e(o.bits >>> 0 === o.bits), e(o.nonce >>> 0 === o.nonce), this.version = o.version, this.prevBlock = o.prevBlock, this.merkleRoot = o.merkleRoot, this.time = o.time, this.bits = o.bits, this.nonce = o.nonce, o.mutable != null && (e(typeof o.mutable == "boolean"), this.mutable = o.mutable), this;
    }
    /**
     * Inject properties from json object.
     * @private
     * @param {Object} json
     */
    parseJSON(o) {
      return e(o, "Block data is required."), e(o.version >>> 0 === o.version), e(typeof o.prevBlock == "string"), e(typeof o.merkleRoot == "string"), e(o.time >>> 0 === o.time), e(o.bits >>> 0 === o.bits), e(o.nonce >>> 0 === o.nonce), this.version = o.version, this.prevBlock = w.fromRev(o.prevBlock), this.merkleRoot = w.fromRev(o.merkleRoot), this.time = o.time, this.bits = o.bits, this.nonce = o.nonce, this;
    }
    /**
     * Test whether the block is a memblock.
     * @returns {Boolean}
     */
    isMemory() {
      return !1;
    }
    /**
     * Clear any cached values (abstract).
     */
    _refresh() {
      this._hash = null, this._hhash = null;
    }
    /**
     * Clear any cached values.
     */
    refresh() {
      return this._refresh();
    }
    /**
     * Hash the block headers.
     * @param {String?} enc - Can be `'hex'` or `null`.
     * @returns {Hash|Buffer} hash
     */
    hash(o) {
      let s = this._hash;
      if (s || (s = c.digest(this.toHead()), this.mutable || (this._hash = s)), o === "hex") {
        let i = this._hhash;
        i || (i = s.toString("hex"), this.mutable || (this._hhash = i)), s = i;
      }
      return s;
    }
    /**
     * Serialize the block headers.
     * @returns {Buffer}
     */
    toHead() {
      return this.writeHead(l.write(80)).render();
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     */
    fromHead(o) {
      return this.readHead(l.read(o));
    }
    /**
     * Serialize the block headers.
     * @param {BufferWriter} bw
     */
    writeHead(o) {
      return o.writeU32(this.version), o.writeHash(this.prevBlock), o.writeHash(this.merkleRoot), o.writeU32(this.time), o.writeU32(this.bits), o.writeU32(this.nonce), o;
    }
    /**
     * Parse the block headers.
     * @param {BufferReader} br
     */
    readHead(o) {
      return this.version = o.readU32(), this.prevBlock = o.readHash(), this.merkleRoot = o.readHash(), this.time = o.readU32(), this.bits = o.readU32(), this.nonce = o.readU32(), this;
    }
    /**
     * Verify the block.
     * @returns {Boolean}
     */
    verify() {
      return !(!this.verifyPOW() || !this.verifyBody());
    }
    /**
     * Verify proof-of-work.
     * @returns {Boolean}
     */
    verifyPOW() {
      return f.verifyPOW(this.hash(), this.bits);
    }
    /**
     * Verify the block.
     * @returns {Boolean}
     */
    verifyBody() {
      throw new Error("Abstract method.");
    }
    /**
     * Get little-endian block hash.
     * @returns {Hash}
     */
    rhash() {
      return w.revHex(this.hash());
    }
    /**
     * Convert the block to an inv item.
     * @returns {InvItem}
     */
    toInv() {
      return new m(m.types.BLOCK, this.hash());
    }
  }
  return sh = n, sh;
}
var rn = {}, tb;
function Tp() {
  if (tb) return rn;
  tb = 1;
  const e = Nt();
  function c(f, n) {
    e(f && typeof f.root == "function"), e(Array.isArray(n));
    const u = new Array(n.length);
    for (let p = 0; p < n.length; p++)
      u[p] = n[p];
    let o = u.length, s = !1, i = 0;
    if (o === 0)
      return u.push(f.zero), [u, s];
    for (; o > 1; ) {
      for (let p = 0; p < o; p += 2) {
        const g = Math.min(p + 1, o - 1), S = u[i + p], y = u[i + g];
        g === p + 1 && g + 1 === o && S.equals(y) && (s = !0);
        const b = f.root(S, y);
        u.push(b);
      }
      i += o, o = o + 1 >>> 1;
    }
    return [u, s];
  }
  function l(f, n) {
    e(f && typeof f.root == "function"), e(Array.isArray(n));
    const [u, o] = c(f, n);
    return [u[u.length - 1], o];
  }
  function w(f, n, u) {
    e(f && typeof f.root == "function"), e(n >>> 0 === n), e(Array.isArray(u)), e(n < u.length);
    let o = u.length;
    const [s] = c(f, u), i = [];
    let p = 0;
    for (; o > 1; ) {
      const g = Math.min(n ^ 1, o - 1);
      i.push(s[p + g]), n >>>= 1, p += o, o = o + 1 >>> 1;
    }
    return i;
  }
  function m(f, n, u, o) {
    e(f && typeof f.root == "function"), e(k.isBuffer(n)), e(Array.isArray(u)), e(o >>> 0 === o);
    let s = n;
    for (const i of u) {
      if (o & 1 && i.equals(s))
        return f.zero;
      o & 1 ? s = f.root(i, s) : s = f.root(s, i), o >>>= 1;
    }
    return s;
  }
  return rn.createTree = c, rn.createRoot = l, rn.createBranch = w, rn.deriveRoot = m, rn;
}
var oh, rb;
function Bo() {
  if (rb) return oh;
  rb = 1;
  const e = Xe(), c = At(), l = Or(), w = Cr(), m = Ei(), { inspectSymbol: f } = Kt();
  class n {
    /**
     * Create transaction input.
     * @constructor
     * @param {Object} options
     */
    constructor(o) {
      this.prevout = new m(), this.script = new w(), this.sequence = 4294967295, o && this.fromOptions(o);
    }
    /**
     * Inject properties from options object.
     * @private
     * @param {Object} options
     */
    fromOptions(o) {
      return e(o, "Input data is required."), this.prevout.fromOptions(o.prevout), o.script && this.script.fromOptions(o.script), o.sequence != null && (e(
        o.sequence >>> 0 === o.sequence,
        "Sequence must be a uint32."
      ), this.sequence = o.sequence), this;
    }
    /**
     * Instantiate an Input from options object.
     * @param {Object} options
     * @returns {Input}
     */
    static fromOptions(o) {
      return new this().fromOptions(o);
    }
    /**
     * Clone the input.
     * @returns {Input}
     */
    clone() {
      const o = new this.constructor();
      return o.prevout = this.prevout, o.script.inject(this.script), o.sequence = this.sequence, o;
    }
    /**
     * Test equality against another input.
     * @param {Input} input
     * @returns {Boolean}
     */
    equals(o) {
      return e(n.isInput(o)), this.prevout.equals(o.prevout);
    }
    /**
     * Compare against another input (BIP69).
     * @param {Input} input
     * @returns {Number}
     */
    compare(o) {
      return e(n.isInput(o)), this.prevout.compare(o.prevout);
    }
    /**
     * Get the previous output script type as a string.
     * Will "guess" based on the input script and/or
     * witness if coin is not available.
     * @param {Coin?} coin
     * @returns {ScriptType} type
     */
    getType(o) {
      if (this.isCoinbase())
        return "coinbase";
      if (o)
        return o.getType();
      const s = this.script.getInputType();
      return w.typesByVal[s].toLowerCase();
    }
    /**
     * Get the redeem script.
     * @param {Coin?} coin
     * @returns {Script?} Redeem script.
     */
    getRedeem(o) {
      if (this.isCoinbase())
        return null;
      if (!o)
        return this.script.isScripthashInput() ? this.script.getRedeem() : null;
      let s = o.script, i = null;
      return s.isScripthash() && (s = this.script.getRedeem(), i = s), i;
    }
    /**
     * Get the redeem script type.
     * @param {Coin?} coin
     * @returns {String} subtype
     */
    getSubtype(o) {
      if (this.isCoinbase())
        return null;
      const s = this.getRedeem(o);
      if (!s)
        return null;
      const i = s.getType();
      return w.typesByVal[i].toLowerCase();
    }
    /**
     * Get the previous output script's address. Will "guess"
     * based on the input script and/or witness if coin
     * is not available.
     * @param {Coin?} coin
     * @returns {Address?} addr
     */
    getAddress(o) {
      return this.isCoinbase() ? null : o ? o.getAddress() : this.script.code.length > 0 ? this.script.getInputAddress() : null;
    }
    /**
     * Get the address hash.
     * @param {Coin?} coin
     * @param {String?} enc
     * @returns {Hash} hash
     */
    getHash(o, s) {
      const i = this.getAddress(o);
      return i ? i.getHash(s) : null;
    }
    /**
     * Test to see if nSequence is equal to uint32max.
     * @returns {Boolean}
     */
    isFinal() {
      return this.sequence === 4294967295;
    }
    /**
     * Test to see if nSequence is less than 0xfffffffe.
     * @returns {Boolean}
     */
    isRBF() {
      return this.sequence < 4294967294;
    }
    /**
     * Test to see if outpoint is null.
     * @returns {Boolean}
     */
    isCoinbase() {
      return this.prevout.isNull();
    }
    /**
     * Convert the input to a more user-friendly object.
     * @returns {Object}
     */
    [f]() {
      return this.format();
    }
    /**
     * Convert the input to a more user-friendly object.
     * @param {Coin?} coin
     * @returns {Object}
     */
    format(o) {
      return {
        type: this.getType(o),
        subtype: this.getSubtype(o),
        address: this.getAddress(o),
        script: this.script,
        redeem: this.getRedeem(o),
        sequence: this.sequence,
        prevout: this.prevout,
        coin: o || null
      };
    }
    /**
     * Convert the input to an object suitable
     * for JSON serialization.
     * @returns {Object}
     */
    toJSON(o, s) {
      return this.getJSON();
    }
    /**
     * Convert the input to an object suitable
     * for JSON serialization. Note that the hashes
     * will be reversed to abide by bitcoind's legacy
     * of little-endian uint256s.
     * @param {Network} network
     * @param {Coin} coin
     * @returns {Object}
     */
    getJSON(o, s) {
      o = l.get(o);
      let i;
      return s || (i = this.getAddress(), i && (i = i.toString(o))), {
        prevout: this.prevout.toJSON(),
        script: this.script.toJSON(),
        sequence: this.sequence,
        address: i,
        coin: s ? s.getJSON(o, !0) : void 0
      };
    }
    /**
     * Inject properties from a JSON object.
     * @private
     * @param {Object} json
     */
    fromJSON(o) {
      return e(o, "Input data is required."), e(
        o.sequence >>> 0 === o.sequence,
        "Sequence must be a uint32."
      ), this.prevout.fromJSON(o.prevout), this.script.fromJSON(o.script), this.sequence = o.sequence, this;
    }
    /**
     * Instantiate an Input from a jsonified input object.
     * @param {Object} json - The jsonified input object.
     * @returns {Input}
     */
    static fromJSON(o) {
      return new this().fromJSON(o);
    }
    /**
     * Calculate size of serialized input.
     * @returns {Number}
     */
    getSize() {
      return 40 + this.script.getVarSize();
    }
    /**
     * Serialize the input.
     * @param {String?} enc - Encoding, can be `'hex'` or null.
     * @returns {Buffer|String}
     */
    toRaw() {
      const o = this.getSize();
      return this.toWriter(c.write(o)).render();
    }
    /**
     * Write the input to a buffer writer.
     * @param {BufferWriter} bw
     */
    toWriter(o) {
      return this.prevout.toWriter(o), o.writeVarBytes(this.script.toRaw()), o.writeU32(this.sequence), o;
    }
    /**
     * Inject properties from buffer reader.
     * @private
     * @param {BufferReader} br
     */
    fromReader(o) {
      return this.prevout.fromReader(o), this.script.fromRaw(o.readVarBytes()), this.sequence = o.readU32(), this;
    }
    /**
     * Inject properties from serialized data.
     * @param {Buffer} data
     */
    fromRaw(o) {
      return this.fromReader(c.read(o));
    }
    /**
     * Instantiate an input from a buffer reader.
     * @param {BufferReader} br
     * @returns {Input}
     */
    static fromReader(o) {
      return new this().fromReader(o);
    }
    /**
     * Instantiate an input from a serialized Buffer.
     * @param {Buffer} data
     * @param {String?} enc - Encoding, can be `'hex'` or null.
     * @returns {Input}
     */
    static fromRaw(o, s) {
      return typeof o == "string" && (o = k.from(o, s)), new this().fromRaw(o);
    }
    /**
     * Inject properties from outpoint.
     * @private
     * @param {Outpoint} outpoint
     */
    fromOutpoint(o) {
      return e(k.isBuffer(o.hash)), e(typeof o.index == "number"), this.prevout.hash = o.hash, this.prevout.index = o.index, this;
    }
    /**
     * Instantiate input from outpoint.
     * @param {Outpoint}
     * @returns {Input}
     */
    static fromOutpoint(o) {
      return new this().fromOutpoint(o);
    }
    /**
     * Inject properties from coin.
     * @private
     * @param {Coin} coin
     */
    fromCoin(o) {
      return e(k.isBuffer(o.hash)), e(typeof o.index == "number"), this.prevout.hash = o.hash, this.prevout.index = o.index, this;
    }
    /**
     * Instantiate input from coin.
     * @param {Coin}
     * @returns {Input}
     */
    static fromCoin(o) {
      return new this().fromCoin(o);
    }
    /**
     * Inject properties from transaction.
     * @private
     * @param {TX} tx
     * @param {Number} index
     */
    fromTX(o, s) {
      return e(o), e(typeof s == "number"), e(s >= 0 && s < o.outputs.length), this.prevout.hash = o.hash(), this.prevout.index = s, this;
    }
    /**
     * Instantiate input from tx.
     * @param {TX} tx
     * @param {Number} index
     * @returns {Input}
     */
    static fromTX(o, s) {
      return new this().fromTX(o, s);
    }
    /**
     * Test an object to see if it is an Input.
     * @param {Object} obj
     * @returns {Boolean}
     */
    static isInput(o) {
      return o instanceof n;
    }
  }
  return oh = n, oh;
}
var ah, ib;
function In() {
  if (ib) return ah;
  ib = 1;
  const e = Xe(), c = At(), l = mr(), w = zr(), { BufferSet: m } = $r(), f = Qt(), n = wi(), u = Or(), o = Cr(), s = Io(), i = Bo(), p = Si(), g = Ei(), S = ko(), y = Lt(), b = vi(), h = So(), { encoding: a } = c, { hashType: E } = o, H = fs(), { inspectSymbol: j } = Kt();
  class G {
    /**
     * Create a transaction.
     * @constructor
     * @param {Object?} options
     */
    constructor(A) {
      this.version = 1, this.inputs = [], this.outputs = [], this.locktime = 0, this.mutable = !1, this._hash = null, this._hhash = null, this._raw = null, this._offset = -1, this._block = !1, this._size = -1, this._sigops = -1, this._hashPrevouts = null, this._hashSequence = null, this._hashOutputs = null, A && this.fromOptions(A);
    }
    /**
     * Inject properties from options object.
     * @private
     * @param {Object} options
     */
    fromOptions(A) {
      if (e(A, "TX data is required."), A.version != null && (e(
        A.version >>> 0 === A.version,
        "Version must be a uint32."
      ), this.version = A.version), A.inputs) {
        e(Array.isArray(A.inputs), "Inputs must be an array.");
        for (const q of A.inputs)
          this.inputs.push(new i(q));
      }
      if (A.outputs) {
        e(Array.isArray(A.outputs), "Outputs must be an array.");
        for (const q of A.outputs)
          this.outputs.push(new p(q));
      }
      return A.locktime != null && (e(
        A.locktime >>> 0 === A.locktime,
        "Locktime must be a uint32."
      ), this.locktime = A.locktime), A.slpToken && A.slpToken.constructor === s.TokenRecord().constructor && (this.slpToken = A.slpToken), this;
    }
    /**
     * Instantiate TX from options object.
     * @param {Object} options
     * @returns {TX}
     */
    static fromOptions(A) {
      return new this().fromOptions(A);
    }
    /**
     * Clone the transaction.
     * @returns {TX}
     */
    clone() {
      return new this.constructor().inject(this);
    }
    /**
     * Inject properties from tx.
     * Used for cloning.
     * @private
     * @param {TX} tx
     * @returns {TX}
     */
    inject(A) {
      this.version = A.version;
      for (const q of A.inputs)
        this.inputs.push(q.clone());
      for (const q of A.outputs)
        this.outputs.push(q.clone());
      return this.locktime = A.locktime, this;
    }
    /**
     * Clear any cached values.
     */
    refresh() {
      this._hash = null, this._hhash = null, this._raw = null, this._size = -1, this._offset = -1, this._block = !1, this._sigops = -1, this._hashPrevouts = null, this._hashSequence = null, this._hashOutputs = null;
    }
    /**
     * Hash the transaction with the non-witness serialization.
     * @param {String?} enc - Can be `'hex'` or `null`.
     * @returns {Hash|Buffer} hash
     */
    hash(A) {
      let q = this._hash;
      if (q || (q = l.digest(this.toRaw()), this.mutable || (this._hash = q)), A === "hex") {
        let _ = this._hhash;
        _ || (_ = q.toString("hex"), this.mutable || (this._hhash = _)), q = _;
      }
      return q;
    }
    /**
     * Serialize the transaction. Note
     * that this is cached.
     * @returns {Buffer} Serialized transaction.
     */
    toRaw() {
      return this.frame().data;
    }
    /**
     * Write the transaction to a buffer writer.
     * @param {BufferWriter} bw
     * @param {Boolean} block
     */
    toWriter(A, q) {
      return this.mutable ? this.writeNormal(A) : (q && (this._offset = A.offset, this._block = !0), A.writeBytes(this.toRaw()), A);
    }
    /**
     * Serialize the transaction. Note
     * that this is cached.
     * @private
     * @returns {RawTX}
     */
    frame() {
      if (this.mutable)
        return e(!this._raw), this.frameNormal();
      if (this._raw) {
        e(this._size >= 0);
        const q = new N(this._size);
        return q.data = this._raw, q;
      }
      const A = this.frameNormal();
      return this._raw = A.data, this._size = A.size, A;
    }
    /**
     * Return the offset and size of the transaction. Useful
     * when the transaction is deserialized within a block.
     * @returns {Object} contains `size` and `offset`.
     */
    getPosition() {
      return this._block && this._offset > 80 || console.log(this), e(this._block && this._offset > 80, "Position not available."), {
        offset: this._offset,
        size: this._size
      };
    }
    /**
     * Calculate the real size of the transaction.
     * @returns {Number} size
     */
    getSize() {
      return this.mutable ? this.getNormalSizes().size : this.frame().size;
    }
    /**
     * Get the signature hash of the transaction for signing verifying.
     * @param {Number} index - Index of input being signed/verified.
     * @param {Script} prev - Previous output script or redeem script.
     * @param {Amount} value - Previous output value.
     * @param {SighashType} type - Sighash type.
     * @param {Number} flags - Script flags.
     * @returns {Buffer} Signature hash.
     */
    signatureHash(A, q, _, F, R) {
      if (e(A >= 0 && A < this.inputs.length), e(q instanceof o), e(typeof _ == "number"), e(typeof F == "number"), R == null && (R = o.flags.STANDARD_VERIFY_FLAGS), R & o.flags.VERIFY_REPLAY_PROTECTION) {
        const L = H.getHashTypeForkValue(F) ^ 57005;
        F = H.hashTypeWithForkValue(F, L | 16711680);
      }
      return F & o.hashType.SIGHASH_FORKID && R & o.flags.VERIFY_SIGHASH_FORKID ? this.signatureHashV1(A, q, _, F) : this.signatureHashV0(A, q, F);
    }
    /**
     * Legacy sighashing -- O(n^2).
     * @private
     * @param {Number} index
     * @param {Script} prev
     * @param {SighashType} type
     * @returns {Buffer}
     */
    signatureHashV0(A, q, _) {
      if ((_ & 31) === E.SINGLE && A >= this.outputs.length) {
        const L = k.alloc(32, 0);
        return L[0] = 1, L;
      }
      q = q.removeSeparators();
      const F = this.hashSize(A, q, _), R = c.pool(F);
      if (R.writeU32(this.version), _ & E.ANYONECANPAY) {
        const L = this.inputs[A];
        R.writeVarint(1), L.prevout.toWriter(R), R.writeVarBytes(q.toRaw()), R.writeU32(L.sequence);
      } else {
        R.writeVarint(this.inputs.length);
        for (let L = 0; L < this.inputs.length; L++) {
          const fe = this.inputs[L];
          if (fe.prevout.toWriter(R), L === A) {
            R.writeVarBytes(q.toRaw()), R.writeU32(fe.sequence);
            continue;
          }
          switch (R.writeVarint(0), _ & 31) {
            case E.NONE:
            case E.SINGLE:
              R.writeU32(0);
              break;
            default:
              R.writeU32(fe.sequence);
              break;
          }
        }
      }
      switch (_ & 31) {
        case E.NONE: {
          R.writeVarint(0);
          break;
        }
        case E.SINGLE: {
          const L = this.outputs[A];
          R.writeVarint(A + 1);
          for (let fe = 0; fe < A; fe++)
            R.writeI64(-1), R.writeVarint(0);
          L.toWriter(R);
          break;
        }
        default: {
          R.writeVarint(this.outputs.length);
          for (const L of this.outputs)
            L.toWriter(R);
          break;
        }
      }
      return R.writeU32(this.locktime), R.writeU32(_), l.digest(R.render());
    }
    /**
     * Calculate sighash size.
     * @private
     * @param {Number} index
     * @param {Script} prev
     * @param {Number} type
     * @returns {Number}
     */
    hashSize(A, q, _) {
      let F = 0;
      switch (F += 4, _ & E.ANYONECANPAY ? (F += 1, F += 36, F += q.getVarSize(), F += 4) : (F += a.sizeVarint(this.inputs.length), F += 41 * (this.inputs.length - 1), F += 36, F += q.getVarSize(), F += 4), _ & 31) {
        case E.NONE:
          F += 1;
          break;
        case E.SINGLE:
          F += a.sizeVarint(A + 1), F += 9 * A, F += this.outputs[A].getSize();
          break;
        default:
          F += a.sizeVarint(this.outputs.length);
          for (const R of this.outputs)
            F += R.getSize();
          break;
      }
      return F += 8, F;
    }
    /**
     * Witness sighashing -- O(n).
     * @private
     * @param {Number} index
     * @param {Script} prev
     * @param {Amount} value
     * @param {SighashType} type
     * @returns {Buffer}
     */
    signatureHashV1(A, q, _, F) {
      const R = this.inputs[A];
      let L = y.ZERO_HASH, fe = y.ZERO_HASH, ue = y.ZERO_HASH;
      if (!(F & E.ANYONECANPAY))
        if (this._hashPrevouts)
          L = this._hashPrevouts;
        else {
          const Q = c.pool(this.inputs.length * 36);
          for (const W of this.inputs)
            W.prevout.toWriter(Q);
          L = l.digest(Q.render()), this.mutable || (this._hashPrevouts = L);
        }
      if (!(F & E.ANYONECANPAY) && (F & 31) !== E.SINGLE && (F & 31) !== E.NONE)
        if (this._hashSequence)
          fe = this._hashSequence;
        else {
          const Q = c.pool(this.inputs.length * 4);
          for (const W of this.inputs)
            Q.writeU32(W.sequence);
          fe = l.digest(Q.render()), this.mutable || (this._hashSequence = fe);
        }
      if ((F & 31) !== E.SINGLE && (F & 31) !== E.NONE)
        if (this._hashOutputs)
          ue = this._hashOutputs;
        else {
          let Q = 0;
          for (const oe of this.outputs)
            Q += oe.getSize();
          const W = c.pool(Q);
          for (const oe of this.outputs)
            oe.toWriter(W);
          ue = l.digest(W.render()), this.mutable || (this._hashOutputs = ue);
        }
      else if ((F & 31) === E.SINGLE && A < this.outputs.length) {
        const Q = this.outputs[A];
        ue = l.digest(Q.toRaw());
      }
      const ae = 156 + q.getVarSize(), D = c.pool(ae);
      return D.writeU32(this.version), D.writeBytes(L), D.writeBytes(fe), D.writeHash(R.prevout.hash), D.writeU32(R.prevout.index), D.writeVarBytes(q.toRaw()), D.writeI64(_), D.writeU32(R.sequence), D.writeBytes(ue), D.writeU32(this.locktime), D.writeU32(F), l.digest(D.render());
    }
    /**
     * Verify signature.
     * @param {Number} index
     * @param {Script} prev
     * @param {Amount} value
     * @param {Buffer} sig
     * @param {Buffer} key
     * @param {Number} flags
     * @returns {Boolean}
     */
    checksig(A, q, _, F, R, L) {
      if (F.length === 0)
        return !1;
      const fe = F[F.length - 1], ue = this.signatureHash(A, q, _, fe, L);
      let ae;
      return H.isSchnorr(F) ? ae = w.schnorrVerify(ue, F.slice(0, -1), R) : ae = w.verifyDER(ue, F.slice(0, -1), R), ae;
    }
    /**
     * Create a signature suitable for inserting into scriptSigs.
     * @param {Number} index - Index of input being signed.
     * @param {Script} prev - Previous output script or redeem script.
     * @param {Amount} value - Previous output value.
     * @param {Buffer} key
     * @param {SighashType} type
     * @param {Number} flags - Script flags.
     * @returns {Buffer} Signature in SCHNORR / DER format.
     */
    signature(A, q, _, F, R, L) {
      let fe;
      R == null && (R = E.ALL), L == null && (L = o.flags.VERIFY_SIGHASH_FORKID);
      const ue = this.signatureHash(A, q, _, R, L), ae = w.signDER(ue, F), D = w.schnorrSign(ue, F);
      H.isSchnorr(D) ? fe = D : fe = ae;
      const Q = c.write(fe.length + 1);
      return Q.writeBytes(fe), Q.writeU8(R), Q.render();
    }
    /**
     * Create a signature suitable for inserting into scriptSigs.
     * @param {Number} index - Index of input being signed.
     * @param {Script} prev - Previous output script or redeem script.
     * @param {Amount} value - Previous output value.
     * @param {Buffer} key
     * @param {SighashType} type
     * @param {Number} flags - Script flags.
     * @returns {Buffer} Signature in Schnorr format.
     */
    schnorrSignature(A, q, _, F, R, L) {
      R == null && (R = E.ALL), L == null && (L = o.flags.VERIFY_SIGHASH_FORKID);
      const fe = this.signatureHash(A, q, _, R, L), ue = w.schnorrSign(fe, F), ae = c.write(ue.length + 1);
      return ae.writeBytes(ue), ae.writeU8(R), ae.render();
    }
    /**
     * Verify all transaction inputs.
     * @param {CoinView} view
     * @param {VerifyFlags?} [flags=STANDARD_VERIFY_FLAGS]
     * @throws {ScriptError} on invalid inputs
     */
    check(A, q) {
      if (this.inputs.length === 0)
        throw new h("UNKNOWN_ERROR", "No inputs.");
      if (!this.isCoinbase())
        for (let _ = 0; _ < this.inputs.length; _++) {
          const { prevout: F } = this.inputs[_], R = A.getOutput(F);
          if (!R)
            throw new h("UNKNOWN_ERROR", "No coin available.");
          this.checkInput(_, R, q);
        }
    }
    /**
     * Verify a transaction input.
     * @param {Number} index - Index of output being
     * verified.
     * @param {Coin|Output} coin - Previous output.
     * @param {VerifyFlags} [flags=STANDARD_VERIFY_FLAGS]
     * @throws {ScriptError} on invalid input
     */
    checkInput(A, q, _) {
      const F = this.inputs[A];
      e(F, "Input does not exist."), e(q, "No coin passed."), o.verify(
        F.script,
        null,
        q.script,
        this,
        A,
        q.value,
        _
      );
    }
    /**
     * Verify the transaction inputs on the worker pool
     * (if workers are enabled).
     * @param {CoinView} view
     * @param {VerifyFlags?} [flags=STANDARD_VERIFY_FLAGS]
     * @param {WorkerPool?} pool
     * @returns {Promise}
     */
    async checkAsync(A, q, _) {
      if (this.inputs.length === 0)
        throw new h("UNKNOWN_ERROR", "No inputs.");
      if (!this.isCoinbase()) {
        if (!_) {
          this.check(A, q);
          return;
        }
        await _.check(this, A, q);
      }
    }
    /**
     * Verify a transaction input asynchronously.
     * @param {Number} index - Index of output being
     * verified.
     * @param {Coin|Output} coin - Previous output.
     * @param {VerifyFlags} [flags=STANDARD_VERIFY_FLAGS]
     * @param {WorkerPool?} pool
     * @returns {Promise}
     */
    async checkInputAsync(A, q, _, F) {
      const R = this.inputs[A];
      if (e(R, "Input does not exist."), e(q, "No coin passed."), !F) {
        this.checkInput(A, q, _);
        return;
      }
      await F.checkInput(this, A, q, _);
    }
    /**
     * Verify all transaction inputs.
     * @param {CoinView} view
     * @param {VerifyFlags?} [flags=STANDARD_VERIFY_FLAGS]
     * @returns {Boolean} Whether the inputs are valid.
     */
    verify(A, q) {
      try {
        this.check(A, q);
      } catch (_) {
        if (_.type === "ScriptError")
          return !1;
        throw _;
      }
      return !0;
    }
    /**
     * Verify a transaction input.
     * @param {Number} index - Index of output being
     * verified.
     * @param {Coin|Output} coin - Previous output.
     * @param {VerifyFlags} [flags=STANDARD_VERIFY_FLAGS]
     * @returns {Boolean} Whether the input is valid.
     */
    verifyInput(A, q, _) {
      try {
        this.checkInput(A, q, _);
      } catch (F) {
        if (F.type === "ScriptError")
          return !1;
        throw F;
      }
      return !0;
    }
    /**
     * Verify the transaction inputs on the worker pool
     * (if workers are enabled).
     * @param {CoinView} view
     * @param {VerifyFlags?} [flags=STANDARD_VERIFY_FLAGS]
     * @param {WorkerPool?} pool
     * @returns {Promise}
     */
    async verifyAsync(A, q, _) {
      try {
        await this.checkAsync(A, q, _);
      } catch (F) {
        if (F.type === "ScriptError")
          return !1;
        throw F;
      }
      return !0;
    }
    /**
     * Verify a transaction input asynchronously.
     * @param {Number} index - Index of output being
     * verified.
     * @param {Coin|Output} coin - Previous output.
     * @param {VerifyFlags} [flags=STANDARD_VERIFY_FLAGS]
     * @param {WorkerPool?} pool
     * @returns {Promise}
     */
    async verifyInputAsync(A, q, _, F) {
      try {
        await this.checkInput(A, q, _, F);
      } catch (R) {
        if (R.type === "ScriptError")
          return !1;
        throw R;
      }
      return !0;
    }
    /**
     * Test whether the transaction is a coinbase
     * by examining the inputs.
     * @returns {Boolean}
     */
    isCoinbase() {
      return this.inputs.length === 1 && this.inputs[0].prevout.isNull();
    }
    /**
     * Test whether the transaction is replaceable.
     * @returns {Boolean}
     */
    isRBF() {
      if (this.version === 2)
        return !1;
      for (const A of this.inputs)
        if (A.isRBF())
          return !0;
      return !1;
    }
    /**
     * Calculate the fee for the transaction.
     * @param {CoinView} view
     * @returns {Amount} fee (zero if not all coins are available).
     */
    getFee(A) {
      return this.hasCoins(A) ? this.getInputValue(A) - this.getOutputValue() : 0;
    }
    /**
     * Calculate the total input value.
     * @param {CoinView} view
     * @returns {Amount} value
     */
    getInputValue(A) {
      let q = 0;
      for (const { prevout: _ } of this.inputs) {
        const F = A.getOutput(_);
        if (!F)
          return 0;
        q += F.value;
      }
      return q;
    }
    /**
     * Calculate the total output value.
     * @returns {Amount} value
     */
    getOutputValue() {
      let A = 0;
      for (const q of this.outputs)
        A += q.value;
      return A;
    }
    /**
     * Get all input addresses.
     * @private
     * @param {CoinView} view
     * @returns {Array} [addrs, table]
     */
    _getInputAddresses(A) {
      const q = new m(), _ = [];
      if (this.isCoinbase())
        return [_, q];
      for (const F of this.inputs) {
        const R = A ? A.getOutputFor(F) : null, L = F.getAddress(R);
        if (!L)
          continue;
        const fe = L.getHash();
        q.has(fe) || (q.add(fe), _.push(L));
      }
      return [_, q];
    }
    /**
     * Get all output addresses.
     * @private
     * @returns {Array} [addrs, table]
     */
    _getOutputAddresses() {
      const A = new m(), q = [];
      for (const _ of this.outputs) {
        const F = _.getAddress();
        if (!F)
          continue;
        const R = F.getHash();
        A.has(R) || (A.add(R), q.push(F));
      }
      return [q, A];
    }
    /**
     * Get all addresses.
     * @private
     * @param {CoinView} view
     * @returns {Array} [addrs, table]
     */
    _getAddresses(A) {
      const [q, _] = this._getInputAddresses(A), F = this.getOutputAddresses();
      for (const R of F) {
        const L = R.getHash();
        _.has(L) || (_.add(L), q.push(R));
      }
      return [q, _];
    }
    /**
     * Get all input addresses.
     * @param {CoinView|null} view
     * @returns {Address[]} addresses
     */
    getInputAddresses(A) {
      const [q] = this._getInputAddresses(A);
      return q;
    }
    /**
     * Get all output addresses.
     * @returns {Address[]} addresses
     */
    getOutputAddresses() {
      const [A] = this._getOutputAddresses();
      return A;
    }
    /**
     * Get all addresses.
     * @param {CoinView|null} view
     * @returns {Address[]} addresses
     */
    getAddresses(A) {
      const [q] = this._getAddresses(A);
      return q;
    }
    /**
     * Get all input address hashes.
     * @param {CoinView|null} view
     * @returns {Hash[]} hashes
     */
    getInputHashes(A, q) {
      const [, _] = this._getInputAddresses(A);
      return q !== "hex" ? _.toArray() : _.toArray().map((F) => F.toString("hex"));
    }
    /**
     * Get all output address hashes.
     * @returns {Hash[]} hashes
     */
    getOutputHashes(A) {
      const [, q] = this._getOutputAddresses();
      return A !== "hex" ? q.toArray() : q.toArray().map((_) => _.toString("hex"));
    }
    /**
     * Get all address hashes.
     * @param {CoinView|null} view
     * @returns {Hash[]} hashes
     */
    getHashes(A, q) {
      const [, _] = this._getAddresses(A);
      return q !== "hex" ? _.toArray() : _.toArray().map((F) => F.toString("hex"));
    }
    /**
     * Test whether the transaction has
     * all coins available.
     * @param {CoinView} view
     * @returns {Boolean}
     */
    hasCoins(A) {
      if (this.inputs.length === 0)
        return !1;
      for (const { prevout: q } of this.inputs)
        if (!A.hasEntry(q))
          return !1;
      return !0;
    }
    /**
     * Check finality of transaction by examining
     * nLocktime and nSequence values.
     * @example
     * tx.isFinal(chain.height + 1, network.now());
     * @param {Number} height - Height at which to test. This
     * is usually the chain height, or the chain height + 1
     * when the transaction entered the mempool.
     * @param {Number} time - Time at which to test. This is
     * usually the chain tip's parent's median time, or the
     * time at which the transaction entered the mempool. If
     * MEDIAN_TIME_PAST is enabled this will be the median
     * time of the chain tip's previous entry's median time.
     * @returns {Boolean}
     */
    isFinal(A, q) {
      const _ = y.LOCKTIME_THRESHOLD;
      if (this.locktime === 0 || this.locktime < (this.locktime < _ ? A : q))
        return !0;
      for (const F of this.inputs)
        if (F.sequence !== 4294967295)
          return !1;
      return !0;
    }
    /**
     * Verify the absolute locktime of a transaction.
     * Called by OP_CHECKLOCKTIMEVERIFY.
     * @param {Number} index - Index of input being verified.
     * @param {Number} predicate - Locktime to verify against.
     * @returns {Boolean}
     */
    verifyLocktime(A, q) {
      const _ = y.LOCKTIME_THRESHOLD, F = this.inputs[A];
      return e(F, "Input does not exist."), e(q >= 0, "Locktime must be non-negative."), !(this.locktime < _ != q < _ || q > this.locktime || F.sequence === 4294967295);
    }
    /**
     * Verify the relative locktime of an input.
     * Called by OP_CHECKSEQUENCEVERIFY.
     * @param {Number} index - Index of input being verified.
     * @param {Number} predicate - Relative locktime to verify against.
     * @returns {Boolean}
     */
    verifySequence(A, q) {
      const _ = y.SEQUENCE_DISABLE_FLAG, F = y.SEQUENCE_TYPE_FLAG, R = y.SEQUENCE_MASK, L = this.inputs[A];
      return e(L, "Input does not exist."), e(q >= 0, "Locktime must be non-negative."), q & _ ? !0 : !(this.version < 2 || L.sequence & _ || (L.sequence & F) !== (q & F) || (q & R) > (L.sequence & R));
    }
    /**
     * Calculate legacy (inaccurate) sigop count.
     * @returns {Number} sigop count
     */
    getLegacySigops() {
      if (this._sigops !== -1)
        return this._sigops;
      let A = 0;
      for (const q of this.inputs)
        A += q.script.getSigops(!1);
      for (const q of this.outputs)
        A += q.script.getSigops(!1);
      return this.mutable || (this._sigops = A), A;
    }
    /**
     * Calculate accurate sigop count, taking into account redeem scripts.
     * @param {CoinView} view
     * @param {VerifyFlags} flags
     * @returns {Number} sigop count
     */
    getScripthashSigops(A, q) {
      if (this.isCoinbase())
        return 0;
      let _ = 0;
      for (const F of this.inputs) {
        const R = A.getOutputFor(F);
        R && R.script.isScripthash() && (_ += R.script.getScripthashSigops(F.script, q));
      }
      return _;
    }
    /**
     * Calculate sigops count.
     * @param {CoinView} view
     * @param {VerifyFlags?} flags
     * @returns {Number} sigop count
     */
    getSigopsCount(A, q) {
      q === null && (q = o.flags.STANDARD_VERIFY_FLAGS);
      let _ = this.getLegacySigops();
      return q & o.flags.VERIFY_P2SH && (_ += this.getScripthashSigops(A, q)), _;
    }
    /**
     * Calculate sigop count.
     * @param {CoinView} view
     * @param {VerifyFlags?} flags
     * @returns {Number} sigop count
     */
    getSigops(A, q) {
      return this.getSigopsCount(A, q);
    }
    /**
     * Non-contextual sanity checks for the transaction.
     * Will mostly verify coin and output values.
     * @see CheckTransaction()
     * @returns {Array} [result, reason, score]
     */
    isSane() {
      const [A] = this.checkSanity();
      return A;
    }
    /**
     * Non-contextual sanity checks for the transaction.
     * Will mostly verify coin and output values.
     * @see CheckTransaction()
     * @returns {Array} [valid, reason, score]
     */
    checkSanity() {
      if (this.inputs.length === 0)
        return [!1, "bad-txns-vin-empty", 100];
      if (this.outputs.length === 0)
        return [!1, "bad-txns-vout-empty", 100];
      if (this.getSize() > y.MAX_TX_SIZE)
        return [!1, "bad-txns-oversize", 100];
      let A = 0;
      for (const _ of this.outputs) {
        if (_.value < 0)
          return [!1, "bad-txns-vout-negative", 100];
        if (_.value > y.MAX_MONEY)
          return [!1, "bad-txns-vout-toolarge", 100];
        if (A += _.value, A < 0 || A > y.MAX_MONEY)
          return [!1, "bad-txns-txouttotal-toolarge", 100];
      }
      const q = new m();
      for (const _ of this.inputs) {
        const F = _.prevout.toKey();
        if (q.has(F))
          return [!1, "bad-txns-inputs-duplicate", 100];
        q.add(F);
      }
      if (this.isCoinbase()) {
        const _ = this.inputs[0].script.getSize();
        if (_ < 2 || _ > y.MAX_COINBASE_SCRIPTSIG_SIZE)
          return [!1, "bad-cb-length", 100];
      } else
        for (const _ of this.inputs)
          if (_.prevout.isNull())
            return [!1, "bad-txns-prevout-null", 10];
      return [!0, "valid", 0];
    }
    /**
     * Non-contextual checks to determine whether the
     * transaction has all standard output script
     * types and standard input script size with only
     * pushdatas in the code.
     * Will mostly verify coin and output values.
     * @see IsStandardTx()
     * @returns {Array} [valid, reason, score]
     */
    isStandard() {
      const [A] = this.checkStandard();
      return A;
    }
    /**
     * Non-contextual checks to determine whether the
     * transaction has all standard output script
     * types and standard input script size with only
     * pushdatas in the code.
     * Will mostly verify coin and output values.
     * @see IsStandardTx()
     * @returns {Array} [valid, reason, score]
     */
    checkStandard() {
      if (this.version < 1 || this.version > b.MAX_TX_VERSION)
        return [!1, "version", 0];
      if (this.getSize() >= b.MAX_TX_SIZE)
        return [!1, "tx-size", 0];
      for (const q of this.inputs) {
        if (q.script.getSize() > 1650)
          return [!1, "scriptsig-size", 0];
        if (!q.script.isPushOnly())
          return [!1, "scriptsig-not-pushonly", 0];
      }
      let A = 0;
      for (const q of this.outputs) {
        if (!q.script.isStandard())
          return [!1, "scriptpubkey", 0];
        if (q.script.isNulldata()) {
          A++;
          continue;
        }
        if (q.script.isMultisig() && !b.BARE_MULTISIG)
          return [!1, "bare-multisig", 0];
        if (q.isDust(b.MIN_RELAY))
          return [!1, "dust", 0];
      }
      return A > 1 ? [!1, "multi-op-return", 0] : [!0, "valid", 0];
    }
    /**
     * Perform contextual checks to verify coin and input
     * script standardness (including the redeem script).
     * @see AreInputsStandard()
     * @param {CoinView} view
     * @param {VerifyFlags?} flags
     * @returns {Boolean}
     */
    hasStandardInputs(A) {
      if (this.isCoinbase())
        return !0;
      for (const q of this.inputs) {
        const _ = A.getOutputFor(q);
        if (!_)
          return !1;
        if (!_.script.isPubkeyhash()) {
          if (_.script.isScripthash()) {
            const F = q.script.getRedeem();
            if (!F || F.getSigops(!0) > b.MAX_P2SH_SIGOPS)
              return !1;
            continue;
          }
          if (_.script.isUnknown())
            return !1;
        }
      }
      return !0;
    }
    /**
     * Perform contextual checks to verify input, output,
     * and fee values, as well as coinbase spend maturity
     * (coinbases can only be spent 100 blocks or more
     * after they're created). Note that this function is
     * consensus critical.
     * @param {CoinView} view
     * @param {Number} height - Height at which the
     * transaction is being spent. In the mempool this is
     * the chain height plus one at the time it entered the pool.
     * @returns {Boolean}
     */
    verifyInputs(A, q) {
      const [_] = this.checkInputs(A, q);
      return _ !== -1;
    }
    /**
     * Perform contextual checks to verify input, output,
     * and fee values, as well as coinbase spend maturity
     * (coinbases can only be spent 100 blocks or more
     * after they're created). Note that this function is
     * consensus critical.
     * @param {CoinView} view
     * @param {Number} height - Height at which the
     * transaction is being spent. In the mempool this is
     * the chain height plus one at the time it entered the pool.
     * @returns {Array} [fee, reason, score]
     */
    checkInputs(A, q) {
      e(typeof q == "number");
      let _ = 0;
      for (const { prevout: L } of this.inputs) {
        const fe = A.getEntry(L);
        if (!fe)
          return [-1, "bad-txns-inputs-missingorspent", 0];
        if (fe.coinbase && q - fe.height < y.COINBASE_MATURITY)
          return [-1, "bad-txns-premature-spend-of-coinbase", 0];
        const ue = A.getOutput(L);
        if (e(ue), ue.value < 0 || ue.value > y.MAX_MONEY)
          return [-1, "bad-txns-inputvalues-outofrange", 100];
        if (_ += ue.value, _ < 0 || _ > y.MAX_MONEY)
          return [-1, "bad-txns-inputvalues-outofrange", 100];
      }
      const F = this.getOutputValue();
      if (_ < F)
        return [-1, "bad-txns-in-belowout", 100];
      const R = _ - F;
      return R < 0 ? [-1, "bad-txns-fee-negative", 100] : R > y.MAX_MONEY ? [-1, "bad-txns-fee-outofrange", 100] : [R, "valid", 0];
    }
    /**
     * Calculate the modified size of the transaction. This
     * is used in the mempool for calculating priority.
     * @param {Number?} size - The size to modify. If not present,
     * virtual size will be used.
     * @returns {Number} Modified size.
     */
    getModifiedSize(A) {
      A == null && (A = this.getSize());
      for (const q of this.inputs) {
        const _ = 41 + Math.min(110, q.script.getSize());
        A > _ && (A -= _);
      }
      return A;
    }
    /**
     * Calculate the transaction priority.
     * @param {CoinView} view
     * @param {Number} height
     * @param {Number?} size - Size to calculate priority
     * based on. If not present, virtual size will be used.
     * @returns {Number}
     */
    getPriority(A, q, _) {
      if (e(typeof q == "number", "Must pass in height."), this.isCoinbase())
        return 0;
      _ == null && (_ = this.getSize());
      let F = 0;
      for (const { prevout: R } of this.inputs) {
        const L = A.getOutput(R);
        if (!L)
          continue;
        const fe = A.getHeight(R);
        if (fe !== -1 && fe <= q) {
          const ue = q - fe;
          F += L.value * ue;
        }
      }
      return Math.floor(F / _);
    }
    /**
     * Calculate the transaction's on-chain value.
     * @param {CoinView} view
     * @returns {Number}
     */
    getChainValue(A) {
      if (this.isCoinbase())
        return 0;
      let q = 0;
      for (const { prevout: _ } of this.inputs) {
        const F = A.getOutput(_);
        !F || A.getHeight(_) === -1 || (q += F.value);
      }
      return q;
    }
    /**
     * Determine whether the transaction is above the
     * free threshold in priority. A transaction which
     * passed this test is most likely relayable
     * without a fee.
     * @param {CoinView} view
     * @param {Number?} height - If not present, tx
     * height or network height will be used.
     * @param {Number?} size - If not present, modified
     * size will be calculated and used.
     * @returns {Boolean}
     */
    isFree(A, q, _) {
      return this.getPriority(A, q, _) > b.FREE_THRESHOLD;
    }
    /**
     * Calculate minimum fee in order for the transaction
     * to be relayable (not the constant min relay fee).
     * @param {Number?} size - If not present, max size
     * estimation will be calculated and used.
     * @param {Rate?} rate - Rate of satoshi per kB.
     * @returns {Amount} fee
     */
    getMinFee(A, q) {
      return A == null && (A = this.getSize()), b.getMinFee(A, q);
    }
    /**
     * Calculate the minimum fee in order for the transaction
     * to be relayable, but _round to the nearest kilobyte
     * when taking into account size.
     * @param {Number?} size - If not present, max size
     * estimation will be calculated and used.
     * @param {Rate?} rate - Rate of satoshi per kB.
     * @returns {Amount} fee
     */
    getRoundFee(A, q) {
      return A == null && (A = this.getSize()), b.getRoundFee(A, q);
    }
    /**
     * Calculate the transaction's rate based on size
     * and fees. Size will be calculated if not present.
     * @param {CoinView} view
     * @param {Number?} size
     * @returns {Rate}
     */
    getRate(A, q) {
      const _ = this.getFee(A);
      return _ < 0 ? 0 : (q == null && (q = this.getSize()), b.getRate(q, _));
    }
    /**
     * Get all unique outpoint hashes.
     * @returns {Hash[]} Outpoint hashes.
     */
    getPrevout() {
      if (this.isCoinbase())
        return [];
      const A = new m();
      for (const q of this.inputs)
        A.add(q.prevout.hash);
      return A.toArray();
    }
    /**
     * Test a transaction against a bloom filter using
     * the BIP37 matching algorithm. Note that this may
     * update the filter depending on what the `update`
     * value is.
     * @see "Filter matching algorithm":
     * @see https://github.com/bitcoin/bips/blob/master/bip-0037.mediawiki
     * @param {BloomFilter} filter
     * @returns {Boolean} True if the transaction matched.
     */
    isWatched(A) {
      let q = !1;
      A.test(this.hash()) && (q = !0);
      for (let _ = 0; _ < this.outputs.length; _++) {
        const F = this.outputs[_];
        if (F.script.test(A)) {
          if (A.update === 1) {
            const R = g.fromTX(this, _);
            A.add(R.toRaw());
          } else if (A.update === 2 && (F.script.isPubkey() || F.script.isMultisig())) {
            const R = g.fromTX(this, _);
            A.add(R.toRaw());
          }
          q = !0;
        }
      }
      if (q)
        return q;
      for (const _ of this.inputs) {
        const F = _.prevout;
        if (A.test(F.toRaw()) || _.script.test(A))
          return !0;
      }
      return !1;
    }
    /**
     * Get little-endian tx hash.
     * @returns {Hash}
     */
    rhash() {
      return f.revHex(this.hash());
    }
    /**
     * Get little-endian tx hash.
     * @returns {Hash}
     */
    txid() {
      return this.rhash();
    }
    /**
     * Convert the tx to an inv item.
     * @returns {InvItem}
     */
    toInv() {
      return new S(S.types.TX, this.hash());
    }
    /**
     * Inspect the transaction and return a more
     * user-friendly representation of the data.
     * @returns {Object}
     */
    [j]() {
      return this.format();
    }
    /**
     * Inspect the transaction and return a more
     * user-friendly representation of the data.
     * @param {CoinView} view
     * @param {ChainEntry} entry
     * @param {Number} index
     * @returns {Object}
     */
    format(A, q, _) {
      let F = 0, R = 0, L = -1, fe = null, ue = 0, ae = null;
      A && (R = this.getFee(A), F = this.getRate(A), Number.isSafeInteger(F) || (F = 0)), q && (L = q.height, fe = f.revHex(q.hash), ue = q.time, ae = f.date(ue)), _ == null && (_ = -1);
      const D = {
        hash: this.txid(),
        size: this.getSize(),
        value: n.btc(this.getOutputValue()),
        fee: n.btc(R),
        rate: n.btc(F),
        minFee: n.btc(this.getMinFee()),
        height: L,
        block: fe,
        time: ue,
        date: ae,
        index: _,
        version: this.version,
        inputs: this.inputs.map((Q) => {
          const W = A ? A.getOutputFor(Q) : null;
          return Q.format(W);
        }),
        outputs: this.outputs,
        locktime: this.locktime
      };
      return this.slpToken ? {
        ...D,
        slpToken: this.slpToken
      } : D;
    }
    /**
     * Convert the transaction to an object suitable
     * for JSON serialization.
     * @returns {Object}
     */
    toJSON() {
      return this.getJSON();
    }
    /**
     * Convert the transaction to an object suitable
     * for JSON serialization. Note that the hashes
     * will be reversed to abide by bitcoind's legacy
     * of little-endian uint256s.
     * @param {Network} network
     * @param {CoinView} view
     * @param {ChainEntry} entry
     * @param {Number} index
     * @returns {Object}
     */
    getJSON(A, q, _, F) {
      let R, L, fe, ue, ae, D;
      q && (L = this.getFee(q), R = this.getRate(q), Number.isSafeInteger(R) || (R = 0)), _ && (fe = _.height, ue = f.revHex(_.hash), ae = _.time, D = f.date(ae)), A = u.get(A);
      const Q = {
        hash: this.txid(),
        fee: L,
        rate: R,
        mtime: f.now(),
        height: fe,
        block: ue,
        time: ae,
        date: D,
        index: F,
        version: this.version,
        inputs: this.inputs.map((W) => {
          const oe = q ? q.getCoinFor(W) : null;
          return W.getJSON(A, oe);
        }),
        outputs: this.outputs.map((W) => W.getJSON(A)),
        locktime: this.locktime,
        hex: this.toRaw().toString("hex")
      };
      return this.slpToken ? {
        ...Q,
        slpToken: this.slpToken.getJSON()
      } : Q;
    }
    /**
     * Inject properties from a json object.
     * @private
     * @param {Object} json
     */
    fromJSON(A) {
      e(A, "TX data is required."), e(A.version >>> 0 === A.version, "Version must be a uint32."), e(Array.isArray(A.inputs), "Inputs must be an array."), e(Array.isArray(A.outputs), "Outputs must be an array."), e(
        A.locktime >>> 0 === A.locktime,
        "Locktime must be a uint32."
      ), this.version = A.version;
      for (const q of A.inputs)
        this.inputs.push(i.fromJSON(q));
      for (const q of A.outputs)
        this.outputs.push(p.fromJSON(q));
      return this.locktime = A.locktime, A.slpToken && (this.slpToken = s.TokenRecord().fromJSON(A.slpToken)), this;
    }
    /**
     * Instantiate a transaction from a
     * jsonified transaction object.
     * @param {Object} json - The jsonified transaction object.
     * @returns {TX}
     */
    static fromJSON(A) {
      return new this().fromJSON(A);
    }
    /**
     * Instantiate a transaction from a serialized Buffer.
     * @param {Buffer} data
     * @param {String?} enc - Encoding, can be `'hex'` or null.
     * @returns {TX}
     */
    static fromRaw(A, q) {
      return typeof A == "string" && (A = k.from(A, q)), new this().fromRaw(A);
    }
    /**
     * Instantiate a transaction from a buffer reader.
     * @param {BufferReader} br
     * @param {Boolean} block
     * @returns {TX}
     */
    static fromReader(A, q) {
      return new this().fromReader(A, q);
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     */
    fromRaw(A) {
      return this.fromReader(c.read(A));
    }
    /**
     * Inject properties from buffer reader.
     * @private
     * @param {BufferReader} br
     * @param {Boolean} block
     */
    fromReader(A, q) {
      const _ = A.start();
      this.version = A.readU32();
      const F = A.readVarint();
      for (let L = 0; L < F; L++)
        this.inputs.push(i.fromReader(A));
      const R = A.readVarint();
      for (let L = 0; L < R; L++)
        this.outputs.push(p.fromReader(A));
      return this.locktime = A.readU32(), q && (this._offset = _, this._block = !0), this.mutable ? A.end() : (this._raw = A.endData(), this._size = this._raw.length), this;
    }
    /**
     * Serialize transaction without witness.
     * @private
     * @returns {RawTX}
     */
    frameNormal() {
      const A = this.getNormalSizes(), q = c.write(A.size);
      return this.writeNormal(q), A.data = q.render(), A;
    }
    /**
     * Serialize transaction without witness.
     * @private
     * @param {BufferWriter} bw
     * @returns {RawTX}
     */
    writeNormal(A) {
      if (this.inputs.length === 0 && this.outputs.length !== 0)
        throw new Error("Cannot serialize zero-input tx.");
      A.writeU32(this.version), A.writeVarint(this.inputs.length);
      for (const q of this.inputs)
        q.toWriter(A);
      A.writeVarint(this.outputs.length);
      for (const q of this.outputs)
        q.toWriter(A);
      return A.writeU32(this.locktime), A;
    }
    /**
     * Calculate the real size of the transaction
     * without the witness vector.
     * @returns {RawTX}
     */
    getNormalSizes() {
      let A = 0;
      A += 4, A += a.sizeVarint(this.inputs.length);
      for (const q of this.inputs)
        A += q.getSize();
      A += a.sizeVarint(this.outputs.length);
      for (const q of this.outputs)
        A += q.getSize();
      return A += 4, new N(A, 0);
    }
    /**
     * Test whether an object is a TX.
     * @param {Object} obj
     * @returns {Boolean}
     */
    static isTX(A) {
      return A instanceof G;
    }
  }
  class N {
    constructor(A) {
      this.data = null, this.size = A;
    }
  }
  return ah = G, ah;
}
var fh, nb;
function hs() {
  if (nb) return fh;
  nb = 1;
  const e = At(), c = Qt(), l = us(), { inspectSymbol: w } = Kt();
  class m extends l {
    /**
     * Create headers.
     * @constructor
     * @param {Object} options
     */
    constructor(n) {
      super(), n && this.parseOptions(n);
    }
    /**
     * Perform non-contextual
     * verification on the headers.
     * @returns {Boolean}
     */
    verifyBody() {
      return !0;
    }
    /**
     * Get size of the headers.
     * @returns {Number}
     */
    getSize() {
      return 81;
    }
    /**
     * Serialize the headers to a buffer writer.
     * @param {BufferWriter} bw
     */
    toWriter(n) {
      return this.writeHead(n), n.writeVarint(0), n;
    }
    /**
     * Serialize the headers.
     * @returns {Buffer|String}
     */
    toRaw() {
      const n = this.getSize();
      return this.toWriter(e.write(n)).render();
    }
    /**
     * Inject properties from buffer reader.
     * @private
     * @param {Buffer} data
     */
    fromReader(n) {
      return this.readHead(n), n.readVarint(), this;
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     */
    fromRaw(n) {
      return this.fromReader(e.read(n));
    }
    /**
     * Instantiate headers from buffer reader.
     * @param {BufferReader} br
     * @returns {Headers}
     */
    static fromReader(n) {
      return new this().fromReader(n);
    }
    /**
     * Instantiate headers from serialized data.
     * @param {Buffer} data
     * @param {String?} enc - Encoding, can be `'hex'` or null.
     * @returns {Headers}
     */
    static fromRaw(n, u) {
      return typeof n == "string" && (n = k.from(n, u)), new this().fromRaw(n);
    }
    /**
     * Instantiate headers from serialized data.
     * @param {Buffer} data
     * @param {String?} enc - Encoding, can be `'hex'` or null.
     * @returns {Headers}
     */
    static fromHead(n, u) {
      return typeof n == "string" && (n = k.from(n, u)), new this().fromHead(n);
    }
    /**
     * Instantiate headers from a chain entry.
     * @param {ChainEntry} entry
     * @returns {Headers}
     */
    static fromEntry(n) {
      const u = new this();
      return u.version = n.version, u.prevBlock = n.prevBlock, u.merkleRoot = n.merkleRoot, u.time = n.time, u.bits = n.bits, u.nonce = n.nonce, u._hash = n.hash, u._hhash = n.hash, u;
    }
    /**
     * Convert the block to a headers object.
     * @returns {Headers}
     */
    toHeaders() {
      return this;
    }
    /**
     * Convert the block to a headers object.
     * @param {Block|MerkleBlock} block
     * @returns {Headers}
     */
    static fromBlock(n) {
      const u = new this(n);
      return u._hash = n._hash, u._hhash = n._hhash, u;
    }
    /**
     * Convert the block to an object suitable
     * for JSON serialization.
     * @returns {Object}
     */
    toJSON() {
      return this.getJSON();
    }
    /**
     * Convert the block to an object suitable
     * for JSON serialization. Note that the hashes
     * will be reversed to abide by bitcoind's legacy
     * of little-endian uint256s.
     * @param {Network} network
     * @param {CoinView} view
     * @param {Number} height
     * @returns {Object}
     */
    getJSON(n, u, o) {
      return {
        hash: this.rhash(),
        height: o,
        version: this.version,
        prevBlock: c.revHex(this.prevBlock),
        merkleRoot: c.revHex(this.merkleRoot),
        time: this.time,
        bits: this.bits,
        nonce: this.nonce
      };
    }
    /**
     * Inject properties from json object.
     * @private
     * @param {Object} json
     */
    fromJSON(n) {
      return this.parseJSON(n), this;
    }
    /**
     * Instantiate a merkle block from a jsonified block object.
     * @param {Object} json - The jsonified block object.
     * @returns {Headers}
     */
    static fromJSON(n) {
      return new this().fromJSON(n);
    }
    /**
     * Inspect the headers and return a more
     * user-friendly representation of the data.
     * @returns {Object}
     */
    [w]() {
      return this.format();
    }
    /**
     * Inspect the headers and return a more
     * user-friendly representation of the data.
     * @param {CoinView} view
     * @param {Number} height
     * @returns {Object}
     */
    format(n, u) {
      return {
        hash: this.rhash(),
        height: u ?? -1,
        date: c.date(this.time),
        version: this.version.toString(16),
        prevBlock: c.revHex(this.prevBlock),
        merkleRoot: c.revHex(this.merkleRoot),
        time: this.time,
        bits: this.bits,
        nonce: this.nonce
      };
    }
    /**
     * Test an object to see if it is a Headers object.
     * @param {Object} obj
     * @returns {Boolean}
     */
    static isHeaders(n) {
      return n instanceof m;
    }
  }
  return fh = m, fh;
}
var ch, sb;
function l1() {
  if (sb) return ch;
  sb = 1;
  const e = Xe(), c = At(), { BufferMap: l, BufferSet: w } = $r(), m = Qt(), f = mr(), n = Lt(), u = us(), o = hs(), s = k.from([0]), { encoding: i } = c, { inspectSymbol: p } = Kt();
  class g extends u {
    /**
     * Create a merkle block.
     * @constructor
     * @param {Object} options
     */
    constructor(b) {
      super(), this.txs = [], this.hashes = [], this.flags = s, this.totalTX = 0, this._tree = null, b && this.fromOptions(b);
    }
    /**
     * Inject properties from options object.
     * @private
     * @param {Object} options
     */
    fromOptions(b) {
      if (this.parseOptions(b), e(b, "MerkleBlock data is required."), e(Array.isArray(b.hashes)), e(k.isBuffer(b.flags)), e(b.totalTX >>> 0 === b.totalTX), b.hashes)
        for (const h of b.hashes)
          e(k.isBuffer(h)), this.hashes.push(h);
      return b.flags && (e(k.isBuffer(b.flags)), this.flags = b.flags), b.totalTX != null && (e(b.totalTX >>> 0 === b.totalTX), this.totalTX = b.totalTX), this;
    }
    /**
     * Instantiate merkle block from options object.
     * @param {Object} options
     * @returns {MerkleBlock}
     */
    static fromOptions(b) {
      return new this().fromOptions(b);
    }
    /**
     * Clear any cached values.
     * @param {Boolean?} all - Clear transactions.
     */
    refresh(b) {
      if (this._refresh(), this._tree = null, !!b)
        for (const h of this.txs)
          h.refresh();
    }
    /**
     * Test the block's _matched_ transaction vector against a hash.
     * @param {Hash} hash
     * @returns {Boolean}
     */
    hasTX(b) {
      return this.indexOf(b) !== -1;
    }
    /**
     * Test the block's _matched_ transaction vector against a hash.
     * @param {Hash} hash
     * @returns {Number} Index.
     */
    indexOf(b) {
      const a = this.getTree().map.get(b);
      return a ?? -1;
    }
    /**
     * Verify the partial merkletree.
     * @private
     * @returns {Boolean}
     */
    verifyBody() {
      const [b] = this.checkBody();
      return b;
    }
    /**
     * Verify the partial merkletree.
     * @private
     * @returns {Array} [valid, reason, score]
     */
    checkBody() {
      return this.getTree().root.equals(this.merkleRoot) ? [!0, "valid", 0] : [!1, "bad-txnmrklroot", 100];
    }
    /**
     * Extract the matches from partial merkle
     * tree and calculate merkle root.
     * @returns {Object}
     */
    getTree() {
      if (!this._tree)
        try {
          this._tree = this.extractTree();
        } catch {
          this._tree = new S();
        }
      return this._tree;
    }
    /**
     * Extract the matches from partial merkle
     * tree and calculate merkle root.
     * @private
     * @returns {Object}
     */
    extractTree() {
      const b = [], h = [], a = new l(), E = this.hashes, H = this.flags, j = this.totalTX;
      let G = 0, N = 0, T = !1, A = 0;
      const q = (R) => j + (1 << R) - 1 >>> R, _ = (R, L) => {
        if (G >= H.length * 8)
          return T = !0, n.ZERO_HASH;
        const fe = H[G / 8 | 0] >>> G % 8 & 1;
        if (G += 1, R === 0 || !fe) {
          if (N >= E.length)
            return T = !0, n.ZERO_HASH;
          const D = E[N];
          return N += 1, R === 0 && fe && (b.push(D), h.push(L), a.set(D, L)), D;
        }
        const ue = _(R - 1, L * 2);
        let ae;
        return L * 2 + 1 < q(R - 1) ? (ae = _(R - 1, L * 2 + 1), ae.equals(ue) && (T = !0)) : ae = ue, f.root(ue, ae);
      };
      if (j === 0)
        throw new Error("Zero transactions.");
      if (E.length > j)
        throw new Error("Too many hashes.");
      if (H.length * 8 < E.length)
        throw new Error("Flags too small.");
      for (; q(A) > 1; )
        A += 1;
      const F = _(A, 0);
      if (T)
        throw new Error("Mutated merkle tree.");
      if (((G + 7) / 8 | 0) !== H.length)
        throw new Error("Too many flag bits.");
      if (N !== E.length)
        throw new Error("Incorrect number of hashes.");
      return new S(F, b, h, a);
    }
    /**
     * Extract the coinbase height (always -1).
     * @returns {Number}
     */
    getCoinbaseHeight() {
      return -1;
    }
    /**
     * Inspect the block and return a more
     * user-friendly representation of the data.
     * @returns {Object}
     */
    [p]() {
      return this.format();
    }
    /**
     * Inspect the block and return a more
     * user-friendly representation of the data.
     * @param {CoinView} view
     * @param {Number} height
     * @returns {Object}
     */
    format(b, h) {
      return {
        hash: this.rhash(),
        height: h ?? -1,
        date: m.date(this.time),
        version: this.version.toString(16),
        prevBlock: m.revHex(this.prevBlock),
        merkleRoot: m.revHex(this.merkleRoot),
        time: this.time,
        bits: this.bits,
        nonce: this.nonce,
        totalTX: this.totalTX,
        hashes: this.hashes.map((a) => a.toString("hex")),
        flags: this.flags,
        map: this.getTree().map,
        txs: this.txs.length
      };
    }
    /**
     * Get merkleblock size.
     * @returns {Number} Size.
     */
    getSize() {
      let b = 0;
      return b += 80, b += 4, b += i.sizeVarint(this.hashes.length), b += this.hashes.length * 32, b += i.sizeVarint(this.flags.length), b += this.flags.length, b;
    }
    /**
     * Write the merkleblock to a buffer writer.
     * @param {BufferWriter} bw
     */
    toWriter(b) {
      this.writeHead(b), b.writeU32(this.totalTX), b.writeVarint(this.hashes.length);
      for (const h of this.hashes)
        b.writeHash(h);
      return b.writeVarBytes(this.flags), b;
    }
    /**
     * Serialize the merkleblock.
     * @param {String?} enc - Encoding, can be `'hex'` or null.
     * @returns {Buffer|String}
     */
    toRaw() {
      const b = this.getSize();
      return this.toWriter(c.write(b)).render();
    }
    /**
     * Inject properties from buffer reader.
     * @private
     * @param {BufferReader} br
     */
    fromReader(b) {
      this.readHead(b), this.totalTX = b.readU32();
      const h = b.readVarint();
      for (let a = 0; a < h; a++)
        this.hashes.push(b.readHash());
      return this.flags = b.readVarBytes(), this;
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     */
    fromRaw(b) {
      return this.fromReader(c.read(b));
    }
    /**
     * Instantiate a merkleblock from a buffer reader.
     * @param {BufferReader} br
     * @returns {MerkleBlock}
     */
    static fromReader(b) {
      return new this().fromReader(b);
    }
    /**
     * Instantiate a merkleblock from a serialized data.
     * @param {Buffer} data
     * @param {String?} enc - Encoding, can be `'hex'` or null.
     * @returns {MerkleBlock}
     */
    static fromRaw(b, h) {
      return typeof b == "string" && (b = k.from(b, h)), new this().fromRaw(b);
    }
    /**
     * Convert the block to an object suitable
     * for JSON serialization.
     * @returns {Object}
     */
    toJSON() {
      return this.getJSON();
    }
    /**
     * Convert the block to an object suitable
     * for JSON serialization. Note that the hashes
     * will be reversed to abide by bitcoind's legacy
     * of little-endian uint256s.
     * @param {Network} network
     * @param {CoinView} view
     * @param {Number} height
     * @returns {Object}
     */
    getJSON(b, h, a) {
      return {
        hash: this.rhash(),
        height: a,
        version: this.version,
        prevBlock: m.revHex(this.prevBlock),
        merkleRoot: m.revHex(this.merkleRoot),
        time: this.time,
        bits: this.bits,
        nonce: this.nonce,
        totalTX: this.totalTX,
        hashes: this.hashes.map((E) => m.revHex(E)),
        flags: this.flags.toString("hex")
      };
    }
    /**
     * Inject properties from json object.
     * @private
     * @param {Object} json
     */
    fromJSON(b) {
      e(b, "MerkleBlock data is required."), e(Array.isArray(b.hashes)), e(typeof b.flags == "string"), e(b.totalTX >>> 0 === b.totalTX), this.parseJSON(b);
      for (const h of b.hashes)
        this.hashes.push(m.fromRev(h));
      return this.flags = k.from(b.flags, "hex"), this.totalTX = b.totalTX, this;
    }
    /**
     * Instantiate a merkle block from a jsonified block object.
     * @param {Object} json - The jsonified block object.
     * @returns {MerkleBlock}
     */
    static fromJSON(b) {
      return new this().fromJSON(b);
    }
    /**
     * Create a merkleblock from a {@link Block} object, passing
     * it through a filter first. This will build the partial
     * merkle tree.
     * @param {Block} block
     * @param {Bloom} filter
     * @returns {MerkleBlock}
     */
    static fromBlock(b, h) {
      const a = [];
      for (const E of b.txs)
        a.push(E.isWatched(h) ? 1 : 0);
      return this.fromMatches(b, a);
    }
    /**
     * Create a merkleblock from an array of txids.
     * This will build the partial merkle tree.
     * @param {Block} block
     * @param {Hash[]} hashes
     * @returns {MerkleBlock}
     */
    static fromHashes(b, h) {
      const a = new w();
      for (const H of h)
        a.add(H);
      const E = [];
      for (const H of b.txs) {
        const j = H.hash();
        E.push(a.has(j) ? 1 : 0);
      }
      return this.fromMatches(b, E);
    }
    /**
     * Create a merkleblock from an array of matches.
     * This will build the partial merkle tree.
     * @param {Block} block
     * @param {Number[]} matches
     * @returns {MerkleBlock}
     */
    static fromMatches(b, h) {
      const a = [], E = [], H = [], j = [], G = b.txs.length;
      let N = 0;
      const T = (R) => G + (1 << R) - 1 >>> R, A = (R, L, fe) => {
        if (R === 0)
          return fe[L];
        const ue = A(R - 1, L * 2, fe);
        let ae;
        return L * 2 + 1 < T(R - 1) ? ae = A(R - 1, L * 2 + 1, fe) : ae = ue, f.root(ue, ae);
      }, q = (R, L, fe, ue) => {
        let ae = 0;
        for (let D = L << R; D < L + 1 << R && D < G; D++)
          ae |= ue[D];
        if (H.push(ae), R === 0 || !ae) {
          j.push(A(R, L, fe));
          return;
        }
        q(R - 1, L * 2, fe, ue), L * 2 + 1 < T(R - 1) && q(R - 1, L * 2 + 1, fe, ue);
      };
      for (let R = 0; R < b.txs.length; R++) {
        const L = b.txs[R];
        h[R] && a.push(L), E.push(L.hash());
      }
      for (; T(N) > 1; )
        N += 1;
      q(N, 0, E, h);
      const _ = k.allocUnsafe((H.length + 7) / 8 | 0);
      _.fill(0);
      for (let R = 0; R < H.length; R++)
        _[R / 8 | 0] |= H[R] << R % 8;
      const F = new this();
      return F._hash = b._hash, F._hhash = b._hhash, F.version = b.version, F.prevBlock = b.prevBlock, F.merkleRoot = b.merkleRoot, F.time = b.time, F.bits = b.bits, F.nonce = b.nonce, F.totalTX = G, F.hashes = j, F.flags = _, F.txs = a, F;
    }
    /**
     * Test whether an object is a MerkleBlock.
     * @param {Object} obj
     * @returns {Boolean}
     */
    static isMerkleBlock(b) {
      return b instanceof g;
    }
    /**
     * Convert the block to a headers object.
     * @returns {Headers}
     */
    toHeaders() {
      return o.fromBlock(this);
    }
  }
  class S {
    constructor(b, h, a, E) {
      this.root = b || n.ZERO_HASH, this.matches = h || [], this.indexes = a || [], this.map = E || new l();
    }
  }
  return ch = g, ch;
}
var uh, ob;
function d1() {
  if (ob) return uh;
  ob = 1;
  const e = Xe(), c = At(), { BufferSet: l } = $r(), w = mr(), m = Tp(), f = Lt(), n = us(), u = In(), o = l1(), s = hs(), i = Or(), p = Qt(), { encoding: g } = c, { inspectSymbol: S } = Kt();
  class y extends n {
    /**
     * Create a block.
     * @constructor
     * @param {Object} options
     */
    constructor(a) {
      super(), this.txs = [], this._raw = null, this._size = -1, a && this.fromOptions(a);
    }
    /**
     * Inject properties from options object.
     * @private
     * @param {Object} options
     */
    fromOptions(a) {
      if (this.parseOptions(a), a.txs) {
        e(Array.isArray(a.txs));
        for (const E of a.txs)
          e(E instanceof u), this.txs.push(E);
      }
      return this;
    }
    /**
     * Instantiate block from options.
     * @param {Object} options
     * @returns {Block}
     */
    static fromOptions(a) {
      return new this().fromOptions(a);
    }
    /**
     * Clear any cached values.
     * @param {Boolean?} all - Clear transactions.
     */
    refresh(a) {
      if (this._refresh(), this._raw = null, this._size = -1, !a)
        return this;
      for (const E of this.txs)
        E.refresh();
      return this;
    }
    /**
     * Serialize the block.
     * @returns {Buffer}
     */
    toRaw() {
      return this.frame().data;
    }
    /**
     * Check if block has been serialized.
     * @returns {Buffer}
     */
    hasRaw() {
      return !!this._raw;
    }
    /**
     * Serialize the block.
     * @returns {Buffer}
     */
    toNormal() {
      return this.toRaw();
    }
    /**
     * Serialize the block.
     * @param {BufferWriter} bw
     */
    toWriter(a) {
      if (this.mutable)
        return this.writeNormal(a);
      const E = this.frame();
      return a.writeBytes(E.data), a;
    }
    /**
     * Serialize the block.
     * @param {BufferWriter} bw
     */
    toNormalWriter(a) {
      return this.toWriter(a);
    }
    /**
     * Get the raw block serialization.
     * @private
     * @returns {RawBlock}
     */
    frame() {
      if (this.mutable)
        return e(!this._raw), this.frameNormal();
      if (this._raw) {
        e(this._size >= 0);
        const E = new b(this._size);
        return E.data = this._raw, E;
      }
      const a = this.frameNormal();
      return this._raw = a.data, this._size = a.size, a;
    }
    /**
     * Calculate real block size.
     * @returns {Object} Contains `size`
     */
    getSize() {
      return this.mutable ? this.getNormalSizes().size : this.frame().size;
    }
    /**
     * Test the block's transaction vector against a hash.
     * @param {Hash} hash
     * @returns {Boolean}
     */
    hasTX(a) {
      return this.indexOf(a) !== -1;
    }
    /**
     * Find the index of a transaction in the block.
     * @param {Hash} hash
     * @returns {Number} index (-1 if not present).
     */
    indexOf(a) {
      for (let E = 0; E < this.txs.length; E++)
        if (this.txs[E].hash().equals(a))
          return E;
      return -1;
    }
    /**
     * Calculate merkle root. Returns null
     * if merkle tree has been malleated.
     * @param {String?} enc - Encoding, can be `'hex'` or null.
     * @returns {Hash|null}
     */
    createMerkleRoot(a) {
      const E = [];
      for (const G of this.txs)
        E.push(G.hash());
      const [H, j] = m.createRoot(w, E);
      return j ? null : a === "hex" ? H.toString("hex") : H;
    }
    /**
     * Retrieve the merkle root from the block header.
     * @param {String?} enc
     * @returns {Hash}
     */
    getMerkleRoot(a) {
      return a === "hex" ? this.merkleRoot.toString("hex") : this.merkleRoot;
    }
    /**
     * Do non-contextual verification on the block. Including checking the block
     * size, the coinbase and the merkle root. This is consensus-critical.
     * @returns {Boolean}
     */
    verifyBody() {
      const [a] = this.checkBody();
      return a;
    }
    /**
     * Do non-contextual verification on the block. Including checking the block
     * size, the coinbase and the merkle root. This is consensus-critical.
     * @param {Boolean?} skipSigops
     * @returns {Array} [valid, reason, score]
     */
    checkBody(a) {
      if (this.txs.length === 0 || this.txs.length > f.MAX_FORK_BLOCK_SIZE / 10 || this.getSize() > f.MAX_FORK_BLOCK_SIZE)
        return [!1, "bad-blk-length", 100];
      if (this.txs.length === 0 || !this.txs[0].isCoinbase())
        return [!1, "bad-cb-missing", 100];
      const E = this.createMerkleRoot();
      if (!E)
        return [!1, "bad-txns-duplicate", 100];
      if (!this.merkleRoot.equals(E))
        return [!1, "bad-txnmrklroot", 100];
      const H = this.getSize();
      let j = 0;
      for (let G = 0; G < this.txs.length; G++) {
        const N = this.txs[G];
        if (G > 0 && N.isCoinbase())
          return [!1, "bad-cb-multiple", 100];
        const [T, A, q] = N.checkSanity();
        if (!T)
          return [T, A, q];
        if (j += N.getLegacySigops(), !a && j > f.maxBlockSigops(H))
          return [!1, "bad-blk-sigops", 100];
      }
      return [!0, "valid", 0];
    }
    /**
     * Retrieve the coinbase height from the coinbase input script.
     * @returns {Number} height (-1 if not present).
     */
    getCoinbaseHeight() {
      if (this.version < 2 || this.txs.length === 0)
        return -1;
      const a = this.txs[0];
      return a.inputs.length === 0 ? -1 : a.inputs[0].script.getCoinbaseHeight();
    }
    /**
     * Get the "claimed" reward by the coinbase.
     * @returns {Amount} claimed
     */
    getClaimed() {
      return e(this.txs.length > 0), e(this.txs[0].isCoinbase()), this.txs[0].getOutputValue();
    }
    /**
     * Get all unique outpoint hashes in the
     * block. Coinbases are ignored.
     * @returns {Hash[]} Outpoint hashes.
     */
    getPrevout() {
      const a = new l();
      for (let E = 1; E < this.txs.length; E++) {
        const H = this.txs[E];
        for (const j of H.inputs)
          a.add(j.prevout.hash);
      }
      return a.toArray();
    }
    /**
     * Inspect the block and return a more
     * user-friendly representation of the data.
     * @returns {Object}
     */
    [S]() {
      return this.format();
    }
    /**
     * Inspect the block and return a more
     * user-friendly representation of the data.
     * @param {CoinView} view
     * @param {Number} height
     * @returns {Object}
     */
    format(a, E) {
      return {
        hash: this.rhash(),
        height: E ?? -1,
        size: this.getSize(),
        date: p.date(this.time),
        version: this.version.toString(16),
        prevBlock: p.revHex(this.prevBlock),
        merkleRoot: p.revHex(this.merkleRoot),
        time: this.time,
        bits: this.bits,
        nonce: this.nonce,
        txs: this.txs.map((H, j) => H.format(a, null, j))
      };
    }
    /**
     * Convert the block to an object suitable
     * for JSON serialization.
     * @returns {Object}
     */
    toJSON() {
      return this.getJSON();
    }
    /**
     * Convert the block to an object suitable
     * for JSON serialization. Note that the hashes
     * will be reversed to abide by bitcoind's legacy
     * of little-endian uint256s.
     * @param {Network} network
     * @param {CoinView} view
     * @param {Number} height
     * @param {Number} depth
     * @returns {Object}
     */
    getJSON(a, E, H, j) {
      return a = i.get(a), {
        hash: this.rhash(),
        height: H,
        depth: j,
        version: this.version,
        prevBlock: p.revHex(this.prevBlock),
        merkleRoot: p.revHex(this.merkleRoot),
        time: this.time,
        bits: this.bits,
        nonce: this.nonce,
        txs: this.txs.map((G, N) => G.getJSON(a, E, null, N))
      };
    }
    /**
     * Inject properties from json object.
     * @private
     * @param {Object} json
     */
    fromJSON(a) {
      e(a, "Block data is required."), e(Array.isArray(a.txs)), this.parseJSON(a);
      for (const E of a.txs)
        this.txs.push(u.fromJSON(E));
      return this;
    }
    /**
     * Instantiate a block from a jsonified block object.
     * @param {Object} json - The jsonified block object.
     * @returns {Block}
     */
    static fromJSON(a) {
      return new this().fromJSON(a);
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     */
    fromReader(a) {
      a.start(), this.readHead(a);
      const E = a.readVarint();
      for (let H = 0; H < E; H++) {
        const j = u.fromReader(a, !0);
        this.txs.push(j);
      }
      return this.mutable || (this._raw = a.endData(), this._size = this._raw.length), this;
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     */
    fromRaw(a) {
      return this.fromReader(c.read(a));
    }
    /**
     * Instantiate a block from a serialized Buffer.
     * @param {Buffer} data
     * @param {String?} enc - Encoding, can be `'hex'` or null.
     * @returns {Block}
     */
    static fromReader(a) {
      return new this().fromReader(a);
    }
    /**
     * Instantiate a block from a serialized Buffer.
     * @param {Buffer} data
     * @param {String?} enc - Encoding, can be `'hex'` or null.
     * @returns {Block}
     */
    static fromRaw(a, E) {
      return typeof a == "string" && (a = k.from(a, E)), new this().fromRaw(a);
    }
    /**
     * Convert the Block to a MerkleBlock.
     * @param {Bloom} filter - Bloom filter for transactions
     * to match. The merkle block will contain only the
     * matched transactions.
     * @returns {MerkleBlock}
     */
    toMerkle(a) {
      return o.fromBlock(this, a);
    }
    /**
     * Serialze block data.
     * @private
     * @param {BufferWriter?} writer
     * @returns {Buffer}
     */
    writeNormal(a) {
      this.writeHead(a), a.writeVarint(this.txs.length);
      for (const E of this.txs)
        E.toWriter(a);
      return a;
    }
    /**
     * Serialze block data.
     * @private
     * @param {BufferWriter?} writer
     * @returns {Buffer}
     */
    frameNormal() {
      const a = this.getNormalSizes(), E = c.write(a.size);
      return this.writeNormal(E), a.data = E.render(), a;
    }
    /**
     * Convert the block to a headers object.
     * @returns {Headers}
     */
    toHeaders() {
      return s.fromBlock(this);
    }
    /**
     * Get real block size.
     * @returns {RawBlock}
     */
    getNormalSizes() {
      let a = 0;
      a += 80, a += g.sizeVarint(this.txs.length);
      for (const E of this.txs)
        a += E.getSize();
      return new b(a, 0);
    }
    /**
     * Test whether an object is a Block.
     * @param {Object} obj
     * @returns {Boolean}
     */
    static isBlock(a) {
      return a instanceof y;
    }
  }
  class b {
    constructor(a) {
      this.data = null, this.size = a;
    }
  }
  return uh = y, uh;
}
var hh, ab;
function b1() {
  if (ab) return hh;
  ab = 1;
  const e = Xe(), { base58: c } = gn(), l = At(), w = Xi(), m = mr(), f = Or(), n = Cr(), u = Gr(), o = Si(), s = zr(), { encoding: i } = l, { inspectSymbol: p } = Kt(), g = k.alloc(33, 0);
  class S {
    /**
     * Create a key ring.
     * @constructor
     * @param {Object} options
     */
    constructor(h) {
      this.nested = !1, this.publicKey = g, this.privateKey = null, this.script = null, this._keyHash = null, this._keyAddress = null, this._scriptHash160 = null, this._scriptAddress = null, h && this.fromOptions(h);
    }
    /**
     * Inject properties from options object.
     * @private
     * @param {Object} options
     */
    fromOptions(h) {
      let a = y(h);
      if (k.isBuffer(a))
        return this.fromKey(a);
      a = y(h.key), h.publicKey && (a = y(h.publicKey)), h.privateKey && (a = y(h.privateKey));
      const E = h.script, H = h.compressed;
      return E ? this.fromScript(a, E, H) : this.fromKey(a, H);
    }
    /**
     * Instantiate key ring from options.
     * @param {Object} options
     * @returns {KeyRing}
     */
    static fromOptions(h) {
      return new this().fromOptions(h);
    }
    /**
     * Clear cached key/script hashes.
     */
    refresh() {
      this._keyHash = null, this._keyAddress = null, this._scriptHash160 = null, this._scriptAddress = null;
    }
    /**
     * Inject data from private key.
     * @private
     * @param {Buffer} key
     * @param {Boolean?} compress
     */
    fromPrivate(h, a) {
      return e(k.isBuffer(h), "Private key must be a buffer."), e(s.privateKeyVerify(h), "Not a valid private key."), this.privateKey = h, this.publicKey = s.publicKeyCreate(h, a !== !1), this;
    }
    /**
     * Instantiate keyring from a private key.
     * @param {Buffer} key
     * @param {Boolean?} compress
     * @returns {KeyRing}
     */
    static fromPrivate(h, a) {
      return new this().fromPrivate(h, a);
    }
    /**
     * Inject data from public key.
     * @private
     * @param {Buffer} key
     */
    fromPublic(h) {
      return e(k.isBuffer(h), "Public key must be a buffer."), e(s.publicKeyVerify(h), "Not a valid public key."), this.publicKey = h, this;
    }
    /**
     * Generate a keyring.
     * @private
     * @param {Boolean?} compress
     * @returns {KeyRing}
     */
    generate(h) {
      const a = s.privateKeyGenerate();
      return this.fromKey(a, h);
    }
    /**
     * Generate a keyring.
     * @param {Boolean?} compress
     * @returns {KeyRing}
     */
    static generate(h) {
      return new this().generate(h);
    }
    /**
     * Instantiate keyring from a public key.
     * @param {Buffer} publicKey
     * @returns {KeyRing}
     */
    static fromPublic(h) {
      return new this().fromPublic(h);
    }
    /**
     * Inject data from public key.
     * @private
     * @param {Buffer} privateKey
     * @param {Boolean?} compress
     */
    fromKey(h, a) {
      return e(k.isBuffer(h), "Key must be a buffer."), h.length === 32 ? this.fromPrivate(h, a !== !1) : this.fromPublic(h);
    }
    /**
     * Instantiate keyring from a public key.
     * @param {Buffer} publicKey
     * @param {Boolean?} compress
     * @returns {KeyRing}
     */
    static fromKey(h, a) {
      return new this().fromKey(h, a);
    }
    /**
     * Inject data from script.
     * @private
     * @param {Buffer} key
     * @param {Script} script
     * @param {Boolean?} compress
     */
    fromScript(h, a, E) {
      return e(a instanceof n, "Non-script passed into KeyRing."), this.fromKey(h, E), this.script = a, this;
    }
    /**
     * Instantiate keyring from script.
     * @param {Buffer} key
     * @param {Script} script
     * @param {Boolean?} compress
     * @returns {KeyRing}
     */
    static fromScript(h, a, E) {
      return new this().fromScript(h, a, E);
    }
    /**
     * Get ith public key from multisig script.
     * @private
     * @param {Script} script
     * @param {Number} i
     * @returns {KeyRing}
     */
    fromMultisigScript(h, a) {
      e(h instanceof n, "Non-script passed."), e(h.isMultisig(), "Script must be multisig");
      const E = h.getSmall(-2);
      return e(a >= 1 && a <= E, "Requested `i`th key, `n` available"), this.fromKey(h.code[a].toData()), this;
    }
    /**
     * Instantiate keyring from ith key in multisig script.
     * @param {Script} script
     * @param {Number} i
     * @returns {KeyRing}
     */
    static fromMultisigScript(h, a) {
      return new this().fromMultisigScript(h, a);
    }
    /**
     * Calculate WIF serialization size.
     * @returns {Number}
     */
    getSecretSize() {
      let h = 0;
      return h += 1, h += this.privateKey.length, this.publicKey.length === 33 && (h += 1), h += 4, h;
    }
    /**
     * Convert key to a CBitcoinSecret.
     * @param {(Network|NetworkType)?} network
     * @returns {Base58String}
     */
    toSecret(h) {
      const a = this.getSecretSize(), E = l.write(a);
      return e(this.privateKey, "Cannot serialize without private key."), h = f.get(h), E.writeU8(h.keyPrefix.privkey), E.writeBytes(this.privateKey), this.publicKey.length === 33 && E.writeU8(1), E.writeChecksum(m.digest), c.encode(E.render());
    }
    /**
     * Inject properties from serialized CBitcoinSecret.
     * @private
     * @param {Base58String} secret
     * @param {(Network|NetworkType)?} network
     */
    fromSecret(h, a) {
      const E = l.read(c.decode(h), !0), H = E.readU8();
      f.fromWIF(H, a);
      const j = E.readBytes(32);
      let G = !1;
      return E.left() > 4 && (e(E.readU8() === 1, "Bad compression flag."), G = !0), E.verifyChecksum(m.digest), this.fromPrivate(j, G);
    }
    /**
     * Instantiate a keyring from a serialized CBitcoinSecret.
     * @param {Base58String} secret
     * @param {(Network|NetworkType)?} network
     * @returns {KeyRing}
     */
    static fromSecret(h, a) {
      return new this().fromSecret(h, a);
    }
    /**
     * Get private key.
     * @param {String?} enc - Can be `"hex"`, `"base58"`, or `null`.
     * @returns {Buffer} Private key.
     */
    getPrivateKey(h, a) {
      return this.privateKey ? h === "base58" ? this.toSecret(a) : h === "hex" ? this.privateKey.toString("hex") : this.privateKey : null;
    }
    /**
     * Get public key.
     * @param {String?} enc - `"hex"` or `null`.
     * @returns {Buffer}
     */
    getPublicKey(h) {
      return h === "base58" ? c.encode(this.publicKey) : h === "hex" ? this.publicKey.toString("hex") : this.publicKey;
    }
    /**
     * Get redeem script.
     * @returns {Script}
     */
    getScript() {
      return this.script;
    }
    /**
     * Get scripthash.
     * @param {String?} enc - `"hex"` or `null`.
     * @returns {Buffer}
     */
    getScriptHash(h) {
      return this.getScriptHash160(h);
    }
    /**
     * Get ripemd160 scripthash.
     * @param {String?} enc - `"hex"` or `null`.
     * @returns {Buffer}
     */
    getScriptHash160(h) {
      return this.script ? (this._scriptHash160 || (this._scriptHash160 = this.script.hash160()), h === "hex" ? this._scriptHash160.toString("hex") : this._scriptHash160) : null;
    }
    /**
     * Get scripthash address.
     * @param {String?} enc - `"base58"` or `null`.
     * @returns {Address|AddressString}
     */
    getScriptAddress(h, a) {
      if (!this.script)
        return null;
      if (!this._scriptAddress) {
        const E = this.getScriptHash160(), H = u.fromScripthash(E);
        this._scriptAddress = H;
      }
      return h === "base58" ? this._scriptAddress.toBase58(a) : h === "string" ? this._scriptAddress.toString(a) : this._scriptAddress;
    }
    /**
     * Get public key hash.
     * @param {String?} enc - `"hex"` or `null`.
     * @returns {Buffer}
     */
    getKeyHash(h) {
      return this._keyHash || (this._keyHash = w.digest(this.publicKey)), h === "hex" ? this._keyHash.toString("hex") : this._keyHash;
    }
    /**
     * Get pubkeyhash address.
     * @param {String?} enc - `"base58"` or `null`.
     * @returns {Address|AddressString}
     */
    getKeyAddress(h, a) {
      if (!this._keyAddress) {
        const E = this.getKeyHash(), H = u.fromPubkeyhash(E);
        this._keyAddress = H;
      }
      return h === "base58" ? this._keyAddress.toBase58(a) : h === "string" ? this._keyAddress.toString(a) : this._keyAddress;
    }
    /**
     * Get hash.
     * @param {String?} enc - `"hex"` or `null`.
     * @returns {Buffer}
     */
    getHash(h) {
      return this.script ? this.getScriptHash(h) : this.getKeyHash(h);
    }
    /**
     * Get base58 address.
     * @param {String?} enc - `"base58"` or `null`.
     * @returns {Address|AddressString}
     */
    getAddress(h, a) {
      return this.script ? this.getScriptAddress(h, a) : this.getKeyAddress(h, a);
    }
    /**
     * Test an address hash against hash.
     * @param {Buffer} hash
     * @returns {Boolean}
     */
    ownHash(h) {
      return h ? !!(h.equals(this.getKeyHash()) || this.script && h.equals(this.getScriptHash())) : !1;
    }
    /**
     * Check whether transaction output belongs to this address.
     * @param {TX|Output} tx - Transaction or Output.
     * @param {Number?} index - Output index.
     * @returns {Boolean}
     */
    ownOutput(h, a) {
      let E;
      return h instanceof o ? E = h : (E = h.outputs[a], e(E, "Output does not exist.")), this.ownHash(E.getHash());
    }
    /**
     * Test a hash against script hashes to
     * find the correct redeem script, if any.
     * @param {Buffer} hash
     * @returns {Script|null}
     */
    getRedeem(h) {
      return this.script && h.equals(this.getScriptHash160()) ? this.script : null;
    }
    /**
     * Sign a message.
     * @param {Buffer} msg
     * @returns {Buffer} Signature in DER format.
     */
    sign(h) {
      return e(this.privateKey, "Cannot sign without private key."), s.signDER(h, this.privateKey);
    }
    /**
     * Sign a message.
     * @param {Buffer} msg
     * @returns {Buffer} Signature in Schnorr format.
     */
    signSchnorr(h) {
      return e(this.privateKey, "Cannot sign without private key."), s.schnorrSign(h, this.privateKey);
    }
    /**
     * Verify a message.
     * @param {Buffer} msg
     * @param {Buffer} sig - Signature in DER format.
     * @returns {Boolean}
     */
    verify(h, a) {
      return s.verifyDER(h, a, this.publicKey);
    }
    /**
     * Verify a message.
     * @param {Buffer} msg
     * @param {Buffer} sig - Signature in Schnorr format.
     * @returns {Boolean}
     */
    verifySchnorr(h, a) {
      return s.schnorrVerify(h, a, this.publicKey);
    }
    /**
     * Get witness program version.
     * @returns {Number}
     */
    getVersion() {
      return -1;
    }
    /**
     * Get address type.
     * @returns {ScriptType}
     */
    getType() {
      return this.script ? u.types.SCRIPTHASH : u.types.PUBKEYHASH;
    }
    /**
     * Inspect keyring.
     * @returns {Object}
     */
    [p]() {
      return this.toJSON();
    }
    /**
     * Convert an KeyRing to a more json-friendly object.
     * @returns {Object}
     */
    toJSON(h) {
      return {
        publicKey: this.publicKey.toString("hex"),
        script: this.script ? this.script.toRaw().toString("hex") : null,
        type: u.typesByVal[this.getType()].toLowerCase(),
        address: this.getAddress("string", h)
      };
    }
    /**
     * Inject properties from json object.
     * @private
     * @param {Object} json
     */
    fromJSON(h) {
      return e(h), e(typeof h.publicKey == "string"), e(!h.script || typeof h.script == "string"), this.publicKey = k.from(h.publicKey, "hex"), h.script && (this.script = k.from(h.script, "hex")), this;
    }
    /**
     * Instantiate an KeyRing from a jsonified transaction object.
     * @param {Object} json - The jsonified transaction object.
     * @returns {KeyRing}
     */
    static fromJSON(h) {
      return new this().fromJSON(h);
    }
    /**
     * Calculate serialization size.
     * @returns {Number}
     */
    getSize() {
      let h = 0;
      return h += 1, this.privateKey ? (h += i.sizeVarBytes(this.privateKey), h += 1) : h += i.sizeVarBytes(this.publicKey), h += this.script ? this.script.getVarSize() : 1, h;
    }
    /**
     * Write the keyring to a buffer writer.
     * @param {BufferWriter} bw
     */
    toWriter(h) {
      return h.writeU8(0), this.privateKey ? (h.writeVarBytes(this.privateKey), h.writeU8(this.publicKey.length === 33 ? 1 : 0)) : h.writeVarBytes(this.publicKey), this.script ? h.writeVarBytes(this.script.toRaw()) : h.writeVarint(0), h;
    }
    /**
     * Serialize the keyring.
     * @returns {Buffer}
     */
    toRaw() {
      const h = this.getSize();
      return this.toWriter(l.write(h)).render();
    }
    /**
     * Inject properties from buffer reader.
     * @private
     * @param {BufferReader} br
     */
    fromReader(h) {
      h.readU8();
      const a = h.readVarBytes();
      if (a.length === 32) {
        const H = h.readU8() === 1;
        this.privateKey = a, this.publicKey = s.publicKeyCreate(a, H);
      } else
        this.publicKey = a, e(s.publicKeyVerify(a), "Invalid public key.");
      const E = h.readVarBytes();
      return E.length > 0 && (this.script = n.fromRaw(E)), this;
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     */
    fromRaw(h) {
      return this.fromReader(l.read(h));
    }
    /**
     * Instantiate a keyring from buffer reader.
     * @param {BufferReader} br
     * @returns {KeyRing}
     */
    static fromReader(h) {
      return new this().fromReader(h);
    }
    /**
     * Instantiate a keyring from serialized data.
     * @param {Buffer} data
     * @returns {KeyRing}
     */
    static fromRaw(h) {
      return new this().fromRaw(h);
    }
    /**
     * Test whether an object is a KeyRing.
     * @param {Object} obj
     * @returns {Boolean}
     */
    static isKeyRing(h) {
      return h instanceof S;
    }
  }
  function y(b) {
    return b && (b.privateKey ? b.privateKey : b.publicKey ? b.publicKey : b);
  }
  return hh = S, hh;
}
var lh, fb;
function xy() {
  if (fb) return lh;
  fb = 1;
  const e = At(), c = us(), l = d1(), w = hs(), m = Cr(), f = k.alloc(0);
  class n extends c {
    /**
     * Create a mem block.
     * @constructor
     */
    constructor() {
      super(), this._raw = f;
    }
    /**
     * Test whether the block is a memblock.
     * @returns {Boolean}
     */
    isMemory() {
      return !0;
    }
    /**
     * Serialize the block headers.
     * @returns {Buffer}
     */
    toHead() {
      return this._raw.slice(0, 80);
    }
    /**
     * Get the full block size.
     * @returns {Number}
     */
    getSize() {
      return this._raw.length;
    }
    /**
     * Verify the block.
     * @returns {Boolean}
     */
    verifyBody() {
      return !0;
    }
    /**
     * Retrieve the coinbase height
     * from the coinbase input script.
     * @returns {Number} height (-1 if not present).
     */
    getCoinbaseHeight() {
      if (this.version < 2)
        return -1;
      try {
        return this.parseCoinbaseHeight();
      } catch {
        return -1;
      }
    }
    /**
     * Parse the coinbase height
     * from the coinbase input script.
     * @private
     * @returns {Number} height (-1 if not present).
     */
    parseCoinbaseHeight() {
      const o = e.read(this._raw, !0);
      if (o.seek(80), o.readVarint() === 0)
        return -1;
      o.seek(4);
      let i = o.readVarint();
      if (i === 0 && o.readU8() !== 0 && (i = o.readVarint()), i === 0)
        return -1;
      o.seek(36);
      const p = o.readVarBytes();
      return m.getCoinbaseHeight(p);
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     */
    fromRaw(o) {
      const s = e.read(o, !0);
      return this.readHead(s), this._raw = s.data, this;
    }
    /**
     * Insantiate a memblock from serialized data.
     * @param {Buffer} data
     * @returns {MemBlock}
     */
    static fromRaw(o) {
      return new this().fromRaw(o);
    }
    /**
     * Return serialized block data.
     * @returns {Buffer}
     */
    toRaw() {
      return this._raw;
    }
    /**
     * Parse the serialized block data
     * and create an actual {@link Block}.
     * @returns {Block}
     * @throws Parse error
     */
    toBlock() {
      const o = l.fromRaw(this._raw);
      return o._hash = this._hash, o._hhash = this._hhash, o;
    }
    /**
     * Convert the block to a headers object.
     * @returns {Headers}
     */
    toHeaders() {
      return w.fromBlock(this);
    }
    /**
     * Test whether an object is a MemBlock.
     * @param {Object} obj
     * @returns {Boolean}
     */
    static isMemBlock(o) {
      return o instanceof n;
    }
  }
  return lh = n, lh;
}
var Ps = { exports: {} }, cb;
function p1() {
  return cb || (cb = 1, function(e, c) {
    const l = Xe(), { encoding: w } = At(), { BufferMap: m } = $r(), f = Cr(), n = In(), u = Bo(), o = Si(), s = cs(), i = Ei(), p = Oo(), g = Gr(), S = Lt(), y = vi(), b = wi(), h = Eo(), a = Qt(), { inspectSymbol: E } = Kt();
    class H extends n {
      /**
       * Create a mutable transaction.
       * @alias module:primitives.MTX
       * @constructor
       * @param {Object} options
       */
      constructor(R) {
        super(), this.mutable = !0, this.changeIndex = -1, this.view = new p(), R && this.fromOptions(R);
      }
      /**
       * Inject properties from options object.
       * @private
       * @param {Object} options
       */
      fromOptions(R) {
        if (R.version != null && (l(
          R.version >>> 0 === R.version,
          "Version must a be uint32."
        ), this.version = R.version), R.inputs) {
          l(Array.isArray(R.inputs), "Inputs must be an array.");
          for (const L of R.inputs)
            this.addInput(L);
        }
        if (R.outputs) {
          l(Array.isArray(R.outputs), "Outputs must be an array.");
          for (const L of R.outputs)
            this.addOutput(L);
        }
        return R.locktime != null && (l(
          R.locktime >>> 0 === R.locktime,
          "Locktime must be a uint32."
        ), this.locktime = R.locktime), R.changeIndex != null && (R.changeIndex !== -1 ? (l(
          R.changeIndex >>> 0 === R.changeIndex,
          "Change index must be a uint32."
        ), this.changeIndex = R.changeIndex) : this.changeIndex = -1), this;
      }
      /**
       * Instantiate MTX from options.
       * @param {Object} options
       * @returns {MTX}
       */
      static fromOptions(R) {
        return new this().fromOptions(R);
      }
      /**
       * Clone the transaction. Note that
       * this will not carry over the view.
       * @returns {MTX}
       */
      clone() {
        const R = new this.constructor();
        return R.inject(this), R.changeIndex = this.changeIndex, R;
      }
      /**
       * Add an input to the transaction.
       * @param {Input|Object} options
       * @returns {Input}
       *
       * @example
       * mtx.addInput({ prevout: { hash: ... }, script: ... });
       * mtx.addInput(new Input());
       */
      addInput(R) {
        const L = u.fromOptions(R);
        return this.inputs.push(L), L;
      }
      /**
       * Add an outpoint as an input.
       * @param {Outpoint|Object} outpoint
       * @returns {Input}
       *
       * @example
       * mtx.addOutpoint({ hash: ..., index: 0 });
       * mtx.addOutpoint(new Outpoint(hash, index));
       */
      addOutpoint(R) {
        const L = i.fromOptions(R), fe = u.fromOutpoint(L);
        return this.inputs.push(fe), fe;
      }
      /**
       * Add a coin as an input. Note that this will
       * add the coin to the internal coin viewpoint.
       * @param {Coin} coin
       * @returns {Input}
       *
       * @example
       * mtx.addCoin(Coin.fromTX(tx, 0, -1));
       */
      addCoin(R) {
        l(R instanceof s, "Cannot add non-coin.");
        const L = u.fromCoin(R);
        return this.inputs.push(L), this.view.addCoin(R), L;
      }
      /**
       * Add a transaction as an input. Note that
       * this will add the coin to the internal
       * coin viewpoint.
       * @param {TX} tx
       * @param {Number} index
       * @param {Number?} height
       * @returns {Input}
       *
       * @example
       * mtx.addTX(tx, 0);
       */
      addTX(R, L, fe) {
        l(R instanceof n, "Cannot add non-transaction."), fe == null && (fe = -1);
        const ue = u.fromTX(R, L);
        return this.inputs.push(ue), this.view.addIndex(R, L, fe), ue;
      }
      /**
       * Add an output.
       * @param {Address|Script|Output|Object} script - Script or output options.
       * @param {Amount?} value
       * @returns {Output}
       *
       * @example
       * mtx.addOutput(new Output());
       * mtx.addOutput({ address: ..., value: 100000 });
       * mtx.addOutput(address, 100000);
       * mtx.addOutput(script, 100000);
       */
      addOutput(R, L) {
        let fe;
        return L != null ? fe = o.fromScript(R, L) : fe = o.fromOptions(R), this.outputs.push(fe), fe;
      }
      /**
       * Verify all transaction inputs.
       * @param {VerifyFlags} [flags=STANDARD_VERIFY_FLAGS]
       * @returns {Boolean} Whether the inputs are valid.
       * @throws {ScriptError} on invalid inputs
       */
      check(R) {
        return super.check(this.view, R);
      }
      /**
       * Verify the transaction inputs on the worker pool
       * (if workers are enabled).
       * @param {VerifyFlags?} [flags=STANDARD_VERIFY_FLAGS]
       * @param {WorkerPool?} pool
       * @returns {Promise}
       */
      checkAsync(R, L) {
        return super.checkAsync(this.view, R, L);
      }
      /**
       * Verify all transaction inputs.
       * @param {VerifyFlags} [flags=STANDARD_VERIFY_FLAGS]
       * @returns {Boolean} Whether the inputs are valid.
       */
      verify(R) {
        try {
          this.check(R);
        } catch (L) {
          if (L.type === "ScriptError")
            return !1;
          throw L;
        }
        return !0;
      }
      /**
       * Verify the transaction inputs on the worker pool
       * (if workers are enabled).
       * @param {VerifyFlags?} [flags=STANDARD_VERIFY_FLAGS]
       * @param {WorkerPool?} pool
       * @returns {Promise}
       */
      async verifyAsync(R, L) {
        try {
          await this.checkAsync(R, L);
        } catch (fe) {
          if (fe.type === "ScriptError")
            return !1;
          throw fe;
        }
        return !0;
      }
      /**
       * Calculate the fee for the transaction.
       * @returns {Amount} fee (zero if not all coins are available).
       */
      getFee() {
        return super.getFee(this.view);
      }
      /**
       * Calculate the total input value.
       * @returns {Amount} value
       */
      getInputValue() {
        return super.getInputValue(this.view);
      }
      /**
       * Get all input addresses.
       * @returns {Address[]} addresses
       */
      getInputAddresses() {
        return super.getInputAddresses(this.view);
      }
      /**
       * Get all addresses.
       * @returns {Address[]} addresses
       */
      getAddresses() {
        return super.getAddresses(this.view);
      }
      /**
       * Get all input address hashes.
       * @returns {Hash[]} hashes
       */
      getInputHashes(R) {
        return super.getInputHashes(this.view, R);
      }
      /**
       * Get all address hashes.
       * @returns {Hash[]} hashes
       */
      getHashes(R) {
        return super.getHashes(this.view, R);
      }
      /**
       * Test whether the transaction has
       * all coins available/filled.
       * @returns {Boolean}
       */
      hasCoins() {
        return super.hasCoins(this.view);
      }
      /**
       * Calculate virtual sigop count.
       * @param {VerifyFlags?} flags
       * @returns {Number} sigop count
       */
      getSigops(R) {
        return super.getSigops(this.view, R);
      }
      /**
       *  Calculate sigops count.
       *  @param {CoinView} view
       *  @param {VerifyFlags?} flags
       *  @returns {Number} sigop count
       */
      getSigopsCount(R) {
        return super.getSigopsCount(this.view, R);
      }
      /**
       * Perform contextual checks to verify input, output,
       * and fee values, as well as coinbase spend maturity
       * (coinbases can only be spent 100 blocks or more
       * after they're created). Note that this function is
       * consensus critical.
       * @param {Number} height - Height at which the
       * transaction is being spent. In the mempool this is
       * the chain height plus one at the time it entered the pool.
       * @returns {Boolean}
       */
      verifyInputs(R) {
        const [L] = this.checkInputs(R);
        return L !== -1;
      }
      /**
       * Perform contextual checks to verify input, output,
       * and fee values, as well as coinbase spend maturity
       * (coinbases can only be spent 100 blocks or more
       * after they're created). Note that this function is
       * consensus critical.
       * @param {Number} height - Height at which the
       * transaction is being spent. In the mempool this is
       * the chain height plus one at the time it entered the pool.
       * @returns {Array} [fee, reason, score]
       */
      checkInputs(R) {
        return super.checkInputs(this.view, R);
      }
      /**
       * Build input script (or witness) templates (with
       * OP_0 in place of signatures).
       * @param {Number} index - Input index.
       * @param {Coin|Output} coin
       * @param {KeyRing} ring
       * @returns {Boolean} Whether the script was able to be built.
       */
      scriptInput(R, L, fe) {
        const ue = this.inputs[R];
        if (l(ue, "Input does not exist."), l(L, "No coin passed."), ue.script.raw.length !== 0)
          return !0;
        const ae = L.script, D = ae.getScripthash();
        if (D) {
          const W = fe.getRedeem(D);
          if (!W)
            return !1;
          const oe = this.scriptVector(W, fe);
          return oe ? (oe.push(W.toRaw()), ue.script.fromStack(oe), !0) : !1;
        }
        const Q = this.scriptVector(ae, fe);
        return Q ? (ue.script.fromStack(Q), !0) : !1;
      }
      /**
       * Build script for a single vector
       * based on a previous script.
       * @param {Script} prev
       * @param {Buffer} ring
       * @return {Stack}
       */
      scriptVector(R, L) {
        const fe = R.getPubkey();
        if (fe) {
          if (!fe.equals(L.publicKey))
            return null;
          const D = new h();
          return D.pushInt(0), D;
        }
        const ue = R.getPubkeyhash();
        if (ue) {
          if (!ue.equals(L.getKeyHash()))
            return null;
          const D = new h();
          return D.pushInt(0), D.pushData(L.publicKey), D;
        }
        const [, ae] = R.getMultisig();
        if (ae !== -1) {
          if (R.indexOf(L.publicKey) === -1)
            return null;
          const D = new h();
          D.pushInt(0);
          for (let Q = 0; Q < ae; Q++)
            D.pushInt(0);
          return D;
        }
        return null;
      }
      /**
       * Sign a transaction input on the worker pool
       * (if workers are enabled).
       * @param {Number} index
       * @param {Coin|Output} coin
       * @param {KeyRing} ring
       * @param {SighashType?} type
       * @param {WorkerPool?} pool
       * @returns {Promise}
       */
      async signInputAsync(R, L, fe, ue, ae) {
        return ae ? await ae.signInput(this, R, L, fe, ue, ae) : this.signInput(R, L, fe, ue);
      }
      /**
       * Sign an input.
       * @param {Number} index - Index of input being signed.
       * @param {Coin|Output} coin
       * @param {KeyRing} ring - Private key.
       * @param {SighashType} type
       * @returns {Boolean} Whether the input was able to be signed.
       */
      signInput(R, L, fe, ue) {
        const ae = this.inputs[R], D = fe.privateKey;
        l(ae, "Input does not exist."), l(L, "No coin passed.");
        const Q = L.value;
        let W = L.script;
        const oe = ae.script;
        let v = !1;
        ue == null && (ue = f.hashType.ALL), ue |= f.hashType.SIGHASH_FORKID;
        const Y = f.flags.VERIFY_SIGHASH_FORKID;
        if (W.isScripthash()) {
          if (W = ae.script.getRedeem(), !W)
            throw new Error("Input has not been templated.");
          v = !0;
        }
        const he = this.signature(R, W, Q, D, ue, Y);
        if (v) {
          const Ee = oe.toStack(), we = Ee.pop(), z = this.signVector(W, Ee, he, fe);
          return z ? (z.push(we), oe.fromStack(z), !0) : !1;
        }
        const le = oe.toStack(), ge = this.signVector(W, le, he, fe);
        return ge ? (oe.fromStack(ge), !0) : !1;
      }
      /**
       * Add a signature to a vector
       * based on a previous script.
       * @param {Script} prev
       * @param {Stack} vector
       * @param {Buffer} sig
       * @param {KeyRing} ring
       * @return {Boolean}
       */
      signVector(R, L, fe, ue) {
        const ae = R.getPubkey();
        if (ae) {
          if (!ue.publicKey.equals(ae))
            return null;
          if (L.length === 0)
            throw new Error("Input has not been templated.");
          return L.get(0).length > 0 || L.set(0, fe), L;
        }
        const D = R.getPubkeyhash();
        if (D) {
          if (!ue.getKeyHash().equals(D))
            return null;
          if (L.length !== 2)
            throw new Error("Input has not been templated.");
          if (L.get(1).length === 0)
            throw new Error("Input has not been templated.");
          return L.get(0).length > 0 || L.set(0, fe), L;
        }
        const [Q, W] = R.getMultisig();
        if (Q !== -1) {
          if (L.length < 2)
            throw new Error("Input has not been templated.");
          if (L.get(0).length !== 0)
            throw new Error("Input has not been templated.");
          if (L.length - 1 > W)
            throw new Error("Input has not been templated.");
          let oe = 0;
          for (let he = 1; he < L.length; he++)
            L.get(he).length > 0 && (oe += 1);
          if (oe === Q && L.length - 1 === Q)
            return L;
          for (; L.length - 1 < W; )
            L.pushInt(0);
          const v = [];
          for (const he of R.code)
            he.data && v.push(he.data);
          let Y = -1;
          for (let he = 0; he < v.length; he++)
            if (v[he].equals(ue.publicKey)) {
              Y = he;
              break;
            }
          if (Y === -1)
            return null;
          if (Y += 1, Y < L.length && oe < Q && L.get(Y).length === 0 && (L.set(Y, fe), oe += 1), oe >= Q) {
            for (let he = L.length - 1; he >= 1; he--)
              L.get(he).length === 0 && L.remove(he);
            for (; oe > Q; )
              L.pop(), oe -= 1;
            l(oe === Q), l(L.length - 1 === Q);
          }
          return L;
        }
        return null;
      }
      /**
       * Test whether the transaction is fully-signed.
       * @returns {Boolean}
       */
      isSigned() {
        for (let R = 0; R < this.inputs.length; R++) {
          const { prevout: L } = this.inputs[R], fe = this.view.getOutput(L);
          if (!fe || !this.isInputSigned(R, fe))
            return !1;
        }
        return !0;
      }
      /**
       * Test whether an input is fully-signed.
       * @param {Number} index
       * @param {Coin|Output} coin
       * @returns {Boolean}
       */
      isInputSigned(R, L) {
        const fe = this.inputs[R];
        l(fe, "Input does not exist."), l(L, "No coin passed.");
        const ue = fe.script;
        let ae = L.script, D = !1;
        if (ae.isScripthash()) {
          if (ae = fe.script.getRedeem(), !ae)
            return !1;
          D = !0;
        }
        const Q = ue.toStack();
        return D && Q.pop(), this.isVectorSigned(ae, Q);
      }
      /**
       * Test whether a vector is fully-signed.
       * @param {Script} prev
       * @param {Stack} vector
       * @returns {Boolean}
       */
      isVectorSigned(R, L) {
        if (R.isPubkey())
          return !(L.length !== 1 || L.get(0).length === 0);
        if (R.isPubkeyhash())
          return !(L.length !== 2 || L.get(0).length === 0 || L.get(1).length === 0);
        const [fe] = R.getMultisig();
        if (fe !== -1) {
          if (L.length - 1 !== fe)
            return !1;
          for (let ue = 1; ue < L.length; ue++)
            if (L.get(ue).length === 0)
              return !1;
          return !0;
        }
        return !1;
      }
      /**
       * Build input scripts (or witnesses).
       * @param {KeyRing} ring - Address used to sign. The address
       * must be able to redeem the coin.
       * @returns {Number} Number of inputs templated.
       */
      template(R) {
        if (Array.isArray(R)) {
          let fe = 0;
          for (const ue of R)
            fe += this.template(ue);
          return fe;
        }
        let L = 0;
        for (let fe = 0; fe < this.inputs.length; fe++) {
          const { prevout: ue } = this.inputs[fe], ae = this.view.getOutput(ue);
          ae && R.ownOutput(ae) && this.scriptInput(fe, ae, R) && (L += 1);
        }
        return L;
      }
      /**
       * Built input scripts (or witnesses) and sign the inputs.
       * @param {KeyRing} ring - Address used to sign. The address
       * must be able to redeem the coin.
       * @param {SighashType} type
       * @returns {Number} Number of inputs signed.
       */
      sign(R, L) {
        if (Array.isArray(R)) {
          let ue = 0;
          for (const ae of R)
            ue += this.sign(ae, L);
          return ue;
        }
        l(R.privateKey, "No private key available.");
        let fe = 0;
        for (let ue = 0; ue < this.inputs.length; ue++) {
          const { prevout: ae } = this.inputs[ue], D = this.view.getOutput(ae);
          D && R.ownOutput(D) && this.scriptInput(ue, D, R) && this.signInput(ue, D, R, L) && (fe += 1);
        }
        return fe;
      }
      /**
       * Sign the transaction inputs on the worker pool
       * (if workers are enabled).
       * @param {KeyRing} ring
       * @param {SighashType?} type
       * @param {WorkerPool?} pool
       * @returns {Promise}
       */
      async signAsync(R, L, fe) {
        return fe ? await fe.sign(this, R, L) : this.sign(R, L);
      }
      /**
       * Estimate maximum possible size.
       * @param {Function?} estimate - Input script size estimator.
       * @returns {Number}
       */
      async estimateSize(R) {
        let L = 0;
        L += 4, L += w.sizeVarint(this.inputs.length), L += this.inputs.length * 40, L += w.sizeVarint(this.outputs.length);
        for (const fe of this.outputs)
          L += fe.getSize();
        L += 4;
        for (const { prevout: fe } of this.inputs) {
          const ue = this.view.getOutput(fe);
          if (!ue) {
            L += 110;
            continue;
          }
          const ae = ue.script;
          if (ae.isPubkey()) {
            L += 1, L += 74;
            continue;
          }
          if (ae.isPubkeyhash()) {
            L += 1, L += 74, L += 34;
            continue;
          }
          const [D] = ae.getMultisig();
          if (D !== -1) {
            let Q = 0;
            Q += 1, Q += 74 * D, Q += w.sizeVarint(Q), L += Q;
            continue;
          }
          if (R) {
            const Q = await R(ae);
            if (Q !== -1) {
              L += Q;
              continue;
            }
          }
          if (ae.isScripthash()) {
            L += 1, L += 149;
            continue;
          }
          L += 110;
        }
        return L;
      }
      /**
       * Select necessary coins based on total output value.
       * @param {Coin[]} coins
       * @param {Object?} options
       * @returns {CoinSelection}
       * @throws on not enough funds available.
       */
      selectCoins(R, L) {
        return new j(this, L).select(R);
      }
      /**
       * Attempt to subtract a fee from a single output.
       * @param {Number} index
       * @param {Amount} fee
       */
      subtractIndex(R, L) {
        l(typeof R == "number"), l(typeof L == "number");
        const fe = this.outputs[R];
        if (!fe)
          throw new Error("Subtraction index does not exist.");
        if (fe.value < L + fe.getDustThreshold())
          throw new Error("Could not subtract fee.");
        fe.value -= L;
      }
      /**
       * Attempt to subtract a fee from all outputs evenly.
       * @param {Amount} fee
       */
      subtractFee(R) {
        l(typeof R == "number");
        let L = 0;
        for (const ae of this.outputs)
          ae.script.isUnspendable() || (L += 1);
        if (L === 0)
          throw new Error("Could not subtract fee.");
        const fe = R % L, ue = (R - fe) / L;
        for (const ae of this.outputs)
          if (!ae.script.isUnspendable()) {
            if (ae.value < ue + ae.getDustThreshold())
              throw new Error("Could not subtract fee.");
            ae.value -= ue;
          }
        for (const ae of this.outputs)
          if (!ae.script.isUnspendable() && ae.value >= fe + ae.getDustThreshold()) {
            ae.value -= fe;
            return;
          }
        throw new Error("Could not subtract fee.");
      }
      /**
       * Select coins and fill the inputs.
       * @param {Coin[]} coins
       * @param {Object} options - See {@link MTX#selectCoins} options.
       * @returns {CoinSelector}
       */
      async fund(R, L) {
        l(L, "Options are required."), l(L.changeAddress, "Change address is required."), l(this.inputs.length === 0, "TX is already funded.");
        const fe = await this.selectCoins(R, L);
        for (const ae of fe.chosen)
          this.addCoin(ae);
        if (fe.subtractFee) {
          const ae = fe.subtractIndex;
          ae !== -1 ? this.subtractIndex(ae, fe.fee) : this.subtractFee(fe.fee);
        }
        const ue = new o();
        return ue.value = fe.change, ue.script.fromAddress(fe.changeAddress), ue.isDust(y.MIN_RELAY) ? (this.changeIndex = -1, l.strictEqual(this.getFee(), fe.fee + fe.change)) : (this.outputs.push(ue), this.changeIndex = this.outputs.length - 1, l.strictEqual(this.getFee(), fe.fee)), fe;
      }
      /**
       * Sort inputs and outputs according to BIP69.
       * @see https://github.com/bitcoin/bips/blob/master/bip-0069.mediawiki
       */
      sortMembers() {
        let R = null;
        this.changeIndex !== -1 && (R = this.outputs[this.changeIndex], l(R)), this.inputs.sort(q), this.outputs.sort(_), this.changeIndex !== -1 && (this.changeIndex = this.outputs.indexOf(R), l(this.changeIndex !== -1));
      }
      /**
       * Avoid fee sniping.
       * @param {Number} - Current chain height.
       * @see bitcoin/src/wallet/wallet.cpp
       */
      avoidFeeSniping(R) {
        l(typeof R == "number", "Must pass in height."), (Math.random() * 10 | 0) === 0 && (R -= Math.random() * 100 | 0, R < 0 && (R = 0)), this.setLocktime(R);
      }
      /**
       * Set locktime and sequences appropriately.
       * @param {Number} locktime
       */
      setLocktime(R) {
        l(R >>> 0 === R, "Locktime must be a uint32."), l(this.inputs.length > 0, "Cannot set sequence with no inputs.");
        for (const L of this.inputs)
          L.sequence === 4294967295 && (L.sequence = 4294967294);
        this.locktime = R;
      }
      /**
       * Set sequence locktime.
       * @param {Number} index - Input index.
       * @param {Number} locktime
       * @param {Boolean?} seconds
       */
      setSequence(R, L, fe) {
        const ue = this.inputs[R];
        l(ue, "Input does not exist."), l(L >>> 0 === L, "Locktime must be a uint32."), this.version = 2, fe ? (L >>>= S.SEQUENCE_GRANULARITY, L &= S.SEQUENCE_MASK, L |= S.SEQUENCE_TYPE_FLAG) : L &= S.SEQUENCE_MASK, ue.sequence = L;
      }
      /**
       * Inspect the transaction.
       * @returns {Object}
       */
      [E]() {
        return this.format();
      }
      /**
       * Inspect the transaction.
       * @returns {Object}
       */
      format() {
        return super.format(this.view);
      }
      /**
       * Convert transaction to JSON.
       * @returns {Object}
       */
      toJSON() {
        return super.toJSON(null, this.view);
      }
      /**
       * Convert transaction to JSON.
       * @param {Network} network
       * @returns {Object}
       */
      getJSON(R) {
        return super.getJSON(R, this.view);
      }
      /**
       * Inject properties from a json object
       * @param {Object} json
       */
      fromJSON(R) {
        super.fromJSON(R);
        for (let L = 0; L < R.inputs.length; L++) {
          const fe = R.inputs[L], { prevout: ue } = fe;
          if (!fe.coin)
            continue;
          const ae = s.fromJSON(fe.coin);
          ae.hash = a.fromRev(ue.hash), ae.index = ue.index, this.view.addCoin(ae);
        }
        return this;
      }
      /**
       * Instantiate a transaction from a
       * jsonified transaction object.
       * @param {Object} json - The jsonified transaction object.
       * @returns {MTX}
       */
      static fromJSON(R) {
        return new this().fromJSON(R);
      }
      /**
       * Instantiate a transaction from a buffer reader.
       * @param {BufferReader} br
       * @returns {MTX}
       */
      static fromReader(R) {
        return new this().fromReader(R);
      }
      /**
       * Instantiate a transaction from a serialized Buffer.
       * @param {Buffer} data
       * @param {String?} enc - Encoding, can be `'hex'` or null.
       * @returns {MTX}
       */
      static fromRaw(R, L) {
        return typeof R == "string" && (R = k.from(R, L)), new this().fromRaw(R);
      }
      /**
       * Convert the MTX to a TX.
       * @returns {TX}
       */
      toTX() {
        return new n().inject(this);
      }
      /**
       * Convert the MTX to a TX.
       * @returns {Array} [tx, view]
       */
      commit() {
        return [this.toTX(), this.view];
      }
      /**
       * Instantiate MTX from TX.
       * @param {TX} tx
       * @returns {MTX}
       */
      static fromTX(R) {
        return new this().inject(R);
      }
      /**
       * Test whether an object is an MTX.
       * @param {Object} obj
       * @returns {Boolean}
       */
      static isMTX(R) {
        return R instanceof H;
      }
    }
    class j {
      /**
       * Create a coin selector.
       * @constructor
       * @param {TX} tx
       * @param {Object?} options
       */
      constructor(R, L) {
        this.tx = R.clone(), this.coins = [], this.outputValue = 0, this.index = 0, this.chosen = [], this.change = 0, this.fee = j.MIN_FEE, this.selection = "value", this.subtractFee = !1, this.subtractIndex = -1, this.height = -1, this.depth = -1, this.hardFee = -1, this.rate = j.FEE_RATE, this.maxFee = -1, this.round = !1, this.changeAddress = null, this.inputs = new m(), this.estimate = null, this.injectInputs(), L && this.fromOptions(L);
      }
      /**
       * Initialize selector options.
       * @param {Object} options
       * @private
       */
      fromOptions(R) {
        if (R.selection && (l(typeof R.selection == "string"), this.selection = R.selection), R.subtractFee != null && (typeof R.subtractFee == "number" ? (l(Number.isSafeInteger(R.subtractFee)), l(R.subtractFee >= -1), this.subtractIndex = R.subtractFee, this.subtractFee = this.subtractIndex !== -1) : (l(typeof R.subtractFee == "boolean"), this.subtractFee = R.subtractFee)), R.subtractIndex != null && (l(Number.isSafeInteger(R.subtractIndex)), l(R.subtractIndex >= -1), this.subtractIndex = R.subtractIndex, this.subtractFee = this.subtractIndex !== -1), R.height != null && (l(Number.isSafeInteger(R.height)), l(R.height >= -1), this.height = R.height), R.confirmations != null && (l(Number.isSafeInteger(R.confirmations)), l(R.confirmations >= -1), this.depth = R.confirmations), R.depth != null && (l(Number.isSafeInteger(R.depth)), l(R.depth >= -1), this.depth = R.depth), R.hardFee != null && (l(Number.isSafeInteger(R.hardFee)), l(R.hardFee >= -1), this.hardFee = R.hardFee), R.rate != null && (l(Number.isSafeInteger(R.rate)), l(R.rate >= 0), this.rate = R.rate), R.maxFee != null && (l(Number.isSafeInteger(R.maxFee)), l(R.maxFee >= -1), this.maxFee = R.maxFee), R.round != null && (l(typeof R.round == "boolean"), this.round = R.round), R.changeAddress) {
          const L = R.changeAddress;
          typeof L == "string" ? this.changeAddress = g.fromString(L) : (l(L instanceof g), this.changeAddress = L);
        }
        if (R.estimate && (l(typeof R.estimate == "function"), this.estimate = R.estimate), R.inputs) {
          l(Array.isArray(R.inputs));
          for (let L = 0; L < R.inputs.length; L++) {
            const fe = R.inputs[L];
            l(fe && typeof fe == "object");
            const { hash: ue, index: ae } = fe;
            l(k.isBuffer(ue)), l(typeof ae == "number"), this.inputs.set(i.toKey(ue, ae), L);
          }
        }
        return this;
      }
      /**
       * Attempt to inject existing inputs.
       * @private
       */
      injectInputs() {
        if (this.tx.inputs.length > 0)
          for (let R = 0; R < this.tx.inputs.length; R++) {
            const { prevout: L } = this.tx.inputs[R];
            this.inputs.set(L.toKey(), R);
          }
      }
      /**
       * Initialize the selector with coins to select from.
       * @param {Coin[]} coins
       */
      init(R) {
        switch (this.coins = R.slice(), this.outputValue = this.tx.getOutputValue(), this.index = 0, this.chosen = [], this.change = 0, this.fee = j.MIN_FEE, this.tx.inputs.length = 0, this.selection) {
          case "all":
          case "random":
            this.coins.sort(T);
            break;
          case "age":
            this.coins.sort(N);
            break;
          case "value":
            this.coins.sort(A);
            break;
          default:
            throw new G(`Bad selection type: ${this.selection}.`);
        }
      }
      /**
       * Calculate total value required.
       * @returns {Amount}
       */
      total() {
        return this.subtractFee ? this.outputValue : this.outputValue + this.fee;
      }
      /**
       * Test whether the selector has
       * completely funded the transaction.
       * @returns {Boolean}
       */
      isFull() {
        return this.tx.getInputValue() >= this.total();
      }
      /**
       * Test whether a coin is spendable
       * with regards to the options.
       * @param {Coin} coin
       * @returns {Boolean}
       */
      isSpendable(R) {
        return this.tx.view.hasEntry(R) ? !1 : this.height === -1 ? !0 : R.coinbase ? !(R.height === -1 || this.height + 1 < R.height + S.COINBASE_MATURITY) : this.depth === -1 ? !0 : !(R.getDepth(this.height) < this.depth);
      }
      /**
       * Get the current fee based on a size.
       * @param {Number} size
       * @returns {Amount}
       */
      getFee(R) {
        if (this.round) {
          const fe = y.getRoundFee(R, this.rate);
          return Math.min(fe, j.MAX_FEE);
        }
        const L = y.getMinFee(R, this.rate);
        return Math.min(L, j.MAX_FEE);
      }
      /**
       * Fund the transaction with more
       * coins if the `output value + fee`
       * total was updated.
       */
      fund() {
        if (this.inputs.size > 0) {
          const R = [];
          for (let L = 0; L < this.inputs.size; L++)
            R.push(null);
          for (const L of this.coins) {
            const { hash: fe, index: ue } = L, ae = i.toKey(fe, ue), D = this.inputs.get(ae);
            D != null && (R[D] = L, this.inputs.delete(ae));
          }
          if (this.inputs.size > 0)
            throw new Error("Could not resolve preferred inputs.");
          for (const L of R)
            this.tx.addCoin(L), this.chosen.push(L);
        }
        for (; this.index < this.coins.length; ) {
          const R = this.coins[this.index++];
          if (this.isSpendable(R) && (this.tx.addCoin(R), this.chosen.push(R), this.selection !== "all" && this.isFull()))
            break;
        }
      }
      /**
       * Initiate selection from `coins`.
       * @param {Coin[]} coins
       * @returns {CoinSelector}
       */
      async select(R) {
        if (this.init(R), this.hardFee !== -1 ? this.selectHard() : await this.selectEstimate(), !this.isFull())
          throw new G(
            "Not enough funds.",
            this.tx.getInputValue(),
            this.total()
          );
        return this.change = this.tx.getInputValue() - this.total(), this;
      }
      /**
       * Initialize selection based on size estimate.
       */
      async selectEstimate() {
        this.fee = j.MIN_FEE, this.fund();
        const R = new o();
        this.changeAddress ? R.script.fromAddress(this.changeAddress) : R.script.fromPubkeyhash(k.allocUnsafe(20)), this.tx.outputs.push(R);
        do {
          const L = await this.tx.estimateSize(this.estimate);
          if (this.fee = this.getFee(L), this.maxFee > 0 && this.fee > this.maxFee)
            throw new G("Fee is too high.");
          this.isFull() || this.fund();
        } while (!this.isFull() && this.index < this.coins.length);
      }
      /**
       * Initiate selection based on a hard fee.
       */
      selectHard() {
        this.fee = Math.min(this.hardFee, j.MAX_FEE), this.fund();
      }
    }
    j.FEE_RATE = 1e4, j.MIN_FEE = 1e4, j.MAX_FEE = S.COIN / 10;
    class G extends Error {
      /**
       * Create a funding error.
       * @constructor
       * @param {String} msg
       * @param {Amount} available
       * @param {Amount} required
       */
      constructor(R, L, fe) {
        super(), this.type = "FundingError", this.message = R, this.availableFunds = -1, this.requiredFunds = -1, L != null && (this.message += ` (available=${b.btc(L)},`, this.message += ` required=${b.btc(fe)})`, this.availableFunds = L, this.requiredFunds = fe), Error.captureStackTrace && Error.captureStackTrace(this, G);
      }
    }
    function N(F, R) {
      return F = F.height === -1 ? 2147483647 : F.height, R = R.height === -1 ? 2147483647 : R.height, F - R;
    }
    function T(F, R) {
      return Math.random() > 0.5 ? 1 : -1;
    }
    function A(F, R) {
      return F.height === -1 && R.height !== -1 ? 1 : F.height !== -1 && R.height === -1 ? -1 : R.value - F.value;
    }
    function q(F, R) {
      return F.compare(R);
    }
    function _(F, R) {
      return F.compare(R);
    }
    c = H, c.MTX = H, c.Selector = j, c.FundingError = G, e.exports = c;
  }(Ps, Ps.exports)), Ps.exports;
}
var dh, ub;
function wy() {
  if (ub) return dh;
  ub = 1;
  const e = Xe(), c = At(), l = Qt(), w = In(), { inspectSymbol: m } = Kt();
  class f {
    /**
     * Create an extended transaction.
     * @constructor
     * @param {Object?} options
     */
    constructor(u) {
      this.tx = new w(), this.mtime = l.now(), this.height = -1, this.block = null, this.time = 0, this.index = -1, u && this.fromOptions(u);
    }
    /**
     * Inject properties from options object.
     * @private
     * @param {Object} options
     */
    fromOptions(u) {
      return u.tx && (e(u.tx instanceof w), this.tx = u.tx), u.mtime != null && (e(u.mtime >>> 0 === u.mtime), this.mtime = u.mtime), u.height != null && (e(Number.isSafeInteger(u.height)), this.height = u.height), u.block !== void 0 && (e(u.block == null || k.isBuffer(u.block)), this.block = u.block), u.time != null && (e(u.time >>> 0 === u.time), this.time = u.time), u.index != null && (e(Number.isSafeInteger(u.index)), this.index = u.index), this;
    }
    /**
     * Instantiate TXMeta from options.
     * @param {Object} options
     * @returns {TXMeta}
     */
    static fromOptions(u) {
      return new this().fromOptions(u);
    }
    /**
     * Inject properties from options object.
     * @private
     * @param {Object} options
     */
    fromTX(u, o, s) {
      return this.tx = u, o && (this.height = o.height, this.block = o.hash, this.time = o.time, this.index = s), this;
    }
    /**
     * Instantiate TXMeta from options.
     * @param {Object} options
     * @returns {TXMeta}
     */
    static fromTX(u, o, s) {
      return new this().fromTX(u, o, s);
    }
    /**
     * Inspect the transaction.
     * @returns {Object}
     */
    [m]() {
      return this.format();
    }
    /**
     * Inspect the transaction.
     * @returns {Object}
     */
    format(u) {
      const o = this.tx.format(u, null, this.index);
      return o.mtime = this.mtime, o.height = this.height, o.block = this.block ? l.revHex(this.block) : null, o.time = this.time, o;
    }
    /**
     * Convert transaction to JSON.
     * @returns {Object}
     */
    toJSON() {
      return this.getJSON();
    }
    /**
     * Convert the transaction to an object suitable
     * for JSON serialization.
     * @param {Network} network
     * @param {CoinView} view
     * @returns {Object}
     */
    getJSON(u, o, s) {
      const i = this.tx.getJSON(u, o, null, this.index);
      return i.mtime = this.mtime, i.height = this.height, i.block = this.block ? l.revHex(this.block) : null, i.time = this.time, i.confirmations = 0, s != null && this.height !== -1 && (i.confirmations = s - this.height + 1), i;
    }
    /**
     * Inject properties from a json object.
     * @private
     * @param {Object} json
     */
    fromJSON(u) {
      return this.tx.fromJSON(u), e(u.mtime >>> 0 === u.mtime), e(Number.isSafeInteger(u.height)), e(!u.block || typeof u.block == "string"), e(u.time >>> 0 === u.time), e(Number.isSafeInteger(u.index)), this.mtime = u.mtime, this.height = u.height, this.block = l.fromRev(u.block), this.index = u.index, this;
    }
    /**
     * Instantiate a transaction from a
     * jsonified transaction object.
     * @param {Object} json - The jsonified transaction object.
     * @returns {TX}
     */
    static fromJSON(u) {
      return new this().fromJSON(u);
    }
    /**
     * Calculate serialization size.
     * @returns {Number}
     */
    getSize() {
      let u = 0;
      return u += this.tx.getSize(), u += 4, this.block ? (u += 1, u += 32, u += 12) : u += 1, u;
    }
    /**
     * Serialize a transaction to "extended format".
     * This is the serialization format bcoin uses internally
     * to store transactions in the database. The extended
     * serialization includes the height, block hash, index,
     * timestamp, and pending-since time.
     * @returns {Buffer}
     */
    toRaw() {
      const u = this.getSize(), o = c.write(u);
      return this.tx.toWriter(o), o.writeU32(this.mtime), this.block ? (o.writeU8(1), o.writeHash(this.block), o.writeU32(this.height), o.writeU32(this.time), o.writeU32(this.index)) : o.writeU8(0), o.render();
    }
    /**
     * Inject properties from "extended" serialization format.
     * @private
     * @param {Buffer} data
     */
    fromRaw(u) {
      const o = c.read(u);
      return this.tx.fromReader(o), this.mtime = o.readU32(), o.readU8() === 1 && (this.block = o.readHash(), this.height = o.readU32(), this.time = o.readU32(), this.index = o.readU32(), this.index === 2147483647 && (this.index = -1)), this;
    }
    /**
     * Instantiate a transaction from a Buffer
     * in "extended" serialization format.
     * @param {Buffer} data
     * @param {String?} enc - One of `"hex"` or `null`.
     * @returns {TX}
     */
    static fromRaw(u, o) {
      return typeof u == "string" && (u = k.from(u, o)), new this().fromRaw(u);
    }
    /**
     * Test whether an object is an TXMeta.
     * @param {Object} obj
     * @returns {Boolean}
     */
    static isTXMeta(u) {
      return u instanceof f;
    }
  }
  return dh = f, dh;
}
/*!
 * primitives/index.js - bitcoin primitives for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var hb;
function yy() {
  return hb || (hb = 1, Yt.AbstractBlock = us(), Yt.Address = Gr(), Yt.Block = d1(), Yt.Coin = cs(), Yt.Headers = hs(), Yt.Input = Bo(), Yt.InvItem = ko(), Yt.KeyRing = b1(), Yt.MemBlock = xy(), Yt.MerkleBlock = l1(), Yt.MTX = p1(), Yt.Outpoint = Ei(), Yt.Output = Si(), Yt.TX = In(), Yt.TXMeta = wy()), Yt;
}
var bi = {}, bh = {};
/*!
 * errors.js - error objects for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var lb;
function vy() {
  if (lb) return bh;
  lb = 1;
  const e = Xe();
  class c extends Error {
    /**
     * Create a verify error.
     * @constructor
     * @param {Block|TX} msg
     * @param {String} code - Reject packet code.
     * @param {String} reason - Reject packet reason.
     * @param {Number} score - Ban score increase
     * (can be -1 for no reject packet).
     * @param {Boolean} malleated
     */
    constructor(w, m, f, n, u) {
      super(), e(typeof m == "string"), e(typeof f == "string"), e(n >= 0), this.type = "VerifyError", this.message = "", this.code = m, this.reason = f, this.score = n, this.hash = w.hash(), this.malleated = u || !1, this.message = `Verification failure: ${f} (code=${m} score=${n} hash=${w.rhash()})`, Error.captureStackTrace && Error.captureStackTrace(this, c);
    }
  }
  return bh.VerifyError = c, bh;
}
/*!
 * protocol/index.js - protocol constants for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var db;
function Sy() {
  return db || (db = 1, bi.consensus = Lt(), bi.errors = vy(), bi.Network = Or(), bi.networks = o1(), bi.policy = vi(), bi.timedata = Sp()), bi;
}
var Br = {}, ph, bb;
function zp() {
  if (bb) return ph;
  bb = 1;
  const e = Xe(), { BufferMap: c } = $r(), l = zr();
  class w {
    /**
     * Create a signature cache.
     * @constructor
     * @param {Number} [size=10000]
     */
    constructor(n) {
      n == null && (n = 1e4), e(n >>> 0 === n), this.size = n, this.keys = [], this.valid = new c();
    }
    /**
     * Resize the sigcache.
     * @param {Number} size
     */
    resize(n) {
      e(n >>> 0 === n), this.size = n, this.keys.length = 0, this.valid.clear();
    }
    /**
     * Add item to the sigcache.
     * Potentially evict a random member.
     * @param {Hash} msg - Sig hash.
     * @param {Buffer} sig
     * @param {Buffer} key
     */
    add(n, u, o) {
      if (this.size !== 0)
        if (this.valid.set(n, new m(u, o)), this.keys.length >= this.size) {
          const s = Math.floor(Math.random() * this.keys.length), i = this.keys[s];
          this.valid.delete(i), this.keys[s] = n;
        } else
          this.keys.push(n);
    }
    /**
     * Test whether the sig exists.
     * @param {Hash} msg - Sig hash.
     * @param {Buffer} sig
     * @param {Buffer} key
     * @returns {Boolean}
     */
    has(n, u, o) {
      const s = this.valid.get(n);
      return s ? s.equals(u, o) : !1;
    }
    /**
     * Verify a signature, testing
     * it against the cache first.
     * @param {Buffer} msg
     * @param {Buffer} sig
     * @param {Buffer} key
     * @returns {Boolean}
     */
    verify(n, u, o) {
      return this.size === 0 ? l.verifyDER(n, u, o) : this.has(n, u, o) ? !0 : l.verifyDER(n, u, o) ? (this.add(n, u, o), !0) : !1;
    }
    /**
     * Verify a schnorr signature, testing
     * it against the cache first.
     * @param {Buffer} msg
     * @param {Buffer} sig
     * @param {Buffer} key
     * @returns {Boolean}
     */
    verifySchnorr(n, u, o) {
      return this.size === 0 ? l.schnorrVerify(n, u, o) : this.has(n, u, o) ? !0 : l.schnorrVerify(n, u, o) ? (this.add(n, u, o), !0) : !1;
    }
  }
  class m {
    /**
     * Create a cache entry.
     * @constructor
     * @param {Buffer} sig
     * @param {Buffer} key
     */
    constructor(n, u) {
      this.sig = k.from(n), this.key = k.from(u);
    }
    /**
     * Compare an entry to a sig and key.
     * @param {Buffer} sig
     * @param {Buffer} key
     * @returns {Boolean}
     */
    equals(n, u) {
      return this.sig.equals(n) && this.key.equals(u);
    }
  }
  return ph = w, ph;
}
/*!
 * script/index.js - bitcoin scripting for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var pb;
function Ey() {
  return pb || (pb = 1, Br.common = fs(), Br.Opcode = a1(), Br.Script = Cr(), Br.ScriptError = So(), Br.ScriptNum = Gi(), Br.sigcache = zp(), Br.Stack = Eo(), Br.Metrics = Bp(), Br.SLP = Io()), Br;
}
var mh, mb;
function Cp() {
  if (mb) return mh;
  mb = 1;
  function e(m) {
    if (typeof m != "string")
      throw new TypeError("Path must be a string. Received " + JSON.stringify(m));
  }
  function c(m, f) {
    for (var n = "", u = 0, o = -1, s = 0, i, p = 0; p <= m.length; ++p) {
      if (p < m.length)
        i = m.charCodeAt(p);
      else {
        if (i === 47)
          break;
        i = 47;
      }
      if (i === 47) {
        if (!(o === p - 1 || s === 1)) if (o !== p - 1 && s === 2) {
          if (n.length < 2 || u !== 2 || n.charCodeAt(n.length - 1) !== 46 || n.charCodeAt(n.length - 2) !== 46) {
            if (n.length > 2) {
              var g = n.lastIndexOf("/");
              if (g !== n.length - 1) {
                g === -1 ? (n = "", u = 0) : (n = n.slice(0, g), u = n.length - 1 - n.lastIndexOf("/")), o = p, s = 0;
                continue;
              }
            } else if (n.length === 2 || n.length === 1) {
              n = "", u = 0, o = p, s = 0;
              continue;
            }
          }
          f && (n.length > 0 ? n += "/.." : n = "..", u = 2);
        } else
          n.length > 0 ? n += "/" + m.slice(o + 1, p) : n = m.slice(o + 1, p), u = p - o - 1;
        o = p, s = 0;
      } else i === 46 && s !== -1 ? ++s : s = -1;
    }
    return n;
  }
  function l(m, f) {
    var n = f.dir || f.root, u = f.base || (f.name || "") + (f.ext || "");
    return n ? n === f.root ? n + u : n + m + u : u;
  }
  var w = {
    // path.resolve([from ...], to)
    resolve: function() {
      for (var f = "", n = !1, u, o = arguments.length - 1; o >= -1 && !n; o--) {
        var s;
        o >= 0 ? s = arguments[o] : (u === void 0 && (u = St.cwd()), s = u), e(s), s.length !== 0 && (f = s + "/" + f, n = s.charCodeAt(0) === 47);
      }
      return f = c(f, !n), n ? f.length > 0 ? "/" + f : "/" : f.length > 0 ? f : ".";
    },
    normalize: function(f) {
      if (e(f), f.length === 0) return ".";
      var n = f.charCodeAt(0) === 47, u = f.charCodeAt(f.length - 1) === 47;
      return f = c(f, !n), f.length === 0 && !n && (f = "."), f.length > 0 && u && (f += "/"), n ? "/" + f : f;
    },
    isAbsolute: function(f) {
      return e(f), f.length > 0 && f.charCodeAt(0) === 47;
    },
    join: function() {
      if (arguments.length === 0)
        return ".";
      for (var f, n = 0; n < arguments.length; ++n) {
        var u = arguments[n];
        e(u), u.length > 0 && (f === void 0 ? f = u : f += "/" + u);
      }
      return f === void 0 ? "." : w.normalize(f);
    },
    relative: function(f, n) {
      if (e(f), e(n), f === n || (f = w.resolve(f), n = w.resolve(n), f === n)) return "";
      for (var u = 1; u < f.length && f.charCodeAt(u) === 47; ++u)
        ;
      for (var o = f.length, s = o - u, i = 1; i < n.length && n.charCodeAt(i) === 47; ++i)
        ;
      for (var p = n.length, g = p - i, S = s < g ? s : g, y = -1, b = 0; b <= S; ++b) {
        if (b === S) {
          if (g > S) {
            if (n.charCodeAt(i + b) === 47)
              return n.slice(i + b + 1);
            if (b === 0)
              return n.slice(i + b);
          } else s > S && (f.charCodeAt(u + b) === 47 ? y = b : b === 0 && (y = 0));
          break;
        }
        var h = f.charCodeAt(u + b), a = n.charCodeAt(i + b);
        if (h !== a)
          break;
        h === 47 && (y = b);
      }
      var E = "";
      for (b = u + y + 1; b <= o; ++b)
        (b === o || f.charCodeAt(b) === 47) && (E.length === 0 ? E += ".." : E += "/..");
      return E.length > 0 ? E + n.slice(i + y) : (i += y, n.charCodeAt(i) === 47 && ++i, n.slice(i));
    },
    _makeLong: function(f) {
      return f;
    },
    dirname: function(f) {
      if (e(f), f.length === 0) return ".";
      for (var n = f.charCodeAt(0), u = n === 47, o = -1, s = !0, i = f.length - 1; i >= 1; --i)
        if (n = f.charCodeAt(i), n === 47) {
          if (!s) {
            o = i;
            break;
          }
        } else
          s = !1;
      return o === -1 ? u ? "/" : "." : u && o === 1 ? "//" : f.slice(0, o);
    },
    basename: function(f, n) {
      if (n !== void 0 && typeof n != "string") throw new TypeError('"ext" argument must be a string');
      e(f);
      var u = 0, o = -1, s = !0, i;
      if (n !== void 0 && n.length > 0 && n.length <= f.length) {
        if (n.length === f.length && n === f) return "";
        var p = n.length - 1, g = -1;
        for (i = f.length - 1; i >= 0; --i) {
          var S = f.charCodeAt(i);
          if (S === 47) {
            if (!s) {
              u = i + 1;
              break;
            }
          } else
            g === -1 && (s = !1, g = i + 1), p >= 0 && (S === n.charCodeAt(p) ? --p === -1 && (o = i) : (p = -1, o = g));
        }
        return u === o ? o = g : o === -1 && (o = f.length), f.slice(u, o);
      } else {
        for (i = f.length - 1; i >= 0; --i)
          if (f.charCodeAt(i) === 47) {
            if (!s) {
              u = i + 1;
              break;
            }
          } else o === -1 && (s = !1, o = i + 1);
        return o === -1 ? "" : f.slice(u, o);
      }
    },
    extname: function(f) {
      e(f);
      for (var n = -1, u = 0, o = -1, s = !0, i = 0, p = f.length - 1; p >= 0; --p) {
        var g = f.charCodeAt(p);
        if (g === 47) {
          if (!s) {
            u = p + 1;
            break;
          }
          continue;
        }
        o === -1 && (s = !1, o = p + 1), g === 46 ? n === -1 ? n = p : i !== 1 && (i = 1) : n !== -1 && (i = -1);
      }
      return n === -1 || o === -1 || // We saw a non-dot character immediately before the dot
      i === 0 || // The (right-most) trimmed path component is exactly '..'
      i === 1 && n === o - 1 && n === u + 1 ? "" : f.slice(n, o);
    },
    format: function(f) {
      if (f === null || typeof f != "object")
        throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof f);
      return l("/", f);
    },
    parse: function(f) {
      e(f);
      var n = { root: "", dir: "", base: "", ext: "", name: "" };
      if (f.length === 0) return n;
      var u = f.charCodeAt(0), o = u === 47, s;
      o ? (n.root = "/", s = 1) : s = 0;
      for (var i = -1, p = 0, g = -1, S = !0, y = f.length - 1, b = 0; y >= s; --y) {
        if (u = f.charCodeAt(y), u === 47) {
          if (!S) {
            p = y + 1;
            break;
          }
          continue;
        }
        g === -1 && (S = !1, g = y + 1), u === 46 ? i === -1 ? i = y : b !== 1 && (b = 1) : i !== -1 && (b = -1);
      }
      return i === -1 || g === -1 || // We saw a non-dot character immediately before the dot
      b === 0 || // The (right-most) trimmed path component is exactly '..'
      b === 1 && i === g - 1 && i === p + 1 ? g !== -1 && (p === 0 && o ? n.base = n.name = f.slice(1, g) : n.base = n.name = f.slice(p, g)) : (p === 0 && o ? (n.name = f.slice(1, i), n.base = f.slice(1, g)) : (n.name = f.slice(p, i), n.base = f.slice(p, g)), n.ext = f.slice(i, g)), p > 0 ? n.dir = f.slice(0, p - 1) : o && (n.dir = "/"), n;
    },
    sep: "/",
    delimiter: ":",
    win32: null,
    posix: null
  };
  return w.posix = w, mh = w, mh;
}
var ks = {}, Ln = {}, gb;
function m1() {
  if (gb) return Ln;
  gb = 1;
  const e = Nt();
  function c(n, u) {
    e(k.isBuffer(n)), e(typeof u == "number");
    const o = n.length - (n.length & 3), s = 3432918353, i = 461845907;
    let p = u | 0;
    for (let S = 0; S < o; S += 4) {
      let y = f(n, S);
      y = w(y, s), y = m(y, 15), y = w(y, i), p ^= y, p = m(p, 13), p = w(p, 5) + 3864292196 | 0;
    }
    let g = 0;
    switch (n.length & 3) {
      case 3:
        g ^= n[o + 2] << 16;
      case 2:
        g ^= n[o + 1] << 8;
      case 1:
        g ^= n[o + 0], g = w(g, s), g = m(g, 15), g = w(g, i), p ^= g;
    }
    return p ^= n.length, p ^= p >>> 16, p = w(p, 2246822507), p ^= p >>> 13, p = w(p, 3266489909), p ^= p >>> 16, p >>> 0;
  }
  function l(n, u, o) {
    e(typeof u == "number"), e(typeof o == "number");
    const s = w(u, 4221880213) + (o | 0);
    return c(n, s);
  }
  function w(n, u) {
    const o = n & 65535, s = u & 65535, i = n >>> 16, p = u >>> 16, g = o * s;
    return i * s + p * o + (g >>> 16) << 16 | g & 65535;
  }
  function m(n, u) {
    return n << u | n >>> 32 - u;
  }
  function f(n, u) {
    return n[u++] + n[u++] * 256 + n[u++] * 65536 + n[u] * 16777216;
  }
  return Ln.native = 0, Ln.sum = c, Ln.tweak = l, Ln;
}
var gh, xb;
function Iy() {
  if (xb) return gh;
  xb = 1;
  const { enforce: e } = Xe(), c = At(), l = m1(), w = k.alloc(0), m = 0.48045301391820144, f = 0.6931471805599453;
  class n extends c.Struct {
    /**
     * Create a bloom filter.
     * @constructor
     * @param {Number} size - Filter size in bits.
     * @param {Number} n - Number of hash functions.
     * @param {Number} tweak - Seed value.
     * @param {Number|String} - Update type.
     * @property {Buffer} filter
     * @property {Number} size
     * @property {Number} n
     * @property {Number} tweak
     * @property {Number} update - Update flag (see {@link BloomFilter.flags}).
     */
    constructor(s, i, p, g) {
      super(), this.filter = w, this.size = 0, this.n = 0, this.tweak = 0, this.update = n.flags.NONE, s != null && this.fromOptions(s, i, p, g);
    }
    /**
     * Inject properties from options.
     * @private
     * @param {Number} size - Filter size in bits.
     * @param {Number} n - Number of hash functions.
     * @param {Number} tweak - Seed value.
     * @param {Number|String} - Update type.
     * @returns {BloomFilter}
     */
    fromOptions(s, i, p, g) {
      return (p == null || p === -1) && (p = Math.random() * 4294967296 >>> 0), (g == null || g === -1) && (g = n.flags.NONE), typeof g == "string" && (g = n.flags[g.toUpperCase()], e(g != null, "update", "flag")), e(Number.isSafeInteger(s) && s >= 0, "size", "integer"), e(Number.isSafeInteger(i) && i >= 0, "n", "integer"), e(p >>> 0 === p, "tweak", "integer"), e(g >>> 0 === g, "update", "integer"), e(g <= 2, "update", "range between 0 and 2"), s < 8 && (s = 8), i === 0 && (i = 1), s -= s & 7, this.filter = k.alloc(s / 8, 0), this.size = s, this.n = i, this.tweak = p, this.update = g, this;
    }
    /**
     * Instantiate bloom filter from options.
     * @param {Number} size - Filter size in bits.
     * @param {Number} n - Number of hash functions.
     * @param {Number} tweak - Seed value.
     * @param {Number|String} - Update type.
     * @returns {BloomFilter}
     */
    static fromOptions(s, i, p, g) {
      return new this().fromOptions(s, i, p, g);
    }
    /**
     * Perform the mumur3 hash on data.
     * @param {Buffer} value
     * @param {Number} n
     * @returns {Number}
     */
    hash(s, i) {
      return l.tweak(s, i, this.tweak) % this.size;
    }
    /**
     * Reset the filter.
     */
    reset() {
      this.filter.fill(0);
    }
    /**
     * Add data to the filter.
     * @param {Buffer|String}
     * @param {String?} enc - Can be any of the Buffer object's encodings.
     */
    add(s, i) {
      const p = u(s, i);
      for (let g = 0; g < this.n; g++) {
        const S = this.hash(p, g);
        this.filter[S >>> 3] |= 1 << (7 & S);
      }
    }
    /**
     * Test whether data is present in the filter.
     * @param {Buffer|String} value
     * @param {String?} enc - Can be any of the Buffer object's encodings.
     * @returns {Boolean}
     */
    test(s, i) {
      const p = u(s, i);
      for (let g = 0; g < this.n; g++) {
        const S = this.hash(p, g);
        if ((this.filter[S >>> 3] & 1 << (7 & S)) === 0)
          return !1;
      }
      return !0;
    }
    /**
     * Test whether data is present in the
     * filter and potentially add data.
     * @param {Buffer|String} value
     * @param {String?} enc - Can be any of the Buffer object's encodings.
     * @returns {Boolean} Whether data was added.
     */
    added(s, i) {
      const p = u(s, i);
      let g = !1;
      for (let S = 0; S < this.n; S++) {
        const y = this.hash(p, S);
        !g && (this.filter[y >>> 3] & 1 << (7 & y)) === 0 && (g = !0), this.filter[y >>> 3] |= 1 << (7 & y);
      }
      return g;
    }
    /**
     * Create a filter from a false positive rate.
     * @param {Number} items - Expected number of items.
     * @param {Number} rate - False positive rate (0.0-1.0).
     * @param {Number|String} update
     * @example
     * BloomFilter.fromRate(800000, 0.0001, 'none');
     * @returns {BloomFilter}
     */
    static fromRate(s, i, p) {
      e(Number.isSafeInteger(s) && s > 0, "items", "integer"), e(typeof i == "number" && isFinite(i), "rate", "number"), e(i >= 0 && i <= 1, "rate", "range between 0.1 and 1.0.");
      const g = -1 / m * s * Math.log(i) | 0, S = Math.max(8, g);
      if (p !== -1 && S > n.MAX_BLOOM_FILTER_SIZE * 8)
        throw new Error("Bloom filter size violates policy limits!");
      const y = Math.max(1, S / s * f | 0);
      if (p !== -1 && y > n.MAX_HASH_FUNCS)
        throw new Error("Bloom filter size violates policy limits!");
      return new this(S, y, -1, p);
    }
    /**
     * Ensure the filter is within the size limits.
     * @returns {Boolean}
     */
    isWithinConstraints() {
      return !(this.size > n.MAX_BLOOM_FILTER_SIZE * 8 || this.n > n.MAX_HASH_FUNCS);
    }
    /**
     * Get serialization size.
     * @returns {Number}
     */
    getSize() {
      return c.sizeVarBytes(this.filter) + 9;
    }
    /**
     * Write filter to buffer writer.
     * @param {BufferWriter} bw
     */
    write(s) {
      return s.writeVarBytes(this.filter), s.writeU32(this.n), s.writeU32(this.tweak), s.writeU8(this.update), s;
    }
    /**
     * Inject properties from buffer reader.
     * @private
     * @param {BufferReader} br
     */
    read(s) {
      if (this.filter = s.readVarBytes(), this.size = this.filter.length * 8, this.n = s.readU32(), this.tweak = s.readU32(), this.update = s.readU8(), this.update > 2)
        throw new Error("Invalid update flag.");
      return this;
    }
  }
  n.MAX_BLOOM_FILTER_SIZE = 36e3, n.MAX_HASH_FUNCS = 50, n.flags = {
    /**
     * Never update the filter with outpoints.
     */
    NONE: 0,
    /**
     * Always update the filter with outpoints.
     */
    ALL: 1,
    /**
     * Only update the filter with outpoints if it is
     * "asymmetric" in terms of addresses (pubkey/multisig).
     */
    PUBKEY_ONLY: 2
  }, n.flagsByVal = [
    "NONE",
    "ALL",
    "PUBKEY_ONLY"
  ];
  function u(o, s) {
    return typeof o != "string" ? (e(k.isBuffer(o), "value", "buffer"), o) : (e(typeof s == "string", "enc", "string"), k.from(o, s));
  }
  return gh = n, gh;
}
var xh, wb;
function Ay() {
  if (wb) return xh;
  wb = 1;
  const { enforce: e } = Xe(), { encoding: c } = At(), l = m1(), w = k.alloc(0);
  class m {
    /**
     * Create a rolling bloom filter.
     * @constructor
     * @param {Number} items - Expected number of items.
     * @param {Number} rate - False positive rate (0.0-1.0).
     */
    constructor(i, p) {
      this.entries = 0, this.generation = 1, this.n = 0, this.limit = 0, this.size = 0, this.items = 0, this.tweak = 0, this.filter = w, i != null && this.fromRate(i, p);
    }
    /**
     * Inject properties from items and FPR.
     * @private
     * @param {Number} items - Expected number of items.
     * @param {Number} rate - False positive rate (0.0-1.0).
     * @returns {RollingFilter}
     */
    fromRate(i, p) {
      e(Number.isSafeInteger(i) && i > 0, "items", "integer"), e(typeof p == "number" && isFinite(p), "rate", "number"), e(p >= 0 && p <= 1, "rate", "range between 0.1 and 1.0.");
      const g = Math.log(p), S = Math.max(1, Math.min(Math.round(g / Math.log(0.5)), 50)), y = (i + 1) / 2 | 0, b = y * 3;
      let h = -1 * S * b / Math.log(1 - Math.exp(g / S));
      h = Math.ceil(h), i = ((h + 63) / 64 | 0) << 1, i >>>= 0, i = Math.max(1, i);
      const a = Math.random() * 4294967296 >>> 0, E = k.alloc(i * 8, 0);
      return this.n = S, this.limit = y, this.size = h, this.items = i, this.tweak = a, this.filter = E, this;
    }
    /**
     * Instantiate rolling filter from items and FPR.
     * @param {Number} items - Expected number of items.
     * @param {Number} rate - False positive rate (0.0-1.0).
     * @returns {RollingFilter}
     */
    static fromRate(i, p) {
      return new this().fromRate(i, p);
    }
    /**
     * Perform the mumur3 hash on data.
     * @param {Buffer} value
     * @param {Number} seed
     * @returns {Number}
     */
    hash(i, p) {
      return l.tweak(i, p, this.tweak);
    }
    /**
     * Reset the filter.
     */
    reset() {
      this.entries !== 0 && (this.entries = 0, this.generation = 1, this.filter.fill(0));
    }
    /**
     * Add data to the filter.
     * @param {Buffer|String}
     * @param {String?} enc - Can be any of the Buffer object's encodings.
     */
    add(i, p) {
      const g = o(i, p);
      if (this.entries === this.limit) {
        this.entries = 0, this.generation += 1, this.generation === 4 && (this.generation = 1);
        const S = (this.generation & 1) * 4294967295, y = (this.generation >>> 1) * 4294967295;
        for (let b = 0; b < this.items; b += 2) {
          const h = b * 8, a = (b + 1) * 8, E = n(this.filter, h), H = n(this.filter, a), j = E.hi ^ S | H.hi ^ y, G = E.lo ^ S | H.lo ^ y;
          E.hi &= j, E.lo &= G, H.hi &= j, H.lo &= G, u(this.filter, E, h), u(this.filter, H, a);
        }
      }
      this.entries += 1;
      for (let S = 0; S < this.n; S++) {
        const y = this.hash(g, S), b = y & 63, h = (y >>> 6) % this.items, a = (h & -2) * 8, E = (h | 1) * 8, H = b % 8, j = (b - H) / 8;
        this.filter[a + j] &= ~(1 << H), this.filter[a + j] |= (this.generation & 1) << H, this.filter[E + j] &= ~(1 << H), this.filter[E + j] |= this.generation >>> 1 << H;
      }
    }
    /**
     * Test whether data is present in the filter.
     * @param {Buffer|String} value
     * @param {String?} enc - Can be any of the Buffer object's encodings.
     * @returns {Boolean}
     */
    test(i, p) {
      if (this.entries === 0)
        return !1;
      const g = o(i, p);
      for (let S = 0; S < this.n; S++) {
        const y = this.hash(g, S), b = y & 63, h = (y >>> 6) % this.items, a = (h & -2) * 8, E = (h | 1) * 8, H = b % 8, j = (b - H) / 8, G = this.filter[a + j] >>> H & 1, N = this.filter[E + j] >>> H & 1;
        if ((G | N) === 0)
          return !1;
      }
      return !0;
    }
    /**
     * Test whether data is present in the
     * filter and potentially add data.
     * @param {Buffer|String} value
     * @param {String?} enc - Can be any of the Buffer object's encodings.
     * @returns {Boolean} Whether data was added.
     */
    added(i, p) {
      const g = o(i, p);
      return this.test(g) ? !1 : (this.add(g), !0);
    }
  }
  class f {
    constructor(i, p) {
      this.hi = i, this.lo = p;
    }
  }
  function n(s, i) {
    const p = c.readU32(s, i + 4), g = c.readU32(s, i);
    return new f(p, g);
  }
  function u(s, i, p) {
    c.writeU32(s, i.hi, p + 4), c.writeU32(s, i.lo, p);
  }
  function o(s, i) {
    return typeof s != "string" ? (e(k.isBuffer(s), "value", "buffer"), s) : (e(typeof i == "string", "enc", "string"), k.from(s, i));
  }
  return xh = m, xh;
}
/*!
 * bfilter.js - bloom filters for javascript
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var yb;
function Dp() {
  if (yb) return ks;
  yb = 1;
  const e = Iy(), c = Ay();
  return ks.BloomFilter = e, ks.RollingFilter = c, ks;
}
var Bs = {}, wh, vb;
function Oy() {
  if (vb) return wh;
  vb = 1;
  const e = Xe();
  class c {
    /**
     * Create a lock.
     * @constructor
     * @param {Boolean?} named - Whether to
     * maintain a map of queued jobs by job name.
     * @param {Function?} CustomMap
     */
    constructor(f = !1, n) {
      e(typeof f == "boolean"), e(!n || typeof n == "function"), this.named = f, this.jobs = [], this.busy = !1, this.destroyed = !1, this.map = n ? new n() : /* @__PURE__ */ new Map(), this.current = null, this.unlocker = this.unlock.bind(this);
    }
    /**
     * Create a closure scoped lock.
     * @param {Boolean?} named
     * @param {Function?} CustomMap
     * @returns {Function} Lock method.
     */
    static create(f, n) {
      const u = new c(f, n);
      return function(s, i) {
        return u.lock(s, i);
      };
    }
    /**
     * Test whether the lock has a pending
     * job or a job in progress (by name).
     * @param {String} name
     * @returns {Boolean}
     */
    has(f) {
      if (e(this.named, "Must use named jobs."), this.current) {
        if (k.isBuffer(f)) {
          if (this.current.equals(f))
            return !0;
        } else if (this.current === f)
          return !0;
      }
      return this.pending(f);
    }
    /**
     * Test whether the lock has
     * a pending job by name.
     * @param {String} name
     * @returns {Boolean}
     */
    pending(f) {
      e(this.named, "Must use named jobs.");
      const n = this.map.get(f);
      return n == null ? !1 : n > 0;
    }
    /**
     * Lock the parent object and all its methods
     * which use the lock. Begin to queue calls.
     * @param {String?} name - Job name.
     * @param {Boolean?} force - Bypass the lock.
     * @returns {Promise} - Returns {Function}, must be
     * called once the method finishes executing in order
     * to resolve the queue.
     */
    lock(f, n) {
      let u, o;
      if (this.named ? (u = f || null, o = n || !1) : (u = null, o = f || !1), this.destroyed)
        return Promise.reject(new Error("Lock is destroyed."));
      if (o)
        return e(this.busy), Promise.resolve(w);
      if (this.busy) {
        if (u) {
          const s = this.map.get(u) || 0;
          this.map.set(u, s + 1);
        }
        return new Promise((s, i) => {
          this.jobs.push(new l(s, i, u));
        });
      }
      return this.busy = !0, this.current = u, Promise.resolve(this.unlocker);
    }
    /**
     * The actual unlock callback.
     * @private
     */
    unlock() {
      if (e(this.destroyed || this.busy), this.busy = !1, this.current = null, this.jobs.length === 0)
        return;
      e(!this.destroyed);
      const f = this.jobs.shift();
      if (f.name) {
        let n = this.map.get(f.name);
        e(n > 0), --n === 0 ? this.map.delete(f.name) : this.map.set(f.name, n);
      }
      this.busy = !0, this.current = f.name, f.resolve(this.unlocker);
    }
    /**
     * Destroy the lock. Purge all pending calls.
     */
    destroy() {
      e(!this.destroyed, "Lock is already destroyed."), this.destroyed = !0;
      const f = this.jobs;
      this.busy = !1, this.jobs = [], this.map.clear(), this.current = null;
      for (const n of f)
        n.reject(new Error("Lock was destroyed."));
    }
  }
  class l {
    /**
     * Create a lock job.
     * @constructor
     * @param {Function} resolve
     * @param {Function} reject
     * @param {String?} name
     */
    constructor(f, n, u) {
      this.resolve = f, this.reject = n, this.name = u || null;
    }
  }
  function w() {
  }
  return wh = c, wh;
}
/*!
 * maplock.js - lock and queue for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var yh, Sb;
function _y() {
  if (Sb) return yh;
  Sb = 1;
  const e = Xe();
  class c {
    /**
     * Create a mapped lock.
     * @param {Function?} CustomMap
     * @param {Function?} CustomSet
     * @constructor
     */
    constructor(f, n) {
      e(!f || typeof f == "function"), e(!n || typeof n == "function"), this.Map = f || Map, this.Set = n || Set, this.jobs = new this.Map(), this.busy = new this.Set(), this.destroyed = !1;
    }
    /**
     * Create a closure scoped lock.
     * @param {Function?} CustomMap
     * @param {Function?} CustomSet
     * @returns {Function} Lock method.
     */
    static create(f, n) {
      const u = new c(f, n);
      return function(s, i) {
        return u.lock(s, i);
      };
    }
    /**
     * Test whether the lock has a pending
     * job or a job in progress (by name).
     * @param {String} name
     * @returns {Boolean}
     */
    has(f) {
      return this.busy.has(f);
    }
    /**
     * Test whether the lock has
     * a pending job by name.
     * @param {String} name
     * @returns {Boolean}
     */
    pending(f) {
      return this.jobs.has(f);
    }
    /**
     * Lock the parent object and all its methods
     * which use the lock with a specified key.
     * Begin to queue calls.
     * @param {String|Number} key
     * @param {Boolean} [force=false] - Force a call.
     * @returns {Promise} - Returns {Function}, must be
     * called once the method finishes executing in order
     * to resolve the queue.
     */
    lock(f, n = !1) {
      return this.destroyed ? Promise.reject(new Error("Lock is destroyed.")) : f == null ? Promise.resolve(w) : n ? (e(this.busy.has(f)), Promise.resolve(w)) : this.busy.has(f) ? new Promise((u, o) => {
        this.jobs.has(f) || this.jobs.set(f, []), this.jobs.get(f).push(new l(u, o));
      }) : (this.busy.add(f), Promise.resolve(this._unlock(f)));
    }
    /**
     * Create an unlock callback.
     * @private
     * @param {String} key
     * @returns {Function} Unlocker.
     */
    _unlock(f) {
      const n = this;
      return function u() {
        n.unlock(f, u);
      };
    }
    /**
     * Unlock the mutex.
     * @param {String|Number} key
     * @param {Function} [unlocker=undefined]
     */
    unlock(f, n = void 0) {
      const u = this.jobs.get(f);
      if (e(this.destroyed || this.busy.has(f)), this.busy.delete(f), !u)
        return;
      e(!this.destroyed);
      const o = u.shift();
      e(o), u.length === 0 && this.jobs.delete(f), this.busy.add(f), o.resolve(n);
    }
    /**
     * Destroy the lock. Purge all pending calls.
     */
    destroy() {
      e(!this.destroyed, "Lock is already destroyed.");
      const f = this.jobs;
      this.destroyed = !0, this.jobs = new this.Map(), this.busy = new this.Set();
      for (const n of f.values())
        for (const u of n)
          u.reject(new Error("Lock was destroyed."));
    }
  }
  class l {
    /**
     * Create a lock job.
     * @constructor
     * @param {Function} resolve
     * @param {Function} reject
     */
    constructor(f, n) {
      this.resolve = f, this.reject = n;
    }
  }
  function w() {
  }
  return yh = c, yh;
}
/*!
 * bmutex.js - lock and queue for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var Eb;
function g1() {
  return Eb || (Eb = 1, Bs.Lock = Oy(), Bs.MapLock = _y()), Bs;
}
var nn = {}, vh, Ib;
function Ry() {
  if (Ib) return vh;
  Ib = 1;
  const e = Xe(), c = k.alloc(1, 0), l = k.alloc(255, 255);
  class w {
    /**
     * Create a DB instance.
     * @constructor
     * @param {Function} backend - Database backend.
     * @param {String} location - File location.
     * @param {Object?} options - Leveldown options.
     */
    constructor(a, E, H) {
      e(typeof a == "function", "Backend is required."), e(typeof E == "string", "Filename is required."), this.options = new o(H), this.backend = a, this.location = E, this.loading = !1, this.closing = !1, this.loaded = !1, this.binding = null, this.leveldown = !1, this.init();
    }
    /**
     * Initialize the database.
     * @private
     */
    init() {
      const a = this.backend;
      a.leveldown ? (this.binding = new a(this.location), this.leveldown = !0) : this.binding = new a(this.location);
    }
    /**
     * Open the database.
     * @returns {Promise}
     */
    async open() {
      if (this.loaded)
        throw new Error("Database is already open.");
      e(!this.loading), e(!this.closing);
      try {
        this.loading = !0, await this.load();
      } finally {
        this.loading = !1;
      }
      this.loaded = !0;
    }
    /**
     * Close the database.
     * @returns {Promise}
     */
    async close() {
      if (!this.loaded)
        throw new Error("Database is already closed.");
      e(!this.loading), e(!this.closing);
      try {
        this.loaded = !1, this.closing = !0, await this.unload();
      } catch (a) {
        throw this.loaded = !0, a;
      } finally {
        this.closing = !1;
      }
    }
    /**
     * Open the database.
     * @private
     * @returns {Promise}
     */
    load() {
      return new Promise((a, E) => {
        this.binding.open(this.options, p(a, E));
      });
    }
    /**
     * Close the database.
     * @private
     * @returns {Promise}
     */
    unload() {
      return new Promise((a, E) => {
        this.binding.close(p(a, E));
      });
    }
    /**
     * Destroy the database.
     * @returns {Promise}
     */
    destroy() {
      return new Promise((a, E) => {
        if (this.loaded || this.closing) {
          E(new Error("Cannot destroy open database."));
          return;
        }
        if (!this.backend.destroy) {
          E(new Error("Cannot destroy (method not available)."));
          return;
        }
        this.backend.destroy(this.location, p(a, E));
      });
    }
    /**
     * Repair the database.
     * @returns {Promise}
     */
    repair() {
      return new Promise((a, E) => {
        if (this.loaded || this.closing) {
          E(new Error("Cannot repair open database."));
          return;
        }
        if (!this.backend.repair) {
          E(new Error("Cannot repair (method not available)."));
          return;
        }
        this.backend.repair(this.location, p(a, E));
      });
    }
    /**
     * Backup the database.
     * @param {String} path
     * @returns {Promise}
     */
    backup(a) {
      return this.binding.backup ? new Promise((E, H) => {
        if (!this.loaded) {
          H(new Error("Database is closed."));
          return;
        }
        this.binding.backup(a, p(E, H));
      }) : this.clone(a);
    }
    /**
     * Create a bucket.
     * @param {Buffer} prefix
     * @returns {Bucket}
     */
    bucket(a) {
      return new f(this, a);
    }
    /**
     * Get root bucket.
     * @returns {Bucket}
     */
    root() {
      return this;
    }
    /**
     * Get child bucket.
     * @param {Buffer} prefix
     * @returns {Bucket}
     */
    child(a) {
      return this.bucket(a);
    }
    /**
     * Wrap a batch or iterator.
     * @param {Object} obj
     * @returns {Object}
     */
    wrap(a) {
      return a.root();
    }
    /**
     * Retrieve a record from the database.
     * @param {Buffer} key
     * @returns {Promise} - Returns Buffer.
     */
    get(a) {
      return new Promise((E, H) => {
        if (!this.loaded) {
          H(new Error("Database is closed."));
          return;
        }
        if (!k.isBuffer(a)) {
          H(new Error("Key must be a buffer."));
          return;
        }
        this.binding.get(a, (j, G) => {
          if (j) {
            if (i(j)) {
              E(null);
              return;
            }
            H(j);
            return;
          }
          E(G);
        });
      });
    }
    /**
     * Store a record in the database.
     * @param {Buffer} key
     * @param {Buffer} value
     * @returns {Promise}
     */
    put(a, E) {
      return E == null && (E = c), new Promise((H, j) => {
        if (!this.loaded) {
          j(new Error("Database is closed."));
          return;
        }
        if (!k.isBuffer(a) || !k.isBuffer(E)) {
          j(new Error("Key and value must be buffers."));
          return;
        }
        this.binding.put(a, E, p(H, j));
      });
    }
    /**
     * Remove a record from the database.
     * @param {Buffer} key
     * @returns {Promise}
     */
    del(a) {
      return new Promise((E, H) => {
        if (!this.loaded) {
          H(new Error("Database is closed."));
          return;
        }
        if (!k.isBuffer(a)) {
          H(new Error("Key must be a buffer."));
          return;
        }
        this.binding.del(a, p(E, H));
      });
    }
    /**
     * Create an atomic batch.
     * @returns {Batch}
     */
    batch() {
      if (!this.loaded)
        throw new Error("Database is closed.");
      return new m(this.binding.batch());
    }
    /**
     * Create an iterator.
     * @param {Object} options
     * @returns {Iterator}
     */
    iterator(a) {
      if (!this.loaded)
        throw new Error("Database is closed.");
      return new n(this, a);
    }
    /**
     * Get a database property.
     * @param {String} name - Property name.
     * @returns {String}
     */
    getProperty(a) {
      if (!this.loaded)
        throw new Error("Database is closed.");
      return this.binding.getProperty ? this.binding.getProperty(a) : "";
    }
    /**
     * Calculate approximate database size.
     * @param {Buffer|null} start - Start key.
     * @param {Buffer|null} end - End key.
     * @returns {Promise} - Returns Number.
     */
    approximateSize(a, E) {
      return a == null && (a = c), E == null && (E = l), new Promise((H, j) => {
        if (!this.loaded) {
          j(new Error("Database is closed."));
          return;
        }
        if (!this.binding.approximateSize) {
          j(new Error("Cannot get size."));
          return;
        }
        if (!k.isBuffer(a) || !k.isBuffer(E)) {
          j(new Error("Start and end must be buffers."));
          return;
        }
        this.binding.approximateSize(a, E, p(H, j));
      });
    }
    /**
     * Compact range of keys.
     * @param {Buffer|null} start - Start key.
     * @param {Buffer|null} end - End key.
     * @returns {Promise}
     */
    compactRange(a, E) {
      return a == null && (a = c), E == null && (E = l), new Promise((H, j) => {
        if (!this.loaded) {
          j(new Error("Database is closed."));
          return;
        }
        if (!this.binding.compactRange) {
          H();
          return;
        }
        if (!k.isBuffer(a) || !k.isBuffer(E)) {
          j(new Error("Start and end must be buffers."));
          return;
        }
        this.binding.compactRange(a, E, p(H, j));
      });
    }
    /**
     * Test whether a key exists.
     * @param {Buffer} key
     * @returns {Promise} - Returns Boolean.
     */
    async has(a) {
      return await this.get(a) != null;
    }
    /**
     * Collect all keys from iterator options.
     * @param {Object} options - Iterator options.
     * @returns {Promise} - Returns Array.
     */
    async range(a) {
      return a == null && (a = {}), this.iterator({
        gt: a.gt,
        lt: a.lt,
        gte: a.gte,
        lte: a.lte,
        limit: a.limit,
        reverse: a.reverse,
        keys: !0,
        values: !0
      }).range(a.parse);
    }
    /**
     * Collect all keys from iterator options.
     * @param {Object} options - Iterator options.
     * @returns {Promise} - Returns Array.
     */
    async keys(a) {
      return a == null && (a = {}), this.iterator({
        gt: a.gt,
        lt: a.lt,
        gte: a.gte,
        lte: a.lte,
        limit: a.limit,
        reverse: a.reverse,
        keys: !0,
        values: !1
      }).keys(a.parse);
    }
    /**
     * Collect all keys from iterator options.
     * @param {Object} options - Iterator options.
     * @returns {Promise} - Returns Array.
     */
    async values(a) {
      return a == null && (a = {}), this.iterator({
        gt: a.gt,
        lt: a.lt,
        gte: a.gte,
        lte: a.lte,
        limit: a.limit,
        reverse: a.reverse,
        keys: !1,
        values: !0
      }).values(a.parse);
    }
    /**
     * Dump database (for debugging).
     * @returns {Promise} - Returns Object.
     */
    async dump() {
      const a = /* @__PURE__ */ Object.create(null), E = await this.range();
      for (const H of E) {
        const j = H.key.toString("hex"), G = H.value.toString("hex");
        a[j] = G;
      }
      return a;
    }
    /**
     * Write and assert a version number for the database.
     * @param {Buffer} key
     * @param {String} name
     * @param {Number} version
     * @returns {Promise}
     */
    async verify(a, E, H) {
      e(typeof E == "string"), e(H >>> 0 === H);
      const j = await this.get(a);
      if (!j) {
        const N = k.alloc(E.length + 4);
        N.write(E, 0, "ascii"), N.writeUInt32LE(H, E.length);
        const T = this.batch();
        T.put(a, N), await T.write();
        return;
      }
      if (j.length !== E.length + 4)
        throw new Error(b(E));
      if (j.toString("ascii", 0, E.length) !== E)
        throw new Error(b(E));
      if (j.readUInt32LE(E.length) !== H)
        throw new Error(b(E));
    }
    /**
     * Clone the database.
     * @param {String} path
     * @returns {Promise}
     */
    async clone(a) {
      if (!this.loaded)
        throw new Error("Database is closed.");
      const E = new o(this.options);
      E.createIfMissing = !0, E.errorIfExists = !0;
      const H = new w(this.backend, a, E);
      await H.open();
      try {
        await this.cloneTo(H);
      } finally {
        await H.close();
      }
    }
    /**
     * Clone the database.
     * @param {Object} db
     * @returns {Promise}
     */
    async cloneTo(a) {
      const H = this.iterator({
        keys: !0,
        values: !0
      });
      let j = a.batch(), G = 0;
      return await H.each(async (N, T) => {
        j.put(N, T), G += N.length + 80, G += T.length + 80, G >= 268435456 && (await j.write(), j = a.batch(), G = 0);
      }), j.write();
    }
  }
  class m {
    /**
     * Create a batch.
     * @constructor
     * @ignore
     * @param {Object} binding
     * @param {Buffer} [prefix=null]
     */
    constructor(a, E) {
      this.binding = a, this.prefix = E || null;
    }
    /**
     * Get bucket.
     * @returns {Batch}
     */
    bucket(a) {
      return new m(this.binding, a);
    }
    /**
     * Get root batch.
     * @returns {Batch}
     */
    root() {
      return this.bucket(null);
    }
    /**
     * Get child batch.
     * @param {Buffer} prefix
     * @returns {Batch}
     */
    child(a) {
      return this.bucket(S(this.prefix, a));
    }
    /**
     * Wrap a batch or iterator.
     * @param {Object} obj
     * @returns {Object}
     */
    wrap(a) {
      return a.bucket(this.prefix);
    }
    /**
     * Write a value to the batch.
     * @param {Buffer} key
     * @param {Buffer} value
     */
    put(a, E) {
      return E == null && (E = c), e(k.isBuffer(E), "Value must be a buffer."), this.binding.put(S(this.prefix, a), E), this;
    }
    /**
     * Delete a value from the batch.
     * @param {Buffer} key
     */
    del(a) {
      return this.binding.del(S(this.prefix, a)), this;
    }
    /**
     * Write batch to database.
     * @returns {Promise}
     */
    write() {
      return new Promise((a, E) => {
        this.binding.write(p(a, E));
      });
    }
    /**
     * Clear the batch.
     */
    clear() {
      return this.binding.clear(), this;
    }
  }
  class f {
    /**
     * Create a bucket.
     * @constructor
     * @ignore
     * @param {DB} db
     * @param {Batch} batch
     * @param {Buffer} prefix
     */
    constructor(a, E) {
      e(
        E == null || k.isBuffer(E),
        "Prefix must be a buffer."
      ), this.db = a, this.prefix = E || null;
    }
    /**
     * Get bucket.
     * @param {Buffer} prefix
     * @returns {Bucket}
     */
    bucket(a) {
      return new f(this.db, a);
    }
    /**
     * Get root bucket.
     * @returns {Bucket}
     */
    root() {
      return this.bucket(null);
    }
    /**
     * Get child bucket.
     * @param {Buffer} prefix
     * @returns {Bucket}
     */
    child(a) {
      return this.bucket(S(this.prefix, a));
    }
    /**
     * Wrap a batch or iterator.
     * @param {Object} obj
     * @returns {Object}
     */
    wrap(a) {
      return a.bucket(this.prefix);
    }
    /**
     * Create a batch.
     * @returns {Batch}
     */
    batch() {
      return new m(this.db.binding.batch(), this.prefix);
    }
    /**
     * Get a value from the bucket.
     * @param {Buffer} key
     * @returns {Promise}
     */
    has(a) {
      return this.db.has(S(this.prefix, a));
    }
    /**
     * Get a value from the bucket.
     * @param {Buffer} key
     * @returns {Promise}
     */
    get(a) {
      return this.db.get(S(this.prefix, a));
    }
    /**
     * Create an iterator.
     * @param {Object} options
     * @returns {Iterator}
     */
    iterator(a) {
      return new n(this.db, a, this.prefix);
    }
    /**
     * Collect all keys from iterator options.
     * @param {Object} options - Iterator options.
     * @returns {Promise} - Returns Array.
     */
    async range(a) {
      return a == null && (a = {}), this.iterator({
        gt: a.gt,
        lt: a.lt,
        gte: a.gte,
        lte: a.lte,
        limit: a.limit,
        reverse: a.reverse,
        keys: !0,
        values: !0
      }).range(a.parse);
    }
    /**
     * Collect all keys from iterator options.
     * @param {Object} options - Iterator options.
     * @returns {Promise} - Returns Array.
     */
    async keys(a) {
      return a == null && (a = {}), this.iterator({
        gt: a.gt,
        lt: a.lt,
        gte: a.gte,
        lte: a.lte,
        limit: a.limit,
        reverse: a.reverse,
        keys: !0,
        values: !1
      }).keys(a.parse);
    }
    /**
     * Collect all keys from iterator options.
     * @param {Object} options - Iterator options.
     * @returns {Promise} - Returns Array.
     */
    async values(a) {
      return a == null && (a = {}), this.iterator({
        gt: a.gt,
        lt: a.lt,
        gte: a.gte,
        lte: a.lte,
        limit: a.limit,
        reverse: a.reverse,
        keys: !1,
        values: !0
      }).values(a.parse);
    }
  }
  class n {
    /**
     * Create an iterator.
     * @constructor
     * @ignore
     * @param {DB} db
     * @param {Object} [options=null]
     * @param {Buffer} [prefix=null]
     */
    constructor(a, E, H) {
      this.db = a, this.options = E || null, this.prefix = H || null, this.binding = null, this.cache = [], this.finished = !1, this.key = null, this.value = null;
    }
    /**
     * Start the iterator.
     */
    start() {
      if (this.binding)
        return;
      const a = new s(this.options);
      this.prefix != null && (e(k.isBuffer(this.prefix)), a.gte != null && (a.gte = S(this.prefix, a.gte)), a.lte != null && (a.lte = S(this.prefix, a.lte)), a.gt != null && (a.gt = S(this.prefix, a.gt)), a.lt != null && (a.lt = S(this.prefix, a.lt)), a.gt == null && a.gte == null && (a.gt = this.prefix), a.lt == null && a.lte == null && (a.lt = y(this.prefix))), this.binding = this.db.binding.iterator(a);
    }
    /**
     * Get bucket.
     * @param {Buffer} prefix
     * @returns {Iterator}
     */
    bucket(a) {
      return e(!this.binding), new n(this.db, this.options, a);
    }
    /**
     * Get root iterator.
     * @returns {Iterator}
     */
    root() {
      return this.bucket(null);
    }
    /**
     * Get child iterator.
     * @param {Buffer} prefix
     * @returns {Iterator}
     */
    child(a) {
      return this.bucket(S(this.prefix, a));
    }
    /**
     * Wrap a batch or iterator.
     * @param {Object} obj
     * @returns {Object}
     */
    wrap(a) {
      return a.bucket(this.prefix);
    }
    /**
     * Clean up iterator.
     * @private
     */
    cleanup() {
      this.cache = [], this.finished = !0, this.key = null, this.value = null;
    }
    /**
     * For each.
     * @returns {Promise}
     */
    async each(a) {
      for (e(typeof a == "function"); !this.finished; )
        for (await this.read(); this.cache.length > 0; ) {
          const E = g(this.prefix, this.cache.pop()), H = this.cache.pop();
          let j = null;
          try {
            j = a(E, H), j instanceof Promise && (j = await j);
          } catch (G) {
            throw await this.end(), G;
          }
          if (j === !1)
            return this.end();
        }
      return this.end();
    }
    /**
     * Seek to the next key.
     * @returns {Promise}
     */
    async next() {
      return this.finished || this.cache.length === 0 && await this.read(), this.cache.length > 0 ? (this.key = g(this.prefix, this.cache.pop()), this.value = this.cache.pop(), !0) : (e(this.finished), this.cleanup(), !1);
    }
    /**
     * Seek to the next key.
     * @private
     * @param {Function} callback
     */
    _read(a) {
      if (this.db.leveldown) {
        this.binding.next(a);
        return;
      }
      this.binding.next((E, H, j) => {
        if (E) {
          a(E);
          return;
        }
        if (H === void 0 && j === void 0) {
          a(null, [], !0);
          return;
        }
        a(null, [j, H], !1);
      });
    }
    /**
     * Seek to the next key (buffer values).
     * @private
     * @returns {Promise}
     */
    read() {
      return new Promise((a, E) => {
        if (!this.binding)
          try {
            this.start();
          } catch (H) {
            E(H);
            return;
          }
        this._read((H, j, G) => {
          if (H) {
            this.cleanup(), this.binding.end(() => E(H));
            return;
          }
          this.cache = j, this.finished = G, a();
        });
      });
    }
    /**
     * Seek to an arbitrary key.
     * @param {Buffer} key
     */
    seek(a) {
      return e(k.isBuffer(a), "Key must be a buffer."), this.start(), this.binding.seek(a), this;
    }
    /**
     * End the iterator.
     * @returns {Promise}
     */
    end() {
      return new Promise((a, E) => {
        if (!this.binding)
          try {
            this.start();
          } catch (H) {
            E(H);
            return;
          }
        this.cleanup(), this.binding.end(p(a, E));
      });
    }
    /**
     * Collect all keys and values from iterator options.
     * @param {Function} parse
     * @returns {Promise} - Returns Array.
     */
    async range(a) {
      e(!a || typeof a == "function");
      const E = [];
      return await this.each((H, j) => {
        if (a) {
          const G = a(H, j);
          G != null && E.push(G);
        } else
          E.push(new u(H, j));
      }), E;
    }
    /**
     * Collect all keys from iterator options.
     * @param {Function} parse
     * @returns {Promise} - Returns Array.
     */
    async keys(a) {
      e(!a || typeof a == "function");
      const E = [];
      return await this.each((H, j) => {
        a && (H = a(H)), H != null && E.push(H);
      }), E;
    }
    /**
     * Collect all values from iterator options.
     * @param {Function} parse
     * @returns {Promise} - Returns Array.
     */
    async values(a) {
      e(!a || typeof a == "function");
      const E = [];
      return await this.each((H, j) => {
        a && (j = a(j)), j != null && E.push(j);
      }), E;
    }
  }
  class u {
    /**
     * Create an iterator item.
     * @constructor
     * @ignore
     * @param {Buffer} key
     * @param {Buffer} value
     * @property {Buffer} key
     * @property {Buffer} value
     */
    constructor(a, E) {
      this.key = a, this.value = E;
    }
  }
  class o {
    /**
     * Create DBOptions.
     * @constructor
     * @ignore
     * @param {Object} options
     */
    constructor(a) {
      this.createIfMissing = !0, this.errorIfExists = !1, this.compression = !0, this.cacheSize = 8 << 20, this.writeBufferSize = 4 << 20, this.maxOpenFiles = 64, this.maxFileSize = 2 << 20, this.paranoidChecks = !1, this.memory = !1, a && this.fromOptions(a);
    }
    /**
     * Inject properties from options.
     * @private
     * @param {Object} options
     * @returns {DBOptions}
     */
    fromOptions(a) {
      return e(a, "Options are required."), a.createIfMissing != null && (e(
        typeof a.createIfMissing == "boolean",
        "`createIfMissing` must be a boolean."
      ), this.createIfMissing = a.createIfMissing), a.errorIfExists != null && (e(
        typeof a.errorIfExists == "boolean",
        "`errorIfExists` must be a boolean."
      ), this.errorIfExists = a.errorIfExists), a.compression != null && (e(
        typeof a.compression == "boolean",
        "`compression` must be a boolean."
      ), this.compression = a.compression), a.cacheSize != null && (e(
        typeof a.cacheSize == "number",
        "`cacheSize` must be a number."
      ), e(a.cacheSize >= 0), this.cacheSize = Math.floor(a.cacheSize / 2), this.writeBufferSize = Math.floor(a.cacheSize / 4)), a.maxFiles != null && (e(
        typeof a.maxFiles == "number",
        "`maxFiles` must be a number."
      ), e(a.maxFiles >= 0), this.maxOpenFiles = a.maxFiles), a.maxFileSize != null && (e(
        typeof a.maxFileSize == "number",
        "`maxFileSize` must be a number."
      ), e(a.maxFileSize >= 0), this.maxFileSize = a.maxFileSize), a.paranoidChecks != null && (e(
        typeof a.paranoidChecks == "boolean",
        "`paranoidChecks` must be a boolean."
      ), this.paranoidChecks = a.paranoidChecks), a.memory != null && (e(
        typeof a.memory == "boolean",
        "`memory` must be a boolean."
      ), this.memory = a.memory), this;
    }
  }
  class s {
    /**
     * Create iterator options.
     * @constructor
     * @ignore
     * @param {Object} options
     */
    constructor(a) {
      this.gte = null, this.lte = null, this.gt = null, this.lt = null, this.keys = !0, this.values = !1, this.fillCache = !1, this.keyAsBuffer = !0, this.valueAsBuffer = !0, this.reverse = !1, this.highWaterMark = 16 * 1024, a && this.fromOptions(a);
    }
    /**
     * Inject properties from options.
     * @private
     * @param {Object} options
     * @returns {IteratorOptions}
     */
    fromOptions(a) {
      if (e(a, "Options are required."), a.gte != null && (e(k.isBuffer(a.gte), "`gte` must be a buffer."), this.gte = a.gte), a.lte != null && (e(k.isBuffer(a.lte), "`lte` must be a buffer."), this.lte = a.lte), a.gt != null && (e(k.isBuffer(a.gt), "`gt` must be a buffer."), this.gt = a.gt), a.lt != null && (e(k.isBuffer(a.lt), "`lt` must be a buffer."), this.lt = a.lt), a.keys != null && (e(typeof a.keys == "boolean"), this.keys = a.keys), a.values != null && (e(typeof a.values == "boolean"), this.values = a.values), a.fillCache != null && (e(typeof a.fillCache == "boolean"), this.fillCache = a.fillCache), a.reverse != null && (e(typeof a.reverse == "boolean"), this.reverse = a.reverse), a.limit != null && (e(typeof a.limit == "number"), e(a.limit >= 0), this.limit = a.limit), !this.keys && !this.values)
        throw new Error("Keys and/or values must be chosen.");
      return this;
    }
  }
  function i(h) {
    return h ? h.notFound || h.type === "NotFoundError" || /not\s*found/i.test(h.message) : !1;
  }
  function p(h, a) {
    return function(E, H) {
      if (E) {
        a(E);
        return;
      }
      h(H);
    };
  }
  function g(h, a) {
    return a == null || (e(k.isBuffer(a), "Key must be a buffer."), a.length === 0) || h == null ? a : (e(k.isBuffer(h)), e(a.length >= h.length), a.slice(h.length));
  }
  function S(h, a) {
    if (e(k.isBuffer(a), "Key must be a buffer."), h == null)
      return a;
    e(k.isBuffer(h));
    const E = k.allocUnsafe(h.length + a.length);
    return h.copy(E, 0), a.copy(E, h.length), E;
  }
  function y(h) {
    if (h.length === 0)
      return null;
    const a = k.from(h);
    let E = a.length - 1;
    for (; E >= 0 && (a[E] += 1, a[E] === 0); E--)
      ;
    return E === -1 ? null : a;
  }
  function b(h) {
    return `Database version mismatch for database: "${h}". Please run a data migration before opening.`;
  }
  return vh = w, vh;
}
var Sh, Ab;
function Py() {
  if (Ab) return Sh;
  Ab = 1;
  const e = Xe(), c = /* @__PURE__ */ Object.create(null), l = k.alloc(0), w = k.alloc(255, 255), m = {
    char: {
      min: "\0",
      max: "ÿ",
      dynamic: !1,
      size(N) {
        return 1;
      },
      read(N, T) {
        return h(T + 1 <= N.length), String.fromCharCode(N[T]);
      },
      write(N, T, A) {
        return a(typeof T == "string"), a(T.length === 1), h(A + 1 <= N.length), N[A] = T.charCodeAt(0), 1;
      }
    },
    uint8: {
      min: 0,
      max: 255,
      dynamic: !1,
      size(N) {
        return 1;
      },
      read(N, T) {
        return h(T + 1 <= N.length), N[T];
      },
      write(N, T, A) {
        return a((T & 255) === T), h(A + 1 <= N.length), N[A] = T, 1;
      }
    },
    uint16: {
      min: 0,
      max: 65535,
      dynamic: !1,
      size(N) {
        return 2;
      },
      read(N, T) {
        return h(T + 2 <= N.length), H(N, T);
      },
      write(N, T, A) {
        return a((T & 65535) === T), h(A + 2 <= N.length), G(N, T, A), 2;
      }
    },
    uint32: {
      min: 0,
      max: 4294967295,
      dynamic: !1,
      size(N) {
        return 4;
      },
      read(N, T) {
        return h(T + 4 <= N.length), E(N, T);
      },
      write(N, T, A) {
        return a(T >>> 0 === T), h(A + 4 <= N.length), j(N, T, A), 4;
      }
    },
    buffer: {
      min: l,
      max: w,
      dynamic: !0,
      size(N) {
        return p(N);
      },
      read(N, T) {
        return g(N, T);
      },
      write(N, T, A) {
        return S(N, T, A);
      }
    },
    hex: {
      min: l.toString("hex"),
      max: w.toString("hex"),
      dynamic: !0,
      size(N) {
        return o(N, "hex");
      },
      read(N, T) {
        return s(N, T, "hex");
      },
      write(N, T, A) {
        return i(N, T, A, "hex");
      }
    },
    ascii: {
      min: l.toString("binary"),
      max: w.toString("binary"),
      dynamic: !0,
      size(N) {
        return o(N, "binary");
      },
      read(N, T) {
        return s(N, T, "binary");
      },
      write(N, T, A) {
        return i(N, T, A, "binary");
      }
    },
    utf8: {
      min: l.toString("utf8"),
      max: w.toString("utf8"),
      dynamic: !0,
      size(N) {
        return o(N, "utf8");
      },
      read(N, T) {
        return s(N, T, "utf8");
      },
      write(N, T, A) {
        return i(N, T, A, "utf8");
      }
    },
    hash160: {
      min: k.alloc(20, 0),
      max: k.alloc(20, 255),
      dynamic: !1,
      size(N) {
        return 20;
      },
      read(N, T) {
        return h(T + 20 <= N.length), N.slice(T, T + 20);
      },
      write(N, T, A) {
        return a(k.isBuffer(T)), a(T.copy(N, A) === 20), 20;
      }
    },
    hash256: {
      min: k.alloc(32, 0),
      max: k.alloc(32, 255),
      dynamic: !1,
      size(N) {
        return 32;
      },
      read(N, T) {
        return h(T + 32 <= N.length), N.slice(T, T + 32);
      },
      write(N, T, A) {
        return a(k.isBuffer(T)), a(T.copy(N, A) === 32), 32;
      }
    },
    hash: {
      min: k.alloc(1, 0),
      max: k.alloc(64, 255),
      dynamic: !0,
      size(N) {
        return a(k.isBuffer(N)), 1 + N.length;
      },
      read(N, T) {
        return h(T + 1 <= N.length), h(N[T] >= 1 && N[T] <= 64), h(T + 1 + N[T] <= N.length), N.slice(T + 1, T + 1 + N[T]);
      },
      write(N, T, A) {
        return a(k.isBuffer(T)), a(T.length >= 1 && T.length <= 64), h(A + 1 <= N.length), N[A] = T.length, a(T.copy(N, A + 1) === T.length), 1 + T.length;
      }
    },
    hhash160: {
      min: k.alloc(20, 0),
      max: k.alloc(20, 255),
      dynamic: !1,
      size(N) {
        return 20;
      },
      read(N, T) {
        return h(T + 20 <= N.length), N.toString("hex", T, T + 20);
      },
      write(N, T, A) {
        return a(b(N, T, A) === 20), 20;
      }
    },
    hhash256: {
      min: k.alloc(32, 0),
      max: k.alloc(32, 255),
      dynamic: !1,
      size(N) {
        return 32;
      },
      read(N, T) {
        return h(T + 32 <= N.length), N.toString("hex", T, T + 32);
      },
      write(N, T, A) {
        return a(b(N, T, A) === 32), 32;
      }
    },
    hhash: {
      min: k.alloc(1, 0),
      max: k.alloc(64, 255),
      dynamic: !0,
      size(N) {
        return 1 + y(N);
      },
      read(N, T) {
        return h(T + 1 <= N.length), h(N[T] >= 1 && N[T] <= 64), h(T + 1 + N[T] <= N.length), N.toString("hex", T + 1, T + 1 + N[T]);
      },
      write(N, T, A) {
        const q = y(T);
        return a(q >= 1 && q <= 64), h(A + 1 <= N.length), N[A] = q, a(b(N, T, A + 1) === q), 1 + q;
      }
    }
  };
  class f {
    /**
     * Create a base key.
     * @constructor
     * @param {String[]|null} ops
     */
    constructor(T = []) {
      e(Array.isArray(T)), this.ops = [], this.size = 0, this.index = -1, this.init(T);
    }
    static create(T) {
      const A = T ? T.join(":") : "", q = c[A];
      if (q)
        return q;
      const _ = new f(T);
      return c[A] = _, _;
    }
    init(T) {
      for (let A = 0; A < T.length; A++) {
        const q = T[A];
        if (e(typeof q == "string"), !m.hasOwnProperty(q))
          throw new Error(`Invalid type name: ${q}.`);
        const _ = m[q];
        _.dynamic ? this.index === -1 && (this.index = A) : this.size += _.size(), this.ops.push(_);
      }
    }
    getSize(T) {
      e(T.length === this.ops.length);
      let A = 1 + this.size;
      if (this.index === -1)
        return A;
      for (let q = this.index; q < T.length; q++) {
        const _ = this.ops[q], F = T[q];
        _.dynamic && (A += _.size(F));
      }
      return A;
    }
    encode(T, A) {
      if (e(Array.isArray(A)), A.length !== this.ops.length)
        throw new Error("Wrong number of arguments passed to key.");
      const q = this.getSize(A), _ = k.allocUnsafe(q);
      _[0] = T;
      let F = 1;
      for (let R = 0; R < this.ops.length; R++) {
        const L = this.ops[R], fe = A[R];
        F += L.write(_, fe, F);
      }
      return _;
    }
    decode(T, A) {
      if (e(k.isBuffer(A)), this.ops.length === 0)
        return A;
      if (A.length === 0 || A[0] !== T)
        throw new Error("Key prefix mismatch.");
      const q = [];
      let _ = 1;
      for (const F of this.ops) {
        const R = F.read(A, _);
        _ += F.size(R), q.push(R);
      }
      return q;
    }
    min(T, A) {
      for (let q = A.length; q < this.ops.length; q++) {
        const _ = this.ops[q];
        A.push(_.min);
      }
      return this.encode(T, A);
    }
    max(T, A) {
      for (let q = A.length; q < this.ops.length; q++) {
        const _ = this.ops[q];
        A.push(_.max);
      }
      return this.encode(T, A);
    }
    root(T) {
      const A = k.allocUnsafe(1);
      return A[0] = T, A;
    }
  }
  class n {
    /**
     * Create a key.
     * @constructor
     * @param {Number|String} id
     * @param {String[]|null} ops
     */
    constructor(T, A = []) {
      e(Array.isArray(A)), this.id = u(T), this.base = f.create(A);
    }
    encode(...T) {
      return this.base.encode(this.id, T);
    }
    decode(T) {
      return this.base.decode(this.id, T);
    }
    min(...T) {
      return this.base.min(this.id, T);
    }
    max(...T) {
      return this.base.max(this.id, T);
    }
    root() {
      return this.base.root(this.id);
    }
  }
  function u(N) {
    return typeof N == "string" && (e(N.length === 1), N = N.charCodeAt(0)), e((N & 255) === N), e(N !== 255), N;
  }
  function o(N, T) {
    return a(typeof N == "string"), 1 + k.byteLength(N, T);
  }
  function s(N, T, A) {
    return h(T + 1 <= N.length), h(T + 1 + N[T] <= N.length), N.toString(A, T + 1, T + 1 + N[T]);
  }
  function i(N, T, A, q) {
    a(typeof T == "string");
    const _ = k.byteLength(T, q);
    return a(_ <= 255), h(A + 1 <= N.length), N[A] = _, _ > 0 && a(N.write(T, A + 1, q) === _), 1 + _;
  }
  function p(N) {
    return a(k.isBuffer(N)), 1 + N.length;
  }
  function g(N, T) {
    return h(T + 1 <= N.length), h(T + 1 + N[T] <= N.length), N.slice(T + 1, T + 1 + N[T]);
  }
  function S(N, T, A, q) {
    return a(k.isBuffer(T)), h(T.length <= 255), h(A + 1 <= N.length), N[A] = T.length, h(T.copy(N, A + 1) === T.length), 1 + T.length;
  }
  function y(N) {
    return k.isBuffer(N) ? N.length : (a(typeof N == "string"), N.length >>> 1);
  }
  function b(N, T, A) {
    return k.isBuffer(T) ? T.copy(N, A) : (a(typeof T == "string"), N.write(T, A, "hex"));
  }
  function h(N) {
    if (!N) {
      const T = new RangeError("Invalid length for database key.");
      throw Error.captureStackTrace && Error.captureStackTrace(T, h), T;
    }
  }
  function a(N) {
    if (!N) {
      const T = new TypeError("Invalid type for database key.");
      throw Error.captureStackTrace && Error.captureStackTrace(T, a), T;
    }
  }
  function E(N, T) {
    return N[T++] * 16777216 + N[T++] * 65536 + N[T++] * 256 + N[T];
  }
  function H(N, T) {
    return N[T++] * 256 + N[T];
  }
  function j(N, T, A) {
    return N[A + 3] = T, T >>>= 8, N[A + 2] = T, T >>>= 8, N[A + 1] = T, T >>>= 8, N[A] = T, A + 4;
  }
  function G(N, T, A) {
    return N[A++] = T >>> 8, N[A++] = T, A;
  }
  return Sh = n, Sh;
}
/*!
 * rbt.js - red black tree for bcoin
 * Copyright (c) 2016-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var Eh, Ob;
function ky() {
  if (Ob) return Eh;
  Ob = 1;
  const e = Xe(), c = 0, l = 1;
  let w = null;
  class m {
    /**
     * Create a red black tree.
     * @constructor
     * @param {Function} compare - Comparator.
     * @param {Boolean?} unique
     */
    constructor(g, S) {
      e(typeof g == "function"), this.root = w, this.compare = g, this.unique = S || !1;
    }
    /**
     * Clear the tree.
     */
    reset() {
      this.root = w;
    }
    /**
     * Do a key lookup.
     * @param {Buffer|String} key
     * @returns {Buffer?} value
     */
    search(g) {
      let S = this.root;
      for (; !S.isNull(); ) {
        const y = this.compare(g, S.key);
        if (y === 0)
          return S;
        y < 0 ? S = S.left : S = S.right;
      }
      return null;
    }
    /**
     * Insert a record.
     * @param {Buffer|String} key
     * @param {Buffer} value
     */
    insert(g, S) {
      let y = this.root, b = !1, h;
      for (; !y.isNull(); ) {
        const E = this.compare(g, y.key);
        if (this.unique && E === 0)
          return y.key = g, y.value = S, y;
        h = y, E < 0 ? (b = !0, y = y.left) : (b = !1, y = y.right);
      }
      const a = new n(g, S);
      return h ? (a.parent = h, b ? h.left = a : h.right = a, this.insertFixup(a), a) : (this.root = a, this.insertFixup(a), a);
    }
    /**
     * Repaint necessary nodes after insertion.
     * @private
     * @param {RBTNode} x
     */
    insertFixup(g) {
      for (g.color = c; g !== this.root && g.parent.color === c; )
        if (g.parent === g.parent.parent.left) {
          const S = g.parent.parent.right;
          !S.isNull() && S.color === c ? (g.parent.color = l, S.color = l, g.parent.parent.color = c, g = g.parent.parent) : (g === g.parent.right && (g = g.parent, this.rotl(g)), g.parent.color = l, g.parent.parent.color = c, this.rotr(g.parent.parent));
        } else {
          const S = g.parent.parent.left;
          !S.isNull() && S.color === c ? (g.parent.color = l, S.color = l, g.parent.parent.color = c, g = g.parent.parent) : (g === g.parent.left && (g = g.parent, this.rotr(g)), g.parent.color = l, g.parent.parent.color = c, this.rotl(g.parent.parent));
        }
      this.root.color = l;
    }
    /**
     * Remove a record.
     * @param {Buffer|String} key
     * @returns {Boolean}
     */
    remove(g) {
      let S = this.root;
      for (; !S.isNull(); ) {
        const y = this.compare(g, S.key);
        if (y === 0)
          return this.removeNode(S), S;
        y < 0 ? S = S.left : S = S.right;
      }
      return null;
    }
    /**
     * Remove a single node.
     * @private
     * @param {RBTNode} z
     */
    removeNode(g) {
      let S = g;
      !g.left.isNull() && !g.right.isNull() && (S = this.successor(g));
      const y = S.left.isNull() ? S.right : S.left;
      y.parent = S.parent, S.parent.isNull() ? this.root = y : S === S.parent.left ? S.parent.left = y : S.parent.right = y, S !== g && (g.key = S.key, g.value = S.value), S.color === l && this.removeFixup(y);
    }
    /**
     * Repaint necessary nodes after removal.
     * @private
     * @param {RBTNode} x
     */
    removeFixup(g) {
      for (; g !== this.root && g.color === l; )
        if (g === g.parent.left) {
          let S = g.parent.right;
          S.color === c && (S.color = l, g.parent.color = c, this.rotl(g.parent), S = g.parent.right), S.left.color === l && S.right.color === l ? (S.color = c, g = g.parent) : (S.right.color === l && (S.left.color = l, S.color = c, this.rotr(S), S = g.parent.right), S.color = g.parent.color, g.parent.color = l, S.right.color = l, this.rotl(g.parent), g = this.root);
        } else {
          let S = g.parent.left;
          S.color === c && (S.color = l, g.parent.color = c, this.rotr(g.parent), S = g.parent.left), S.right.color === l && S.left.color === l ? (S.color = c, g = g.parent) : (S.left.color === l && (S.right.color = l, S.color = c, this.rotl(S), S = g.parent.left), S.color = g.parent.color, g.parent.color = l, S.left.color = l, this.rotr(g.parent), g = this.root);
        }
      g.color = l;
    }
    /**
     * Do a left rotate.
     * @private
     * @param {RBTNode} x
     */
    rotl(g) {
      const S = g.right;
      g.right = S.left, S.left.isNull() || (S.left.parent = g), S.parent = g.parent, g.parent.isNull() ? this.root = S : g === g.parent.left ? g.parent.left = S : g.parent.right = S, S.left = g, g.parent = S;
    }
    /**
     * Do a right rotate.
     * @private
     * @param {RBTNode} x
     */
    rotr(g) {
      const S = g.left;
      g.left = S.right, S.right.isNull() || (S.right.parent = g), S.parent = g.parent, g.parent.isNull() ? this.root = S : g === g.parent.right ? g.parent.right = S : g.parent.left = S, S.right = g, g.parent = S;
    }
    /**
     * Minimum subtree.
     * @private
     * @param {RBTNode} z
     * @returns {RBTNode}
     */
    min(g) {
      if (g.isNull())
        return g;
      for (; !g.left.isNull(); )
        g = g.left;
      return g;
    }
    /**
     * Maximum subtree.
     * @private
     * @param {RBTNode} z
     * @returns {RBTNode}
     */
    max(g) {
      if (g.isNull())
        return g;
      for (; !g.right.isNull(); )
        g = g.right;
      return g;
    }
    /**
     * Successor node.
     * @private
     * @param {RBTNode} x
     * @returns {RBTNode}
     */
    successor(g) {
      if (!g.right.isNull()) {
        for (g = g.right; !g.left.isNull(); )
          g = g.left;
        return g;
      }
      let S = g.parent;
      for (; !S.isNull() && g === S.right; )
        g = S, S = S.parent;
      return S;
    }
    /**
     * Predecessor node.
     * @private
     * @param {RBTNode} x
     * @returns {RBTNode}
     */
    predecessor(g) {
      if (!g.left.isNull()) {
        for (g = g.left; !g.right.isNull(); )
          g = g.right;
        return g;
      }
      let S = g.parent;
      for (; !S.isNull() && g === S.left; )
        g = S, S = S.parent;
      return S;
    }
    /**
     * Take a snapshot and return
     * a cloned root node (iterative).
     * @returns {RBTNode}
     */
    clone() {
      if (this.root.isNull())
        return w;
      const g = [];
      let S = this.root, y = !0, b, h;
      for (; ; ) {
        if (!S.isNull()) {
          const a = S.clone();
          b && (a.parent = b), y ? b ? b.left = a : h = a : b ? b.right = a : h = a, g.push(a), b = a, y = !0, S = S.left;
          continue;
        }
        if (g.length === 0)
          break;
        S = g.pop(), b = S, y = !1, S = S.right;
      }
      return e(h), h;
    }
    /**
     * Take a snapshot and return
     * a cloned root node (recursive).
     * @returns {RBTNode}
     */
    snapshot() {
      if (this.root.isNull())
        return w;
      const g = this.root.clone();
      return s(g, g.left), i(g, g.right), g;
    }
    /**
     * Create an iterator.
     * @param {RBTNode?} snapshot
     * @returns {RBTIterator}
     */
    iterator(g) {
      return new f(this, g || this.root);
    }
    /**
     * Traverse between a range of keys and collect records.
     * @param {Buffer} min
     * @param {Buffer} max
     * @returns {RBTNode[]} Records.
     */
    range(g, S) {
      const y = this.iterator(), b = [];
      for (g ? y.seekMin(g) : y.seekFirst(); y.next() && !(S && y.compare(S) > 0); )
        b.push(y.data());
      return b;
    }
  }
  class f {
    /**
     * Create an iterator.
     * @constructor
     * @param {RBT} tree
     * @param {RBTNode} snapshot
     * @property {RBT} tree
     * @property {RBTNode} current
     * @property {Object} key
     * @property {Object} value
     */
    constructor(g, S) {
      this.tree = g, this.root = S, this.current = S, this.key = null, this.value = null;
    }
    /**
     * Compare keys using tree's comparator.
     * @param {Object} key
     */
    compare(g) {
      return e(this.key != null, "No key."), this.tree.compare(this.key, g);
    }
    /**
     * Test whether current node is valid.
     */
    valid() {
      return !this.current.isNull();
    }
    /**
     * Seek to the root.
     */
    reset() {
      this.current = this.root, this.key = null, this.value = null;
    }
    /**
     * Seek to the start of the tree.
     */
    seekFirst() {
      this.current = this.tree.min(this.root), this.key = this.current.key, this.value = this.current.value;
    }
    /**
     * Seek to the end of the tree.
     */
    seekLast() {
      this.current = this.tree.max(this.root), this.key = this.current.key, this.value = this.current.value;
    }
    /**
     * Seek to a key from the current node (gte).
     * @param {String} key
     */
    seek(g) {
      return this.seekMin(g);
    }
    /**
     * Seek to a key from the current node (gte).
     * @param {String} key
     */
    seekMin(g) {
      e(g != null, "No key passed to seek.");
      let S = this.current, y = w;
      for (; !S.isNull(); ) {
        const b = this.tree.compare(S.key, g);
        if (b === 0) {
          y = S;
          break;
        }
        b > 0 ? (y = S, S = S.left) : S = S.right;
      }
      this.current = y, this.key = y.key, this.value = y.value;
    }
    /**
     * Seek to a key from the current node (lte).
     * @param {String} key
     */
    seekMax(g) {
      e(g != null, "No key passed to seek.");
      let S = this.current, y = w;
      for (; !S.isNull(); ) {
        const b = this.tree.compare(S.key, g);
        if (b === 0) {
          y = S;
          break;
        }
        b < 0 ? (y = S, S = S.right) : S = S.left;
      }
      this.current = y, this.key = y.key, this.value = y.value;
    }
    /**
     * Seek to previous node.
     * @param {String} key
     */
    prev() {
      return this.current.isNull() ? (this.key = null, this.value = null, !1) : (this.key = this.current.key, this.value = this.current.value, this.current = this.tree.predecessor(this.current), !0);
    }
    /**
     * Seek to next node.
     * @returns {Boolean}
     */
    next() {
      return this.current.isNull() ? (this.key = null, this.value = null, !1) : (this.key = this.current.key, this.value = this.current.value, this.current = this.tree.successor(this.current), !0);
    }
    /**
     * Return the current key/value pair.
     * @returns {RBTData}
     */
    data() {
      return e(this.key != null, "No data available."), new o(this.key, this.value);
    }
  }
  class n {
    /**
     * Create an RBT node.
     * @constructor
     * @param {Buffer} key
     * @param {Buffer} value
     * @property {Buffer} key
     * @property {Buffer} value
     * @property {Number} color
     * @property {RBTNode|RBTSentinel} parent
     * @property {RBTNode|RBTSentinel} left
     * @property {RBTNode|RBTSentinel} right
     */
    constructor(g, S) {
      this.key = g, this.value = S, this.color = c, this.parent = w, this.left = w, this.right = w;
    }
    /**
     * Clone the node.
     * @returns {RBTNode}
     */
    clone() {
      const g = new n(this.key, this.value);
      return g.color = this.color, g.parent = this.parent, g.left = this.left, g.right = this.right, g;
    }
    /**
     * Clone the node (key/value only).
     * @returns {RBTData}
     */
    copy() {
      return new o(this.key, this.value);
    }
    /**
     * Inspect the rbt node.
     * @returns {Object}
     */
    inspect() {
      return {
        key: this.key,
        value: this.value,
        color: this.color === c ? "red" : "black",
        left: this.left,
        right: this.right
      };
    }
    /**
     * Test whether the node is a leaf.
     * Always returns false.
     * @returns {Boolean}
     */
    isNull() {
      return !1;
    }
  }
  class u {
    /**
     * Create an RBT Sentinel Node.
     * @constructor
     * @property {null} key
     * @property {null} value
     * @property {Number} [color=BLACK]
     * @property {null} parent
     * @property {null} left
     * @property {null} right
     */
    constructor() {
      this.key = null, this.value = null, this.color = l, this.parent = null, this.left = null, this.right = null;
    }
    /**
     * Inspect the rbt node.
     * @returns {String}
     */
    inspect() {
      return "NIL";
    }
    /**
     * Test whether the node is a leaf.
     * Always returns true.
     * @returns {Boolean}
     */
    isNull() {
      return !0;
    }
  }
  class o {
    /**
     * Create an RBT key/value pair.
     * @constructor
     * @param {Buffer} key
     * @param {Buffer} value
     * @property {Buffer} key
     * @property {Buffer} value
     */
    constructor(g, S) {
      this.key = g, this.value = S;
    }
  }
  w = new u();
  function s(p, g) {
    g.isNull() || (p.left = g.clone(), p.left.parent = p, s(p.left, g.left), i(p.left, g.right));
  }
  function i(p, g) {
    g.isNull() || (p.right = g.clone(), p.right.parent = p, s(p.right, g.left), i(p.right, g.right));
  }
  return Eh = m, Eh;
}
var Ih, _b;
function By() {
  if (_b) return Ih;
  _b = 1;
  const e = Xe(), c = ky(), l = k.alloc(0);
  class w {
    /**
     * Create a memdb.
     * @constructor
     * @param {String?} location - Phony location.
     * @param {Object?} options
     * @param {Function} options.compare - Comparator.
     */
    constructor(i) {
      this.location = i || "memory", this.options = {}, this.tree = new c(o, !0);
    }
    /**
     * Do a key lookup.
     * @private
     * @param {Buffer|String} key
     * @returns {Buffer?} value
     */
    search(i) {
      typeof i == "string" && (i = k.from(i, "utf8")), e(k.isBuffer(i), "Key must be a Buffer.");
      const p = this.tree.search(i);
      if (p)
        return p.value;
    }
    /**
     * Insert a record.
     * @private
     * @param {Buffer|String} key
     * @param {Buffer} value
     */
    insert(i, p) {
      return typeof i == "string" && (i = k.from(i, "utf8")), typeof p == "string" && (p = k.from(p, "utf8")), p == null && (p = l), e(k.isBuffer(i), "Key must be a Buffer."), e(k.isBuffer(p), "Value must be a Buffer."), this.tree.insert(i, p) != null;
    }
    /**
     * Remove a record.
     * @private
     * @param {Buffer|String} key
     * @returns {Boolean}
     */
    remove(i) {
      return typeof i == "string" && (i = k.from(i, "utf8")), e(k.isBuffer(i), "Key must be a Buffer."), this.tree.remove(i) != null;
    }
    /**
     * Traverse between a range of keys and collect records.
     * @private
     * @param {Buffer} min
     * @param {Buffer} max
     * @returns {RBTData[]} Records.
     */
    range(i, p) {
      return typeof i == "string" && (i = k.from(i, "utf8")), typeof p == "string" && (p = k.from(p, "utf8")), e(!i || k.isBuffer(i), "Key must be a Buffer."), e(!p || k.isBuffer(p), "Key must be a Buffer."), this.tree.range(i, p);
    }
    /**
     * Open the database (leveldown method).
     * @param {Object?} options
     * @param {Function} callback
     */
    open(i, p) {
      p || (p = i, i = null), i || (i = {}), this.options = i, setImmediate(p);
    }
    /**
     * Close the database (leveldown method).
     * @param {Function} callback
     */
    close(i) {
      setImmediate(i);
    }
    /**
     * Retrieve a record (leveldown method).
     * @param {Buffer|String} key
     * @param {Object?} options
     * @param {Function} callback - Returns Buffer.
     */
    get(i, p, g) {
      g || (g = p, p = null), p || (p = {});
      let S = this.search(i);
      if (!S) {
        const y = new Error("MEMDB_NOTFOUND: Key not found.");
        y.notFound = !0, y.type = "NotFoundError", setImmediate(() => g(y));
        return;
      }
      p.asBuffer === !1 && (S = S.toString("utf8")), setImmediate(() => g(null, S));
    }
    /**
     * Insert a record (leveldown method).
     * @param {Buffer|String} key
     * @param {Buffer} value
     * @param {Object?} options
     * @param {Function} callback
     */
    put(i, p, g, S) {
      S || (S = g, g = null), this.insert(i, p), setImmediate(S);
    }
    /**
     * Remove a record (leveldown method).
     * @param {Buffer|String} key
     * @param {Object?} options
     * @param {Function} callback
     */
    del(i, p, g) {
      g || (g = p, p = null), this.remove(i), setImmediate(g);
    }
    /**
     * Create an atomic batch (leveldown method).
     * @see Leveldown.Batch
     * @param {Object[]?} ops
     * @param {Object?} options
     * @param {Function} callback
     */
    batch(i, p, g) {
      g || (g = p, p = null);
      const S = new m(this, p);
      if (i) {
        S.ops = i, S.write(g);
        return;
      }
      return S;
    }
    /**
     * Create an iterator (leveldown method).
     * @param {Object} options - See {Leveldown.Iterator}.
     * @returns {Leveldown.Iterator}.
     */
    iterator(i) {
      return new n(this, i);
    }
    /**
     * Get a database property (leveldown method) (NOP).
     * @param {String} name - Property name.
     * @returns {String}
     */
    getProperty(i) {
      return "";
    }
    /**
     * Calculate approximate database size (leveldown method).
     * @param {Buffer|String} start - Start key.
     * @param {Buffer|String} end - End key.
     * @param {Function} callback - Returns Number.
     */
    approximateSize(i, p, g) {
      const S = this.range(i, p);
      let y = 0;
      for (const b of S)
        y += b.key.length, y += b.value.length;
      setImmediate(() => g(null, y));
    }
    /**
     * Destroy the database (leveldown function) (NOP).
     * @param {String} location
     * @param {Function} callback
     */
    static destroy(i, p) {
      setImmediate(p);
    }
    /**
     * Repair the database (leveldown function) (NOP).
     * @param {String} location
     * @param {Function} callback
     */
    static repair(i, p) {
      setImmediate(p);
    }
  }
  class m {
    /**
     * Create a batch.
     * @constructor
     * @ignore
     * @param {MemDB} db
     * @param {Object?} options
     */
    constructor(i, p) {
      this.options = p || {}, this.ops = [], this.db = i, this.written = !1;
    }
    /**
     * Insert a record.
     * @param {Buffer|String} key
     * @param {Buffer} value
     */
    put(i, p) {
      return e(!this.written, "Already written."), this.ops.push(new f("put", i, p)), this;
    }
    /**
     * Remove a record.
     * @param {Buffer|String} key
     */
    del(i) {
      return e(!this.written, "Already written."), this.ops.push(new f("del", i)), this;
    }
    /**
     * Commit the batch.
     * @param {Function} callback
     */
    write(i) {
      if (this.written)
        return setImmediate(() => i(new Error("Already written."))), this;
      for (const p of this.ops)
        switch (p.type) {
          case "put":
            this.db.insert(p.key, p.value);
            break;
          case "del":
            this.db.remove(p.key);
            break;
          default:
            return setImmediate(() => i(new Error("Bad op."))), this;
        }
      return this.ops = [], this.written = !0, setImmediate(i), this;
    }
    /**
     * Clear batch of all ops.
     */
    clear() {
      return e(!this.written, "Already written."), this.ops = [], this;
    }
  }
  class f {
    /**
     * Create a batch op.
     * @constructor
     * @ignore
     * @param {String} type
     * @param {Buffer} key
     * @param {Buffer|null} value
     */
    constructor(i, p, g) {
      this.type = i, this.key = p, this.value = g;
    }
  }
  class n {
    /**
     * Create an iterator.
     * @constructor
     * @ignore
     * @param {RBT} db
     * @param {Object?} options
     */
    constructor(i, p) {
      this.db = i, this.options = new u(p), this.iter = null, this.ended = !1, this.total = 0, this.init();
    }
    /**
     * Initialize the iterator.
     */
    init() {
      const i = this.db.tree.snapshot(), p = this.db.tree.iterator(i);
      this.options.reverse ? this.options.end ? (p.seekMax(this.options.end), this.options.lt && p.valid() && p.compare(this.options.end) === 0 && p.prev()) : p.seekLast() : this.options.start ? (p.seekMin(this.options.start), this.options.gt && p.valid() && p.compare(this.options.start) === 0 && p.next()) : p.seekFirst(), this.iter = p;
    }
    /**
     * Seek to the next key.
     * @param {Function} callback
     */
    next(i) {
      const p = this.options, g = this.iter;
      if (!this.iter) {
        setImmediate(() => i(new Error("Cannot call next.")));
        return;
      }
      let S;
      if (p.reverse ? (S = g.prev(), S && p.start && (p.gt ? g.compare(p.start) <= 0 && (S = !1) : g.compare(p.start) < 0 && (S = !1))) : (S = g.next(), S && p.end && (p.lt ? g.compare(p.end) >= 0 && (S = !1) : g.compare(p.end) > 0 && (S = !1))), !S) {
        this.iter = null, setImmediate(i);
        return;
      }
      if (p.limit !== -1) {
        if (this.total >= p.limit) {
          this.iter = null, setImmediate(i);
          return;
        }
        this.total += 1;
      }
      let y = g.key, b = g.value;
      p.keys || (y = l), p.values || (b = l), p.keyAsBuffer || (y = y.toString("utf8")), p.valueAsBuffer || (b = b.toString("utf8")), setImmediate(() => i(null, y, b));
    }
    /**
     * Seek to a key gte to `key`.
     * @param {String|Buffer} key
     */
    seek(i) {
      e(this.iter, "Already ended."), typeof i == "string" && (i = k.from(i, "utf8")), e(k.isBuffer(i), "Key must be a Buffer."), this.options.reverse ? this.iter.seekMax(i) : this.iter.seekMin(i);
    }
    /**
     * End the iterator. Free up snapshot.
     * @param {Function} callback
     */
    end(i) {
      if (this.ended) {
        setImmediate(() => i(new Error("Already ended.")));
        return;
      }
      this.ended = !0, this.iter = null, setImmediate(i);
    }
  }
  class u {
    /**
     * Create iterator options.
     * @constructor
     * @ignore
     * @param {Object} options
     */
    constructor(i) {
      this.keys = !0, this.values = !0, this.start = null, this.end = null, this.gt = !1, this.lt = !1, this.keyAsBuffer = !0, this.valueAsBuffer = !0, this.reverse = !1, this.limit = -1, i && this.fromOptions(i);
    }
    /**
     * Inject properties from options.
     * @private
     * @param {Object} options
     * @returns {IteratorOptions}
     */
    fromOptions(i) {
      return i.keys != null && (e(typeof i.keys == "boolean"), this.keys = i.keys), i.values != null && (e(typeof i.values == "boolean"), this.values = i.values), i.start != null && (this.start = i.start), i.end != null && (this.end = i.end), i.gte != null && (this.start = i.gte), i.lte != null && (this.end = i.lte), i.gt != null && (this.gt = !0, this.start = i.gt), i.lt != null && (this.lt = !0, this.end = i.lt), this.start != null && (typeof this.start == "string" && (this.start = k.from(this.start, "utf8")), e(k.isBuffer(this.start), "`start` must be a Buffer.")), this.end != null && (typeof this.end == "string" && (this.end = k.from(this.end, "utf8")), e(k.isBuffer(this.end), "`end` must be a Buffer.")), i.keyAsBuffer != null && (e(typeof i.keyAsBuffer == "boolean"), this.keyAsBuffer = i.keyAsBuffer), i.valueAsBuffer != null && (e(typeof i.valueAsBuffer == "boolean"), this.valueAsBuffer = i.valueAsBuffer), i.reverse != null && (e(typeof i.reverse == "boolean"), this.reverse = i.reverse), i.limit != null && (e(typeof i.limit == "number"), this.limit = i.limit), this;
    }
  }
  function o(s, i) {
    return s.compare(i);
  }
  return Ih = w, Ih;
}
var Ah, Rb;
function My() {
  if (Rb) return Ah;
  Rb = 1;
  const e = Xe(), c = Ft.indexedDB || Ft.webkitIndexedDB || Ft.mozIndexedDB || Ft.shimIndexedDB, l = Ft.IDBKeyRange || Ft.webkitIDBKeyRange || Ft.mozIDBKeyRange, w = {
    READ_ONLY: "readonly",
    READ_WRITE: "readwrite",
    NEXT: "next",
    PREV: "prev"
  };
  class m {
    constructor(S) {
      e(typeof S == "string"), this.options = {}, this.version = 1, this.name = `bdb-${S}`, this.location = S, this.db = null, this.store = null;
    }
    transaction(S) {
      return this.db.transaction([this.location], S);
    }
    open(S, y) {
      y || (y = S, S = null), S || (S = {}), this.options = S;
      const b = c.open(this.name, this.version);
      return b.onerror = p(y), b.onsuccess = (h) => {
        if (this.db) {
          y();
          return;
        }
        if (this.db = h.target.result, typeof this.db.version == "string") {
          y(new Error("IndexedDB is out of date."));
          return;
        }
        if (!this.db.objectStoreNames.contains(this.location)) {
          y(new Error("Could not create object store."));
          return;
        }
        const a = this.transaction(w.READ_ONLY);
        this.store = a.objectStore(this.location), y();
      }, b.onupgradeneeded = (h) => {
        if (this.db = h.target.result, this.db.objectStoreNames.contains(this.location)) {
          this.store = h.target.transaction.objectStore(this.location);
          return;
        }
        this.store = this.db.createObjectStore(this.location, {
          autoIncrement: !1
        });
      }, this;
    }
    close(S) {
      return this.db.close(), S(), this;
    }
    put(S, y, b) {
      const h = p(b), a = this.transaction(w.READ_WRITE);
      let E = !1;
      a.oncomplete = () => {
        if (!E) {
          b(new Error("Operation failed."));
          return;
        }
        b();
      }, a.onabort = h, a.onerror = h;
      const H = a.objectStore(this.location).put(y, s(S));
      return H.onsuccess = (j) => {
        E = !0;
      }, H.onerror = h, this;
    }
    get(S, y, b) {
      b || (b = y, y = null), y || (y = {});
      const h = p(b), a = this.transaction(w.READ_ONLY);
      let E = !1, H = null;
      a.oncomplete = () => {
        if (!E) {
          b(new Error("Operation failed."));
          return;
        }
        if (H === void 0) {
          const G = new Error("IDB_NOTFOUND: Key not found.");
          G.notFound = !0, G.type = "NotFoundError", b(G);
          return;
        }
        H && !k.isBuffer(H) && H.buffer && (H = k.from(H.buffer)), y.asBuffer === !1 && (H = H.toString("utf8")), b(null, H);
      }, a.onabort = h, a.onerror = h;
      const j = a.objectStore(this.location).get(s(S));
      return j.onsuccess = function(G) {
        E = !0, H = G.target.result;
      }, j.onerror = h, this;
    }
    del(S, y) {
      const b = p(y), h = this.transaction(w.READ_WRITE);
      let a = !1;
      h.oncomplete = () => {
        if (!a) {
          y(new Error("Operation failed."));
          return;
        }
        y();
      }, h.onabort = b, h.onerror = b;
      const E = h.objectStore(this.location).delete(s(S));
      return E.onsuccess = (H) => {
        a = !0;
      }, E.onerror = b, this;
    }
    batch(S, y, b) {
      b || (b = y, y = null);
      const h = new f(this, y);
      if (S) {
        h.ops = S, h.write(b);
        return;
      }
      return h;
    }
    iterator(S) {
      return new u(this, S);
    }
    static destroy(S, y) {
      if (!c.deleteDatabase) {
        y(new Error("Destroy not supported."));
        return;
      }
      const b = c.deleteDatabase(`bdb-${S}`);
      b.onsuccess = () => y(), b.onerror = p(y);
    }
  }
  class f {
    /**
     * Create a batch.
     * @constructor
     * @ignore
     * @param {Level} db
     * @param {Object?} options
     */
    constructor(S, y) {
      this.db = S, this.options = y || {}, this.ops = [], this.written = !1;
    }
    /**
     * Insert a record.
     * @param {Buffer|String} key
     * @param {Buffer} value
     */
    put(S, y) {
      return e(!this.written, "Already written."), this.ops.push(new n("put", S, y)), this;
    }
    /**
     * Remove a record.
     * @param {Buffer|String} key
     */
    del(S) {
      return e(!this.written, "Already written."), this.ops.push(new n("del", S)), this;
    }
    /**
     * Commit the batch.
     * @param {Function} callback
     */
    write(S) {
      if (this.written)
        return S(new Error("Already written.")), this;
      const y = p(S), b = this.db.transaction(w.READ_WRITE);
      let h = this.ops.length, a = !1, E = !1;
      b.oncomplete = () => {
        if (!E) {
          S(new Error("Operation failed."));
          return;
        }
        S();
      }, b.onabort = y, b.onerror = y;
      const H = () => {
        h -= 1, h === 0 && !a && (a = !0, E = !0);
      }, j = (G) => {
        b.abort(), a || (a = !0, y(G));
      };
      for (const { type: G, key: N, value: T } of this.ops) {
        const A = b.objectStore(this.db.location);
        switch (G) {
          case "put": {
            const q = A.put(T, s(N));
            q.onsuccess = H, q.onerror = j;
            break;
          }
          case "del": {
            const q = A.delete(s(N));
            q.onsuccess = H, q.onerror = j;
            break;
          }
          default:
            return S(new Error("Bad op type.")), this;
        }
      }
      return this;
    }
    /**
     * Clear batch of all ops.
     */
    clear() {
      return e(!this.written, "Already written."), this.ops = [], this;
    }
  }
  class n {
    /**
     * Create a batch op.
     * @constructor
     * @ignore
     * @param {String} type
     * @param {Buffer} key
     * @param {Buffer|null} value
     */
    constructor(S, y, b) {
      this.type = S, this.key = y, this.value = b;
    }
  }
  class u {
    constructor(S, y) {
      this.db = S, this.options = new o(y), this.cursor = null, this.error = null, this.started = !1, this.ended = !1, this.callback = null;
    }
    seek(S) {
      throw new Error("Not implemented.");
    }
    next(S) {
      if (this.ended) {
        S(new Error("Iterator already ended."));
        return;
      }
      if (this.callback) {
        S(new Error("Callback already pending."));
        return;
      }
      if (this.error) {
        S(this.error);
        return;
      }
      if (!this.started) {
        this.callback = S, this.start();
        return;
      }
      e(this.cursor), this.callback = S, this.cursor.continue(), this.cursor = null;
    }
    end(S) {
      if (this.ended) {
        S(new Error("Iterator already ended."));
        return;
      }
      this.ended = !0, S();
    }
    start() {
      if (this.started)
        return;
      const S = this.options, y = this.db.transaction(w.READ_ONLY), b = y.objectStore(this.db.location);
      let h = !1, a = 0;
      y.oncomplete = () => {
        if (!h && !this.error && (this.error = new Error("Iterator ended early.")), this.error) {
          this.respond(this.error);
          return;
        }
        this.respond(null, void 0, void 0);
      };
      const E = (A) => {
        this.error = i(A), this.respond(this.error);
      };
      y.onabort = E, y.onerror = E;
      const H = s(S.start), j = s(S.end);
      let G = null;
      H && j ? G = l.bound(H, j, S.gt, S.lt) : H ? G = l.lowerBound(H, S.gt) : j ? G = l.upperBound(j, S.lt) : G = l.lowerBound("\0", !0);
      const N = S.reverse ? w.PREV : w.NEXT, T = b.openCursor(G, N);
      T.onerror = E, T.onsuccess = (A) => {
        const q = A.target.result;
        if (this.error) {
          this.respond(this.error);
          return;
        }
        if (!q) {
          h = !0;
          return;
        }
        if (S.limit !== -1) {
          if (a >= S.limit) {
            h = !0;
            return;
          }
          a += 1;
        }
        let _ = k.from(q.key, "hex"), F = q.value;
        F && !k.isBuffer(F) && F.buffer && (F = k.from(F.buffer)), S.keyAsBuffer || (_ = _.toString("utf8")), S.valueAsBuffer || (F = F.toString("utf8")), this.cursor = q, this.respond(null, _, F);
      }, this.started = !0;
    }
    respond(S, y, b) {
      if (!this.callback)
        return;
      const h = this.callback;
      this.callback = null, h(S, y, b);
    }
  }
  class o {
    /**
     * Create iterator options.
     * @constructor
     * @ignore
     * @param {Object} options
     */
    constructor(S) {
      this.keys = !0, this.values = !0, this.start = null, this.end = null, this.gt = !1, this.lt = !1, this.keyAsBuffer = !0, this.valueAsBuffer = !0, this.reverse = !1, this.limit = -1, S && this.fromOptions(S);
    }
    /**
     * Inject properties from options.
     * @private
     * @param {Object} options
     * @returns {IteratorOptions}
     */
    fromOptions(S) {
      return S.keys != null && (e(typeof S.keys == "boolean"), this.keys = S.keys), S.values != null && (e(typeof S.values == "boolean"), this.values = S.values), S.start != null && (this.start = S.start), S.end != null && (this.end = S.end), S.gte != null && (this.start = S.gte), S.lte != null && (this.end = S.lte), S.gt != null && (this.gt = !0, this.start = S.gt), S.lt != null && (this.lt = !0, this.end = S.lt), this.start != null && (typeof this.start == "string" && (this.start = k.from(this.start, "utf8")), e(k.isBuffer(this.start), "`start` must be a Buffer.")), this.end != null && (typeof this.end == "string" && (this.end = k.from(this.end, "utf8")), e(k.isBuffer(this.end), "`end` must be a Buffer.")), S.keyAsBuffer != null && (e(typeof S.keyAsBuffer == "boolean"), this.keyAsBuffer = S.keyAsBuffer), S.valueAsBuffer != null && (e(typeof S.valueAsBuffer == "boolean"), this.valueAsBuffer = S.valueAsBuffer), S.reverse != null && (e(typeof S.reverse == "boolean"), this.reverse = S.reverse), S.limit != null && (e(typeof S.limit == "number"), this.limit = S.limit), this;
    }
  }
  function s(g) {
    return g == null ? g : (typeof g == "string" && (g = k.from(g, "utf8")), e(k.isBuffer(g)), g.toString("hex"));
  }
  function i(g) {
    if (!g)
      return new Error("Unknown IndexedDB error (no event).");
    if (g instanceof Error)
      return g;
    const { target: S } = g;
    if (!S)
      return new Error("Unknown IndexedDB error (no target).");
    if (S.error) {
      const { error: y } = S;
      return y instanceof Error ? y : y.name === "VersionError" ? new Error("IndexedDB version error.") : new Error(String(y));
    }
    return S.errorCode != null ? S.errorCode === 12 ? new Error("IndexedDB version error.") : new Error(`IndexedDB error: ${S.errorCode}.`) : new Error("Unknown IndexedDB error (no error).");
  }
  function p(g) {
    return (S) => g(i(S));
  }
  return Ah = m, Ah;
}
var Pb;
function Up() {
  if (Pb) return nn;
  Pb = 1;
  const e = Xe(), c = Ry(), l = Py(), w = By(), m = My();
  return nn.DB = c, nn.Key = l, nn.create = (f) => {
    f == null && (f = {}), typeof f == "string" && (f = { location: f }), e(f && typeof f == "object");
    const { memory: n, location: u } = f;
    return n ? new c(w, "memory", f) : new c(m, u, f);
  }, nn.key = (f, n) => new l(f, n), nn;
}
var Oh, kb;
function Ny() {
  return kb || (kb = 1, Oh = function(c) {
    if (c === void 0)
      return "undefined";
    if (c !== c)
      return "NaN";
    try {
      return JSON.stringify(c, null, 2);
    } catch {
      return "{}";
    }
  }), Oh;
}
var _h, Bb;
function qy() {
  if (Bb) return _h;
  Bb = 1;
  const e = Ny(), c = {
    showHidden: !1,
    depth: 20,
    colors: !1,
    customInspect: !0,
    showProxy: !1,
    maxArrayLength: 1e4,
    breakLength: 60,
    compact: !0
  };
  function l(o, s) {
    if (o.length === 0)
      return "";
    const i = o[0];
    if (c.colors = s, typeof i != "string")
      return e(i, c);
    if (o.length === 1)
      return i;
    let p = "", g = 1, S = 0, y;
    for (let b = 0; b < i.length - 1; b++) {
      if (i.charCodeAt(b) !== 37)
        continue;
      const h = i.charCodeAt(++b);
      if (g !== o.length) {
        switch (h) {
          case 115:
            y = String(o[g++]);
            break;
          case 106:
            y = w(o[g++]);
            break;
          case 100:
            y = n(o[g++]);
            break;
          case 79:
          // 'O'
          case 111:
            y = e(o[g++], c);
            break;
          case 105:
            y = u(o[g++]);
            break;
          case 102:
            y = `${parseFloat(o[g++])}`;
            break;
          case 120:
            y = m(o[g++], !1);
            break;
          case 104:
            y = m(o[g++], !0);
            break;
          case 37:
            p += i.slice(S, b), S = b + 1;
            continue;
          default:
            continue;
        }
        S !== b - 1 && (p += i.slice(S, b - 1)), p += y, S = b + 1;
      } else h === 37 && (p += i.slice(S, b), S = b + 1);
    }
    for (S === 0 ? p = i : S < i.length && (p += i.slice(S)); g < o.length; ) {
      const b = o[g++];
      typeof b != "object" && typeof b != "symbol" || b === null ? p += ` ${b}` : p += ` ${e(b, c)}`;
    }
    return p;
  }
  function w(o) {
    try {
      return JSON.stringify(o);
    } catch {
      return "[error]";
    }
  }
  function m(o, s) {
    if (o == null)
      return "null";
    if (!k.isBuffer(o)) {
      let p = (o >>> 0).toString(16);
      for (; p.length < 8; )
        p = "0" + p;
      return s && (p = f(p)), `0x${p}`;
    }
    const i = o.toString("hex");
    return s ? f(i) : i;
  }
  function f(o) {
    let s = "";
    for (let i = o.length - 2; i >= 0; i -= 2)
      s += o[i] + o[i + 1];
    return s;
  }
  function n(o) {
    return typeof o == "bigint" ? `${o}n` : `${Number(o)}`;
  }
  function u(o) {
    return typeof o == "bigint" ? `${o}n` : `${parseInt(o)}`;
  }
  return _h = l, _h;
}
var Rh = {}, Mb;
function Ty() {
  return Mb || (Mb = 1, Rh.unsupported = !0), Rh;
}
var Ph, Nb;
function zy() {
  if (Nb) return Ph;
  Nb = 1;
  const e = Cp(), c = Xe(), l = qy(), w = Ty();
  class m {
    /**
     * Create a logger.
     * @constructor
     * @param {(String|Object)?} options/level
     * @param {String?} options.level
     * @param {Boolean} [options.colors=true]
     */
    constructor(p) {
      this.level = m.levels.NONE, this.colors = m.HAS_TTY, this.maxFileSize = m.MAX_FILE_SIZE, this.maxFiles = m.MAX_ARCHIVAL_FILES, this.console = !0, this.closed = !0, this.closing = !1, this.filename = null, this.stream = null, this.contexts = /* @__PURE__ */ Object.create(null), this.fmt = l, this.rotating = !1, this._fileSize = 0, this._buffer = [], p && this.set(p);
    }
    /**
     * Set logger options.
     * @param {Object} options
     */
    set(p) {
      if (c(p), c(this.closed), typeof p == "string") {
        this.setLevel(p);
        return;
      }
      p.level != null && (c(typeof p.level == "string"), this.setLevel(p.level)), p.colors != null && m.HAS_TTY && (c(typeof p.colors == "boolean"), this.colors = p.colors), p.console != null && (c(typeof p.console == "boolean"), this.console = p.console), p.filename != null && (c(typeof p.filename == "string", "Bad file."), this.filename = p.filename), p.maxFileSize != null && (c(p.maxFileSize >>> 0 === p.maxFileSize), this.maxFileSize = p.maxFileSize), p.maxFiles != null && (c(p.maxFiles >>> 0 === p.maxFiles), this.maxFiles = p.maxFiles);
    }
    /**
     * Open the logger.
     * @method
     * @returns {Promise}
     */
    async open() {
      if (!this.filename) {
        this.closed = !1;
        return;
      }
      if (this.stream) {
        this.closed = !1;
        return;
      }
      if (w.unsupported) {
        this.closed = !1;
        return;
      }
      this._fileSize = await this.getSize(), this.stream = await u(this.filename), this.stream.once("error", this.handleError.bind(this)), this.closed = !1;
    }
    /**
     * Destroy the write stream.
     * @method
     * @returns {Promise}
     */
    async close() {
      if (this.timer != null && (clearTimeout(this.timer), this.timer = null), w.unsupported) {
        this.closed = !0, this.stream = null;
        return;
      }
      if (this.stream) {
        try {
          this.closing = !0, await o(this.stream);
        } finally {
          this.closing = !1;
        }
        this.stream = null;
      }
      this._fileSize = 0, this.closed = !0;
    }
    /**
     * Rotate out the current log file.
     * @method
     * @private
     * @returns {Promise} - Returns String
     */
    async rotate() {
      if (this.rotating || !this.filename || w.unsupported)
        return null;
      this.rotating = !0, await this.close();
      const p = e.extname(this.filename), g = e.basename(this.filename, p), S = e.dirname(this.filename), y = e.join(S, g + "_" + s() + p);
      for (await w.rename(this.filename, y), await this.open(); this._buffer.length > 0; ) {
        const b = this._buffer.shift();
        this.stream.write(b), this._fileSize += b.length;
      }
      return this.rotating = !1, this.prune(S, g, p), y;
    }
    /**
     * Remove old log files
     * @method
     * @private
     * @param {String} dir
     * @param {String} base
     * @param {String} ext
     * @returns {Promise} - Returns Number
     */
    async prune(p, g, S) {
      const y = await w.readdir(p), b = new RegExp(`${g}_.*${S}`), h = y.filter((E) => b.test(E));
      if (h.length <= this.maxFiles)
        return;
      h.sort();
      const a = h.slice(0, -1 * this.maxFiles);
      for (const E of a)
        await w.unlink(e.join(p, E));
    }
    /**
     * Get the size of the current log file in bytes.
     * @method
     * @private
     * @returns {Promise} - Returns Number
     */
    async getSize() {
      try {
        return (await w.stat(this.filename)).size;
      } catch (p) {
        if (p.code === "ENOENT")
          return 0;
        throw p;
      }
    }
    /**
     * Handle write stream error.
     * @param {Error} err
     */
    handleError(p) {
      try {
        this.stream.close();
      } catch {
      }
      this.stream = null, this.retry();
    }
    /**
     * Try to reopen the logger.
     * @method
     * @private
     * @returns {Promise}
     */
    async reopen() {
      if (!this.stream && !this.closed && !w.unsupported) {
        try {
          this.stream = await u(this.filename);
        } catch {
          this.retry();
          return;
        }
        this.stream.once("error", (p) => this.handleError(p));
      }
    }
    /**
     * Try to reopen the logger after a timeout.
     * @method
     * @private
     * @returns {Promise}
     */
    retry() {
      this.timer == null && (this.timer = setTimeout(() => {
        this.timer = null, this.reopen();
      }, 1e4));
    }
    /**
     * Set the log file location.
     * @param {String} filename
     */
    setFile(p) {
      c(typeof p == "string"), c(!this.stream, "Log stream has already been created."), this.filename = p;
    }
    /**
     * Set or reset the log level.
     * @param {String} level
     */
    setLevel(p) {
      const g = m.levels[p.toUpperCase()];
      c(g != null, "Invalid log level."), this.level = g;
    }
    /**
     * Output a log to the `error` log level.
     * @param {String|Object|Error} err
     * @param {...Object} args
     */
    error(...p) {
      if (this.level < m.levels.ERROR)
        return;
      const g = p[0];
      if (g instanceof Error) {
        this.logError(m.levels.ERROR, null, g);
        return;
      }
      this.log(m.levels.ERROR, null, p);
    }
    /**
     * Output a log to the `warning` log level.
     * @param {String|Object} obj
     * @param {...Object} args
     */
    warning(...p) {
      if (this.level < m.levels.WARNING)
        return;
      const g = p[0];
      if (g instanceof Error) {
        this.logError(m.levels.WARNING, null, g);
        return;
      }
      this.log(m.levels.WARNING, null, p);
    }
    /**
     * Output a log to the `info` log level.
     * @param {String|Object} obj
     * @param {...Object} args
     */
    info(...p) {
      if (this.level < m.levels.INFO)
        return;
      const g = p[0];
      if (g instanceof Error) {
        this.logError(m.levels.INFO, null, g);
        return;
      }
      this.log(m.levels.INFO, null, p);
    }
    /**
     * Output a log to the `debug` log level.
     * @param {String|Object} obj
     * @param {...Object} args
     */
    debug(...p) {
      if (this.level < m.levels.DEBUG)
        return;
      const g = p[0];
      if (g instanceof Error) {
        this.logError(m.levels.DEBUG, null, g);
        return;
      }
      this.log(m.levels.DEBUG, null, p);
    }
    /**
     * Output a log to the `spam` log level.
     * @param {String|Object} obj
     * @param {...Object} args
     */
    spam(...p) {
      if (this.level < m.levels.SPAM)
        return;
      const g = p[0];
      if (g instanceof Error) {
        this.logError(m.levels.SPAM, null, g);
        return;
      }
      this.log(m.levels.SPAM, null, p);
    }
    /**
     * Output a log to the desired log level.
     * Note that this bypasses the level check.
     * @param {String} level
     * @param {String|null} module
     * @param {Object[]} args
     */
    log(p, g, S) {
      this.closed && !this.rotating || this.level < p || (this.writeConsole(p, g, S), this.writeStream(p, g, S));
    }
    /**
     * Create logger context.
     * @param {String} module
     * @returns {LoggerContext}
     */
    context(p) {
      let g = this.contexts[p];
      return g || (g = new f(this, p), this.contexts[p] = g), g;
    }
    /**
     * Write log to the console.
     * @param {String} level
     * @param {String|null} module
     * @param {Object[]} args
     */
    writeConsole(p, g, S) {
      const y = m.levelsByVal[p];
      if (c(y, "Invalid log level."), !this.console)
        return !1;
      if (!St.stdout) {
        let h = `[${y}] `;
        if (g && (h += `(${g}) `), S.length > 0) {
          const [a] = S;
          if (a && typeof a == "object")
            return p === m.levels.ERROR ? console.error(h, a) : console.log(h, a);
        }
        return h += l(S, !1), p === m.levels.ERROR ? console.error(h) : console.log(h), !0;
      }
      let b;
      if (this.colors) {
        const h = m.styles[p];
        c(h), b = `\x1B[${h}m[${y}]\x1B[m `;
      } else
        b = `[${y}] `;
      return g && (b += `(${g}) `), b += l(S, this.colors), b += `
`, p === m.levels.ERROR ? St.stderr.write(b) : St.stdout.write(b);
    }
    /**
     * Write a string to the output stream (usually a file).
     * @param {String} level
     * @param {String|null} module
     * @param {Object[]} args
     */
    writeStream(p, g, S) {
      const y = m.prefixByVal[p];
      if (c(y, "Invalid log level."), !this.stream && !this.rotating || this.closing && !this.rotating)
        return;
      const b = (/* @__PURE__ */ new Date()).toISOString().slice(0, -5) + "Z";
      let h = `[${y}:${b}] `;
      g && (h += `(${g}) `), h += l(S, !1), h += `
`, this.rotating ? this._buffer.push(h) : (this.stream.write(h), this._fileSize += h.length, this._fileSize >= this.maxFileSize && this.rotate());
    }
    /**
     * Helper to parse an error into a nicer
     * format. Call's `log` internally.
     * @private
     * @param {Number} level
     * @param {String|null} module
     * @param {Error} err
     */
    logError(p, g, S) {
      if (this.closed && !this.rotating)
        return;
      w.unsupported && this.console && p <= m.levels.WARNING && console.error(S);
      let y = String(S.message).replace(/^ *Error: */, "");
      p !== m.levels.ERROR && (y = `Error: ${y}`), p <= m.levels.WARNING && S.stack && (y += `
` + String(S.stack).split(`
`).slice(1).join(`
`)), this.log(p, g, [y]);
    }
    /**
     * Get the current memory usage.
     * @returns {Object}
     */
    memoryUsage() {
      if (!St.memoryUsage)
        return {
          total: 0,
          jsHeap: 0,
          jsHeapTotal: 0,
          nativeHeap: 0,
          external: 0
        };
      const p = St.memoryUsage();
      return {
        total: n(p.rss),
        jsHeap: n(p.heapUsed),
        jsHeapTotal: n(p.heapTotal),
        nativeHeap: n(p.rss - p.heapTotal),
        external: n(p.external)
      };
    }
    /**
     * Log the current memory usage.
     * @param {String|null} module
     */
    memory(p) {
      const g = this.memoryUsage();
      this.log(m.levels.DEBUG, p, [
        "Memory: rss=%dmb, js-heap=%d/%dmb native-heap=%dmb",
        g.total,
        g.jsHeap,
        g.jsHeapTotal,
        g.nativeHeap
      ]);
    }
  }
  class f {
    /**
     * Create a logger context.
     * @constructor
     * @ignore
     * @param {Logger} logger
     * @param {String} module
     */
    constructor(p, g) {
      c(typeof g == "string"), this.logger = p, this.module = g;
    }
    /**
     * Open the logger.
     * @returns {Promise}
     */
    open() {
      return this.logger.open();
    }
    /**
     * Destroy the write stream.
     * @returns {Promise}
     */
    close() {
      return this.logger.close();
    }
    /**
     * Set the log file location.
     * @param {String} filename
     */
    setFile(p) {
      this.logger.setFile(p);
    }
    /**
     * Set or reset the log level.
     * @param {String} level
     */
    setLevel(p) {
      this.logger.setLevel(p);
    }
    /**
     * Output a log to the `error` log level.
     * @param {String|Object|Error} err
     * @param {...Object} args
     */
    error(...p) {
      if (this.logger.level < m.levels.ERROR)
        return;
      const g = p[0];
      if (g instanceof Error) {
        this.logError(m.levels.ERROR, g);
        return;
      }
      this.log(m.levels.ERROR, p);
    }
    /**
     * Output a log to the `warning` log level.
     * @param {String|Object} obj
     * @param {...Object} args
     */
    warning(...p) {
      if (this.logger.level < m.levels.WARNING)
        return;
      const g = p[0];
      if (g instanceof Error) {
        this.logError(m.levels.WARNING, g);
        return;
      }
      this.log(m.levels.WARNING, p);
    }
    /**
     * Output a log to the `info` log level.
     * @param {String|Object} obj
     * @param {...Object} args
     */
    info(...p) {
      if (this.logger.level < m.levels.INFO)
        return;
      const g = p[0];
      if (g instanceof Error) {
        this.logError(m.levels.INFO, g);
        return;
      }
      this.log(m.levels.INFO, p);
    }
    /**
     * Output a log to the `debug` log level.
     * @param {String|Object} obj
     * @param {...Object} args
     */
    debug(...p) {
      if (this.logger.level < m.levels.DEBUG)
        return;
      const g = p[0];
      if (g instanceof Error) {
        this.logError(m.levels.DEBUG, g);
        return;
      }
      this.log(m.levels.DEBUG, p);
    }
    /**
     * Output a log to the `spam` log level.
     * @param {String|Object} obj
     * @param {...Object} args
     */
    spam(...p) {
      if (this.logger.level < m.levels.SPAM)
        return;
      const g = p[0];
      if (g instanceof Error) {
        this.logError(m.levels.SPAM, g);
        return;
      }
      this.log(m.levels.SPAM, p);
    }
    /**
     * Output a log to the desired log level.
     * Note that this bypasses the level check.
     * @param {String} level
     * @param {Object[]} args
     */
    log(p, g) {
      this.logger.log(p, this.module, g);
    }
    /**
     * Create logger context.
     * @param {String} module
     * @returns {LoggerContext}
     */
    context(p) {
      return new f(this.logger, p);
    }
    /**
     * Helper to parse an error into a nicer
     * format. Call's `log` internally.
     * @private
     * @param {Number} level
     * @param {Error} err
     */
    logError(p, g) {
      this.logger.logError(p, this.module, g);
    }
    /**
     * Get the current memory usage.
     * @returns {Object}
     */
    memoryUsage() {
      return this.logger.memoryUsage();
    }
    /**
     * Log the current memory usage.
     */
    memory() {
      this.logger.memory(this.module);
    }
  }
  m.HAS_TTY = !!(St.stdout && St.stdout.isTTY), m.MAX_FILE_SIZE = 20 << 20, m.MAX_ARCHIVAL_FILES = 10, m.levels = {
    NONE: 0,
    ERROR: 1,
    WARNING: 2,
    INFO: 3,
    DEBUG: 4,
    SPAM: 5
  }, m.levelsByVal = [
    "none",
    "error",
    "warning",
    "info",
    "debug",
    "spam"
  ], m.prefixByVal = [
    "N",
    "E",
    "W",
    "I",
    "D",
    "S"
  ], m.styles = [
    "0",
    "1;31",
    "1;33",
    "94",
    "90",
    "90"
  ], m.global = new m();
  function n(i) {
    return Math.floor(i / (1 << 20));
  }
  function u(i) {
    return new Promise((p, g) => {
      const S = w.createWriteStream(i, { flags: "a" }), y = () => {
        S.removeListener("error", b), S.removeListener("open", h);
      }, b = (a) => {
        try {
          S.close();
        } catch {
        }
        y(), g(a);
      }, h = () => {
        y(), p(S);
      };
      S.once("error", b), S.once("open", h);
    });
  }
  function o(i) {
    return new Promise((p, g) => {
      const S = () => {
        i.removeListener("error", y), i.removeListener("close", b);
      }, y = (h) => {
        S(), g(h);
      }, b = () => {
        S(), p(i);
      };
      i.removeAllListeners("error"), i.removeAllListeners("close"), i.once("error", y), i.once("close", b), i.close();
    });
  }
  function s() {
    let i = (/* @__PURE__ */ new Date()).toJSON();
    return i = i.replace(/:/g, "-").replace("T", "_").replace(".", "-").slice(0, -1), i;
  }
  return Ph = m, Ph;
}
/*!
 * blgr.js - basic logger for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var kh, qb;
function Cy() {
  return qb || (qb = 1, kh = zy()), kh;
}
var Zt = {}, Tb;
function x1() {
  if (Tb) return Zt;
  Tb = 1;
  const e = Nt();
  function c(b, h) {
    if (e(k.isBuffer(b)), e(k.isBuffer(h)), m(b.length, 0))
      return m(h.length, 0);
    let a = b.length ^ h.length;
    for (let E = 0; E < h.length; E++)
      a |= b[E % b.length] ^ h[E];
    return a - 1 >>> 31;
  }
  function l(b, h) {
    if (e(k.isBuffer(b)), e(k.isBuffer(h)), !m(b.length, h.length))
      return 0;
    let a = 0;
    for (let E = 0; E < b.length; E++)
      a |= b[E] ^ h[E];
    return a - 1 >>> 31;
  }
  function w(b, h) {
    return m(b & 255, h & 255);
  }
  function m(b, h) {
    return (b ^ h) - 1 >>> 31;
  }
  function f(b, h, a) {
    return b & a - 1 | h & ~(a - 1);
  }
  function n(b, h) {
    return b - h >>> 31;
  }
  function u(b, h) {
    return b - h - 1 >>> 31;
  }
  function o(b, h) {
    return h - b >>> 31;
  }
  function s(b, h) {
    return h - b - 1 >>> 31;
  }
  function i(b, h) {
    return f(b, h, n(h, b));
  }
  function p(b, h) {
    return f(b, h, o(h, b));
  }
  function g(b) {
    return (b | 0) * (b >> 31 | 1);
  }
  function S(b) {
    return (b >> 31 | -b >> 31) & 1;
  }
  function y(b, h, a) {
    e(k.isBuffer(b)), e(k.isBuffer(h)), e(m(b.length, h.length));
    const E = a - 1 & 255, H = ~(a - 1) & 255;
    for (let j = 0; j < b.length; j++)
      b[j] = b[j] & E | h[j] & H;
  }
  return Zt.safeCompare = c, Zt.safeEqual = l, Zt.safeEqualByte = w, Zt.safeEqualInt = m, Zt.safeSelect = f, Zt.safeLT = n, Zt.safeLTE = u, Zt.safeGT = o, Zt.safeGTE = s, Zt.safeMin = i, Zt.safeMax = p, Zt.safeAbs = g, Zt.safeBool = S, Zt.safeCopy = y, Zt;
}
var Kn = {}, Bh, zb;
function Dy() {
  if (zb) return Bh;
  zb = 1;
  const e = Nt(), c = new Uint32Array([
    3328402341,
    4168907908,
    4000806809,
    4135287693,
    4294111757,
    3597364157,
    3731845041,
    2445657428,
    1613770832,
    33620227,
    3462883241,
    1445669757,
    3892248089,
    3050821474,
    1303096294,
    3967186586,
    2412431941,
    528646813,
    2311702848,
    4202528135,
    4026202645,
    2992200171,
    2387036105,
    4226871307,
    1101901292,
    3017069671,
    1604494077,
    1169141738,
    597466303,
    1403299063,
    3832705686,
    2613100635,
    1974974402,
    3791519004,
    1033081774,
    1277568618,
    1815492186,
    2118074177,
    4126668546,
    2211236943,
    1748251740,
    1369810420,
    3521504564,
    4193382664,
    3799085459,
    2883115123,
    1647391059,
    706024767,
    134480908,
    2512897874,
    1176707941,
    2646852446,
    806885416,
    932615841,
    168101135,
    798661301,
    235341577,
    605164086,
    461406363,
    3756188221,
    3454790438,
    1311188841,
    2142417613,
    3933566367,
    302582043,
    495158174,
    1479289972,
    874125870,
    907746093,
    3698224818,
    3025820398,
    1537253627,
    2756858614,
    1983593293,
    3084310113,
    2108928974,
    1378429307,
    3722699582,
    1580150641,
    327451799,
    2790478837,
    3117535592,
    0,
    3253595436,
    1075847264,
    3825007647,
    2041688520,
    3059440621,
    3563743934,
    2378943302,
    1740553945,
    1916352843,
    2487896798,
    2555137236,
    2958579944,
    2244988746,
    3151024235,
    3320835882,
    1336584933,
    3992714006,
    2252555205,
    2588757463,
    1714631509,
    293963156,
    2319795663,
    3925473552,
    67240454,
    4269768577,
    2689618160,
    2017213508,
    631218106,
    1269344483,
    2723238387,
    1571005438,
    2151694528,
    93294474,
    1066570413,
    563977660,
    1882732616,
    4059428100,
    1673313503,
    2008463041,
    2950355573,
    1109467491,
    537923632,
    3858759450,
    4260623118,
    3218264685,
    2177748300,
    403442708,
    638784309,
    3287084079,
    3193921505,
    899127202,
    2286175436,
    773265209,
    2479146071,
    1437050866,
    4236148354,
    2050833735,
    3362022572,
    3126681063,
    840505643,
    3866325909,
    3227541664,
    427917720,
    2655997905,
    2749160575,
    1143087718,
    1412049534,
    999329963,
    193497219,
    2353415882,
    3354324521,
    1807268051,
    672404540,
    2816401017,
    3160301282,
    369822493,
    2916866934,
    3688947771,
    1681011286,
    1949973070,
    336202270,
    2454276571,
    201721354,
    1210328172,
    3093060836,
    2680341085,
    3184776046,
    1135389935,
    3294782118,
    965841320,
    831886756,
    3554993207,
    4068047243,
    3588745010,
    2345191491,
    1849112409,
    3664604599,
    26054028,
    2983581028,
    2622377682,
    1235855840,
    3630984372,
    2891339514,
    4092916743,
    3488279077,
    3395642799,
    4101667470,
    1202630377,
    268961816,
    1874508501,
    4034427016,
    1243948399,
    1546530418,
    941366308,
    1470539505,
    1941222599,
    2546386513,
    3421038627,
    2715671932,
    3899946140,
    1042226977,
    2521517021,
    1639824860,
    227249030,
    260737669,
    3765465232,
    2084453954,
    1907733956,
    3429263018,
    2420656344,
    100860677,
    4160157185,
    470683154,
    3261161891,
    1781871967,
    2924959737,
    1773779408,
    394692241,
    2579611992,
    974986535,
    664706745,
    3655459128,
    3958962195,
    731420851,
    571543859,
    3530123707,
    2849626480,
    126783113,
    865375399,
    765172662,
    1008606754,
    361203602,
    3387549984,
    2278477385,
    2857719295,
    1344809080,
    2782912378,
    59542671,
    1503764984,
    160008576,
    437062935,
    1707065306,
    3622233649,
    2218934982,
    3496503480,
    2185314755,
    697932208,
    1512910199,
    504303377,
    2075177163,
    2824099068,
    1841019862,
    739644986
  ]), l = new Uint32Array([
    2781242211,
    2230877308,
    2582542199,
    2381740923,
    234877682,
    3184946027,
    2984144751,
    1418839493,
    1348481072,
    50462977,
    2848876391,
    2102799147,
    434634494,
    1656084439,
    3863849899,
    2599188086,
    1167051466,
    2636087938,
    1082771913,
    2281340285,
    368048890,
    3954334041,
    3381544775,
    201060592,
    3963727277,
    1739838676,
    4250903202,
    3930435503,
    3206782108,
    4149453988,
    2531553906,
    1536934080,
    3262494647,
    484572669,
    2923271059,
    1783375398,
    1517041206,
    1098792767,
    49674231,
    1334037708,
    1550332980,
    4098991525,
    886171109,
    150598129,
    2481090929,
    1940642008,
    1398944049,
    1059722517,
    201851908,
    1385547719,
    1699095331,
    1587397571,
    674240536,
    2704774806,
    252314885,
    3039795866,
    151914247,
    908333586,
    2602270848,
    1038082786,
    651029483,
    1766729511,
    3447698098,
    2682942837,
    454166793,
    2652734339,
    1951935532,
    775166490,
    758520603,
    3000790638,
    4004797018,
    4217086112,
    4137964114,
    1299594043,
    1639438038,
    3464344499,
    2068982057,
    1054729187,
    1901997871,
    2534638724,
    4121318227,
    1757008337,
    0,
    750906861,
    1614815264,
    535035132,
    3363418545,
    3988151131,
    3201591914,
    1183697867,
    3647454910,
    1265776953,
    3734260298,
    3566750796,
    3903871064,
    1250283471,
    1807470800,
    717615087,
    3847203498,
    384695291,
    3313910595,
    3617213773,
    1432761139,
    2484176261,
    3481945413,
    283769337,
    100925954,
    2180939647,
    4037038160,
    1148730428,
    3123027871,
    3813386408,
    4087501137,
    4267549603,
    3229630528,
    2315620239,
    2906624658,
    3156319645,
    1215313976,
    82966005,
    3747855548,
    3245848246,
    1974459098,
    1665278241,
    807407632,
    451280895,
    251524083,
    1841287890,
    1283575245,
    337120268,
    891687699,
    801369324,
    3787349855,
    2721421207,
    3431482436,
    959321879,
    1469301956,
    4065699751,
    2197585534,
    1199193405,
    2898814052,
    3887750493,
    724703513,
    2514908019,
    2696962144,
    2551808385,
    3516813135,
    2141445340,
    1715741218,
    2119445034,
    2872807568,
    2198571144,
    3398190662,
    700968686,
    3547052216,
    1009259540,
    2041044702,
    3803995742,
    487983883,
    1991105499,
    1004265696,
    1449407026,
    1316239930,
    504629770,
    3683797321,
    168560134,
    1816667172,
    3837287516,
    1570751170,
    1857934291,
    4014189740,
    2797888098,
    2822345105,
    2754712981,
    936633572,
    2347923833,
    852879335,
    1133234376,
    1500395319,
    3084545389,
    2348912013,
    1689376213,
    3533459022,
    3762923945,
    3034082412,
    4205598294,
    133428468,
    634383082,
    2949277029,
    2398386810,
    3913789102,
    403703816,
    3580869306,
    2297460856,
    1867130149,
    1918643758,
    607656988,
    4049053350,
    3346248884,
    1368901318,
    600565992,
    2090982877,
    2632479860,
    557719327,
    3717614411,
    3697393085,
    2249034635,
    2232388234,
    2430627952,
    1115438654,
    3295786421,
    2865522278,
    3633334344,
    84280067,
    33027830,
    303828494,
    2747425121,
    1600795957,
    4188952407,
    3496589753,
    2434238086,
    1486471617,
    658119965,
    3106381470,
    953803233,
    334231800,
    3005978776,
    857870609,
    3151128937,
    1890179545,
    2298973838,
    2805175444,
    3056442267,
    574365214,
    2450884487,
    550103529,
    1233637070,
    4289353045,
    2018519080,
    2057691103,
    2399374476,
    4166623649,
    2148108681,
    387583245,
    3664101311,
    836232934,
    3330556482,
    3100665960,
    3280093505,
    2955516313,
    2002398509,
    287182607,
    3413881008,
    4238890068,
    3597515707,
    975967766
  ]), w = new Uint32Array([
    1671808611,
    2089089148,
    2006576759,
    2072901243,
    4061003762,
    1807603307,
    1873927791,
    3310653893,
    810573872,
    16974337,
    1739181671,
    729634347,
    4263110654,
    3613570519,
    2883997099,
    1989864566,
    3393556426,
    2191335298,
    3376449993,
    2106063485,
    4195741690,
    1508618841,
    1204391495,
    4027317232,
    2917941677,
    3563566036,
    2734514082,
    2951366063,
    2629772188,
    2767672228,
    1922491506,
    3227229120,
    3082974647,
    4246528509,
    2477669779,
    644500518,
    911895606,
    1061256767,
    4144166391,
    3427763148,
    878471220,
    2784252325,
    3845444069,
    4043897329,
    1905517169,
    3631459288,
    827548209,
    356461077,
    67897348,
    3344078279,
    593839651,
    3277757891,
    405286936,
    2527147926,
    84871685,
    2595565466,
    118033927,
    305538066,
    2157648768,
    3795705826,
    3945188843,
    661212711,
    2999812018,
    1973414517,
    152769033,
    2208177539,
    745822252,
    439235610,
    455947803,
    1857215598,
    1525593178,
    2700827552,
    1391895634,
    994932283,
    3596728278,
    3016654259,
    695947817,
    3812548067,
    795958831,
    2224493444,
    1408607827,
    3513301457,
    0,
    3979133421,
    543178784,
    4229948412,
    2982705585,
    1542305371,
    1790891114,
    3410398667,
    3201918910,
    961245753,
    1256100938,
    1289001036,
    1491644504,
    3477767631,
    3496721360,
    4012557807,
    2867154858,
    4212583931,
    1137018435,
    1305975373,
    861234739,
    2241073541,
    1171229253,
    4178635257,
    33948674,
    2139225727,
    1357946960,
    1011120188,
    2679776671,
    2833468328,
    1374921297,
    2751356323,
    1086357568,
    2408187279,
    2460827538,
    2646352285,
    944271416,
    4110742005,
    3168756668,
    3066132406,
    3665145818,
    560153121,
    271589392,
    4279952895,
    4077846003,
    3530407890,
    3444343245,
    202643468,
    322250259,
    3962553324,
    1608629855,
    2543990167,
    1154254916,
    389623319,
    3294073796,
    2817676711,
    2122513534,
    1028094525,
    1689045092,
    1575467613,
    422261273,
    1939203699,
    1621147744,
    2174228865,
    1339137615,
    3699352540,
    577127458,
    712922154,
    2427141008,
    2290289544,
    1187679302,
    3995715566,
    3100863416,
    339486740,
    3732514782,
    1591917662,
    186455563,
    3681988059,
    3762019296,
    844522546,
    978220090,
    169743370,
    1239126601,
    101321734,
    611076132,
    1558493276,
    3260915650,
    3547250131,
    2901361580,
    1655096418,
    2443721105,
    2510565781,
    3828863972,
    2039214713,
    3878868455,
    3359869896,
    928607799,
    1840765549,
    2374762893,
    3580146133,
    1322425422,
    2850048425,
    1823791212,
    1459268694,
    4094161908,
    3928346602,
    1706019429,
    2056189050,
    2934523822,
    135794696,
    3134549946,
    2022240376,
    628050469,
    779246638,
    472135708,
    2800834470,
    3032970164,
    3327236038,
    3894660072,
    3715932637,
    1956440180,
    522272287,
    1272813131,
    3185336765,
    2340818315,
    2323976074,
    1888542832,
    1044544574,
    3049550261,
    1722469478,
    1222152264,
    50660867,
    4127324150,
    236067854,
    1638122081,
    895445557,
    1475980887,
    3117443513,
    2257655686,
    3243809217,
    489110045,
    2662934430,
    3778599393,
    4162055160,
    2561878936,
    288563729,
    1773916777,
    3648039385,
    2391345038,
    2493985684,
    2612407707,
    505560094,
    2274497927,
    3911240169,
    3460925390,
    1442818645,
    678973480,
    3749357023,
    2358182796,
    2717407649,
    2306869641,
    219617805,
    3218761151,
    3862026214,
    1120306242,
    1756942440,
    1103331905,
    2578459033,
    762796589,
    252780047,
    2966125488,
    1425844308,
    3151392187,
    372911126
  ]), m = new Uint32Array([
    1667474886,
    2088535288,
    2004326894,
    2071694838,
    4075949567,
    1802223062,
    1869591006,
    3318043793,
    808472672,
    16843522,
    1734846926,
    724270422,
    4278065639,
    3621216949,
    2880169549,
    1987484396,
    3402253711,
    2189597983,
    3385409673,
    2105378810,
    4210693615,
    1499065266,
    1195886990,
    4042263547,
    2913856577,
    3570689971,
    2728590687,
    2947541573,
    2627518243,
    2762274643,
    1920112356,
    3233831835,
    3082273397,
    4261223649,
    2475929149,
    640051788,
    909531756,
    1061110142,
    4160160501,
    3435941763,
    875846760,
    2779116625,
    3857003729,
    4059105529,
    1903268834,
    3638064043,
    825316194,
    353713962,
    67374088,
    3351728789,
    589522246,
    3284360861,
    404236336,
    2526454071,
    84217610,
    2593830191,
    117901582,
    303183396,
    2155911963,
    3806477791,
    3958056653,
    656894286,
    2998062463,
    1970642922,
    151591698,
    2206440989,
    741110872,
    437923380,
    454765878,
    1852748508,
    1515908788,
    2694904667,
    1381168804,
    993742198,
    3604373943,
    3014905469,
    690584402,
    3823320797,
    791638366,
    2223281939,
    1398011302,
    3520161977,
    0,
    3991743681,
    538992704,
    4244381667,
    2981218425,
    1532751286,
    1785380564,
    3419096717,
    3200178535,
    960056178,
    1246420628,
    1280103576,
    1482221744,
    3486468741,
    3503319995,
    4025428677,
    2863326543,
    4227536621,
    1128514950,
    1296947098,
    859002214,
    2240123921,
    1162203018,
    4193849577,
    33687044,
    2139062782,
    1347481760,
    1010582648,
    2678045221,
    2829640523,
    1364325282,
    2745433693,
    1077985408,
    2408548869,
    2459086143,
    2644360225,
    943212656,
    4126475505,
    3166494563,
    3065430391,
    3671750063,
    555836226,
    269496352,
    4294908645,
    4092792573,
    3537006015,
    3452783745,
    202118168,
    320025894,
    3974901699,
    1600119230,
    2543297077,
    1145359496,
    387397934,
    3301201811,
    2812801621,
    2122220284,
    1027426170,
    1684319432,
    1566435258,
    421079858,
    1936954854,
    1616945344,
    2172753945,
    1330631070,
    3705438115,
    572679748,
    707427924,
    2425400123,
    2290647819,
    1179044492,
    4008585671,
    3099120491,
    336870440,
    3739122087,
    1583276732,
    185277718,
    3688593069,
    3772791771,
    842159716,
    976899700,
    168435220,
    1229577106,
    101059084,
    606366792,
    1549591736,
    3267517855,
    3553849021,
    2897014595,
    1650632388,
    2442242105,
    2509612081,
    3840161747,
    2038008818,
    3890688725,
    3368567691,
    926374254,
    1835907034,
    2374863873,
    3587531953,
    1313788572,
    2846482505,
    1819063512,
    1448540844,
    4109633523,
    3941213647,
    1701162954,
    2054852340,
    2930698567,
    134748176,
    3132806511,
    2021165296,
    623210314,
    774795868,
    471606328,
    2795958615,
    3031746419,
    3334885783,
    3907527627,
    3722280097,
    1953799400,
    522133822,
    1263263126,
    3183336545,
    2341176845,
    2324333839,
    1886425312,
    1044267644,
    3048588401,
    1718004428,
    1212733584,
    50529542,
    4143317495,
    235803164,
    1633788866,
    892690282,
    1465383342,
    3115962473,
    2256965911,
    3250673817,
    488449850,
    2661202215,
    3789633753,
    4177007595,
    2560144171,
    286339874,
    1768537042,
    3654906025,
    2391705863,
    2492770099,
    2610673197,
    505291324,
    2273808917,
    3924369609,
    3469625735,
    1431699370,
    673740880,
    3755965093,
    2358021891,
    2711746649,
    2307489801,
    218961690,
    3217021541,
    3873845719,
    1111672452,
    1751693520,
    1094828930,
    2576986153,
    757954394,
    252645662,
    2964376443,
    1414855848,
    3149649517,
    370555436
  ]), f = new Uint32Array([
    1374988112,
    2118214995,
    437757123,
    975658646,
    1001089995,
    530400753,
    2902087851,
    1273168787,
    540080725,
    2910219766,
    2295101073,
    4110568485,
    1340463100,
    3307916247,
    641025152,
    3043140495,
    3736164937,
    632953703,
    1172967064,
    1576976609,
    3274667266,
    2169303058,
    2370213795,
    1809054150,
    59727847,
    361929877,
    3211623147,
    2505202138,
    3569255213,
    1484005843,
    1239443753,
    2395588676,
    1975683434,
    4102977912,
    2572697195,
    666464733,
    3202437046,
    4035489047,
    3374361702,
    2110667444,
    1675577880,
    3843699074,
    2538681184,
    1649639237,
    2976151520,
    3144396420,
    4269907996,
    4178062228,
    1883793496,
    2403728665,
    2497604743,
    1383856311,
    2876494627,
    1917518562,
    3810496343,
    1716890410,
    3001755655,
    800440835,
    2261089178,
    3543599269,
    807962610,
    599762354,
    33778362,
    3977675356,
    2328828971,
    2809771154,
    4077384432,
    1315562145,
    1708848333,
    101039829,
    3509871135,
    3299278474,
    875451293,
    2733856160,
    92987698,
    2767645557,
    193195065,
    1080094634,
    1584504582,
    3178106961,
    1042385657,
    2531067453,
    3711829422,
    1306967366,
    2438237621,
    1908694277,
    67556463,
    1615861247,
    429456164,
    3602770327,
    2302690252,
    1742315127,
    2968011453,
    126454664,
    3877198648,
    2043211483,
    2709260871,
    2084704233,
    4169408201,
    0,
    159417987,
    841739592,
    504459436,
    1817866830,
    4245618683,
    260388950,
    1034867998,
    908933415,
    168810852,
    1750902305,
    2606453969,
    607530554,
    202008497,
    2472011535,
    3035535058,
    463180190,
    2160117071,
    1641816226,
    1517767529,
    470948374,
    3801332234,
    3231722213,
    1008918595,
    303765277,
    235474187,
    4069246893,
    766945465,
    337553864,
    1475418501,
    2943682380,
    4003061179,
    2743034109,
    4144047775,
    1551037884,
    1147550661,
    1543208500,
    2336434550,
    3408119516,
    3069049960,
    3102011747,
    3610369226,
    1113818384,
    328671808,
    2227573024,
    2236228733,
    3535486456,
    2935566865,
    3341394285,
    496906059,
    3702665459,
    226906860,
    2009195472,
    733156972,
    2842737049,
    294930682,
    1206477858,
    2835123396,
    2700099354,
    1451044056,
    573804783,
    2269728455,
    3644379585,
    2362090238,
    2564033334,
    2801107407,
    2776292904,
    3669462566,
    1068351396,
    742039012,
    1350078989,
    1784663195,
    1417561698,
    4136440770,
    2430122216,
    775550814,
    2193862645,
    2673705150,
    1775276924,
    1876241833,
    3475313331,
    3366754619,
    270040487,
    3902563182,
    3678124923,
    3441850377,
    1851332852,
    3969562369,
    2203032232,
    3868552805,
    2868897406,
    566021896,
    4011190502,
    3135740889,
    1248802510,
    3936291284,
    699432150,
    832877231,
    708780849,
    3332740144,
    899835584,
    1951317047,
    4236429990,
    3767586992,
    866637845,
    4043610186,
    1106041591,
    2144161806,
    395441711,
    1984812685,
    1139781709,
    3433712980,
    3835036895,
    2664543715,
    1282050075,
    3240894392,
    1181045119,
    2640243204,
    25965917,
    4203181171,
    4211818798,
    3009879386,
    2463879762,
    3910161971,
    1842759443,
    2597806476,
    933301370,
    1509430414,
    3943906441,
    3467192302,
    3076639029,
    3776767469,
    2051518780,
    2631065433,
    1441952575,
    404016761,
    1942435775,
    1408749034,
    1610459739,
    3745345300,
    2017778566,
    3400528769,
    3110650942,
    941896748,
    3265478751,
    371049330,
    3168937228,
    675039627,
    4279080257,
    967311729,
    135050206,
    3635733660,
    1683407248,
    2076935265,
    3576870512,
    1215061108,
    3501741890
  ]), n = new Uint32Array([
    1347548327,
    1400783205,
    3273267108,
    2520393566,
    3409685355,
    4045380933,
    2880240216,
    2471224067,
    1428173050,
    4138563181,
    2441661558,
    636813900,
    4233094615,
    3620022987,
    2149987652,
    2411029155,
    1239331162,
    1730525723,
    2554718734,
    3781033664,
    46346101,
    310463728,
    2743944855,
    3328955385,
    3875770207,
    2501218972,
    3955191162,
    3667219033,
    768917123,
    3545789473,
    692707433,
    1150208456,
    1786102409,
    2029293177,
    1805211710,
    3710368113,
    3065962831,
    401639597,
    1724457132,
    3028143674,
    409198410,
    2196052529,
    1620529459,
    1164071807,
    3769721975,
    2226875310,
    486441376,
    2499348523,
    1483753576,
    428819965,
    2274680428,
    3075636216,
    598438867,
    3799141122,
    1474502543,
    711349675,
    129166120,
    53458370,
    2592523643,
    2782082824,
    4063242375,
    2988687269,
    3120694122,
    1559041666,
    730517276,
    2460449204,
    4042459122,
    2706270690,
    3446004468,
    3573941694,
    533804130,
    2328143614,
    2637442643,
    2695033685,
    839224033,
    1973745387,
    957055980,
    2856345839,
    106852767,
    1371368976,
    4181598602,
    1033297158,
    2933734917,
    1179510461,
    3046200461,
    91341917,
    1862534868,
    4284502037,
    605657339,
    2547432937,
    3431546947,
    2003294622,
    3182487618,
    2282195339,
    954669403,
    3682191598,
    1201765386,
    3917234703,
    3388507166,
    0,
    2198438022,
    1211247597,
    2887651696,
    1315723890,
    4227665663,
    1443857720,
    507358933,
    657861945,
    1678381017,
    560487590,
    3516619604,
    975451694,
    2970356327,
    261314535,
    3535072918,
    2652609425,
    1333838021,
    2724322336,
    1767536459,
    370938394,
    182621114,
    3854606378,
    1128014560,
    487725847,
    185469197,
    2918353863,
    3106780840,
    3356761769,
    2237133081,
    1286567175,
    3152976349,
    4255350624,
    2683765030,
    3160175349,
    3309594171,
    878443390,
    1988838185,
    3704300486,
    1756818940,
    1673061617,
    3403100636,
    272786309,
    1075025698,
    545572369,
    2105887268,
    4174560061,
    296679730,
    1841768865,
    1260232239,
    4091327024,
    3960309330,
    3497509347,
    1814803222,
    2578018489,
    4195456072,
    575138148,
    3299409036,
    446754879,
    3629546796,
    4011996048,
    3347532110,
    3252238545,
    4270639778,
    915985419,
    3483825537,
    681933534,
    651868046,
    2755636671,
    3828103837,
    223377554,
    2607439820,
    1649704518,
    3270937875,
    3901806776,
    1580087799,
    4118987695,
    3198115200,
    2087309459,
    2842678573,
    3016697106,
    1003007129,
    2802849917,
    1860738147,
    2077965243,
    164439672,
    4100872472,
    32283319,
    2827177882,
    1709610350,
    2125135846,
    136428751,
    3874428392,
    3652904859,
    3460984630,
    3572145929,
    3593056380,
    2939266226,
    824852259,
    818324884,
    3224740454,
    930369212,
    2801566410,
    2967507152,
    355706840,
    1257309336,
    4148292826,
    243256656,
    790073846,
    2373340630,
    1296297904,
    1422699085,
    3756299780,
    3818836405,
    457992840,
    3099667487,
    2135319889,
    77422314,
    1560382517,
    1945798516,
    788204353,
    1521706781,
    1385356242,
    870912086,
    325965383,
    2358957921,
    2050466060,
    2388260884,
    2313884476,
    4006521127,
    901210569,
    3990953189,
    1014646705,
    1503449823,
    1062597235,
    2031621326,
    3212035895,
    3931371469,
    1533017514,
    350174575,
    2256028891,
    2177544179,
    1052338372,
    741876788,
    1606591296,
    1914052035,
    213705253,
    2334669897,
    1107234197,
    1899603969,
    3725069491,
    2631447780,
    2422494913,
    1635502980,
    1893020342,
    1950903388,
    1120974935
  ]), u = new Uint32Array([
    2807058932,
    1699970625,
    2764249623,
    1586903591,
    1808481195,
    1173430173,
    1487645946,
    59984867,
    4199882800,
    1844882806,
    1989249228,
    1277555970,
    3623636965,
    3419915562,
    1149249077,
    2744104290,
    1514790577,
    459744698,
    244860394,
    3235995134,
    1963115311,
    4027744588,
    2544078150,
    4190530515,
    1608975247,
    2627016082,
    2062270317,
    1507497298,
    2200818878,
    567498868,
    1764313568,
    3359936201,
    2305455554,
    2037970062,
    1047239e3,
    1910319033,
    1337376481,
    2904027272,
    2892417312,
    984907214,
    1243112415,
    830661914,
    861968209,
    2135253587,
    2011214180,
    2927934315,
    2686254721,
    731183368,
    1750626376,
    4246310725,
    1820824798,
    4172763771,
    3542330227,
    48394827,
    2404901663,
    2871682645,
    671593195,
    3254988725,
    2073724613,
    145085239,
    2280796200,
    2779915199,
    1790575107,
    2187128086,
    472615631,
    3029510009,
    4075877127,
    3802222185,
    4107101658,
    3201631749,
    1646252340,
    4270507174,
    1402811438,
    1436590835,
    3778151818,
    3950355702,
    3963161475,
    4020912224,
    2667994737,
    273792366,
    2331590177,
    104699613,
    95345982,
    3175501286,
    2377486676,
    1560637892,
    3564045318,
    369057872,
    4213447064,
    3919042237,
    1137477952,
    2658625497,
    1119727848,
    2340947849,
    1530455833,
    4007360968,
    172466556,
    266959938,
    516552836,
    0,
    2256734592,
    3980931627,
    1890328081,
    1917742170,
    4294704398,
    945164165,
    3575528878,
    958871085,
    3647212047,
    2787207260,
    1423022939,
    775562294,
    1739656202,
    3876557655,
    2530391278,
    2443058075,
    3310321856,
    547512796,
    1265195639,
    437656594,
    3121275539,
    719700128,
    3762502690,
    387781147,
    218828297,
    3350065803,
    2830708150,
    2848461854,
    428169201,
    122466165,
    3720081049,
    1627235199,
    648017665,
    4122762354,
    1002783846,
    2117360635,
    695634755,
    3336358691,
    4234721005,
    4049844452,
    3704280881,
    2232435299,
    574624663,
    287343814,
    612205898,
    1039717051,
    840019705,
    2708326185,
    793451934,
    821288114,
    1391201670,
    3822090177,
    376187827,
    3113855344,
    1224348052,
    1679968233,
    2361698556,
    1058709744,
    752375421,
    2431590963,
    1321699145,
    3519142200,
    2734591178,
    188127444,
    2177869557,
    3727205754,
    2384911031,
    3215212461,
    2648976442,
    2450346104,
    3432737375,
    1180849278,
    331544205,
    3102249176,
    4150144569,
    2952102595,
    2159976285,
    2474404304,
    766078933,
    313773861,
    2570832044,
    2108100632,
    1668212892,
    3145456443,
    2013908262,
    418672217,
    3070356634,
    2594734927,
    1852171925,
    3867060991,
    3473416636,
    3907448597,
    2614737639,
    919489135,
    164948639,
    2094410160,
    2997825956,
    590424639,
    2486224549,
    1723872674,
    3157750862,
    3399941250,
    3501252752,
    3625268135,
    2555048196,
    3673637356,
    1343127501,
    4130281361,
    3599595085,
    2957853679,
    1297403050,
    81781910,
    3051593425,
    2283490410,
    532201772,
    1367295589,
    3926170974,
    895287692,
    1953757831,
    1093597963,
    492483431,
    3528626907,
    1446242576,
    1192455638,
    1636604631,
    209336225,
    344873464,
    1015671571,
    669961897,
    3375740769,
    3857572124,
    2973530695,
    3747192018,
    1933530610,
    3464042516,
    935293895,
    3454686199,
    2858115069,
    1863638845,
    3683022916,
    4085369519,
    3292445032,
    875313188,
    1080017571,
    3279033885,
    621591778,
    1233856572,
    2504130317,
    24197544,
    3017672716,
    3835484340,
    3247465558,
    2220981195,
    3060847922,
    1551124588,
    1463996600
  ]), o = new Uint32Array([
    4104605777,
    1097159550,
    396673818,
    660510266,
    2875968315,
    2638606623,
    4200115116,
    3808662347,
    821712160,
    1986918061,
    3430322568,
    38544885,
    3856137295,
    718002117,
    893681702,
    1654886325,
    2975484382,
    3122358053,
    3926825029,
    4274053469,
    796197571,
    1290801793,
    1184342925,
    3556361835,
    2405426947,
    2459735317,
    1836772287,
    1381620373,
    3196267988,
    1948373848,
    3764988233,
    3385345166,
    3263785589,
    2390325492,
    1480485785,
    3111247143,
    3780097726,
    2293045232,
    548169417,
    3459953789,
    3746175075,
    439452389,
    1362321559,
    1400849762,
    1685577905,
    1806599355,
    2174754046,
    137073913,
    1214797936,
    1174215055,
    3731654548,
    2079897426,
    1943217067,
    1258480242,
    529487843,
    1437280870,
    3945269170,
    3049390895,
    3313212038,
    923313619,
    679998e3,
    3215307299,
    57326082,
    377642221,
    3474729866,
    2041877159,
    133361907,
    1776460110,
    3673476453,
    96392454,
    878845905,
    2801699524,
    777231668,
    4082475170,
    2330014213,
    4142626212,
    2213296395,
    1626319424,
    1906247262,
    1846563261,
    562755902,
    3708173718,
    1040559837,
    3871163981,
    1418573201,
    3294430577,
    114585348,
    1343618912,
    2566595609,
    3186202582,
    1078185097,
    3651041127,
    3896688048,
    2307622919,
    425408743,
    3371096953,
    2081048481,
    1108339068,
    2216610296,
    0,
    2156299017,
    736970802,
    292596766,
    1517440620,
    251657213,
    2235061775,
    2933202493,
    758720310,
    265905162,
    1554391400,
    1532285339,
    908999204,
    174567692,
    1474760595,
    4002861748,
    2610011675,
    3234156416,
    3693126241,
    2001430874,
    303699484,
    2478443234,
    2687165888,
    585122620,
    454499602,
    151849742,
    2345119218,
    3064510765,
    514443284,
    4044981591,
    1963412655,
    2581445614,
    2137062819,
    19308535,
    1928707164,
    1715193156,
    4219352155,
    1126790795,
    600235211,
    3992742070,
    3841024952,
    836553431,
    1669664834,
    2535604243,
    3323011204,
    1243905413,
    3141400786,
    4180808110,
    698445255,
    2653899549,
    2989552604,
    2253581325,
    3252932727,
    3004591147,
    1891211689,
    2487810577,
    3915653703,
    4237083816,
    4030667424,
    2100090966,
    865136418,
    1229899655,
    953270745,
    3399679628,
    3557504664,
    4118925222,
    2061379749,
    3079546586,
    2915017791,
    983426092,
    2022837584,
    1607244650,
    2118541908,
    2366882550,
    3635996816,
    972512814,
    3283088770,
    1568718495,
    3499326569,
    3576539503,
    621982671,
    2895723464,
    410887952,
    2623762152,
    1002142683,
    645401037,
    1494807662,
    2595684844,
    1335535747,
    2507040230,
    4293295786,
    3167684641,
    367585007,
    3885750714,
    1865862730,
    2668221674,
    2960971305,
    2763173681,
    1059270954,
    2777952454,
    2724642869,
    1320957812,
    2194319100,
    2429595872,
    2815956275,
    77089521,
    3973773121,
    3444575871,
    2448830231,
    1305906550,
    4021308739,
    2857194700,
    2516901860,
    3518358430,
    1787304780,
    740276417,
    1699839814,
    1592394909,
    2352307457,
    2272556026,
    188821243,
    1729977011,
    3687994002,
    274084841,
    3594982253,
    3613494426,
    2701949495,
    4162096729,
    322734571,
    2837966542,
    1640576439,
    484830689,
    1202797690,
    3537852828,
    4067639125,
    349075736,
    3342319475,
    4157467219,
    4255800159,
    1030690015,
    1155237496,
    2951971274,
    1757691577,
    607398968,
    2738905026,
    499347990,
    3794078908,
    1011452712,
    227885567,
    2818666809,
    213114376,
    3034881240,
    1455525988,
    3414450555,
    850817237,
    1817998408,
    3092726480
  ]), s = new Uint8Array([
    82,
    9,
    106,
    213,
    48,
    54,
    165,
    56,
    191,
    64,
    163,
    158,
    129,
    243,
    215,
    251,
    124,
    227,
    57,
    130,
    155,
    47,
    255,
    135,
    52,
    142,
    67,
    68,
    196,
    222,
    233,
    203,
    84,
    123,
    148,
    50,
    166,
    194,
    35,
    61,
    238,
    76,
    149,
    11,
    66,
    250,
    195,
    78,
    8,
    46,
    161,
    102,
    40,
    217,
    36,
    178,
    118,
    91,
    162,
    73,
    109,
    139,
    209,
    37,
    114,
    248,
    246,
    100,
    134,
    104,
    152,
    22,
    212,
    164,
    92,
    204,
    93,
    101,
    182,
    146,
    108,
    112,
    72,
    80,
    253,
    237,
    185,
    218,
    94,
    21,
    70,
    87,
    167,
    141,
    157,
    132,
    144,
    216,
    171,
    0,
    140,
    188,
    211,
    10,
    247,
    228,
    88,
    5,
    184,
    179,
    69,
    6,
    208,
    44,
    30,
    143,
    202,
    63,
    15,
    2,
    193,
    175,
    189,
    3,
    1,
    19,
    138,
    107,
    58,
    145,
    17,
    65,
    79,
    103,
    220,
    234,
    151,
    242,
    207,
    206,
    240,
    180,
    230,
    115,
    150,
    172,
    116,
    34,
    231,
    173,
    53,
    133,
    226,
    249,
    55,
    232,
    28,
    117,
    223,
    110,
    71,
    241,
    26,
    113,
    29,
    41,
    197,
    137,
    111,
    183,
    98,
    14,
    170,
    24,
    190,
    27,
    252,
    86,
    62,
    75,
    198,
    210,
    121,
    32,
    154,
    219,
    192,
    254,
    120,
    205,
    90,
    244,
    31,
    221,
    168,
    51,
    136,
    7,
    199,
    49,
    177,
    18,
    16,
    89,
    39,
    128,
    236,
    95,
    96,
    81,
    127,
    169,
    25,
    181,
    74,
    13,
    45,
    229,
    122,
    159,
    147,
    201,
    156,
    239,
    160,
    224,
    59,
    77,
    174,
    42,
    245,
    176,
    200,
    235,
    187,
    60,
    131,
    83,
    153,
    97,
    23,
    43,
    4,
    126,
    186,
    119,
    214,
    38,
    225,
    105,
    20,
    99,
    85,
    33,
    12,
    125
  ]), i = new Uint32Array([
    16777216,
    33554432,
    67108864,
    134217728,
    268435456,
    536870912,
    1073741824,
    2147483648,
    452984832,
    905969664
  ]);
  class p {
    constructor(h = 256) {
      e(h >>> 0 === h), this.bits = h, this.rounds = g(h), this.key = null, this.encKey = null, this.decKey = null;
    }
    get blockSize() {
      return 16;
    }
    init(h) {
      if (e(k.isBuffer(h)), h.length !== this.bits >>> 3)
        throw new Error("Invalid key size.");
      return this.destroy(), this.key = k.from(h), this.encKey = null, this.decKey = null, this;
    }
    createEncryptKey() {
      if (!this.key)
        throw new Error("Cipher is not initialized.");
      const h = this.key;
      if (h.length !== this.bits >>> 3)
        throw new Error("Invalid key size.");
      const a = new Uint32Array(60);
      a[0] = S(h, 0), a[1] = S(h, 4), a[2] = S(h, 8), a[3] = S(h, 12);
      let E = 0, H = 0;
      if (this.bits === 128) {
        for (; ; ) {
          const j = a[E + 3];
          if (a[E + 4] = a[E] ^ w[j >>> 16 & 255] & 4278190080 ^ m[j >>> 8 & 255] & 16711680 ^ c[j >>> 0 & 255] & 65280 ^ l[j >>> 24 & 255] & 255 ^ i[H], a[E + 5] = a[E + 1] ^ a[E + 4], a[E + 6] = a[E + 2] ^ a[E + 5], a[E + 7] = a[E + 3] ^ a[E + 6], H += 1, H === 10)
            break;
          E += 4;
        }
        return a;
      }
      if (a[E + 4] = S(h, 16), a[E + 5] = S(h, 20), this.bits === 192) {
        for (; ; ) {
          const j = a[E + 5];
          if (a[E + 6] = a[E] ^ w[j >>> 16 & 255] & 4278190080 ^ m[j >>> 8 & 255] & 16711680 ^ c[j >>> 0 & 255] & 65280 ^ l[j >>> 24 & 255] & 255 ^ i[H], a[E + 7] = a[E + 1] ^ a[E + 6], a[E + 8] = a[E + 2] ^ a[E + 7], a[E + 9] = a[E + 3] ^ a[E + 8], H += 1, H === 8)
            break;
          a[E + 10] = a[E + 4] ^ a[E + 9], a[E + 11] = a[E + 5] ^ a[E + 10], E += 6;
        }
        return a;
      }
      if (a[E + 6] = S(h, 24), a[E + 7] = S(h, 28), this.bits === 256) {
        for (; ; ) {
          let j = a[E + 7];
          if (a[E + 8] = a[E] ^ w[j >>> 16 & 255] & 4278190080 ^ m[j >>> 8 & 255] & 16711680 ^ c[j >>> 0 & 255] & 65280 ^ l[j >>> 24 & 255] & 255 ^ i[H], a[E + 9] = a[E + 1] ^ a[E + 8], a[E + 10] = a[E + 2] ^ a[E + 9], a[E + 11] = a[E + 3] ^ a[E + 10], H += 1, H === 7)
            break;
          j = a[E + 11], a[E + 12] = a[E + 4] ^ w[j >>> 24 & 255] & 4278190080 ^ m[j >>> 16 & 255] & 16711680 ^ c[j >>> 8 & 255] & 65280 ^ l[j >>> 0 & 255] & 255, a[E + 13] = a[E + 5] ^ a[E + 12], a[E + 14] = a[E + 6] ^ a[E + 13], a[E + 15] = a[E + 7] ^ a[E + 14], E += 8;
        }
        return a;
      }
      throw new Error("Bad key size.");
    }
    createDecryptKey() {
      const h = this.createEncryptKey();
      let a = 0;
      for (let E = 0, H = 4 * this.rounds; E < H; E += 4, H -= 4) {
        let j = h[a + E + 0];
        h[a + E + 0] = h[a + H + 0], h[a + H + 0] = j, j = h[a + E + 1], h[a + E + 1] = h[a + H + 1], h[a + H + 1] = j, j = h[a + E + 2], h[a + E + 2] = h[a + H + 2], h[a + H + 2] = j, j = h[a + E + 3], h[a + E + 3] = h[a + H + 3], h[a + H + 3] = j;
      }
      for (let E = 1; E < this.rounds; E++)
        a += 4, h[a + 0] = f[l[h[a + 0] >>> 24 & 255] & 255] ^ n[l[h[a + 0] >>> 16 & 255] & 255] ^ u[l[h[a + 0] >>> 8 & 255] & 255] ^ o[l[h[a + 0] >>> 0 & 255] & 255], h[a + 1] = f[l[h[a + 1] >>> 24 & 255] & 255] ^ n[l[h[a + 1] >>> 16 & 255] & 255] ^ u[l[h[a + 1] >>> 8 & 255] & 255] ^ o[l[h[a + 1] >>> 0 & 255] & 255], h[a + 2] = f[l[h[a + 2] >>> 24 & 255] & 255] ^ n[l[h[a + 2] >>> 16 & 255] & 255] ^ u[l[h[a + 2] >>> 8 & 255] & 255] ^ o[l[h[a + 2] >>> 0 & 255] & 255], h[a + 3] = f[l[h[a + 3] >>> 24 & 255] & 255] ^ n[l[h[a + 3] >>> 16 & 255] & 255] ^ u[l[h[a + 3] >>> 8 & 255] & 255] ^ o[l[h[a + 3] >>> 0 & 255] & 255];
      return h;
    }
    getEncryptKey() {
      return this.encKey || (this.encKey = this.createEncryptKey()), this.encKey;
    }
    getDecryptKey() {
      return this.decKey || (this.decKey = this.createDecryptKey()), this.decKey;
    }
    encrypt(h, a, E, H) {
      const j = this.getEncryptKey();
      let G = S(E, H + 0) ^ j[0], N = S(E, H + 4) ^ j[1], T = S(E, H + 8) ^ j[2], A = S(E, H + 12) ^ j[3], q = this.rounds >>> 1, _ = 0, F, R, L, fe;
      for (; F = c[G >>> 24 & 255] ^ l[N >>> 16 & 255] ^ w[T >>> 8 & 255] ^ m[A >>> 0 & 255] ^ j[_ + 4], R = c[N >>> 24 & 255] ^ l[T >>> 16 & 255] ^ w[A >>> 8 & 255] ^ m[G >>> 0 & 255] ^ j[_ + 5], L = c[T >>> 24 & 255] ^ l[A >>> 16 & 255] ^ w[G >>> 8 & 255] ^ m[N >>> 0 & 255] ^ j[_ + 6], fe = c[A >>> 24 & 255] ^ l[G >>> 16 & 255] ^ w[N >>> 8 & 255] ^ m[T >>> 0 & 255] ^ j[_ + 7], _ += 8, q -= 1, q !== 0; )
        G = c[F >>> 24 & 255] ^ l[R >>> 16 & 255] ^ w[L >>> 8 & 255] ^ m[fe >>> 0 & 255] ^ j[_ + 0], N = c[R >>> 24 & 255] ^ l[L >>> 16 & 255] ^ w[fe >>> 8 & 255] ^ m[F >>> 0 & 255] ^ j[_ + 1], T = c[L >>> 24 & 255] ^ l[fe >>> 16 & 255] ^ w[F >>> 8 & 255] ^ m[R >>> 0 & 255] ^ j[_ + 2], A = c[fe >>> 24 & 255] ^ l[F >>> 16 & 255] ^ w[R >>> 8 & 255] ^ m[L >>> 0 & 255] ^ j[_ + 3];
      return G = w[F >>> 24 & 255] & 4278190080 ^ m[R >>> 16 & 255] & 16711680 ^ c[L >>> 8 & 255] & 65280 ^ l[fe >>> 0 & 255] & 255 ^ j[_ + 0], N = w[R >>> 24 & 255] & 4278190080 ^ m[L >>> 16 & 255] & 16711680 ^ c[fe >>> 8 & 255] & 65280 ^ l[F >>> 0 & 255] & 255 ^ j[_ + 1], T = w[L >>> 24 & 255] & 4278190080 ^ m[fe >>> 16 & 255] & 16711680 ^ c[F >>> 8 & 255] & 65280 ^ l[R >>> 0 & 255] & 255 ^ j[_ + 2], A = w[fe >>> 24 & 255] & 4278190080 ^ m[F >>> 16 & 255] & 16711680 ^ c[R >>> 8 & 255] & 65280 ^ l[L >>> 0 & 255] & 255 ^ j[_ + 3], y(h, G, a + 0), y(h, N, a + 4), y(h, T, a + 8), y(h, A, a + 12), this;
    }
    decrypt(h, a, E, H) {
      const j = this.getDecryptKey();
      let G = S(E, H + 0) ^ j[0], N = S(E, H + 4) ^ j[1], T = S(E, H + 8) ^ j[2], A = S(E, H + 12) ^ j[3], q = this.rounds >>> 1, _ = 0, F, R, L, fe;
      for (; F = f[G >>> 24 & 255] ^ n[A >>> 16 & 255] ^ u[T >>> 8 & 255] ^ o[N >>> 0 & 255] ^ j[_ + 4], R = f[N >>> 24 & 255] ^ n[G >>> 16 & 255] ^ u[A >>> 8 & 255] ^ o[T >>> 0 & 255] ^ j[_ + 5], L = f[T >>> 24 & 255] ^ n[N >>> 16 & 255] ^ u[G >>> 8 & 255] ^ o[A >>> 0 & 255] ^ j[_ + 6], fe = f[A >>> 24 & 255] ^ n[T >>> 16 & 255] ^ u[N >>> 8 & 255] ^ o[G >>> 0 & 255] ^ j[_ + 7], _ += 8, q -= 1, q !== 0; )
        G = f[F >>> 24 & 255] ^ n[fe >>> 16 & 255] ^ u[L >>> 8 & 255] ^ o[R >>> 0 & 255] ^ j[_ + 0], N = f[R >>> 24 & 255] ^ n[F >>> 16 & 255] ^ u[fe >>> 8 & 255] ^ o[L >>> 0 & 255] ^ j[_ + 1], T = f[L >>> 24 & 255] ^ n[R >>> 16 & 255] ^ u[F >>> 8 & 255] ^ o[fe >>> 0 & 255] ^ j[_ + 2], A = f[fe >>> 24 & 255] ^ n[L >>> 16 & 255] ^ u[R >>> 8 & 255] ^ o[F >>> 0 & 255] ^ j[_ + 3];
      return G = s[F >>> 24 & 255] << 24 ^ s[fe >>> 16 & 255] << 16 ^ s[L >>> 8 & 255] << 8 ^ s[R >>> 0 & 255] << 0 ^ j[_ + 0], N = s[R >>> 24 & 255] << 24 ^ s[F >>> 16 & 255] << 16 ^ s[fe >>> 8 & 255] << 8 ^ s[L >>> 0 & 255] << 0 ^ j[_ + 1], T = s[L >>> 24 & 255] << 24 ^ s[R >>> 16 & 255] << 16 ^ s[F >>> 8 & 255] << 8 ^ s[fe >>> 0 & 255] << 0 ^ j[_ + 2], A = s[fe >>> 24 & 255] << 24 ^ s[L >>> 16 & 255] << 16 ^ s[R >>> 8 & 255] << 8 ^ s[F >>> 0 & 255] << 0 ^ j[_ + 3], y(h, G, a + 0), y(h, N, a + 4), y(h, T, a + 8), y(h, A, a + 12), this;
    }
    destroy() {
      if (this.key)
        for (let h = 0; h < this.key.length; h++)
          this.key[h] = 0;
      if (this.encKey)
        for (let h = 0; h < 60; h++)
          this.encKey[h] = 0;
      if (this.decKey)
        for (let h = 0; h < 60; h++)
          this.decKey[h] = 0;
      return this.key = null, this.encKey = null, this.decKey = null, this;
    }
  }
  function g(b) {
    switch (b) {
      case 128:
        return 10;
      case 192:
        return 12;
      case 256:
        return 14;
      default:
        throw new Error("Bad key size.");
    }
  }
  function S(b, h) {
    return b[h++] * 16777216 + b[h++] * 65536 + b[h++] * 256 + b[h];
  }
  function y(b, h, a) {
    return b[a++] = h >>> 24, b[a++] = h >>> 16, b[a++] = h >>> 8, b[a++] = h, a;
  }
  return Bh = p, Bh;
}
var vt = {}, Mh, Cb;
function Uy() {
  if (Cb) return Mh;
  Cb = 1;
  const e = Nt(), c = k.alloc(16, 0), l = -1, w = new Uint16Array([
    0,
    7200,
    14400,
    9312,
    28800,
    27808,
    18624,
    21728,
    57600,
    64800,
    55616,
    50528,
    37248,
    36256,
    43456,
    46560
  ]);
  class m {
    constructor() {
      this.state = new Uint32Array(4), this.block = k.alloc(16), this.size = l, this.adLen = 0, this.ctLen = 0, this.table = new Array(16);
      for (let p = 0; p < 16; p++)
        this.table[p] = new Uint32Array(4);
    }
    init(p) {
      e(k.isBuffer(p)), e(p.length === 16);
      for (let S = 0; S < 4; S++)
        this.state[S] = 0;
      this.size = 0, this.adLen = 0, this.ctLen = 0;
      for (let S = 0; S < 16; S++)
        for (let y = 0; y < 4; y++)
          this.table[S][y] = 0;
      const g = new Uint32Array(4);
      g[1] = o(p, 0), g[0] = o(p, 4), g[3] = o(p, 8), g[2] = o(p, 12), this.table[u(1)] = g;
      for (let S = 2; S < 16; S += 2)
        this.table[u(S)] = this.double(this.table[u(S >>> 1)]), this.table[u(S + 1)] = this.add(this.table[u(S)], g);
      return this;
    }
    absorb(p) {
      return this._absorb(p, p.length), this;
    }
    _absorb(p, g) {
      e(this.size !== l, "Context is not initialized.");
      let S = this.size & 15, y = 0;
      if (this.size += g, S > 0) {
        let b = 16 - S;
        if (b > g && (b = g), p.copy(this.block, S, y, y + b), S += b, g -= b, y += b, S < 16)
          return;
        this.transform(this.block, 0);
      }
      for (; g >= 16; )
        this.transform(p, y), y += 16, g -= 16;
      g > 0 && p.copy(this.block, 0, y, y + g);
    }
    transform(p, g) {
      this.state[1] ^= o(p, g + 0), this.state[0] ^= o(p, g + 4), this.state[3] ^= o(p, g + 8), this.state[2] ^= o(p, g + 12), this.mul(this.state);
    }
    pad() {
      const p = this.size & 15;
      p !== 0 && this._absorb(c, 16 - p);
    }
    aad(p) {
      return e(k.isBuffer(p)), e(this.ctLen === 0), this.adLen += p.length, this.absorb(p);
    }
    update(p) {
      return e(k.isBuffer(p)), p.length === 0 ? this : (this.ctLen === 0 && this.pad(), this.ctLen += p.length, this.absorb(p));
    }
    final() {
      const p = k.alloc(16);
      this.pad();
      const g = this.adLen * 8, S = this.ctLen * 8;
      this.state[1] ^= f(g), this.state[0] ^= n(g), this.state[3] ^= f(S), this.state[2] ^= n(S), this.mul(this.state), s(p, this.state[1], 0), s(p, this.state[0], 4), s(p, this.state[3], 8), s(p, this.state[2], 12);
      for (let y = 0; y < 4; y++)
        this.state[y] = 0;
      for (let y = 0; y < 16; y++)
        this.block[y] = 0;
      this.size = l, this.adLen = 0, this.ctLen = 0;
      for (let y = 0; y < 16; y++)
        for (let b = 0; b < 4; b++)
          this.table[y][b] = 0;
      return p;
    }
    destroy() {
      for (let p = 0; p < 4; p++)
        this.state[p] = 0;
      for (let p = 0; p < 16; p++)
        this.block[p] = 0;
      this.size = l, this.adLen = 0, this.ctLen = 0;
      for (let p = 0; p < 16; p++)
        for (let g = 0; g < 4; g++)
          this.table[p][g] = 0;
    }
    add(p, g) {
      e(p instanceof Uint32Array), e(p.length === 4), e(g instanceof Uint32Array), e(g.length === 4);
      const S = new Uint32Array(4);
      return S[0] = p[0] ^ g[0], S[1] = p[1] ^ g[1], S[2] = p[2] ^ g[2], S[3] = p[3] ^ g[3], S;
    }
    double(p) {
      e(p instanceof Uint32Array), e(p.length === 4);
      const g = new Uint32Array(4), S = (p[2] & 1) === 1;
      let y;
      return g[3] = p[3], g[2] = p[2], y = g[3] & 1, g[3] >>>= 1, g[2] >>>= 1, g[2] |= y << 31, g[3] |= (p[0] & 1) << 31, g[1] = p[1], g[0] = p[0], y = g[1] & 1, g[1] >>>= 1, g[0] >>>= 1, g[0] |= y << 31, S && (g[1] ^= 3774873600, g[0] ^= 0), g;
    }
    mul(p) {
      e(p instanceof Uint32Array), e(p.length === 4);
      const g = new Uint32Array(4), S = new Uint32Array(2);
      let y, b;
      for (let h = 0; h < 2; h++) {
        S[0] = p[2], S[1] = p[3], h === 1 && (S[0] = p[0], S[1] = p[1]);
        for (let a = 0; a < 64; a += 4) {
          const E = g[2] & 15;
          y = g[3] & 15, g[3] >>>= 4, g[2] >>>= 4, g[2] |= y << 28, g[3] |= g[0] << 28, y = g[1] & 15, g[1] >>>= 4, g[0] >>>= 4, g[0] |= y << 28, g[1] ^= w[E] << 16, b = this.table[S[0] & 15], g[0] ^= b[0], g[1] ^= b[1], g[2] ^= b[2], g[3] ^= b[3], y = S[1] & 15, S[1] >>>= 4, S[0] >>>= 4, S[0] |= y << 28;
        }
      }
      p[0] = g[0], p[1] = g[1], p[2] = g[2], p[3] = g[3];
    }
  }
  function f(i) {
    return i * (1 / 4294967296) >>> 0;
  }
  function n(i) {
    return i >>> 0;
  }
  function u(i) {
    return i = i << 2 & 12 | i >>> 2 & 3, i = i << 1 & 10 | i >>> 1 & 5, i;
  }
  function o(i, p) {
    return i[p++] * 16777216 + i[p++] * 65536 + i[p++] * 256 + i[p++];
  }
  function s(i, p, g) {
    return i[g++] = p >>> 24, i[g++] = p >>> 16, i[g++] = p >>> 8, i[g++] = p, g;
  }
  return Mh = m, Mh;
}
var Db;
function Fy() {
  if (Db) return vt;
  Db = 1;
  const e = Nt(), c = Uy(), l = k.alloc(0), w = new Uint32Array([
    27,
    // 8
    135,
    // 16
    1061,
    // 32
    0,
    293,
    // 64
    0,
    0,
    0,
    524355
    // 128
  ]);
  class m {
    constructor(z) {
      e(z && typeof z.encrypt == "function"), e(typeof z.blockSize == "number"), this.ctx = z;
    }
    get blockSize() {
      return this.ctx.blockSize;
    }
    init(z, I) {
      throw new Error("Not implemented.");
    }
    update(z) {
      throw new Error("Not implemented.");
    }
    crypt(z, I) {
      throw new Error("Not implemented.");
    }
    final() {
      throw new Error("Not implemented.");
    }
    destroy() {
      throw new Error("Not implemented.");
    }
    setAutoPadding(z) {
      return e(typeof z == "boolean"), this._setAutoPadding(z), this;
    }
    setAAD(z) {
      return e(k.isBuffer(z)), this._setAAD(z), this;
    }
    setCCM(z, I, ne) {
      return e(z >>> 0 === z), e(I >>> 0 === I), e(ne == null || k.isBuffer(ne)), this._setCCM(z, I, ne), this;
    }
    getAuthTag() {
      return this._getAuthTag();
    }
    setAuthTag(z) {
      return e(k.isBuffer(z)), this._setAuthTag(z), this;
    }
    _setAutoPadding(z) {
      throw new Error("Not available.");
    }
    _setAAD(z) {
      throw new Error("Cipher is not authenticated.");
    }
    _setCCM(z, I, ne) {
      throw new Error("Not available.");
    }
    _getAuthTag() {
      throw new Error("Cipher is not authenticated.");
    }
    _setAuthTag(z) {
      throw new Error("Cipher is not authenticated.");
    }
  }
  class f extends m {
    constructor(z, I) {
      super(z), this.padding = !0, this.unpad = I, this.block = k.alloc(this.blockSize), this.blockPos = -1, this.last = null, this.lastSize = 0, I && (this.last = k.alloc(this.blockSize));
    }
    init(z, I) {
      return I == null && (I = l), e(k.isBuffer(z)), e(k.isBuffer(I)), this.ctx.init(z), this.blockPos = 0, this.lastSize = 0, this._init(z, I), this;
    }
    _updateSize(z) {
      if (this.blockPos + z < this.blockSize)
        return 0;
      let I = 0;
      return this.unpad && (I += this.lastSize), this.blockPos > 0 && (z -= this.blockSize - this.blockPos, I += this.blockSize), z >= this.blockSize && (I += z - z % this.blockSize), e(I >= this.blockSize), I;
    }
    update(z) {
      if (e(k.isBuffer(z)), this.blockPos === -1)
        throw new Error("Cipher is not initialized.");
      const I = this._updateSize(z.length), ne = k.alloc(I);
      if (this.blockPos + z.length < this.blockSize)
        return this.blockPos += z.copy(this.block, this.blockPos, 0, z.length), ne;
      let t = z.length, d = 0, B = 0;
      if (this.unpad && (B += this.last.copy(ne, B, 0, this.lastSize)), this.blockPos > 0) {
        const U = this.blockSize - this.blockPos;
        d += z.copy(this.block, this.blockPos, d, d + U), t -= U, this._update(ne, B, this.block, 0), B += this.blockSize, this.blockPos = 0;
      }
      for (; t >= this.blockSize; )
        this._update(ne, B, z, d), d += this.blockSize, t -= this.blockSize, B += this.blockSize;
      return t > 0 && (this.blockPos = z.copy(this.block, 0, d, d + t)), e(B === I), this.unpad ? (this.lastSize = ne.copy(this.last, 0, I - this.blockSize, I), ne.slice(0, I - this.blockSize)) : ne;
    }
    crypt(z, I) {
      if (e(k.isBuffer(z)), e(k.isBuffer(I)), e(z.length === I.length), this.blockPos === -1)
        throw new Error("Cipher is not initialized.");
      if (this.unpad || this.blockPos !== 0)
        throw new Error("Cannot crypt while buffering.");
      if (I.length % this.blockSize !== 0)
        throw new Error("Input must be a multiple of the block size.");
      const ne = this.blockSize;
      let t = I.length, d = 0;
      for (; t > 0; )
        this._update(z, d, I, d), d += ne, t -= ne;
      return z;
    }
    final() {
      if (this.blockPos === -1)
        throw new Error("Cipher is not initialized.");
      try {
        return this._final();
      } finally {
        this.destroy();
      }
    }
    destroy() {
      this.ctx.destroy(), this.blockPos = -1, this.lastSize = 0;
      for (let z = 0; z < this.blockSize; z++)
        this.block[z] = 0;
      if (this.unpad)
        for (let z = 0; z < this.blockSize; z++)
          this.last[z] = 0;
      return this._destroy(), this;
    }
    _init(z, I) {
      throw new Error("Not implemented.");
    }
    _update(z, I, ne, t) {
      throw new Error("Not implemented.");
    }
    _final() {
      throw new Error("Not implemented.");
    }
    _destroy() {
      throw new Error("Not implemented.");
    }
  }
  class n extends m {
    constructor(z) {
      super(z), this.pos = -1;
    }
    init(z, I) {
      return I == null && (I = l), e(k.isBuffer(z)), e(k.isBuffer(I)), this.ctx.init(z), this.pos = 0, this._init(z, I), this;
    }
    update(z) {
      if (e(k.isBuffer(z)), this.pos === -1)
        throw new Error("Cipher is not initialized.");
      const I = k.alloc(z.length);
      return this._crypt(I, z), I;
    }
    crypt(z, I) {
      if (e(k.isBuffer(z)), e(k.isBuffer(I)), e(z.length === I.length), this.pos === -1)
        throw new Error("Cipher is not initialized.");
      return this._crypt(z, I), z;
    }
    final() {
      if (this.pos === -1)
        throw new Error("Cipher is not initialized.");
      try {
        return this._final();
      } finally {
        this.destroy();
      }
    }
    destroy() {
      return this.ctx.destroy(), this.pos = -1, this._destroy(), this;
    }
    _init(z, I) {
      throw new Error("Not implemented.");
    }
    _crypt(z, I) {
      throw new Error("Not implemented.");
    }
    _final() {
      throw new Error("Not implemented.");
    }
    _destroy() {
      throw new Error("Not implemented.");
    }
  }
  class u extends f {
    constructor(z) {
      super(z, !1);
    }
    _init(z, I) {
      e(I.length === 0);
    }
    _update(z, I, ne, t) {
      this.ctx.encrypt(z, I, ne, t);
    }
    _final() {
      if (this.blockPos !== 0)
        throw new Error("Bad encrypt (trailing bytes).");
      return k.alloc(0);
    }
    _destroy() {
    }
  }
  class o extends f {
    constructor(z) {
      super(z, !1);
    }
    _init(z, I) {
      e(I.length === 0);
    }
    _update(z, I, ne, t) {
      this.ctx.decrypt(z, I, ne, t);
    }
    _final() {
      if (this.blockPos !== 0)
        throw new Error("Bad decrypt (trailing bytes).");
      return k.alloc(0);
    }
    _destroy() {
    }
  }
  class s extends f {
    constructor(z) {
      super(z, !1);
    }
    _final() {
      if (!this.padding) {
        if (this.blockPos !== 0)
          throw new Error("Bad encrypt (trailing bytes).");
        return k.alloc(0);
      }
      const z = this.blockSize - this.blockPos, I = k.from(this.block);
      for (let ne = this.blockPos; ne < this.blockSize; ne++)
        I[ne] = z;
      return this._update(I, 0, I, 0), I;
    }
    _setAutoPadding(z) {
      this.padding = z;
    }
  }
  class i extends f {
    constructor(z) {
      super(z, !0);
    }
    _final() {
      if (this.blockPos !== 0)
        throw new Error("Bad decrypt (trailing bytes).");
      if (!this.padding)
        return k.alloc(0);
      if (this.lastSize === 0)
        throw new Error("Bad decrypt (no data).");
      e(this.lastSize === this.last.length), e(this.lastSize === this.blockSize);
      const z = k.from(this.last);
      let I = z[z.length - 1], ne = 1;
      ne &= I - 1 >>> 31 ^ 1, ne &= I - this.blockSize - 1 >>> 31, I &= -ne;
      const t = this.blockSize - I;
      for (let d = 0; d < this.blockSize; d++) {
        const B = z[d];
        ne &= d - t >>> 31 | (B ^ I) - 1 >>> 31;
      }
      if (!ne)
        throw new Error("Bad decrypt (padding).");
      return z.slice(0, t);
    }
    _setAutoPadding(z) {
      if (this.lastSize !== 0 || this.blockPos !== 0)
        throw new Error("Cannot set auto padding.");
      this.padding = z, this.unpad = z;
    }
  }
  class p extends s {
    constructor(z) {
      super(z);
    }
    _init(z, I) {
      e(I.length === 0);
    }
    _update(z, I, ne, t) {
      this.ctx.encrypt(z, I, ne, t);
    }
    _destroy() {
    }
  }
  class g extends i {
    constructor(z) {
      super(z);
    }
    _init(z, I) {
      e(I.length === 0);
    }
    _update(z, I, ne, t) {
      this.ctx.decrypt(z, I, ne, t);
    }
    _destroy() {
    }
  }
  class S extends s {
    constructor(z) {
      super(z), this.prev = k.alloc(this.blockSize);
    }
    _init(z, I) {
      e(I.length === this.blockSize), I.copy(this.prev, 0);
    }
    _update(z, I, ne, t) {
      for (let d = 0; d < this.blockSize; d++)
        this.prev[d] ^= ne[t + d];
      this.ctx.encrypt(z, I, this.prev, 0), z.copy(this.prev, 0, I, I + this.blockSize);
    }
    _destroy() {
      for (let z = 0; z < this.blockSize; z++)
        this.prev[z] = 0;
    }
  }
  class y extends i {
    constructor(z) {
      super(z), this.prev = k.alloc(this.blockSize), this.tmp = k.alloc(this.blockSize);
    }
    _init(z, I) {
      e(I.length === this.blockSize), I.copy(this.prev, 0);
    }
    _update(z, I, ne, t) {
      if (ge(z, I, ne, t)) {
        this.prev.copy(this.tmp, 0), ne.copy(this.prev, 0, t, t + this.blockSize), this.ctx.decrypt(z, I, ne, t);
        for (let d = 0; d < this.blockSize; d++)
          z[I + d] ^= this.tmp[d];
      } else {
        this.ctx.decrypt(z, I, ne, t);
        for (let d = 0; d < this.blockSize; d++)
          z[I + d] ^= this.prev[d];
        ne.copy(this.prev, 0, t, t + this.blockSize);
      }
    }
    _destroy() {
      for (let z = 0; z < this.blockSize; z++)
        this.prev[z] = 0, this.tmp[z] = 0;
    }
  }
  class b extends f {
    constructor(z) {
      super(z, !0), this.prev = k.alloc(this.blockSize);
    }
    _init(z, I) {
      e(I.length === this.blockSize), I.copy(this.prev, 0);
    }
    _update(z, I, ne, t) {
      for (let d = 0; d < this.blockSize; d++)
        this.prev[d] ^= ne[t + d];
      this.ctx.encrypt(z, I, this.prev, 0), z.copy(this.prev, 0, I, I + this.blockSize);
    }
    _final() {
      if (!this.padding) {
        if (this.blockPos !== 0)
          throw new Error("Bad encrypt (trailing bytes).");
        return k.alloc(0);
      }
      if (this.lastSize === 0)
        throw new Error("Bad encrypt (no data).");
      for (let I = 0; I < this.blockPos; I++)
        this.prev[I] ^= this.block[I];
      this.ctx.encrypt(this.prev, 0, this.prev, 0);
      const z = this.last.slice(0, this.blockPos);
      return k.concat([this.prev, z]);
    }
    _destroy() {
      for (let z = 0; z < this.blockSize; z++)
        this.prev[z] = 0;
    }
    _setAutoPadding(z) {
      if (this.lastSize !== 0 || this.blockPos !== 0)
        throw new Error("Cannot set auto padding.");
      this.padding = z, this.unpad = z;
    }
  }
  class h extends f {
    constructor(z) {
      super(z, !0), this.prev = k.alloc(this.blockSize), this.tmp = k.alloc(this.blockSize);
    }
    _init(z, I) {
      e(I.length === this.blockSize), I.copy(this.prev, 0);
    }
    _update(z, I, ne, t) {
      if (ge(z, I, ne, t)) {
        this.prev.copy(this.tmp, 0), ne.copy(this.prev, 0, t, t + this.blockSize), this.ctx.decrypt(z, I, ne, t);
        for (let d = 0; d < this.blockSize; d++)
          z[I + d] ^= this.tmp[d];
      } else {
        this.ctx.decrypt(z, I, ne, t);
        for (let d = 0; d < this.blockSize; d++)
          z[I + d] ^= this.prev[d];
        ne.copy(this.prev, 0, t, t + this.blockSize);
      }
    }
    _final() {
      if (!this.padding) {
        if (this.blockPos !== 0)
          throw new Error("Bad decrypt (trailing bytes).");
        return k.alloc(0);
      }
      if (this.lastSize === 0)
        throw new Error("Bad decrypt (no data).");
      const z = k.alloc(this.blockSize);
      this.ctx.decrypt(this.prev, 0, this.prev, 0);
      for (let ne = 0; ne < this.blockSize; ne++)
        z[ne] = this.last[ne] ^ this.prev[ne];
      for (let ne = 0; ne < this.blockPos; ne++)
        this.last[ne] = this.block[ne], this.block[ne] ^= this.prev[ne];
      for (let ne = this.blockPos; ne < this.blockSize; ne++)
        this.last[ne] = this.prev[ne];
      this.ctx.decrypt(this.last, 0, this.last, 0);
      for (let ne = 0; ne < this.blockSize; ne++)
        this.last[ne] ^= z[ne];
      const I = this.block.slice(0, this.blockPos);
      return k.concat([this.last, I]);
    }
    _destroy() {
      for (let z = 0; z < this.blockSize; z++)
        this.prev[z] = 0, this.tmp[z] = 0;
    }
    _setAutoPadding(z) {
      if (this.lastSize !== 0 || this.blockPos !== 0)
        throw new Error("Cannot set auto padding.");
      this.padding = z, this.unpad = z;
    }
  }
  class a extends f {
    constructor(z, I) {
      super(z, !0), this.encrypt = I, this.poly = w[this.blockSize >>> 4], this.tweak = k.alloc(this.blockSize), this.prev = k.alloc(this.blockSize);
    }
    init(z, I) {
      e(k.isBuffer(z)), e(k.isBuffer(I)), e(z.length > 0 && (z.length & 1) === 0), e(I.length === this.blockSize);
      const ne = z.length >>> 1, t = z.slice(0, ne), d = z.slice(ne);
      if (Ee(t, d, ne))
        throw new Error("XTS keys are equal.");
      return this.ctx.init(d), this.ctx.encrypt(this.tweak, 0, I, 0), this.ctx.init(t), this.blockPos = 0, this.lastSize = 0, this;
    }
    _shift() {
      let z = 0;
      this.encrypt || this.tweak.copy(this.prev, 0);
      for (let I = 0; I < this.blockSize; I++) {
        const ne = this.tweak[I] >> 7;
        this.tweak[I] <<= 1, this.tweak[I] |= z, z = ne;
      }
      z = -z & 255, this.tweak[2] ^= this.poly >> 16 & z, this.tweak[1] ^= this.poly >> 8 & z, this.tweak[0] ^= this.poly >> 0 & z;
    }
    _update(z, I, ne, t) {
      for (let d = 0; d < this.blockSize; d++)
        z[I + d] = ne[t + d] ^ this.tweak[d];
      this.encrypt ? this.ctx.encrypt(z, I, z, I) : this.ctx.decrypt(z, I, z, I);
      for (let d = 0; d < this.blockSize; d++)
        z[I + d] ^= this.tweak[d];
      this._shift();
    }
    _destroy() {
      for (let z = 0; z < this.blockSize; z++)
        this.tweak[z] = 0, this.prev[z] = 0;
    }
    _setAutoPadding(z) {
      if (this.lastSize !== 0 || this.blockPos !== 0)
        throw new Error("Cannot set auto padding.");
      this.padding = z, this.unpad = z;
    }
  }
  class E extends a {
    constructor(z) {
      super(z, !0);
    }
    _final() {
      if (!this.padding) {
        if (this.blockPos !== 0)
          throw new Error("Bad encrypt (trailing bytes).");
        return k.alloc(0);
      }
      if (this.lastSize === 0)
        throw new Error("Bad encrypt (no data).");
      if (this.blockPos === 0)
        return k.from(this.last);
      const z = k.alloc(this.blockPos);
      for (let I = 0; I < this.blockPos; I++)
        z[I] = this.last[I], this.last[I] = this.block[I];
      for (let I = 0; I < this.blockSize; I++)
        this.last[I] ^= this.tweak[I];
      this.ctx.encrypt(this.last, 0, this.last, 0);
      for (let I = 0; I < this.blockSize; I++)
        this.last[I] ^= this.tweak[I];
      return k.concat([this.last, z]);
    }
  }
  class H extends a {
    constructor(z) {
      super(z, !1);
    }
    _final() {
      if (!this.padding) {
        if (this.blockPos !== 0)
          throw new Error("Bad decrypt (trailing bytes).");
        return k.alloc(0);
      }
      if (this.lastSize === 0)
        throw new Error("Bad decrypt (no data).");
      if (this.blockPos === 0)
        return k.from(this.last);
      for (let I = 0; I < this.blockSize; I++)
        this.last[I] ^= this.prev[I];
      this.ctx.encrypt(this.last, 0, this.last, 0);
      for (let I = 0; I < this.blockSize; I++)
        this.last[I] ^= this.prev[I];
      for (let I = 0; I < this.blockSize; I++)
        this.last[I] ^= this.tweak[I];
      this.ctx.decrypt(this.last, 0, this.last, 0);
      for (let I = 0; I < this.blockSize; I++)
        this.last[I] ^= this.tweak[I];
      const z = k.alloc(this.blockPos);
      for (let I = 0; I < this.blockPos; I++)
        z[I] = this.last[I], this.last[I] = this.block[I];
      for (let I = 0; I < this.blockSize; I++)
        this.last[I] ^= this.prev[I];
      this.ctx.decrypt(this.last, 0, this.last, 0);
      for (let I = 0; I < this.blockSize; I++)
        this.last[I] ^= this.prev[I];
      return k.concat([this.last, z]);
    }
  }
  class j extends n {
    constructor(z) {
      super(z), this.state = k.alloc(this.blockSize), this.ctr = k.alloc(this.blockSize);
    }
    _init(z, I) {
      e(I.length === this.blockSize), I.copy(this.ctr, 0);
    }
    _increment() {
      for (let z = this.ctr.length - 1; z >= 0 && (this.ctr[z] += 1, this.ctr[z] === 0); z--)
        ;
    }
    _crypt(z, I) {
      const ne = this.blockSize - 1;
      for (let t = 0; t < I.length; t++)
        (this.pos & ne) === 0 && (this.ctx.encrypt(this.state, 0, this.ctr, 0), this._increment(), this.pos = 0), z[t] = I[t] ^ this.state[this.pos++];
    }
    _final() {
      return k.alloc(0);
    }
    _destroy() {
      for (let z = 0; z < this.blockSize; z++)
        this.state[z] = 0, this.ctr[z] = 0;
    }
  }
  class G extends j {
    constructor(z) {
      super(z);
    }
  }
  class N extends j {
    constructor(z) {
      super(z);
    }
  }
  class T extends n {
    constructor(z) {
      super(z), this.state = k.alloc(this.blockSize), this.prev = k.alloc(this.blockSize);
    }
    _init(z, I) {
      e(I.length === this.blockSize), I.copy(this.prev, 0);
    }
    _final() {
      return k.alloc(0);
    }
    _destroy() {
      for (let z = 0; z < this.blockSize; z++)
        this.state[z] = 0, this.prev[z] = 0;
    }
  }
  class A extends T {
    constructor(z) {
      super(z);
    }
    _crypt(z, I) {
      const ne = this.blockSize - 1;
      for (let t = 0; t < I.length; t++)
        (this.pos & ne) === 0 && (this.ctx.encrypt(this.state, 0, this.prev, 0), this.pos = 0), z[t] = I[t] ^ this.state[this.pos], this.prev[this.pos] = z[t], this.pos += 1;
    }
  }
  class q extends T {
    constructor(z) {
      super(z);
    }
    _crypt(z, I) {
      const ne = this.blockSize - 1;
      for (let t = 0; t < I.length; t++)
        (this.pos & ne) === 0 && (this.ctx.encrypt(this.state, 0, this.prev, 0), this.pos = 0), this.prev[this.pos] = I[t], z[t] = I[t] ^ this.state[this.pos], this.pos += 1;
    }
  }
  class _ extends n {
    constructor(z) {
      super(z), this.state = k.alloc(this.blockSize);
    }
    _init(z, I) {
      e(k.isBuffer(I)), e(I.length === this.blockSize), I.copy(this.state, 0);
    }
    _crypt(z, I) {
      const ne = this.blockSize - 1;
      for (let t = 0; t < I.length; t++)
        (this.pos & ne) === 0 && (this.ctx.encrypt(this.state, 0, this.state, 0), this.pos = 0), z[t] = I[t] ^ this.state[this.pos++];
    }
    _final() {
      return k.alloc(0);
    }
    _destroy() {
      for (let z = 0; z < this.blockSize; z++)
        this.state[z] = 0;
    }
  }
  class F extends _ {
    constructor(z) {
      super(z);
    }
  }
  class R extends _ {
    constructor(z) {
      super(z);
    }
  }
  class L extends n {
    constructor(z, I) {
      e(z.blockSize === 16), super(z), this.encrypt = I, this.hash = new c(), this.ctr = k.alloc(16), this.state = k.alloc(16), this.key = k.alloc(16), this.mask = k.alloc(16), this.tag = null, this.mac = null;
    }
    _init(z, I) {
      for (let ne = 0; ne < 16; ne++)
        this.ctr[ne] = 0, this.key[ne] = 0, this.mask[ne] = 0;
      return this._encipher(this.key, this.key), this.hash.init(this.key), I.length !== 12 && (this.hash.update(I), I = this.hash.final(), this.hash.init(this.key)), I.copy(this.ctr, 0), I.length === 12 && (this.ctr[12] = 0, this.ctr[13] = 0, this.ctr[14] = 0, this.ctr[15] = 1), this._encipher(this.mask, this.mask), this.tag = null, this.mac = null, this;
    }
    _increment() {
      let z = 1, I = 4;
      for (; I--; )
        z += this.ctr[12 + I], this.ctr[12 + I] = z, z >>= 8;
    }
    _encipher(z, I) {
      for (let ne = 0; ne < I.length; ne++)
        (this.pos & 15) === 0 && (this.ctx.encrypt(this.state, 0, this.ctr, 0), this._increment(), this.pos = 0), z[ne] = I[ne] ^ this.state[this.pos++];
    }
    _crypt(z, I) {
      this.encrypt ? (this._encipher(z, I), this.hash.update(z)) : (this.hash.update(I), this._encipher(z, I));
    }
    _final() {
      const z = this.hash.final();
      for (let I = 0; I < 16; I++)
        z[I] ^= this.mask[I];
      if (this.encrypt)
        return this.mac = z, k.alloc(0);
      if (!this.tag)
        throw new Error("No tag provided.");
      if (!Ee(z, this.tag, this.tag.length))
        throw new Error("Invalid tag.");
      return k.alloc(0);
    }
    _destroy() {
      this.hash.destroy();
      for (let z = 0; z < 16; z++)
        this.ctr[z] = 0, this.state[z] = 0, this.key[z] = 0, this.mask[z] = 0;
      if (this.tag) {
        for (let z = 0; z < this.tag.length; z++)
          this.tag[z] = 0;
        this.tag = null;
      }
    }
    _setAAD(z) {
      if (this.pos === -1)
        throw new Error("Cipher is not initialized.");
      return this.hash.aad(z), this;
    }
    _getAuthTag() {
      if (!this.encrypt)
        throw new Error("Must be a cipher context.");
      if (!this.mac)
        throw new Error("Cipher is not finalized.");
      return k.from(this.mac);
    }
    _setAuthTag(z) {
      if (this.encrypt)
        throw new Error("Must be a decipher context.");
      if (this.pos === -1)
        throw new Error("Cipher is not initialized.");
      if (z.length !== 4 && z.length !== 8 && (z.length < 12 || z.length > 16))
        throw new RangeError("Invalid tag size.");
      return this.tag = k.from(z), this;
    }
  }
  class fe extends L {
    constructor(z) {
      super(z, !0);
    }
  }
  class ue extends L {
    constructor(z) {
      super(z, !1);
    }
  }
  class ae {
    constructor(z) {
      this.ctx = z, this.size = z.blockSize, this.mac = k.alloc(this.size), this.pos = -1;
    }
    init() {
      return this.mac.fill(0), this.pos = 0, this;
    }
    update(z) {
      if (e(k.isBuffer(z)), this.pos === -1)
        throw new Error("Context is not initialized.");
      for (let I = 0; I < z.length; I++)
        this.mac[this.pos++] ^= z[I], this.pos === this.size && (this.ctx.encrypt(this.mac, 0, this.mac, 0), this.pos = 0);
    }
    pad() {
      this.pos > 0 && (this.ctx.encrypt(this.mac, 0, this.mac, 0), this.pos = 0);
    }
    final() {
      if (this.pos === -1)
        throw new Error("Context is not initialized.");
      return this.pad(), this.pos = -1, k.from(this.mac);
    }
  }
  class D extends n {
    constructor(z, I) {
      e(z.blockSize === 16), super(z), this.encrypt = I, this.hash = new ae(z), this.state = k.alloc(16), this.ctr = k.alloc(16), this.tagLen = 0, this.iv = null, this.mac = null, this.tag = null;
    }
    _increment() {
      for (let z = 15; z >= 1 && (this.ctr[z] += 1, this.ctr[z] === 0); z--)
        ;
    }
    _encipher(z, I) {
      for (let ne = 0; ne < I.length; ne++)
        (this.pos & 15) === 0 && (this.ctx.encrypt(this.state, 0, this.ctr, 0), this._increment(), this.pos = 0), z[ne] = I[ne] ^ this.state[this.pos++];
    }
    _init(z, I) {
      if (I.length < 7)
        throw new RangeError("Invalid nonce length.");
      I.length > 13 && (I = I.slice(0, 13)), this.iv = k.from(I), this.pos = -1, this.tagLen = 0, this.mac = null, this.tag = null;
    }
    _setCCM(z, I, ne) {
      if (!this.iv)
        throw new Error("Cipher is not initialized.");
      let t = z, d = Math.ceil((32 - Math.clz32(t)) / 8);
      d < 2 && (d = 2);
      const B = I, U = 15 - d, J = (ne && ne.length > 0) | 0, C = k.alloc(16);
      if (B < 4 || B > 16 || (B & 1) !== 0)
        throw new RangeError("Invalid tag length.");
      C[0] = 64 * J + 8 * ((B - 2) / 2) + (d - 1), this.iv.copy(C, 1, 0, Math.min(U, this.iv.length));
      for (let M = 15; M >= 1 + U; M--)
        C[M] = t & 255, t >>>= 8;
      if (e(t === 0), this.hash.init(), this.hash.update(C), J) {
        if (ne.length < 65280) {
          const M = k.alloc(2);
          M[0] = ne.length >>> 8, M[1] = ne.length >>> 0, this.hash.update(M);
        } else if (ne.length < 4294967295) {
          const M = k.alloc(6);
          M[0] = 255, M[1] = 254, M[2] = ne.length >>> 24, M[3] = ne.length >>> 16, M[4] = ne.length >>> 8, M[5] = ne.length >>> 0, this.hash.update(M);
        } else
          throw new RangeError("Invalid AAD length.");
        this.hash.update(ne), this.hash.pad();
      }
      C[0] &= 7, C[15] = 1;
      for (let M = 14; M >= 1 + U; M--)
        C[M] = 0;
      C.copy(this.ctr, 0), this.pos = 0, this.tagLen = B, this.iv = null;
    }
    _crypt(z, I) {
      this.encrypt ? (this.hash.update(I), this._encipher(z, I)) : (this._encipher(z, I), this.hash.update(z));
    }
    _final() {
      const z = this.hash.final();
      let I = 16 - ((this.ctr[0] & 7) + 1);
      for (; I < 16; )
        this.ctr[I++] = 0;
      if (this.pos = 0, this._encipher(z, z), this.encrypt)
        return this.mac = z.slice(0, this.tagLen), k.alloc(0);
      if (!this.tag)
        throw new Error("No tag provided.");
      if (!Ee(z, this.tag, this.tagLen))
        throw new Error("Invalid tag.");
      return k.alloc(0);
    }
    _destroy() {
      for (let z = 0; z < 16; z++)
        this.state[z] = 0, this.ctr[z] = 0;
      this.tagLen = 0, this.iv = null, this.tag = null;
    }
    _getAuthTag() {
      if (!this.encrypt)
        throw new Error("Must be a cipher context.");
      if (!this.mac)
        throw new Error("Cipher is not finalized.");
      return k.from(this.mac);
    }
    _setAuthTag(z) {
      if (this.encrypt)
        throw new Error("Must be a decipher context.");
      if (this.pos === -1)
        throw new Error("Cipher is not initialized.");
      if (this.tagLen === 0 || z.length !== this.tagLen)
        throw new RangeError("Invalid tag size.");
      return this.tag = k.from(z), this;
    }
  }
  class Q extends D {
    constructor(z) {
      super(z, !0);
    }
  }
  class W extends D {
    constructor(z) {
      super(z, !1);
    }
  }
  class oe {
    constructor(z) {
      this.ctx = z, this.poly = w[z.blockSize >>> 4], this.size = z.blockSize, this.mac = k.alloc(this.size), this.pos = -1;
    }
    init(z) {
      return this.mac.fill(0), this.pos = 0, z != null && (this.mac[this.size - 1] ^= z, this.pos = this.size), this;
    }
    shift(z, I) {
      let ne = 0;
      for (let t = this.size - 1; t >= 0; t--) {
        const d = I[t] >> 7;
        z[t] = I[t] << 1 | ne, ne = d;
      }
      ne = -ne & 255, z[this.size - 3] ^= this.poly >> 16 & ne, z[this.size - 2] ^= this.poly >> 8 & ne, z[this.size - 1] ^= this.poly >> 0 & ne;
    }
    update(z) {
      if (e(k.isBuffer(z)), this.pos === -1)
        throw new Error("Context is not initialized.");
      for (let I = 0; I < z.length; I++)
        this.pos === this.size && (this.ctx.encrypt(this.mac, 0, this.mac, 0), this.pos = 0), this.mac[this.pos++] ^= z[I];
    }
    final() {
      if (this.pos === -1)
        throw new Error("Context is not initialized.");
      const z = k.alloc(this.size);
      this.ctx.encrypt(z, 0, z, 0), this.shift(z, z), this.pos < this.size && (this.mac[this.pos] ^= 128, this.shift(z, z));
      for (let I = 0; I < this.size; I++)
        this.mac[I] ^= z[I];
      return this.ctx.encrypt(this.mac, 0, this.mac, 0), this.pos = -1, k.from(this.mac);
    }
  }
  class v extends n {
    constructor(z, I) {
      super(z), this.encrypt = I, this.hash1 = new oe(z), this.hash2 = new oe(z), this.state = k.alloc(this.blockSize), this.ctr = k.alloc(this.blockSize), this.mask = k.alloc(this.blockSize), this.mac = null, this.tag = null;
    }
    _increment() {
      let z = this.blockSize, I = 1;
      for (; z--; )
        I += this.ctr[z], this.ctr[z] = I, I >>= 8;
    }
    _encipher(z, I) {
      const ne = this.blockSize - 1;
      for (let t = 0; t < I.length; t++)
        (this.pos & ne) === 0 && (this.ctx.encrypt(this.state, 0, this.ctr, 0), this._increment(), this.pos = 0), z[t] = I[t] ^ this.state[this.pos++];
    }
    _init(z, I) {
      e(I.length > 0), this.hash1.init(0), this.hash1.update(I), this.mask = this.hash1.final(), this.mask.copy(this.ctr, 0), this.hash1.init(1), this.hash2.init(2), this.mac = null, this.tag = null;
    }
    _crypt(z, I) {
      this.encrypt ? (this._encipher(z, I), this.hash2.update(z)) : (this.hash2.update(I), this._encipher(z, I));
    }
    _final() {
      const z = k.alloc(this.blockSize), I = this.hash1.final(), ne = this.hash2.final();
      for (let t = 0; t < this.blockSize; t++)
        z[t] = I[t] ^ ne[t] ^ this.mask[t];
      if (this.encrypt)
        return this.mac = z, k.alloc(0);
      if (!this.tag)
        throw new Error("No tag provided.");
      if (!Ee(z, this.tag, this.tag.length))
        throw new Error("Invalid tag.");
      return k.alloc(0);
    }
    _destroy() {
      for (let z = 0; z < this.blockSize; z++)
        this.state[z] = 0, this.ctr[z] = 0, this.mask[z] = 0;
      this.tag = null;
    }
    _setAAD(z) {
      if (this.pos === -1)
        throw new Error("Cipher is not initialized.");
      return this.hash1.update(z), this;
    }
    _getAuthTag() {
      if (!this.encrypt)
        throw new Error("Must be a cipher context.");
      if (!this.mac)
        throw new Error("Cipher is not finalized.");
      return k.from(this.mac);
    }
    _setAuthTag(z) {
      if (this.encrypt)
        throw new Error("Must be a decipher context.");
      if (this.pos === -1)
        throw new Error("Cipher is not initialized.");
      if (z.length === 0 || z.length > this.blockSize)
        throw new RangeError("Invalid tag size.");
      return this.tag = k.from(z), this;
    }
  }
  class Y extends v {
    constructor(z) {
      super(z, !0);
    }
  }
  class he extends v {
    constructor(z) {
      super(z, !1);
    }
  }
  function le(we, z = !0) {
    switch (e(typeof we == "string"), e(typeof z == "boolean"), we) {
      case "RAW":
        return z ? u : o;
      case "ECB":
        return z ? p : g;
      case "CBC":
        return z ? S : y;
      case "CTS":
        return z ? b : h;
      case "XTS":
        return z ? E : H;
      case "CTR":
        return z ? G : N;
      case "CFB":
        return z ? A : q;
      case "OFB":
        return z ? F : R;
      case "GCM":
        return z ? fe : ue;
      case "CCM":
        return z ? Q : W;
      case "EAX":
        return z ? Y : he;
      default:
        throw new Error(`Unknown mode: ${we}.`);
    }
  }
  function ge(we, z, I, ne) {
    return we.buffer === I.buffer && we.byteOffset === I.byteOffset && z === ne;
  }
  function Ee(we, z, I) {
    let ne = 0;
    for (let t = 0; t < I; t++)
      ne |= we[t] ^ z[t];
    return ne - 1 >>> 31;
  }
  return vt.Mode = m, vt.Block = f, vt.Stream = n, vt.RawCipher = u, vt.RawDecipher = o, vt.PKCS7Cipher = s, vt.PKCS7Decipher = i, vt.ECBCipher = p, vt.ECBDecipher = g, vt.CBCCipher = S, vt.CBCDecipher = y, vt.CTSCipher = b, vt.CTSDecipher = h, vt.XTS = a, vt.XTSCipher = E, vt.XTSDecipher = H, vt.CTR = j, vt.CTRCipher = G, vt.CTRDecipher = N, vt.CFB = T, vt.CFBCipher = A, vt.CFBDecipher = q, vt.OFB = _, vt.OFBCipher = F, vt.OFBDecipher = R, vt.GCM = L, vt.GCMCipher = fe, vt.GCMDecipher = ue, vt.CBCMAC = ae, vt.CCM = D, vt.CCMCipher = Q, vt.CCMDecipher = W, vt.CMAC = oe, vt.EAX = v, vt.EAXCipher = Y, vt.EAXDecipher = he, vt.get = le, vt;
}
var Ub;
function w1() {
  if (Ub) return Kn;
  Ub = 1;
  const e = Dy(), { CBCCipher: c, CBCDecipher: l } = Fy();
  function w(f, n, u) {
    const o = new c(new e(256));
    return o.init(n, u), k.concat([o.update(f), o.final()]);
  }
  function m(f, n, u) {
    const o = new l(new e(256));
    return o.init(n, u), k.concat([o.update(f), o.final()]);
  }
  return Kn.native = 0, Kn.encipher = w, Kn.decipher = m, Kn;
}
/*!
 * path.js - path object for wallets
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var Nh, Fb;
function Mo() {
  if (Fb) return Nh;
  Fb = 1;
  const e = Xe(), c = At(), l = Gr(), { encoding: w } = c, { inspectSymbol: m } = Kt();
  class f {
    /**
     * Create a path.
     * @constructor
     * @param {Object?} options
     */
    constructor(u) {
      this.keyType = f.types.HD, this.name = null, this.account = 0, this.type = l.types.PUBKEYHASH, this.version = -1, this.branch = -1, this.index = -1, this.encrypted = !1, this.data = null, this.hash = null, u && this.fromOptions(u);
    }
    /**
     * Instantiate path from options object.
     * @private
     * @param {Object} options
     * @returns {Path}
     */
    fromOptions(u) {
      return this.keyType = u.keyType, this.name = u.name, this.account = u.account, this.branch = u.branch, this.index = u.index, this.encrypted = u.encrypted, this.data = u.data, this.type = u.type, this.version = u.version, this.hash = u.hash, this;
    }
    /**
     * Instantiate path from options object.
     * @param {Object} options
     * @returns {Path}
     */
    static fromOptions(u) {
      return new this().fromOptions(u);
    }
    /**
     * Clone the path object.
     * @returns {Path}
     */
    clone() {
      const u = new this.constructor();
      return u.keyType = this.keyType, u.name = this.name, u.account = this.account, u.branch = this.branch, u.index = this.index, u.encrypted = this.encrypted, u.data = this.data, u.type = this.type, u.version = this.version, u.hash = this.hash, u;
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     */
    fromRaw(u) {
      const o = c.read(u);
      this.account = o.readU32(), this.keyType = o.readU8();
      const s = o.readU8();
      switch (this.type = s & 7, this.version = s >>> 3, this.version === 31 && (this.version = -1), this.keyType) {
        case f.types.HD:
          this.branch = o.readU32(), this.index = o.readU32();
          break;
        case f.types.KEY:
          this.encrypted = o.readU8() === 1, this.data = o.readVarBytes();
          break;
        case f.types.ADDRESS:
          break;
        default:
          e(!1);
          break;
      }
      return this;
    }
    /**
     * Instantiate path from serialized data.
     * @param {Buffer} data
     * @returns {Path}
     */
    static fromRaw(u) {
      return new this().fromRaw(u);
    }
    /**
     * Calculate serialization size.
     * @returns {Number}
     */
    getSize() {
      let u = 0;
      switch (u += 6, this.keyType) {
        case f.types.HD:
          u += 8;
          break;
        case f.types.KEY:
          u += 1, u += w.sizeVarBytes(this.data);
          break;
      }
      return u;
    }
    /**
     * Serialize path.
     * @returns {Buffer}
     */
    toRaw() {
      const u = this.getSize(), o = c.write(u);
      o.writeU32(this.account), o.writeU8(this.keyType);
      let s = this.version;
      s === -1 && (s = 31);
      const i = s << 3 | this.type;
      switch (o.writeU8(i), this.keyType) {
        case f.types.HD:
          e(!this.data), e(this.index !== -1), o.writeU32(this.branch), o.writeU32(this.index);
          break;
        case f.types.KEY:
          e(this.data), e(this.index === -1), o.writeU8(this.encrypted ? 1 : 0), o.writeVarBytes(this.data);
          break;
        case f.types.ADDRESS:
          e(!this.data), e(this.index === -1);
          break;
        default:
          e(!1);
          break;
      }
      return o.render();
    }
    /**
     * Inject properties from address.
     * @private
     * @param {Account} account
     * @param {Address} address
     */
    fromAddress(u, o) {
      return this.keyType = f.types.ADDRESS, this.name = u.name, this.account = u.accountIndex, this.version = o.version, this.type = o.type, this.hash = o.getHash(), this;
    }
    /**
     * Instantiate path from address.
     * @param {Account} account
     * @param {Address} address
     * @returns {Path}
     */
    static fromAddress(u, o) {
      return new this().fromAddress(u, o);
    }
    /**
     * Convert path object to string derivation path.
     * @returns {String}
     */
    toPath() {
      return this.keyType !== f.types.HD ? null : `m/${this.account}'/${this.branch}/${this.index}`;
    }
    /**
     * Convert path object to an address (currently unused).
     * @returns {Address}
     */
    toAddress() {
      return l.fromHash(this.hash, this.type, this.version);
    }
    /**
     * Convert path to a json-friendly object.
     * @returns {Object}
     */
    toJSON() {
      return {
        name: this.name,
        account: this.account,
        change: this.branch === 1,
        derivation: this.toPath()
      };
    }
    /**
     * Inspect the path.
     * @returns {String}
     */
    [m]() {
      return `<Path: ${this.name}:${this.toPath()}>`;
    }
  }
  return f.types = {
    HD: 0,
    KEY: 1,
    ADDRESS: 2
  }, f.typesByVal = [
    "HD",
    "KEY",
    "ADDRESS"
  ], Nh = f, Nh;
}
var qh = {};
/*!
 * common.js - commonly required functions for wallet.
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var Hb;
function y1() {
  return Hb || (Hb = 1, function(e) {
    const { BufferMap: c } = $r(), l = e;
    l.isName = function(m) {
      if (typeof m != "string" || m.length === 0 || !/^[\-\._0-9A-Za-z]+$/.test(m))
        return !1;
      switch (m[0]) {
        case "_":
        case "-":
        case ".":
          return !1;
      }
      switch (m[m.length - 1]) {
        case "_":
        case "-":
        case ".":
          return !1;
      }
      return m.length >= 1 && m.length <= 40;
    }, l.sortTX = function(m) {
      return m.sort((f, n) => f.mtime - n.mtime);
    }, l.sortCoins = function(m) {
      return m.sort((f, n) => (f = f.height === -1 ? 2147483647 : f.height, n = n.height === -1 ? 2147483647 : n.height, f - n));
    }, l.sortDeps = function(m) {
      const f = new c();
      for (const i of m) {
        const p = i.hash();
        f.set(p, i);
      }
      const n = new c(), u = new c(), o = [];
      for (const [i, p] of f) {
        u.set(i, 0);
        let g = !1;
        for (const S of p.inputs) {
          const y = S.prevout.hash;
          if (!f.has(y))
            continue;
          const b = u.get(i);
          u.set(i, b + 1), g = !0, n.has(y) || n.set(y, []), n.get(y).push(p);
        }
        g || o.push(p);
      }
      const s = [];
      for (const i of o) {
        const p = n.get(i.hash());
        if (s.push(i), !!p)
          for (const g of p) {
            let S = u.get(g.hash());
            --S === 0 && o.push(g), u.set(g.hash(), S);
          }
      }
      return s;
    };
  }(qh)), qh;
}
var Ms = { exports: {} };
/*!
 * records.js - walletdb records
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var Lb;
function Fp() {
  return Lb || (Lb = 1, function(e, c) {
    const l = Xe(), w = At(), m = Qt(), f = In(), n = Lt();
    class u {
      /**
       * Create a chain state.
       * @constructor
       */
      constructor() {
        this.startHeight = 0, this.startHash = n.ZERO_HASH, this.height = 0, this.marked = !1;
      }
      /**
       * Clone the state.
       * @returns {ChainState}
       */
      clone() {
        const g = new u();
        return g.startHeight = this.startHeight, g.startHash = this.startHash, g.height = this.height, g.marked = this.marked, g;
      }
      /**
       * Inject properties from serialized data.
       * @private
       * @param {Buffer} data
       */
      fromRaw(g) {
        const S = w.read(g);
        return this.startHeight = S.readU32(), this.startHash = S.readHash(), this.height = S.readU32(), this.marked = S.readU8() === 1, this;
      }
      /**
       * Instantiate chain state from serialized data.
       * @param {Hash} hash
       * @param {Buffer} data
       * @returns {ChainState}
       */
      static fromRaw(g) {
        return new this().fromRaw(g);
      }
      /**
       * Serialize the chain state.
       * @returns {Buffer}
       */
      toRaw() {
        const g = w.write(41);
        return g.writeU32(this.startHeight), g.writeHash(this.startHash), g.writeU32(this.height), g.writeU8(this.marked ? 1 : 0), g.render();
      }
    }
    class o {
      /**
       * Create block meta.
       * @constructor
       * @param {Hash} hash
       * @param {Number} height
       * @param {Number} time
       */
      constructor(g, S, y) {
        this.hash = g || n.ZERO_HASH, this.height = S ?? -1, this.time = y || 0;
      }
      /**
       * Clone the block.
       * @returns {BlockMeta}
       */
      clone() {
        return new this.constructor(this.hash, this.height, this.time);
      }
      /**
       * Get block meta hash as a buffer.
       * @returns {Buffer}
       */
      toHash() {
        return this.hash;
      }
      /**
       * Instantiate block meta from chain entry.
       * @private
       * @param {ChainEntry} entry
       */
      fromEntry(g) {
        return this.hash = g.hash, this.height = g.height, this.time = g.time, this;
      }
      /**
       * Instantiate block meta from json object.
       * @private
       * @param {Object} json
       */
      fromJSON(g) {
        return this.hash = m.revHex(g.hash), this.height = g.height, this.time = g.time, this;
      }
      /**
       * Instantiate block meta from serialized tip data.
       * @private
       * @param {Buffer} data
       */
      fromRaw(g) {
        const S = w.read(g);
        return this.hash = S.readHash(), this.height = S.readU32(), this.time = S.readU32(), this;
      }
      /**
       * Instantiate block meta from chain entry.
       * @param {ChainEntry} entry
       * @returns {BlockMeta}
       */
      static fromEntry(g) {
        return new this().fromEntry(g);
      }
      /**
       * Instantiate block meta from json object.
       * @param {Object} json
       * @returns {BlockMeta}
       */
      static fromJSON(g) {
        return new this().fromJSON(g);
      }
      /**
       * Instantiate block meta from serialized data.
       * @param {Hash} hash
       * @param {Buffer} data
       * @returns {BlockMeta}
       */
      static fromRaw(g) {
        return new this().fromRaw(g);
      }
      /**
       * Serialize the block meta.
       * @returns {Buffer}
       */
      toRaw() {
        const g = w.write(42);
        return g.writeHash(this.hash), g.writeU32(this.height), g.writeU32(this.time), g.render();
      }
      /**
       * Convert the block meta to a more json-friendly object.
       * @returns {Object}
       */
      toJSON() {
        return {
          hash: m.revHex(this.hash),
          height: this.height,
          time: this.time
        };
      }
    }
    class s {
      /**
       * Create tx record.
       * @constructor
       * @param {TX} tx
       * @param {BlockMeta?} block
       */
      constructor(g, S) {
        this.tx = null, this.hash = null, this.mtime = m.now(), this.height = -1, this.block = null, this.index = -1, this.time = 0, g && this.fromTX(g, S);
      }
      /**
       * Inject properties from tx and block.
       * @private
       * @param {TX} tx
       * @param {Block?} block
       * @returns {TXRecord}
       */
      fromTX(g, S) {
        return this.tx = g, this.hash = g.hash(), S && this.setBlock(S), this;
      }
      /**
       * Instantiate tx record from tx and block.
       * @param {TX} tx
       * @param {Block?} block
       * @returns {TXRecord}
       */
      static fromTX(g, S) {
        return new this().fromTX(g, S);
      }
      /**
       * Set block data (confirm).
       * @param {BlockMeta} block
       */
      setBlock(g) {
        this.height = g.height, this.block = g.hash, this.time = g.time;
      }
      /**
       * Unset block (unconfirm).
       */
      unsetBlock() {
        this.height = -1, this.block = null, this.time = 0;
      }
      /**
       * Convert tx record to a block meta.
       * @returns {BlockMeta}
       */
      getBlock() {
        return this.height === -1 ? null : new o(this.block, this.height, this.time);
      }
      /**
       * Calculate current number of transaction confirmations.
       * @param {Number} height - Current chain height.
       * @returns {Number} confirmations
       */
      getDepth(g) {
        return l(typeof g == "number", "Must pass in height."), this.height === -1 || g < this.height ? 0 : g - this.height + 1;
      }
      /**
       * Get serialization size.
       * @returns {Number}
       */
      getSize() {
        let g = 0;
        return g += this.tx.getSize(), g += 4, this.block ? (g += 1, g += 32, g += 12) : g += 1, g;
      }
      /**
       * Serialize a transaction to "extended format".
       * @returns {Buffer}
       */
      toRaw() {
        const g = this.getSize(), S = w.write(g);
        let y = this.index;
        return this.tx.toWriter(S), S.writeU32(this.mtime), this.block ? (y === -1 && (y = 2147483647), S.writeU8(1), S.writeHash(this.block), S.writeU32(this.height), S.writeU32(this.time), S.writeU32(y)) : S.writeU8(0), S.render();
      }
      /**
       * Inject properties from "extended" format.
       * @private
       * @param {Buffer} data
       */
      fromRaw(g) {
        const S = w.read(g);
        return this.tx = new f(), this.tx.fromReader(S), this.hash = this.tx.hash(), this.mtime = S.readU32(), S.readU8() === 1 && (this.block = S.readHash(), this.height = S.readU32(), this.time = S.readU32(), this.index = S.readU32(), this.index === 2147483647 && (this.index = -1)), this;
      }
      /**
       * Instantiate a transaction from a buffer
       * in "extended" serialization format.
       * @param {Buffer} data
       * @returns {TX}
       */
      static fromRaw(g) {
        return new this().fromRaw(g);
      }
    }
    class i {
      /**
       * Create map record.
       * @constructor
       */
      constructor() {
        this.wids = /* @__PURE__ */ new Set();
      }
      add(g) {
        return this.wids.has(g) ? !1 : (this.wids.add(g), !0);
      }
      remove(g) {
        return this.wids.delete(g);
      }
      toWriter(g) {
        g.writeU32(this.wids.size);
        for (const S of this.wids)
          g.writeU32(S);
        return g;
      }
      getSize() {
        return 4 + this.wids.size * 4;
      }
      toRaw() {
        const g = this.getSize();
        return this.toWriter(w.write(g)).render();
      }
      fromReader(g) {
        const S = g.readU32();
        for (let y = 0; y < S; y++)
          this.wids.add(g.readU32());
        return this;
      }
      fromRaw(g) {
        return this.fromReader(w.read(g));
      }
      static fromReader(g) {
        return new this().fromReader(g);
      }
      static fromRaw(g) {
        return new this().fromRaw(g);
      }
    }
    c.ChainState = u, c.BlockMeta = o, c.TXRecord = s, c.MapRecord = i, e.exports = c;
  }(Ms, Ms.exports)), Ms.exports;
}
var Ns = {};
/*!
 * layout.js - data layout for wallets
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var Kb;
function Hp() {
  if (Kb) return Ns;
  Kb = 1;
  const e = Up();
  return Ns.wdb = {
    V: e.key("V"),
    O: e.key("O"),
    R: e.key("R"),
    D: e.key("D"),
    p: e.key("p", ["hash"]),
    P: e.key("P", ["uint32", "hash"]),
    r: e.key("r", ["uint32", "uint32", "hash"]),
    w: e.key("w", ["uint32"]),
    W: e.key("W", ["uint32"]),
    l: e.key("l", ["ascii"]),
    a: e.key("a", ["uint32", "uint32"]),
    i: e.key("i", ["uint32", "ascii"]),
    n: e.key("n", ["uint32", "uint32"]),
    h: e.key("h", ["uint32"]),
    b: e.key("b", ["uint32"]),
    o: e.key("o", ["hash256", "uint32"]),
    T: e.key("T", ["hash256"]),
    t: e.key("t", ["uint32"])
  }, Ns.txdb = {
    prefix: e.key("t", ["uint32"]),
    R: e.key("R"),
    r: e.key("r", ["uint32"]),
    t: e.key("t", ["hash256"]),
    c: e.key("c", ["hash256", "uint32"]),
    d: e.key("d", ["hash256", "uint32"]),
    s: e.key("s", ["hash256", "uint32"]),
    p: e.key("p", ["hash256"]),
    m: e.key("m", ["uint32", "hash256"]),
    h: e.key("h", ["uint32", "hash256"]),
    T: e.key("T", ["uint32", "hash256"]),
    P: e.key("P", ["uint32", "hash256"]),
    M: e.key("M", ["uint32", "uint32", "hash256"]),
    H: e.key("H", ["uint32", "uint32", "hash256"]),
    C: e.key("C", ["uint32", "hash256", "uint32"]),
    b: e.key("b", ["uint32"])
  }, Ns;
}
var Th, Vb;
function Hy() {
  if (Vb) return Th;
  Vb = 1;
  const e = Xe(), c = At(), { BufferSet: l } = $r(), w = Qt(), m = wi(), f = Oo(), n = cs(), u = Ei(), o = Fp(), s = Hp().txdb, i = Lt(), p = vi(), { TXRecord: g } = o, { inspectSymbol: S } = Kt();
  class y {
    /**
     * Create a TXDB.
     * @constructor
     * @param {WalletDB} wdb
     */
    constructor(N, T) {
      this.wdb = N, this.db = N.db, this.logger = N.logger, this.wid = T || 0, this.bucket = null, this.wallet = null, this.locked = new l();
    }
    /**
     * Open TXDB.
     * @returns {Promise}
     */
    async open(N) {
      const T = s.prefix.encode(N.wid);
      this.wid = N.wid, this.bucket = this.db.bucket(T), this.wallet = N;
    }
    /**
     * Emit transaction event.
     * @private
     * @param {String} event
     * @param {Object} data
     * @param {Details} details
     */
    emit(N, T, A) {
      this.wdb.emit(N, this.wallet, T, A), this.wallet.emit(N, T, A);
    }
    /**
     * Get wallet path for output.
     * @param {Output} output
     * @returns {Promise} - Returns {@link Path}.
     */
    getPath(N) {
      const T = N.getHash();
      return T ? this.wdb.getPath(this.wid, T) : null;
    }
    /**
     * Test whether path exists for output.
     * @param {Output} output
     * @returns {Promise} - Returns Boolean.
     */
    hasPath(N) {
      const T = N.getHash();
      return T ? this.wdb.hasPath(this.wid, T) : !1;
    }
    /**
     * Save credit.
     * @param {Credit} credit
     * @param {Path} path
     */
    async saveCredit(N, T, A) {
      const { coin: q } = T;
      return N.put(s.c.encode(q.hash, q.index), T.toRaw()), N.put(s.C.encode(A.account, q.hash, q.index), null), this.addOutpointMap(N, q.hash, q.index);
    }
    /**
     * Remove credit.
     * @param {Credit} credit
     * @param {Path} path
     */
    async removeCredit(N, T, A) {
      const { coin: q } = T;
      return N.del(s.c.encode(q.hash, q.index)), N.del(s.C.encode(A.account, q.hash, q.index)), this.removeOutpointMap(N, q.hash, q.index);
    }
    /**
     * Spend credit.
     * @param {Credit} credit
     * @param {TX} tx
     * @param {Number} index
     */
    spendCredit(N, T, A, q) {
      const _ = A.inputs[q].prevout, F = u.fromTX(A, q);
      N.put(s.s.encode(_.hash, _.index), F.toRaw()), N.put(s.d.encode(F.hash, F.index), T.coin.toRaw());
    }
    /**
     * Unspend credit.
     * @param {TX} tx
     * @param {Number} index
     */
    unspendCredit(N, T, A) {
      const q = T.inputs[A].prevout, _ = u.fromTX(T, A);
      N.del(s.s.encode(q.hash, q.index)), N.del(s.d.encode(_.hash, _.index));
    }
    /**
     * Write input record.
     * @param {TX} tx
     * @param {Number} index
     */
    async writeInput(N, T, A) {
      const q = T.inputs[A].prevout, _ = u.fromTX(T, A);
      return N.put(s.s.encode(q.hash, q.index), _.toRaw()), this.addOutpointMap(N, q.hash, q.index);
    }
    /**
     * Remove input record.
     * @param {TX} tx
     * @param {Number} index
     */
    async removeInput(N, T, A) {
      const q = T.inputs[A].prevout;
      return N.del(s.s.encode(q.hash, q.index)), this.removeOutpointMap(N, q.hash, q.index);
    }
    /**
     * Update wallet balance.
     * @param {BalanceDelta} state
     */
    async updateBalance(N, T) {
      const A = await this.getWalletBalance();
      return T.applyTo(A), N.put(s.R.encode(), A.toRaw()), A;
    }
    /**
     * Update account balance.
     * @param {Number} acct
     * @param {Balance} delta
     */
    async updateAccountBalance(N, T, A) {
      const q = await this.getAccountBalance(T);
      return A.applyTo(q), N.put(s.r.encode(T), q.toRaw()), q;
    }
    /**
     * Test a whether a coin has been spent.
     * @param {Hash} hash
     * @param {Number} index
     * @returns {Promise} - Returns Boolean.
     */
    async getSpent(N, T) {
      const A = await this.bucket.get(s.s.encode(N, T));
      return A ? u.fromRaw(A) : null;
    }
    /**
     * Test a whether a coin has been spent.
     * @param {Hash} hash
     * @param {Number} index
     * @returns {Promise} - Returns Boolean.
     */
    isSpent(N, T) {
      return this.bucket.has(s.s.encode(N, T));
    }
    /**
     * Append to global map.
     * @param {Number} height
     * @returns {Promise}
     */
    addBlockMap(N, T) {
      return this.wdb.addBlockMap(N.root(), T, this.wid);
    }
    /**
     * Remove from global map.
     * @param {Number} height
     * @returns {Promise}
     */
    removeBlockMap(N, T) {
      return this.wdb.removeBlockMap(N.root(), T, this.wid);
    }
    /**
     * Append to global map.
     * @param {Hash} hash
     * @returns {Promise}
     */
    addTXMap(N, T) {
      return this.wdb.addTXMap(N.root(), T, this.wid);
    }
    /**
     * Remove from global map.
     * @param {Hash} hash
     * @returns {Promise}
     */
    removeTXMap(N, T) {
      return this.wdb.removeTXMap(N.root(), T, this.wid);
    }
    /**
     * Append to global map.
     * @param {Hash} hash
     * @param {Number} index
     * @returns {Promise}
     */
    addOutpointMap(N, T, A) {
      return this.wdb.addOutpointMap(N.root(), T, A, this.wid);
    }
    /**
     * Remove from global map.
     * @param {Hash} hash
     * @param {Number} index
     * @returns {Promise}
     */
    removeOutpointMap(N, T, A) {
      return this.wdb.removeOutpointMap(N.root(), T, A, this.wid);
    }
    /**
     * List block records.
     * @returns {Promise}
     */
    getBlocks() {
      return this.bucket.keys({
        gte: s.b.min(),
        lte: s.b.max(),
        parse: (N) => s.b.decode(N)[0]
      });
    }
    /**
     * Get block record.
     * @param {Number} height
     * @returns {Promise}
     */
    async getBlock(N) {
      const T = await this.bucket.get(s.b.encode(N));
      return T ? j.fromRaw(T) : null;
    }
    /**
     * Append to the global block record.
     * @param {Hash} hash
     * @param {BlockMeta} block
     * @returns {Promise}
     */
    async addBlock(N, T, A) {
      const q = s.b.encode(A.height), _ = await this.bucket.get(q);
      if (!_) {
        const L = j.fromMeta(A);
        L.add(T), N.put(q, L.toRaw());
        return;
      }
      const F = k.allocUnsafe(_.length + 32);
      _.copy(F, 0);
      const R = F.readUInt32LE(40, !0);
      F.writeUInt32LE(R + 1, 40, !0), T.copy(F, _.length), N.put(q, F);
    }
    /**
     * Remove from the global block record.
     * @param {Hash} hash
     * @param {Number} height
     * @returns {Promise}
     */
    async removeBlock(N, T, A) {
      const q = s.b.encode(A), _ = await this.bucket.get(q);
      if (!_)
        return;
      const F = _.readUInt32LE(40, !0);
      if (e(F > 0), e(_.slice(-32).equals(T)), F === 1) {
        N.del(q);
        return;
      }
      const R = _.slice(0, -32);
      R.writeUInt32LE(F - 1, 40, !0), N.put(q, R);
    }
    /**
     * Remove from the global block record.
     * @param {Hash} hash
     * @param {Number} height
     * @returns {Promise}
     */
    async spliceBlock(N, T, A) {
      const q = await this.getBlock(A);
      if (q && q.remove(T)) {
        if (q.hashes.size === 0) {
          N.del(s.b.encode(A));
          return;
        }
        N.put(s.b.encode(A), q.toRaw());
      }
    }
    /**
     * Add transaction without a batch.
     * @private
     * @param {TX} tx
     * @returns {Promise}
     */
    async add(N, T) {
      const A = N.hash(), q = await this.getTX(A);
      if (e(!N.mutable, "Cannot add mutable TX to wallet."), q)
        return q.height !== -1 || !T ? null : this.confirm(q, T);
      const _ = g.fromTX(N, T);
      if (T)
        await this.removeConflicts(N, !1);
      else if (!await this.removeConflicts(N, !0))
        return null;
      return this.insert(_, T);
    }
    /**
     * Insert transaction.
     * @private
     * @param {TXRecord} wtx
     * @param {BlockMeta} block
     * @returns {Promise}
     */
    async insert(N, T) {
      const A = this.bucket.batch(), { tx: q, hash: _ } = N, F = T ? T.height : -1, R = new E(N, T), L = new h();
      let fe = !1;
      if (!q.isCoinbase())
        for (let ae = 0; ae < q.inputs.length; ae++) {
          const D = q.inputs[ae], { hash: Q, index: W } = D.prevout, oe = await this.getCredit(Q, W);
          if (!oe) {
            T || await this.writeInput(A, q, ae);
            continue;
          }
          const v = oe.coin, Y = await this.getPath(v);
          e(Y), R.setInput(ae, Y, v), this.spendCredit(A, oe, q, ae), L.tx(Y, 1), L.coin(Y, -1), L.unconfirmed(Y, -v.value), T ? (L.confirmed(Y, -v.value), await this.removeCredit(A, oe, Y)) : (oe.spent = !0, await this.saveCredit(A, oe, Y)), fe = !0;
        }
      for (let ae = 0; ae < q.outputs.length; ae++) {
        const D = q.outputs[ae], Q = await this.getPath(D);
        if (!Q)
          continue;
        R.setOutput(ae, Q);
        const W = a.fromTX(q, ae, F);
        W.own = fe, L.tx(Q, 1), L.coin(Q, 1), L.unconfirmed(Q, D.value), T && L.confirmed(Q, D.value), await this.saveCredit(A, W, Q);
      }
      if (!L.updated())
        return null;
      A.put(s.t.encode(_), N.toRaw()), A.put(s.m.encode(N.mtime, _), null), T ? A.put(s.h.encode(F, _), null) : A.put(s.p.encode(_), null);
      for (const [ae, D] of L.accounts)
        await this.updateAccountBalance(A, ae, D), A.put(s.T.encode(ae, _), null), A.put(s.M.encode(ae, N.mtime, _), null), T ? A.put(s.H.encode(ae, F, _), null) : A.put(s.P.encode(ae, _), null);
      T ? (await this.addBlockMap(A, F), await this.addBlock(A, q.hash(), T)) : await this.addTXMap(A, _);
      const ue = await this.updateBalance(A, L);
      return await A.write(), this.unlockTX(q), this.emit("tx", q, R), this.emit("balance", ue), R;
    }
    /**
     * Attempt to confirm a transaction.
     * @private
     * @param {TXRecord} wtx
     * @param {BlockMeta} block
     * @returns {Promise}
     */
    async confirm(N, T) {
      const A = this.bucket.batch(), { tx: q, hash: _ } = N, F = T.height, R = new E(N, T), L = new h();
      if (N.setBlock(T), !q.isCoinbase()) {
        const ue = await this.getSpentCredits(q);
        for (let ae = 0; ae < q.inputs.length; ae++) {
          const D = q.inputs[ae], { hash: Q, index: W } = D.prevout;
          let oe = !1;
          if (!ue[ae]) {
            await this.removeInput(A, q, ae);
            const le = await this.getCredit(Q, W);
            if (!le)
              continue;
            this.spendCredit(A, le, q, ae), ue[ae] = le, oe = !0;
          }
          const v = ue[ae], Y = v.coin;
          e(Y.height !== -1);
          const he = await this.getPath(Y);
          e(he), R.setInput(ae, he, Y), oe && (L.coin(he, -1), L.unconfirmed(he, -Y.value)), L.confirmed(he, -Y.value), await this.removeCredit(A, v, he);
        }
      }
      for (let ue = 0; ue < q.outputs.length; ue++) {
        const ae = q.outputs[ue], D = await this.getPath(ae);
        if (!D)
          continue;
        R.setOutput(ue, D);
        const Q = await this.getCredit(_, ue);
        e(Q), Q.spent && await this.updateSpentCoin(A, q, ue, F), L.confirmed(D, ae.value), Q.coin.height = F, await this.saveCredit(A, Q, D);
      }
      A.put(s.t.encode(_), N.toRaw()), A.del(s.p.encode(_)), A.put(s.h.encode(F, _), null);
      for (const [ue, ae] of L.accounts)
        await this.updateAccountBalance(A, ue, ae), A.del(s.P.encode(ue, _)), A.put(s.H.encode(ue, F, _), null);
      await this.removeTXMap(A, _), await this.addBlockMap(A, F), await this.addBlock(A, q.hash(), T);
      const fe = await this.updateBalance(A, L);
      return await A.write(), this.unlockTX(q), this.emit("confirmed", q, R), this.emit("balance", fe), R;
    }
    /**
     * Recursively remove a transaction
     * from the database.
     * @param {Hash} hash
     * @returns {Promise}
     */
    async remove(N) {
      const T = await this.getTX(N);
      return T ? this.removeRecursive(T) : null;
    }
    /**
     * Remove a transaction from the
     * database. Disconnect inputs.
     * @private
     * @param {TXRecord} wtx
     * @returns {Promise}
     */
    async erase(N, T) {
      const A = this.bucket.batch(), { tx: q, hash: _ } = N, F = T ? T.height : -1, R = new E(N, T), L = new h();
      if (!q.isCoinbase()) {
        const ue = await this.getSpentCredits(q);
        for (let ae = 0; ae < q.inputs.length; ae++) {
          const D = ue[ae];
          if (!D) {
            T || await this.removeInput(A, q, ae);
            continue;
          }
          const Q = D.coin, W = await this.getPath(Q);
          e(W), R.setInput(ae, W, Q), L.tx(W, -1), L.coin(W, 1), L.unconfirmed(W, Q.value), T && L.confirmed(W, Q.value), this.unspendCredit(A, q, ae), D.spent = !1, await this.saveCredit(A, D, W);
        }
      }
      for (let ue = 0; ue < q.outputs.length; ue++) {
        const ae = q.outputs[ue], D = await this.getPath(ae);
        if (!D)
          continue;
        R.setOutput(ue, D);
        const Q = a.fromTX(q, ue, F);
        L.tx(D, -1), L.coin(D, -1), L.unconfirmed(D, -ae.value), T && L.confirmed(D, -ae.value), await this.removeCredit(A, Q, D);
      }
      A.del(s.t.encode(_)), A.del(s.m.encode(N.mtime, _)), T ? A.del(s.h.encode(F, _)) : A.del(s.p.encode(_));
      for (const [ue, ae] of L.accounts)
        await this.updateAccountBalance(A, ue, ae), A.del(s.T.encode(ue, _)), A.del(s.M.encode(ue, N.mtime, _)), T ? A.del(s.H.encode(ue, F, _)) : A.del(s.P.encode(ue, _));
      T ? (await this.removeBlockMap(A, F), await this.spliceBlock(A, _, F)) : await this.removeTXMap(A, _);
      const fe = await this.updateBalance(A, L);
      return await A.write(), this.emit("remove tx", q, R), this.emit("balance", fe), R;
    }
    /**
     * Remove a transaction and recursively
     * remove all of its spenders.
     * @private
     * @param {TXRecord} wtx
     * @returns {Promise}
     */
    async removeRecursive(N) {
      const { tx: T, hash: A } = N;
      if (!await this.hasTX(A))
        return null;
      for (let q = 0; q < T.outputs.length; q++) {
        const _ = await this.getSpent(A, q);
        if (!_)
          continue;
        const F = await this.getTX(_.hash);
        e(F), await this.removeRecursive(F);
      }
      return this.erase(N, N.getBlock());
    }
    /**
     * Revert a block.
     * @param {Number} height
     * @returns {Promise}
     */
    async revert(N) {
      const T = await this.getBlock(N);
      if (!T)
        return 0;
      this.logger.debug("Rescan: reverting block %d", N);
      const A = T.toArray();
      for (let q = A.length - 1; q >= 0; q--) {
        const _ = A[q];
        await this.unconfirm(_);
      }
      return A.length;
    }
    /**
     * Unconfirm a transaction without a batch.
     * @private
     * @param {Hash} hash
     * @returns {Promise}
     */
    async unconfirm(N) {
      const T = await this.getTX(N);
      return !T || T.height === -1 ? null : this.disconnect(T, T.getBlock());
    }
    /**
     * Unconfirm a transaction. Necessary after a reorg.
     * @param {TXRecord} wtx
     * @returns {Promise}
     */
    async disconnect(N, T) {
      const A = this.bucket.batch(), { tx: q, hash: _, height: F } = N, R = new E(N, T), L = new h();
      if (e(T), N.unsetBlock(), !q.isCoinbase()) {
        const ue = await this.getSpentCredits(q);
        for (let ae = 0; ae < q.inputs.length; ae++) {
          const D = ue[ae];
          if (!D) {
            await this.writeInput(A, q, ae);
            continue;
          }
          const Q = D.coin;
          e(Q.height !== -1);
          const W = await this.getPath(Q);
          e(W), R.setInput(ae, W, Q), L.confirmed(W, Q.value), D.spent = !0, await this.saveCredit(A, D, W);
        }
      }
      for (let ue = 0; ue < q.outputs.length; ue++) {
        const ae = q.outputs[ue], D = await this.getPath(ae);
        if (!D)
          continue;
        const Q = await this.getCredit(_, ue);
        if (!Q) {
          await this.updateSpentCoin(A, q, ue, F);
          continue;
        }
        Q.spent && await this.updateSpentCoin(A, q, ue, F), R.setOutput(ue, D), Q.coin.height = -1, L.confirmed(D, -ae.value), await this.saveCredit(A, Q, D);
      }
      await this.addTXMap(A, _), await this.removeBlockMap(A, F), await this.removeBlock(A, q.hash(), F), A.put(s.t.encode(_), N.toRaw()), A.put(s.p.encode(_), null), A.del(s.h.encode(F, _));
      for (const [ue, ae] of L.accounts)
        await this.updateAccountBalance(A, ue, ae), A.put(s.P.encode(ue, _), null), A.del(s.H.encode(ue, F, _));
      const fe = await this.updateBalance(A, L);
      return await A.write(), this.emit("unconfirmed", q, R), this.emit("balance", fe), R;
    }
    /**
     * Remove spenders that have not been confirmed. We do this in the
     * odd case of stuck transactions or when a coin is double-spent
     * by a newer transaction. All previously-spending transactions
     * of that coin that are _not_ confirmed will be removed from
     * the database.
     * @private
     * @param {Hash} hash
     * @param {TX} ref - Reference tx, the tx that double-spent.
     * @returns {Promise} - Returns Boolean.
     */
    async removeConflict(N) {
      const T = N.tx;
      this.logger.warning("Handling conflicting tx: %h.", T.hash());
      const A = await this.removeRecursive(N);
      return A ? (this.logger.warning("Removed conflict: %h.", T.hash()), this.emit("conflict", T, A), A) : null;
    }
    /**
     * Retrieve coins for own inputs, remove
     * double spenders, and verify inputs.
     * @private
     * @param {TX} tx
     * @returns {Promise}
     */
    async removeConflicts(N, T) {
      if (N.isCoinbase())
        return !0;
      const A = N.hash(), q = [];
      for (const { prevout: _ } of N.inputs) {
        const { hash: F, index: R } = _, L = await this.getSpent(F, R);
        if (!L || L.hash.equals(A))
          continue;
        const fe = await this.getTX(L.hash);
        if (e(fe), T && fe.height !== -1)
          return !1;
        q.push(fe);
      }
      for (const _ of q)
        await this.removeConflict(_);
      return !0;
    }
    /**
     * Lock all coins in a transaction.
     * @param {TX} tx
     */
    lockTX(N) {
      if (!N.isCoinbase())
        for (const T of N.inputs)
          this.lockCoin(T.prevout);
    }
    /**
     * Unlock all coins in a transaction.
     * @param {TX} tx
     */
    unlockTX(N) {
      if (!N.isCoinbase())
        for (const T of N.inputs)
          this.unlockCoin(T.prevout);
    }
    /**
     * Lock a single coin.
     * @param {Coin|Outpoint} coin
     */
    lockCoin(N) {
      const T = N.toKey();
      this.locked.add(T);
    }
    /**
     * Unlock a single coin.
     * @param {Coin|Outpoint} coin
     */
    unlockCoin(N) {
      const T = N.toKey();
      return this.locked.delete(T);
    }
    /**
     * Unlock all coins.
     */
    unlockCoins() {
      for (const N of this.getLocked())
        this.unlockCoin(N);
    }
    /**
     * Test locked status of a single coin.
     * @param {Coin|Outpoint} coin
     */
    isLocked(N) {
      const T = N.toKey();
      return this.locked.has(T);
    }
    /**
     * Filter array of coins or outpoints
     * for only unlocked ones.
     * @param {Coin[]|Outpoint[]}
     * @returns {Array}
     */
    filterLocked(N) {
      const T = [];
      for (const A of N)
        this.isLocked(A) || T.push(A);
      return T;
    }
    /**
     * Return an array of all locked outpoints.
     * @returns {Outpoint[]}
     */
    getLocked() {
      const N = [];
      for (const T of this.locked.keys())
        N.push(u.fromKey(T));
      return N;
    }
    /**
     * Get hashes of all transactions in the database.
     * @param {Number} acct
     * @returns {Promise} - Returns {@link Hash}[].
     */
    getAccountHistoryHashes(N) {
      return e(typeof N == "number"), this.bucket.keys({
        gte: s.T.min(N),
        lte: s.T.max(N),
        parse: (T) => {
          const [, A] = s.T.decode(T);
          return A;
        }
      });
    }
    /**
     * Get hashes of all transactions in the database.
     * @param {Number} acct
     * @returns {Promise} - Returns {@link Hash}[].
     */
    getHistoryHashes(N) {
      return e(typeof N == "number"), N !== -1 ? this.getAccountHistoryHashes(N) : this.bucket.keys({
        gte: s.t.min(),
        lte: s.t.max(),
        parse: (T) => s.t.decode(T)[0]
      });
    }
    /**
     * Get hashes of all unconfirmed transactions in the database.
     * @param {Number} acct
     * @returns {Promise} - Returns {@link Hash}[].
     */
    getAccountPendingHashes(N) {
      return e(typeof N == "number"), this.bucket.keys({
        gte: s.P.min(N),
        lte: s.P.max(N),
        parse: (T) => {
          const [, A] = s.P.decode(T);
          return A;
        }
      });
    }
    /**
     * Get hashes of all unconfirmed transactions in the database.
     * @param {Number} acct
     * @returns {Promise} - Returns {@link Hash}[].
     */
    getPendingHashes(N) {
      return e(typeof N == "number"), N !== -1 ? this.getAccountPendingHashes(N) : this.bucket.keys({
        gte: s.p.min(),
        lte: s.p.max(),
        parse: (T) => s.p.decode(T)[0]
      });
    }
    /**
     * Get all coin hashes in the database.
     * @param {Number} acct
     * @returns {Promise} - Returns {@link Hash}[].
     */
    getAccountOutpoints(N) {
      return e(typeof N == "number"), this.bucket.keys({
        gte: s.C.min(N),
        lte: s.C.max(N),
        parse: (T) => {
          const [, A, q] = s.C.decode(T);
          return new u(A, q);
        }
      });
    }
    /**
     * Get all coin hashes in the database.
     * @param {Number} acct
     * @returns {Promise} - Returns {@link Hash}[].
     */
    getOutpoints(N) {
      return e(typeof N == "number"), N !== -1 ? this.getAccountOutpoints(N) : this.bucket.keys({
        gte: s.c.min(),
        lte: s.c.max(),
        parse: (T) => {
          const [A, q] = s.c.decode(T);
          return new u(A, q);
        }
      });
    }
    /**
     * Get TX hashes by height range.
     * @param {Number} acct
     * @param {Object} options
     * @param {Number} options.start - Start height.
     * @param {Number} options.end - End height.
     * @param {Number?} options.limit - Max number of records.
     * @param {Boolean?} options.reverse - Reverse order.
     * @returns {Promise} - Returns {@link Hash}[].
     */
    getAccountHeightRangeHashes(N, T) {
      e(typeof N == "number");
      const A = T.start || 0, q = T.end || 4294967295;
      return this.bucket.keys({
        gte: s.H.min(N, A),
        lte: s.H.max(N, q),
        limit: T.limit,
        reverse: T.reverse,
        parse: (_) => {
          const [, , F] = s.H.decode(_);
          return F;
        }
      });
    }
    /**
     * Get TX hashes by height range.
     * @param {Number} acct
     * @param {Object} options
     * @param {Number} options.start - Start height.
     * @param {Number} options.end - End height.
     * @param {Number?} options.limit - Max number of records.
     * @param {Boolean?} options.reverse - Reverse order.
     * @returns {Promise} - Returns {@link Hash}[].
     */
    getHeightRangeHashes(N, T) {
      if (e(typeof N == "number"), N !== -1)
        return this.getAccountHeightRangeHashes(N, T);
      const A = T.start || 0, q = T.end || 4294967295;
      return this.bucket.keys({
        gte: s.h.min(A),
        lte: s.h.max(q),
        limit: T.limit,
        reverse: T.reverse,
        parse: (_) => {
          const [, F] = s.h.decode(_);
          return F;
        }
      });
    }
    /**
     * Get TX hashes by height.
     * @param {Number} height
     * @returns {Promise} - Returns {@link Hash}[].
     */
    getHeightHashes(N) {
      return this.getHeightRangeHashes({ start: N, end: N });
    }
    /**
     * Get TX hashes by timestamp range.
     * @param {Number} acct
     * @param {Object} options
     * @param {Number} options.start - Start height.
     * @param {Number} options.end - End height.
     * @param {Number?} options.limit - Max number of records.
     * @param {Boolean?} options.reverse - Reverse order.
     * @returns {Promise} - Returns {@link Hash}[].
     */
    getAccountRangeHashes(N, T) {
      e(typeof N == "number");
      const A = T.start || 0, q = T.end || 4294967295;
      return this.bucket.keys({
        gte: s.M.min(N, A),
        lte: s.M.max(N, q),
        limit: T.limit,
        reverse: T.reverse,
        parse: (_) => {
          const [, , F] = s.M.decode(_);
          return F;
        }
      });
    }
    /**
     * Get TX hashes by timestamp range.
     * @param {Number} acct
     * @param {Object} options
     * @param {Number} options.start - Start height.
     * @param {Number} options.end - End height.
     * @param {Number?} options.limit - Max number of records.
     * @param {Boolean?} options.reverse - Reverse order.
     * @returns {Promise} - Returns {@link Hash}[].
     */
    getRangeHashes(N, T) {
      if (e(typeof N == "number"), N !== -1)
        return this.getAccountRangeHashes(N, T);
      const A = T.start || 0, q = T.end || 4294967295;
      return this.bucket.keys({
        gte: s.m.min(A),
        lte: s.m.max(q),
        limit: T.limit,
        reverse: T.reverse,
        parse: (_) => {
          const [, F] = s.m.decode(_);
          return F;
        }
      });
    }
    /**
     * Get transactions by timestamp range.
     * @param {Number} acct
     * @param {Object} options
     * @param {Number} options.start - Start time.
     * @param {Number} options.end - End time.
     * @param {Number?} options.limit - Max number of records.
     * @param {Boolean?} options.reverse - Reverse order.
     * @returns {Promise} - Returns {@link TX}[].
     */
    async getRange(N, T) {
      const A = await this.getRangeHashes(N, T), q = [];
      for (const _ of A) {
        const F = await this.getTX(_);
        e(F), q.push(F);
      }
      return q;
    }
    /**
     * Get last N transactions.
     * @param {Number} acct
     * @param {Number} limit - Max number of transactions.
     * @returns {Promise} - Returns {@link TX}[].
     */
    getLast(N, T) {
      return this.getRange(N, {
        start: 0,
        end: 4294967295,
        reverse: !0,
        limit: T || 10
      });
    }
    /**
     * Get all transactions.
     * @param {Number} acct
     * @returns {Promise} - Returns {@link TX}[].
     */
    getHistory(N) {
      return e(typeof N == "number"), N !== -1 ? this.getAccountHistory(N) : this.bucket.values({
        gte: s.t.min(),
        lte: s.t.max(),
        parse: (T) => g.fromRaw(T)
      });
    }
    /**
     * Get all acct transactions.
     * @param {Number} acct
     * @returns {Promise} - Returns {@link TX}[].
     */
    async getAccountHistory(N) {
      const T = await this.getHistoryHashes(N), A = [];
      for (const q of T) {
        const _ = await this.getTX(q);
        e(_), A.push(_);
      }
      return A;
    }
    /**
     * Get unconfirmed transactions.
     * @param {Number} acct
     * @returns {Promise} - Returns {@link TX}[].
     */
    async getPending(N) {
      const T = await this.getPendingHashes(N), A = [];
      for (const q of T) {
        const _ = await this.getTX(q);
        e(_), A.push(_);
      }
      return A;
    }
    /**
     * Get coins.
     * @param {Number} acct
     * @returns {Promise} - Returns {@link Coin}[].
     */
    getCredits(N) {
      return e(typeof N == "number"), N !== -1 ? this.getAccountCredits(N) : this.bucket.range({
        gte: s.c.min(),
        lte: s.c.max(),
        parse: (T, A) => {
          const [q, _] = s.c.decode(T), F = a.fromRaw(A);
          return F.coin.hash = q, F.coin.index = _, F;
        }
      });
    }
    /**
     * Get coins by account.
     * @param {Number} acct
     * @returns {Promise} - Returns {@link Coin}[].
     */
    async getAccountCredits(N) {
      const T = await this.getOutpoints(N), A = [];
      for (const { hash: q, index: _ } of T) {
        const F = await this.getCredit(q, _);
        e(F), A.push(F);
      }
      return A;
    }
    /**
     * Fill a transaction with coins (all historical coins).
     * @param {TX} tx
     * @returns {Promise} - Returns {@link TX}.
     */
    async getSpentCredits(N) {
      if (N.isCoinbase())
        return [];
      const T = N.hash(), A = [];
      for (let q = 0; q < N.inputs.length; q++)
        A.push(null);
      return await this.bucket.range({
        gte: s.d.min(T),
        lte: s.d.max(T),
        parse: (q, _) => {
          const [, F] = s.d.decode(q), R = n.fromRaw(_), L = N.inputs[F];
          e(L), R.hash = L.prevout.hash, R.index = L.prevout.index, A[F] = new a(R);
        }
      }), A;
    }
    /**
     * Get coins.
     * @param {Number} acct
     * @returns {Promise} - Returns {@link Coin}[].
     */
    async getCoins(N) {
      const T = await this.getCredits(N), A = [];
      for (const q of T)
        q.spent || A.push(q.coin);
      return A;
    }
    /**
     * Get coins by account.
     * @param {Number} acct
     * @returns {Promise} - Returns {@link Coin}[].
     */
    async getAccountCoins(N) {
      const T = await this.getAccountCredits(N), A = [];
      for (const q of T)
        q.spent || A.push(q.coin);
      return A;
    }
    /**
     * Get historical coins for a transaction.
     * @param {TX} tx
     * @returns {Promise} - Returns {@link TX}.
     */
    async getSpentCoins(N) {
      if (N.isCoinbase())
        return [];
      const T = await this.getSpentCredits(N), A = [];
      for (const q of T) {
        if (!q) {
          A.push(null);
          continue;
        }
        A.push(q.coin);
      }
      return A;
    }
    /**
     * Get a coin viewpoint.
     * @param {TX} tx
     * @returns {Promise} - Returns {@link CoinView}.
     */
    async getCoinView(N) {
      const T = new f();
      if (N.isCoinbase())
        return T;
      for (const { prevout: A } of N.inputs) {
        const { hash: q, index: _ } = A, F = await this.getCoin(q, _);
        F && T.addCoin(F);
      }
      return T;
    }
    /**
     * Get historical coin viewpoint.
     * @param {TX} tx
     * @returns {Promise} - Returns {@link CoinView}.
     */
    async getSpentView(N) {
      const T = new f();
      if (N.isCoinbase())
        return T;
      const A = await this.getSpentCoins(N);
      for (const q of A)
        q && T.addCoin(q);
      return T;
    }
    /**
     * Get transaction.
     * @param {Hash} hash
     * @returns {Promise} - Returns {@link TX}.
     */
    async getTX(N) {
      const T = await this.bucket.get(s.t.encode(N));
      return T ? g.fromRaw(T) : null;
    }
    /**
     * Get transaction details.
     * @param {Hash} hash
     * @returns {Promise} - Returns {@link TXDetails}.
     */
    async getDetails(N) {
      const T = await this.getTX(N);
      return T ? this.toDetails(T) : null;
    }
    /**
     * Convert transaction to transaction details.
     * @param {TXRecord[]} wtxs
     * @returns {Promise}
     */
    async toDetails(N) {
      const T = [];
      if (!Array.isArray(N))
        return this._toDetails(N);
      for (const A of N) {
        const q = await this._toDetails(A);
        q && T.push(q);
      }
      return T;
    }
    /**
     * Convert transaction to transaction details.
     * @private
     * @param {TXRecord} wtx
     * @returns {Promise}
     */
    async _toDetails(N) {
      const T = N.tx, A = N.getBlock(), q = new E(N, A), _ = await this.getSpentCoins(T);
      for (let F = 0; F < T.inputs.length; F++) {
        const R = _[F];
        let L = null;
        R && (L = await this.getPath(R)), q.setInput(F, L, R);
      }
      for (let F = 0; F < T.outputs.length; F++) {
        const R = T.outputs[F], L = await this.getPath(R);
        q.setOutput(F, L);
      }
      return q;
    }
    /**
     * Test whether the database has a transaction.
     * @param {Hash} hash
     * @returns {Promise} - Returns Boolean.
     */
    hasTX(N) {
      return this.bucket.has(s.t.encode(N));
    }
    /**
     * Get coin.
     * @param {Hash} hash
     * @param {Number} index
     * @returns {Promise} - Returns {@link Coin}.
     */
    async getCoin(N, T) {
      const A = await this.getCredit(N, T);
      return A ? A.coin : null;
    }
    /**
     * Get coin.
     * @param {Hash} hash
     * @param {Number} index
     * @returns {Promise} - Returns {@link Coin}.
     */
    async getCredit(N, T) {
      const A = await this.bucket.get(s.c.encode(N, T));
      if (!A)
        return null;
      const q = a.fromRaw(A);
      return q.coin.hash = N, q.coin.index = T, q;
    }
    /**
     * Get spender coin.
     * @param {Outpoint} spent
     * @param {Outpoint} prevout
     * @returns {Promise} - Returns {@link Coin}.
     */
    async getSpentCoin(N, T) {
      const A = await this.bucket.get(s.d.encode(
        N.hash,
        N.index
      ));
      if (!A)
        return null;
      const q = n.fromRaw(A);
      return q.hash = T.hash, q.index = T.index, q;
    }
    /**
     * Test whether the database has a spent coin.
     * @param {Outpoint} spent
     * @returns {Promise} - Returns {@link Coin}.
     */
    hasSpentCoin(N) {
      return this.bucket.has(s.d.encode(N.hash, N.index));
    }
    /**
     * Update spent coin height in storage.
     * @param {TX} tx - Sending transaction.
     * @param {Number} index
     * @param {Number} height
     * @returns {Promise}
     */
    async updateSpentCoin(N, T, A, q) {
      const _ = u.fromTX(T, A), F = await this.getSpent(_.hash, _.index);
      if (!F)
        return;
      const R = await this.getSpentCoin(F, _);
      R && (R.height = q, N.put(s.d.encode(F.hash, F.index), R.toRaw()));
    }
    /**
     * Test whether the database has a transaction.
     * @param {Hash} hash
     * @returns {Promise} - Returns Boolean.
     */
    async hasCoin(N, T) {
      return this.bucket.has(s.c.encode(N, T));
    }
    /**
     * Calculate balance.
     * @param {Number?} account
     * @returns {Promise} - Returns {@link Balance}.
     */
    async getBalance(N) {
      return e(typeof N == "number"), N !== -1 ? this.getAccountBalance(N) : this.getWalletBalance();
    }
    /**
     * Calculate balance.
     * @returns {Promise} - Returns {@link Balance}.
     */
    async getWalletBalance() {
      const N = await this.bucket.get(s.R.encode());
      return N ? b.fromRaw(-1, N) : new b();
    }
    /**
     * Calculate balance by account.
     * @param {Number} acct
     * @returns {Promise} - Returns {@link Balance}.
     */
    async getAccountBalance(N) {
      const T = await this.bucket.get(s.r.encode(N));
      return T ? b.fromRaw(N, T) : new b(N);
    }
    /**
     * Zap pending transactions older than `age`.
     * @param {Number} acct
     * @param {Number} age - Age delta.
     * @returns {Promise}
     */
    async zap(N, T) {
      e(T >>> 0 === T);
      const A = w.now(), q = await this.getRange(N, {
        start: 0,
        end: A - T
      }), _ = [];
      for (const F of q)
        F.height === -1 && (e(A - F.mtime >= T), this.logger.debug(
          "Zapping TX: %h (%d)",
          F.tx.hash(),
          this.wid
        ), await this.remove(F.hash), _.push(F.hash));
      return _;
    }
    /**
     * Abandon transaction.
     * @param {Hash} hash
     * @returns {Promise}
     */
    async abandon(N) {
      if (!await this.bucket.has(s.p.encode(N)))
        throw new Error("TX not eligible.");
      return this.remove(N);
    }
  }
  class b {
    /**
     * Create a balance.
     * @constructor
     * @param {Number} account
     */
    constructor(N = -1) {
      e(typeof N == "number"), this.account = N, this.tx = 0, this.coin = 0, this.unconfirmed = 0, this.confirmed = 0;
    }
    /**
     * Apply delta.
     * @param {Balance} balance
     */
    applyTo(N) {
      N.tx += this.tx, N.coin += this.coin, N.unconfirmed += this.unconfirmed, N.confirmed += this.confirmed, e(N.tx >= 0), e(N.coin >= 0), e(N.unconfirmed >= 0), e(N.confirmed >= 0);
    }
    /**
     * Serialize balance.
     * @returns {Buffer}
     */
    toRaw() {
      const N = c.write(32);
      return N.writeU64(this.tx), N.writeU64(this.coin), N.writeU64(this.unconfirmed), N.writeU64(this.confirmed), N.render();
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     * @returns {TXDBState}
     */
    fromRaw(N) {
      const T = c.read(N);
      return this.tx = T.readU64(), this.coin = T.readU64(), this.unconfirmed = T.readU64(), this.confirmed = T.readU64(), this;
    }
    /**
     * Instantiate balance from serialized data.
     * @param {Number} acct
     * @param {Buffer} data
     * @returns {TXDBState}
     */
    static fromRaw(N, T) {
      return new this(N).fromRaw(T);
    }
    /**
     * Convert balance to a more json-friendly object.
     * @param {Boolean?} minimal
     * @returns {Object}
     */
    toJSON(N) {
      return {
        account: N ? void 0 : this.account,
        tx: this.tx,
        coin: this.coin,
        unconfirmed: this.unconfirmed,
        confirmed: this.confirmed
      };
    }
    /**
     * Inspect balance.
     * @param {String}
     */
    [S]() {
      return `<Balance tx=${this.tx} coin=${this.coin} unconfirmed=${m.btc(this.unconfirmed)} confirmed=${m.btc(this.confirmed)}>`;
    }
  }
  class h {
    /**
     * Create a balance delta.
     * @constructor
     */
    constructor() {
      this.wallet = new b(), this.accounts = /* @__PURE__ */ new Map();
    }
    updated() {
      return this.wallet.tx !== 0;
    }
    applyTo(N) {
      this.wallet.applyTo(N);
    }
    get(N) {
      return this.accounts.has(N.account) || this.accounts.set(N.account, new b()), this.accounts.get(N.account);
    }
    tx(N, T) {
      const A = this.get(N);
      A.tx = T, this.wallet.tx = T;
    }
    coin(N, T) {
      const A = this.get(N);
      A.coin += T, this.wallet.coin += T;
    }
    unconfirmed(N, T) {
      const A = this.get(N);
      A.unconfirmed += T, this.wallet.unconfirmed += T;
    }
    confirmed(N, T) {
      const A = this.get(N);
      A.confirmed += T, this.wallet.confirmed += T;
    }
  }
  class a {
    /**
     * Create a credit.
     * @constructor
     * @param {Coin} coin
     * @param {Boolean?} spent
     */
    constructor(N, T) {
      this.coin = N || new n(), this.spent = T || !1, this.own = !1;
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     */
    fromRaw(N) {
      const T = c.read(N);
      return this.coin.fromReader(T), this.spent = T.readU8() === 1, this.own = T.readU8() === 1, this;
    }
    /**
     * Instantiate credit from serialized data.
     * @param {Buffer} data
     * @returns {Credit}
     */
    static fromRaw(N) {
      return new this().fromRaw(N);
    }
    /**
     * Get serialization size.
     * @returns {Number}
     */
    getSize() {
      return this.coin.getSize() + 2;
    }
    /**
     * Serialize credit.
     * @returns {Buffer}
     */
    toRaw() {
      const N = this.getSize(), T = c.write(N);
      return this.coin.toWriter(T), T.writeU8(this.spent ? 1 : 0), T.writeU8(this.own ? 1 : 0), T.render();
    }
    /**
     * Inject properties from tx object.
     * @private
     * @param {TX} tx
     * @param {Number} index
     * @returns {Credit}
     */
    fromTX(N, T, A) {
      return this.coin.fromTX(N, T, A), this.spent = !1, this.own = !1, this;
    }
    /**
     * Instantiate credit from transaction.
     * @param {TX} tx
     * @param {Number} index
     * @returns {Credit}
     */
    static fromTX(N, T, A) {
      return new this().fromTX(N, T, A);
    }
  }
  class E {
    /**
     * Create transaction details.
     * @constructor
     * @param {TXRecord} wtx
     * @param {BlockMeta} block
     */
    constructor(N, T) {
      this.hash = N.hash, this.tx = N.tx, this.mtime = N.mtime, this.size = this.tx.getSize(), this.block = null, this.height = -1, this.time = 0, T && (this.block = T.hash, this.height = T.height, this.time = T.time), this.inputs = [], this.outputs = [], this.init();
    }
    /**
     * Initialize transaction details.
     * @private
     */
    init() {
      for (const N of this.tx.inputs) {
        const T = new H();
        T.address = N.getAddress(), this.inputs.push(T);
      }
      for (const N of this.tx.outputs) {
        const T = new H();
        T.value = N.value, T.address = N.getAddress(), this.outputs.push(T);
      }
    }
    /**
     * Add necessary info to input member.
     * @param {Number} i
     * @param {Path} path
     * @param {Coin} coin
     */
    setInput(N, T, A) {
      const q = this.inputs[N];
      A && (q.value = A.value, q.address = A.getAddress()), T && (q.path = T);
    }
    /**
     * Add necessary info to output member.
     * @param {Number} i
     * @param {Path} path
     */
    setOutput(N, T) {
      const A = this.outputs[N];
      T && (A.path = T);
    }
    /**
     * Calculate confirmations.
     * @returns {Number}
     */
    getDepth(N) {
      if (this.height === -1 || N == null)
        return 0;
      const T = N - this.height;
      return T < 0 ? 0 : T + 1;
    }
    /**
     * Calculate fee. Only works if wallet
     * owns all inputs. Returns 0 otherwise.
     * @returns {Amount}
     */
    getFee() {
      let N = 0, T = 0;
      for (const A of this.inputs) {
        if (!A.path)
          return 0;
        N += A.value;
      }
      for (const A of this.outputs)
        T += A.value;
      return N - T;
    }
    /**
     * Calculate fee rate. Only works if wallet
     * owns all inputs. Returns 0 otherwise.
     * @param {Amount} fee
     * @returns {Rate}
     */
    getRate(N) {
      return p.getRate(this.size, N);
    }
    /**
     * Convert details to a more json-friendly object.
     * @returns {Object}
     */
    toJSON(N, T) {
      const A = this.getFee(), q = this.getRate(A);
      return {
        hash: w.revHex(this.hash),
        height: this.height,
        block: this.block ? w.revHex(this.block) : null,
        time: this.time,
        mtime: this.mtime,
        date: w.date(this.time),
        mdate: w.date(this.mtime),
        size: this.size,
        fee: A,
        rate: q,
        confirmations: this.getDepth(T),
        inputs: this.inputs.map((_) => _.getJSON(N)),
        outputs: this.outputs.map((_) => _.getJSON(N)),
        tx: this.tx.toRaw().toString("hex")
      };
    }
  }
  class H {
    /**
     * Create details member.
     * @constructor
     */
    constructor() {
      this.value = 0, this.address = null, this.path = null;
    }
    /**
     * Convert the member to a more json-friendly object.
     * @returns {Object}
     */
    toJSON() {
      return this.getJSON();
    }
    /**
     * Convert the member to a more json-friendly object.
     * @param {Network} network
     * @returns {Object}
     */
    getJSON(N) {
      return {
        value: this.value,
        address: this.address ? this.address.toString(N) : null,
        path: this.path ? this.path.toJSON() : null
      };
    }
  }
  class j {
    /**
     * Create a block record.
     * @constructor
     * @param {Hash} hash
     * @param {Number} height
     * @param {Number} time
     */
    constructor(N, T, A) {
      this.hash = N || i.ZERO_HASH, this.height = T ?? -1, this.time = A || 0, this.hashes = new l();
    }
    /**
     * Add transaction to block record.
     * @param {Hash} hash
     * @returns {Boolean}
     */
    add(N) {
      return this.hashes.has(N) ? !1 : (this.hashes.add(N), !0);
    }
    /**
     * Remove transaction from block record.
     * @param {Hash} hash
     * @returns {Boolean}
     */
    remove(N) {
      return this.hashes.delete(N);
    }
    /**
     * Instantiate wallet block from serialized tip data.
     * @private
     * @param {Buffer} data
     */
    fromRaw(N) {
      const T = c.read(N);
      this.hash = T.readHash(), this.height = T.readU32(), this.time = T.readU32();
      const A = T.readU32();
      for (let q = 0; q < A; q++) {
        const _ = T.readHash();
        this.hashes.add(_);
      }
      return this;
    }
    /**
     * Instantiate wallet block from serialized data.
     * @param {Buffer} data
     * @returns {BlockRecord}
     */
    static fromRaw(N) {
      return new this().fromRaw(N);
    }
    /**
     * Get serialization size.
     * @returns {Number}
     */
    getSize() {
      return 44 + this.hashes.size * 32;
    }
    /**
     * Serialize the wallet block as a tip (hash and height).
     * @returns {Buffer}
     */
    toRaw() {
      const N = this.getSize(), T = c.write(N);
      T.writeHash(this.hash), T.writeU32(this.height), T.writeU32(this.time), T.writeU32(this.hashes.size);
      for (const A of this.hashes)
        T.writeHash(A);
      return T.render();
    }
    /**
     * Convert hashes set to an array.
     * @returns {Hash[]}
     */
    toArray() {
      const N = [];
      for (const T of this.hashes)
        N.push(T);
      return N;
    }
    /**
     * Convert the block to a more json-friendly object.
     * @returns {Object}
     */
    toJSON() {
      return {
        hash: w.revHex(this.hash),
        height: this.height,
        time: this.time,
        hashes: this.toArray().map(w.revHex)
      };
    }
    /**
     * Instantiate wallet block from block meta.
     * @private
     * @param {BlockMeta} block
     */
    fromMeta(N) {
      return this.hash = N.hash, this.height = N.height, this.time = N.time, this;
    }
    /**
     * Instantiate wallet block from block meta.
     * @param {BlockMeta} block
     * @returns {BlockRecord}
     */
    static fromMeta(N) {
      return new this().fromMeta(N);
    }
  }
  return Th = y, Th;
}
/*!
 * walletkey.js - walletkey object for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var zh, $b;
function Lp() {
  if ($b) return zh;
  $b = 1;
  const e = Gr(), c = b1(), l = Mo();
  class w extends c {
    /**
     * Create a wallet key.
     * @constructor
     * @param {Object?} options
     */
    constructor(f) {
      super(f), this.keyType = l.types.HD, this.name = null, this.account = -1, this.branch = -1, this.index = -1;
    }
    /**
     * Convert an WalletKey to a more json-friendly object.
     * @returns {Object}
     */
    toJSON(f) {
      return {
        name: this.name,
        account: this.account,
        branch: this.branch,
        index: this.index,
        publicKey: this.publicKey.toString("hex"),
        script: this.script ? this.script.toRaw().toString("hex") : null,
        type: e.typesByVal[this.getType()].toLowerCase(),
        address: this.getAddress("string", f)
      };
    }
    /**
     * Inject properties from hd key.
     * @private
     * @param {Account} account
     * @param {HDPrivateKey|HDPublicKey} key
     * @param {Number} branch
     * @param {Number} index
     * @returns {WalletKey}
     */
    fromHD(f, n, u, o) {
      return this.keyType = l.types.HD, this.name = f.name, this.account = f.accountIndex, this.branch = u, this.index = o, n.privateKey ? this.fromPrivate(n.privateKey) : this.fromPublic(n.publicKey);
    }
    /**
     * Instantiate a wallet key from hd key.
     * @param {Account} account
     * @param {HDPrivateKey|HDPublicKey} key
     * @param {Number} branch
     * @param {Number} index
     * @returns {WalletKey}
     */
    static fromHD(f, n, u, o) {
      return new this().fromHD(f, n, u, o);
    }
    /**
     * Inject properties from imported data.
     * @private
     * @param {Account} account
     * @param {Buffer} data
     * @returns {WalletKey}
     */
    fromImport(f, n) {
      return this.keyType = l.types.KEY, this.name = f.name, this.account = f.accountIndex, this.fromRaw(n);
    }
    /**
     * Instantiate a wallet key from imported data.
     * @param {Account} account
     * @param {Buffer} data
     * @returns {WalletKey}
     */
    static fromImport(f, n) {
      return new this().fromImport(f, n);
    }
    /**
     * Inject properties from key.
     * @private
     * @param {Account} account
     * @param {KeyRing} ring
     * @returns {WalletKey}
     */
    fromRing(f, n) {
      return this.keyType = l.types.KEY, this.name = f.name, this.account = f.accountIndex, this.fromOptions(n);
    }
    /**
     * Instantiate a wallet key from regular key.
     * @param {Account} account
     * @param {KeyRing} ring
     * @returns {WalletKey}
     */
    static fromRing(f, n) {
      return new this().fromRing(f, n);
    }
    /**
     * Convert wallet key to a path.
     * @returns {Path}
     */
    toPath() {
      const f = new l();
      switch (f.name = this.name, f.account = this.account, this.keyType) {
        case l.types.HD:
          f.branch = this.branch, f.index = this.index;
          break;
        case l.types.KEY:
          f.data = this.toRaw();
          break;
      }
      return f.keyType = this.keyType, f.version = this.getVersion(), f.type = this.getType(), f.hash = this.getHash(), f;
    }
    /**
     * Test whether an object is a WalletKey.
     * @param {Object} obj
     * @returns {Boolean}
     */
    static isWalletKey(f) {
      return f instanceof w;
    }
  }
  return zh = w, zh;
}
/*!
 * account.js - account object for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var Ch, jb;
function Kp() {
  if (jb) return Ch;
  jb = 1;
  const e = Xe(), c = At(), l = yo(), w = Mo(), m = y1(), f = Cr(), n = Lp(), { HDPublicKey: u } = h1(), { inspectSymbol: o } = Kt();
  class s {
    /**
     * Create an account.
     * @constructor
     * @param {Object} options
     */
    constructor(y, b) {
      e(y, "Database is required."), this.wdb = y, this.network = y.network, this.wid = 0, this.id = null, this.accountIndex = 0, this.name = null, this.initialized = !1, this.watchOnly = !1, this.type = s.types.PUBKEYHASH, this.m = 1, this.n = 1, this.receiveDepth = 0, this.changeDepth = 0, this.lookahead = 10, this.accountKey = null, this.keys = [], b && this.fromOptions(b);
    }
    /**
     * Inject properties from options object.
     * @private
     * @param {Object} options
     */
    fromOptions(y) {
      if (e(y, "Options are required."), e(y.wid >>> 0 === y.wid), e(m.isName(y.id), "Bad Wallet ID."), e(
        u.isHDPublicKey(y.accountKey),
        "Account key is required."
      ), e(
        y.accountIndex >>> 0 === y.accountIndex,
        "Account index is required."
      ), this.wid = y.wid, this.id = y.id, y.accountIndex != null && (e(y.accountIndex >>> 0 === y.accountIndex), this.accountIndex = y.accountIndex), y.name != null && (e(m.isName(y.name), "Bad account name."), this.name = y.name), y.initialized != null && (e(typeof y.initialized == "boolean"), this.initialized = y.initialized), y.watchOnly != null && (e(typeof y.watchOnly == "boolean"), this.watchOnly = y.watchOnly), y.type != null && (typeof y.type == "string" ? (this.type = s.types[y.type.toUpperCase()], e(this.type != null)) : (e(typeof y.type == "number"), this.type = y.type, e(s.typesByVal[this.type]))), y.m != null && (e((y.m & 255) === y.m), this.m = y.m), y.n != null && (e((y.n & 255) === y.n), this.n = y.n), y.receiveDepth != null && (e(y.receiveDepth >>> 0 === y.receiveDepth), this.receiveDepth = y.receiveDepth), y.changeDepth != null && (e(y.changeDepth >>> 0 === y.changeDepth), this.changeDepth = y.changeDepth), y.lookahead != null && (e(y.lookahead >>> 0 === y.lookahead), e(y.lookahead >= 0), e(y.lookahead <= s.MAX_LOOKAHEAD), this.lookahead = y.lookahead), this.accountKey = y.accountKey, this.n > 1 && (this.type = s.types.MULTISIG), this.name || (this.name = this.accountIndex.toString(10)), this.m < 1 || this.m > this.n)
        throw new Error("m ranges between 1 and n");
      if (y.keys) {
        e(Array.isArray(y.keys));
        for (const b of y.keys)
          this.pushKey(b);
      }
      return this;
    }
    /**
     * Instantiate account from options.
     * @param {WalletDB} wdb
     * @param {Object} options
     * @returns {Account}
     */
    static fromOptions(y, b) {
      return new this(y).fromOptions(b);
    }
    /**
     * Attempt to intialize the account (generating
     * the first addresses along with the lookahead
     * addresses). Called automatically from the
     * walletdb.
     * @returns {Promise}
     */
    async init(y) {
      if (this.keys.length !== this.n - 1) {
        e(!this.initialized), this.save(y);
        return;
      }
      e(this.receiveDepth === 0), e(this.changeDepth === 0), this.initialized = !0, await this.initDepth(y);
    }
    /**
     * Add a public account key to the account (multisig).
     * Does not update the database.
     * @param {HDPublicKey} key - Account (bip44)
     * key (can be in base58 form).
     * @throws Error on non-hdkey/non-accountkey.
     */
    pushKey(y) {
      if (typeof y == "string" && (y = u.fromBase58(y, this.network)), !u.isHDPublicKey(y))
        throw new Error("Must add HD keys to wallet.");
      if (!y.isAccount())
        throw new Error("Must add HD account keys to BIP44 wallet.");
      if (this.type !== s.types.MULTISIG)
        throw new Error("Cannot add keys to non-multisig wallet.");
      if (y.equals(this.accountKey))
        throw new Error("Cannot add own key.");
      if (l.insert(this.keys, y, i, !0) === -1)
        return !1;
      if (this.keys.length > this.n - 1)
        throw l.remove(this.keys, y, i), new Error("Cannot add more keys.");
      return !0;
    }
    /**
     * Remove a public account key to the account (multisig).
     * Does not update the database.
     * @param {HDPublicKey} key - Account (bip44)
     * key (can be in base58 form).
     * @throws Error on non-hdkey/non-accountkey.
     */
    spliceKey(y) {
      if (typeof y == "string" && (y = u.fromBase58(y, this.network)), !u.isHDPublicKey(y))
        throw new Error("Must add HD keys to wallet.");
      if (!y.isAccount())
        throw new Error("Must add HD account keys to BIP44 wallet.");
      if (this.type !== s.types.MULTISIG)
        throw new Error("Cannot remove keys from non-multisig wallet.");
      if (this.keys.length === this.n - 1)
        throw new Error("Cannot remove key.");
      return l.remove(this.keys, y, i);
    }
    /**
     * Add a public account key to the account (multisig).
     * Saves the key in the wallet database.
     * @param {HDPublicKey} key
     * @returns {Promise}
     */
    async addSharedKey(y, b) {
      const h = this.pushKey(b);
      if (await this.hasDuplicate())
        throw this.spliceKey(b), new Error("Cannot add a key from another account.");
      return await this.init(y), h;
    }
    /**
     * Ensure accounts are not sharing keys.
     * @private
     * @returns {Promise}
     */
    async hasDuplicate() {
      if (this.keys.length !== this.n - 1)
        return !1;
      const b = this.deriveReceive(0).getScriptHash();
      return this.wdb.hasPath(this.wid, b);
    }
    /**
     * Remove a public account key from the account (multisig).
     * Remove the key from the wallet database.
     * @param {HDPublicKey} key
     * @returns {Promise}
     */
    removeSharedKey(y, b) {
      return this.spliceKey(b) ? (this.save(y), !0) : !1;
    }
    /**
     * Create a new receiving address (increments receiveDepth).
     * @returns {Promise} - Returns {@link WalletKey}
     */
    createReceive(y) {
      return this.createKey(y, 0);
    }
    /**
     * Create a new change address (increments receiveDepth).
     * @returns {Promise} - Returns {@link WalletKey}
     */
    createChange(y) {
      return this.createKey(y, 1);
    }
    /**
     * Create a new address (increments depth).
     * @param {Boolean} change
     * @returns {Promise} - Returns {@link WalletKey}.
     */
    async createKey(y, b) {
      let h, a;
      switch (b) {
        case 0:
          h = this.deriveReceive(this.receiveDepth), a = this.deriveReceive(this.receiveDepth + this.lookahead), await this.saveKey(y, a), this.receiveDepth += 1, this.receive = h;
          break;
        case 1:
          h = this.deriveChange(this.changeDepth), a = this.deriveChange(this.changeDepth + this.lookahead), await this.saveKey(y, a), this.changeDepth += 1, this.change = h;
          break;
        default:
          throw new Error(`Bad branch: ${b}.`);
      }
      return this.save(y), h;
    }
    /**
     * Derive a receiving address at `index`. Do not increment depth.
     * @param {Number} index
     * @returns {WalletKey}
     */
    deriveReceive(y, b) {
      return this.deriveKey(0, y, b);
    }
    /**
     * Derive a change address at `index`. Do not increment depth.
     * @param {Number} index
     * @returns {WalletKey}
     */
    deriveChange(y, b) {
      return this.deriveKey(1, y, b);
    }
    /**
     * Derive an address from `path` object.
     * @param {Path} path
     * @param {MasterKey} master
     * @returns {WalletKey}
     */
    derivePath(y, b) {
      switch (y.keyType) {
        case w.types.HD:
          return this.deriveKey(y.branch, y.index, b);
        case w.types.KEY: {
          e(this.type === s.types.PUBKEYHASH);
          let h = y.data;
          return y.encrypted && (h = b.decipher(h, y.hash), !h) ? null : n.fromImport(this, h);
        }
        case w.types.ADDRESS:
          return null;
        default:
          throw new Error("Bad key type.");
      }
    }
    /**
     * Derive an address at `index`. Do not increment depth.
     * @param {Number} branch
     * @param {Number} index
     * @returns {WalletKey}
     */
    deriveKey(y, b, h) {
      e(typeof y == "number");
      const a = [];
      let E;
      if (h && h.key && !this.watchOnly) {
        const j = this.network.keyPrefix.coinType;
        E = h.key.deriveAccount(44, j, this.accountIndex), E = E.derive(y).derive(b);
      } else
        E = this.accountKey.derive(y).derive(b);
      const H = n.fromHD(this, E, y, b);
      switch (this.type) {
        case s.types.PUBKEYHASH:
          break;
        case s.types.MULTISIG:
          a.push(E.publicKey);
          for (const j of this.keys) {
            const G = j.derive(y).derive(b);
            a.push(G.publicKey);
          }
          H.script = f.fromMultisig(this.m, this.n, a);
          break;
      }
      return H;
    }
    /**
     * Save the account to the database. Necessary
     * when address depth and keys change.
     * @returns {Promise}
     */
    save(y) {
      return this.wdb.saveAccount(y, this);
    }
    /**
     * Save addresses to path map.
     * @param {WalletKey[]} rings
     * @returns {Promise}
     */
    saveKey(y, b) {
      return this.wdb.saveKey(y, this.wid, b);
    }
    /**
     * Save paths to path map.
     * @param {Path[]} rings
     * @returns {Promise}
     */
    savePath(y, b) {
      return this.wdb.savePath(y, this.wid, b);
    }
    /**
     * Initialize address depths (including lookahead).
     * @returns {Promise}
     */
    async initDepth(y) {
      this.receiveDepth = 1;
      for (let b = 0; b <= this.lookahead; b++) {
        const h = this.deriveReceive(b);
        await this.saveKey(y, h);
      }
      this.changeDepth = 1;
      for (let b = 0; b <= this.lookahead; b++) {
        const h = this.deriveChange(b);
        await this.saveKey(y, h);
      }
      this.save(y);
    }
    /**
     * Allocate new lookahead addresses if necessary.
     * @param {Number} receiveDepth
     * @param {Number} changeDepth
     * @returns {Promise} - Returns {@link WalletKey}.
     */
    async syncDepth(y, b, h) {
      let a = !1, E = null;
      if (b > this.receiveDepth) {
        const H = this.receiveDepth + this.lookahead;
        e(b <= H + 1);
        for (let j = H; j < b + this.lookahead; j++) {
          const G = this.deriveReceive(j);
          await this.saveKey(y, G), E = G;
        }
        this.receiveDepth = b, a = !0;
      }
      if (h > this.changeDepth) {
        const H = this.changeDepth + this.lookahead;
        e(h <= H + 1);
        for (let j = H; j < h + this.lookahead; j++) {
          const G = this.deriveChange(j);
          await this.saveKey(y, G);
        }
        this.changeDepth = h, a = !0;
      }
      return a && this.save(y), E;
    }
    /**
     * Allocate new lookahead addresses.
     * @param {Number} lookahead
     * @returns {Promise}
     */
    async setLookahead(y, b) {
      if (b !== this.lookahead) {
        if (b < this.lookahead) {
          const h = this.lookahead - b;
          this.receiveDepth += h, this.changeDepth += h, this.lookahead = b, this.save(y);
          return;
        }
        {
          const h = this.receiveDepth + this.lookahead, a = this.receiveDepth + b;
          for (let E = h; E < a; E++) {
            const H = this.deriveReceive(E);
            await this.saveKey(y, H);
          }
        }
        {
          const h = this.changeDepth + this.lookahead, a = this.changeDepth + b;
          for (let E = h; E < a; E++) {
            const H = this.deriveChange(E);
            await this.saveKey(y, H);
          }
        }
        this.lookahead = b, this.save(y);
      }
    }
    /**
     * Get current receive key.
     * @returns {WalletKey}
     */
    receiveKey() {
      return this.initialized ? this.deriveReceive(this.receiveDepth - 1) : null;
    }
    /**
     * Get current change key.
     * @returns {WalletKey}
     */
    changeKey() {
      return this.initialized ? this.deriveChange(this.changeDepth - 1) : null;
    }
    /**
     * Get current receive address.
     * @returns {Address}
     */
    receiveAddress() {
      const y = this.receiveKey();
      return y ? y.getAddress() : null;
    }
    /**
     * Get current change address.
     * @returns {Address}
     */
    changeAddress() {
      const y = this.changeKey();
      return y ? y.getAddress() : null;
    }
    /**
     * Convert the account to a more inspection-friendly object.
     * @returns {Object}
     */
    [o]() {
      const y = this.receiveAddress(), b = this.changeAddress();
      return {
        id: this.id,
        wid: this.wid,
        name: this.name,
        network: this.network.type,
        initialized: this.initialized,
        watchOnly: this.watchOnly,
        type: s.typesByVal[this.type].toLowerCase(),
        m: this.m,
        n: this.n,
        accountIndex: this.accountIndex,
        receiveDepth: this.receiveDepth,
        changeDepth: this.changeDepth,
        lookahead: this.lookahead,
        receiveAddress: y ? y.toString(this.network) : null,
        changeAddress: b ? b.toString(this.network) : null,
        accountKey: this.accountKey.toBase58(this.network),
        keys: this.keys.map((h) => h.toBase58(this.network))
      };
    }
    /**
     * Convert the account to an object suitable for
     * serialization.
     * @returns {Object}
     */
    toJSON(y) {
      const b = this.receiveAddress(), h = this.changeAddress();
      return {
        name: this.name,
        initialized: this.initialized,
        watchOnly: this.watchOnly,
        type: s.typesByVal[this.type].toLowerCase(),
        m: this.m,
        n: this.n,
        accountIndex: this.accountIndex,
        receiveDepth: this.receiveDepth,
        changeDepth: this.changeDepth,
        lookahead: this.lookahead,
        receiveAddress: b ? b.toString(this.network) : null,
        changeAddress: h ? h.toString(this.network) : null,
        accountKey: this.accountKey.toBase58(this.network),
        keys: this.keys.map((a) => a.toBase58(this.network)),
        balance: y ? y.toJSON(!0) : null
      };
    }
    /**
     * Calculate serialization size.
     * @returns {Number}
     */
    getSize() {
      let y = 0;
      return y += 88, y += this.keys.length * 74, y;
    }
    /**
     * Serialize the account.
     * @returns {Buffer}
     */
    toRaw() {
      const y = this.getSize(), b = c.write(y);
      let h = 0;
      this.initialized && (h |= 1), b.writeU8(h), b.writeU8(this.type), b.writeU8(this.m), b.writeU8(this.n), b.writeU32(this.receiveDepth), b.writeU32(this.changeDepth), b.writeU8(this.lookahead), p(this.accountKey, b), b.writeU8(this.keys.length);
      for (const a of this.keys)
        p(a, b);
      return b.render();
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     * @returns {Object}
     */
    fromRaw(y) {
      const b = c.read(y), h = b.readU8();
      this.initialized = (h & 1) !== 0, this.type = b.readU8(), this.m = b.readU8(), this.n = b.readU8(), this.receiveDepth = b.readU32(), this.changeDepth = b.readU32(), this.lookahead = b.readU8(), this.accountKey = g(b), e(this.type < s.typesByVal.length);
      const a = b.readU8();
      for (let E = 0; E < a; E++) {
        const H = g(b);
        l.insert(this.keys, H, i, !0);
      }
      return this;
    }
    /**
     * Instantiate a account from serialized data.
     * @param {WalletDB} data
     * @param {Buffer} data
     * @returns {Account}
     */
    static fromRaw(y, b) {
      return new this(y).fromRaw(b);
    }
    /**
     * Test an object to see if it is a Account.
     * @param {Object} obj
     * @returns {Boolean}
     */
    static isAccount(y) {
      return y instanceof s;
    }
  }
  s.types = {
    PUBKEYHASH: 0,
    MULTISIG: 1
  }, s.typesByVal = [
    "PUBKEYHASH",
    "MULTISIG"
  ], s.MAX_LOOKAHEAD = 40;
  function i(S, y) {
    return S.compare(y);
  }
  function p(S, y) {
    y.writeU8(S.depth), y.writeU32BE(S.parentFingerPrint), y.writeU32BE(S.childIndex), y.writeBytes(S.chainCode), y.writeBytes(S.publicKey);
  }
  function g(S) {
    const y = new u();
    return y.depth = S.readU8(), y.parentFingerPrint = S.readU32BE(), y.childIndex = S.readU32BE(), y.chainCode = S.readBytes(32), y.publicKey = S.readBytes(33), y;
  }
  return Ch = s, Ch;
}
var Vn = {}, Yb;
function Vp() {
  if (Yb) return Vn;
  Yb = 1;
  const e = Nt(), c = Ro(), l = Ar(), w = k.alloc(64), m = new Uint32Array(16), f = new Uint32Array(16);
  function n(j, G, N, T, A, q) {
    if (typeof j == "string" && (j = k.from(j, "utf8")), typeof G == "string" && (G = k.from(G, "utf8")), G == null && (G = k.alloc(0)), e(k.isBuffer(j)), e(k.isBuffer(G)), e(N >>> 0 === N), e(T >>> 0 === T), e(A >>> 0 === A), e(q >>> 0 === q), T * A >= 1 << 30)
      throw new Error("EFBIG");
    if ((N & N - 1) !== 0 || N === 0)
      throw new Error("EINVAL");
    if (N > 4294967295)
      throw new Error("EINVAL");
    const _ = k.alloc(256 * T), F = k.alloc(128 * T * N), R = c.derive(l, j, G, 1, A * 128 * T);
    for (let L = 0; L < A; L++)
      g(R, L * 128 * T, T, N, F, _);
    return a(), c.derive(l, j, R, 1, q);
  }
  async function u(j, G, N, T, A, q) {
    if (typeof j == "string" && (j = k.from(j, "utf8")), typeof G == "string" && (G = k.from(G, "utf8")), G == null && (G = k.alloc(0)), e(k.isBuffer(j)), e(k.isBuffer(G)), e(N >>> 0 === N), e(T >>> 0 === T), e(A >>> 0 === A), e(q >>> 0 === q), T * A >= 1 << 30)
      throw new Error("EFBIG");
    if ((N & N - 1) !== 0 || N === 0)
      throw new Error("EINVAL");
    if (N > 4294967295)
      throw new Error("EINVAL");
    const _ = k.alloc(256 * T), F = k.alloc(128 * T * N), R = await c.deriveAsync(l, j, G, 1, A * 128 * T);
    for (let L = 0; L < A; L++)
      await S(R, L * 128 * T, T, N, F, _);
    return a(), c.deriveAsync(l, j, R, 1, q);
  }
  function o(j) {
    const G = m, N = f;
    for (let T = 0; T < 16; T++)
      G[T] = E(j, T * 4);
    for (let T = 0; T < 16; T++)
      N[T] = G[T];
    for (let T = 0; T < 8; T += 2)
      N[4] ^= s(N[0] + N[12], 7), N[8] ^= s(N[4] + N[0], 9), N[12] ^= s(N[8] + N[4], 13), N[0] ^= s(N[12] + N[8], 18), N[9] ^= s(N[5] + N[1], 7), N[13] ^= s(N[9] + N[5], 9), N[1] ^= s(N[13] + N[9], 13), N[5] ^= s(N[1] + N[13], 18), N[14] ^= s(N[10] + N[6], 7), N[2] ^= s(N[14] + N[10], 9), N[6] ^= s(N[2] + N[14], 13), N[10] ^= s(N[6] + N[2], 18), N[3] ^= s(N[15] + N[11], 7), N[7] ^= s(N[3] + N[15], 9), N[11] ^= s(N[7] + N[3], 13), N[15] ^= s(N[11] + N[7], 18), N[1] ^= s(N[0] + N[3], 7), N[2] ^= s(N[1] + N[0], 9), N[3] ^= s(N[2] + N[1], 13), N[0] ^= s(N[3] + N[2], 18), N[6] ^= s(N[5] + N[4], 7), N[7] ^= s(N[6] + N[5], 9), N[4] ^= s(N[7] + N[6], 13), N[5] ^= s(N[4] + N[7], 18), N[11] ^= s(N[10] + N[9], 7), N[8] ^= s(N[11] + N[10], 9), N[9] ^= s(N[8] + N[11], 13), N[10] ^= s(N[9] + N[8], 18), N[12] ^= s(N[15] + N[14], 7), N[13] ^= s(N[12] + N[15], 9), N[14] ^= s(N[13] + N[12], 13), N[15] ^= s(N[14] + N[13], 18);
    for (let T = 0; T < 16; T++)
      G[T] += N[T];
    for (let T = 0; T < 16; T++)
      H(j, G[T], 4 * T);
  }
  function s(j, G) {
    return j << G | j >>> 32 - G;
  }
  function i(j, G, N, T) {
    const A = w;
    y(A, j, 0, (2 * T - 1) * 64, 64);
    for (let q = 0; q < 2 * T; q++)
      b(A, j, 0, q * 64, 64), o(A), y(G, A, N + q * 64, 0, 64);
    for (let q = 0; q < T; q++)
      y(j, G, q * 64, N + q * 2 * 64, 64);
    for (let q = 0; q < T; q++)
      y(j, G, (q + T) * 64, N + (q * 2 + 1) * 64, 64);
  }
  function p(j, G) {
    return E(j, (2 * G - 1) * 64);
  }
  function g(j, G, N, T, A, q) {
    const _ = q, F = q;
    y(_, j, 0, G, 128 * N);
    for (let R = 0; R < T; R++)
      y(A, _, R * (128 * N), 0, 128 * N), i(_, F, 128 * N, N);
    for (let R = 0; R < T; R++) {
      const L = p(_, N) & T - 1;
      b(_, A, 0, L * (128 * N), 128 * N), i(_, F, 128 * N, N);
    }
    y(j, _, G, 0, 128 * N);
  }
  async function S(j, G, N, T, A, q) {
    const _ = q, F = q;
    y(_, j, 0, G, 128 * N);
    for (let R = 0; R < T; R++)
      y(A, _, R * (128 * N), 0, 128 * N), i(_, F, 128 * N, N), await h();
    for (let R = 0; R < T; R++) {
      const L = p(_, N) & T - 1;
      b(_, A, 0, L * (128 * N), 128 * N), i(_, F, 128 * N, N), await h();
    }
    y(j, _, G, 0, 128 * N);
  }
  function y(j, G, N, T, A) {
    G.copy(j, N, T, T + A);
  }
  function b(j, G, N, T, A) {
    for (let q = 0; q < A; q++)
      j[N + q] ^= G[T + q];
  }
  function h() {
    return new Promise((j) => setImmediate(j));
  }
  function a() {
    for (let j = 0; j < 64; j++)
      w[j] = 0;
    for (let j = 0; j < 16; j++)
      m[j] = 0, f[j] = 0;
  }
  function E(j, G) {
    return j[G++] + j[G++] * 256 + j[G++] * 65536 + j[G] * 16777216;
  }
  function H(j, G, N) {
    return j[N++] = G, G >>>= 8, j[N++] = G, G >>>= 8, j[N++] = G, G >>>= 8, j[N++] = G, N;
  }
  return Vn.native = 0, Vn.derive = n, Vn.deriveAsync = u, Vn;
}
var Dh, Xb;
function Ly() {
  if (Xb) return Dh;
  Xb = 1;
  const e = Xe(), c = At(), { Lock: l } = g1(), w = yi(), m = Sn(), f = w1(), n = Ar(), u = mr(), o = zr(), s = Ro(), i = Vp(), p = Qt(), g = u1(), S = Po(), { encoding: y } = c, { inspectSymbol: b } = Kt();
  class h {
    /**
     * Create a master key.
     * @constructor
     * @param {Object} options
     */
    constructor(H) {
      this.encrypted = !1, this.iv = null, this.ciphertext = null, this.key = null, this.mnemonic = null, this.alg = h.alg.PBKDF2, this.n = 5e4, this.r = 0, this.p = 0, this.aesKey = null, this.timer = null, this.until = 0, this.locker = new l(), H && this.fromOptions(H);
    }
    /**
     * Inject properties from options object.
     * @private
     * @param {Object} options
     */
    fromOptions(H) {
      return e(H), H.encrypted != null && (e(typeof H.encrypted == "boolean"), this.encrypted = H.encrypted), H.iv && (e(k.isBuffer(H.iv)), this.iv = H.iv), H.ciphertext && (e(k.isBuffer(H.ciphertext)), this.ciphertext = H.ciphertext), H.key && (e(g.isHDPrivateKey(H.key)), this.key = H.key), H.mnemonic && (e(H.mnemonic instanceof S), this.mnemonic = H.mnemonic), H.alg != null && (typeof H.alg == "string" ? (this.alg = h.alg[H.alg.toUpperCase()], e(this.alg != null, "Unknown algorithm.")) : (e(typeof H.alg == "number"), e(h.algByVal[H.alg]), this.alg = H.alg)), H.rounds != null && (e(H.rounds >>> 0 === H.rounds), this.rounds = H.rounds), H.n != null && (e(H.n >>> 0 === H.n), this.n = H.n), H.r != null && (e(H.r >>> 0 === H.r), this.r = H.r), H.p != null && (e(H.p >>> 0 === H.p), this.p = H.p), e(this.encrypted ? !this.key : this.key), this;
    }
    /**
     * Instantiate master key from options.
     * @returns {MasterKey}
     */
    static fromOptions(H) {
      return new this().fromOptions(H);
    }
    /**
     * Decrypt the key and set a timeout to destroy decrypted data.
     * @param {Buffer|String} passphrase - Zero this yourself.
     * @param {Number} [timeout=60000] timeout in ms.
     * @returns {Promise} - Returns {@link HDPrivateKey}.
     */
    async unlock(H, j) {
      const G = await this.locker.lock();
      try {
        return await this._unlock(H, j);
      } finally {
        G();
      }
    }
    /**
     * Decrypt the key without a lock.
     * @private
     * @param {Buffer|String} passphrase - Zero this yourself.
     * @param {Number} [timeout=60000] timeout in ms.
     * @returns {Promise} - Returns {@link HDPrivateKey}.
     */
    async _unlock(H, j) {
      if (this.key)
        return this.encrypted && (e(this.timer != null), this.start(j)), this.key;
      if (!H)
        throw new Error("No passphrase.");
      e(this.encrypted);
      const G = await this.derive(H), N = f.decipher(this.ciphertext, G, this.iv);
      return this.readKey(N), this.start(j), this.aesKey = G, this.key;
    }
    /**
     * Start the destroy timer.
     * @private
     * @param {Number} [timeout=60] timeout in seconds.
     */
    start(H) {
      H || (H = 60), this.stop(), H !== -1 && (e(H >>> 0 === H), this.until = p.now() + H, this.timer = setTimeout(() => this.lock(), H * 1e3));
    }
    /**
     * Stop the destroy timer.
     * @private
     */
    stop() {
      this.timer != null && (clearTimeout(this.timer), this.timer = null, this.until = 0);
    }
    /**
     * Derive an aes key based on params.
     * @param {String|Buffer} passphrase
     * @returns {Promise}
     */
    async derive(H) {
      const j = h.SALT, G = this.n, N = this.r, T = this.p;
      switch (typeof H == "string" && (H = k.from(H, "utf8")), this.alg) {
        case h.alg.PBKDF2:
          return s.deriveAsync(n, H, j, G, 32);
        case h.alg.SCRYPT:
          return i.deriveAsync(H, j, G, N, T, 32);
        default:
          throw new Error(`Unknown algorithm: ${this.alg}.`);
      }
    }
    /**
     * Encrypt data with in-memory aes key.
     * @param {Buffer} data
     * @param {Buffer} iv
     * @returns {Buffer}
     */
    encipher(H, j) {
      return this.aesKey ? f.encipher(H, this.aesKey, j.slice(0, 16)) : null;
    }
    /**
     * Decrypt data with in-memory aes key.
     * @param {Buffer} data
     * @param {Buffer} iv
     * @returns {Buffer}
     */
    decipher(H, j) {
      return this.aesKey ? f.decipher(H, this.aesKey, j.slice(0, 16)) : null;
    }
    /**
     * Destroy the key by zeroing the
     * privateKey and chainCode. Stop
     * the timer if there is one.
     * @returns {Promise}
     */
    async lock() {
      const H = await this.locker.lock();
      try {
        return await this._lock();
      } finally {
        H();
      }
    }
    /**
     * Destroy the key by zeroing the
     * privateKey and chainCode. Stop
     * the timer if there is one.
     */
    _lock() {
      if (!this.encrypted) {
        e(this.timer == null), e(this.key);
        return;
      }
      this.stop(), this.key && (this.key.destroy(!0), this.key = null), this.aesKey && (m(this.aesKey), this.aesKey = null);
    }
    /**
     * Destroy the key permanently.
     */
    async destroy() {
      await this.lock(), this.locker.destroy();
    }
    /**
     * Decrypt the key permanently.
     * @param {Buffer|String} passphrase - Zero this yourself.
     * @returns {Promise}
     */
    async decrypt(H, j) {
      const G = await this.locker.lock();
      try {
        return await this._decrypt(H, j);
      } finally {
        G();
      }
    }
    /**
     * Decrypt the key permanently without a lock.
     * @private
     * @param {Buffer|String} passphrase - Zero this yourself.
     * @returns {Promise}
     */
    async _decrypt(H, j) {
      if (!this.encrypted)
        throw new Error("Master key is not encrypted.");
      if (!H)
        throw new Error("No passphrase provided.");
      this._lock();
      const G = await this.derive(H), N = f.decipher(this.ciphertext, G, this.iv);
      return this.readKey(N), this.encrypted = !1, this.iv = null, this.ciphertext = null, j ? G : (m(G), null);
    }
    /**
     * Encrypt the key permanently.
     * @param {Buffer|String} passphrase - Zero this yourself.
     * @returns {Promise}
     */
    async encrypt(H, j) {
      const G = await this.locker.lock();
      try {
        return await this._encrypt(H, j);
      } finally {
        G();
      }
    }
    /**
     * Encrypt the key permanently without a lock.
     * @private
     * @param {Buffer|String} passphrase - Zero this yourself.
     * @returns {Promise}
     */
    async _encrypt(H, j) {
      if (this.encrypted)
        throw new Error("Master key is already encrypted.");
      if (!H)
        throw new Error("No passphrase provided.");
      const G = this.writeKey(), N = w.randomBytes(16);
      this.stop();
      const T = await this.derive(H), A = f.encipher(G, T, N);
      return this.key = null, this.mnemonic = null, this.encrypted = !0, this.iv = N, this.ciphertext = A, j ? T : (m(T), null);
    }
    /**
     * Calculate key serialization size.
     * @returns {Number}
     */
    keySize() {
      let H = 0;
      return H += 64, H += 1, this.mnemonic && (H += this.mnemonic.getSize()), H;
    }
    /**
     * Serialize key and menmonic to a single buffer.
     * @returns {Buffer}
     */
    writeKey() {
      const H = c.write(this.keySize());
      return H.writeBytes(this.key.chainCode), H.writeBytes(this.key.privateKey), this.mnemonic ? (H.writeU8(1), this.mnemonic.toWriter(H)) : H.writeU8(0), H.render();
    }
    /**
     * Inject properties from serialized key.
     * @param {Buffer} data
     */
    readKey(H) {
      const j = c.read(H);
      return this.key = new g(), a(H) ? (j.seek(13), this.key.chainCode = j.readBytes(32), e(j.readU8() === 0), this.key.privateKey = j.readBytes(32)) : (this.key.chainCode = j.readBytes(32), this.key.privateKey = j.readBytes(32)), this.key.publicKey = o.publicKeyCreate(this.key.privateKey, !0), j.readU8() === 1 && (this.mnemonic = S.fromReader(j)), this;
    }
    /**
     * Calculate serialization size.
     * @returns {Number}
     */
    getSize() {
      let H = 0;
      return this.encrypted ? (H += 1, H += y.sizeVarBytes(this.iv), H += y.sizeVarBytes(this.ciphertext), H += 13, H) : (H += 1, H += this.keySize(), H);
    }
    /**
     * Serialize the key in the form of:
     * `[enc-flag][iv?][ciphertext?][extended-key?]`
     * @returns {Buffer}
     */
    toWriter(H) {
      return this.encrypted ? (H.writeU8(1), H.writeVarBytes(this.iv), H.writeVarBytes(this.ciphertext), H.writeU8(this.alg), H.writeU32(this.n), H.writeU32(this.r), H.writeU32(this.p), H) : (H.writeU8(0), H.writeBytes(this.key.chainCode), H.writeBytes(this.key.privateKey), this.mnemonic ? (H.writeU8(1), this.mnemonic.toWriter(H)) : H.writeU8(0), H);
    }
    /**
     * Serialize the key in the form of:
     * `[enc-flag][iv?][ciphertext?][extended-key?]`
     * @returns {Buffer}
     */
    toRaw() {
      const H = this.getSize();
      return this.toWriter(c.write(H)).render();
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} raw
     */
    fromReader(H) {
      return this.encrypted = H.readU8() === 1, this.encrypted ? (this.iv = H.readVarBytes(), this.ciphertext = H.readVarBytes(), this.alg = H.readU8(), e(this.alg < h.algByVal.length), this.n = H.readU32(), this.r = H.readU32(), this.p = H.readU32(), this) : (this.key = new g(), this.key.chainCode = H.readBytes(32), this.key.privateKey = H.readBytes(32), this.key.publicKey = o.publicKeyCreate(this.key.privateKey, !0), H.readU8() === 1 && (this.mnemonic = S.fromReader(H)), this);
    }
    /**
     * Instantiate master key from serialized data.
     * @returns {MasterKey}
     */
    static fromReader(H) {
      return new this().fromReader(H);
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} raw
     */
    fromRaw(H) {
      return this.fromReader(c.read(H));
    }
    /**
     * Instantiate master key from serialized data.
     * @returns {MasterKey}
     */
    static fromRaw(H) {
      return new this().fromRaw(H);
    }
    /**
     * Inject properties from an HDPrivateKey.
     * @private
     * @param {HDPrivateKey} key
     * @param {Mnemonic?} mnemonic
     */
    fromKey(H, j) {
      return this.encrypted = !1, this.iv = null, this.ciphertext = null, this.key = H, this.mnemonic = j || null, this;
    }
    /**
     * Instantiate master key from an HDPrivateKey.
     * @param {HDPrivateKey} key
     * @param {Mnemonic?} mnemonic
     * @returns {MasterKey}
     */
    static fromKey(H, j) {
      return new this().fromKey(H, j);
    }
    /**
     * Convert master key to a jsonifiable object.
     * @param {Network?} network
     * @param {Boolean?} unsafe - Whether to include
     * the key data in the JSON.
     * @returns {Object}
     */
    toJSON(H, j) {
      return this.encrypted ? {
        encrypted: !0,
        until: this.until,
        iv: this.iv.toString("hex"),
        ciphertext: j ? this.ciphertext.toString("hex") : void 0,
        algorithm: h.algByVal[this.alg].toLowerCase(),
        n: this.n,
        r: this.r,
        p: this.p
      } : {
        encrypted: !1,
        key: j ? this.key.toJSON(H) : void 0,
        mnemonic: j && this.mnemonic ? this.mnemonic.toJSON() : void 0
      };
    }
    /**
     * Inspect the key.
     * @returns {Object}
     */
    [b]() {
      const H = this.toJSON(null, !0);
      return this.key && (H.key = this.key.toJSON()), this.mnemonic && (H.mnemonic = this.mnemonic.toJSON()), H;
    }
    /**
     * Test whether an object is a MasterKey.
     * @param {Object} obj
     * @returns {Boolean}
     */
    static isMasterKey(H) {
      return H instanceof h;
    }
  }
  h.SALT = k.from("bcoin", "ascii"), h.alg = {
    PBKDF2: 0,
    SCRYPT: 1
  }, h.algByVal = [
    "PBKDF2",
    "SCRYPT"
  ];
  function a(E) {
    if (E.length < 82)
      return !1;
    const H = E.slice(0, 78), j = E.readUInt32LE(78, !0);
    return u.digest(H).readUInt32LE(0, !0) === j;
  }
  return Dh = h, Dh;
}
var Uh, Gb;
function Ky() {
  if (Gb) return Uh;
  Gb = 1;
  const e = Xe(), c = vo(), { Lock: l } = g1(), { base58: w } = gn(), m = At(), f = Xi(), n = mr(), u = Sn(), o = Hy(), s = Mo(), i = y1(), p = Gr(), g = p1(), S = Cr(), y = Lp(), b = h1(), h = Si(), a = Kp(), E = Ly(), H = vi(), j = Lt(), { encoding: G } = m, { Mnemonic: N } = b, { inspectSymbol: T } = Kt();
  class A extends c {
    /**
     * Create a wallet.
     * @constructor
     * @param {Object} options
     */
    constructor(_, F) {
      super(), e(_, "WDB required."), this.wdb = _, this.db = _.db, this.network = _.network, this.logger = _.logger, this.writeLock = new l(), this.fundLock = new l(), this.wid = 0, this.id = null, this.watchOnly = !1, this.accountDepth = 0, this.token = j.ZERO_HASH, this.tokenDepth = 0, this.master = new E(), this.txdb = new o(this.wdb), F && this.fromOptions(F);
    }
    /**
     * Inject properties from options object.
     * @private
     * @param {Object} options
     */
    fromOptions(_) {
      if (!_)
        return this;
      let F = _.master, R, L, fe;
      return F ? (typeof F == "string" && (F = b.PrivateKey.fromBase58(F, this.network)), e(
        b.isPrivate(F),
        "Must create wallet with hd private key."
      )) : (fe = new N(_.mnemonic), F = b.fromMnemonic(fe, _.password)), this.master.fromKey(F, fe), _.wid != null && (e(_.wid >>> 0 === _.wid), this.wid = _.wid), _.id && (e(i.isName(_.id), "Bad wallet ID."), R = _.id), _.watchOnly != null && (e(typeof _.watchOnly == "boolean"), this.watchOnly = _.watchOnly), _.accountDepth != null && (e(_.accountDepth >>> 0 === _.accountDepth), this.accountDepth = _.accountDepth), _.token && (e(k.isBuffer(_.token)), e(_.token.length === 32), L = _.token), _.tokenDepth != null && (e(_.tokenDepth >>> 0 === _.tokenDepth), this.tokenDepth = _.tokenDepth), R || (R = this.getID()), L || (L = this.getToken(this.tokenDepth)), this.id = R, this.token = L, this;
    }
    /**
     * Instantiate wallet from options.
     * @param {WalletDB} wdb
     * @param {Object} options
     * @returns {Wallet}
     */
    static fromOptions(_, F) {
      return new this(_).fromOptions(F);
    }
    /**
     * Attempt to intialize the wallet (generating
     * the first addresses along with the lookahead
     * addresses). Called automatically from the
     * walletdb.
     * @returns {Promise}
     */
    async init(_, F) {
      F && await this.master.encrypt(F);
      const R = await this._createAccount(_, F);
      return e(R), this.logger.info("Wallet initialized (%s).", this.id), this.txdb.open(this);
    }
    /**
     * Open wallet (done after retrieval).
     * @returns {Promise}
     */
    async open() {
      if (!await this.getAccount(0))
        throw new Error("Default account not found.");
      return this.logger.info("Wallet opened (%s).", this.id), this.txdb.open(this);
    }
    /**
     * Close the wallet, unregister with the database.
     * @returns {Promise}
     */
    async destroy() {
      const _ = await this.writeLock.lock(), F = await this.fundLock.lock();
      try {
        await this.master.destroy(), this.writeLock.destroy(), this.fundLock.destroy();
      } finally {
        F(), _();
      }
    }
    /**
     * Add a public account key to the wallet (multisig).
     * Saves the key in the wallet database.
     * @param {(Number|String)} acct
     * @param {HDPublicKey} key
     * @returns {Promise}
     */
    async addSharedKey(_, F) {
      const R = await this.writeLock.lock();
      try {
        return await this._addSharedKey(_, F);
      } finally {
        R();
      }
    }
    /**
     * Add a public account key to the wallet without a lock.
     * @private
     * @param {(Number|String)} acct
     * @param {HDPublicKey} key
     * @returns {Promise}
     */
    async _addSharedKey(_, F) {
      const R = await this.getAccount(_);
      if (!R)
        throw new Error("Account not found.");
      const L = this.db.batch(), fe = await R.addSharedKey(L, F);
      return await L.write(), fe;
    }
    /**
     * Remove a public account key from the wallet (multisig).
     * @param {(Number|String)} acct
     * @param {HDPublicKey} key
     * @returns {Promise}
     */
    async removeSharedKey(_, F) {
      const R = await this.writeLock.lock();
      try {
        return await this._removeSharedKey(_, F);
      } finally {
        R();
      }
    }
    /**
     * Remove a public account key from the wallet (multisig).
     * @private
     * @param {(Number|String)} acct
     * @param {HDPublicKey} key
     * @returns {Promise}
     */
    async _removeSharedKey(_, F) {
      const R = await this.getAccount(_);
      if (!R)
        throw new Error("Account not found.");
      const L = this.db.batch(), fe = await R.removeSharedKey(L, F);
      return await L.write(), fe;
    }
    /**
     * Change or set master key's passphrase.
     * @param {String|Buffer} passphrase
     * @param {String|Buffer} old
     * @returns {Promise}
     */
    async setPassphrase(_, F) {
      F != null && await this.decrypt(F), await this.encrypt(_);
    }
    /**
     * Encrypt the wallet permanently.
     * @param {String|Buffer} passphrase
     * @returns {Promise}
     */
    async encrypt(_) {
      const F = await this.writeLock.lock();
      try {
        return await this._encrypt(_);
      } finally {
        F();
      }
    }
    /**
     * Encrypt the wallet permanently, without a lock.
     * @private
     * @param {String|Buffer} passphrase
     * @returns {Promise}
     */
    async _encrypt(_) {
      const F = await this.master.encrypt(_, !0), R = this.db.batch();
      try {
        await this.wdb.encryptKeys(R, this.wid, F);
      } finally {
        u(F);
      }
      this.save(R), await R.write();
    }
    /**
     * Decrypt the wallet permanently.
     * @param {String|Buffer} passphrase
     * @returns {Promise}
     */
    async decrypt(_) {
      const F = await this.writeLock.lock();
      try {
        return await this._decrypt(_);
      } finally {
        F();
      }
    }
    /**
     * Decrypt the wallet permanently, without a lock.
     * @private
     * @param {String|Buffer} passphrase
     * @returns {Promise}
     */
    async _decrypt(_) {
      const F = await this.master.decrypt(_, !0), R = this.db.batch();
      try {
        await this.wdb.decryptKeys(R, this.wid, F);
      } finally {
        u(F);
      }
      this.save(R), await R.write();
    }
    /**
     * Generate a new token.
     * @param {(String|Buffer)?} passphrase
     * @returns {Promise}
     */
    async retoken(_) {
      const F = await this.writeLock.lock();
      try {
        return await this._retoken(_);
      } finally {
        F();
      }
    }
    /**
     * Generate a new token without a lock.
     * @private
     * @param {(String|Buffer)?} passphrase
     * @returns {Promise}
     */
    async _retoken(_) {
      _ && await this.unlock(_), this.tokenDepth += 1, this.token = this.getToken(this.tokenDepth);
      const F = this.db.batch();
      return this.save(F), await F.write(), this.token;
    }
    /**
     * Rename the wallet.
     * @param {String} id
     * @returns {Promise}
     */
    async rename(_) {
      const F = await this.writeLock.lock();
      try {
        return await this.wdb.rename(this, _);
      } finally {
        F();
      }
    }
    /**
     * Rename account.
     * @param {(String|Number)?} acct
     * @param {String} name
     * @returns {Promise}
     */
    async renameAccount(_, F) {
      const R = await this.writeLock.lock();
      try {
        return await this._renameAccount(_, F);
      } finally {
        R();
      }
    }
    /**
     * Rename account without a lock.
     * @private
     * @param {(String|Number)?} acct
     * @param {String} name
     * @returns {Promise}
     */
    async _renameAccount(_, F) {
      if (!i.isName(F))
        throw new Error("Bad account name.");
      const R = await this.getAccount(_);
      if (!R)
        throw new Error("Account not found.");
      if (R.accountIndex === 0)
        throw new Error("Cannot rename default account.");
      if (await this.hasAccount(F))
        throw new Error("Account name not available.");
      const L = this.db.batch();
      this.wdb.renameAccount(L, R, F), await L.write();
    }
    /**
     * Lock the wallet, destroy decrypted key.
     */
    async lock() {
      const _ = await this.writeLock.lock(), F = await this.fundLock.lock();
      try {
        await this.master.lock();
      } finally {
        F(), _();
      }
    }
    /**
     * Unlock the key for `timeout` seconds.
     * @param {Buffer|String} passphrase
     * @param {Number?} [timeout=60]
     */
    unlock(_, F) {
      return this.master.unlock(_, F);
    }
    /**
     * Generate the wallet ID if none was passed in.
     * It is represented as HASH160(m/44->public|magic)
     * converted to an "address" with a prefix
     * of `0x03be04` (`WLT` in base58).
     * @private
     * @returns {Base58String}
     */
    getID() {
      e(this.master.key, "Cannot derive id.");
      const _ = this.master.key.derive(44), F = m.write(37);
      F.writeBytes(_.publicKey), F.writeU32(this.network.magic);
      const R = f.digest(F.render()), L = m.write(27);
      return L.writeU8(3), L.writeU8(190), L.writeU8(4), L.writeBytes(R), L.writeChecksum(n.digest), w.encode(L.render());
    }
    /**
     * Generate the wallet api key if none was passed in.
     * It is represented as HASH256(m/44'->private|nonce).
     * @private
     * @param {HDPrivateKey} master
     * @param {Number} nonce
     * @returns {Buffer}
     */
    getToken(_) {
      if (!this.master.key)
        throw new Error("Cannot derive token.");
      const F = this.master.key.derive(44, !0), R = m.write(36);
      return R.writeBytes(F.privateKey), R.writeU32(_), n.digest(R.render());
    }
    /**
     * Create an account. Requires passphrase if master key is encrypted.
     * @param {Object} options - See {@link Account} options.
     * @returns {Promise} - Returns {@link Account}.
     */
    async createAccount(_, F) {
      const R = await this.writeLock.lock();
      try {
        return await this._createAccount(_, F);
      } finally {
        R();
      }
    }
    /**
     * Create an account without a lock.
     * @param {Object} options - See {@link Account} options.
     * @returns {Promise} - Returns {@link Account}.
     */
    async _createAccount(_, F) {
      let R = _.name;
      if (R || (R = this.accountDepth.toString(10)), await this.hasAccount(R))
        throw new Error("Account already exists.");
      await this.unlock(F);
      let L;
      if (this.watchOnly) {
        if (L = _.accountKey, typeof L == "string" && (L = b.PublicKey.fromBase58(L, this.network)), !b.isPublic(L))
          throw new Error("Must add HD public keys to watch only wallet.");
      } else {
        e(this.master.key);
        const D = this.network.keyPrefix.coinType;
        L = this.master.key.deriveAccount(44, D, this.accountDepth), L = L.toPublic();
      }
      const fe = {
        wid: this.wid,
        id: this.id,
        name: this.accountDepth === 0 ? "default" : R,
        watchOnly: this.watchOnly,
        accountKey: L,
        accountIndex: this.accountDepth,
        type: _.type,
        m: _.m,
        n: _.n,
        keys: _.keys
      }, ue = this.db.batch(), ae = a.fromOptions(this.wdb, fe);
      return await ae.init(ue), this.logger.info(
        "Created account %s/%s/%d.",
        ae.id,
        ae.name,
        ae.accountIndex
      ), this.accountDepth += 1, this.save(ue), this.accountDepth === 1 && this.increment(ue), await ue.write(), ae;
    }
    /**
     * Ensure an account. Requires passphrase if master key is encrypted.
     * @param {Object} options - See {@link Account} options.
     * @returns {Promise} - Returns {@link Account}.
     */
    async ensureAccount(_, F) {
      const R = _.name, L = await this.getAccount(R);
      return L || this.createAccount(_, F);
    }
    /**
     * List account names and indexes from the db.
     * @returns {Promise} - Returns Array.
     */
    getAccounts() {
      return this.wdb.getAccounts(this.wid);
    }
    /**
     * Get all wallet address hashes.
     * @param {(String|Number)?} acct
     * @returns {Promise} - Returns Array.
     */
    getAddressHashes(_) {
      return _ != null ? this.getAccountHashes(_) : this.wdb.getWalletHashes(this.wid);
    }
    /**
     * Get all account address hashes.
     * @param {String|Number} acct
     * @returns {Promise} - Returns Array.
     */
    async getAccountHashes(_) {
      const F = await this.getAccountIndex(_);
      if (F === -1)
        throw new Error("Account not found.");
      return this.wdb.getAccountHashes(this.wid, F);
    }
    /**
     * Retrieve an account from the database.
     * @param {Number|String} acct
     * @returns {Promise} - Returns {@link Account}.
     */
    async getAccount(_) {
      const F = await this.getAccountIndex(_);
      if (F === -1)
        return null;
      const R = await this.wdb.getAccount(this.wid, F);
      return R ? (R.wid = this.wid, R.id = this.id, R.watchOnly = this.watchOnly, R) : null;
    }
    /**
     * Lookup the corresponding account name's index.
     * @param {String|Number} acct - Account name/index.
     * @returns {Promise} - Returns Number.
     */
    getAccountIndex(_) {
      return _ == null ? -1 : typeof _ == "number" ? _ : this.wdb.getAccountIndex(this.wid, _);
    }
    /**
     * Lookup the corresponding account name's index.
     * @param {String|Number} acct - Account name/index.
     * @returns {Promise} - Returns Number.
     * @throws on non-existent account
     */
    async ensureIndex(_) {
      if (_ == null || _ === -1)
        return -1;
      const F = await this.getAccountIndex(_);
      if (F === -1)
        throw new Error("Account not found.");
      return F;
    }
    /**
     * Lookup the corresponding account index's name.
     * @param {Number} index - Account index.
     * @returns {Promise} - Returns String.
     */
    async getAccountName(_) {
      return typeof _ == "string" ? _ : this.wdb.getAccountName(this.wid, _);
    }
    /**
     * Test whether an account exists.
     * @param {Number|String} acct
     * @returns {Promise} - Returns {@link Boolean}.
     */
    async hasAccount(_) {
      const F = await this.getAccountIndex(_);
      return F === -1 ? !1 : this.wdb.hasAccount(this.wid, F);
    }
    /**
     * Create a new receiving address (increments receiveDepth).
     * @param {(Number|String)?} acct
     * @returns {Promise} - Returns {@link WalletKey}.
     */
    createReceive(_ = 0) {
      return this.createKey(_, 0);
    }
    /**
     * Create a new change address (increments receiveDepth).
     * @param {(Number|String)?} acct
     * @returns {Promise} - Returns {@link WalletKey}.
     */
    createChange(_ = 0) {
      return this.createKey(_, 1);
    }
    /**
     * Create a new address (increments depth).
     * @param {(Number|String)?} acct
     * @param {Number} branch
     * @returns {Promise} - Returns {@link WalletKey}.
     */
    async createKey(_, F) {
      const R = await this.writeLock.lock();
      try {
        return await this._createKey(_, F);
      } finally {
        R();
      }
    }
    /**
     * Create a new address (increments depth) without a lock.
     * @private
     * @param {(Number|String)?} acct
     * @param {Number} branch
     * @returns {Promise} - Returns {@link WalletKey}.
     */
    async _createKey(_, F) {
      const R = await this.getAccount(_);
      if (!R)
        throw new Error("Account not found.");
      const L = this.db.batch(), fe = await R.createKey(L, F);
      return await L.write(), fe;
    }
    /**
     * Save the wallet to the database. Necessary
     * when address depth and keys change.
     * @returns {Promise}
     */
    save(_) {
      return this.wdb.save(_, this);
    }
    /**
     * Increment the wid depth.
     * @returns {Promise}
     */
    increment(_) {
      return this.wdb.increment(_, this.wid);
    }
    /**
     * Test whether the wallet possesses an address.
     * @param {Address|Hash} address
     * @returns {Promise} - Returns Boolean.
     */
    async hasAddress(_) {
      const F = p.getHash(_);
      return await this.getPath(F) != null;
    }
    /**
     * Get path by address hash.
     * @param {Address|Hash} address
     * @returns {Promise} - Returns {@link Path}.
     */
    async getPath(_) {
      const F = p.getHash(_);
      return this.wdb.getPath(this.wid, F);
    }
    /**
     * Get path by address hash (without account name).
     * @private
     * @param {Address|Hash} address
     * @returns {Promise} - Returns {@link Path}.
     */
    async readPath(_) {
      const F = p.getHash(_);
      return this.wdb.readPath(this.wid, F);
    }
    /**
     * Test whether the wallet contains a path.
     * @param {Address|Hash} address
     * @returns {Promise} - Returns {Boolean}.
     */
    async hasPath(_) {
      const F = p.getHash(_);
      return this.wdb.hasPath(this.wid, F);
    }
    /**
     * Get all wallet paths.
     * @param {(String|Number)?} acct
     * @returns {Promise} - Returns {@link Path}.
     */
    async getPaths(_) {
      return _ != null ? this.getAccountPaths(_) : this.wdb.getWalletPaths(this.wid);
    }
    /**
     * Get all account paths.
     * @param {String|Number} acct
     * @returns {Promise} - Returns {@link Path}.
     */
    async getAccountPaths(_) {
      const F = await this.getAccountIndex(_);
      if (F === -1)
        throw new Error("Account not found.");
      const R = await this.getAccountHashes(F), L = await this.getAccountName(_);
      e(L);
      const fe = [];
      for (const ue of R) {
        const ae = await this.readPath(ue);
        e(ae), e(ae.account === F), ae.name = L, fe.push(ae);
      }
      return fe;
    }
    /**
     * Import a keyring (will not exist on derivation chain).
     * Rescanning must be invoked manually.
     * @param {(String|Number)?} acct
     * @param {WalletKey} ring
     * @param {(String|Buffer)?} passphrase
     * @returns {Promise}
     */
    async importKey(_, F, R) {
      const L = await this.writeLock.lock();
      try {
        return await this._importKey(_, F, R);
      } finally {
        L();
      }
    }
    /**
     * Import a keyring (will not exist on derivation chain) without a lock.
     * @private
     * @param {(String|Number)?} acct
     * @param {WalletKey} ring
     * @param {(String|Buffer)?} passphrase
     * @returns {Promise}
     */
    async _importKey(_, F, R) {
      if (this.watchOnly) {
        if (F.privateKey)
          throw new Error("Cannot import privkey into watch-only wallet.");
      } else if (!F.privateKey)
        throw new Error("Cannot import pubkey into non watch-only wallet.");
      const L = F.getHash();
      if (await this.getPath(L))
        throw new Error("Key already exists.");
      const fe = await this.getAccount(_);
      if (!fe)
        throw new Error("Account not found.");
      if (fe.type !== a.types.PUBKEYHASH)
        throw new Error("Cannot import into non-pkh account.");
      await this.unlock(R);
      const ae = y.fromRing(fe, F).toPath();
      this.master.encrypted && (ae.data = this.master.encipher(ae.data, ae.hash), e(ae.data), ae.encrypted = !0);
      const D = this.db.batch();
      await fe.savePath(D, ae), await D.write();
    }
    /**
     * Import a keyring (will not exist on derivation chain).
     * Rescanning must be invoked manually.
     * @param {(String|Number)?} acct
     * @param {WalletKey} ring
     * @param {(String|Buffer)?} passphrase
     * @returns {Promise}
     */
    async importAddress(_, F) {
      const R = await this.writeLock.lock();
      try {
        return await this._importAddress(_, F);
      } finally {
        R();
      }
    }
    /**
     * Import a keyring (will not exist on derivation chain) without a lock.
     * @private
     * @param {(String|Number)?} acct
     * @param {WalletKey} ring
     * @param {(String|Buffer)?} passphrase
     * @returns {Promise}
     */
    async _importAddress(_, F) {
      if (!this.watchOnly)
        throw new Error("Cannot import address into non watch-only wallet.");
      if (await this.getPath(F))
        throw new Error("Address already exists.");
      const R = await this.getAccount(_);
      if (!R)
        throw new Error("Account not found.");
      if (R.type !== a.types.PUBKEYHASH)
        throw new Error("Cannot import into non-pkh account.");
      const L = s.fromAddress(R, F), fe = this.db.batch();
      await R.savePath(fe, L), await fe.write();
    }
    /**
     * Fill a transaction with inputs, estimate
     * transaction size, calculate fee, and add a change output.
     * @see MTX#selectCoins
     * @see MTX#fill
     * @param {MTX} mtx - _Must_ be a mutable transaction.
     * @param {Object?} options
     * @param {(String|Number)?} options.account - If no account is
     * specified, coins from the entire wallet will be filled.
     * @param {String?} options.selection - Coin selection priority. Can
     * be `age`, `random`, or `all`. (default=age).
     * @param {Boolean} options.round - Whether to round to the nearest
     * kilobyte for fee calculation.
     * See {@link TX#getMinFee} vs. {@link TX#getRoundFee}.
     * @param {Rate} options.rate - Rate used for fee calculation.
     * @param {Boolean} options.confirmed - Select only confirmed coins.
     * @param {Boolean} options.free - Do not apply a fee if the
     * transaction priority is high enough to be considered free.
     * @param {Amount?} options.hardFee - Use a hard fee rather than
     * calculating one.
     * @param {Number|Boolean} options.subtractFee - Whether to subtract the
     * fee from existing outputs rather than adding more inputs.
     */
    async fund(_, F, R) {
      const L = await this.fundLock.lock(R);
      try {
        return await this._fund(_, F);
      } finally {
        L();
      }
    }
    /**
     * Fill a transaction with inputs without a lock.
     * @private
     * @see MTX#selectCoins
     * @see MTX#fill
     */
    async _fund(_, F) {
      F || (F = {});
      const R = F.account || 0, L = await this.changeAddress(R);
      if (!L)
        throw new Error("Account not found.");
      let fe = F.rate;
      fe == null && (fe = await this.wdb.estimateFee(F.blocks));
      let ue;
      F.smart ? ue = await this.getSmartCoins(F.account) : (ue = await this.getCoins(F.account), ue = this.txdb.filterLocked(ue)), await _.fund(ue, {
        selection: F.selection,
        round: F.round,
        depth: F.depth,
        hardFee: F.hardFee,
        subtractFee: F.subtractFee,
        subtractIndex: F.subtractIndex,
        changeAddress: L,
        height: this.wdb.state.height,
        rate: fe,
        maxFee: F.maxFee,
        estimate: (ae) => this.estimateSize(ae)
      }), e(_.getFee() <= g.Selector.MAX_FEE, "TX exceeds MAX_FEE.");
    }
    /**
     * Get account by address.
     * @param {Address} address
     * @returns {Account}
     */
    async getAccountByAddress(_) {
      const F = p.getHash(_), R = await this.getPath(F);
      return R ? this.getAccount(R.account) : null;
    }
    /**
     * Input size estimator for max possible tx size.
     * @param {Script} prev
     * @returns {Number}
     */
    async estimateSize(_) {
      const F = _.getAddress();
      if (!F)
        return -1;
      const R = await this.getAccountByAddress(F);
      if (!R)
        return -1;
      let L = 0;
      switch (R.type) {
        case a.types.PUBKEYHASH:
          L += 74, L += 34;
          break;
        case a.types.MULTISIG:
          L += 1, L += 74 * R.m, L += 3, L += 1, L += 34 * R.n, L += 1, L += 1;
          break;
      }
      return L += G.sizeVarint(L), L;
    }
    /**
     * Build a transaction, fill it with outputs and inputs,
     * sort the members according to BIP69 (set options.sort=false
     * to avoid sorting), set locktime, and template it.
     * @param {Object} options - See {@link Wallet#fund options}.
     * @param {Object[]} options.outputs - See {@link MTX#addOutput}.
     * @param {Boolean} options.sort - Sort inputs and outputs (BIP69).
     * @param {Boolean} options.template - Build scripts for inputs.
     * @param {Number} options.locktime - TX locktime
     * @returns {Promise} - Returns {@link MTX}.
     */
    async createTX(_, F) {
      const R = _.outputs, L = new g();
      e(Array.isArray(R), "Outputs must be an array."), e(R.length > 0, "At least one output required");
      for (const ue of R) {
        const ae = new h(ue), D = ae.getAddress();
        if (ae.isDust())
          throw new Error("Output is dust.");
        if (ae.value > 0) {
          if (!D)
            throw new Error("Cannot send to unknown address.");
          if (D.isNull())
            throw new Error("Cannot send to null address.");
        }
        L.outputs.push(ae);
      }
      if (await this.fund(L, _, F), _.sort !== !1 && L.sortMembers(), _.locktime != null && L.setLocktime(_.locktime), e(L.isSane(), "TX failed sanity check."), e(
        L.verifyInputs(this.wdb.state.height + 1),
        "TX failed context check."
      ), _.template === !1)
        return L;
      if (await this.template(L) === 0)
        throw new Error("Templating failed.");
      return L;
    }
    /**
     * Build a transaction, fill it with outputs and inputs,
     * sort the members according to BIP69, set locktime,
     * sign and broadcast. Doing this all in one go prevents
     * coins from being double spent.
     * @param {Object} options - See {@link Wallet#fund options}.
     * @param {Object[]} options.outputs - See {@link MTX#addOutput}.
     * @returns {Promise} - Returns {@link TX}.
     */
    async send(_, F) {
      const R = await this.fundLock.lock();
      try {
        return await this._send(_, F);
      } finally {
        R();
      }
    }
    /**
     * Build and send a transaction without a lock.
     * @private
     * @param {Object} options - See {@link Wallet#fund options}.
     * @param {Object[]} options.outputs - See {@link MTX#addOutput}.
     * @returns {Promise} - Returns {@link TX}.
     */
    async _send(_, F) {
      const R = await this.createTX(_, !0);
      if (await this.sign(R, F), !R.isSigned())
        throw new Error("TX could not be fully signed.");
      const L = R.toTX();
      if (L.getSigopsCount(R.view) > H.MAX_TX_SIGOPS)
        throw new Error("TX exceeds policy sigops.");
      if (L.getSize() > H.MAX_TX_SIZE)
        throw new Error("TX exceeds policy size.");
      return await this.wdb.addTX(L), this.logger.debug("Sending wallet tx (%s): %h", this.id, L.hash()), await this.wdb.send(L), L;
    }
    /**
     * Intentionally double-spend outputs by
     * increasing fee for an existing transaction.
     * @param {Hash} hash
     * @param {Rate} rate
     * @param {(String|Buffer)?} passphrase
     * @returns {Promise} - Returns {@link TX}.
     */
    async increaseFee(_, F, R) {
      e(F >>> 0 === F, "Rate must be a number.");
      const L = await this.getTX(_);
      if (!L)
        throw new Error("Transaction not found.");
      if (L.height !== -1)
        throw new Error("Transaction is confirmed.");
      const fe = L.tx;
      if (fe.isCoinbase())
        throw new Error("Transaction is a coinbase.");
      const ue = await this.getSpentView(fe);
      if (!fe.hasCoins(ue))
        throw new Error("Not all coins available.");
      const ae = fe.getFee(ue);
      let D = fe.getMinFee(null, F);
      if (D > g.Selector.MAX_FEE && (D = g.Selector.MAX_FEE), ae >= D)
        throw new Error("Fee is not increasing.");
      const Q = g.fromTX(fe);
      Q.view = ue;
      for (const v of Q.inputs)
        v.script.clear();
      let W;
      for (let v = 0; v < Q.outputs.length; v++) {
        const Y = Q.outputs[v], he = Y.getAddress();
        if (!he)
          continue;
        const le = await this.getPath(he);
        if (le && le.branch === 1) {
          W = Y, Q.changeIndex = v;
          break;
        }
      }
      if (!W)
        throw new Error("No change output.");
      if (W.value += ae, Q.getFee() !== 0)
        throw new Error("Arithmetic error for change.");
      if (W.value -= D, W.value < 0)
        throw new Error("Fee is too high.");
      if (W.isDust() && (Q.outputs.splice(Q.changeIndex, 1), Q.changeIndex = -1), await this.sign(Q, R), !Q.isSigned())
        throw new Error("TX could not be fully signed.");
      const oe = Q.toTX();
      return this.logger.debug(
        "Increasing fee for wallet tx (%s): %h",
        this.id,
        oe.hash()
      ), await this.wdb.addTX(oe), await this.wdb.send(oe), oe;
    }
    /**
     * Resend pending wallet transactions.
     * @returns {Promise}
     */
    async resend() {
      const _ = await this.getPending();
      _.length > 0 && this.logger.info("Rebroadcasting %d transactions.", _.length);
      const F = [];
      for (const L of _)
        F.push(L.tx);
      const R = i.sortDeps(F);
      for (const L of R)
        await this.wdb.send(L);
      return F;
    }
    /**
     * Derive necessary addresses for signing a transaction.
     * @param {MTX} mtx
     * @param {Number?} index - Input index.
     * @returns {Promise} - Returns {@link WalletKey}[].
     */
    async deriveInputs(_) {
      e(_.mutable);
      const F = await this.getInputPaths(_), R = [];
      for (const L of F) {
        const fe = await this.getAccount(L.account);
        if (!fe)
          continue;
        const ue = fe.derivePath(L, this.master);
        ue && R.push(ue);
      }
      return R;
    }
    /**
     * Retrieve a single keyring by address.
     * @param {Address|Hash} hash
     * @returns {Promise}
     */
    async getKey(_) {
      const F = p.getHash(_), R = await this.getPath(F);
      if (!R)
        return null;
      const L = await this.getAccount(R.account);
      return L ? L.derivePath(R, this.master) : null;
    }
    /**
     * Retrieve a single keyring by address
     * (with the private key reference).
     * @param {Address|Hash} hash
     * @param {(Buffer|String)?} passphrase
     * @returns {Promise}
     */
    async getPrivateKey(_, F) {
      const R = p.getHash(_), L = await this.getPath(R);
      if (!L)
        return null;
      const fe = await this.getAccount(L.account);
      if (!fe)
        return null;
      await this.unlock(F);
      const ue = fe.derivePath(L, this.master);
      return ue.privateKey ? ue : null;
    }
    /**
     * Map input addresses to paths.
     * @param {MTX} mtx
     * @returns {Promise} - Returns {@link Path}[].
     */
    async getInputPaths(_) {
      if (e(_.mutable), !_.hasCoins())
        throw new Error("Not all coins available.");
      const F = _.getInputHashes(), R = [];
      for (const L of F) {
        const fe = await this.getPath(L);
        fe && R.push(fe);
      }
      return R;
    }
    /**
     * Map output addresses to paths.
     * @param {TX} tx
     * @returns {Promise} - Returns {@link Path}[].
     */
    async getOutputPaths(_) {
      const F = [], R = _.getOutputHashes();
      for (const L of R) {
        const fe = await this.getPath(L);
        fe && F.push(fe);
      }
      return F;
    }
    /**
     * Increase lookahead for account.
     * @param {(Number|String)?} account
     * @param {Number} lookahead
     * @returns {Promise}
     */
    async setLookahead(_, F) {
      const R = await this.writeLock.lock();
      try {
        return this._setLookahead(_, F);
      } finally {
        R();
      }
    }
    /**
     * Increase lookahead for account (without a lock).
     * @private
     * @param {(Number|String)?} account
     * @param {Number} lookahead
     * @returns {Promise}
     */
    async _setLookahead(_, F) {
      const R = await this.getAccount(_);
      if (!R)
        throw new Error("Account not found.");
      const L = this.db.batch();
      await R.setLookahead(L, F), await L.write();
    }
    /**
     * Sync address depths based on a transaction's outputs.
     * This is used for deriving new addresses when
     * a confirmed transaction is seen.
     * @param {TX} tx
     * @returns {Promise}
     */
    async syncOutputDepth(_) {
      const F = /* @__PURE__ */ new Map();
      for (const fe of _.getOutputHashes()) {
        const ue = await this.readPath(fe);
        ue && ue.index !== -1 && (F.has(ue.account) || F.set(ue.account, []), F.get(ue.account).push(ue));
      }
      const R = [], L = this.db.batch();
      for (const [fe, ue] of F) {
        let ae = -1, D = -1;
        for (const oe of ue)
          switch (oe.branch) {
            case 0:
              oe.index > ae && (ae = oe.index);
              break;
            case 1:
              oe.index > D && (D = oe.index);
              break;
          }
        ae += 2, D += 2;
        const Q = await this.getAccount(fe);
        e(Q);
        const W = await Q.syncDepth(L, ae, D);
        W && R.push(W);
      }
      return await L.write(), R;
    }
    /**
     * Build input scripts templates for a transaction (does not
     * sign, only creates signature slots). Only builds scripts
     * for inputs that are redeemable by this wallet.
     * @param {MTX} mtx
     * @returns {Promise} - Returns Number
     * (total number of scripts built).
     */
    async template(_) {
      const F = await this.deriveInputs(_);
      return _.template(F);
    }
    /**
     * Build input scripts and sign inputs for a transaction. Only attempts
     * to build/sign inputs that are redeemable by this wallet.
     * @param {MTX} tx
     * @param {Object|String|Buffer} options - Options or passphrase.
     * @returns {Promise} - Returns Number (total number
     * of inputs scripts built and signed).
     */
    async sign(_, F) {
      if (this.watchOnly)
        throw new Error("Cannot sign from a watch-only wallet.");
      await this.unlock(F);
      const R = await this.deriveInputs(_);
      return _.signAsync(R, S.hashType.ALL, this.wdb.workers);
    }
    /**
     * Get a coin viewpoint.
     * @param {TX} tx
     * @returns {Promise} - Returns {@link CoinView}.
     */
    getCoinView(_) {
      return this.txdb.getCoinView(_);
    }
    /**
     * Get a historical coin viewpoint.
     * @param {TX} tx
     * @returns {Promise} - Returns {@link CoinView}.
     */
    getSpentView(_) {
      return this.txdb.getSpentView(_);
    }
    /**
     * Convert transaction to transaction details.
     * @param {TXRecord} wtx
     * @returns {Promise} - Returns {@link Details}.
     */
    toDetails(_) {
      return this.txdb.toDetails(_);
    }
    /**
     * Get transaction details.
     * @param {Hash} hash
     * @returns {Promise} - Returns {@link Details}.
     */
    getDetails(_) {
      return this.txdb.getDetails(_);
    }
    /**
     * Get a coin from the wallet.
     * @param {Hash} hash
     * @param {Number} index
     * @returns {Promise} - Returns {@link Coin}.
     */
    getCoin(_, F) {
      return this.txdb.getCoin(_, F);
    }
    /**
     * Get a transaction from the wallet.
     * @param {Hash} hash
     * @returns {Promise} - Returns {@link TX}.
     */
    getTX(_) {
      return this.txdb.getTX(_);
    }
    /**
     * List blocks for the wallet.
     * @returns {Promise} - Returns {@link BlockRecord}.
     */
    getBlocks() {
      return this.txdb.getBlocks();
    }
    /**
     * Get a block from the wallet.
     * @param {Number} height
     * @returns {Promise} - Returns {@link BlockRecord}.
     */
    getBlock(_) {
      return this.txdb.getBlock(_);
    }
    /**
     * Add a transaction to the wallets TX history.
     * @param {TX} tx
     * @returns {Promise}
     */
    async add(_, F) {
      const R = await this.writeLock.lock();
      try {
        return await this._add(_, F);
      } finally {
        R();
      }
    }
    /**
     * Add a transaction to the wallet without a lock.
     * Potentially resolves orphans.
     * @private
     * @param {TX} tx
     * @returns {Promise}
     */
    async _add(_, F) {
      const R = await this.txdb.add(_, F);
      if (R) {
        const L = await this.syncOutputDepth(_);
        L.length > 0 && (this.wdb.emit("address", this, L), this.emit("address", L));
      }
      return R;
    }
    /**
     * Revert a block.
     * @param {Number} height
     * @returns {Promise}
     */
    async revert(_) {
      const F = await this.writeLock.lock();
      try {
        return await this.txdb.revert(_);
      } finally {
        F();
      }
    }
    /**
     * Remove a wallet transaction.
     * @param {Hash} hash
     * @returns {Promise}
     */
    async remove(_) {
      const F = await this.writeLock.lock();
      try {
        return await this.txdb.remove(_);
      } finally {
        F();
      }
    }
    /**
     * Zap stale TXs from wallet.
     * @param {(Number|String)?} acct
     * @param {Number} age - Age threshold (unix time, default=72 hours).
     * @returns {Promise}
     */
    async zap(_, F) {
      const R = await this.writeLock.lock();
      try {
        return await this._zap(_, F);
      } finally {
        R();
      }
    }
    /**
     * Zap stale TXs from wallet without a lock.
     * @private
     * @param {(Number|String)?} acct
     * @param {Number} age
     * @returns {Promise}
     */
    async _zap(_, F) {
      const R = await this.ensureIndex(_);
      return this.txdb.zap(R, F);
    }
    /**
     * Abandon transaction.
     * @param {Hash} hash
     * @returns {Promise}
     */
    async abandon(_) {
      const F = await this.writeLock.lock();
      try {
        return await this._abandon(_);
      } finally {
        F();
      }
    }
    /**
     * Abandon transaction without a lock.
     * @private
     * @param {Hash} hash
     * @returns {Promise}
     */
    _abandon(_) {
      return this.txdb.abandon(_);
    }
    /**
     * Lock a single coin.
     * @param {Coin|Outpoint} coin
     */
    lockCoin(_) {
      return this.txdb.lockCoin(_);
    }
    /**
     * Unlock a single coin.
     * @param {Coin|Outpoint} coin
     */
    unlockCoin(_) {
      return this.txdb.unlockCoin(_);
    }
    /**
     * Unlock all locked coins.
     */
    unlockCoins() {
      return this.txdb.unlockCoins();
    }
    /**
     * Test locked status of a single coin.
     * @param {Coin|Outpoint} coin
     */
    isLocked(_) {
      return this.txdb.isLocked(_);
    }
    /**
     * Return an array of all locked outpoints.
     * @returns {Outpoint[]}
     */
    getLocked() {
      return this.txdb.getLocked();
    }
    /**
     * Get all transactions in transaction history.
     * @param {(String|Number)?} acct
     * @returns {Promise} - Returns {@link TX}[].
     */
    async getHistory(_) {
      const F = await this.ensureIndex(_);
      return this.txdb.getHistory(F);
    }
    /**
     * Get all available coins.
     * @param {(String|Number)?} account
     * @returns {Promise} - Returns {@link Coin}[].
     */
    async getCoins(_) {
      const F = await this.ensureIndex(_);
      return this.txdb.getCoins(F);
    }
    /**
     * Get all available credits.
     * @param {(String|Number)?} account
     * @returns {Promise} - Returns {@link Credit}[].
     */
    async getCredits(_) {
      const F = await this.ensureIndex(_);
      return this.txdb.getCredits(F);
    }
    /**
     * Get "smart" coins.
     * @param {(String|Number)?} account
     * @returns {Promise} - Returns {@link Coin}[].
     */
    async getSmartCoins(_) {
      const F = await this.getCredits(_), R = [];
      for (const L of F) {
        const fe = L.coin;
        if (!L.spent && !this.txdb.isLocked(fe)) {
          if (fe.height !== -1) {
            R.push(fe);
            continue;
          }
          L.own && R.push(fe);
        }
      }
      return R;
    }
    /**
     * Get all pending/unconfirmed transactions.
     * @param {(String|Number)?} acct
     * @returns {Promise} - Returns {@link TX}[].
     */
    async getPending(_) {
      const F = await this.ensureIndex(_);
      return this.txdb.getPending(F);
    }
    /**
     * Get wallet balance.
     * @param {(String|Number)?} acct
     * @returns {Promise} - Returns {@link Balance}.
     */
    async getBalance(_) {
      const F = await this.ensureIndex(_);
      return this.txdb.getBalance(F);
    }
    /**
     * Get a range of transactions between two timestamps.
     * @param {(String|Number)?} acct
     * @param {Object} options
     * @param {Number} options.start
     * @param {Number} options.end
     * @returns {Promise} - Returns {@link TX}[].
     */
    async getRange(_, F) {
      const R = await this.ensureIndex(_);
      return this.txdb.getRange(R, F);
    }
    /**
     * Get the last N transactions.
     * @param {(String|Number)?} acct
     * @param {Number} limit
     * @returns {Promise} - Returns {@link TX}[].
     */
    async getLast(_, F) {
      const R = await this.ensureIndex(_);
      return this.txdb.getLast(R, F);
    }
    /**
     * Get account key.
     * @param {Number} [acct=0]
     * @returns {HDPublicKey}
     */
    async accountKey(_ = 0) {
      const F = await this.getAccount(_);
      if (!F)
        throw new Error("Account not found.");
      return F.accountKey;
    }
    /**
     * Get current receive depth.
     * @param {Number} [acct=0]
     * @returns {Number}
     */
    async receiveDepth(_ = 0) {
      const F = await this.getAccount(_);
      if (!F)
        throw new Error("Account not found.");
      return F.receiveDepth;
    }
    /**
     * Get current change depth.
     * @param {Number} [acct=0]
     * @returns {Number}
     */
    async changeDepth(_ = 0) {
      const F = await this.getAccount(_);
      if (!F)
        throw new Error("Account not found.");
      return F.changeDepth;
    }
    /**
     * Get current receive address.
     * @param {Number} [acct=0]
     * @returns {Address}
     */
    async receiveAddress(_ = 0) {
      const F = await this.getAccount(_);
      if (!F)
        throw new Error("Account not found.");
      return F.receiveAddress();
    }
    /**
     * Get current change address.
     * @param {Number} [acct=0]
     * @returns {Address}
     */
    async changeAddress(_ = 0) {
      const F = await this.getAccount(_);
      if (!F)
        throw new Error("Account not found.");
      return F.changeAddress();
    }
    /**
     * Get current receive key.
     * @param {Number} [acct=0]
     * @returns {WalletKey}
     */
    async receiveKey(_ = 0) {
      const F = await this.getAccount(_);
      if (!F)
        throw new Error("Account not found.");
      return F.receiveKey();
    }
    /**
     * Get current change key.
     * @param {Number} [acct=0]
     * @returns {WalletKey}
     */
    async changeKey(_ = 0) {
      const F = await this.getAccount(_);
      if (!F)
        throw new Error("Account not found.");
      return F.changeKey();
    }
    /**
     * Convert the wallet to a more inspection-friendly object.
     * @returns {Object}
     */
    [T]() {
      return {
        wid: this.wid,
        id: this.id,
        network: this.network.type,
        accountDepth: this.accountDepth,
        token: this.token.toString("hex"),
        tokenDepth: this.tokenDepth,
        master: this.master
      };
    }
    /**
     * Convert the wallet to an object suitable for
     * serialization.
     * @param {Boolean?} unsafe - Whether to include
     * the master key in the JSON.
     * @returns {Object}
     */
    toJSON(_, F) {
      return {
        network: this.network.type,
        wid: this.wid,
        id: this.id,
        watchOnly: this.watchOnly,
        accountDepth: this.accountDepth,
        token: this.token.toString("hex"),
        tokenDepth: this.tokenDepth,
        master: this.master.toJSON(this.network, _),
        balance: F ? F.toJSON(!0) : null
      };
    }
    /**
     * Calculate serialization size.
     * @returns {Number}
     */
    getSize() {
      let _ = 0;
      return _ += 41, _ += this.master.getSize(), _;
    }
    /**
     * Serialize the wallet.
     * @returns {Buffer}
     */
    toRaw() {
      const _ = this.getSize(), F = m.write(_);
      let R = 0;
      return this.watchOnly && (R |= 1), F.writeU8(R), F.writeU32(this.accountDepth), F.writeBytes(this.token), F.writeU32(this.tokenDepth), this.master.toWriter(F), F.render();
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     */
    fromRaw(_) {
      const F = m.read(_), R = F.readU8();
      return this.watchOnly = (R & 1) !== 0, this.accountDepth = F.readU32(), this.token = F.readBytes(32), this.tokenDepth = F.readU32(), this.master.fromReader(F), this;
    }
    /**
     * Instantiate a wallet from serialized data.
     * @param {Buffer} data
     * @returns {Wallet}
     */
    static fromRaw(_, F) {
      return new this(_).fromRaw(F);
    }
    /**
     * Test an object to see if it is a Wallet.
     * @param {Object} obj
     * @returns {Boolean}
     */
    static isWallet(_) {
      return _ instanceof A;
    }
  }
  return Uh = A, Uh;
}
/*!
 * nullclient.js - node client for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var Fh, Jb;
function Vy() {
  if (Jb) return Fh;
  Jb = 1;
  const e = Xe(), c = vo();
  class l extends c {
    /**
     * Create a client.
     * @constructor
     */
    constructor(m) {
      super(), this.wdb = m, this.network = m.network, this.opened = !1;
    }
    /**
     * Open the client.
     * @returns {Promise}
     */
    async open(m) {
      e(!this.opened, "NullClient is already open."), this.opened = !0, setImmediate(() => this.emit("connect"));
    }
    /**
     * Close the client.
     * @returns {Promise}
     */
    async close() {
      e(this.opened, "NullClient is not open."), this.opened = !1, setImmediate(() => this.emit("disconnect"));
    }
    /**
     * Add a listener.
     * @param {String} type
     * @param {Function} handler
     */
    bind(m, f) {
      return this.on(m, f);
    }
    /**
     * Add a listener.
     * @param {String} type
     * @param {Function} handler
     */
    hook(m, f) {
      return this.on(m, f);
    }
    /**
     * Get chain tip.
     * @returns {Promise}
     */
    async getTip() {
      const { hash: m, height: f, time: n } = this.network.genesis;
      return { hash: m, height: f, time: n };
    }
    /**
     * Get chain entry.
     * @param {Hash} hash
     * @returns {Promise}
     */
    async getEntry(m) {
      return { hash: m, height: 0, time: 0 };
    }
    /**
     * Send a transaction. Do not wait for promise.
     * @param {TX} tx
     * @returns {Promise}
     */
    async send(m) {
      this.wdb.emit("send", m);
    }
    /**
     * Set bloom filter.
     * @param {Bloom} filter
     * @returns {Promise}
     */
    async setFilter(m) {
      this.wdb.emit("set filter", m);
    }
    /**
     * Add data to filter.
     * @param {Buffer} data
     * @returns {Promise}
     */
    async addFilter(m) {
      this.wdb.emit("add filter", m);
    }
    /**
     * Reset filter.
     * @returns {Promise}
     */
    async resetFilter() {
      this.wdb.emit("reset filter");
    }
    /**
     * Esimate smart fee.
     * @param {Number?} blocks
     * @returns {Promise}
     */
    async estimateFee(m) {
      return this.network.feeRate;
    }
    /**
     * Get hash range.
     * @param {Number} start
     * @param {Number} end
     * @returns {Promise}
     */
    async getHashes(m = -1, f = -1) {
      return [this.network.genesis.hash];
    }
    /**
     * Rescan for any missed transactions.
     * @param {Number|Hash} start - Start block.
     * @param {Bloom} filter
     * @param {Function} iter - Iterator.
     * @returns {Promise}
     */
    async rescan(m) {
    }
  }
  return Fh = l, Fh;
}
var Hh, Wb;
function $y() {
  if (Wb) return Hh;
  Wb = 1;
  const e = Xe(), c = Cp(), l = vo(), w = At(), { BufferMap: m } = $r(), { BloomFilter: f } = Dp(), { Lock: n, MapLock: u } = g1(), o = Up(), s = Cy(), { safeEqual: i } = x1(), p = w1(), g = Or(), S = Mo(), y = y1(), b = Ky(), h = Kp(), a = Ei(), E = Hp(), H = Fp(), j = Vy(), G = E.wdb, N = E.txdb, {
    ChainState: T,
    BlockMeta: A,
    TXRecord: q,
    MapRecord: _
  } = H;
  class F extends l {
    /**
     * Create a wallet db.
     * @constructor
     * @param {Object} options
     */
    constructor(D) {
      super(), this.options = new R(D), this.network = this.options.network, this.logger = this.options.logger.context("wallet"), this.workers = this.options.workers, this.client = this.options.client || new j(this), this.feeRate = this.options.feeRate, this.db = o.create(this.options), this.primary = null, this.state = new T(), this.confirming = !1, this.height = 0, this.wallets = /* @__PURE__ */ new Map(), this.depth = 0, this.rescanning = !1, this.filterSent = !1, this.readLock = new u(), this.writeLock = new n(), this.txLock = new n(), this.filter = new f(), this.init();
    }
    /**
     * Initialize walletdb.
     * @private
     */
    init() {
      let D = 3e6, Q = -1;
      this.options.spv && (D = 2e4, Q = f.flags.ALL), this.filter = f.fromRate(D, 1e-3, Q), this._bind();
    }
    /**
     * Bind to node events.
     * @private
     */
    _bind() {
      this.client.on("error", (D) => {
        this.emit("error", D);
      }), this.client.on("connect", async () => {
        try {
          await this.syncNode();
        } catch (D) {
          this.emit("error", D);
        }
      }), this.client.on("disconnect", async () => {
        this.filterSent = !1;
      }), this.client.bind("block connect", async (D, Q) => {
        try {
          await this.addBlock(D, Q);
        } catch (W) {
          this.emit("error", W);
        }
      }), this.client.bind("block disconnect", async (D) => {
        try {
          await this.removeBlock(D);
        } catch (Q) {
          this.emit("error", Q);
        }
      }), this.client.hook("block rescan", async (D, Q) => {
        try {
          await this.rescanBlock(D, Q);
        } catch (W) {
          this.emit("error", W);
        }
      }), this.client.bind("tx", async (D) => {
        try {
          await this.addTX(D);
        } catch (Q) {
          this.emit("error", Q);
        }
      }), this.client.bind("chain reset", async (D) => {
        try {
          await this.resetChain(D);
        } catch (Q) {
          this.emit("error", Q);
        }
      });
    }
    /**
     * Open the walletdb, wait for the database to load.
     * @returns {Promise}
     */
    async open() {
      this.logger.info("Opening WalletDB..."), await this.db.open(), await this.db.verify(G.V.encode(), "wallet", 135), await this.verifyNetwork(), this.depth = await this.getDepth(), this.options.wipeNoReally && await this.wipe(), await this.watch(), await this.connect(), this.logger.info(
        "WalletDB loaded (depth=%d, height=%d, start=%d).",
        this.depth,
        this.state.height,
        this.state.startHeight
      );
      const D = await this.ensure({
        id: "primary"
      }), Q = await D.receiveAddress();
      this.logger.info(
        "Loaded primary wallet (id=%s, wid=%d, address=%s)",
        D.id,
        D.wid,
        Q.toString(this.network)
      ), this.primary = D;
    }
    /**
     * Verify network.
     * @returns {Promise}
     */
    async verifyNetwork() {
      const D = await this.db.get(G.O.encode());
      if (!D) {
        const W = this.db.batch();
        return W.put(G.O.encode(), L(this.network.magic)), W.write();
      }
      if (D.readUInt32LE(0, !0) !== this.network.magic)
        throw new Error("Network mismatch for WalletDB.");
    }
    /**
     * Close the walletdb, wait for the database to close.
     * @returns {Promise}
     */
    async close() {
      await this.disconnect();
      for (const D of this.wallets.values())
        await D.destroy(), this.unregister(D);
      return this.db.close();
    }
    /**
     * Watch addresses and outpoints.
     * @private
     * @returns {Promise}
     */
    async watch() {
      const D = this.db.iterator({
        gte: G.p.min(),
        lte: G.p.max()
      });
      let Q = 0;
      await D.each((v) => {
        const [Y] = G.p.decode(v);
        this.filter.add(Y), Q += 1;
      }), this.logger.info("Added %d hashes to WalletDB filter.", Q);
      const W = this.db.iterator({
        gte: G.o.min(),
        lte: G.o.max()
      });
      let oe = 0;
      await W.each((v) => {
        const [Y, he] = G.o.decode(v), ge = new a(Y, he).toRaw();
        this.filter.add(ge), oe += 1;
      }), this.logger.info("Added %d outpoints to WalletDB filter.", oe);
    }
    /**
     * Connect to the node server (client required).
     * @returns {Promise}
     */
    async connect() {
      return this.client.open();
    }
    /**
     * Disconnect from node server (client required).
     * @returns {Promise}
     */
    async disconnect() {
      return this.client.close();
    }
    /**
     * Sync state with server on every connect.
     * @returns {Promise}
     */
    async syncNode() {
      const D = await this.txLock.lock();
      try {
        this.logger.info("Resyncing from server..."), await this.syncState(), await this.syncFilter(), await this.syncChain(), await this.resend();
      } finally {
        D();
      }
    }
    /**
     * Initialize and write initial sync state.
     * @returns {Promise}
     */
    async syncState() {
      const D = await this.getState();
      if (D) {
        if (!await this.getBlock(0))
          return this.migrateState(D);
        this.state = D, this.height = D.height;
        return;
      }
      this.logger.info("Initializing database state from server.");
      const Q = this.db.batch(), W = await this.client.getHashes();
      let oe = null;
      for (let Y = 0; Y < W.length; Y++) {
        const he = W[Y], le = new A(he, Y);
        Q.put(G.h.encode(Y), le.toHash()), oe = le;
      }
      e(oe);
      const v = this.state.clone();
      v.startHeight = oe.height, v.startHash = oe.hash, v.height = oe.height, v.marked = !1, Q.put(G.R.encode(), v.toRaw()), await Q.write(), this.state = v, this.height = v.height;
    }
    /**
     * Migrate sync state.
     * @private
     * @param {ChainState} state
     * @returns {Promise}
     */
    async migrateState(D) {
      const Q = this.db.batch();
      this.logger.info("Migrating to new sync state.");
      const W = await this.client.getHashes(0, D.height);
      for (let oe = 0; oe < W.length; oe++) {
        const v = W[oe], Y = new A(v, oe);
        Q.put(G.h.encode(oe), Y.toHash());
      }
      await Q.write(), this.state = D, this.height = D.height;
    }
    /**
     * Connect and sync with the chain server.
     * @private
     * @returns {Promise}
     */
    async syncChain() {
      let D = this.state.height;
      for (this.logger.info("Syncing state from height %d.", D); ; ) {
        const Q = await this.getBlock(D);
        if (e(Q), await this.client.getEntry(Q.hash))
          break;
        e(D !== 0), D -= 1;
      }
      return this.scan(D);
    }
    /**
     * Rescan blockchain from a given height.
     * @private
     * @param {Number?} height
     * @returns {Promise}
     */
    async scan(D) {
      D == null && (D = this.state.startHeight), e(D >>> 0 === D, "WDB: Must pass in a height."), this.logger.info(
        "WalletDB is scanning %d blocks.",
        this.state.height - D + 1
      ), await this.rollback(D);
      const Q = await this.getTip();
      try {
        this.rescanning = !0, await this.client.rescan(Q.hash);
      } finally {
        this.rescanning = !1;
      }
    }
    /**
     * Force a rescan.
     * @param {Number} height
     * @returns {Promise}
     */
    async rescan(D) {
      const Q = await this.txLock.lock();
      try {
        return await this._rescan(D);
      } finally {
        Q();
      }
    }
    /**
     * Force a rescan (without a lock).
     * @private
     * @param {Number} height
     * @returns {Promise}
     */
    async _rescan(D) {
      return this.scan(D);
    }
    /**
     * Broadcast a transaction via chain server.
     * @param {TX} tx
     * @returns {Promise}
     */
    async send(D) {
      return this.client.send(D);
    }
    /**
     * Estimate smart fee from chain server.
     * @param {Number} blocks
     * @returns {Promise}
     */
    async estimateFee(D) {
      if (this.feeRate > 0)
        return this.feeRate;
      const Q = await this.client.estimateFee(D);
      return Q < this.network.feeRate ? this.network.feeRate : Q > this.network.maxFeeRate ? this.network.maxFeeRate : Q;
    }
    /**
     * Send filter to the remote node.
     * @private
     * @returns {Promise}
     */
    syncFilter() {
      return this.logger.info(
        "Sending filter to server (%dmb).",
        this.filter.size / 8 / (1 << 20)
      ), this.filterSent = !0, this.client.setFilter(this.filter);
    }
    /**
     * Add data to remote filter.
     * @private
     * @param {Buffer} data
     * @returns {Promise}
     */
    addFilter(D) {
      if (this.filterSent)
        return this.client.addFilter(D);
    }
    /**
     * Reset remote filter.
     * @private
     * @returns {Promise}
     */
    resetFilter() {
      if (this.filterSent)
        return this.client.resetFilter();
    }
    /**
     * Backup the wallet db.
     * @param {String} path
     * @returns {Promise}
     */
    backup(D) {
      return this.db.backup(D);
    }
    /**
     * Wipe the txdb - NEVER USE.
     * @returns {Promise}
     */
    async wipe() {
      this.logger.warning("Wiping WalletDB TXDB..."), this.logger.warning("I hope you know what you're doing.");
      const D = this.db.iterator(), Q = this.db.batch();
      let W = 0;
      return await D.each((oe) => {
        switch (oe[0]) {
          case 98:
          // b
          case 99:
          // c
          case 101:
          // e
          case 116:
          // t
          case 111:
          // o
          case 104:
          // h
          case 82:
            Q.del(oe), W += 1;
            break;
        }
      }), this.logger.warning("Wiped %d txdb records.", W), Q.write();
    }
    /**
     * Get current wallet wid depth.
     * @private
     * @returns {Promise}
     */
    async getDepth() {
      const D = await this.db.get(G.D.encode());
      return D ? D.readUInt32LE(0, !0) : 0;
    }
    /**
     * Test the bloom filter against a tx or address hash.
     * @private
     * @param {Hash} hash
     * @returns {Boolean}
     */
    testFilter(D) {
      return this.filter.test(D);
    }
    /**
     * Add hash to local and remote filters.
     * @private
     * @param {Hash} hash
     */
    addHash(D) {
      return this.filter.add(D), this.addFilter(D);
    }
    /**
     * Add outpoint to local filter.
     * @private
     * @param {Hash} hash
     * @param {Number} index
     */
    addOutpoint(D, Q) {
      const W = new a(D, Q);
      this.filter.add(W.toRaw());
    }
    /**
     * Dump database (for debugging).
     * @returns {Promise} - Returns Object.
     */
    dump() {
      return this.db.dump();
    }
    /**
     * Register an object with the walletdb.
     * @param {Object} object
     */
    register(D) {
      e(!this.wallets.has(D.wid)), this.wallets.set(D.wid, D);
    }
    /**
     * Unregister a object with the walletdb.
     * @param {Object} object
     * @returns {Boolean}
     */
    unregister(D) {
      e(this.wallets.has(D.wid)), this.wallets.delete(D.wid);
    }
    /**
     * Map wallet id to wid.
     * @param {String|Number} id
     * @returns {Promise} - Returns {Number}.
     */
    async ensureWID(D) {
      return typeof D == "number" ? await this.db.has(G.W.encode(D)) ? D : -1 : this.getWID(D);
    }
    /**
     * Map wallet id to wid.
     * @param {String} id
     * @returns {Promise} - Returns {Number}.
     */
    async getWID(D) {
      const Q = await this.db.get(G.l.encode(D));
      return Q ? (e(Q.length === 4), Q.readUInt32LE(0, !0)) : -1;
    }
    /**
     * Map wallet wid to id.
     * @param {Number} wid
     * @returns {Promise} - Returns {String}.
     */
    async getID(D) {
      const Q = await this.db.get(G.W.encode(D));
      return Q ? ue(Q) : null;
    }
    /**
     * Get a wallet from the database, setup watcher.
     * @param {Number|String} id
     * @returns {Promise} - Returns {@link Wallet}.
     */
    async get(D) {
      const Q = await this.ensureWID(D);
      if (Q === -1)
        return null;
      const W = await this.readLock.lock(Q);
      try {
        return await this._get(Q);
      } finally {
        W();
      }
    }
    /**
     * Get a wallet from the database without a lock.
     * @private
     * @param {Number} wid
     * @returns {Promise} - Returns {@link Wallet}.
     */
    async _get(D) {
      const Q = this.wallets.get(D);
      if (Q)
        return Q;
      const W = await this.getID(D);
      if (!W)
        return null;
      const oe = await this.db.get(G.w.encode(D));
      e(oe);
      const v = b.fromRaw(this, oe);
      return v.wid = D, v.id = W, await v.open(), this.register(v), v;
    }
    /**
     * Save a wallet to the database.
     * @param {Wallet} wallet
     */
    save(D, Q) {
      const W = Q.wid, oe = Q.id;
      D.put(G.w.encode(W), Q.toRaw()), D.put(G.W.encode(W), fe(oe)), D.put(G.l.encode(oe), L(W));
    }
    /**
     * Increment the wid depth.
     * @param {Batch} b
     * @param {Number} wid
     */
    increment(D, Q) {
      D.put(G.D.encode(), L(Q + 1));
    }
    /**
     * Rename a wallet.
     * @param {Wallet} wallet
     * @param {String} id
     * @returns {Promise}
     */
    async rename(D, Q) {
      const W = await this.writeLock.lock();
      try {
        return await this._rename(D, Q);
      } finally {
        W();
      }
    }
    /**
     * Rename a wallet without a lock.
     * @private
     * @param {Wallet} wallet
     * @param {String} id
     * @returns {Promise}
     */
    async _rename(D, Q) {
      if (!y.isName(Q))
        throw new Error("WDB: Bad wallet ID.");
      if (await this.has(Q))
        throw new Error("WDB: ID not available.");
      const W = this.db.batch();
      W.put(G.W.encode(D.wid), fe(Q)), W.del(G.l.encode(D.id)), W.put(G.l.encode(Q), L(D.wid)), await W.write(), D.id = Q;
    }
    /**
     * Rename an account.
     * @param {Account} account
     * @param {String} name
     */
    renameAccount(D, Q, W) {
      const oe = Q.wid, v = Q.accountIndex;
      D.del(G.i.encode(oe, Q.name)), D.put(G.i.encode(oe, W), L(v)), D.put(G.n.encode(oe, v), fe(W)), Q.name = W;
    }
    /**
     * Remove a wallet.
     * @param {Number|String} id
     * @returns {Promise}
     */
    async remove(D) {
      const Q = await this.ensureWID(D);
      if (Q === -1)
        return !1;
      const W = await this.readLock.lock(Q), oe = await this.writeLock.lock(), v = await this.txLock.lock();
      try {
        return await this._remove(Q);
      } finally {
        v(), oe(), W();
      }
    }
    /**
     * Remove a wallet (without a lock).
     * @private
     * @param {Number} wid
     * @returns {Promise}
     */
    async _remove(D) {
      const Q = await this.getID(D);
      if (!Q)
        return !1;
      if (Q === "primary")
        throw new Error("Cannot remove primary wallet.");
      const W = this.db.batch();
      W.del(G.w.encode(D)), W.del(G.W.encode(D)), W.del(G.l.encode(Q)), await this.db.iterator({
        gte: G.P.min(D),
        lte: G.P.max(D)
      }).each((we, z) => {
        const [, I] = G.P.decode(we);
        return W.del(we), this.removePathMap(W, I, D);
      });
      const v = (we) => this.db.iterator(we).each((z) => W.del(z));
      await v({
        gte: G.r.min(D),
        lte: G.r.max(D)
      }), await v({
        gte: G.a.min(D),
        lte: G.a.max(D)
      }), await v({
        gte: G.i.min(D),
        lte: G.i.max(D)
      }), await v({
        gte: G.n.min(D),
        lte: G.n.max(D)
      }), await v({
        gt: G.t.encode(D),
        lt: G.t.encode(D + 1)
      });
      const Y = this.db.bucket(G.t.encode(D));
      await Y.iterator({
        gte: N.b.min(),
        lte: N.b.max()
      }).each((we, z) => {
        const [I] = N.b.decode(we);
        return this.removeBlockMap(W, I, D);
      }), await Y.iterator({
        gte: N.s.min(),
        lte: N.s.max(),
        keys: !0
      }).each((we, z) => {
        const [I, ne] = N.s.decode(we);
        return this.removeOutpointMap(W, I, ne, D);
      }), await Y.iterator({
        gte: N.p.min(),
        lte: N.p.max(),
        keys: !0
      }).each((we, z) => {
        const [I] = N.p.decode(we);
        return this.removeTXMap(W, I, D);
      });
      const Ee = this.wallets.get(D);
      return Ee && (await Ee.destroy(), this.unregister(Ee)), await W.write(), !0;
    }
    /**
     * Get a wallet with token auth first.
     * @param {Number|String} id
     * @param {Buffer} token
     * @returns {Promise} - Returns {@link Wallet}.
     */
    async auth(D, Q) {
      const W = await this.get(D);
      if (!W)
        return null;
      if (!i(Q, W.token))
        throw new Error("WDB: Authentication error.");
      return W;
    }
    /**
     * Create a new wallet, save to database, setup watcher.
     * @param {Object} options - See {@link Wallet}.
     * @returns {Promise} - Returns {@link Wallet}.
     */
    async create(D) {
      const Q = await this.writeLock.lock();
      D || (D = {});
      try {
        return await this._create(D);
      } finally {
        Q();
      }
    }
    /**
     * Create a new wallet, save to database without a lock.
     * @private
     * @param {Object} options - See {@link Wallet}.
     * @returns {Promise} - Returns {@link Wallet}.
     */
    async _create(D) {
      if (D.id && await this.has(D.id))
        throw new Error("WDB: Wallet already exists.");
      const Q = b.fromOptions(this, D);
      return Q.wid = this.depth, await Q.init(D, D.passphrase), this.depth += 1, this.register(Q), this.logger.info("Created wallet %s in WalletDB.", Q.id), Q;
    }
    /**
     * Test for the existence of a wallet.
     * @param {Number|String} id
     * @returns {Promise}
     */
    async has(D) {
      return await this.ensureWID(D) !== -1;
    }
    /**
     * Attempt to create wallet, return wallet if already exists.
     * @param {Object} options - See {@link Wallet}.
     * @returns {Promise}
     */
    async ensure(D) {
      if (D.id) {
        const Q = await this.get(D.id);
        if (Q)
          return Q;
      }
      return this.create(D);
    }
    /**
     * Get an account from the database by wid.
     * @private
     * @param {Number} wid
     * @param {Number} index - Account index.
     * @returns {Promise} - Returns {@link Wallet}.
     */
    async getAccount(D, Q) {
      const W = await this.getAccountName(D, Q);
      if (!W)
        return null;
      const oe = await this.db.get(G.a.encode(D, Q));
      e(oe);
      const v = h.fromRaw(this, oe);
      return v.accountIndex = Q, v.name = W, v;
    }
    /**
     * List account names and indexes from the db.
     * @param {Number} wid
     * @returns {Promise} - Returns Array.
     */
    async getAccounts(D) {
      return this.db.values({
        gte: G.n.min(D),
        lte: G.n.max(D),
        parse: ue
      });
    }
    /**
     * Lookup the corresponding account name's index.
     * @param {Number} wid
     * @param {String} name - Account name/index.
     * @returns {Promise} - Returns Number.
     */
    async getAccountIndex(D, Q) {
      const W = await this.db.get(G.i.encode(D, Q));
      return W ? W.readUInt32LE(0, !0) : -1;
    }
    /**
     * Lookup the corresponding account index's name.
     * @param {Number} wid
     * @param {Number} index
     * @returns {Promise} - Returns Number.
     */
    async getAccountName(D, Q) {
      const W = await this.db.get(G.n.encode(D, Q));
      return W ? ue(W) : null;
    }
    /**
     * Save an account to the database.
     * @param {Account} account
     * @returns {Promise}
     */
    saveAccount(D, Q) {
      const W = Q.wid, oe = Q.accountIndex, v = Q.name;
      D.put(G.a.encode(W, oe), Q.toRaw()), D.put(G.i.encode(W, v), L(oe)), D.put(G.n.encode(W, oe), fe(v));
    }
    /**
     * Test for the existence of an account.
     * @param {Number} wid
     * @param {String|Number} acct
     * @returns {Promise} - Returns Boolean.
     */
    async hasAccount(D, Q) {
      return this.db.has(G.a.encode(D, Q));
    }
    /**
     * Save an address to the path map.
     * @param {Wallet} wallet
     * @param {WalletKey} ring
     * @returns {Promise}
     */
    async saveKey(D, Q, W) {
      return this.savePath(D, Q, W.toPath());
    }
    /**
     * Save a path to the path map.
     *
     * The path map exists in the form of:
     *   - `p[address-hash] -> wid map`
     *   - `P[wid][address-hash] -> path data`
     *   - `r[wid][account-index][address-hash] -> dummy`
     *
     * @param {Wallet} wallet
     * @param {Path} path
     * @returns {Promise}
     */
    async savePath(D, Q, W) {
      await this.addPathMap(D, W.hash, Q), D.put(G.P.encode(Q, W.hash), W.toRaw()), D.put(G.r.encode(Q, W.account, W.hash), null);
    }
    /**
     * Retrieve path by hash.
     * @param {Number} wid
     * @param {Hash} hash
     * @returns {Promise}
     */
    async getPath(D, Q) {
      const W = await this.readPath(D, Q);
      return W ? (W.name = await this.getAccountName(D, W.account), e(W.name), W) : null;
    }
    /**
     * Retrieve path by hash.
     * @param {Number} wid
     * @param {Hash} hash
     * @returns {Promise}
     */
    async readPath(D, Q) {
      const W = await this.db.get(G.P.encode(D, Q));
      if (!W)
        return null;
      const oe = S.fromRaw(W);
      return oe.hash = Q, oe;
    }
    /**
     * Test whether a wallet contains a path.
     * @param {Number} wid
     * @param {Hash} hash
     * @returns {Promise}
     */
    async hasPath(D, Q) {
      return this.db.has(G.P.encode(D, Q));
    }
    /**
     * Get all address hashes.
     * @returns {Promise}
     */
    async getHashes() {
      return this.db.keys({
        gte: G.p.min(),
        lte: G.p.max(),
        parse: (D) => G.p.decode(D)[0]
      });
    }
    /**
     * Get all outpoints.
     * @returns {Promise}
     */
    async getOutpoints() {
      return this.db.keys({
        gte: G.o.min(),
        lte: G.o.max(),
        parse: (D) => {
          const [Q, W] = G.o.decode(D);
          return new a(Q, W);
        }
      });
    }
    /**
     * Get all address hashes.
     * @param {Number} wid
     * @returns {Promise}
     */
    async getWalletHashes(D) {
      return this.db.keys({
        gte: G.P.min(D),
        lte: G.P.max(D),
        parse: (Q) => G.P.decode(Q)[1]
      });
    }
    /**
     * Get all account address hashes.
     * @param {Number} wid
     * @param {Number} account
     * @returns {Promise}
     */
    async getAccountHashes(D, Q) {
      return this.db.keys({
        gte: G.r.min(D, Q),
        lte: G.r.max(D, Q),
        parse: (W) => G.r.decode(W)[2]
      });
    }
    /**
     * Get all paths for a wallet.
     * @param {Number} wid
     * @returns {Promise}
     */
    async getWalletPaths(D) {
      const Q = await this.db.range({
        gte: G.P.min(D),
        lte: G.P.max(D)
      }), W = [];
      for (const { key: oe, value: v } of Q) {
        const [, Y] = G.P.decode(oe), he = S.fromRaw(v);
        he.hash = Y, he.name = await this.getAccountName(D, he.account), e(he.name), W.push(he);
      }
      return W;
    }
    /**
     * Get all wallet ids.
     * @returns {Promise}
     */
    async getWallets() {
      return this.db.values({
        gte: G.W.min(),
        lte: G.W.max(),
        parse: ue
      });
    }
    /**
     * Encrypt all imported keys for a wallet.
     * @param {Number} wid
     * @param {Buffer} key
     * @returns {Promise}
     */
    async encryptKeys(D, Q, W) {
      await this.db.iterator({
        gte: G.P.min(Q),
        lte: G.P.max(Q),
        values: !0
      }).each((v, Y) => {
        const [, he] = G.P.decode(v), le = S.fromRaw(Y);
        if (!le.data)
          return;
        e(!le.encrypted);
        const ge = he.slice(0, 16);
        le.data = p.encipher(le.data, W, ge), le.encrypted = !0, D.put(v, le.toRaw());
      });
    }
    /**
     * Decrypt all imported keys for a wallet.
     * @param {Number} wid
     * @param {Buffer} key
     * @returns {Promise}
     */
    async decryptKeys(D, Q, W) {
      await this.db.iterator({
        gte: G.P.min(Q),
        lte: G.P.max(Q),
        values: !0
      }).each((v, Y) => {
        const [, he] = G.P.decode(v), le = S.fromRaw(Y);
        if (!le.data)
          return;
        e(le.encrypted);
        const ge = he.slice(0, 16);
        le.data = p.decipher(le.data, W, ge), le.encrypted = !1, D.put(v, le.toRaw());
      });
    }
    /**
     * Resend all pending transactions.
     * @returns {Promise}
     */
    async resend() {
      const D = await this.db.keys({
        gte: G.w.min(),
        lte: G.w.max(),
        parse: (Q) => G.w.decode(Q)[0]
      });
      this.logger.info("Resending from %d wallets.", D.length);
      for (const Q of D)
        await this.resendPending(Q);
    }
    /**
     * Resend all pending transactions for a specific wallet.
     * @private
     * @param {Number} wid
     * @returns {Promise}
     */
    async resendPending(D) {
      const Q = G.t.encode(D), W = this.db.bucket(Q), oe = await W.keys({
        gte: N.p.min(),
        lte: N.p.max(),
        parse: (Y) => N.p.decode(Y)[0]
      });
      if (oe.length === 0)
        return;
      this.logger.info(
        "Rebroadcasting %d transactions for %d.",
        oe.length,
        D
      );
      const v = [];
      for (const Y of oe) {
        const he = await W.get(N.t.encode(Y));
        if (!he)
          continue;
        const le = q.fromRaw(he);
        le.tx.isCoinbase() || v.push(le.tx);
      }
      for (const Y of y.sortDeps(v))
        await this.send(Y);
    }
    /**
     * Get all wallet ids by output addresses and outpoints.
     * @param {Hash[]} hashes
     * @returns {Promise}
     */
    async getWalletsByTX(D) {
      const Q = /* @__PURE__ */ new Set();
      if (!D.isCoinbase())
        for (const { prevout: oe } of D.inputs) {
          const { hash: v, index: Y } = oe;
          if (!this.testFilter(oe.toRaw()))
            continue;
          const he = await this.getOutpointMap(v, Y);
          if (he)
            for (const le of he.wids)
              Q.add(le);
        }
      const W = D.getOutputHashes();
      for (const oe of W) {
        if (!this.testFilter(oe))
          continue;
        const v = await this.getPathMap(oe);
        if (v)
          for (const Y of v.wids)
            Q.add(Y);
      }
      return Q.size === 0 ? null : Q;
    }
    /**
     * Get the best block hash.
     * @returns {Promise}
     */
    async getState() {
      const D = await this.db.get(G.R.encode());
      return D ? T.fromRaw(D) : null;
    }
    /**
     * Sync the current chain state to tip.
     * @param {BlockMeta} tip
     * @returns {Promise}
     */
    async setTip(D) {
      const Q = this.db.batch(), W = this.state.clone();
      if (D.height < W.height)
        for (; W.height !== D.height; )
          Q.del(G.h.encode(W.height)), W.height -= 1;
      else D.height > W.height && (e(D.height === W.height + 1, "Bad chain sync."), W.height += 1);
      D.height < W.startHeight && (W.startHeight = D.height, W.startHash = D.hash, W.marked = !1), Q.put(G.h.encode(D.height), D.toHash()), Q.put(G.R.encode(), W.toRaw()), await Q.write(), this.state = W, this.height = W.height;
    }
    /**
     * Will return the current height and will increment
     * to the current height of a block currently being
     * added to the wallet.
     * @returns {Number}
     */
    liveHeight() {
      let D = this.height;
      return this.confirming && (D += 1), D;
    }
    /**
     * Mark current state.
     * @param {BlockMeta} block
     * @returns {Promise}
     */
    async markState(D) {
      const Q = this.state.clone();
      Q.startHeight = D.height, Q.startHash = D.hash, Q.marked = !0;
      const W = this.db.batch();
      W.put(G.R.encode(), Q.toRaw()), await W.write(), this.state = Q, this.height = Q.height;
    }
    /**
     * Get a wallet map.
     * @param {Buffer} key
     * @returns {Promise}
     */
    async getMap(D) {
      const Q = await this.db.get(D);
      return Q ? _.fromRaw(Q) : null;
    }
    /**
     * Add wid to a wallet map.
     * @param {Wallet} wallet
     * @param {Buffer} key
     * @param {Number} wid
     */
    async addMap(D, Q, W) {
      const oe = await this.db.get(Q);
      if (!oe) {
        const he = new _();
        he.add(W), D.put(Q, he.toRaw());
        return;
      }
      e(oe.length >= 4);
      const v = oe.readUInt32LE(0, !0), Y = w.write(oe.length + 4);
      Y.writeU32(v + 1), Y.copy(oe, 4, oe.length), Y.writeU32(W), D.put(Q, Y.render());
    }
    /**
     * Remove wid from a wallet map.
     * @param {Wallet} wallet
     * @param {Buffer} key
     * @param {Number} wid
     */
    async removeMap(D, Q, W) {
      const oe = await this.getMap(Q);
      if (oe && oe.remove(W)) {
        if (oe.size === 0) {
          D.del(Q);
          return;
        }
        D.put(Q, oe.toRaw());
      }
    }
    /**
     * Get a wallet map.
     * @param {Buffer} key
     * @returns {Promise}
     */
    async getPathMap(D) {
      return this.getMap(G.p.encode(D));
    }
    /**
     * Add wid to a wallet map.
     * @param {Wallet} wallet
     * @param {Buffer} key
     * @param {Number} wid
     */
    async addPathMap(D, Q, W) {
      return await this.addHash(Q), this.addMap(D, G.p.encode(Q), W);
    }
    /**
     * Remove wid from a wallet map.
     * @param {Wallet} wallet
     * @param {Buffer} key
     * @param {Number} wid
     */
    async removePathMap(D, Q, W) {
      return this.removeMap(D, G.p.encode(Q), W);
    }
    /**
     * Get a wallet map.
     * @param {Buffer} key
     * @returns {Promise}
     */
    async getBlockMap(D) {
      return this.getMap(G.b.encode(D));
    }
    /**
     * Add wid to a wallet map.
     * @param {Wallet} wallet
     * @param {Buffer} key
     * @param {Number} wid
     */
    async addBlockMap(D, Q, W) {
      return this.addMap(D, G.b.encode(Q), W);
    }
    /**
     * Remove wid from a wallet map.
     * @param {Wallet} wallet
     * @param {Buffer} key
     * @param {Number} wid
     */
    async removeBlockMap(D, Q, W) {
      return this.removeMap(D, G.b.encode(Q), W);
    }
    /**
     * Get a wallet map.
     * @param {Buffer} key
     * @returns {Promise}
     */
    async getTXMap(D) {
      return this.getMap(G.T.encode(D));
    }
    /**
     * Add wid to a wallet map.
     * @param {Wallet} wallet
     * @param {Buffer} key
     * @param {Number} wid
     */
    async addTXMap(D, Q, W) {
      return this.addMap(D, G.T.encode(Q), W);
    }
    /**
     * Remove wid from a wallet map.
     * @param {Wallet} wallet
     * @param {Buffer} key
     * @param {Number} wid
     */
    async removeTXMap(D, Q, W) {
      return this.removeMap(D, G.T.encode(Q), W);
    }
    /**
     * Get a wallet map.
     * @param {Buffer} key
     * @returns {Promise}
     */
    async getOutpointMap(D, Q) {
      return this.getMap(G.o.encode(D, Q));
    }
    /**
     * Add wid to a wallet map.
     * @param {Wallet} wallet
     * @param {Buffer} key
     * @param {Number} wid
     */
    async addOutpointMap(D, Q, W, oe) {
      return await this.addOutpoint(Q, W), this.addMap(D, G.o.encode(Q, W), oe);
    }
    /**
     * Remove wid from a wallet map.
     * @param {Wallet} wallet
     * @param {Buffer} key
     * @param {Number} wid
     */
    async removeOutpointMap(D, Q, W, oe) {
      return this.removeMap(D, G.o.encode(Q, W), oe);
    }
    /**
     * Get a wallet block meta.
     * @param {Hash} hash
     * @returns {Promise}
     */
    async getBlock(D) {
      const Q = await this.db.get(G.h.encode(D));
      if (!Q)
        return null;
      const W = new A();
      return W.hash = Q, W.height = D, W;
    }
    /**
     * Get wallet tip.
     * @param {Hash} hash
     * @returns {Promise}
     */
    async getTip() {
      const D = await this.getBlock(this.state.height);
      if (!D)
        throw new Error("WDB: Tip not found!");
      return D;
    }
    /**
     * Sync with chain height.
     * @param {Number} height
     * @returns {Promise}
     */
    async rollback(D) {
      if (D > this.state.height)
        throw new Error("WDB: Cannot rollback to the future.");
      if (D === this.state.height) {
        this.logger.info("Rolled back to same height (%d).", D);
        return;
      }
      this.logger.info(
        "Rolling back %d WalletDB blocks to height %d.",
        this.state.height - D,
        D
      );
      const Q = await this.getBlock(D);
      e(Q), await this.revert(Q.height), await this.setTip(Q);
    }
    /**
     * Revert TXDB to an older state.
     * @param {Number} target
     * @returns {Promise}
     */
    async revert(D) {
      const Q = this.db.iterator({
        gte: G.b.encode(D + 1),
        lte: G.b.max(),
        reverse: !0,
        values: !0
      });
      let W = 0;
      await Q.each(async (oe, v) => {
        const [Y] = G.b.decode(oe), he = _.fromRaw(v);
        for (const le of he.wids) {
          const ge = await this.get(le);
          e(ge), W += await ge.revert(Y);
        }
      }), this.logger.info("Rolled back %d WalletDB transactions.", W);
    }
    /**
     * Add a block's transactions and write the new best hash.
     * @param {ChainEntry} entry
     * @returns {Promise}
     */
    async addBlock(D, Q) {
      const W = await this.txLock.lock();
      try {
        return await this._addBlock(D, Q);
      } finally {
        W();
      }
    }
    /**
     * Add a block's transactions without a lock.
     * @private
     * @param {ChainEntry} entry
     * @param {TX[]} txs
     * @returns {Promise}
     */
    async _addBlock(D, Q) {
      const W = A.fromEntry(D);
      if (W.height < this.state.height)
        return this.logger.warning(
          "WalletDB is connecting low blocks (%d).",
          W.height
        ), 0;
      if (W.height >= this.network.block.slowHeight && this.logger.debug("Adding block: %d.", W.height), W.height === this.state.height)
        this.logger.warning("Already saw WalletDB block (%d).", W.height);
      else if (W.height !== this.state.height + 1)
        return await this.scan(this.state.height), 0;
      let oe = 0;
      try {
        this.confirming = !0;
        for (const v of Q)
          await this._addTX(v, W) && (oe += 1);
        await this.setTip(W);
      } finally {
        this.confirming = !1;
      }
      return oe > 0 && this.logger.info(
        "Connected WalletDB block %h (tx=%d).",
        W.hash,
        oe
      ), oe;
    }
    /**
     * Unconfirm a block's transactions
     * and write the new best hash (SPV version).
     * @param {ChainEntry} entry
     * @returns {Promise}
     */
    async removeBlock(D) {
      const Q = await this.txLock.lock();
      try {
        return await this._removeBlock(D);
      } finally {
        Q();
      }
    }
    /**
     * Unconfirm a block's transactions.
     * @private
     * @param {ChainEntry} entry
     * @returns {Promise}
     */
    async _removeBlock(D) {
      const Q = A.fromEntry(D);
      if (Q.height === 0)
        throw new Error("WDB: Bad disconnection (genesis block).");
      if (Q.height > this.state.height)
        return this.logger.warning(
          "WalletDB is disconnecting high blocks (%d).",
          Q.height
        ), 0;
      if (Q.height !== this.state.height)
        throw new Error("WDB: Bad disconnection (height mismatch).");
      const W = await this.getBlock(Q.height - 1);
      e(W);
      const oe = await this.getBlockMap(Q.height);
      if (!oe)
        return await this.setTip(W), 0;
      let v = 0;
      for (const Y of oe.wids) {
        const he = await this.get(Y);
        e(he), v += await he.revert(Q.height);
      }
      return await this.setTip(W), this.logger.warning(
        "Disconnected wallet block %h (tx=%d).",
        Q.hash,
        v
      ), v;
    }
    /**
     * Rescan a block.
     * @private
     * @param {ChainEntry} entry
     * @param {TX[]} txs
     * @returns {Promise}
     */
    async rescanBlock(D, Q) {
      if (!this.rescanning) {
        this.logger.warning("Unsolicited rescan block: %d.", D.height);
        return;
      }
      if (D.height > this.state.height + 1) {
        this.logger.warning("Rescan block too high: %d.", D.height);
        return;
      }
      try {
        await this._addBlock(D, Q);
      } catch (W) {
        throw this.emit("error", W), W;
      }
    }
    /**
     * Add a transaction to the database, map addresses
     * to wallet IDs, potentially store orphans, resolve
     * orphans, or confirm a transaction.
     * @param {TX} tx
     * @param {BlockMeta?} block
     * @returns {Promise}
     */
    async addTX(D, Q) {
      const W = await this.txLock.lock();
      try {
        return await this._addTX(D, Q);
      } finally {
        W();
      }
    }
    /**
     * Add a transaction to the database without a lock.
     * @private
     * @param {TX} tx
     * @param {BlockMeta} block
     * @returns {Promise}
     */
    async _addTX(D, Q) {
      const W = await this.getWalletsByTX(D);
      if (e(!D.mutable, "WDB: Cannot add mutable TX."), !W)
        return null;
      Q && !this.state.marked && await this.markState(Q), this.logger.info(
        "Incoming transaction for %d wallets in WalletDB (%h).",
        W.size,
        D.hash()
      );
      let oe = !1;
      for (const v of W) {
        const Y = await this.get(v);
        e(Y), await Y.add(D, Q) && (this.logger.info(
          "Added transaction to wallet in WalletDB: %s (%d).",
          Y.id,
          v
        ), oe = !0);
      }
      return oe ? W : null;
    }
    /**
     * Handle a chain reset.
     * @param {ChainEntry} entry
     * @returns {Promise}
     */
    async resetChain(D) {
      const Q = await this.txLock.lock();
      try {
        return await this._resetChain(D);
      } finally {
        Q();
      }
    }
    /**
     * Handle a chain reset without a lock.
     * @private
     * @param {ChainEntry} entry
     * @returns {Promise}
     */
    async _resetChain(D) {
      if (D.height > this.state.height)
        throw new Error("WDB: Bad reset height.");
      return this.rollback(D.height);
    }
  }
  class R {
    /**
     * Create wallet options.
     * @constructor
     * @param {Object} options
     */
    constructor(D) {
      this.network = g.primary, this.logger = s.global, this.workers = null, this.client = null, this.feeRate = 0, this.prefix = null, this.location = null, this.memory = !0, this.maxFiles = 64, this.cacheSize = 16 << 20, this.compression = !0, this.spv = !1, this.checkpoints = !1, this.wipeNoReally = !1, D && this.fromOptions(D);
    }
    /**
     * Inject properties from object.
     * @private
     * @param {Object} options
     * @returns {WalletOptions}
     */
    fromOptions(D) {
      return D.network != null && (this.network = g.get(D.network)), D.logger != null && (e(typeof D.logger == "object"), this.logger = D.logger), D.workers != null && (e(typeof D.workers == "object"), this.workers = D.workers), D.client != null && (e(typeof D.client == "object"), this.client = D.client), D.feeRate != null && (e(D.feeRate >>> 0 === D.feeRate), this.feeRate = D.feeRate), D.prefix != null && (e(typeof D.prefix == "string"), this.prefix = D.prefix, this.location = c.join(this.prefix, "wallet")), D.location != null && (e(typeof D.location == "string"), this.location = D.location), D.memory != null && (e(typeof D.memory == "boolean"), this.memory = D.memory), D.maxFiles != null && (e(D.maxFiles >>> 0 === D.maxFiles), this.maxFiles = D.maxFiles), D.cacheSize != null && (e(Number.isSafeInteger(D.cacheSize) && D.cacheSize >= 0), this.cacheSize = D.cacheSize), D.compression != null && (e(typeof D.compression == "boolean"), this.compression = D.compression), D.spv != null && (e(typeof D.spv == "boolean"), this.spv = D.spv), D.checkpoints != null && (e(typeof D.checkpoints == "boolean"), this.checkpoints = D.checkpoints), D.wipeNoReally != null && (e(typeof D.wipeNoReally == "boolean"), this.wipeNoReally = D.wipeNoReally), this;
    }
    /**
     * Instantiate chain options from object.
     * @param {Object} options
     * @returns {WalletOptions}
     */
    static fromOptions(D) {
      return new this().fromOptions(D);
    }
  }
  function L(ae) {
    const D = k.allocUnsafe(4);
    return D.writeUInt32LE(ae, 0, !0), D;
  }
  function fe(ae) {
    const D = k.alloc(1 + ae.length);
    return D[0] = ae.length, D.write(ae, 1, ae.length, "ascii"), D;
  }
  function ue(ae) {
    return e(ae.length > 0), e(ae[0] === ae.length - 1), ae.toString("ascii", 1, ae.length);
  }
  return Hh = F, Hh;
}
var Lh = {}, Kh, Zb;
function $p() {
  if (Zb) return Kh;
  Zb = 1;
  const e = Nt(), c = fi(), l = 2147483648, w = new Uint32Array([
    1,
    0,
    32898,
    0,
    32906,
    2147483648,
    2147516416,
    2147483648,
    32907,
    0,
    2147483649,
    0,
    2147516545,
    2147483648,
    32777,
    2147483648,
    138,
    0,
    136,
    0,
    2147516425,
    0,
    2147483658,
    0,
    2147516555,
    0,
    139,
    2147483648,
    32905,
    2147483648,
    32771,
    2147483648,
    32770,
    2147483648,
    128,
    2147483648,
    32778,
    0,
    2147483658,
    2147483648,
    2147516545,
    2147483648,
    32896,
    2147483648,
    2147483649,
    0,
    2147516424,
    2147483648
  ]);
  class m {
    constructor() {
      this.state = new Uint32Array(50), this.block = k.alloc(200), this.bs = 136, this.pos = l;
    }
    init(u) {
      u == null && (u = 256), e(u >>> 0 === u), e(u >= 128), e(u <= 512);
      const o = 1600 - u * 2;
      return e(o >= 0 && (o & 63) === 0), this.bs = o >>> 3, this.pos = 0, this;
    }
    update(u) {
      e(k.isBuffer(u)), e(!(this.pos & l), "Context is not initialized.");
      let o = u.length, s = this.pos, i = 0;
      if (this.pos = (this.pos + o) % this.bs, s > 0) {
        let p = this.bs - s;
        if (p > o && (p = o), u.copy(this.block, s, i, i + p), s += p, o -= p, i += p, s < this.bs)
          return this;
        this._transform(this.block, 0);
      }
      for (; o >= this.bs; )
        this._transform(u, i), i += this.bs, o -= this.bs;
      return o > 0 && u.copy(this.block, 0, i, i + o), this;
    }
    final(u, o) {
      u == null && (u = 1), (o == null || o === 0) && (o = 100 - (this.bs >>> 1)), e((u & 255) === u), e(o >>> 0 === o), e(!(this.pos & l), "Context is not initialized."), this.block.fill(0, this.pos, this.bs), this.block[this.pos] |= u, this.block[this.bs - 1] |= 128, this._transform(this.block, 0), this.pos = l, e(o <= this.bs);
      const s = k.alloc(o);
      for (let i = 0; i < o; i++)
        s[i] = this.state[i >>> 2] >>> 8 * (i & 3);
      for (let i = 0; i < 50; i++)
        this.state[i] = 0;
      for (let i = 0; i < this.bs; i++)
        this.block[i] = 0;
      return s;
    }
    _transform(u, o) {
      const s = this.bs >>> 2, i = this.state;
      for (let p = 0; p < s; p++)
        i[p] ^= f(u, o + p * 4);
      for (let p = 0; p < 48; p += 2) {
        const g = i[0] ^ i[10] ^ i[20] ^ i[30] ^ i[40], S = i[1] ^ i[11] ^ i[21] ^ i[31] ^ i[41], y = i[2] ^ i[12] ^ i[22] ^ i[32] ^ i[42], b = i[3] ^ i[13] ^ i[23] ^ i[33] ^ i[43], h = i[4] ^ i[14] ^ i[24] ^ i[34] ^ i[44], a = i[5] ^ i[15] ^ i[25] ^ i[35] ^ i[45], E = i[6] ^ i[16] ^ i[26] ^ i[36] ^ i[46], H = i[7] ^ i[17] ^ i[27] ^ i[37] ^ i[47], j = i[8] ^ i[18] ^ i[28] ^ i[38] ^ i[48], G = i[9] ^ i[19] ^ i[29] ^ i[39] ^ i[49], N = j ^ (y << 1 | b >>> 31), T = G ^ (b << 1 | y >>> 31), A = g ^ (h << 1 | a >>> 31), q = S ^ (a << 1 | h >>> 31), _ = y ^ (E << 1 | H >>> 31), F = b ^ (H << 1 | E >>> 31), R = h ^ (j << 1 | G >>> 31), L = a ^ (G << 1 | j >>> 31), fe = E ^ (g << 1 | S >>> 31), ue = H ^ (S << 1 | g >>> 31);
        i[0] ^= N, i[1] ^= T, i[10] ^= N, i[11] ^= T, i[20] ^= N, i[21] ^= T, i[30] ^= N, i[31] ^= T, i[40] ^= N, i[41] ^= T, i[2] ^= A, i[3] ^= q, i[12] ^= A, i[13] ^= q, i[22] ^= A, i[23] ^= q, i[32] ^= A, i[33] ^= q, i[42] ^= A, i[43] ^= q, i[4] ^= _, i[5] ^= F, i[14] ^= _, i[15] ^= F, i[24] ^= _, i[25] ^= F, i[34] ^= _, i[35] ^= F, i[44] ^= _, i[45] ^= F, i[6] ^= R, i[7] ^= L, i[16] ^= R, i[17] ^= L, i[26] ^= R, i[27] ^= L, i[36] ^= R, i[37] ^= L, i[46] ^= R, i[47] ^= L, i[8] ^= fe, i[9] ^= ue, i[18] ^= fe, i[19] ^= ue, i[28] ^= fe, i[29] ^= ue, i[38] ^= fe, i[39] ^= ue, i[48] ^= fe, i[49] ^= ue;
        const ae = i[0], D = i[1], Q = i[11] << 4 | i[10] >>> 28, W = i[10] << 4 | i[11] >>> 28, oe = i[20] << 3 | i[21] >>> 29, v = i[21] << 3 | i[20] >>> 29, Y = i[31] << 9 | i[30] >>> 23, he = i[30] << 9 | i[31] >>> 23, le = i[40] << 18 | i[41] >>> 14, ge = i[41] << 18 | i[40] >>> 14, Ee = i[2] << 1 | i[3] >>> 31, we = i[3] << 1 | i[2] >>> 31, z = i[13] << 12 | i[12] >>> 20, I = i[12] << 12 | i[13] >>> 20, ne = i[22] << 10 | i[23] >>> 22, t = i[23] << 10 | i[22] >>> 22, d = i[33] << 13 | i[32] >>> 19, B = i[32] << 13 | i[33] >>> 19, U = i[42] << 2 | i[43] >>> 30, J = i[43] << 2 | i[42] >>> 30, C = i[5] << 30 | i[4] >>> 2, M = i[4] << 30 | i[5] >>> 2, $ = i[14] << 6 | i[15] >>> 26, r = i[15] << 6 | i[14] >>> 26, x = i[25] << 11 | i[24] >>> 21, O = i[24] << 11 | i[25] >>> 21, K = i[34] << 15 | i[35] >>> 17, X = i[35] << 15 | i[34] >>> 17, P = i[45] << 29 | i[44] >>> 3, V = i[44] << 29 | i[45] >>> 3, re = i[6] << 28 | i[7] >>> 4, ce = i[7] << 28 | i[6] >>> 4, de = i[17] << 23 | i[16] >>> 9, pe = i[16] << 23 | i[17] >>> 9, se = i[26] << 25 | i[27] >>> 7, Z = i[27] << 25 | i[26] >>> 7, ee = i[36] << 21 | i[37] >>> 11, me = i[37] << 21 | i[36] >>> 11, Ae = i[47] << 24 | i[46] >>> 8, Oe = i[46] << 24 | i[47] >>> 8, ye = i[8] << 27 | i[9] >>> 5, _e = i[9] << 27 | i[8] >>> 5, ke = i[18] << 20 | i[19] >>> 12, Me = i[19] << 20 | i[18] >>> 12, De = i[29] << 7 | i[28] >>> 25, Ne = i[28] << 7 | i[29] >>> 25, $e = i[38] << 8 | i[39] >>> 24, bt = i[39] << 8 | i[38] >>> 24, Ve = i[48] << 14 | i[49] >>> 18, je = i[49] << 14 | i[48] >>> 18;
        i[0] = ae ^ ~z & x, i[1] = D ^ ~I & O, i[10] = re ^ ~ke & oe, i[11] = ce ^ ~Me & v, i[20] = Ee ^ ~$ & se, i[21] = we ^ ~r & Z, i[30] = ye ^ ~Q & ne, i[31] = _e ^ ~W & t, i[40] = C ^ ~de & De, i[41] = M ^ ~pe & Ne, i[2] = z ^ ~x & ee, i[3] = I ^ ~O & me, i[12] = ke ^ ~oe & d, i[13] = Me ^ ~v & B, i[22] = $ ^ ~se & $e, i[23] = r ^ ~Z & bt, i[32] = Q ^ ~ne & K, i[33] = W ^ ~t & X, i[42] = de ^ ~De & Y, i[43] = pe ^ ~Ne & he, i[4] = x ^ ~ee & Ve, i[5] = O ^ ~me & je, i[14] = oe ^ ~d & P, i[15] = v ^ ~B & V, i[24] = se ^ ~$e & le, i[25] = Z ^ ~bt & ge, i[34] = ne ^ ~K & Ae, i[35] = t ^ ~X & Oe, i[44] = De ^ ~Y & U, i[45] = Ne ^ ~he & J, i[6] = ee ^ ~Ve & ae, i[7] = me ^ ~je & D, i[16] = d ^ ~P & re, i[17] = B ^ ~V & ce, i[26] = $e ^ ~le & Ee, i[27] = bt ^ ~ge & we, i[36] = K ^ ~Ae & ye, i[37] = X ^ ~Oe & _e, i[46] = Y ^ ~U & C, i[47] = he ^ ~J & M, i[8] = Ve ^ ~ae & z, i[9] = je ^ ~D & I, i[18] = P ^ ~re & ke, i[19] = V ^ ~ce & Me, i[28] = le ^ ~Ee & $, i[29] = ge ^ ~we & r, i[38] = Ae ^ ~ye & Q, i[39] = Oe ^ ~_e & W, i[48] = U ^ ~C & de, i[49] = J ^ ~M & pe, i[0] ^= w[p + 0], i[1] ^= w[p + 1];
      }
    }
    static hash() {
      return new m();
    }
    static hmac(u, o, s) {
      u == null && (u = 256), e(u >>> 0 === u);
      const i = 1600 - u * 2;
      return e(i >= 0 && (i & 63) === 0), new c(m, i >>> 3, [u], [o, s]);
    }
    static digest(u, o, s, i) {
      return m.ctx.init(o).update(u).final(s, i);
    }
    static root(u, o, s, i, p) {
      return s == null && (s = 256), p == null && (p = 0), p === 0 && (p = s >>> 3), e(s >>> 0 === s), e((s & 7) === 0), e(p >>> 0 === p), e(k.isBuffer(u) && u.length === p), e(k.isBuffer(o) && o.length === p), m.ctx.init(s).update(u).update(o).final(i, p);
    }
    static multi(u, o, s, i, p, g) {
      const { ctx: S } = m;
      return S.init(i), S.update(u), S.update(o), s && S.update(s), S.final(p, g);
    }
    static mac(u, o, s, i, p) {
      return m.hmac(s, i, p).init(o).update(u).final();
    }
  }
  m.native = 0, m.id = "KECCAK256", m.size = 32, m.bits = 256, m.blockSize = 136, m.zero = k.alloc(32, 0), m.ctx = new m();
  function f(n, u) {
    return n[u++] + n[u++] * 256 + n[u++] * 65536 + n[u] * 16777216;
  }
  return Kh = m, Kh;
}
/*!
 * p224.js - ECDSA-P224 for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var Vh, Qb;
function jy() {
  if (Qb) return Vh;
  Qb = 1;
  const e = as(), c = Ar();
  return Vh = new e("P224", c, c), Vh;
}
/*!
 * p256.js - ECDSA-P256 for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var $h, e8;
function Yy() {
  if (e8) return $h;
  e8 = 1;
  const e = as(), c = Ar();
  return $h = new e("P256", c, c), $h;
}
var jh, t8;
function jp() {
  if (t8) return jh;
  t8 = 1;
  const e = Nt(), c = En(), l = fi();
  class w extends c {
    constructor() {
      super();
    }
    init() {
      return this.state[0] = 3418070365, this.state[1] = 3238371032, this.state[2] = 1654270250, this.state[3] = 914150663, this.state[4] = 2438529370, this.state[5] = 812702999, this.state[6] = 355462360, this.state[7] = 4144912697, this.state[8] = 1731405415, this.state[9] = 4290775857, this.state[10] = 2394180231, this.state[11] = 1750603025, this.state[12] = 3675008525, this.state[13] = 1694076839, this.state[14] = 1203062813, this.state[15] = 3204075428, this.size = 0, this;
    }
    final() {
      return super.final().slice(0, 48);
    }
    static hash() {
      return new w();
    }
    static hmac() {
      return new l(w, 128);
    }
    static digest(f) {
      return w.ctx.init().update(f).final();
    }
    static root(f, n) {
      return e(k.isBuffer(f) && f.length === 48), e(k.isBuffer(n) && n.length === 48), w.ctx.init().update(f).update(n).final();
    }
    static multi(f, n, u) {
      const { ctx: o } = w;
      return o.init(), o.update(f), o.update(n), u && o.update(u), o.final();
    }
    static mac(f, n) {
      return w.hmac().init(n).update(f).final();
    }
  }
  return w.native = 0, w.id = "SHA384", w.size = 48, w.bits = 384, w.blockSize = 128, w.zero = k.alloc(48, 0), w.ctx = new w(), jh = w, jh;
}
/*!
 * p384.js - ECDSA-P384 for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var Yh, r8;
function Xy() {
  if (r8) return Yh;
  r8 = 1;
  const e = as(), c = jp();
  return Yh = new e("P384", c, c), Yh;
}
var Xh, i8;
function Yp() {
  if (i8) return Xh;
  i8 = 1;
  const e = $p();
  class c extends e {
    /**
     * Create a SHAKE Context.
     * @constructor
     */
    constructor() {
      super();
    }
    final(w) {
      return super.final(31, w);
    }
    static hash() {
      return new c();
    }
    static hmac(w, m) {
      return super.hmac(w, 31, m);
    }
    static digest(w, m, f) {
      return super.digest(w, m, 31, f);
    }
    static root(w, m, f, n) {
      return super.root(w, m, f, 31, n);
    }
    static multi(w, m, f, n, u) {
      return super.multi(w, m, f, n, 31, u);
    }
    static mac(w, m, f, n) {
      return super.mac(w, m, f, 31, n);
    }
  }
  return c.native = e.native, c.id = "SHAKE256", c.size = 32, c.bits = 256, c.blockSize = 136, c.zero = k.alloc(32, 0), c.ctx = new c(), Xh = c, Xh;
}
var Gh, n8;
function Xp() {
  if (n8) return Gh;
  n8 = 1;
  const e = Yp();
  class c extends e {
    constructor() {
      super();
    }
    init() {
      return super.init(256);
    }
    static hash() {
      return new c();
    }
    static hmac(w) {
      return super.hmac(256, w);
    }
    static digest(w, m) {
      return super.digest(w, 256, m);
    }
    static root(w, m, f) {
      return super.root(w, m, 256, f);
    }
    static multi(w, m, f, n) {
      return super.multi(w, m, f, 256, n);
    }
    static mac(w, m, f) {
      return super.mac(w, m, 256, f);
    }
  }
  return c.native = e.native, c.id = "SHAKE256", c.size = 32, c.bits = 256, c.blockSize = 136, c.zero = k.alloc(32, 0), c.ctx = new c(), Gh = c, Gh;
}
/*!
 * p521.js - ECDSA-P521 for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var Jh, s8;
function Gy() {
  if (s8) return Jh;
  s8 = 1;
  const e = as(), c = En(), l = Xp();
  return Jh = new e("P521", c, l), Jh;
}
var Ct = {}, $n = {};
/*!
 * primes.js - Prime number generation for javascript
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on golang/go:
 *   Copyright (c) 2009, The Go Authors. All rights reserved.
 *   https://github.com/golang/go
 *
 * Parts of this software are based on indutny/miller-rabin:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/miller-rabin
 *
 * Resources:
 *   https://github.com/golang/go/blob/master/src/crypto/rsa/rsa.go
 *   https://github.com/golang/go/blob/master/src/math/big/prime.go
 *   https://github.com/golang/go/blob/master/src/math/big/int.go
 *   https://github.com/golang/go/blob/master/src/math/big/nat.go
 *   https://github.com/golang/go/blob/master/src/crypto/rand/util.go
 *   https://github.com/indutny/miller-rabin/blob/master/lib/mr.js
 */
var o8;
function Jy() {
  if (o8) return $n;
  o8 = 1;
  const e = Nt(), c = Xr(), l = yi(), w = new Uint8Array([
    3,
    5,
    7,
    11,
    13,
    17,
    19,
    23,
    29,
    31,
    37,
    41,
    43,
    47,
    53
  ]), m = new c("16294579238595022365", 10), f = 10412 | 1 << 17 | 1 << 19 | 1 << 23 | 1 << 29 | 1 << 31, n = 35360 | 1 << 21 | 1 << 27 | 1 << 29, u = new c(1155 * 13 * 17 * 19 * 23 * 37), o = new c(899 * 41 * 43 * 47 * 53);
  function s(g, S = 20, y = l) {
    if (e(g >>> 0 === g), e(S >>> 0 === S), e(y != null), g < 2)
      throw new Error("Prime must be at least 2 bits.");
    for (; ; ) {
      const b = c.randomBits(y, g);
      b.setn(g - 1, 1), b.setn(g - 2, 1), b.setn(0, 1);
      const h = b.mod(m);
      e:
        for (let a = 0; a < 1 << 20; a += 2) {
          const E = h.addn(a);
          for (let H = 0; H < w.length; H++) {
            const j = w[H];
            if (E.modrn(j) === 0 && (g > 6 || E.cmpn(j) !== 0))
              continue e;
          }
          b.iaddn(a);
          break;
        }
      if (b.bitLength() === g && i(b, S, y))
        return b;
    }
  }
  function i(g, S, y = l) {
    if (e(g instanceof c), g.sign() <= 0)
      return !1;
    if (g.cmpn(64) < 0) {
      const a = g.word(0);
      return a > 31 ? (n & 1 << a - 32) !== 0 : (f & 1 << a) !== 0;
    }
    if (g.isEven())
      return !1;
    const b = g.mod(u).toNumber(), h = g.mod(o).toNumber();
    return b % 3 === 0 || b % 5 === 0 || b % 7 === 0 || b % 11 === 0 || b % 13 === 0 || b % 17 === 0 || b % 19 === 0 || b % 23 === 0 || b % 37 === 0 || h % 29 === 0 || h % 31 === 0 || h % 41 === 0 || h % 43 === 0 || h % 47 === 0 || h % 53 === 0 ? !1 : g.isPrime(y, S);
  }
  function p(g, S, y) {
    if (!i(g, S, y))
      return !1;
    const b = g.subn(1).iushrn(1);
    return !!i(b, S, y);
  }
  return $n.randomPrime = s, $n.isProbablePrime = i, $n.isSafePrime = p, $n;
}
var Qr = {}, a8;
function Wy() {
  if (a8) return Qr;
  a8 = 1;
  const e = Nt(), c = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", l = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", w = [
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    62,
    -1,
    -1,
    -1,
    63,
    52,
    53,
    54,
    55,
    56,
    57,
    58,
    59,
    60,
    61,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    16,
    17,
    18,
    19,
    20,
    21,
    22,
    23,
    24,
    25,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    26,
    27,
    28,
    29,
    30,
    31,
    32,
    33,
    34,
    35,
    36,
    37,
    38,
    39,
    40,
    41,
    42,
    43,
    44,
    45,
    46,
    47,
    48,
    49,
    50,
    51,
    -1,
    -1,
    -1,
    -1,
    -1
  ], m = [
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    62,
    -1,
    -1,
    52,
    53,
    54,
    55,
    56,
    57,
    58,
    59,
    60,
    61,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    16,
    17,
    18,
    19,
    20,
    21,
    22,
    23,
    24,
    25,
    -1,
    -1,
    -1,
    -1,
    63,
    -1,
    26,
    27,
    28,
    29,
    30,
    31,
    32,
    33,
    34,
    35,
    36,
    37,
    38,
    39,
    40,
    41,
    42,
    43,
    44,
    45,
    46,
    47,
    48,
    49,
    50,
    51,
    -1,
    -1,
    -1,
    -1,
    -1
  ];
  function f(h, a, E) {
    e(k.isBuffer(h));
    let H = h.length, j = "", G = 0;
    for (; H >= 3; ) {
      const N = h[G++], T = h[G++], A = h[G++];
      j += a[N >> 2], j += a[(N & 3) << 4 | T >> 4], j += a[(T & 15) << 2 | A >> 6], j += a[A & 63], H -= 3;
    }
    switch (H) {
      case 1: {
        const N = h[G++];
        j += a[N >> 2], j += a[(N & 3) << 4], E && (j += "==");
        break;
      }
      case 2: {
        const N = h[G++], T = h[G++];
        j += a[N >> 2], j += a[(N & 3) << 4 | T >> 4], j += a[(T & 15) << 2], E && (j += "=");
        break;
      }
    }
    return j;
  }
  function n(h, a, E) {
    e(typeof h == "string");
    const H = k.alloc(E);
    let j = h.length, G = 0, N = 0;
    if (j > 0 && h[j - 1] === "=" && (j -= 1), j > 0 && h[j - 1] === "=" && (j -= 1), (j & 3) === 1)
      throw new Error("Invalid base64 string.");
    for (; j >= 4; ) {
      const T = h.charCodeAt(G++), A = h.charCodeAt(G++), q = h.charCodeAt(G++), _ = h.charCodeAt(G++);
      if ((T | A | q | _) & 65408)
        throw new Error("Invalid base64 string.");
      const F = a[T], R = a[A], L = a[q], fe = a[_];
      if ((F | R | L | fe) < 0)
        throw new Error("Invalid base64 string.");
      H[N++] = F << 2 | R >> 4, H[N++] = R << 4 | L >> 2, H[N++] = L << 6 | fe >> 0, j -= 4;
    }
    switch (j) {
      case 1:
        throw new Error("Invalid base64 string.");
      case 2: {
        const T = h.charCodeAt(G++), A = h.charCodeAt(G++);
        if ((T | A) & 65408)
          throw new Error("Invalid base64 string.");
        const q = a[T], _ = a[A];
        if ((q | _) < 0)
          throw new Error("Invalid base64 string.");
        if (H[N++] = q << 2 | _ >> 4, _ & 15)
          throw new Error("Invalid base64 string.");
        break;
      }
      case 3: {
        const T = h.charCodeAt(G++), A = h.charCodeAt(G++), q = h.charCodeAt(G++);
        if ((T | A | q) & 65408)
          throw new Error("Invalid base64 string.");
        const _ = a[T], F = a[A], R = a[q];
        if ((_ | F | R) < 0)
          throw new Error("Invalid base64 string.");
        if (H[N++] = _ << 2 | F >> 4, H[N++] = F << 4 | R >> 2, R & 3)
          throw new Error("Invalid base64 string.");
        break;
      }
    }
    return e(N === E), H;
  }
  function u(h, a) {
    e(typeof h == "string");
    let E = h.length;
    if (E > 0 && h[E - 1] === "=" && (E -= 1), E > 0 && h[E - 1] === "=" && (E -= 1), (E & 3) === 1)
      return !1;
    for (let H = 0; H < E; H++) {
      const j = h.charCodeAt(H);
      if (j & 65408 || a[j] === -1)
        return !1;
    }
    switch (E & 3) {
      case 1:
        return !1;
      case 2:
        return (a[h.charCodeAt(E - 1)] & 15) === 0;
      case 3:
        return (a[h.charCodeAt(E - 1)] & 3) === 0;
    }
    return !0;
  }
  function o(h) {
    return f(h, c, !0);
  }
  function s(h) {
    const a = y(h);
    if (!b(h, a))
      throw new Error("Invalid base64 padding.");
    return n(h, w, a);
  }
  function i(h) {
    const a = y(h);
    return b(h, a) ? u(h, w) : !1;
  }
  function p(h) {
    return f(h, l, !1);
  }
  function g(h) {
    const a = y(h);
    if (!b(h, 0))
      throw new Error("Invalid base64 padding.");
    return n(h, m, a);
  }
  function S(h) {
    return b(h, 0) ? u(h, m) : !1;
  }
  function y(h) {
    e(typeof h == "string");
    let a = h.length;
    a > 0 && h[a - 1] === "=" && (a -= 1), a > 0 && h[a - 1] === "=" && (a -= 1);
    let E = (a >>> 2) * 3;
    const H = a & 3;
    return H && (E += H - 1), E;
  }
  function b(h, a) {
    switch (e(typeof h == "string"), a % 3) {
      case 0:
        return h.length === 0 ? !0 : h.length === 1 ? h[0] !== "=" : h[h.length - 2] !== "=" && h[h.length - 1] !== "=";
      case 1:
        return h.length >= 4 && h[h.length - 2] === "=" && h[h.length - 1] === "=";
      case 2:
        return h.length >= 4 && h[h.length - 2] !== "=" && h[h.length - 1] === "=";
      default:
        throw new Error("unreachable");
    }
  }
  return Qr.native = 0, Qr.encode = o, Qr.decode = s, Qr.test = i, Qr.encodeURL = p, Qr.decodeURL = g, Qr.testURL = S, Qr;
}
var f8;
function Zy() {
  if (f8) return Ct;
  f8 = 1;
  const e = Nt(), c = Xr(), l = yi(), { randomPrime: w } = Jy(), m = Wy(), f = Op(), n = x1(), {
    safeEqual: u,
    safeEqualByte: o,
    safeSelect: s,
    safeLTE: i
  } = n, p = 2048, g = 65537, S = 512, y = 16384, b = 3, h = 2 ** 33 - 1, a = 33, E = 0, H = -1, j = k.alloc(8, 0), G = k.alloc(0), N = {
    __proto__: null,
    BLAKE2B160: k.from("3027300f060b2b060104018d3a0c02010505000414", "hex"),
    BLAKE2B256: k.from("3033300f060b2b060104018d3a0c02010805000420", "hex"),
    BLAKE2B384: k.from("3043300f060b2b060104018d3a0c02010c05000430", "hex"),
    BLAKE2B512: k.from("3053300f060b2b060104018d3a0c02011005000440", "hex"),
    BLAKE2S128: k.from("3023300f060b2b060104018d3a0c02020405000410", "hex"),
    BLAKE2S160: k.from("3027300f060b2b060104018d3a0c02020505000414", "hex"),
    BLAKE2S224: k.from("302f300f060b2b060104018d3a0c0202070500041c", "hex"),
    BLAKE2S256: k.from("3033300f060b2b060104018d3a0c02020805000420", "hex"),
    GOST94: k.from("302e300a06062a850302021405000420", "hex"),
    HASH160: k.from([20]),
    HASH256: k.from([32]),
    KECCAK224: k.from([28]),
    KECCAK256: k.from([32]),
    KECCAK384: k.from([48]),
    KECCAK512: k.from([64]),
    MD2: k.from("3020300c06082a864886f70d020205000410", "hex"),
    MD4: k.from("3020300c06082a864886f70d020405000410", "hex"),
    MD5: k.from("3020300c06082a864886f70d020505000410", "hex"),
    MD5SHA1: k.from([36]),
    RIPEMD160: k.from("3021300906052b2403020105000414", "hex"),
    SHA1: k.from("3021300906052b0e03021a05000414", "hex"),
    SHA224: k.from("302d300d06096086480165030402040500041c", "hex"),
    SHA256: k.from("3031300d060960864801650304020105000420", "hex"),
    SHA384: k.from("3041300d060960864801650304020205000430", "hex"),
    SHA512: k.from("3051300d060960864801650304020305000440", "hex"),
    SHA3_224: k.from("302d300d06096086480165030402070500041c", "hex"),
    SHA3_256: k.from("3031300d060960864801650304020805000420", "hex"),
    SHA3_384: k.from("3041300d060960864801650304020905000430", "hex"),
    SHA3_512: k.from("3051300d060960864801650304020a05000440", "hex"),
    SHAKE128: k.from("3021300d060960864801650304020b05000410", "hex"),
    SHAKE256: k.from("3031300d060960864801650304020c05000420", "hex"),
    WHIRLPOOL: k.from("304e300a060628cf0603003705000440", "hex")
  };
  class T {
    constructor() {
      this.n = new c(0), this.e = new c(0);
    }
    bits() {
      return this.n.bitLength();
    }
    size() {
      return this.n.byteLength();
    }
    isSane() {
      return this.n.sign() > 0 && this.e.sign() > 0 && this.n.bitLength() <= y && this.e.bitLength() <= a;
    }
    verify() {
      return !(!this.isSane() || this.n.bitLength() < S || !this.n.isOdd() || this.e.cmpn(b) < 0 || !this.e.isOdd());
    }
    encrypt(M) {
      e(k.isBuffer(M));
      const { n: $, e: r } = this, x = c.decode(M);
      if (x.cmp($) >= 0)
        throw new Error("Invalid RSA message size.");
      return x.powm(r, $).encode("be", $.byteLength());
    }
    encode() {
      const M = f.sizeInt(this.n) + f.sizeInt(this.e), $ = k.alloc(f.sizeSeq(M));
      let r = 0;
      return r = f.writeSeq($, r, M), r = f.writeInt($, r, this.n), r = f.writeInt($, r, this.e), e(r === $.length), $;
    }
    decode(M) {
      let $ = 0;
      if ($ = f.readSeq(M, $), [this.n, $] = f.readInt(M, $), [this.e, $] = f.readInt(M, $), $ !== M.length)
        throw new Error("Trailing bytes.");
      return this;
    }
    static decode(M) {
      return new T().decode(M);
    }
  }
  class A extends T {
    constructor() {
      super(), this.d = new c(0), this.p = new c(0), this.q = new c(0), this.dp = new c(0), this.dq = new c(0), this.qi = new c(0);
    }
    isSane() {
      return this.n.sign() > 0 && this.e.sign() > 0 && this.d.sign() > 0 && this.p.sign() > 0 && this.q.sign() > 0 && this.dp.sign() > 0 && this.dq.sign() > 0 && this.qi.sign() > 0 && this.n.bitLength() <= y && this.e.bitLength() <= a && this.d.bitLength() <= y && this.p.bitLength() <= y && this.q.bitLength() <= y && this.dp.bitLength() <= y && this.dq.bitLength() <= y && this.qi.bitLength() <= y;
    }
    verify() {
      if (!this.isSane() || this.n.bitLength() < S || !this.n.isOdd() || this.e.cmpn(b) < 0 || !this.e.isOdd() || this.p.cmpn(3) < 0 || !this.p.isOdd() || this.q.cmpn(3) < 0 || !this.q.isOdd())
        return !1;
      const M = this.p.subn(1), $ = this.q.subn(1), r = M.mul($);
      if (this.d.cmpn(2) < 0 || this.d.cmp(r) >= 0 || this.dp.sign() === 0 || this.dp.cmp(M) >= 0 || this.dq.sign() === 0 || this.dq.cmp($) >= 0 || this.qi.cmpn(2) < 0 || this.qi.cmp(this.p) >= 0 || this.p.cmp(this.q) === 0 || this.p.mul(this.q).cmp(this.n) !== 0)
        return !1;
      const x = r.div(M.gcd($));
      return !(this.e.mul(this.d).imod(x).cmpn(1) !== 0 || this.d.mod(M).cmp(this.dp) !== 0 || this.d.mod($).cmp(this.dq) !== 0 || this.q.mul(this.qi).imod(this.p).cmpn(1) !== 0);
    }
    decrypt(M) {
      e(k.isBuffer(M));
      const { n: $, e: r, p: x, q: O, dp: K, dq: X, qi: P } = this, V = c.decode(M);
      if (V.cmp($) >= 0)
        throw new Error("Invalid RSA message size.");
      let re, ce;
      for (; ; ) {
        const ee = c.random(l, 1, $);
        try {
          ce = ee.invert($);
        } catch {
          continue;
        }
        re = ee.powm(r, $);
        break;
      }
      V.imul(re).imod($);
      const de = V.powm(K, x, !0), pe = V.powm(X, O, !0), Z = de.sub(pe).mul(P).imod(x).mul(O).iadd(pe).imod($);
      if (Z.powm(r, $).cmp(V) !== 0)
        throw new Error("Invalid RSA private key.");
      return Z.imul(ce).imod($), Z.encode("be", $.byteLength());
    }
    generate(M, $) {
      e(M >>> 0 === M), e(Number.isSafeInteger($) && $ >= 0), e(M >= 64), e($ >= 3 && ($ & 1) !== 0);
      const r = new c($);
      for (; ; ) {
        const x = w((M >>> 1) + (M & 1)), O = w(M >>> 1);
        if (x.cmp(O) === 0 || (x.cmp(O) < 0 && x.swap(O), x.sub(O).bitLength() <= (M >>> 1) - 99))
          continue;
        const K = x.mul(O);
        if (K.bitLength() !== M)
          continue;
        const X = x.subn(1), P = O.subn(1), V = X.mul(P);
        if (r.gcd(V).cmpn(1) !== 0)
          continue;
        const re = V.div(X.gcd(P)), ce = r.invert(re);
        if (ce.bitLength() <= M + 1 >>> 1)
          continue;
        const de = ce.mod(X), pe = ce.mod(P), se = O.invert(x);
        return this.n = K, this.e = r, this.d = ce, this.p = x, this.q = O, this.dp = de, this.dq = pe, this.qi = se, this;
      }
    }
    async _generateSubtle(M, $) {
      e(M >>> 0 === M), e(Number.isSafeInteger($) && $ >= 0), e(M >= 64), e($ >= 3 && ($ & 1) !== 0);
      const r = Ft.crypto || Ft.msCrypto;
      if (!r)
        throw new Error("Crypto API not available.");
      const { subtle: x } = r;
      if (!x || !x.generateKey || !x.exportKey)
        throw new Error("Subtle API not available.");
      const O = new c($), K = {
        name: "RSASSA-PKCS1-v1_5",
        modulusLength: M,
        publicExponent: O.toArrayLike(Uint8Array, "be", 8),
        hash: { name: "SHA-256" }
      }, X = await x.generateKey(K, !0, ["sign"]), P = await x.exportKey("jwk", X.privateKey), V = c.decode(m.decodeURL(P.p)), re = c.decode(m.decodeURL(P.q));
      return this.fromPQE(V, re, O);
    }
    async generateAsync(M, $) {
      try {
        return await this._generateSubtle(M, $);
      } catch {
        return this.generate(M, $);
      }
    }
    fromPQE(M, $, r) {
      if (e(M instanceof c), e($ instanceof c), e(r instanceof c), M.cmp($) < 0 && ([M, $] = [$, M]), M.cmp($) === 0)
        throw new Error("Invalid RSA private key.");
      if (M.cmpn(3) < 0 || M.bitLength() > y)
        throw new Error("Invalid RSA private key.");
      if ($.cmpn(3) < 0 || $.bitLength() > y)
        throw new Error("Invalid RSA private key.");
      if (r.cmpn(b) < 0 || r.bitLength() > a)
        throw new Error("Invalid RSA private key.");
      if (!M.isOdd() || !$.isOdd() || !r.isOdd())
        throw new Error("Invalid RSA private key.");
      const x = M.mul($);
      if (e(x.isOdd()), x.bitLength() < S || x.bitLength() > y)
        throw new Error("Invalid RSA private key.");
      const O = M.subn(1), K = $.subn(1), X = O.lcm(K), P = r.invert(X), V = P.mod(O), re = P.mod(K), ce = $.invert(M);
      return this.n = x, this.e = r, this.d = P, this.p = M, this.q = $, this.dp = V, this.dq = re, this.qi = ce, this;
    }
    fromPQD(M, $, r) {
      if (e(M instanceof c), e($ instanceof c), e(r instanceof c), M.cmpn(3) < 0 || M.bitLength() > y)
        throw new Error("Invalid RSA private key.");
      if ($.cmpn(3) < 0 || $.bitLength() > y)
        throw new Error("Invalid RSA private key.");
      if (!M.isOdd() || !$.isOdd())
        throw new Error("Invalid RSA private key.");
      const x = M.subn(1), O = $.subn(1), K = x.mul(O);
      if (r.cmpn(2) < 0 || r.cmp(K) >= 0)
        throw new Error("Invalid RSA private key.");
      const X = K.div(x.gcd(O)), P = r.invert(X);
      return this.fromPQE(M, $, P);
    }
    fromNED(M, $, r) {
      if (e(M instanceof c), e($ instanceof c), e(r instanceof c), M.sign() < 0)
        throw new Error("Invalid RSA private key.");
      if (M.bitLength() < S || M.bitLength() > y)
        throw new Error("Invalid RSA private key.");
      if ($.cmpn(b) < 0 || $.bitLength() > a)
        throw new Error("Invalid RSA private key.");
      if (r.cmpn(2) < 0 || r.bitLength() > y)
        throw new Error("Invalid RSA private key.");
      if (!M.isOdd() || !$.isOdd())
        throw new Error("Invalid RSA private key.");
      const x = $.mul(r).isubn(1), O = M.subn(1), K = x.zeroBits(), X = x.ushrn(K);
      for (let P = 0; P < 64; P++) {
        let re = c.random(l, 2, O).powm(X, M);
        if (!(re.cmpn(1) === 0 || re.cmp(O) === 0))
          for (let ce = 1; ce < K; ce++) {
            const de = re.sqr().imod(M);
            if (de.cmpn(1) === 0) {
              const pe = M.gcd(re.subn(1)), se = M.gcd(re.addn(1));
              return this.fromPQE(pe, se, $);
            }
            if (de.cmp(O) === 0)
              break;
            re = de;
          }
      }
      throw new Error("Invalid RSA private key.");
    }
    toPublic() {
      const M = new T();
      return M.n = this.n, M.e = this.e, M;
    }
    encode() {
      let M = 0;
      M += f.sizeVersion(0), M += f.sizeInt(this.n), M += f.sizeInt(this.e), M += f.sizeInt(this.d), M += f.sizeInt(this.p), M += f.sizeInt(this.q), M += f.sizeInt(this.dp), M += f.sizeInt(this.dq), M += f.sizeInt(this.qi);
      const $ = k.alloc(f.sizeSeq(M));
      let r = 0;
      return r = f.writeSeq($, r, M), r = f.writeVersion($, r, 0), r = f.writeInt($, r, this.n), r = f.writeInt($, r, this.e), r = f.writeInt($, r, this.d), r = f.writeInt($, r, this.p), r = f.writeInt($, r, this.q), r = f.writeInt($, r, this.dp), r = f.writeInt($, r, this.dq), r = f.writeInt($, r, this.qi), e(r === $.length), $;
    }
    decode(M) {
      let $ = 0;
      if ($ = f.readSeq(M, $), $ = f.readVersion(M, $, 0), [this.n, $] = f.readInt(M, $), [this.e, $] = f.readInt(M, $), [this.d, $] = f.readInt(M, $), [this.p, $] = f.readInt(M, $), [this.q, $] = f.readInt(M, $), [this.dp, $] = f.readInt(M, $), [this.dq, $] = f.readInt(M, $), [this.qi, $] = f.readInt(M, $), $ !== M.length)
        throw new Error("Trailing bytes.");
      return this;
    }
    static generate(M, $) {
      return new A().generate(M, $);
    }
    static async generateAsync(M, $) {
      return new A().generateAsync(M, $);
    }
    static fromPQE(M, $, r) {
      return new A().fromPQE(M, $, r);
    }
    static fromPQD(M, $, r) {
      return new A().fromPQD(M, $, r);
    }
    static fromNED(M, $, r) {
      return new A().fromNED(M, $, r);
    }
    static decode(M) {
      return new A().decode(M);
    }
  }
  function q(C, M) {
    if (C == null && (C = p), M == null && (M = g), e(C >>> 0 === C), e(Number.isSafeInteger(M) && M >= 0), C < S || C > y)
      throw new RangeError(`"bits" ranges from ${S} to ${y}.`);
    if (M < b || M > h)
      throw new RangeError(`"exponent" ranges from ${b} to ${h}.`);
    if (M === 1 || (M & 1) === 0)
      throw new RangeError('"exponent" must be odd.');
    return A.generate(C, M).encode();
  }
  async function _(C, M) {
    if (C == null && (C = p), M == null && (M = g), e(C >>> 0 === C), e(Number.isSafeInteger(M) && M >= 0), C < S || C > y)
      throw new RangeError(`"bits" ranges from ${S} to ${y}.`);
    if (M < b || M > h)
      throw new RangeError(`"exponent" ranges from ${b} to ${h}.`);
    if (M === 1 || (M & 1) === 0)
      throw new RangeError('"exponent" must be odd.');
    return (await A.generateAsync(C, M)).encode();
  }
  function F(C) {
    const M = A.decode(C);
    if (!M.verify())
      throw new Error("Invalid RSA private key.");
    return M.bits();
  }
  function R(C) {
    e(k.isBuffer(C));
    let M;
    try {
      M = A.decode(C);
    } catch {
      return !1;
    }
    return M.verify();
  }
  function L(C) {
    e(C && typeof C == "object");
    let M = new A();
    return C.n != null && (M.n = c.decode(C.n)), C.e != null && (M.e = c.decode(C.e)), C.d != null && (M.d = c.decode(C.d)), C.p != null && (M.p = c.decode(C.p)), C.q != null && (M.q = c.decode(C.q)), C.dp != null && (M.dp = c.decode(C.dp)), C.dq != null && (M.dq = c.decode(C.dq)), C.qi != null && (M.qi = c.decode(C.qi)), M.verify() || (!M.p.isZero() && !M.q.isZero() ? M.e.isZero() ? M = A.fromPQD(M.p, M.q, M.d) : M = A.fromPQE(M.p, M.q, M.e) : M = A.fromNED(M.n, M.e, M.d)), M.encode();
  }
  function fe(C) {
    const M = A.decode(C);
    if (!M.verify())
      throw new Error("Invalid RSA private key.");
    return {
      n: M.n.encode(),
      e: M.e.encode(),
      d: M.d.encode(),
      p: M.p.encode(),
      q: M.q.encode(),
      dp: M.dp.encode(),
      dq: M.dq.encode(),
      qi: M.qi.encode()
    };
  }
  function ue(C) {
    const M = A.decode(C);
    if (!M.verify())
      throw new Error("Invalid RSA private key.");
    return M.toPublic().encode();
  }
  function ae(C) {
    const M = T.decode(C);
    if (!M.verify())
      throw new Error("Invalid RSA public key.");
    return M.bits();
  }
  function D(C) {
    e(k.isBuffer(C));
    let M;
    try {
      M = T.decode(C);
    } catch {
      return !1;
    }
    return M.verify();
  }
  function Q(C) {
    e(C && typeof C == "object");
    const M = new T();
    if (C.n != null && (M.n = c.decode(C.n)), C.e != null && (M.e = c.decode(C.e)), !M.verify())
      throw new Error("Invalid RSA public key.");
    return M.encode();
  }
  function W(C) {
    const M = T.decode(C);
    if (!M.verify())
      throw new Error("Invalid RSA public key.");
    return {
      n: M.n.encode(),
      e: M.e.encode()
    };
  }
  function oe(C, M, $) {
    C && typeof C.id == "string" && (C = C.id), e(C == null || typeof C == "string"), e(k.isBuffer(M));
    const [r, x] = d(C, M);
    if (!r)
      throw new Error("Unknown RSA hash function.");
    if (M.length !== x)
      throw new Error("Invalid RSA message size.");
    const O = A.decode($);
    if (!O.verify())
      throw new Error("Invalid RSA private key.");
    const K = r.length + x, X = O.size();
    if (X < K + 11)
      throw new Error("Invalid RSA message size.");
    const P = k.alloc(X);
    P[0] = 0, P[1] = 1;
    for (let V = 2; V < X - K - 1; V++)
      P[V] = 255;
    return P[X - K - 1] = 0, r.copy(P, X - K), M.copy(P, X - x), O.decrypt(P);
  }
  function v(C, M, $, r) {
    C && typeof C.id == "string" && (C = C.id), e(C == null || typeof C == "string"), e(k.isBuffer(M)), e(k.isBuffer($)), e(k.isBuffer(r));
    try {
      return Y(C, M, $, r);
    } catch {
      return !1;
    }
  }
  function Y(C, M, $, r) {
    const [x, O] = d(C, M);
    if (!x || M.length !== O)
      return !1;
    const K = T.decode(r);
    if (!K.verify())
      return !1;
    const X = K.size();
    if ($.length !== X)
      return !1;
    const P = x.length + O;
    if (X < P + 11)
      return !1;
    const V = K.encrypt($);
    let re = 1;
    re &= o(V[0], 0), re &= o(V[1], 1);
    for (let ce = 2; ce < X - P - 1; ce++)
      re &= o(V[ce], 255);
    return re &= o(V[X - P - 1], 0), re &= u(V.slice(X - P, X - O), x), re &= u(V.slice(X - O, X), M), re === 1;
  }
  function he(C, M) {
    e(k.isBuffer(C));
    const $ = T.decode(M);
    if (!$.verify())
      throw new Error("Invalid RSA public key.");
    const r = $.size();
    if (C.length > r - 11)
      throw new Error("Invalid RSA message size.");
    const x = k.alloc(r), O = C.length, K = r - O - 3;
    x[0] = 0, x[1] = 2, l.randomFill(x, 2, K);
    for (let X = 2; X < 2 + K; X++)
      for (; x[X] === 0; )
        l.randomFill(x, X, 1);
    return x[r - O - 1] = 0, C.copy(x, r - O), $.encrypt(x);
  }
  function le(C, M) {
    e(k.isBuffer(C));
    const $ = A.decode(M);
    if (!$.verify())
      throw new Error("Invalid RSA private key.");
    const r = $.size();
    if (r < 11)
      throw new Error("Invalid RSA private key.");
    if (C.length !== r)
      throw new Error("Invalid RSA message size.");
    const x = $.decrypt(C), O = o(x[0], 0), K = o(x[1], 2);
    let X = 0, P = 1;
    for (let de = 2; de < x.length; de++) {
      const pe = o(x[de], 0);
      X = s(X, de, P & pe), P = s(P, 0, pe);
    }
    const V = i(10, X), re = O & K & (P ^ 1) & V, ce = s(0, X + 1, re);
    if (re === 0)
      throw new Error("Invalid RSA ciphertext.");
    return x.slice(ce);
  }
  function ge(C, M, $, r) {
    if (r == null && (r = H), e(C && typeof C.id == "string"), e(k.isBuffer(M)), e((r | 0) === r), M.length !== C.size)
      throw new Error("Invalid RSA message size.");
    const x = A.decode($);
    if (!x.verify())
      throw new Error("Invalid RSA private key.");
    const O = x.bits(), K = O + 7 >>> 3, X = O + 6 >>> 3;
    if (r === E ? r = X - 2 - C.size : r === H && (r = C.size), r < 0 || r > K)
      throw new Error("Invalid PSS salt length.");
    const P = l.randomBytes(r), V = U(C, M, O - 1, P);
    return x.decrypt(V);
  }
  function Ee(C, M, $, r, x) {
    x == null && (x = H), e(C && typeof C.id == "string"), e(k.isBuffer(M)), e(k.isBuffer($)), e(k.isBuffer(r)), e((x | 0) === x);
    try {
      return we(C, M, $, r, x);
    } catch {
      return !1;
    }
  }
  function we(C, M, $, r, x) {
    if (M.length !== C.size)
      return !1;
    const O = T.decode(r);
    if (!O.verify())
      return !1;
    const K = O.bits(), X = K + 7 >>> 3;
    if ($.length !== X || (x === E ? x = 0 : x === H && (x = C.size), x < 0 || x > X))
      return !1;
    let P = O.encrypt($);
    if ((K - 1 & 7) === 0) {
      if (P[0] !== 0)
        return !1;
      P = P.slice(1);
    }
    return J(C, M, P, K - 1, x);
  }
  function z(C, M, $, r) {
    r == null && (r = G), e(C && typeof C.id == "string"), e(k.isBuffer(M)), e(k.isBuffer(r));
    const x = T.decode($);
    if (!x.verify())
      throw new Error("Invalid RSA public key.");
    const O = x.size(), K = M.length, X = C.size;
    if (K > O - 2 * X - 2)
      throw new Error("Invalid RSA message size.");
    const P = k.alloc(O), V = C.digest(r), re = P.slice(1, 1 + X), ce = P.slice(1 + X), de = ce.length;
    return P[0] = 0, l.randomFill(re, 0, re.length), V.copy(ce, 0), ce.fill(0, X, de - K - 1), ce[de - K - 1] = 1, M.copy(ce, de - K), B(C, ce, re), B(C, re, ce), x.encrypt(P);
  }
  function I(C, M, $, r) {
    r == null && (r = G), e(C && typeof C.id == "string"), e(k.isBuffer(M)), e(k.isBuffer(r));
    const x = A.decode($);
    if (!x.verify())
      throw new Error("Invalid RSA private key.");
    const O = x.size(), K = M.length, X = C.size;
    if (O < X * 2 + 2)
      throw new Error("Invalid RSA private key size.");
    if (K !== O)
      throw new Error("Invalid RSA message size.");
    const P = x.decrypt(M), V = C.digest(r), re = o(P[0], 0), ce = P.slice(1, X + 1), de = P.slice(X + 1);
    B(C, ce, de), B(C, de, ce);
    const pe = de.slice(0, X), se = u(pe, V), Z = de.slice(X);
    let ee = 1, me = 0, Ae = 0;
    for (let ye = 0; ye < Z.length; ye++) {
      const _e = o(Z[ye], 0), ke = o(Z[ye], 1);
      me = s(me, ye, ee & ke), ee = s(ee, 0, ke), Ae = s(Ae, 1, ee & (_e ^ 1));
    }
    if ((re & se & (Ae ^ 1) & (ee ^ 1)) === 0)
      throw new Error("Invalid RSA ciphertext.");
    return Z.slice(me + 1);
  }
  function ne(C, M, $) {
    e(k.isBuffer(C)), e(M >>> 0 === M);
    const r = T.decode($);
    if (!r.verify())
      throw new Error("Invalid RSA public key.");
    if (C.length !== r.size())
      throw new Error("Invalid RSA ciphertext.");
    if (M < r.bits())
      throw new Error("Cannot make ciphertext smaller.");
    const x = M + 7 >>> 3, O = c.decode(C);
    if (O.cmp(r.n) >= 0)
      throw new Error("Invalid RSA ciphertext.");
    const K = c.shift(1, M), X = K.sub(O).iadd(r.n).isubn(1).div(r.n);
    e(X.sign() > 0);
    let P = K;
    for (; P.cmp(K) >= 0; ) {
      const V = c.random(l, 0, X);
      P = O.add(V.mul(r.n));
    }
    return e(P.mod(r.n).cmp(O) === 0), e(P.bitLength() <= M), P.encode("be", x);
  }
  function t(C, M, $) {
    e(k.isBuffer(C)), e(M >>> 0 === M);
    const r = T.decode($);
    if (!r.verify())
      throw new Error("Invalid RSA public key.");
    const x = r.size();
    if (C.length < x)
      throw new Error("Invalid RSA ciphertext.");
    const O = c.decode(C);
    if (M !== 0 && O.bitLength() > M)
      throw new Error("Invalid RSA ciphertext.");
    return O.imod(r.n).encode("be", x);
  }
  function d(C, M) {
    if (e(C == null || typeof C == "string"), e(k.isBuffer(M)), C == null)
      return [G, M.length];
    const $ = N[C];
    return $ == null ? [null, 0] : $.length === 1 ? [G, $[0]] : [
      $,
      $[$.length - 1]
    ];
  }
  function B(C, M, $) {
    e(C && typeof C.id == "string"), e(k.isBuffer(M)), e(k.isBuffer($));
    const r = k.alloc(4, 0);
    let x = 0;
    for (; x < M.length; ) {
      const O = C.multi($, r);
      let K = 0;
      for (; x < M.length && K < O.length; )
        M[x++] ^= O[K++];
      for (K = 3; K >= 0 && (r[K] += 1, r[K] === 0); K--)
        ;
    }
  }
  function U(C, M, $, r) {
    e(C && typeof C.id == "string"), e(k.isBuffer(M)), e($ >>> 0 === $), e(k.isBuffer(r));
    const x = C.size, O = r.length, K = $ + 7 >>> 3;
    if (M.length !== x)
      throw new Error("Invalid RSA message size.");
    if (K < x + O + 2)
      throw new Error("Message too long.");
    const X = k.alloc(K), P = X.slice(0, K - x - 1), V = X.slice(K - x - 1, K - 1), re = C.multi(j, M, r), ce = 255 >>> 8 * K - $;
    return P.fill(0, 0, K - O - x - 2), P[K - O - x - 2] = 1, r.copy(P, K - O - x - 1), re.copy(V, 0), X[K - 1] = 188, B(C, P, V), P[0] &= ce, X;
  }
  function J(C, M, $, r, x) {
    e(C && typeof C.id == "string"), e(k.isBuffer(M)), e(k.isBuffer($)), e(r >>> 0 === r), e(x >>> 0 === x);
    const O = C.size, K = r + 7 >>> 3;
    if (M.length !== O || K < O + x + 2 || $[K - 1] !== 188)
      return !1;
    const X = $.slice(0, K - O - 1), P = $.slice(K - O - 1, K - 1), V = 255 >>> 8 * K - r;
    if ($[0] & ~V)
      return !1;
    if (B(C, X, P), X[0] &= V, x === 0) {
      x = -1;
      for (let de = 0; de < X.length; de++)
        if (X[de] !== 0) {
          if (X[de] === 1) {
            x = X.length - (de + 1);
            break;
          }
          return !1;
        }
      if (x === -1)
        return !1;
    } else {
      const de = X.length - x - 1;
      for (let pe = 0; pe < de; pe++)
        if (X[pe] !== 0)
          return !1;
      if (X[de] !== 1)
        return !1;
    }
    const re = X.slice(X.length - x);
    return C.multi(j, M, re).equals(P);
  }
  return Ct.native = 0, Ct.SALT_LENGTH_AUTO = E, Ct.SALT_LENGTH_HASH = H, Ct.privateKeyGenerate = q, Ct.privateKeyGenerateAsync = _, Ct.privateKeyBits = F, Ct.privateKeyVerify = R, Ct.privateKeyImport = L, Ct.privateKeyExport = fe, Ct.publicKeyCreate = ue, Ct.publicKeyBits = ae, Ct.publicKeyVerify = D, Ct.publicKeyImport = Q, Ct.publicKeyExport = W, Ct.sign = oe, Ct.verify = v, Ct.encrypt = he, Ct.decrypt = le, Ct.signPSS = ge, Ct.verifyPSS = Ee, Ct.encryptOAEP = z, Ct.decryptOAEP = I, Ct.veil = ne, Ct.unveil = t, Ct;
}
var Wh, c8;
function Qy() {
  if (c8) return Wh;
  c8 = 1;
  const e = Nt(), c = Ar(), l = fi();
  class w extends c {
    constructor() {
      super();
    }
    init() {
      return this.state[0] = 3238371032, this.state[1] = 914150663, this.state[2] = 812702999, this.state[3] = 4144912697, this.state[4] = 4290775857, this.state[5] = 1750603025, this.state[6] = 1694076839, this.state[7] = 3204075428, this.size = 0, this;
    }
    final() {
      return super.final().slice(0, 28);
    }
    static hash() {
      return new w();
    }
    static hmac() {
      return new l(w, 64);
    }
    static digest(f) {
      return w.ctx.init().update(f).final();
    }
    static root(f, n) {
      return e(k.isBuffer(f) && f.length === 28), e(k.isBuffer(n) && n.length === 28), w.ctx.init().update(f).update(n).final();
    }
    static multi(f, n, u) {
      const { ctx: o } = w;
      return o.init(), o.update(f), o.update(n), u && o.update(u), o.final();
    }
    static mac(f, n) {
      return w.hmac().init(n).update(f).final();
    }
  }
  return w.native = 0, w.id = "SHA224", w.size = 28, w.bits = 224, w.blockSize = 64, w.zero = k.alloc(28, 0), w.ctx = new w(), Wh = w, Wh;
}
/*!
 * bcrypto.js - crypto for bcrypto
 * Copyright (c) 2014-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var u8;
function ev() {
  return u8 || (u8 = 1, function(e) {
    e.aes = w1(), e.BN = Xr(), e.ChaCha20 = _p(), e.cleanse = Sn(), e.Hash160 = Xi(), e.Hash256 = mr(), e.HmacDRBG = Rp(), e.Keccak = $p(), e.merkle = Tp(), e.murmur3 = m1(), e.p224 = jy(), e.p256 = Yy(), e.p384 = Xy(), e.p521 = Gy(), e.pbkdf2 = Ro(), e.random = yi(), e.RIPEMD160 = s1(), e.rsa = Zy(), e.safe = x1(), e.scrypt = Vp(), e.secp256k1 = zr(), e.SHA1 = kp(), e.SHA224 = Qy(), e.SHA256 = Ar(), e.SHA384 = jp(), e.SHA512 = En(), e.SHAKE = Yp(), e.SHAKE256 = Xp(), e.version = "5.5.1", e.native = e.SHA256.native;
  }(Lh)), Lh;
}
var Zh = {};
const tv = "@hansekontor/checkout-components", rv = "1.0.0", h8 = {
  name: tv,
  version: rv
};
/*!
 * pkg.js - package constants
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * Copyright (c) 2018, bcash developers.
 * https://github.com/bcoin-org/bcash
 */
var l8;
function iv() {
  return l8 || (l8 = 1, function(e) {
    const c = e;
    c.name = h8.name, c.core = "bcash", c.organization = "badger-cash", c.currency = "bitcoin cash", c.unit = "bch", c.base = "satoshi", c.cfg = `${c.core}.conf`, c.url = `https://github.com/${c.organization}/${c.name}`, c.version = h8.version;
  }(Zh)), Zh;
}
/*!
 * bcoin.js - a javascript bitcoin library.
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License).
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var d8;
function Gp() {
  return d8 || (d8 = 1, function(e) {
    const c = e;
    c.set = function(w) {
      return c.Network.set(w), c;
    }, c.btc = ny(), c.Amount = wi(), c.URI = Pp(), c.coins = sy(), c.Coins = f1(), c.CoinEntry = Ao(), c.CoinView = Oo(), c.hd = gy(), c.HDPrivateKey = u1(), c.HDPublicKey = c1(), c.Mnemonic = Po(), c.primitives = yy(), c.Address = Gr(), c.Block = d1(), c.Coin = cs(), c.Headers = hs(), c.Input = Bo(), c.InvItem = ko(), c.KeyRing = b1(), c.MerkleBlock = l1(), c.MTX = p1(), c.Outpoint = Ei(), c.Output = Si(), c.TX = In(), c.protocol = Sy(), c.consensus = Lt(), c.Network = Or(), c.networks = o1(), c.policy = vi(), c.script = Ey(), c.Opcode = a1(), c.Script = Cr(), c.ScriptNum = Gi(), c.SigCache = zp(), c.Stack = Eo(), c.utils = Kt(), c.util = Qt(), c.WalletDB = $y(), c.bcrypto = ev(), c.bfilter = Dp(), c.pkg = iv();
  }(Uc)), Uc;
}
var Qh = {}, b8;
function nv() {
  return b8 || (b8 = 1, function(e) {
    const c = At(), l = e;
    l.readTag = function(m) {
      let f = m.readU8();
      const n = (f & 32) === 0;
      if ((f & 31) === 31) {
        let u = f;
        for (f = 0; (u & 128) === 128; )
          u = m.readU8(), f <<= 7, f |= u & 127;
      } else
        f &= 31;
      return {
        type: f,
        primitive: n,
        size: l.readSize(m, n)
      };
    }, l.readSize = function(m, f) {
      let n = m.readU8();
      if (!f && n === 128)
        throw new Error("Indefinite size.");
      if ((n & 128) === 0)
        return n;
      const u = n & 127;
      if (u > 3)
        throw new Error("Length octet is too long.");
      n = 0;
      for (let o = 0; o < u; o++)
        n <<= 8, n |= m.readU8();
      return n;
    }, l.readSeq = function(m) {
      const f = l.implicit(m, 16);
      return m.readBytes(f.size);
    }, l.implicit = function(m, f) {
      const n = l.readTag(m);
      if (n.type !== f)
        throw new Error(`Unexpected tag: ${n.type}.`);
      return n;
    }, l.explicit = function(m, f) {
      const n = m.offset;
      return l.readTag(m).type !== f ? (m.offset = n, !1) : !0;
    }, l.seq = function(m) {
      return c.read(l.readSeq(m), !0);
    }, l.readInt = function(m, f) {
      const n = l.implicit(m, 2), u = m.readBytes(n.size);
      return f ? u.readUIntBE(0, u.length) : u;
    }, l.readExplicitInt = function(m, f, n) {
      return l.explicit(m, f) ? l.readInt(m, n) : -1;
    }, l.readBitstr = function(m) {
      const f = l.implicit(m, 3), n = m.readBytes(f.size);
      return l.alignBitstr(n);
    }, l.readString = function(m) {
      const f = l.readTag(m);
      switch (f.type) {
        case 3: {
          const n = m.readBytes(f.size);
          return l.alignBitstr(n).toString("utf8");
        }
        // Note:
        // Fuck all these.
        case 4:
        // octstr
        case 18:
        // numstr
        case 19:
        // prinstr
        case 20:
        // t61str
        case 21:
        // videostr
        case 22:
        // ia5str
        case 25:
        // graphstr
        case 12:
        // utf8str
        case 26:
        // iso646str
        case 27:
        // genstr
        case 28:
        // unistr
        case 29:
        // charstr
        case 30:
          return m.readString(f.size, "utf8");
        default:
          throw new Error(`Unexpected tag: ${f.type}.`);
      }
    }, l.alignBitstr = function(m) {
      const f = m[0], n = (m.length - 1) * 8 - f, u = m.slice(1), o = 8 - n % 8;
      if (o === 8 || u.length === 0)
        return u;
      const s = k.allocUnsafe(u.length);
      s[0] = u[0] >>> o;
      for (let i = 1; i < u.length; i++)
        s[i] = u[i - 1] << 8 - o, s[i] |= u[i] >>> o;
      return s;
    }, l.readCert = function(m) {
      const f = m;
      return f.start(), m = l.seq(f), {
        tbs: l.readTBS(m),
        sigAlg: l.readAlgIdent(m),
        sig: l.readBitstr(m),
        raw: f.endData(!0)
      };
    }, l.readTBS = function(m) {
      const f = m;
      return f.start(), m = l.seq(f), {
        version: l.readExplicitInt(m, 0, !0),
        serial: l.readInt(m),
        sig: l.readAlgIdent(m),
        issuer: l.readName(m),
        validity: l.readValidity(m),
        subject: l.readName(m),
        pubkey: l.readPubkey(m),
        raw: f.endData(!0)
      };
    }, l.readPubkey = function(m) {
      return m = l.seq(m), {
        alg: l.readAlgIdent(m),
        pubkey: l.readBitstr(m)
      };
    }, l.readName = function(m) {
      const f = [];
      for (m = l.seq(m); m.left(); )
        l.implicit(m, 17), l.implicit(m, 16), f.push({
          type: l.readOID(m),
          value: l.readString(m)
        });
      return f;
    }, l.readValidity = function(m) {
      return m = l.seq(m), {
        notBefore: l.readTime(m),
        notAfter: l.readTime(m)
      };
    }, l.readTime = function(m) {
      const f = l.readTag(m), n = m.readString(f.size, "ascii");
      let u, o, s, i, p, g;
      switch (f.type) {
        case 23:
          u = n.slice(0, 2) | 0, o = n.slice(2, 4) | 0, s = n.slice(4, 6) | 0, i = n.slice(6, 8) | 0, p = n.slice(8, 10) | 0, g = n.slice(10, 12) | 0, u < 70 ? u = 2e3 + u : u = 1900 + u;
          break;
        case 24:
          u = n.slice(0, 4) | 0, o = n.slice(4, 6) | 0, s = n.slice(6, 8) | 0, i = n.slice(8, 10) | 0, p = n.slice(10, 12) | 0, g = n.slice(12, 14) | 0;
          break;
        default:
          throw new Error(`Unexpected tag: ${f.type}.`);
      }
      return Date.UTC(u, o - 1, s, i, p, g, 0) / 1e3;
    }, l.readOID = function(m) {
      const f = l.implicit(m, 6), n = m.readBytes(f.size);
      return l.formatOID(n);
    }, l.formatOID = function(m) {
      const f = c.read(m), n = [];
      let u = 0, o = 0;
      for (; f.left(); )
        o = f.readU8(), u <<= 7, u |= o & 127, (o & 128) === 0 && (n.push(u), u = 0);
      o & 128 && n.push(u);
      const s = n[0] / 40 | 0, i = n[0] % 40;
      return [s, i].concat(n.slice(1)).join(".");
    }, l.readAlgIdent = function(m) {
      let f = null;
      m = l.seq(m);
      const n = l.readOID(m);
      if (m.left() > 0) {
        const u = l.readTag(m);
        f = m.readBytes(u.size), f.length === 0 && (f = null);
      }
      return {
        alg: n,
        params: f
      };
    }, l.readRSAPublic = function(m) {
      return m = l.seq(m), {
        modulus: l.readInt(m),
        publicExponent: l.readInt(m)
      };
    }, l.readRSAPrivate = function(m) {
      return m = l.seq(m), {
        version: l.readInt(m, !0),
        modulus: l.readInt(m),
        publicExponent: l.readInt(m),
        privateExponent: l.readInt(m),
        prime1: l.readInt(m),
        prime2: l.readInt(m),
        exponent1: l.readInt(m),
        exponent2: l.readInt(m),
        coefficient: l.readInt(m)
      };
    }, l.parseRSAPublic = function(m) {
      return l.readRSAPublic(c.read(m, !0));
    }, l.parseRSAPrivate = function(m) {
      return l.readRSAPrivate(c.read(m, !0));
    }, l.parseCert = function(m) {
      return l.readCert(c.read(m, !0));
    }, l.parseTBS = function(m) {
      return l.readTBS(c.read(m, !0));
    };
  }(Qh)), Qh;
}
var qs = {};
/*!
 * pk.js - public key algorithms for bcoin
 * Copyright (c) 2016-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var p8;
function sv() {
  if (p8) return qs;
  p8 = 1;
  const e = Xe(), c = Gp().bcrypto, {
    SHA224: l,
    SHA256: w,
    SHA384: m,
    SHA512: f,
    rsa: n,
    p224: u,
    p256: o,
    p384: s,
    p521: i
  } = c;
  qs.verify = function(y, b, h, a) {
    const E = p(y);
    if (!E)
      return !1;
    switch (a.alg) {
      case "rsa":
        return n.verify(E, E.digest(b), h, a.data);
      case "ecdsa": {
        const H = g(a.curve);
        return H ? H.verifyDER(E.digest(b), h, a.data) : !1;
      }
      default:
        throw new Error(`Unsupported algorithm: ${a.alg}.`);
    }
  }, qs.sign = function(y, b, h) {
    const a = p(y);
    if (!a)
      throw new Error(`Unsupported hash algorithm: ${y}.`);
    switch (h.alg) {
      case "rsa":
        return n.sign(a, a.digest(b), h.data);
      case "ecdsa": {
        const E = g(h.curve);
        if (!E)
          throw new Error(`Unsupported curve: ${h.curve}.`);
        return E.signDER(a.digest(b), h.data);
      }
      default:
        throw new Error(`Unsupported algorithm: ${h.alg}.`);
    }
  };
  function p(S) {
    switch (e(typeof S == "string"), S) {
      case "sha224":
        return l;
      case "sha256":
        return w;
      case "sha384":
        return m;
      case "sha512":
        return f;
      default:
        return null;
    }
  }
  function g(S) {
    switch (e(typeof S == "string"), S) {
      case "p224":
        return u;
      case "p256":
        return o;
      case "p384":
        return s;
      case "p521":
        return i;
      default:
        return null;
    }
  }
  return qs;
}
var m8;
function Jp() {
  return m8 || (m8 = 1, function(e) {
    const c = Xe(), l = Gp().bcrypto, { SHA256: w } = l, m = nv(), f = sv(), n = xp(), u = e;
    u.trusted = /* @__PURE__ */ new Set(), u.allowUntrusted = !1, u.oid = {
      "1.2.840.10040.4.1": { key: "dsa", hash: null },
      "1.2.840.10040.4.2": { key: "dsa", hash: null },
      "1.2.840.10040.4.3": { key: "dsa", hash: "sha1" },
      "1.2.840.113549.1.1.1": { key: "rsa", hash: null },
      "1.2.840.113549.1.1.2": { key: "rsa", hash: "md2" },
      "1.2.840.113549.1.1.3": { key: "rsa", hash: "md4" },
      "1.2.840.113549.1.1.4": { key: "rsa", hash: "md5" },
      "1.2.840.113549.1.1.5": { key: "rsa", hash: "sha1" },
      "1.2.840.113549.1.1.11": { key: "rsa", hash: "sha256" },
      "1.2.840.113549.1.1.12": { key: "rsa", hash: "sha384" },
      "1.2.840.113549.1.1.13": { key: "rsa", hash: "sha512" },
      "1.2.840.113549.1.1.14": { key: "rsa", hash: "sha224" },
      "2.16.840.1.101.3.4.2.8": { key: "rsa", hash: "sha3-256" },
      "2.16.840.1.101.3.4.2.9": { key: "rsa", hash: "sha3-384" },
      "2.16.840.1.101.3.4.2.10": { key: "rsa", hash: "sha3-512" },
      "1.2.840.10045.2.1": { key: "ecdsa", hash: null },
      "1.2.840.10045.4.1": { key: "ecdsa", hash: "sha1" },
      "1.2.840.10045.4.3.1": { key: "ecdsa", hash: "sha224" },
      "1.2.840.10045.4.3.2": { key: "ecdsa", hash: "sha256" },
      "1.2.840.10045.4.3.3": { key: "ecdsa", hash: "sha384" },
      "1.2.840.10045.4.3.4": { key: "ecdsa", hash: "sha512" }
    }, u.curves = {
      "1.3.132.0.33": "p224",
      "1.2.840.10045.3.1.7": "p256",
      "1.3.132.0.34": "p384",
      "1.3.132.0.35": "p521"
    }, u.getSubjectOID = function(s, i) {
      const p = s.tbs.subject;
      for (const g of p)
        if (g.type === i)
          return g.value;
      return null;
    }, u.getCAName = function(s) {
      return u.getSubjectOID(s, "2.5.4.3") || u.getSubjectOID(s, "2.5.4.11") || u.getSubjectOID(s, "2.5.4.10") || "Unknown";
    }, u.isTrusted = function(s) {
      const p = w.digest(s.raw).toString("hex");
      return u.trusted.has(p);
    }, u.setTrust = function(s) {
      c(Array.isArray(s), "Certs must be an array.");
      for (const i of s) {
        c(k.isBuffer(i), "Certificates must be DER.");
        const p = u.parse(i), S = w.digest(p.raw).toString("hex");
        u.trusted.add(S);
      }
    }, u.setFingerprints = function(s) {
      c(Array.isArray(s), "Certs must be an array.");
      for (const i of s) {
        c(k.isBuffer(i), "Fingerprint must be a buffer."), c(i.length === 32, "Fingerprint must be a sha256 hash.");
        const p = i.toString("hex");
        u.trusted.add(p);
      }
    }, u.getKeyAlgorithm = function(s) {
      const i = s.tbs.pubkey.alg.alg, p = u.oid[i];
      if (!p)
        throw new Error(`Unknown key algorithm: ${i}.`);
      return p;
    }, u.getSigAlgorithm = function(s) {
      const i = s.sigAlg.alg, p = u.oid[i];
      if (!p || !p.hash)
        throw new Error(`Unknown signature algorithm: ${i}.`);
      return p;
    }, u.getCurve = function(s) {
      let i;
      try {
        i = m.parseOID(s);
      } catch {
        throw new Error("Could not parse curve OID.");
      }
      const p = u.curves[i];
      if (!p)
        throw new Error(`Unknown ECDSA curve: ${i}.`);
      return p;
    }, u.parse = function(s) {
      try {
        return m.parseCert(s);
      } catch {
        throw new Error("Could not parse DER certificate.");
      }
    }, u.getPublicKey = function(s) {
      const i = u.getKeyAlgorithm(s), p = s.tbs.pubkey.pubkey, g = s.tbs.pubkey.alg.params;
      let S = null;
      if (i.key === "ecdsa") {
        if (!g)
          throw new Error("No curve selected for ECDSA (cert).");
        S = u.getCurve(g);
      }
      return {
        alg: i.key,
        data: p,
        params: g,
        curve: S
      };
    }, u.verifyTime = function(s) {
      const i = s.tbs.validity, p = Math.floor(Date.now() / 1e3);
      return p > i.notBefore && p < i.notAfter;
    }, u.getSigningKey = function(s, i) {
      c(i.length !== 0, "No chain available.");
      const p = u.parse(i[0]), g = u.getPublicKey(p);
      return {
        alg: g.alg,
        data: s,
        params: g.params,
        curve: g.curve
      };
    }, u.signSubject = function(s, i, p, g) {
      const S = u.getSigningKey(p, g);
      return f.sign(s, i, S);
    }, u.getVerifyKey = function(s) {
      if (s.length === 0)
        throw new Error("No verify key available (cert chain).");
      const i = u.parse(s[0]);
      return u.getPublicKey(i);
    }, u.verifySubject = function(s, i, p, g) {
      const S = u.getVerifyKey(g);
      return f.verify(s, i, p, S);
    }, u.parseChain = function(s) {
      const i = [];
      for (const p of s) {
        const g = u.parse(p);
        i.push(g);
      }
      return i;
    }, u.verifyTimes = function(s) {
      for (const i of s)
        if (!u.verifyTime(i))
          return !1;
      return !0;
    }, u.verifyTrust = function(s) {
      if (u.allowUntrusted)
        return !0;
      for (const i of s)
        if (u.isTrusted(i))
          return !0;
      return !1;
    }, u.verifyChain = function(s) {
      const i = u.parseChain(s);
      if (!u.verifyTimes(i))
        throw new Error("Invalid certificate times.");
      for (let p = 1; p < i.length; p++) {
        const g = i[p - 1], S = i[p], y = u.getSigAlgorithm(g), b = u.getPublicKey(S), h = g.tbs.raw, a = g.sig;
        if (!f.verify(y.hash, h, a, b))
          throw new Error(`${y.key} verification failed for chain.`);
      }
      if (!u.verifyTrust(i))
        throw new Error("Certificate chain is untrusted.");
      return !0;
    }, u.setFingerprints(n);
  }(Dc)), Dc;
}
var el, g8;
function ov() {
  if (g8) return el;
  g8 = 1;
  const e = Xe(), c = xo(), l = wo(), w = n1(), m = Jp();
  class f {
    /**
     * Create a payment request.
     * @constructor
     * @param {Object?} options
     * @property {Number} version
     * @property {String|null} pkiType
     * @property {Buffer|null} pkiData
     * @property {PaymentDetails} paymentDetails
     * @property {Buffer|null} signature
     */
    constructor(s) {
      this.version = -1, this.pkiType = null, this.pkiData = null, this.paymentDetails = new w(), this.signature = null, s && this.fromOptions(s);
    }
    /**
     * Inject properties from options.
     * @private
     * @param {Object} options
     * @returns {PaymentRequest}
     */
    fromOptions(s) {
      return s.version != null && (e((s.version | 0) === s.version), this.version = s.version), s.pkiType != null && (e(typeof s.pkiType == "string"), this.pkiType = s.pkiType), s.pkiData && (e(k.isBuffer(s.pkiData)), this.pkiData = s.pkiData), s.paymentDetails && this.paymentDetails.fromOptions(s.paymentDetails), s.signature && (e(k.isBuffer(s.signature)), this.signature = s.signature), s.chain && this.setChain(s.chain), this;
    }
    /**
     * Instantiate payment request from options.
     * @param {Object} options
     * @returns {PaymentRequest}
     */
    static fromOptions(s) {
      return new f().fromOptions(s);
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     * @returns {PaymentRequest}
     */
    fromRaw(s) {
      const i = new c(s);
      return this.version = i.readFieldU32(1, !0), this.pkiType = i.readFieldString(2, !0), this.pkiData = i.readFieldBytes(3, !0), this.paymentDetails.fromRaw(i.readFieldBytes(4)), this.signature = i.readFieldBytes(5, !0), this;
    }
    /**
     * Instantiate payment request from serialized data.
     * @param {Buffer} data
     * @returns {PaymentRequest}
     */
    static fromRaw(s, i) {
      return typeof s == "string" && (s = k.from(s, i)), new f().fromRaw(s);
    }
    /**
     * Serialize the payment request (protobuf).
     * @returns {Buffer}
     */
    toRaw() {
      const s = new l();
      return this.version !== -1 && s.writeFieldU32(1, this.version), this.pkiType != null && s.writeFieldString(2, this.pkiType), this.pkiData && s.writeFieldBytes(3, this.pkiData), s.writeFieldBytes(4, this.paymentDetails.toRaw()), this.signature && s.writeFieldBytes(5, this.signature), s.render();
    }
    /**
     * Get payment request signature algorithm.
     * @returns {Object|null}
     */
    getAlgorithm() {
      if (!this.pkiType)
        throw new Error("No PKI type available.");
      const s = this.pkiType.split("+");
      if (s.length !== 2)
        throw new Error("Could not parse PKI algorithm.");
      if (s[0] !== "x509")
        throw new Error(`Unknown PKI type: ${s[0]}.`);
      if (s[1] !== "sha1" && s[1] !== "sha256")
        throw new Error(`Unknown hash algorithm: ${s[1]}.`);
      return new n(s[0], s[1]);
    }
    /**
     * Serialize payment request for sighash.
     * @returns {Buffer}
     */
    signatureData() {
      const s = this.signature;
      this.signature = k.alloc(0);
      const i = this.toRaw();
      return this.signature = s, i;
    }
    /**
     * Set x509 certificate chain.
     * @param {Buffer[]} chain
     */
    setChain(s) {
      const i = new l();
      e(Array.isArray(s), "Chain must be an array.");
      for (const p of s)
        e(k.isBuffer(p), "Certificates must be DER."), i.writeFieldBytes(1, p);
      this.pkiData = i.render();
    }
    /**
     * Get x509 certificate chain.
     * @returns {Buffer[]}
     */
    getChain() {
      const s = [];
      if (!this.pkiData)
        return s;
      const i = new c(this.pkiData);
      for (; i.nextTag() === 1; )
        s.push(i.readFieldBytes(1));
      return s;
    }
    /**
     * Sign payment request (chain must be set).
     * @param {Buffer} key
     * @param {Buffer[]?} certs
     */
    sign(s, i) {
      i && this.setChain(i), this.pkiType || (this.pkiType = "x509+sha256");
      const p = this.getAlgorithm(), g = this.signatureData(), S = this.getChain();
      this.signature = m.signSubject(p.hash, g, s, S);
    }
    /**
     * Verify payment request signature.
     * @returns {Boolean}
     */
    verify() {
      if (!this.pkiType || this.pkiType === "none" || !this.signature)
        return !1;
      let s;
      try {
        s = this.getAlgorithm();
      } catch {
        return !1;
      }
      const i = this.signatureData(), p = this.signature, g = this.getChain();
      try {
        return m.verifySubject(s.hash, i, p, g);
      } catch {
        return !1;
      }
    }
    /**
     * Verify x509 certificate chain.
     * @returns {Boolean}
     */
    verifyChain() {
      if (!this.pkiType || this.pkiType === "none")
        return !1;
      try {
        return m.verifyChain(this.getChain());
      } catch {
        return !1;
      }
    }
    /**
     * Get root certificate authority.
     * @returns {Object|null}
     */
    getCA() {
      if (!this.pkiType || this.pkiType === "none")
        throw new Error("No CA found (pkiType).");
      const s = this.getChain();
      if (s.length === 0)
        throw new Error("No CA found (chain).");
      const i = m.parse(s[s.length - 1]);
      return new u(i);
    }
  }
  class n {
    /**
     * Create an algorithm.
     * @constructor
     * @ignore
     */
    constructor(s, i) {
      this.key = s, this.hash = i;
    }
  }
  class u {
    /**
     * Create a CA.
     * @constructor
     * @ignore
     */
    constructor(s) {
      this.name = m.getCAName(s), this.trusted = m.isTrusted(s), this.cert = s;
    }
  }
  return el = f, el;
}
/*!
 * b70.js - bip70 for bcoin
 * Copyright (c) 2016-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var x8;
function av() {
  return x8 || (x8 = 1, li.certs = xp(), li.PaymentACK = Hw(), li.PaymentDetails = n1(), li.Payment = wp(), li.PaymentRequest = ov(), li.x509 = Jp()), li;
}
var w8 = av();
const fv = (e, c, l) => new Promise((w, m) => {
  let f = new XMLHttpRequest();
  f.open("POST", e, !0), Object.entries(c).forEach(([n, u]) => {
    f.setRequestHeader(n, u);
  }), f.responseType = "arraybuffer", f.onload = function(n) {
    let u = f.response;
    if (f.status === 400 || f.status === 404 || f.status === 500) {
      m(
        new Error(
          `${f.status} Error processing payment, please check with the merchant and try again.`
        )
      );
      return;
    }
    u && w(u);
  }, f.onerror = function(n) {
    console.warn(n), m(n);
  }, f.send(l);
}), cv = async (e, c, l) => {
  const m = new w8.Payment(c).toRaw(), f = {
    Accept: `application/${l}-paymentrequest, application/${l}-paymentack`,
    "Content-Type": `application/${l}-payment`,
    "Content-Transfer-Encoding": "binary"
  }, n = await fv(
    e,
    f,
    m
  ), u = k.from(n);
  return w8.PaymentACK.fromRaw(u);
}, { Coin: y8, MTX: uv, Input: hv, Script: lv } = ss, Ts = {
  etokenSats: 546,
  defaultFee: 1.01
}, dv = () => {
  const e = async (n, u, o, s, i, p) => {
    const g = u.state.slp, S = g.nonSlpUtxos.map(
      (L) => y8.fromJSON(L)
    ), y = g.slpUtxos.filter(
      (L) => {
        if (L && L.slp.tokenId === s && L.slp.type !== "BATON")
          return !0;
      }
    );
    if (y.length === 0)
      throw new Error("No MUSD could be found");
    const b = g.tokens;
    let h = {};
    switch (s) {
      case b.prod.tokenId:
        h = b.prod;
        break;
      case b.sandbox.tokenId:
        h = b.sandbox;
        break;
    }
    if (!h)
      throw new Error("Unknown token");
    const a = h.info, E = new uv();
    let H = new dr(0), j = new dr(0), G = new dr(n).times(10 ** a.decimals), N = G;
    const T = [];
    for (let L = 0; L < y.length; L++) {
      const fe = y8.fromJSON(y[L]);
      T.push(fe);
      const ue = new dr(y[L].slp.value);
      H = H.plus(ue);
      const ae = T.length, D = l(ae, 1, i);
      if (j = new dr(D), N = G.plus(j), N.lte(H))
        break;
    }
    const A = [G.toString()];
    j.gt(0) && A.push(j.toString());
    const q = H.minus(N);
    q.gt(0) && A.push(q.toString());
    const _ = w(s, A);
    E.addOutput(_, 0);
    const F = Bi.decode(o[0]), R = Bi.encode(
      "ecash",
      F.type,
      F.hash
    );
    if (E.addOutput(
      R,
      Ts.etokenSats
    ), j.gt(0)) {
      const L = Bi.decode(i.address), fe = Bi.encode(
        "ecash",
        L.type,
        L.hash
      );
      E.addOutput(fe, Ts.etokenSats);
    }
    if (q.gt(0) && E.addOutput(p, Ts.etokenSats), i)
      for (let L = 0; L < T.length; L++)
        E.addCoin(T[L]);
    else {
      const L = {
        inputs: T.map((fe) => hv.fromCoin(fe).prevout),
        changeAddress: p,
        rate: Ts.defaultFee * 1e3
      };
      await E.fund([...T, S], L);
    }
    return console.log("build tx", E.toRaw().toString("hex")), E;
  }, c = async (n) => {
    const u = "https://ecash.badger.cash:8332/broadcast", o = "POST", s = JSON.stringify({ tx: n });
    return await (await fetch(u, { method: o, body: s })).json();
  }, l = (n, u, o) => {
    const s = ["1", "1"];
    for (let y = 0; y < u; y++)
      s.push("1");
    const i = w(
      k.alloc(32).toString("hex"),
      s
    );
    let p = m(
      { P2PKH: n },
      { P2PKH: s.length }
    );
    p += 9 + i.length, p += 546 * (s.length - n);
    let g = Math.ceil(p / o.weight);
    return g < 1 && (g = 1), o.stamp.rate * g;
  }, w = (n, u) => {
    const s = new lv().pushSym("return").pushData(k.concat([
      k.from("SLP", "ascii"),
      k.alloc(1)
    ])).pushPush(k.alloc(1, 2)).pushData(k.from("SEND", "ascii")).pushData(k.from(n, "hex"));
    for (let i = 0; i < u.length; i++) {
      const p = u[i];
      s.pushData(N8.U64.fromString(p).toBE(k));
    }
    return s.compile();
  }, m = (n, u) => {
    let o = 0, s = !1;
    const g = {
      inputs: {
        "MULTISIG-P2SH": 196,
        "MULTISIG-P2WSH": 170,
        "MULTISIG-P2SH-P2WSH": 310,
        P2PKH: 592,
        P2WPKH: 272,
        "P2SH-P2WPKH": 364
      },
      outputs: {
        P2SH: 128,
        P2PKH: 136,
        P2WPKH: 124,
        P2WSH: 172
      }
    };
    return Object.keys(n).forEach(function(S) {
      if (S.slice(0, 8) === "MULTISIG") {
        const y = S.split(":");
        if (y.length !== 2) throw new Error(`invalid input: ${S}`);
        const b = y[0], h = y[1].split("-").map(function(E) {
          return parseInt(E);
        });
        o += g.inputs[b] * n[S];
        const a = b === "MULTISIG-P2SH" ? 4 : 1;
        o += (73 * h[0] + 34 * h[1]) * a;
      } else
        o += g.inputs[S] * n[S];
      S.indexOf("W") >= 0 && (s = !0);
    }), Object.keys(u).forEach(function(S) {
      o += g.outputs[S] * u[S];
    }), s && (o += 2), o += 40, Math.ceil(o / 4);
  };
  return {
    getPostage: async (n) => {
      try {
        const s = await (await fetch("https://pay.badger.cash/postage?currency=etoken")).json(), i = s.stamps.find(
          (p) => p.tokenId === n
        );
        if (console.log("postageObj", s), console.log("stamp", i), i)
          return {
            address: s.address,
            weight: s.weight,
            stamp: i
          };
      } catch (u) {
        console.error(u);
      }
      return null;
    },
    buildSendTx: e,
    broadcastTx: c,
    postPayment: cv
  };
}, {
  TX: bv,
  KeyRing: pv,
  Script: v8
} = ss, Wp = ol({}), mv = ({ children: e }) => {
  const { createWallet: c, cashtab: l, wallet: w, activateWallet: m, update: f, walletLoading: n, walletLoaded: u, removeWallet: o } = Uw(), { getPostage: s, buildSendTx: i, broadcastTx: p, postPayment: g } = dv(), [S, y] = jn("WALLET_INIT");
  return Yn(() => {
    !u || y(n ? "WALLET_LOADING" : "IDLE");
  }, [n, u]), /* @__PURE__ */ fn(Wp, { value: {
    status: S,
    wallet: w,
    cashtab: l,
    validateMnemonic: m4,
    updateWallet: async () => {
      f(l);
    },
    changeWallet: async (A) => {
      if (A.length === 5) {
        const _ = l.wallets.find((F) => F.name === A);
        if (_)
          await m(_);
        else
          throw new Error("Wallet not found");
      } else
        throw new Error("Invalid wallet name");
    },
    addWallet: async (A, q) => {
      if (console.log("addWallet mnemonic", q), q)
        if (console.log("addWallet import wallet"), m4(q))
          c(A, q);
        else
          throw new Error("Invalid mnemonic");
      else
        console.log("addWallet create new wallet"), c(A);
    },
    deleteWallet: async (A) => {
      if (console.log("deleteWallet()"), A.length === 5) {
        const _ = l.wallets.find((F) => F.name === A);
        if (_)
          await o(_);
        else
          throw new Error("Wallet not found");
      } else
        throw new Error("Invalid wallet name");
    },
    send: async (A, q, _, F = !1) => {
      if (!w?.Path1899)
        throw new Error("No wallet found");
      y("SENDING_TOKENS"), console.log(A, q, F);
      const R = w.state.slp.tokens, L = _ ? R.sandbox.tokenId : R.prod.tokenId, fe = await s(L), ue = w.Path1899.cashAddress, ae = await i(A, w, q, L, fe, ue), D = pv.fromSecret(w.Path1899.fundingWif), Q = v8.hashType, W = fe ? Q.ALL | Q.ANYONECANPAY | Q.SIGHASH_FORKID : Q.ALL | Q.SIGHASH_FORKID;
      ae.sign(D, W);
      let oe;
      const v = ae.toRaw(), Y = v.toString("hex");
      if (console.log("hex", Y), fe) {
        const le = "https://pay.badger.cash/postage?currency=etoken", ge = {
          merchantData: k.alloc(0),
          transactions: [v],
          refundTo: [{
            script: v8.fromAddress(ue).toRaw(),
            value: 0
          }],
          memo: ""
        }, we = await g(
          le,
          ge,
          "etoken"
        );
        we.payment && (oe = we.payment.transactions.map(
          (I) => bv.fromRaw(I).txid()
        )[0], console.log("MUSD txid", oe));
      } else {
        let le = { success: !0 };
        F || (le = await p(Y)), oe = ae.txid().toString("hex"), le.success && (console.log("MUSD txid", oe), on.emit("TOKENS_SENT", "success"));
      }
      return `https://explorer.e.cash/tx/${oe}`;
    },
    receive: {},
    bridge: () => {
    },
    withdraw: (A, q) => {
      console.log(A, q);
    }
  }, children: e });
}, Sv = () => {
  const e = al(Wp);
  if (!e)
    throw new Error("useApp must be used within an AppProvider");
  return e;
}, Ev = ({
  children: e
}) => /* @__PURE__ */ fn(rm, { children: /* @__PURE__ */ fn(Dw, { children: /* @__PURE__ */ fn(mv, { children: e }) }) });
export {
  Wp as AppContext,
  mv as AppProvider,
  S8 as AuthContext,
  rm as AuthProvider,
  on as EventBus,
  Ev as MUSDProvider,
  lo as Tokens,
  gp as WalletContext,
  Dw as WalletProvider,
  xx as WalletState,
  Sv as useApp,
  yv as useAuth,
  Uw as useWallet
};
