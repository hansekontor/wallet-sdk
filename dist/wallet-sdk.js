import { jsx as Qi } from "react/jsx-runtime";
import { createContext as vh, use as Sh, useState as Un, useEffect as ph } from "react";
const G3 = vh({}), S7 = ({ children: e }) => /* @__PURE__ */ Qi(G3, { value: {
  isAuthenticationRequired: !1
}, children: e }), gw = () => {
  const e = Sh(G3);
  if (!e)
    throw new Error("useAuth must be used within an AuthProvider");
  return e;
};
var Lt = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Cr(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function ss(e) {
  throw new Error('Could not dynamically require "' + e + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var Ao = { exports: {} };
/*!
    localForage -- Offline Storage, Improved
    Version 1.10.0
    https://localforage.github.io/localForage
    (c) 2013-2017 Mozilla, Apache License 2.0
*/
var kl;
function E7() {
  return kl || (kl = 1, function(e, c) {
    (function(d) {
      e.exports = d();
    })(function() {
      return function d(w, g, f) {
        function n(s, i) {
          if (!g[s]) {
            if (!w[s]) {
              var p = typeof ss == "function" && ss;
              if (!i && p) return p(s, !0);
              if (u) return u(s, !0);
              var m = new Error("Cannot find module '" + s + "'");
              throw m.code = "MODULE_NOT_FOUND", m;
            }
            var E = g[s] = { exports: {} };
            w[s][0].call(E.exports, function(v) {
              var b = w[s][1][v];
              return n(b || v);
            }, E, E.exports, d, w, g, f);
          }
          return g[s].exports;
        }
        for (var u = typeof ss == "function" && ss, a = 0; a < f.length; a++) n(f[a]);
        return n;
      }({ 1: [function(d, w, g) {
        (function(f) {
          var n = f.MutationObserver || f.WebKitMutationObserver, u;
          if (n) {
            var a = 0, s = new n(v), i = f.document.createTextNode("");
            s.observe(i, {
              characterData: !0
            }), u = function() {
              i.data = a = ++a % 2;
            };
          } else if (!f.setImmediate && typeof f.MessageChannel < "u") {
            var p = new f.MessageChannel();
            p.port1.onmessage = v, u = function() {
              p.port2.postMessage(0);
            };
          } else "document" in f && "onreadystatechange" in f.document.createElement("script") ? u = function() {
            var h = f.document.createElement("script");
            h.onreadystatechange = function() {
              v(), h.onreadystatechange = null, h.parentNode.removeChild(h), h = null;
            }, f.document.documentElement.appendChild(h);
          } : u = function() {
            setTimeout(v, 0);
          };
          var m, E = [];
          function v() {
            m = !0;
            for (var h, o, S = E.length; S; ) {
              for (o = E, E = [], h = -1; ++h < S; )
                o[h]();
              S = E.length;
            }
            m = !1;
          }
          w.exports = b;
          function b(h) {
            E.push(h) === 1 && !m && u();
          }
        }).call(this, typeof Lt < "u" ? Lt : typeof self < "u" ? self : typeof window < "u" ? window : {});
      }, {}], 2: [function(d, w, g) {
        var f = d(1);
        function n() {
        }
        var u = {}, a = ["REJECTED"], s = ["FULFILLED"], i = ["PENDING"];
        w.exports = p;
        function p(J) {
          if (typeof J != "function")
            throw new TypeError("resolver must be a function");
          this.state = i, this.queue = [], this.outcome = void 0, J !== n && b(this, J);
        }
        p.prototype.catch = function(J) {
          return this.then(null, J);
        }, p.prototype.then = function(J, N) {
          if (typeof J != "function" && this.state === s || typeof N != "function" && this.state === a)
            return this;
          var z = new this.constructor(n);
          if (this.state !== i) {
            var A = this.state === s ? J : N;
            E(z, A, this.outcome);
          } else
            this.queue.push(new m(z, J, N));
          return z;
        };
        function m(J, N, z) {
          this.promise = J, typeof N == "function" && (this.onFulfilled = N, this.callFulfilled = this.otherCallFulfilled), typeof z == "function" && (this.onRejected = z, this.callRejected = this.otherCallRejected);
        }
        m.prototype.callFulfilled = function(J) {
          u.resolve(this.promise, J);
        }, m.prototype.otherCallFulfilled = function(J) {
          E(this.promise, this.onFulfilled, J);
        }, m.prototype.callRejected = function(J) {
          u.reject(this.promise, J);
        }, m.prototype.otherCallRejected = function(J) {
          E(this.promise, this.onRejected, J);
        };
        function E(J, N, z) {
          f(function() {
            var A;
            try {
              A = N(z);
            } catch (q) {
              return u.reject(J, q);
            }
            A === J ? u.reject(J, new TypeError("Cannot resolve promise with itself")) : u.resolve(J, A);
          });
        }
        u.resolve = function(J, N) {
          var z = h(v, N);
          if (z.status === "error")
            return u.reject(J, z.value);
          var A = z.value;
          if (A)
            b(J, A);
          else {
            J.state = s, J.outcome = N;
            for (var q = -1, _ = J.queue.length; ++q < _; )
              J.queue[q].callFulfilled(N);
          }
          return J;
        }, u.reject = function(J, N) {
          J.state = a, J.outcome = N;
          for (var z = -1, A = J.queue.length; ++z < A; )
            J.queue[z].callRejected(N);
          return J;
        };
        function v(J) {
          var N = J && J.then;
          if (J && (typeof J == "object" || typeof J == "function") && typeof N == "function")
            return function() {
              N.apply(J, arguments);
            };
        }
        function b(J, N) {
          var z = !1;
          function A(R) {
            z || (z = !0, u.reject(J, R));
          }
          function q(R) {
            z || (z = !0, u.resolve(J, R));
          }
          function _() {
            N(q, A);
          }
          var F = h(_);
          F.status === "error" && A(F.value);
        }
        function h(J, N) {
          var z = {};
          try {
            z.value = J(N), z.status = "success";
          } catch (A) {
            z.status = "error", z.value = A;
          }
          return z;
        }
        p.resolve = o;
        function o(J) {
          return J instanceof this ? J : u.resolve(new this(n), J);
        }
        p.reject = S;
        function S(J) {
          var N = new this(n);
          return u.reject(N, J);
        }
        p.all = H;
        function H(J) {
          var N = this;
          if (Object.prototype.toString.call(J) !== "[object Array]")
            return this.reject(new TypeError("must be an array"));
          var z = J.length, A = !1;
          if (!z)
            return this.resolve([]);
          for (var q = new Array(z), _ = 0, F = -1, R = new this(n); ++F < z; )
            V(J[F], F);
          return R;
          function V(fe, ue) {
            N.resolve(fe).then(ae, function(D) {
              A || (A = !0, u.reject(R, D));
            });
            function ae(D) {
              q[ue] = D, ++_ === z && !A && (A = !0, u.resolve(R, q));
            }
          }
        }
        p.race = j;
        function j(J) {
          var N = this;
          if (Object.prototype.toString.call(J) !== "[object Array]")
            return this.reject(new TypeError("must be an array"));
          var z = J.length, A = !1;
          if (!z)
            return this.resolve([]);
          for (var q = -1, _ = new this(n); ++q < z; )
            F(J[q]);
          return _;
          function F(R) {
            N.resolve(R).then(function(V) {
              A || (A = !0, u.resolve(_, V));
            }, function(V) {
              A || (A = !0, u.reject(_, V));
            });
          }
        }
      }, { 1: 1 }], 3: [function(d, w, g) {
        (function(f) {
          typeof f.Promise != "function" && (f.Promise = d(2));
        }).call(this, typeof Lt < "u" ? Lt : typeof self < "u" ? self : typeof window < "u" ? window : {});
      }, { 2: 2 }], 4: [function(d, w, g) {
        var f = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(ie) {
          return typeof ie;
        } : function(ie) {
          return ie && typeof Symbol == "function" && ie.constructor === Symbol && ie !== Symbol.prototype ? "symbol" : typeof ie;
        };
        function n(ie, de) {
          if (!(ie instanceof de))
            throw new TypeError("Cannot call a class as a function");
        }
        function u() {
          try {
            if (typeof indexedDB < "u")
              return indexedDB;
            if (typeof webkitIndexedDB < "u")
              return webkitIndexedDB;
            if (typeof mozIndexedDB < "u")
              return mozIndexedDB;
            if (typeof OIndexedDB < "u")
              return OIndexedDB;
            if (typeof msIndexedDB < "u")
              return msIndexedDB;
          } catch {
            return;
          }
        }
        var a = u();
        function s() {
          try {
            if (!a || !a.open)
              return !1;
            var ie = typeof openDatabase < "u" && /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/BlackBerry/.test(navigator.platform), de = typeof fetch == "function" && fetch.toString().indexOf("[native code") !== -1;
            return (!ie || de) && typeof indexedDB < "u" && // some outdated implementations of IDB that appear on Samsung
            // and HTC Android devices <4.4 are missing IDBKeyRange
            // See: https://github.com/mozilla/localForage/issues/128
            // See: https://github.com/mozilla/localForage/issues/272
            typeof IDBKeyRange < "u";
          } catch {
            return !1;
          }
        }
        function i(ie, de) {
          ie = ie || [], de = de || {};
          try {
            return new Blob(ie, de);
          } catch (Re) {
            if (Re.name !== "TypeError")
              throw Re;
            for (var Se = typeof BlobBuilder < "u" ? BlobBuilder : typeof MSBlobBuilder < "u" ? MSBlobBuilder : typeof MozBlobBuilder < "u" ? MozBlobBuilder : WebKitBlobBuilder, _e = new Se(), Pe = 0; Pe < ie.length; Pe += 1)
              _e.append(ie[Pe]);
            return _e.getBlob(de.type);
          }
        }
        typeof Promise > "u" && d(3);
        var p = Promise;
        function m(ie, de) {
          de && ie.then(function(Se) {
            de(null, Se);
          }, function(Se) {
            de(Se);
          });
        }
        function E(ie, de, Se) {
          typeof de == "function" && ie.then(de), typeof Se == "function" && ie.catch(Se);
        }
        function v(ie) {
          return typeof ie != "string" && (console.warn(ie + " used as a key, but it is not a string."), ie = String(ie)), ie;
        }
        function b() {
          if (arguments.length && typeof arguments[arguments.length - 1] == "function")
            return arguments[arguments.length - 1];
        }
        var h = "local-forage-detect-blob-support", o = void 0, S = {}, H = Object.prototype.toString, j = "readonly", J = "readwrite";
        function N(ie) {
          for (var de = ie.length, Se = new ArrayBuffer(de), _e = new Uint8Array(Se), Pe = 0; Pe < de; Pe++)
            _e[Pe] = ie.charCodeAt(Pe);
          return Se;
        }
        function z(ie) {
          return new p(function(de) {
            var Se = ie.transaction(h, J), _e = i([""]);
            Se.objectStore(h).put(_e, "key"), Se.onabort = function(Pe) {
              Pe.preventDefault(), Pe.stopPropagation(), de(!1);
            }, Se.oncomplete = function() {
              var Pe = navigator.userAgent.match(/Chrome\/(\d+)/), Re = navigator.userAgent.match(/Edge\//);
              de(Re || !Pe || parseInt(Pe[1], 10) >= 43);
            };
          }).catch(function() {
            return !1;
          });
        }
        function A(ie) {
          return typeof o == "boolean" ? p.resolve(o) : z(ie).then(function(de) {
            return o = de, o;
          });
        }
        function q(ie) {
          var de = S[ie.name], Se = {};
          Se.promise = new p(function(_e, Pe) {
            Se.resolve = _e, Se.reject = Pe;
          }), de.deferredOperations.push(Se), de.dbReady ? de.dbReady = de.dbReady.then(function() {
            return Se.promise;
          }) : de.dbReady = Se.promise;
        }
        function _(ie) {
          var de = S[ie.name], Se = de.deferredOperations.pop();
          if (Se)
            return Se.resolve(), Se.promise;
        }
        function F(ie, de) {
          var Se = S[ie.name], _e = Se.deferredOperations.pop();
          if (_e)
            return _e.reject(de), _e.promise;
        }
        function R(ie, de) {
          return new p(function(Se, _e) {
            if (S[ie.name] = S[ie.name] || Y(), ie.db)
              if (de)
                q(ie), ie.db.close();
              else
                return Se(ie.db);
            var Pe = [ie.name];
            de && Pe.push(ie.version);
            var Re = a.open.apply(a, Pe);
            de && (Re.onupgradeneeded = function(Me) {
              var qe = Re.result;
              try {
                qe.createObjectStore(ie.storeName), Me.oldVersion <= 1 && qe.createObjectStore(h);
              } catch (De) {
                if (De.name === "ConstraintError")
                  console.warn('The database "' + ie.name + '" has been upgraded from version ' + Me.oldVersion + " to version " + Me.newVersion + ', but the storage "' + ie.storeName + '" already exists.');
                else
                  throw De;
              }
            }), Re.onerror = function(Me) {
              Me.preventDefault(), _e(Re.error);
            }, Re.onsuccess = function() {
              var Me = Re.result;
              Me.onversionchange = function(qe) {
                qe.target.close();
              }, Se(Me), _(ie);
            };
          });
        }
        function V(ie) {
          return R(ie, !1);
        }
        function fe(ie) {
          return R(ie, !0);
        }
        function ue(ie, de) {
          if (!ie.db)
            return !0;
          var Se = !ie.db.objectStoreNames.contains(ie.storeName), _e = ie.version < ie.db.version, Pe = ie.version > ie.db.version;
          if (_e && (ie.version !== de && console.warn('The database "' + ie.name + `" can't be downgraded from version ` + ie.db.version + " to version " + ie.version + "."), ie.version = ie.db.version), Pe || Se) {
            if (Se) {
              var Re = ie.db.version + 1;
              Re > ie.version && (ie.version = Re);
            }
            return !0;
          }
          return !1;
        }
        function ae(ie) {
          return new p(function(de, Se) {
            var _e = new FileReader();
            _e.onerror = Se, _e.onloadend = function(Pe) {
              var Re = btoa(Pe.target.result || "");
              de({
                __local_forage_encoded_blob: !0,
                data: Re,
                type: ie.type
              });
            }, _e.readAsBinaryString(ie);
          });
        }
        function D(ie) {
          var de = N(atob(ie.data));
          return i([de], { type: ie.type });
        }
        function Q(ie) {
          return ie && ie.__local_forage_encoded_blob;
        }
        function Z(ie) {
          var de = this, Se = de._initReady().then(function() {
            var _e = S[de._dbInfo.name];
            if (_e && _e.dbReady)
              return _e.dbReady;
          });
          return E(Se, ie, ie), Se;
        }
        function oe(ie) {
          q(ie);
          for (var de = S[ie.name], Se = de.forages, _e = 0; _e < Se.length; _e++) {
            var Pe = Se[_e];
            Pe._dbInfo.db && (Pe._dbInfo.db.close(), Pe._dbInfo.db = null);
          }
          return ie.db = null, V(ie).then(function(Re) {
            return ie.db = Re, ue(ie) ? fe(ie) : Re;
          }).then(function(Re) {
            ie.db = de.db = Re;
            for (var Me = 0; Me < Se.length; Me++)
              Se[Me]._dbInfo.db = Re;
          }).catch(function(Re) {
            throw F(ie, Re), Re;
          });
        }
        function y(ie, de, Se, _e) {
          _e === void 0 && (_e = 1);
          try {
            var Pe = ie.db.transaction(ie.storeName, de);
            Se(null, Pe);
          } catch (Re) {
            if (_e > 0 && (!ie.db || Re.name === "InvalidStateError" || Re.name === "NotFoundError"))
              return p.resolve().then(function() {
                if (!ie.db || Re.name === "NotFoundError" && !ie.db.objectStoreNames.contains(ie.storeName) && ie.version <= ie.db.version)
                  return ie.db && (ie.version = ie.db.version + 1), fe(ie);
              }).then(function() {
                return oe(ie).then(function() {
                  y(ie, de, Se, _e - 1);
                });
              }).catch(Se);
            Se(Re);
          }
        }
        function Y() {
          return {
            // Running localForages sharing a database.
            forages: [],
            // Shared database.
            db: null,
            // Database readiness (promise).
            dbReady: null,
            // Deferred operations on the database.
            deferredOperations: []
          };
        }
        function he(ie) {
          var de = this, Se = {
            db: null
          };
          if (ie)
            for (var _e in ie)
              Se[_e] = ie[_e];
          var Pe = S[Se.name];
          Pe || (Pe = Y(), S[Se.name] = Pe), Pe.forages.push(de), de._initReady || (de._initReady = de.ready, de.ready = Z);
          var Re = [];
          function Me() {
            return p.resolve();
          }
          for (var qe = 0; qe < Pe.forages.length; qe++) {
            var De = Pe.forages[qe];
            De !== de && Re.push(De._initReady().catch(Me));
          }
          var Ue = Pe.forages.slice(0);
          return p.all(Re).then(function() {
            return Se.db = Pe.db, V(Se);
          }).then(function(He) {
            return Se.db = He, ue(Se, de._defaultConfig.version) ? fe(Se) : He;
          }).then(function(He) {
            Se.db = Pe.db = He, de._dbInfo = Se;
            for (var je = 0; je < Ue.length; je++) {
              var ft = Ue[je];
              ft !== de && (ft._dbInfo.db = Se.db, ft._dbInfo.version = Se.version);
            }
          });
        }
        function be(ie, de) {
          var Se = this;
          ie = v(ie);
          var _e = new p(function(Pe, Re) {
            Se.ready().then(function() {
              y(Se._dbInfo, j, function(Me, qe) {
                if (Me)
                  return Re(Me);
                try {
                  var De = qe.objectStore(Se._dbInfo.storeName), Ue = De.get(ie);
                  Ue.onsuccess = function() {
                    var He = Ue.result;
                    He === void 0 && (He = null), Q(He) && (He = D(He)), Pe(He);
                  }, Ue.onerror = function() {
                    Re(Ue.error);
                  };
                } catch (He) {
                  Re(He);
                }
              });
            }).catch(Re);
          });
          return m(_e, de), _e;
        }
        function xe(ie, de) {
          var Se = this, _e = new p(function(Pe, Re) {
            Se.ready().then(function() {
              y(Se._dbInfo, j, function(Me, qe) {
                if (Me)
                  return Re(Me);
                try {
                  var De = qe.objectStore(Se._dbInfo.storeName), Ue = De.openCursor(), He = 1;
                  Ue.onsuccess = function() {
                    var je = Ue.result;
                    if (je) {
                      var ft = je.value;
                      Q(ft) && (ft = D(ft));
                      var St = ie(ft, je.key, He++);
                      St !== void 0 ? Pe(St) : je.continue();
                    } else
                      Pe();
                  }, Ue.onerror = function() {
                    Re(Ue.error);
                  };
                } catch (je) {
                  Re(je);
                }
              });
            }).catch(Re);
          });
          return m(_e, de), _e;
        }
        function Ie(ie, de, Se) {
          var _e = this;
          ie = v(ie);
          var Pe = new p(function(Re, Me) {
            var qe;
            _e.ready().then(function() {
              return qe = _e._dbInfo, H.call(de) === "[object Blob]" ? A(qe.db).then(function(De) {
                return De ? de : ae(de);
              }) : de;
            }).then(function(De) {
              y(_e._dbInfo, J, function(Ue, He) {
                if (Ue)
                  return Me(Ue);
                try {
                  var je = He.objectStore(_e._dbInfo.storeName);
                  De === null && (De = void 0);
                  var ft = je.put(De, ie);
                  He.oncomplete = function() {
                    De === void 0 && (De = null), Re(De);
                  }, He.onabort = He.onerror = function() {
                    var St = ft.error ? ft.error : ft.transaction.error;
                    Me(St);
                  };
                } catch (St) {
                  Me(St);
                }
              });
            }).catch(Me);
          });
          return m(Pe, Se), Pe;
        }
        function ve(ie, de) {
          var Se = this;
          ie = v(ie);
          var _e = new p(function(Pe, Re) {
            Se.ready().then(function() {
              y(Se._dbInfo, J, function(Me, qe) {
                if (Me)
                  return Re(Me);
                try {
                  var De = qe.objectStore(Se._dbInfo.storeName), Ue = De.delete(ie);
                  qe.oncomplete = function() {
                    Pe();
                  }, qe.onerror = function() {
                    Re(Ue.error);
                  }, qe.onabort = function() {
                    var He = Ue.error ? Ue.error : Ue.transaction.error;
                    Re(He);
                  };
                } catch (He) {
                  Re(He);
                }
              });
            }).catch(Re);
          });
          return m(_e, de), _e;
        }
        function C(ie) {
          var de = this, Se = new p(function(_e, Pe) {
            de.ready().then(function() {
              y(de._dbInfo, J, function(Re, Me) {
                if (Re)
                  return Pe(Re);
                try {
                  var qe = Me.objectStore(de._dbInfo.storeName), De = qe.clear();
                  Me.oncomplete = function() {
                    _e();
                  }, Me.onabort = Me.onerror = function() {
                    var Ue = De.error ? De.error : De.transaction.error;
                    Pe(Ue);
                  };
                } catch (Ue) {
                  Pe(Ue);
                }
              });
            }).catch(Pe);
          });
          return m(Se, ie), Se;
        }
        function I(ie) {
          var de = this, Se = new p(function(_e, Pe) {
            de.ready().then(function() {
              y(de._dbInfo, j, function(Re, Me) {
                if (Re)
                  return Pe(Re);
                try {
                  var qe = Me.objectStore(de._dbInfo.storeName), De = qe.count();
                  De.onsuccess = function() {
                    _e(De.result);
                  }, De.onerror = function() {
                    Pe(De.error);
                  };
                } catch (Ue) {
                  Pe(Ue);
                }
              });
            }).catch(Pe);
          });
          return m(Se, ie), Se;
        }
        function se(ie, de) {
          var Se = this, _e = new p(function(Pe, Re) {
            if (ie < 0) {
              Pe(null);
              return;
            }
            Se.ready().then(function() {
              y(Se._dbInfo, j, function(Me, qe) {
                if (Me)
                  return Re(Me);
                try {
                  var De = qe.objectStore(Se._dbInfo.storeName), Ue = !1, He = De.openKeyCursor();
                  He.onsuccess = function() {
                    var je = He.result;
                    if (!je) {
                      Pe(null);
                      return;
                    }
                    ie === 0 || Ue ? Pe(je.key) : (Ue = !0, je.advance(ie));
                  }, He.onerror = function() {
                    Re(He.error);
                  };
                } catch (je) {
                  Re(je);
                }
              });
            }).catch(Re);
          });
          return m(_e, de), _e;
        }
        function t(ie) {
          var de = this, Se = new p(function(_e, Pe) {
            de.ready().then(function() {
              y(de._dbInfo, j, function(Re, Me) {
                if (Re)
                  return Pe(Re);
                try {
                  var qe = Me.objectStore(de._dbInfo.storeName), De = qe.openKeyCursor(), Ue = [];
                  De.onsuccess = function() {
                    var He = De.result;
                    if (!He) {
                      _e(Ue);
                      return;
                    }
                    Ue.push(He.key), He.continue();
                  }, De.onerror = function() {
                    Pe(De.error);
                  };
                } catch (He) {
                  Pe(He);
                }
              });
            }).catch(Pe);
          });
          return m(Se, ie), Se;
        }
        function l(ie, de) {
          de = b.apply(this, arguments);
          var Se = this.config();
          ie = typeof ie != "function" && ie || {}, ie.name || (ie.name = ie.name || Se.name, ie.storeName = ie.storeName || Se.storeName);
          var _e = this, Pe;
          if (!ie.name)
            Pe = p.reject("Invalid arguments");
          else {
            var Re = ie.name === Se.name && _e._dbInfo.db, Me = Re ? p.resolve(_e._dbInfo.db) : V(ie).then(function(qe) {
              var De = S[ie.name], Ue = De.forages;
              De.db = qe;
              for (var He = 0; He < Ue.length; He++)
                Ue[He]._dbInfo.db = qe;
              return qe;
            });
            ie.storeName ? Pe = Me.then(function(qe) {
              if (qe.objectStoreNames.contains(ie.storeName)) {
                var De = qe.version + 1;
                q(ie);
                var Ue = S[ie.name], He = Ue.forages;
                qe.close();
                for (var je = 0; je < He.length; je++) {
                  var ft = He[je];
                  ft._dbInfo.db = null, ft._dbInfo.version = De;
                }
                var St = new p(function(Et, Pt) {
                  var Ot = a.open(ie.name, De);
                  Ot.onerror = function(lr) {
                    var wn = Ot.result;
                    wn.close(), Pt(lr);
                  }, Ot.onupgradeneeded = function() {
                    var lr = Ot.result;
                    lr.deleteObjectStore(ie.storeName);
                  }, Ot.onsuccess = function() {
                    var lr = Ot.result;
                    lr.close(), Et(lr);
                  };
                });
                return St.then(function(Et) {
                  Ue.db = Et;
                  for (var Pt = 0; Pt < He.length; Pt++) {
                    var Ot = He[Pt];
                    Ot._dbInfo.db = Et, _(Ot._dbInfo);
                  }
                }).catch(function(Et) {
                  throw (F(ie, Et) || p.resolve()).catch(function() {
                  }), Et;
                });
              }
            }) : Pe = Me.then(function(qe) {
              q(ie);
              var De = S[ie.name], Ue = De.forages;
              qe.close();
              for (var He = 0; He < Ue.length; He++) {
                var je = Ue[He];
                je._dbInfo.db = null;
              }
              var ft = new p(function(St, Et) {
                var Pt = a.deleteDatabase(ie.name);
                Pt.onerror = function() {
                  var Ot = Pt.result;
                  Ot && Ot.close(), Et(Pt.error);
                }, Pt.onblocked = function() {
                  console.warn('dropInstance blocked for database "' + ie.name + '" until all open connections are closed');
                }, Pt.onsuccess = function() {
                  var Ot = Pt.result;
                  Ot && Ot.close(), St(Ot);
                };
              });
              return ft.then(function(St) {
                De.db = St;
                for (var Et = 0; Et < Ue.length; Et++) {
                  var Pt = Ue[Et];
                  _(Pt._dbInfo);
                }
              }).catch(function(St) {
                throw (F(ie, St) || p.resolve()).catch(function() {
                }), St;
              });
            });
          }
          return m(Pe, de), Pe;
        }
        var B = {
          _driver: "asyncStorage",
          _initStorage: he,
          _support: s(),
          iterate: xe,
          getItem: be,
          setItem: Ie,
          removeItem: ve,
          clear: C,
          length: I,
          key: se,
          keys: t,
          dropInstance: l
        };
        function U() {
          return typeof openDatabase == "function";
        }
        var G = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", T = "~~local_forage_type~", M = /^~~local_forage_type~([^~]+)~/, $ = "__lfsc__:", r = $.length, x = "arbf", O = "blob", L = "si08", X = "ui08", P = "uic8", K = "si16", re = "si32", ce = "ur16", le = "ui32", me = "fl32", ne = "fl64", W = r + x.length, te = Object.prototype.toString;
        function pe(ie) {
          var de = ie.length * 0.75, Se = ie.length, _e, Pe = 0, Re, Me, qe, De;
          ie[ie.length - 1] === "=" && (de--, ie[ie.length - 2] === "=" && de--);
          var Ue = new ArrayBuffer(de), He = new Uint8Array(Ue);
          for (_e = 0; _e < Se; _e += 4)
            Re = G.indexOf(ie[_e]), Me = G.indexOf(ie[_e + 1]), qe = G.indexOf(ie[_e + 2]), De = G.indexOf(ie[_e + 3]), He[Pe++] = Re << 2 | Me >> 4, He[Pe++] = (Me & 15) << 4 | qe >> 2, He[Pe++] = (qe & 3) << 6 | De & 63;
          return Ue;
        }
        function Ee(ie) {
          var de = new Uint8Array(ie), Se = "", _e;
          for (_e = 0; _e < de.length; _e += 3)
            Se += G[de[_e] >> 2], Se += G[(de[_e] & 3) << 4 | de[_e + 1] >> 4], Se += G[(de[_e + 1] & 15) << 2 | de[_e + 2] >> 6], Se += G[de[_e + 2] & 63];
          return de.length % 3 === 2 ? Se = Se.substring(0, Se.length - 1) + "=" : de.length % 3 === 1 && (Se = Se.substring(0, Se.length - 2) + "=="), Se;
        }
        function Ae(ie, de) {
          var Se = "";
          if (ie && (Se = te.call(ie)), ie && (Se === "[object ArrayBuffer]" || ie.buffer && te.call(ie.buffer) === "[object ArrayBuffer]")) {
            var _e, Pe = $;
            ie instanceof ArrayBuffer ? (_e = ie, Pe += x) : (_e = ie.buffer, Se === "[object Int8Array]" ? Pe += L : Se === "[object Uint8Array]" ? Pe += X : Se === "[object Uint8ClampedArray]" ? Pe += P : Se === "[object Int16Array]" ? Pe += K : Se === "[object Uint16Array]" ? Pe += ce : Se === "[object Int32Array]" ? Pe += re : Se === "[object Uint32Array]" ? Pe += le : Se === "[object Float32Array]" ? Pe += me : Se === "[object Float64Array]" ? Pe += ne : de(new Error("Failed to get type for BinaryArray"))), de(Pe + Ee(_e));
          } else if (Se === "[object Blob]") {
            var Re = new FileReader();
            Re.onload = function() {
              var Me = T + ie.type + "~" + Ee(this.result);
              de($ + O + Me);
            }, Re.readAsArrayBuffer(ie);
          } else
            try {
              de(JSON.stringify(ie));
            } catch (Me) {
              console.error("Couldn't convert value into a JSON string: ", ie), de(null, Me);
            }
        }
        function Oe(ie) {
          if (ie.substring(0, r) !== $)
            return JSON.parse(ie);
          var de = ie.substring(W), Se = ie.substring(r, W), _e;
          if (Se === O && M.test(de)) {
            var Pe = de.match(M);
            _e = Pe[1], de = de.substring(Pe[0].length);
          }
          var Re = pe(de);
          switch (Se) {
            case x:
              return Re;
            case O:
              return i([Re], { type: _e });
            case L:
              return new Int8Array(Re);
            case X:
              return new Uint8Array(Re);
            case P:
              return new Uint8ClampedArray(Re);
            case K:
              return new Int16Array(Re);
            case ce:
              return new Uint16Array(Re);
            case re:
              return new Int32Array(Re);
            case le:
              return new Uint32Array(Re);
            case me:
              return new Float32Array(Re);
            case ne:
              return new Float64Array(Re);
            default:
              throw new Error("Unkown type: " + Se);
          }
        }
        var Be = {
          serialize: Ae,
          deserialize: Oe,
          stringToBuffer: pe,
          bufferToString: Ee
        };
        function ke(ie, de, Se, _e) {
          ie.executeSql("CREATE TABLE IF NOT EXISTS " + de.storeName + " (id INTEGER PRIMARY KEY, key unique, value)", [], Se, _e);
        }
        function Ne(ie) {
          var de = this, Se = {
            db: null
          };
          if (ie)
            for (var _e in ie)
              Se[_e] = typeof ie[_e] != "string" ? ie[_e].toString() : ie[_e];
          var Pe = new p(function(Re, Me) {
            try {
              Se.db = openDatabase(Se.name, String(Se.version), Se.description, Se.size);
            } catch (qe) {
              return Me(qe);
            }
            Se.db.transaction(function(qe) {
              ke(qe, Se, function() {
                de._dbInfo = Se, Re();
              }, function(De, Ue) {
                Me(Ue);
              });
            }, Me);
          });
          return Se.serializer = Be, Pe;
        }
        function Ke(ie, de, Se, _e, Pe, Re) {
          ie.executeSql(Se, _e, Pe, function(Me, qe) {
            qe.code === qe.SYNTAX_ERR ? Me.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name = ?", [de.storeName], function(De, Ue) {
              Ue.rows.length ? Re(De, qe) : ke(De, de, function() {
                De.executeSql(Se, _e, Pe, Re);
              }, Re);
            }, Re) : Re(Me, qe);
          }, Re);
        }
        function Ce(ie, de) {
          var Se = this;
          ie = v(ie);
          var _e = new p(function(Pe, Re) {
            Se.ready().then(function() {
              var Me = Se._dbInfo;
              Me.db.transaction(function(qe) {
                Ke(qe, Me, "SELECT * FROM " + Me.storeName + " WHERE key = ? LIMIT 1", [ie], function(De, Ue) {
                  var He = Ue.rows.length ? Ue.rows.item(0).value : null;
                  He && (He = Me.serializer.deserialize(He)), Pe(He);
                }, function(De, Ue) {
                  Re(Ue);
                });
              });
            }).catch(Re);
          });
          return m(_e, de), _e;
        }
        function Ye(ie, de) {
          var Se = this, _e = new p(function(Pe, Re) {
            Se.ready().then(function() {
              var Me = Se._dbInfo;
              Me.db.transaction(function(qe) {
                Ke(qe, Me, "SELECT * FROM " + Me.storeName, [], function(De, Ue) {
                  for (var He = Ue.rows, je = He.length, ft = 0; ft < je; ft++) {
                    var St = He.item(ft), Et = St.value;
                    if (Et && (Et = Me.serializer.deserialize(Et)), Et = ie(Et, St.key, ft + 1), Et !== void 0) {
                      Pe(Et);
                      return;
                    }
                  }
                  Pe();
                }, function(De, Ue) {
                  Re(Ue);
                });
              });
            }).catch(Re);
          });
          return m(_e, de), _e;
        }
        function vt(ie, de, Se, _e) {
          var Pe = this;
          ie = v(ie);
          var Re = new p(function(Me, qe) {
            Pe.ready().then(function() {
              de === void 0 && (de = null);
              var De = de, Ue = Pe._dbInfo;
              Ue.serializer.serialize(de, function(He, je) {
                je ? qe(je) : Ue.db.transaction(function(ft) {
                  Ke(ft, Ue, "INSERT OR REPLACE INTO " + Ue.storeName + " (key, value) VALUES (?, ?)", [ie, He], function() {
                    Me(De);
                  }, function(St, Et) {
                    qe(Et);
                  });
                }, function(ft) {
                  if (ft.code === ft.QUOTA_ERR) {
                    if (_e > 0) {
                      Me(vt.apply(Pe, [ie, De, Se, _e - 1]));
                      return;
                    }
                    qe(ft);
                  }
                });
              });
            }).catch(qe);
          });
          return m(Re, Se), Re;
        }
        function Ve(ie, de, Se) {
          return vt.apply(this, [ie, de, Se, 1]);
        }
        function Xe(ie, de) {
          var Se = this;
          ie = v(ie);
          var _e = new p(function(Pe, Re) {
            Se.ready().then(function() {
              var Me = Se._dbInfo;
              Me.db.transaction(function(qe) {
                Ke(qe, Me, "DELETE FROM " + Me.storeName + " WHERE key = ?", [ie], function() {
                  Pe();
                }, function(De, Ue) {
                  Re(Ue);
                });
              });
            }).catch(Re);
          });
          return m(_e, de), _e;
        }
        function qt(ie) {
          var de = this, Se = new p(function(_e, Pe) {
            de.ready().then(function() {
              var Re = de._dbInfo;
              Re.db.transaction(function(Me) {
                Ke(Me, Re, "DELETE FROM " + Re.storeName, [], function() {
                  _e();
                }, function(qe, De) {
                  Pe(De);
                });
              });
            }).catch(Pe);
          });
          return m(Se, ie), Se;
        }
        function Ge(ie) {
          var de = this, Se = new p(function(_e, Pe) {
            de.ready().then(function() {
              var Re = de._dbInfo;
              Re.db.transaction(function(Me) {
                Ke(Me, Re, "SELECT COUNT(key) as c FROM " + Re.storeName, [], function(qe, De) {
                  var Ue = De.rows.item(0).c;
                  _e(Ue);
                }, function(qe, De) {
                  Pe(De);
                });
              });
            }).catch(Pe);
          });
          return m(Se, ie), Se;
        }
        function Je(ie, de) {
          var Se = this, _e = new p(function(Pe, Re) {
            Se.ready().then(function() {
              var Me = Se._dbInfo;
              Me.db.transaction(function(qe) {
                Ke(qe, Me, "SELECT key FROM " + Me.storeName + " WHERE id = ? LIMIT 1", [ie + 1], function(De, Ue) {
                  var He = Ue.rows.length ? Ue.rows.item(0).key : null;
                  Pe(He);
                }, function(De, Ue) {
                  Re(Ue);
                });
              });
            }).catch(Re);
          });
          return m(_e, de), _e;
        }
        function Rt(ie) {
          var de = this, Se = new p(function(_e, Pe) {
            de.ready().then(function() {
              var Re = de._dbInfo;
              Re.db.transaction(function(Me) {
                Ke(Me, Re, "SELECT key FROM " + Re.storeName, [], function(qe, De) {
                  for (var Ue = [], He = 0; He < De.rows.length; He++)
                    Ue.push(De.rows.item(He).key);
                  _e(Ue);
                }, function(qe, De) {
                  Pe(De);
                });
              });
            }).catch(Pe);
          });
          return m(Se, ie), Se;
        }
        function We(ie) {
          return new p(function(de, Se) {
            ie.transaction(function(_e) {
              _e.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name <> '__WebKitDatabaseInfoTable__'", [], function(Pe, Re) {
                for (var Me = [], qe = 0; qe < Re.rows.length; qe++)
                  Me.push(Re.rows.item(qe).name);
                de({
                  db: ie,
                  storeNames: Me
                });
              }, function(Pe, Re) {
                Se(Re);
              });
            }, function(_e) {
              Se(_e);
            });
          });
        }
        function Ze(ie, de) {
          de = b.apply(this, arguments);
          var Se = this.config();
          ie = typeof ie != "function" && ie || {}, ie.name || (ie.name = ie.name || Se.name, ie.storeName = ie.storeName || Se.storeName);
          var _e = this, Pe;
          return ie.name ? Pe = new p(function(Re) {
            var Me;
            ie.name === Se.name ? Me = _e._dbInfo.db : Me = openDatabase(ie.name, "", "", 0), ie.storeName ? Re({
              db: Me,
              storeNames: [ie.storeName]
            }) : Re(We(Me));
          }).then(function(Re) {
            return new p(function(Me, qe) {
              Re.db.transaction(function(De) {
                function Ue(St) {
                  return new p(function(Et, Pt) {
                    De.executeSql("DROP TABLE IF EXISTS " + St, [], function() {
                      Et();
                    }, function(Ot, lr) {
                      Pt(lr);
                    });
                  });
                }
                for (var He = [], je = 0, ft = Re.storeNames.length; je < ft; je++)
                  He.push(Ue(Re.storeNames[je]));
                p.all(He).then(function() {
                  Me();
                }).catch(function(St) {
                  qe(St);
                });
              }, function(De) {
                qe(De);
              });
            });
          }) : Pe = p.reject("Invalid arguments"), m(Pe, de), Pe;
        }
        var Ft = {
          _driver: "webSQLStorage",
          _initStorage: Ne,
          _support: U(),
          iterate: Ye,
          getItem: Ce,
          setItem: Ve,
          removeItem: Xe,
          clear: qt,
          length: Ge,
          key: Je,
          keys: Rt,
          dropInstance: Ze
        };
        function Qe() {
          try {
            return typeof localStorage < "u" && "setItem" in localStorage && // in IE8 typeof localStorage.setItem === 'object'
            !!localStorage.setItem;
          } catch {
            return !1;
          }
        }
        function st(ie, de) {
          var Se = ie.name + "/";
          return ie.storeName !== de.storeName && (Se += ie.storeName + "/"), Se;
        }
        function Kr() {
          var ie = "_localforage_support_test";
          try {
            return localStorage.setItem(ie, !0), localStorage.removeItem(ie), !1;
          } catch {
            return !0;
          }
        }
        function ct() {
          return !Kr() || localStorage.length > 0;
        }
        function ut(ie) {
          var de = this, Se = {};
          if (ie)
            for (var _e in ie)
              Se[_e] = ie[_e];
          return Se.keyPrefix = st(ie, de._defaultConfig), ct() ? (de._dbInfo = Se, Se.serializer = Be, p.resolve()) : p.reject();
        }
        function Vr(ie) {
          var de = this, Se = de.ready().then(function() {
            for (var _e = de._dbInfo.keyPrefix, Pe = localStorage.length - 1; Pe >= 0; Pe--) {
              var Re = localStorage.key(Pe);
              Re.indexOf(_e) === 0 && localStorage.removeItem(Re);
            }
          });
          return m(Se, ie), Se;
        }
        function rt(ie, de) {
          var Se = this;
          ie = v(ie);
          var _e = Se.ready().then(function() {
            var Pe = Se._dbInfo, Re = localStorage.getItem(Pe.keyPrefix + ie);
            return Re && (Re = Pe.serializer.deserialize(Re)), Re;
          });
          return m(_e, de), _e;
        }
        function ht(ie, de) {
          var Se = this, _e = Se.ready().then(function() {
            for (var Pe = Se._dbInfo, Re = Pe.keyPrefix, Me = Re.length, qe = localStorage.length, De = 1, Ue = 0; Ue < qe; Ue++) {
              var He = localStorage.key(Ue);
              if (He.indexOf(Re) === 0) {
                var je = localStorage.getItem(He);
                if (je && (je = Pe.serializer.deserialize(je)), je = ie(je, He.substring(Me), De++), je !== void 0)
                  return je;
              }
            }
          });
          return m(_e, de), _e;
        }
        function $r(ie, de) {
          var Se = this, _e = Se.ready().then(function() {
            var Pe = Se._dbInfo, Re;
            try {
              Re = localStorage.key(ie);
            } catch {
              Re = null;
            }
            return Re && (Re = Re.substring(Pe.keyPrefix.length)), Re;
          });
          return m(_e, de), _e;
        }
        function lt(ie) {
          var de = this, Se = de.ready().then(function() {
            for (var _e = de._dbInfo, Pe = localStorage.length, Re = [], Me = 0; Me < Pe; Me++) {
              var qe = localStorage.key(Me);
              qe.indexOf(_e.keyPrefix) === 0 && Re.push(qe.substring(_e.keyPrefix.length));
            }
            return Re;
          });
          return m(Se, ie), Se;
        }
        function dt(ie) {
          var de = this, Se = de.keys().then(function(_e) {
            return _e.length;
          });
          return m(Se, ie), Se;
        }
        function jr(ie, de) {
          var Se = this;
          ie = v(ie);
          var _e = Se.ready().then(function() {
            var Pe = Se._dbInfo;
            localStorage.removeItem(Pe.keyPrefix + ie);
          });
          return m(_e, de), _e;
        }
        function bt(ie, de, Se) {
          var _e = this;
          ie = v(ie);
          var Pe = _e.ready().then(function() {
            de === void 0 && (de = null);
            var Re = de;
            return new p(function(Me, qe) {
              var De = _e._dbInfo;
              De.serializer.serialize(de, function(Ue, He) {
                if (He)
                  qe(He);
                else
                  try {
                    localStorage.setItem(De.keyPrefix + ie, Ue), Me(Re);
                  } catch (je) {
                    (je.name === "QuotaExceededError" || je.name === "NS_ERROR_DOM_QUOTA_REACHED") && qe(je), qe(je);
                  }
              });
            });
          });
          return m(Pe, Se), Pe;
        }
        function pt(ie, de) {
          if (de = b.apply(this, arguments), ie = typeof ie != "function" && ie || {}, !ie.name) {
            var Se = this.config();
            ie.name = ie.name || Se.name, ie.storeName = ie.storeName || Se.storeName;
          }
          var _e = this, Pe;
          return ie.name ? Pe = new p(function(Re) {
            ie.storeName ? Re(st(ie, _e._defaultConfig)) : Re(ie.name + "/");
          }).then(function(Re) {
            for (var Me = localStorage.length - 1; Me >= 0; Me--) {
              var qe = localStorage.key(Me);
              qe.indexOf(Re) === 0 && localStorage.removeItem(qe);
            }
          }) : Pe = p.reject("Invalid arguments"), m(Pe, de), Pe;
        }
        var Yr = {
          _driver: "localStorageWrapper",
          _initStorage: ut,
          _support: Qe(),
          iterate: ht,
          getItem: rt,
          setItem: bt,
          removeItem: jr,
          clear: Vr,
          length: dt,
          key: $r,
          keys: lt,
          dropInstance: pt
        }, ot = function(de, Se) {
          return de === Se || typeof de == "number" && typeof Se == "number" && isNaN(de) && isNaN(Se);
        }, mt = function(de, Se) {
          for (var _e = de.length, Pe = 0; Pe < _e; ) {
            if (ot(de[Pe], Se))
              return !0;
            Pe++;
          }
          return !1;
        }, kr = Array.isArray || function(ie) {
          return Object.prototype.toString.call(ie) === "[object Array]";
        }, et = {}, at = {}, ir = {
          INDEXEDDB: B,
          WEBSQL: Ft,
          LOCALSTORAGE: Yr
        }, it = [ir.INDEXEDDB._driver, ir.WEBSQL._driver, ir.LOCALSTORAGE._driver], tt = ["dropInstance"], Le = ["clear", "getItem", "iterate", "key", "keys", "length", "removeItem", "setItem"].concat(tt), ye = {
          description: "",
          driver: it.slice(),
          name: "localforage",
          // Default DB size is _JUST UNDER_ 5MB, as it's the highest size
          // we can use without a prompt.
          size: 4980736,
          storeName: "keyvaluepairs",
          version: 1
        };
        function ee(ie, de) {
          ie[de] = function() {
            var Se = arguments;
            return ie.ready().then(function() {
              return ie[de].apply(ie, Se);
            });
          };
        }
        function we() {
          for (var ie = 1; ie < arguments.length; ie++) {
            var de = arguments[ie];
            if (de)
              for (var Se in de)
                de.hasOwnProperty(Se) && (kr(de[Se]) ? arguments[0][Se] = de[Se].slice() : arguments[0][Se] = de[Se]);
          }
          return arguments[0];
        }
        var Ct = function() {
          function ie(de) {
            n(this, ie);
            for (var Se in ir)
              if (ir.hasOwnProperty(Se)) {
                var _e = ir[Se], Pe = _e._driver;
                this[Se] = Pe, et[Pe] || this.defineDriver(_e);
              }
            this._defaultConfig = we({}, ye), this._config = we({}, this._defaultConfig, de), this._driverSet = null, this._initDriver = null, this._ready = !1, this._dbInfo = null, this._wrapLibraryMethodsWithReady(), this.setDriver(this._config.driver).catch(function() {
            });
          }
          return ie.prototype.config = function(Se) {
            if ((typeof Se > "u" ? "undefined" : f(Se)) === "object") {
              if (this._ready)
                return new Error("Can't call config() after localforage has been used.");
              for (var _e in Se) {
                if (_e === "storeName" && (Se[_e] = Se[_e].replace(/\W/g, "_")), _e === "version" && typeof Se[_e] != "number")
                  return new Error("Database version must be a number.");
                this._config[_e] = Se[_e];
              }
              return "driver" in Se && Se.driver ? this.setDriver(this._config.driver) : !0;
            } else return typeof Se == "string" ? this._config[Se] : this._config;
          }, ie.prototype.defineDriver = function(Se, _e, Pe) {
            var Re = new p(function(Me, qe) {
              try {
                var De = Se._driver, Ue = new Error("Custom driver not compliant; see https://mozilla.github.io/localForage/#definedriver");
                if (!Se._driver) {
                  qe(Ue);
                  return;
                }
                for (var He = Le.concat("_initStorage"), je = 0, ft = He.length; je < ft; je++) {
                  var St = He[je], Et = !mt(tt, St);
                  if ((Et || Se[St]) && typeof Se[St] != "function") {
                    qe(Ue);
                    return;
                  }
                }
                var Pt = function() {
                  for (var wn = function(y7) {
                    return function() {
                      var v7 = new Error("Method " + y7 + " is not implemented by the current driver"), Pl = p.reject(v7);
                      return m(Pl, arguments[arguments.length - 1]), Pl;
                    };
                  }, Eo = 0, w7 = tt.length; Eo < w7; Eo++) {
                    var Io = tt[Eo];
                    Se[Io] || (Se[Io] = wn(Io));
                  }
                };
                Pt();
                var Ot = function(wn) {
                  et[De] && console.info("Redefining LocalForage driver: " + De), et[De] = Se, at[De] = wn, Me();
                };
                "_support" in Se ? Se._support && typeof Se._support == "function" ? Se._support().then(Ot, qe) : Ot(!!Se._support) : Ot(!0);
              } catch (lr) {
                qe(lr);
              }
            });
            return E(Re, _e, Pe), Re;
          }, ie.prototype.driver = function() {
            return this._driver || null;
          }, ie.prototype.getDriver = function(Se, _e, Pe) {
            var Re = et[Se] ? p.resolve(et[Se]) : p.reject(new Error("Driver not found."));
            return E(Re, _e, Pe), Re;
          }, ie.prototype.getSerializer = function(Se) {
            var _e = p.resolve(Be);
            return E(_e, Se), _e;
          }, ie.prototype.ready = function(Se) {
            var _e = this, Pe = _e._driverSet.then(function() {
              return _e._ready === null && (_e._ready = _e._initDriver()), _e._ready;
            });
            return E(Pe, Se, Se), Pe;
          }, ie.prototype.setDriver = function(Se, _e, Pe) {
            var Re = this;
            kr(Se) || (Se = [Se]);
            var Me = this._getSupportedDrivers(Se);
            function qe() {
              Re._config.driver = Re.driver();
            }
            function De(je) {
              return Re._extend(je), qe(), Re._ready = Re._initStorage(Re._config), Re._ready;
            }
            function Ue(je) {
              return function() {
                var ft = 0;
                function St() {
                  for (; ft < je.length; ) {
                    var Et = je[ft];
                    return ft++, Re._dbInfo = null, Re._ready = null, Re.getDriver(Et).then(De).catch(St);
                  }
                  qe();
                  var Pt = new Error("No available storage method found.");
                  return Re._driverSet = p.reject(Pt), Re._driverSet;
                }
                return St();
              };
            }
            var He = this._driverSet !== null ? this._driverSet.catch(function() {
              return p.resolve();
            }) : p.resolve();
            return this._driverSet = He.then(function() {
              var je = Me[0];
              return Re._dbInfo = null, Re._ready = null, Re.getDriver(je).then(function(ft) {
                Re._driver = ft._driver, qe(), Re._wrapLibraryMethodsWithReady(), Re._initDriver = Ue(Me);
              });
            }).catch(function() {
              qe();
              var je = new Error("No available storage method found.");
              return Re._driverSet = p.reject(je), Re._driverSet;
            }), E(this._driverSet, _e, Pe), this._driverSet;
          }, ie.prototype.supports = function(Se) {
            return !!at[Se];
          }, ie.prototype._extend = function(Se) {
            we(this, Se);
          }, ie.prototype._getSupportedDrivers = function(Se) {
            for (var _e = [], Pe = 0, Re = Se.length; Pe < Re; Pe++) {
              var Me = Se[Pe];
              this.supports(Me) && _e.push(Me);
            }
            return _e;
          }, ie.prototype._wrapLibraryMethodsWithReady = function() {
            for (var Se = 0, _e = Le.length; Se < _e; Se++)
              ee(this, Le[Se]);
          }, ie.prototype.createInstance = function(Se) {
            return new ie(Se);
          }, ie;
        }(), ge = new Ct();
        w.exports = ge;
      }, { 3: 3 }] }, {}, [4])(4);
    });
  }(Ao)), Ao.exports;
}
var I7 = E7();
const Bl = /* @__PURE__ */ Cr(I7), Ps = globalThis || void 0 || self;
var W3 = {}, qs = {};
qs.byteLength = _7;
qs.toByteArray = P7;
qs.fromByteArray = M7;
var Nr = [], mr = [], A7 = typeof Uint8Array < "u" ? Uint8Array : Array, Oo = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var Ki = 0, O7 = Oo.length; Ki < O7; ++Ki)
  Nr[Ki] = Oo[Ki], mr[Oo.charCodeAt(Ki)] = Ki;
mr[45] = 62;
mr[95] = 63;
function Z3(e) {
  var c = e.length;
  if (c % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var d = e.indexOf("=");
  d === -1 && (d = c);
  var w = d === c ? 0 : 4 - d % 4;
  return [d, w];
}
function _7(e) {
  var c = Z3(e), d = c[0], w = c[1];
  return (d + w) * 3 / 4 - w;
}
function R7(e, c, d) {
  return (c + d) * 3 / 4 - d;
}
function P7(e) {
  var c, d = Z3(e), w = d[0], g = d[1], f = new A7(R7(e, w, g)), n = 0, u = g > 0 ? w - 4 : w, a;
  for (a = 0; a < u; a += 4)
    c = mr[e.charCodeAt(a)] << 18 | mr[e.charCodeAt(a + 1)] << 12 | mr[e.charCodeAt(a + 2)] << 6 | mr[e.charCodeAt(a + 3)], f[n++] = c >> 16 & 255, f[n++] = c >> 8 & 255, f[n++] = c & 255;
  return g === 2 && (c = mr[e.charCodeAt(a)] << 2 | mr[e.charCodeAt(a + 1)] >> 4, f[n++] = c & 255), g === 1 && (c = mr[e.charCodeAt(a)] << 10 | mr[e.charCodeAt(a + 1)] << 4 | mr[e.charCodeAt(a + 2)] >> 2, f[n++] = c >> 8 & 255, f[n++] = c & 255), f;
}
function k7(e) {
  return Nr[e >> 18 & 63] + Nr[e >> 12 & 63] + Nr[e >> 6 & 63] + Nr[e & 63];
}
function B7(e, c, d) {
  for (var w, g = [], f = c; f < d; f += 3)
    w = (e[f] << 16 & 16711680) + (e[f + 1] << 8 & 65280) + (e[f + 2] & 255), g.push(k7(w));
  return g.join("");
}
function M7(e) {
  for (var c, d = e.length, w = d % 3, g = [], f = 16383, n = 0, u = d - w; n < u; n += f)
    g.push(B7(e, n, n + f > u ? u : n + f));
  return w === 1 ? (c = e[d - 1], g.push(
    Nr[c >> 2] + Nr[c << 4 & 63] + "=="
  )) : w === 2 && (c = (e[d - 2] << 8) + e[d - 1], g.push(
    Nr[c >> 10] + Nr[c >> 4 & 63] + Nr[c << 2 & 63] + "="
  )), g.join("");
}
var Eh = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
Eh.read = function(e, c, d, w, g) {
  var f, n, u = g * 8 - w - 1, a = (1 << u) - 1, s = a >> 1, i = -7, p = d ? g - 1 : 0, m = d ? -1 : 1, E = e[c + p];
  for (p += m, f = E & (1 << -i) - 1, E >>= -i, i += u; i > 0; f = f * 256 + e[c + p], p += m, i -= 8)
    ;
  for (n = f & (1 << -i) - 1, f >>= -i, i += w; i > 0; n = n * 256 + e[c + p], p += m, i -= 8)
    ;
  if (f === 0)
    f = 1 - s;
  else {
    if (f === a)
      return n ? NaN : (E ? -1 : 1) * (1 / 0);
    n = n + Math.pow(2, w), f = f - s;
  }
  return (E ? -1 : 1) * n * Math.pow(2, f - w);
};
Eh.write = function(e, c, d, w, g, f) {
  var n, u, a, s = f * 8 - g - 1, i = (1 << s) - 1, p = i >> 1, m = g === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, E = w ? 0 : f - 1, v = w ? 1 : -1, b = c < 0 || c === 0 && 1 / c < 0 ? 1 : 0;
  for (c = Math.abs(c), isNaN(c) || c === 1 / 0 ? (u = isNaN(c) ? 1 : 0, n = i) : (n = Math.floor(Math.log(c) / Math.LN2), c * (a = Math.pow(2, -n)) < 1 && (n--, a *= 2), n + p >= 1 ? c += m / a : c += m * Math.pow(2, 1 - p), c * a >= 2 && (n++, a /= 2), n + p >= i ? (u = 0, n = i) : n + p >= 1 ? (u = (c * a - 1) * Math.pow(2, g), n = n + p) : (u = c * Math.pow(2, p - 1) * Math.pow(2, g), n = 0)); g >= 8; e[d + E] = u & 255, E += v, u /= 256, g -= 8)
    ;
  for (n = n << g | u, s += g; s > 0; e[d + E] = n & 255, E += v, n /= 256, s -= 8)
    ;
  e[d + E - v] |= b * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(e) {
  const c = qs, d = Eh, w = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  e.Buffer = i, e.SlowBuffer = J, e.INSPECT_MAX_BYTES = 50;
  const g = 2147483647;
  e.kMaxLength = g;
  const { Uint8Array: f, ArrayBuffer: n, SharedArrayBuffer: u } = globalThis;
  i.TYPED_ARRAY_SUPPORT = a(), !i.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function a() {
    try {
      const ne = new f(1), W = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(W, f.prototype), Object.setPrototypeOf(ne, W), ne.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(i.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (i.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(i.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (i.isBuffer(this))
        return this.byteOffset;
    }
  });
  function s(ne) {
    if (ne > g)
      throw new RangeError('The value "' + ne + '" is invalid for option "size"');
    const W = new f(ne);
    return Object.setPrototypeOf(W, i.prototype), W;
  }
  function i(ne, W, te) {
    if (typeof ne == "number") {
      if (typeof W == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return v(ne);
    }
    return p(ne, W, te);
  }
  i.poolSize = 8192;
  function p(ne, W, te) {
    if (typeof ne == "string")
      return b(ne, W);
    if (n.isView(ne))
      return o(ne);
    if (ne == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof ne
      );
    if (K(ne, n) || ne && K(ne.buffer, n) || typeof u < "u" && (K(ne, u) || ne && K(ne.buffer, u)))
      return S(ne, W, te);
    if (typeof ne == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    const pe = ne.valueOf && ne.valueOf();
    if (pe != null && pe !== ne)
      return i.from(pe, W, te);
    const Ee = H(ne);
    if (Ee) return Ee;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof ne[Symbol.toPrimitive] == "function")
      return i.from(ne[Symbol.toPrimitive]("string"), W, te);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof ne
    );
  }
  i.from = function(ne, W, te) {
    return p(ne, W, te);
  }, Object.setPrototypeOf(i.prototype, f.prototype), Object.setPrototypeOf(i, f);
  function m(ne) {
    if (typeof ne != "number")
      throw new TypeError('"size" argument must be of type number');
    if (ne < 0)
      throw new RangeError('The value "' + ne + '" is invalid for option "size"');
  }
  function E(ne, W, te) {
    return m(ne), ne <= 0 ? s(ne) : W !== void 0 ? typeof te == "string" ? s(ne).fill(W, te) : s(ne).fill(W) : s(ne);
  }
  i.alloc = function(ne, W, te) {
    return E(ne, W, te);
  };
  function v(ne) {
    return m(ne), s(ne < 0 ? 0 : j(ne) | 0);
  }
  i.allocUnsafe = function(ne) {
    return v(ne);
  }, i.allocUnsafeSlow = function(ne) {
    return v(ne);
  };
  function b(ne, W) {
    if ((typeof W != "string" || W === "") && (W = "utf8"), !i.isEncoding(W))
      throw new TypeError("Unknown encoding: " + W);
    const te = N(ne, W) | 0;
    let pe = s(te);
    const Ee = pe.write(ne, W);
    return Ee !== te && (pe = pe.slice(0, Ee)), pe;
  }
  function h(ne) {
    const W = ne.length < 0 ? 0 : j(ne.length) | 0, te = s(W);
    for (let pe = 0; pe < W; pe += 1)
      te[pe] = ne[pe] & 255;
    return te;
  }
  function o(ne) {
    if (K(ne, f)) {
      const W = new f(ne);
      return S(W.buffer, W.byteOffset, W.byteLength);
    }
    return h(ne);
  }
  function S(ne, W, te) {
    if (W < 0 || ne.byteLength < W)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (ne.byteLength < W + (te || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let pe;
    return W === void 0 && te === void 0 ? pe = new f(ne) : te === void 0 ? pe = new f(ne, W) : pe = new f(ne, W, te), Object.setPrototypeOf(pe, i.prototype), pe;
  }
  function H(ne) {
    if (i.isBuffer(ne)) {
      const W = j(ne.length) | 0, te = s(W);
      return te.length === 0 || ne.copy(te, 0, 0, W), te;
    }
    if (ne.length !== void 0)
      return typeof ne.length != "number" || re(ne.length) ? s(0) : h(ne);
    if (ne.type === "Buffer" && Array.isArray(ne.data))
      return h(ne.data);
  }
  function j(ne) {
    if (ne >= g)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + g.toString(16) + " bytes");
    return ne | 0;
  }
  function J(ne) {
    return +ne != ne && (ne = 0), i.alloc(+ne);
  }
  i.isBuffer = function(W) {
    return W != null && W._isBuffer === !0 && W !== i.prototype;
  }, i.compare = function(W, te) {
    if (K(W, f) && (W = i.from(W, W.offset, W.byteLength)), K(te, f) && (te = i.from(te, te.offset, te.byteLength)), !i.isBuffer(W) || !i.isBuffer(te))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (W === te) return 0;
    let pe = W.length, Ee = te.length;
    for (let Ae = 0, Oe = Math.min(pe, Ee); Ae < Oe; ++Ae)
      if (W[Ae] !== te[Ae]) {
        pe = W[Ae], Ee = te[Ae];
        break;
      }
    return pe < Ee ? -1 : Ee < pe ? 1 : 0;
  }, i.isEncoding = function(W) {
    switch (String(W).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, i.concat = function(W, te) {
    if (!Array.isArray(W))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (W.length === 0)
      return i.alloc(0);
    let pe;
    if (te === void 0)
      for (te = 0, pe = 0; pe < W.length; ++pe)
        te += W[pe].length;
    const Ee = i.allocUnsafe(te);
    let Ae = 0;
    for (pe = 0; pe < W.length; ++pe) {
      let Oe = W[pe];
      if (K(Oe, f))
        Ae + Oe.length > Ee.length ? (i.isBuffer(Oe) || (Oe = i.from(Oe)), Oe.copy(Ee, Ae)) : f.prototype.set.call(
          Ee,
          Oe,
          Ae
        );
      else if (i.isBuffer(Oe))
        Oe.copy(Ee, Ae);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      Ae += Oe.length;
    }
    return Ee;
  };
  function N(ne, W) {
    if (i.isBuffer(ne))
      return ne.length;
    if (n.isView(ne) || K(ne, n))
      return ne.byteLength;
    if (typeof ne != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof ne
      );
    const te = ne.length, pe = arguments.length > 2 && arguments[2] === !0;
    if (!pe && te === 0) return 0;
    let Ee = !1;
    for (; ; )
      switch (W) {
        case "ascii":
        case "latin1":
        case "binary":
          return te;
        case "utf8":
        case "utf-8":
          return x(ne).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return te * 2;
        case "hex":
          return te >>> 1;
        case "base64":
          return X(ne).length;
        default:
          if (Ee)
            return pe ? -1 : x(ne).length;
          W = ("" + W).toLowerCase(), Ee = !0;
      }
  }
  i.byteLength = N;
  function z(ne, W, te) {
    let pe = !1;
    if ((W === void 0 || W < 0) && (W = 0), W > this.length || ((te === void 0 || te > this.length) && (te = this.length), te <= 0) || (te >>>= 0, W >>>= 0, te <= W))
      return "";
    for (ne || (ne = "utf8"); ; )
      switch (ne) {
        case "hex":
          return Y(this, W, te);
        case "utf8":
        case "utf-8":
          return D(this, W, te);
        case "ascii":
          return oe(this, W, te);
        case "latin1":
        case "binary":
          return y(this, W, te);
        case "base64":
          return ae(this, W, te);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return he(this, W, te);
        default:
          if (pe) throw new TypeError("Unknown encoding: " + ne);
          ne = (ne + "").toLowerCase(), pe = !0;
      }
  }
  i.prototype._isBuffer = !0;
  function A(ne, W, te) {
    const pe = ne[W];
    ne[W] = ne[te], ne[te] = pe;
  }
  i.prototype.swap16 = function() {
    const W = this.length;
    if (W % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let te = 0; te < W; te += 2)
      A(this, te, te + 1);
    return this;
  }, i.prototype.swap32 = function() {
    const W = this.length;
    if (W % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let te = 0; te < W; te += 4)
      A(this, te, te + 3), A(this, te + 1, te + 2);
    return this;
  }, i.prototype.swap64 = function() {
    const W = this.length;
    if (W % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let te = 0; te < W; te += 8)
      A(this, te, te + 7), A(this, te + 1, te + 6), A(this, te + 2, te + 5), A(this, te + 3, te + 4);
    return this;
  }, i.prototype.toString = function() {
    const W = this.length;
    return W === 0 ? "" : arguments.length === 0 ? D(this, 0, W) : z.apply(this, arguments);
  }, i.prototype.toLocaleString = i.prototype.toString, i.prototype.equals = function(W) {
    if (!i.isBuffer(W)) throw new TypeError("Argument must be a Buffer");
    return this === W ? !0 : i.compare(this, W) === 0;
  }, i.prototype.inspect = function() {
    let W = "";
    const te = e.INSPECT_MAX_BYTES;
    return W = this.toString("hex", 0, te).replace(/(.{2})/g, "$1 ").trim(), this.length > te && (W += " ... "), "<Buffer " + W + ">";
  }, w && (i.prototype[w] = i.prototype.inspect), i.prototype.compare = function(W, te, pe, Ee, Ae) {
    if (K(W, f) && (W = i.from(W, W.offset, W.byteLength)), !i.isBuffer(W))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof W
      );
    if (te === void 0 && (te = 0), pe === void 0 && (pe = W ? W.length : 0), Ee === void 0 && (Ee = 0), Ae === void 0 && (Ae = this.length), te < 0 || pe > W.length || Ee < 0 || Ae > this.length)
      throw new RangeError("out of range index");
    if (Ee >= Ae && te >= pe)
      return 0;
    if (Ee >= Ae)
      return -1;
    if (te >= pe)
      return 1;
    if (te >>>= 0, pe >>>= 0, Ee >>>= 0, Ae >>>= 0, this === W) return 0;
    let Oe = Ae - Ee, Be = pe - te;
    const ke = Math.min(Oe, Be), Ne = this.slice(Ee, Ae), Ke = W.slice(te, pe);
    for (let Ce = 0; Ce < ke; ++Ce)
      if (Ne[Ce] !== Ke[Ce]) {
        Oe = Ne[Ce], Be = Ke[Ce];
        break;
      }
    return Oe < Be ? -1 : Be < Oe ? 1 : 0;
  };
  function q(ne, W, te, pe, Ee) {
    if (ne.length === 0) return -1;
    if (typeof te == "string" ? (pe = te, te = 0) : te > 2147483647 ? te = 2147483647 : te < -2147483648 && (te = -2147483648), te = +te, re(te) && (te = Ee ? 0 : ne.length - 1), te < 0 && (te = ne.length + te), te >= ne.length) {
      if (Ee) return -1;
      te = ne.length - 1;
    } else if (te < 0)
      if (Ee) te = 0;
      else return -1;
    if (typeof W == "string" && (W = i.from(W, pe)), i.isBuffer(W))
      return W.length === 0 ? -1 : _(ne, W, te, pe, Ee);
    if (typeof W == "number")
      return W = W & 255, typeof f.prototype.indexOf == "function" ? Ee ? f.prototype.indexOf.call(ne, W, te) : f.prototype.lastIndexOf.call(ne, W, te) : _(ne, [W], te, pe, Ee);
    throw new TypeError("val must be string, number or Buffer");
  }
  function _(ne, W, te, pe, Ee) {
    let Ae = 1, Oe = ne.length, Be = W.length;
    if (pe !== void 0 && (pe = String(pe).toLowerCase(), pe === "ucs2" || pe === "ucs-2" || pe === "utf16le" || pe === "utf-16le")) {
      if (ne.length < 2 || W.length < 2)
        return -1;
      Ae = 2, Oe /= 2, Be /= 2, te /= 2;
    }
    function ke(Ke, Ce) {
      return Ae === 1 ? Ke[Ce] : Ke.readUInt16BE(Ce * Ae);
    }
    let Ne;
    if (Ee) {
      let Ke = -1;
      for (Ne = te; Ne < Oe; Ne++)
        if (ke(ne, Ne) === ke(W, Ke === -1 ? 0 : Ne - Ke)) {
          if (Ke === -1 && (Ke = Ne), Ne - Ke + 1 === Be) return Ke * Ae;
        } else
          Ke !== -1 && (Ne -= Ne - Ke), Ke = -1;
    } else
      for (te + Be > Oe && (te = Oe - Be), Ne = te; Ne >= 0; Ne--) {
        let Ke = !0;
        for (let Ce = 0; Ce < Be; Ce++)
          if (ke(ne, Ne + Ce) !== ke(W, Ce)) {
            Ke = !1;
            break;
          }
        if (Ke) return Ne;
      }
    return -1;
  }
  i.prototype.includes = function(W, te, pe) {
    return this.indexOf(W, te, pe) !== -1;
  }, i.prototype.indexOf = function(W, te, pe) {
    return q(this, W, te, pe, !0);
  }, i.prototype.lastIndexOf = function(W, te, pe) {
    return q(this, W, te, pe, !1);
  };
  function F(ne, W, te, pe) {
    te = Number(te) || 0;
    const Ee = ne.length - te;
    pe ? (pe = Number(pe), pe > Ee && (pe = Ee)) : pe = Ee;
    const Ae = W.length;
    pe > Ae / 2 && (pe = Ae / 2);
    let Oe;
    for (Oe = 0; Oe < pe; ++Oe) {
      const Be = parseInt(W.substr(Oe * 2, 2), 16);
      if (re(Be)) return Oe;
      ne[te + Oe] = Be;
    }
    return Oe;
  }
  function R(ne, W, te, pe) {
    return P(x(W, ne.length - te), ne, te, pe);
  }
  function V(ne, W, te, pe) {
    return P(O(W), ne, te, pe);
  }
  function fe(ne, W, te, pe) {
    return P(X(W), ne, te, pe);
  }
  function ue(ne, W, te, pe) {
    return P(L(W, ne.length - te), ne, te, pe);
  }
  i.prototype.write = function(W, te, pe, Ee) {
    if (te === void 0)
      Ee = "utf8", pe = this.length, te = 0;
    else if (pe === void 0 && typeof te == "string")
      Ee = te, pe = this.length, te = 0;
    else if (isFinite(te))
      te = te >>> 0, isFinite(pe) ? (pe = pe >>> 0, Ee === void 0 && (Ee = "utf8")) : (Ee = pe, pe = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    const Ae = this.length - te;
    if ((pe === void 0 || pe > Ae) && (pe = Ae), W.length > 0 && (pe < 0 || te < 0) || te > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    Ee || (Ee = "utf8");
    let Oe = !1;
    for (; ; )
      switch (Ee) {
        case "hex":
          return F(this, W, te, pe);
        case "utf8":
        case "utf-8":
          return R(this, W, te, pe);
        case "ascii":
        case "latin1":
        case "binary":
          return V(this, W, te, pe);
        case "base64":
          return fe(this, W, te, pe);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ue(this, W, te, pe);
        default:
          if (Oe) throw new TypeError("Unknown encoding: " + Ee);
          Ee = ("" + Ee).toLowerCase(), Oe = !0;
      }
  }, i.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function ae(ne, W, te) {
    return W === 0 && te === ne.length ? c.fromByteArray(ne) : c.fromByteArray(ne.slice(W, te));
  }
  function D(ne, W, te) {
    te = Math.min(ne.length, te);
    const pe = [];
    let Ee = W;
    for (; Ee < te; ) {
      const Ae = ne[Ee];
      let Oe = null, Be = Ae > 239 ? 4 : Ae > 223 ? 3 : Ae > 191 ? 2 : 1;
      if (Ee + Be <= te) {
        let ke, Ne, Ke, Ce;
        switch (Be) {
          case 1:
            Ae < 128 && (Oe = Ae);
            break;
          case 2:
            ke = ne[Ee + 1], (ke & 192) === 128 && (Ce = (Ae & 31) << 6 | ke & 63, Ce > 127 && (Oe = Ce));
            break;
          case 3:
            ke = ne[Ee + 1], Ne = ne[Ee + 2], (ke & 192) === 128 && (Ne & 192) === 128 && (Ce = (Ae & 15) << 12 | (ke & 63) << 6 | Ne & 63, Ce > 2047 && (Ce < 55296 || Ce > 57343) && (Oe = Ce));
            break;
          case 4:
            ke = ne[Ee + 1], Ne = ne[Ee + 2], Ke = ne[Ee + 3], (ke & 192) === 128 && (Ne & 192) === 128 && (Ke & 192) === 128 && (Ce = (Ae & 15) << 18 | (ke & 63) << 12 | (Ne & 63) << 6 | Ke & 63, Ce > 65535 && Ce < 1114112 && (Oe = Ce));
        }
      }
      Oe === null ? (Oe = 65533, Be = 1) : Oe > 65535 && (Oe -= 65536, pe.push(Oe >>> 10 & 1023 | 55296), Oe = 56320 | Oe & 1023), pe.push(Oe), Ee += Be;
    }
    return Z(pe);
  }
  const Q = 4096;
  function Z(ne) {
    const W = ne.length;
    if (W <= Q)
      return String.fromCharCode.apply(String, ne);
    let te = "", pe = 0;
    for (; pe < W; )
      te += String.fromCharCode.apply(
        String,
        ne.slice(pe, pe += Q)
      );
    return te;
  }
  function oe(ne, W, te) {
    let pe = "";
    te = Math.min(ne.length, te);
    for (let Ee = W; Ee < te; ++Ee)
      pe += String.fromCharCode(ne[Ee] & 127);
    return pe;
  }
  function y(ne, W, te) {
    let pe = "";
    te = Math.min(ne.length, te);
    for (let Ee = W; Ee < te; ++Ee)
      pe += String.fromCharCode(ne[Ee]);
    return pe;
  }
  function Y(ne, W, te) {
    const pe = ne.length;
    (!W || W < 0) && (W = 0), (!te || te < 0 || te > pe) && (te = pe);
    let Ee = "";
    for (let Ae = W; Ae < te; ++Ae)
      Ee += ce[ne[Ae]];
    return Ee;
  }
  function he(ne, W, te) {
    const pe = ne.slice(W, te);
    let Ee = "";
    for (let Ae = 0; Ae < pe.length - 1; Ae += 2)
      Ee += String.fromCharCode(pe[Ae] + pe[Ae + 1] * 256);
    return Ee;
  }
  i.prototype.slice = function(W, te) {
    const pe = this.length;
    W = ~~W, te = te === void 0 ? pe : ~~te, W < 0 ? (W += pe, W < 0 && (W = 0)) : W > pe && (W = pe), te < 0 ? (te += pe, te < 0 && (te = 0)) : te > pe && (te = pe), te < W && (te = W);
    const Ee = this.subarray(W, te);
    return Object.setPrototypeOf(Ee, i.prototype), Ee;
  };
  function be(ne, W, te) {
    if (ne % 1 !== 0 || ne < 0) throw new RangeError("offset is not uint");
    if (ne + W > te) throw new RangeError("Trying to access beyond buffer length");
  }
  i.prototype.readUintLE = i.prototype.readUIntLE = function(W, te, pe) {
    W = W >>> 0, te = te >>> 0, pe || be(W, te, this.length);
    let Ee = this[W], Ae = 1, Oe = 0;
    for (; ++Oe < te && (Ae *= 256); )
      Ee += this[W + Oe] * Ae;
    return Ee;
  }, i.prototype.readUintBE = i.prototype.readUIntBE = function(W, te, pe) {
    W = W >>> 0, te = te >>> 0, pe || be(W, te, this.length);
    let Ee = this[W + --te], Ae = 1;
    for (; te > 0 && (Ae *= 256); )
      Ee += this[W + --te] * Ae;
    return Ee;
  }, i.prototype.readUint8 = i.prototype.readUInt8 = function(W, te) {
    return W = W >>> 0, te || be(W, 1, this.length), this[W];
  }, i.prototype.readUint16LE = i.prototype.readUInt16LE = function(W, te) {
    return W = W >>> 0, te || be(W, 2, this.length), this[W] | this[W + 1] << 8;
  }, i.prototype.readUint16BE = i.prototype.readUInt16BE = function(W, te) {
    return W = W >>> 0, te || be(W, 2, this.length), this[W] << 8 | this[W + 1];
  }, i.prototype.readUint32LE = i.prototype.readUInt32LE = function(W, te) {
    return W = W >>> 0, te || be(W, 4, this.length), (this[W] | this[W + 1] << 8 | this[W + 2] << 16) + this[W + 3] * 16777216;
  }, i.prototype.readUint32BE = i.prototype.readUInt32BE = function(W, te) {
    return W = W >>> 0, te || be(W, 4, this.length), this[W] * 16777216 + (this[W + 1] << 16 | this[W + 2] << 8 | this[W + 3]);
  }, i.prototype.readBigUInt64LE = le(function(W) {
    W = W >>> 0, T(W, "offset");
    const te = this[W], pe = this[W + 7];
    (te === void 0 || pe === void 0) && M(W, this.length - 8);
    const Ee = te + this[++W] * 2 ** 8 + this[++W] * 2 ** 16 + this[++W] * 2 ** 24, Ae = this[++W] + this[++W] * 2 ** 8 + this[++W] * 2 ** 16 + pe * 2 ** 24;
    return BigInt(Ee) + (BigInt(Ae) << BigInt(32));
  }), i.prototype.readBigUInt64BE = le(function(W) {
    W = W >>> 0, T(W, "offset");
    const te = this[W], pe = this[W + 7];
    (te === void 0 || pe === void 0) && M(W, this.length - 8);
    const Ee = te * 2 ** 24 + this[++W] * 2 ** 16 + this[++W] * 2 ** 8 + this[++W], Ae = this[++W] * 2 ** 24 + this[++W] * 2 ** 16 + this[++W] * 2 ** 8 + pe;
    return (BigInt(Ee) << BigInt(32)) + BigInt(Ae);
  }), i.prototype.readIntLE = function(W, te, pe) {
    W = W >>> 0, te = te >>> 0, pe || be(W, te, this.length);
    let Ee = this[W], Ae = 1, Oe = 0;
    for (; ++Oe < te && (Ae *= 256); )
      Ee += this[W + Oe] * Ae;
    return Ae *= 128, Ee >= Ae && (Ee -= Math.pow(2, 8 * te)), Ee;
  }, i.prototype.readIntBE = function(W, te, pe) {
    W = W >>> 0, te = te >>> 0, pe || be(W, te, this.length);
    let Ee = te, Ae = 1, Oe = this[W + --Ee];
    for (; Ee > 0 && (Ae *= 256); )
      Oe += this[W + --Ee] * Ae;
    return Ae *= 128, Oe >= Ae && (Oe -= Math.pow(2, 8 * te)), Oe;
  }, i.prototype.readInt8 = function(W, te) {
    return W = W >>> 0, te || be(W, 1, this.length), this[W] & 128 ? (255 - this[W] + 1) * -1 : this[W];
  }, i.prototype.readInt16LE = function(W, te) {
    W = W >>> 0, te || be(W, 2, this.length);
    const pe = this[W] | this[W + 1] << 8;
    return pe & 32768 ? pe | 4294901760 : pe;
  }, i.prototype.readInt16BE = function(W, te) {
    W = W >>> 0, te || be(W, 2, this.length);
    const pe = this[W + 1] | this[W] << 8;
    return pe & 32768 ? pe | 4294901760 : pe;
  }, i.prototype.readInt32LE = function(W, te) {
    return W = W >>> 0, te || be(W, 4, this.length), this[W] | this[W + 1] << 8 | this[W + 2] << 16 | this[W + 3] << 24;
  }, i.prototype.readInt32BE = function(W, te) {
    return W = W >>> 0, te || be(W, 4, this.length), this[W] << 24 | this[W + 1] << 16 | this[W + 2] << 8 | this[W + 3];
  }, i.prototype.readBigInt64LE = le(function(W) {
    W = W >>> 0, T(W, "offset");
    const te = this[W], pe = this[W + 7];
    (te === void 0 || pe === void 0) && M(W, this.length - 8);
    const Ee = this[W + 4] + this[W + 5] * 2 ** 8 + this[W + 6] * 2 ** 16 + (pe << 24);
    return (BigInt(Ee) << BigInt(32)) + BigInt(te + this[++W] * 2 ** 8 + this[++W] * 2 ** 16 + this[++W] * 2 ** 24);
  }), i.prototype.readBigInt64BE = le(function(W) {
    W = W >>> 0, T(W, "offset");
    const te = this[W], pe = this[W + 7];
    (te === void 0 || pe === void 0) && M(W, this.length - 8);
    const Ee = (te << 24) + // Overflow
    this[++W] * 2 ** 16 + this[++W] * 2 ** 8 + this[++W];
    return (BigInt(Ee) << BigInt(32)) + BigInt(this[++W] * 2 ** 24 + this[++W] * 2 ** 16 + this[++W] * 2 ** 8 + pe);
  }), i.prototype.readFloatLE = function(W, te) {
    return W = W >>> 0, te || be(W, 4, this.length), d.read(this, W, !0, 23, 4);
  }, i.prototype.readFloatBE = function(W, te) {
    return W = W >>> 0, te || be(W, 4, this.length), d.read(this, W, !1, 23, 4);
  }, i.prototype.readDoubleLE = function(W, te) {
    return W = W >>> 0, te || be(W, 8, this.length), d.read(this, W, !0, 52, 8);
  }, i.prototype.readDoubleBE = function(W, te) {
    return W = W >>> 0, te || be(W, 8, this.length), d.read(this, W, !1, 52, 8);
  };
  function xe(ne, W, te, pe, Ee, Ae) {
    if (!i.isBuffer(ne)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (W > Ee || W < Ae) throw new RangeError('"value" argument is out of bounds');
    if (te + pe > ne.length) throw new RangeError("Index out of range");
  }
  i.prototype.writeUintLE = i.prototype.writeUIntLE = function(W, te, pe, Ee) {
    if (W = +W, te = te >>> 0, pe = pe >>> 0, !Ee) {
      const Be = Math.pow(2, 8 * pe) - 1;
      xe(this, W, te, pe, Be, 0);
    }
    let Ae = 1, Oe = 0;
    for (this[te] = W & 255; ++Oe < pe && (Ae *= 256); )
      this[te + Oe] = W / Ae & 255;
    return te + pe;
  }, i.prototype.writeUintBE = i.prototype.writeUIntBE = function(W, te, pe, Ee) {
    if (W = +W, te = te >>> 0, pe = pe >>> 0, !Ee) {
      const Be = Math.pow(2, 8 * pe) - 1;
      xe(this, W, te, pe, Be, 0);
    }
    let Ae = pe - 1, Oe = 1;
    for (this[te + Ae] = W & 255; --Ae >= 0 && (Oe *= 256); )
      this[te + Ae] = W / Oe & 255;
    return te + pe;
  }, i.prototype.writeUint8 = i.prototype.writeUInt8 = function(W, te, pe) {
    return W = +W, te = te >>> 0, pe || xe(this, W, te, 1, 255, 0), this[te] = W & 255, te + 1;
  }, i.prototype.writeUint16LE = i.prototype.writeUInt16LE = function(W, te, pe) {
    return W = +W, te = te >>> 0, pe || xe(this, W, te, 2, 65535, 0), this[te] = W & 255, this[te + 1] = W >>> 8, te + 2;
  }, i.prototype.writeUint16BE = i.prototype.writeUInt16BE = function(W, te, pe) {
    return W = +W, te = te >>> 0, pe || xe(this, W, te, 2, 65535, 0), this[te] = W >>> 8, this[te + 1] = W & 255, te + 2;
  }, i.prototype.writeUint32LE = i.prototype.writeUInt32LE = function(W, te, pe) {
    return W = +W, te = te >>> 0, pe || xe(this, W, te, 4, 4294967295, 0), this[te + 3] = W >>> 24, this[te + 2] = W >>> 16, this[te + 1] = W >>> 8, this[te] = W & 255, te + 4;
  }, i.prototype.writeUint32BE = i.prototype.writeUInt32BE = function(W, te, pe) {
    return W = +W, te = te >>> 0, pe || xe(this, W, te, 4, 4294967295, 0), this[te] = W >>> 24, this[te + 1] = W >>> 16, this[te + 2] = W >>> 8, this[te + 3] = W & 255, te + 4;
  };
  function Ie(ne, W, te, pe, Ee) {
    G(W, pe, Ee, ne, te, 7);
    let Ae = Number(W & BigInt(4294967295));
    ne[te++] = Ae, Ae = Ae >> 8, ne[te++] = Ae, Ae = Ae >> 8, ne[te++] = Ae, Ae = Ae >> 8, ne[te++] = Ae;
    let Oe = Number(W >> BigInt(32) & BigInt(4294967295));
    return ne[te++] = Oe, Oe = Oe >> 8, ne[te++] = Oe, Oe = Oe >> 8, ne[te++] = Oe, Oe = Oe >> 8, ne[te++] = Oe, te;
  }
  function ve(ne, W, te, pe, Ee) {
    G(W, pe, Ee, ne, te, 7);
    let Ae = Number(W & BigInt(4294967295));
    ne[te + 7] = Ae, Ae = Ae >> 8, ne[te + 6] = Ae, Ae = Ae >> 8, ne[te + 5] = Ae, Ae = Ae >> 8, ne[te + 4] = Ae;
    let Oe = Number(W >> BigInt(32) & BigInt(4294967295));
    return ne[te + 3] = Oe, Oe = Oe >> 8, ne[te + 2] = Oe, Oe = Oe >> 8, ne[te + 1] = Oe, Oe = Oe >> 8, ne[te] = Oe, te + 8;
  }
  i.prototype.writeBigUInt64LE = le(function(W, te = 0) {
    return Ie(this, W, te, BigInt(0), BigInt("0xffffffffffffffff"));
  }), i.prototype.writeBigUInt64BE = le(function(W, te = 0) {
    return ve(this, W, te, BigInt(0), BigInt("0xffffffffffffffff"));
  }), i.prototype.writeIntLE = function(W, te, pe, Ee) {
    if (W = +W, te = te >>> 0, !Ee) {
      const ke = Math.pow(2, 8 * pe - 1);
      xe(this, W, te, pe, ke - 1, -ke);
    }
    let Ae = 0, Oe = 1, Be = 0;
    for (this[te] = W & 255; ++Ae < pe && (Oe *= 256); )
      W < 0 && Be === 0 && this[te + Ae - 1] !== 0 && (Be = 1), this[te + Ae] = (W / Oe >> 0) - Be & 255;
    return te + pe;
  }, i.prototype.writeIntBE = function(W, te, pe, Ee) {
    if (W = +W, te = te >>> 0, !Ee) {
      const ke = Math.pow(2, 8 * pe - 1);
      xe(this, W, te, pe, ke - 1, -ke);
    }
    let Ae = pe - 1, Oe = 1, Be = 0;
    for (this[te + Ae] = W & 255; --Ae >= 0 && (Oe *= 256); )
      W < 0 && Be === 0 && this[te + Ae + 1] !== 0 && (Be = 1), this[te + Ae] = (W / Oe >> 0) - Be & 255;
    return te + pe;
  }, i.prototype.writeInt8 = function(W, te, pe) {
    return W = +W, te = te >>> 0, pe || xe(this, W, te, 1, 127, -128), W < 0 && (W = 255 + W + 1), this[te] = W & 255, te + 1;
  }, i.prototype.writeInt16LE = function(W, te, pe) {
    return W = +W, te = te >>> 0, pe || xe(this, W, te, 2, 32767, -32768), this[te] = W & 255, this[te + 1] = W >>> 8, te + 2;
  }, i.prototype.writeInt16BE = function(W, te, pe) {
    return W = +W, te = te >>> 0, pe || xe(this, W, te, 2, 32767, -32768), this[te] = W >>> 8, this[te + 1] = W & 255, te + 2;
  }, i.prototype.writeInt32LE = function(W, te, pe) {
    return W = +W, te = te >>> 0, pe || xe(this, W, te, 4, 2147483647, -2147483648), this[te] = W & 255, this[te + 1] = W >>> 8, this[te + 2] = W >>> 16, this[te + 3] = W >>> 24, te + 4;
  }, i.prototype.writeInt32BE = function(W, te, pe) {
    return W = +W, te = te >>> 0, pe || xe(this, W, te, 4, 2147483647, -2147483648), W < 0 && (W = 4294967295 + W + 1), this[te] = W >>> 24, this[te + 1] = W >>> 16, this[te + 2] = W >>> 8, this[te + 3] = W & 255, te + 4;
  }, i.prototype.writeBigInt64LE = le(function(W, te = 0) {
    return Ie(this, W, te, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), i.prototype.writeBigInt64BE = le(function(W, te = 0) {
    return ve(this, W, te, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function C(ne, W, te, pe, Ee, Ae) {
    if (te + pe > ne.length) throw new RangeError("Index out of range");
    if (te < 0) throw new RangeError("Index out of range");
  }
  function I(ne, W, te, pe, Ee) {
    return W = +W, te = te >>> 0, Ee || C(ne, W, te, 4), d.write(ne, W, te, pe, 23, 4), te + 4;
  }
  i.prototype.writeFloatLE = function(W, te, pe) {
    return I(this, W, te, !0, pe);
  }, i.prototype.writeFloatBE = function(W, te, pe) {
    return I(this, W, te, !1, pe);
  };
  function se(ne, W, te, pe, Ee) {
    return W = +W, te = te >>> 0, Ee || C(ne, W, te, 8), d.write(ne, W, te, pe, 52, 8), te + 8;
  }
  i.prototype.writeDoubleLE = function(W, te, pe) {
    return se(this, W, te, !0, pe);
  }, i.prototype.writeDoubleBE = function(W, te, pe) {
    return se(this, W, te, !1, pe);
  }, i.prototype.copy = function(W, te, pe, Ee) {
    if (!i.isBuffer(W)) throw new TypeError("argument should be a Buffer");
    if (pe || (pe = 0), !Ee && Ee !== 0 && (Ee = this.length), te >= W.length && (te = W.length), te || (te = 0), Ee > 0 && Ee < pe && (Ee = pe), Ee === pe || W.length === 0 || this.length === 0) return 0;
    if (te < 0)
      throw new RangeError("targetStart out of bounds");
    if (pe < 0 || pe >= this.length) throw new RangeError("Index out of range");
    if (Ee < 0) throw new RangeError("sourceEnd out of bounds");
    Ee > this.length && (Ee = this.length), W.length - te < Ee - pe && (Ee = W.length - te + pe);
    const Ae = Ee - pe;
    return this === W && typeof f.prototype.copyWithin == "function" ? this.copyWithin(te, pe, Ee) : f.prototype.set.call(
      W,
      this.subarray(pe, Ee),
      te
    ), Ae;
  }, i.prototype.fill = function(W, te, pe, Ee) {
    if (typeof W == "string") {
      if (typeof te == "string" ? (Ee = te, te = 0, pe = this.length) : typeof pe == "string" && (Ee = pe, pe = this.length), Ee !== void 0 && typeof Ee != "string")
        throw new TypeError("encoding must be a string");
      if (typeof Ee == "string" && !i.isEncoding(Ee))
        throw new TypeError("Unknown encoding: " + Ee);
      if (W.length === 1) {
        const Oe = W.charCodeAt(0);
        (Ee === "utf8" && Oe < 128 || Ee === "latin1") && (W = Oe);
      }
    } else typeof W == "number" ? W = W & 255 : typeof W == "boolean" && (W = Number(W));
    if (te < 0 || this.length < te || this.length < pe)
      throw new RangeError("Out of range index");
    if (pe <= te)
      return this;
    te = te >>> 0, pe = pe === void 0 ? this.length : pe >>> 0, W || (W = 0);
    let Ae;
    if (typeof W == "number")
      for (Ae = te; Ae < pe; ++Ae)
        this[Ae] = W;
    else {
      const Oe = i.isBuffer(W) ? W : i.from(W, Ee), Be = Oe.length;
      if (Be === 0)
        throw new TypeError('The value "' + W + '" is invalid for argument "value"');
      for (Ae = 0; Ae < pe - te; ++Ae)
        this[Ae + te] = Oe[Ae % Be];
    }
    return this;
  };
  const t = {};
  function l(ne, W, te) {
    t[ne] = class extends te {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: W.apply(this, arguments),
          writable: !0,
          configurable: !0
        }), this.name = `${this.name} [${ne}]`, this.stack, delete this.name;
      }
      get code() {
        return ne;
      }
      set code(Ee) {
        Object.defineProperty(this, "code", {
          configurable: !0,
          enumerable: !0,
          value: Ee,
          writable: !0
        });
      }
      toString() {
        return `${this.name} [${ne}]: ${this.message}`;
      }
    };
  }
  l(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(ne) {
      return ne ? `${ne} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  ), l(
    "ERR_INVALID_ARG_TYPE",
    function(ne, W) {
      return `The "${ne}" argument must be of type number. Received type ${typeof W}`;
    },
    TypeError
  ), l(
    "ERR_OUT_OF_RANGE",
    function(ne, W, te) {
      let pe = `The value of "${ne}" is out of range.`, Ee = te;
      return Number.isInteger(te) && Math.abs(te) > 2 ** 32 ? Ee = B(String(te)) : typeof te == "bigint" && (Ee = String(te), (te > BigInt(2) ** BigInt(32) || te < -(BigInt(2) ** BigInt(32))) && (Ee = B(Ee)), Ee += "n"), pe += ` It must be ${W}. Received ${Ee}`, pe;
    },
    RangeError
  );
  function B(ne) {
    let W = "", te = ne.length;
    const pe = ne[0] === "-" ? 1 : 0;
    for (; te >= pe + 4; te -= 3)
      W = `_${ne.slice(te - 3, te)}${W}`;
    return `${ne.slice(0, te)}${W}`;
  }
  function U(ne, W, te) {
    T(W, "offset"), (ne[W] === void 0 || ne[W + te] === void 0) && M(W, ne.length - (te + 1));
  }
  function G(ne, W, te, pe, Ee, Ae) {
    if (ne > te || ne < W) {
      const Oe = typeof W == "bigint" ? "n" : "";
      let Be;
      throw W === 0 || W === BigInt(0) ? Be = `>= 0${Oe} and < 2${Oe} ** ${(Ae + 1) * 8}${Oe}` : Be = `>= -(2${Oe} ** ${(Ae + 1) * 8 - 1}${Oe}) and < 2 ** ${(Ae + 1) * 8 - 1}${Oe}`, new t.ERR_OUT_OF_RANGE("value", Be, ne);
    }
    U(pe, Ee, Ae);
  }
  function T(ne, W) {
    if (typeof ne != "number")
      throw new t.ERR_INVALID_ARG_TYPE(W, "number", ne);
  }
  function M(ne, W, te) {
    throw Math.floor(ne) !== ne ? (T(ne, te), new t.ERR_OUT_OF_RANGE("offset", "an integer", ne)) : W < 0 ? new t.ERR_BUFFER_OUT_OF_BOUNDS() : new t.ERR_OUT_OF_RANGE(
      "offset",
      `>= 0 and <= ${W}`,
      ne
    );
  }
  const $ = /[^+/0-9A-Za-z-_]/g;
  function r(ne) {
    if (ne = ne.split("=")[0], ne = ne.trim().replace($, ""), ne.length < 2) return "";
    for (; ne.length % 4 !== 0; )
      ne = ne + "=";
    return ne;
  }
  function x(ne, W) {
    W = W || 1 / 0;
    let te;
    const pe = ne.length;
    let Ee = null;
    const Ae = [];
    for (let Oe = 0; Oe < pe; ++Oe) {
      if (te = ne.charCodeAt(Oe), te > 55295 && te < 57344) {
        if (!Ee) {
          if (te > 56319) {
            (W -= 3) > -1 && Ae.push(239, 191, 189);
            continue;
          } else if (Oe + 1 === pe) {
            (W -= 3) > -1 && Ae.push(239, 191, 189);
            continue;
          }
          Ee = te;
          continue;
        }
        if (te < 56320) {
          (W -= 3) > -1 && Ae.push(239, 191, 189), Ee = te;
          continue;
        }
        te = (Ee - 55296 << 10 | te - 56320) + 65536;
      } else Ee && (W -= 3) > -1 && Ae.push(239, 191, 189);
      if (Ee = null, te < 128) {
        if ((W -= 1) < 0) break;
        Ae.push(te);
      } else if (te < 2048) {
        if ((W -= 2) < 0) break;
        Ae.push(
          te >> 6 | 192,
          te & 63 | 128
        );
      } else if (te < 65536) {
        if ((W -= 3) < 0) break;
        Ae.push(
          te >> 12 | 224,
          te >> 6 & 63 | 128,
          te & 63 | 128
        );
      } else if (te < 1114112) {
        if ((W -= 4) < 0) break;
        Ae.push(
          te >> 18 | 240,
          te >> 12 & 63 | 128,
          te >> 6 & 63 | 128,
          te & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return Ae;
  }
  function O(ne) {
    const W = [];
    for (let te = 0; te < ne.length; ++te)
      W.push(ne.charCodeAt(te) & 255);
    return W;
  }
  function L(ne, W) {
    let te, pe, Ee;
    const Ae = [];
    for (let Oe = 0; Oe < ne.length && !((W -= 2) < 0); ++Oe)
      te = ne.charCodeAt(Oe), pe = te >> 8, Ee = te % 256, Ae.push(Ee), Ae.push(pe);
    return Ae;
  }
  function X(ne) {
    return c.toByteArray(r(ne));
  }
  function P(ne, W, te, pe) {
    let Ee;
    for (Ee = 0; Ee < pe && !(Ee + te >= W.length || Ee >= ne.length); ++Ee)
      W[Ee + te] = ne[Ee];
    return Ee;
  }
  function K(ne, W) {
    return ne instanceof W || ne != null && ne.constructor != null && ne.constructor.name != null && ne.constructor.name === W.name;
  }
  function re(ne) {
    return ne !== ne;
  }
  const ce = function() {
    const ne = "0123456789abcdef", W = new Array(256);
    for (let te = 0; te < 16; ++te) {
      const pe = te * 16;
      for (let Ee = 0; Ee < 16; ++Ee)
        W[pe + Ee] = ne[te] + ne[Ee];
    }
    return W;
  }();
  function le(ne) {
    return typeof BigInt > "u" ? me : ne;
  }
  function me() {
    throw new Error("BigInt not supported");
  }
})(W3);
const k = W3.Buffer;
function N7(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Q3 = { exports: {} }, Ut = Q3.exports = {}, Br, Mr;
function mh() {
  throw new Error("setTimeout has not been defined");
}
function gh() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    typeof setTimeout == "function" ? Br = setTimeout : Br = mh;
  } catch {
    Br = mh;
  }
  try {
    typeof clearTimeout == "function" ? Mr = clearTimeout : Mr = gh;
  } catch {
    Mr = gh;
  }
})();
function e8(e) {
  if (Br === setTimeout)
    return setTimeout(e, 0);
  if ((Br === mh || !Br) && setTimeout)
    return Br = setTimeout, setTimeout(e, 0);
  try {
    return Br(e, 0);
  } catch {
    try {
      return Br.call(null, e, 0);
    } catch {
      return Br.call(this, e, 0);
    }
  }
}
function q7(e) {
  if (Mr === clearTimeout)
    return clearTimeout(e);
  if ((Mr === gh || !Mr) && clearTimeout)
    return Mr = clearTimeout, clearTimeout(e);
  try {
    return Mr(e);
  } catch {
    try {
      return Mr.call(null, e);
    } catch {
      return Mr.call(this, e);
    }
  }
}
var Zr = [], en = !1, Ai, _s = -1;
function z7() {
  !en || !Ai || (en = !1, Ai.length ? Zr = Ai.concat(Zr) : _s = -1, Zr.length && t8());
}
function t8() {
  if (!en) {
    var e = e8(z7);
    en = !0;
    for (var c = Zr.length; c; ) {
      for (Ai = Zr, Zr = []; ++_s < c; )
        Ai && Ai[_s].run();
      _s = -1, c = Zr.length;
    }
    Ai = null, en = !1, q7(e);
  }
}
Ut.nextTick = function(e) {
  var c = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var d = 1; d < arguments.length; d++)
      c[d - 1] = arguments[d];
  Zr.push(new r8(e, c)), Zr.length === 1 && !en && e8(t8);
};
function r8(e, c) {
  this.fun = e, this.array = c;
}
r8.prototype.run = function() {
  this.fun.apply(null, this.array);
};
Ut.title = "browser";
Ut.browser = !0;
Ut.env = {};
Ut.argv = [];
Ut.version = "";
Ut.versions = {};
function ti() {
}
Ut.on = ti;
Ut.addListener = ti;
Ut.once = ti;
Ut.off = ti;
Ut.removeListener = ti;
Ut.removeAllListeners = ti;
Ut.emit = ti;
Ut.prependListener = ti;
Ut.prependOnceListener = ti;
Ut.listeners = function(e) {
  return [];
};
Ut.binding = function(e) {
  throw new Error("process.binding is not supported");
};
Ut.cwd = function() {
  return "/";
};
Ut.chdir = function(e) {
  throw new Error("process.chdir is not supported");
};
Ut.umask = function() {
  return 0;
};
var T7 = Q3.exports;
const It = /* @__PURE__ */ N7(T7);
/*!
 * assert.js - assertions for javascript
 * Copyright (c) 2018, Christopher Jeffrey (MIT License).
 * https://github.com/chjj/bsert
 */
var _o, Ml;
function $e() {
  if (Ml) return _o;
  Ml = 1;
  class e extends Error {
    constructor(I) {
      typeof I == "string" && (I = { message: I }), (I === null || typeof I != "object") && (I = {});
      let se = null, t = "fail", l = !!I.generatedMessage, B = null;
      if (I.message != null && (se = H(I.message)), typeof I.operator == "string" && (t = I.operator), se == null) {
        if (t === "fail")
          se = "Assertion failed.";
        else {
          const U = S(I.actual), G = S(I.expected);
          se = `${U} ${t} ${G}`;
        }
        l = !0;
      }
      typeof I.stackStartFunction == "function" ? B = I.stackStartFunction : typeof I.stackStartFn == "function" && (B = I.stackStartFn), super(se), this.generatedMessage = l, this.code = "ERR_ASSERTION", this.actual = I.actual, this.expected = I.expected, this.operator = t, Object.defineProperty(this, "name", {
        value: "AssertionError [ERR_ASSERTION]",
        enumerable: !1,
        writable: !0,
        configurable: !0
      }), Error.captureStackTrace && B != null && Error.captureStackTrace(this, B), this.stack, this.name = "AssertionError";
    }
    toString() {
      return `${this.name} [${this.code}]: ${this.message}`;
    }
  }
  e.prototype.name = "AssertionError", e.prototype.type = "AssertionError";
  function c(C, I) {
    if (!C) {
      let se = !1;
      if (arguments.length === 0)
        I = "No value argument passed to `assert()`.", se = !0;
      else if (I == null)
        I = "Assertion failed.", se = !0;
      else if (Z(I))
        throw I;
      throw new e({
        message: I,
        actual: C,
        expected: !0,
        operator: "==",
        generatedMessage: se,
        stackStartFn: c
      });
    }
  }
  function d(C, I, se) {
    if (!Object.is(C, I))
      throw Z(se) ? se : new e({
        message: se,
        actual: C,
        expected: I,
        operator: "strictEqual",
        stackStartFn: d
      });
  }
  function w(C, I, se) {
    if (Object.is(C, I))
      throw Z(se) ? se : new e({
        message: se,
        actual: C,
        expected: I,
        operator: "notStrictEqual",
        stackStartFn: w
      });
  }
  function g(C) {
    let I = !1;
    throw Z(C) ? C : (C == null && (C = "Assertion failed.", I = !0), new e({
      message: C,
      actual: !1,
      expected: !0,
      operator: "fail",
      generatedMessage: I,
      stackStartFn: g
    }));
  }
  function f(C, I, se) {
    typeof I == "string" && (se = I, I = void 0);
    let t = !1, l = null;
    h(typeof C == "function", "func", "function");
    try {
      C();
    } catch (B) {
      t = !0, l = B;
    }
    if (!t) {
      let B = !1;
      throw se == null && (se = "Missing expected exception.", B = !0), new e({
        message: se,
        actual: void 0,
        expected: I,
        operator: "throws",
        generatedMessage: B,
        stackStartFn: f
      });
    }
    if (!J(l, I, se, f))
      throw l;
  }
  function n(C, I, se) {
    typeof I == "string" && (se = I, I = void 0);
    let t = !1, l = null;
    h(typeof C == "function", "func", "function");
    try {
      C();
    } catch (B) {
      t = !0, l = B;
    }
    if (t) {
      if (J(l, I, se, n)) {
        let B = !1;
        throw se == null && (se = "Got unwanted exception.", B = !0), new e({
          message: se,
          actual: l,
          expected: I,
          operator: "doesNotThrow",
          generatedMessage: B,
          stackStartFn: n
        });
      }
      throw l;
    }
  }
  async function u(C, I, se) {
    typeof I == "string" && (se = I, I = void 0);
    let t = !1, l = null;
    typeof C != "function" && h(Y(C), "func", "promise");
    try {
      Y(C) ? await C : await C();
    } catch (B) {
      t = !0, l = B;
    }
    if (!t) {
      let B = !1;
      throw se == null && (se = "Missing expected rejection.", B = !0), new e({
        message: se,
        actual: void 0,
        expected: I,
        operator: "rejects",
        generatedMessage: B,
        stackStartFn: u
      });
    }
    if (!J(l, I, se, u))
      throw l;
  }
  async function a(C, I, se) {
    typeof I == "string" && (se = I, I = void 0);
    let t = !1, l = null;
    typeof C != "function" && h(Y(C), "func", "promise");
    try {
      Y(C) ? await C : await C();
    } catch (B) {
      t = !0, l = B;
    }
    if (t) {
      if (J(l, I, se, a)) {
        let B = !1;
        throw se == null && (se = "Got unwanted rejection.", B = !0), new e({
          message: se,
          actual: void 0,
          expected: I,
          operator: "doesNotReject",
          generatedMessage: B,
          stackStartFn: a
        });
      }
      throw l;
    }
  }
  function s(C) {
    if (C != null) {
      let I = "ifError got unwanted exception: ";
      throw typeof C == "object" && typeof C.message == "string" ? C.message.length === 0 && C.constructor ? I += C.constructor.name : I += C.message : I += S(C), new e({
        message: I,
        actual: C,
        expected: null,
        operator: "ifError",
        generatedMessage: !0,
        stackStartFn: s
      });
    }
  }
  function i(C, I, se) {
    N(C, I, se, i, !0);
  }
  function p(C, I, se) {
    N(C, I, se, p, !1);
  }
  function m(C, I, se) {
    if (!z(C, I, !1))
      throw Z(se) ? se : new e({
        message: se,
        actual: C,
        expected: I,
        operator: "deepStrictEqual",
        stackStartFn: m
      });
  }
  function E(C, I, se) {
    if (z(C, I, !0))
      throw Z(se) ? se : new e({
        message: se,
        actual: C,
        expected: I,
        operator: "notDeepStrictEqual",
        stackStartFn: E
      });
  }
  function v(C, I, se, t) {
    if (Ie(se) || (t = se, se = null), se == null && (se = "hex"), I = ve(C, I, se), h(D(C), "actual", "buffer"), h(D(I), "expected", "buffer"), C !== I && !C.equals(I))
      throw Z(t) ? t : new e({
        message: t,
        actual: C.toString(se),
        expected: I.toString(se),
        operator: "bufferEqual",
        stackStartFn: v
      });
  }
  function b(C, I, se, t) {
    if (Ie(se) || (t = se, se = null), se == null && (se = "hex"), I = ve(C, I, se), h(D(C), "actual", "buffer"), h(D(I), "expected", "buffer"), C === I || C.equals(I))
      throw Z(t) ? t : new e({
        message: t,
        actual: C.toString(se),
        expected: I.toString(se),
        operator: "notBufferEqual",
        stackStartFn: b
      });
  }
  function h(C, I, se) {
    if (!C) {
      let t;
      I == null ? t = "Invalid type for parameter." : se == null ? t = `Invalid type for "${I}".` : t = `"${I}" must be a(n) ${se}.`;
      const l = new TypeError(t);
      throw Error.captureStackTrace && Error.captureStackTrace(l, h), l;
    }
  }
  function o(C, I) {
    if (!C) {
      const se = I != null ? `"${I}" is out of range.` : "Parameter is out of range.", t = new RangeError(se);
      throw Error.captureStackTrace && Error.captureStackTrace(t, o), t;
    }
  }
  function S(C) {
    switch (typeof C) {
      case "undefined":
        return "undefined";
      case "object":
        return C === null ? "null" : `[${V(C)}]`;
      case "boolean":
        return `${C}`;
      case "number":
        return `${C}`;
      case "string":
        return C.length > 80 && (C = `${C.substring(0, 77)}...`), JSON.stringify(C);
      case "symbol":
        return j(C);
      case "function":
        return `[${fe(C)}]`;
      case "bigint":
        return `${C}n`;
      default:
        return `[${typeof C}]`;
    }
  }
  function H(C) {
    return typeof C == "string" ? C : Z(C) ? j(C) : S(C);
  }
  function j(C) {
    try {
      return String(C);
    } catch {
      return "Object";
    }
  }
  function J(C, I, se, t) {
    if (I == null)
      return !0;
    if (he(I))
      return I.test(C);
    if (typeof I != "function") {
      if (t === n || t === a)
        throw new TypeError('"expected" must not be an object.');
      if (typeof I != "object")
        throw new TypeError('"expected" must be an object.');
      let l = !1;
      if (se == null && (se = `Missing expected ${t === u ? "rejection" : "exception"}.`, l = !0), C == null || typeof C != "object")
        throw new e({
          actual: C,
          expected: I,
          message: se,
          operator: t.name,
          generatedMessage: l,
          stackStartFn: t
        });
      const B = Object.keys(I);
      if (Z(I) && B.push("name", "message"), B.length === 0)
        throw new TypeError('"expected" may not be an empty object.');
      for (const U of B) {
        const G = I[U], T = C[U];
        if (!(typeof T == "string" && he(G) && G.test(T)) && !(U in C && z(T, G, !1)))
          throw new e({
            actual: C,
            expected: I,
            message: se,
            operator: t.name,
            generatedMessage: l,
            stackStartFn: t
          });
      }
      return !0;
    }
    return I.prototype !== void 0 && C instanceof I ? !0 : Error.isPrototypeOf(I) ? !1 : I.call({}, C) === !0;
  }
  function N(C, I, se, t, l) {
    if (h(typeof C == "string", "string", "string"), h(he(I), "regexp", "RegExp"), I.test(C) !== l) {
      if (Z(se))
        throw se;
      let B = !1;
      throw se == null && (se = `The input ${l ? "did" : "was expected to"} not match the regular expression ${I}. Input:

${S(C)}
`, B = !0), new e({
        actual: C,
        expected: I,
        message: se,
        operator: t.name,
        generatedMessage: B,
        stackStartFn: t
      });
    }
  }
  function z(C, I, se) {
    try {
      return A(C, I, null);
    } catch {
      return se;
    }
  }
  function A(C, I, se) {
    if (Object.is(C, I))
      return !0;
    if (!y(C) || !y(I) || F(C) !== F(I) || Object.getPrototypeOf(C) !== Object.getPrototypeOf(I))
      return !1;
    if (D(C) && D(I))
      return C.equals(I);
    if (Q(C))
      return Object.is(C.getTime(), I.getTime());
    if (he(C))
      return C.source === I.source && C.flags === I.flags;
    if (Z(C) && C.message !== I.message)
      return !1;
    if (ae(C) && (C = new Uint8Array(C), I = new Uint8Array(I)), xe(C) && !D(C)) {
      if (D(I))
        return !1;
      const l = new Uint8Array(C.buffer, C.byteOffset, C.byteLength), B = new Uint8Array(I.buffer, I.byteOffset, I.byteLength);
      if (l.length !== B.length)
        return !1;
      for (let U = 0; U < l.length; U++)
        if (l[U] !== B[U])
          return !1;
      return !0;
    }
    if (be(C))
      return C.size !== I.size ? !1 : (/* @__PURE__ */ new Set([...C, ...I])).size === C.size;
    if (!se)
      se = {
        a: /* @__PURE__ */ new Map(),
        b: /* @__PURE__ */ new Map(),
        p: 0
      };
    else {
      const l = se.a.get(C);
      if (l != null) {
        const B = se.b.get(I);
        if (B != null)
          return l === B;
      }
      se.p += 1;
    }
    se.a.set(C, se.p), se.b.set(I, se.p);
    const t = q(C, I, se);
    return se.a.delete(C), se.b.delete(I), t;
  }
  function q(C, I, se) {
    if (oe(C)) {
      if (C.size !== I.size)
        return !1;
      const U = /* @__PURE__ */ new Set([...C.keys(), ...I.keys()]);
      if (U.size !== C.size)
        return !1;
      for (const G of U)
        if (!A(C.get(G), I.get(G), se))
          return !1;
      return !0;
    }
    if (ue(C)) {
      if (C.length !== I.length)
        return !1;
      for (let U = 0; U < C.length; U++)
        if (!A(C[U], I[U], se))
          return !1;
      return !0;
    }
    const t = _(C), l = _(I);
    if (t.length !== l.length)
      return !1;
    const B = /* @__PURE__ */ new Set([...t, ...l]);
    if (B.size !== t.length)
      return !1;
    for (const U of B)
      if (!A(C[U], I[U], se))
        return !1;
    return !0;
  }
  function _(C) {
    const I = Object.keys(C);
    if (!Object.getOwnPropertySymbols || !Object.getOwnPropertyDescriptor)
      return I;
    const se = Object.getOwnPropertySymbols(C);
    for (const t of se) {
      const l = Object.getOwnPropertyDescriptor(C, t);
      l && l.enumerable && I.push(t);
    }
    return I;
  }
  function F(C) {
    if (C === void 0)
      return "[object Undefined]";
    if (C === null)
      return "[object Null]";
    try {
      return Object.prototype.toString.call(C);
    } catch {
      return "[object Object]";
    }
  }
  function R(C) {
    return F(C).slice(8, -1);
  }
  function V(C) {
    const I = R(C);
    if (C == null || I !== "Object" && I !== "Error")
      return I;
    let se, t;
    try {
      se = C.constructor;
    } catch {
    }
    if (se == null)
      return I;
    try {
      t = se.name;
    } catch {
      return I;
    }
    return typeof t != "string" || t.length === 0 ? I : t;
  }
  function fe(C) {
    let I;
    try {
      I = C.name;
    } catch {
    }
    return typeof I != "string" || I.length === 0 ? "Function" : `Function: ${I}`;
  }
  function ue(C) {
    return Array.isArray(C);
  }
  function ae(C) {
    return C instanceof ArrayBuffer;
  }
  function D(C) {
    return y(C) && typeof C.writeUInt32LE == "function" && typeof C.equals == "function";
  }
  function Q(C) {
    return C instanceof Date;
  }
  function Z(C) {
    return C instanceof Error;
  }
  function oe(C) {
    return C instanceof Map;
  }
  function y(C) {
    return C && typeof C == "object";
  }
  function Y(C) {
    return C instanceof Promise;
  }
  function he(C) {
    return C instanceof RegExp;
  }
  function be(C) {
    return C instanceof Set;
  }
  function xe(C) {
    return ArrayBuffer.isView(C);
  }
  function Ie(C) {
    if (typeof C != "string" || C.length > 9)
      return !1;
    switch (C.toLowerCase()) {
      case "ascii":
      case "binary":
      case "base64":
      case "base64url":
      case "hex":
      case "latin1":
      case "ucs2":
      case "utf8":
      case "utf16le":
      case "ucs-2":
      case "utf-8":
      case "utf-16le":
        return !0;
    }
    return !1;
  }
  function ve(C, I, se) {
    if (typeof I == "string") {
      if (!D(C))
        return null;
      const { constructor: t } = C;
      if (!t || typeof t.from != "function" || !Ie(se))
        return null;
      const l = t.from(I, se);
      return se.length === 3 && l.length * 2 !== I.length ? null : l;
    }
    return I;
  }
  return c.AssertionError = e, c.assert = c, c.strict = c, c.ok = c, c.equal = d, c.notEqual = w, c.strictEqual = d, c.notStrictEqual = w, c.fail = g, c.throws = f, c.doesNotThrow = n, c.rejects = u, c.doesNotReject = a, c.ifError = s, c.match = i, c.doesNotMatch = p, c.deepEqual = m, c.notDeepEqual = E, c.deepStrictEqual = m, c.notDeepStrictEqual = E, c.bufferEqual = v, c.notBufferEqual = b, c.enforce = h, c.range = o, _o = c, _o;
}
var C7 = $e();
const nt = /* @__PURE__ */ Cr(C7);
var ze = {}, Ro = {}, Nl;
function i8() {
  return Nl || (Nl = 1, Ro.custom = "inspect"), Ro;
}
var Fe = {};
/*!
 * enforce.js - type enforcement for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var Po, ql;
function fn() {
  if (ql) return Po;
  ql = 1;
  function e(c, d, w) {
    if (!c) {
      const g = new TypeError(`'${d}' must be a(n) ${w}.`);
      throw Error.captureStackTrace && Error.captureStackTrace(g, e), g;
    }
  }
  return Po = e, Po;
}
/*!
 * error.js - encoding error for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var ko, zl;
function Ln() {
  if (zl) return ko;
  zl = 1;
  class e extends Error {
    /**
     * Create an encoding error.
     * @constructor
     * @param {Number} offset
     * @param {String} reason
     */
    constructor(d, w, g) {
      super(), this.type = "EncodingError", this.name = "EncodingError", this.code = "ERR_ENCODING", this.message = `${w} (offset=${d}).`, Error.captureStackTrace && Error.captureStackTrace(this, g || e);
    }
  }
  return ko = e, ko;
}
var Tl;
function zs() {
  if (Tl) return Fe;
  Tl = 1;
  const e = fn(), c = Ln(), d = 1 / 4294967296, { MAX_SAFE_INTEGER: w } = Number, g = new Float32Array(1), f = new Uint8Array(g.buffer), n = new Float64Array(1), u = new Uint8Array(n.buffer);
  g[0] = -1;
  const a = f[3] === 0;
  function s(ge, ie, de) {
    switch (de) {
      case 8:
        return i(ge, ie);
      case 7:
        return p(ge, ie);
      case 6:
        return m(ge, ie);
      case 5:
        return E(ge, ie);
      case 4:
        return v(ge, ie);
      case 3:
        return b(ge, ie);
      case 2:
        return h(ge, ie);
      case 1:
        return o(ge, ie);
      default:
        throw new c(ie, "Invalid read length");
    }
  }
  function i(ge, ie) {
    const de = v(ge, ie + 4), Se = v(ge, ie);
    return Ct((de & 4292870144) === 0, ie, "Number exceeds 2^53-1"), de * 4294967296 + Se;
  }
  function p(ge, ie) {
    const de = b(ge, ie + 4), Se = v(ge, ie);
    return Ct((de & 4292870144) === 0, ie, "Number exceeds 2^53-1"), de * 4294967296 + Se;
  }
  function m(ge, ie) {
    return ge[ie++] + ge[ie++] * 256 + ge[ie++] * 65536 + ge[ie++] * 16777216 + ge[ie++] * 4294967296 + ge[ie] * 1099511627776;
  }
  function E(ge, ie) {
    return ge[ie++] + ge[ie++] * 256 + ge[ie++] * 65536 + ge[ie++] * 16777216 + ge[ie] * 4294967296;
  }
  function v(ge, ie) {
    return ge[ie++] + ge[ie++] * 256 + ge[ie++] * 65536 + ge[ie] * 16777216;
  }
  function b(ge, ie) {
    return ge[ie++] + ge[ie++] * 256 + ge[ie] * 65536;
  }
  function h(ge, ie) {
    return ge[ie++] + ge[ie] * 256;
  }
  function o(ge, ie) {
    return ge[ie];
  }
  function S(ge, ie, de) {
    switch (de) {
      case 8:
        return H(ge, ie);
      case 7:
        return j(ge, ie);
      case 6:
        return J(ge, ie);
      case 5:
        return N(ge, ie);
      case 4:
        return z(ge, ie);
      case 3:
        return A(ge, ie);
      case 2:
        return q(ge, ie);
      case 1:
        return o(ge, ie);
      default:
        throw new c(ie, "Invalid read length");
    }
  }
  function H(ge, ie) {
    const de = z(ge, ie), Se = z(ge, ie + 4);
    return Ct((de & 4292870144) === 0, ie, "Number exceeds 2^53-1"), de * 4294967296 + Se;
  }
  function j(ge, ie) {
    const de = A(ge, ie), Se = z(ge, ie + 3);
    return Ct((de & 4292870144) === 0, ie, "Number exceeds 2^53-1"), de * 4294967296 + Se;
  }
  function J(ge, ie) {
    return ge[ie++] * 1099511627776 + ge[ie++] * 4294967296 + ge[ie++] * 16777216 + ge[ie++] * 65536 + ge[ie++] * 256 + ge[ie];
  }
  function N(ge, ie) {
    return ge[ie++] * 4294967296 + ge[ie++] * 16777216 + ge[ie++] * 65536 + ge[ie++] * 256 + ge[ie];
  }
  function z(ge, ie) {
    return ge[ie++] * 16777216 + ge[ie++] * 65536 + ge[ie++] * 256 + ge[ie];
  }
  function A(ge, ie) {
    return ge[ie++] * 65536 + ge[ie++] * 256 + ge[ie];
  }
  function q(ge, ie) {
    return ge[ie++] * 256 + ge[ie];
  }
  function _(ge, ie, de) {
    switch (de) {
      case 8:
        return F(ge, ie);
      case 7:
        return R(ge, ie);
      case 6:
        return V(ge, ie);
      case 5:
        return fe(ge, ie);
      case 4:
        return ue(ge, ie);
      case 3:
        return ae(ge, ie);
      case 2:
        return D(ge, ie);
      case 1:
        return Q(ge, ie);
      default:
        throw new c(ie, "Invalid read length");
    }
  }
  function F(ge, ie) {
    const de = ue(ge, ie + 4), Se = v(ge, ie);
    return Ct(it(de, Se), "Number exceeds 2^53-1"), de * 4294967296 + Se;
  }
  function R(ge, ie) {
    const de = ae(ge, ie + 4), Se = v(ge, ie);
    return Ct(it(de, Se), "Number exceeds 2^53-1"), de * 4294967296 + Se;
  }
  function V(ge, ie) {
    const de = ge[ie + 4] + ge[ie + 5] * 256;
    return ge[ie++] + ge[ie++] * 256 + ge[ie++] * 65536 + ge[ie] * 16777216 + (de | (de & 32768) * 131070) * 4294967296;
  }
  function fe(ge, ie) {
    return ge[ie++] + ge[ie++] * 256 + ge[ie++] * 65536 + ge[ie++] * 16777216 + (ge[ie] | (ge[ie] & 128) * 33554430) * 4294967296;
  }
  function ue(ge, ie) {
    return ge[ie++] + ge[ie++] * 256 + ge[ie++] * 65536 + (ge[ie] << 24);
  }
  function ae(ge, ie) {
    const de = ge[ie++] + ge[ie++] * 256 + ge[ie] * 65536;
    return de | (de & 8388608) * 510;
  }
  function D(ge, ie) {
    const de = ge[ie++] + ge[ie] * 256;
    return de | (de & 32768) * 131070;
  }
  function Q(ge, ie) {
    const de = ge[ie];
    return de | (de & 128) * 33554430;
  }
  function Z(ge, ie, de) {
    switch (de) {
      case 8:
        return oe(ge, ie);
      case 7:
        return y(ge, ie);
      case 6:
        return Y(ge, ie);
      case 5:
        return he(ge, ie);
      case 4:
        return be(ge, ie);
      case 3:
        return xe(ge, ie);
      case 2:
        return Ie(ge, ie);
      case 1:
        return Q(ge, ie);
      default:
        throw new c(ie, "Invalid read length");
    }
  }
  function oe(ge, ie) {
    const de = be(ge, ie), Se = z(ge, ie + 4);
    return Ct(it(de, Se), "Number exceeds 2^53-1"), de * 4294967296 + Se;
  }
  function y(ge, ie) {
    const de = xe(ge, ie), Se = z(ge, ie + 3);
    return Ct(it(de, Se), "Number exceeds 2^53-1"), de * 4294967296 + Se;
  }
  function Y(ge, ie) {
    const de = ge[ie++] * 256 + ge[ie++];
    return (de | (de & 32768) * 131070) * 4294967296 + ge[ie++] * 16777216 + ge[ie++] * 65536 + ge[ie++] * 256 + ge[ie];
  }
  function he(ge, ie) {
    const de = ge[ie++];
    return (de | (de & 128) * 33554430) * 4294967296 + ge[ie++] * 16777216 + ge[ie++] * 65536 + ge[ie++] * 256 + ge[ie];
  }
  function be(ge, ie) {
    return (ge[ie++] << 24) + ge[ie++] * 65536 + ge[ie++] * 256 + ge[ie];
  }
  function xe(ge, ie) {
    const de = ge[ie++] * 65536 + ge[ie++] * 256 + ge[ie];
    return de | (de & 8388608) * 510;
  }
  function Ie(ge, ie) {
    const de = ge[ie++] * 256 + ge[ie];
    return de | (de & 32768) * 131070;
  }
  function ve(ge, ie) {
    return f[3] = ge[ie++], f[2] = ge[ie++], f[1] = ge[ie++], f[0] = ge[ie], g[0];
  }
  function C(ge, ie) {
    return f[0] = ge[ie++], f[1] = ge[ie++], f[2] = ge[ie++], f[3] = ge[ie], g[0];
  }
  function I(ge, ie) {
    return u[7] = ge[ie++], u[6] = ge[ie++], u[5] = ge[ie++], u[4] = ge[ie++], u[3] = ge[ie++], u[2] = ge[ie++], u[1] = ge[ie++], u[0] = ge[ie], n[0];
  }
  function se(ge, ie) {
    return u[0] = ge[ie++], u[1] = ge[ie++], u[2] = ge[ie++], u[3] = ge[ie++], u[4] = ge[ie++], u[5] = ge[ie++], u[6] = ge[ie++], u[7] = ge[ie], n[0];
  }
  const t = a ? ve : C, l = a ? C : ve, B = a ? I : se, U = a ? se : I;
  function G(ge, ie, de, Se) {
    switch (Se) {
      case 8:
        return T(ge, ie, de);
      case 7:
        return M(ge, ie, de);
      case 6:
        return $(ge, ie, de);
      case 5:
        return r(ge, ie, de);
      case 4:
        return x(ge, ie, de);
      case 3:
        return O(ge, ie, de);
      case 2:
        return L(ge, ie, de);
      case 1:
        return X(ge, ie, de);
      default:
        throw new c(de, "Invalid write length");
    }
  }
  function T(ge, ie, de) {
    return e(Number.isSafeInteger(ie), "num", "integer"), tt(ge, ie, de, !1);
  }
  function M(ge, ie, de) {
    return e(Number.isSafeInteger(ie), "num", "integer"), Le(ge, ie, de, !1);
  }
  function $(ge, ie, de) {
    e(Number.isSafeInteger(ie), "num", "integer");
    const Se = ie * d | 0;
    return ge[de++] = ie, ie >>>= 8, ge[de++] = ie, ie >>>= 8, ge[de++] = ie, ie >>>= 8, ge[de++] = ie, ge[de++] = Se, ge[de++] = Se >>> 8, de;
  }
  function r(ge, ie, de) {
    e(Number.isSafeInteger(ie), "num", "integer");
    const Se = ie * d | 0;
    return ge[de++] = ie, ie >>>= 8, ge[de++] = ie, ie >>>= 8, ge[de++] = ie, ie >>>= 8, ge[de++] = ie, ge[de++] = Se, de;
  }
  function x(ge, ie, de) {
    return e(Number.isSafeInteger(ie), "num", "integer"), ge[de++] = ie, ie >>>= 8, ge[de++] = ie, ie >>>= 8, ge[de++] = ie, ie >>>= 8, ge[de++] = ie, de;
  }
  function O(ge, ie, de) {
    return e(Number.isSafeInteger(ie), "num", "integer"), ge[de++] = ie, ie >>>= 8, ge[de++] = ie, ie >>>= 8, ge[de++] = ie, de;
  }
  function L(ge, ie, de) {
    return e(Number.isSafeInteger(ie), "num", "integer"), ge[de++] = ie, ge[de++] = ie >>> 8, de;
  }
  function X(ge, ie, de) {
    return e(Number.isSafeInteger(ie), "num", "integer"), ge[de] = ie, de + 1;
  }
  function P(ge, ie, de, Se) {
    switch (Se) {
      case 8:
        return K(ge, ie, de);
      case 7:
        return re(ge, ie, de);
      case 6:
        return ce(ge, ie, de);
      case 5:
        return le(ge, ie, de);
      case 4:
        return me(ge, ie, de);
      case 3:
        return ne(ge, ie, de);
      case 2:
        return W(ge, ie, de);
      case 1:
        return X(ge, ie, de);
      default:
        throw new c(de, "Invalid write length");
    }
  }
  function K(ge, ie, de) {
    return e(Number.isSafeInteger(ie), "num", "integer"), tt(ge, ie, de, !0);
  }
  function re(ge, ie, de) {
    return e(Number.isSafeInteger(ie), "num", "integer"), Le(ge, ie, de, !0);
  }
  function ce(ge, ie, de) {
    e(Number.isSafeInteger(ie), "num", "integer");
    const Se = ie * d | 0;
    return ge[de++] = Se >>> 8, ge[de++] = Se, ge[de + 3] = ie, ie >>>= 8, ge[de + 2] = ie, ie >>>= 8, ge[de + 1] = ie, ie >>>= 8, ge[de] = ie, de + 4;
  }
  function le(ge, ie, de) {
    e(Number.isSafeInteger(ie), "num", "integer");
    const Se = ie * d | 0;
    return ge[de++] = Se, ge[de + 3] = ie, ie >>>= 8, ge[de + 2] = ie, ie >>>= 8, ge[de + 1] = ie, ie >>>= 8, ge[de] = ie, de + 4;
  }
  function me(ge, ie, de) {
    return e(Number.isSafeInteger(ie), "num", "integer"), ge[de + 3] = ie, ie >>>= 8, ge[de + 2] = ie, ie >>>= 8, ge[de + 1] = ie, ie >>>= 8, ge[de] = ie, de + 4;
  }
  function ne(ge, ie, de) {
    return e(Number.isSafeInteger(ie), "num", "integer"), ge[de + 2] = ie, ie >>>= 8, ge[de + 1] = ie, ie >>>= 8, ge[de] = ie, de + 3;
  }
  function W(ge, ie, de) {
    return e(Number.isSafeInteger(ie), "num", "integer"), ge[de++] = ie >>> 8, ge[de++] = ie, de;
  }
  function te(ge, ie, de, Se) {
    switch (Se) {
      case 8:
        return T(ge, ie, de);
      case 7:
        return M(ge, ie, de);
      case 6:
        return $(ge, ie, de);
      case 5:
        return r(ge, ie, de);
      case 4:
        return O(ge, ie, de);
      case 3:
        return x(ge, ie, de);
      case 2:
        return L(ge, ie, de);
      case 1:
        return X(ge, ie, de);
      default:
        throw new c(de, "Invalid write length");
    }
  }
  function pe(ge, ie, de) {
    return T(ge, ie, de);
  }
  function Ee(ge, ie, de) {
    return M(ge, ie, de);
  }
  function Ae(ge, ie, de) {
    return $(ge, ie, de);
  }
  function Oe(ge, ie, de) {
    return r(ge, ie, de);
  }
  function Be(ge, ie, de) {
    return x(ge, ie, de);
  }
  function ke(ge, ie, de) {
    return O(ge, ie, de);
  }
  function Ne(ge, ie, de) {
    return L(ge, ie, de);
  }
  function Ke(ge, ie, de) {
    return X(ge, ie, de);
  }
  function Ce(ge, ie, de, Se) {
    switch (Se) {
      case 8:
        return K(ge, ie, de);
      case 7:
        return re(ge, ie, de);
      case 6:
        return ce(ge, ie, de);
      case 5:
        return le(ge, ie, de);
      case 4:
        return me(ge, ie, de);
      case 3:
        return ne(ge, ie, de);
      case 2:
        return W(ge, ie, de);
      case 1:
        return X(ge, ie, de);
      default:
        throw new c(de, "Invalid write length");
    }
  }
  function Ye(ge, ie, de) {
    return K(ge, ie, de);
  }
  function vt(ge, ie, de) {
    return re(ge, ie, de);
  }
  function Ve(ge, ie, de) {
    return ce(ge, ie, de);
  }
  function Xe(ge, ie, de) {
    return le(ge, ie, de);
  }
  function qt(ge, ie, de) {
    return me(ge, ie, de);
  }
  function Ge(ge, ie, de) {
    return ne(ge, ie, de);
  }
  function Je(ge, ie, de) {
    return W(ge, ie, de);
  }
  function Rt(ge, ie, de) {
    return e(ee(ie), "num", "number"), n[0] = ie, ge[de++] = u[0], ge[de++] = u[1], ge[de++] = u[2], ge[de++] = u[3], ge[de++] = u[4], ge[de++] = u[5], ge[de++] = u[6], ge[de++] = u[7], de;
  }
  function We(ge, ie, de) {
    return e(ee(ie), "num", "number"), n[0] = ie, ge[de++] = u[7], ge[de++] = u[6], ge[de++] = u[5], ge[de++] = u[4], ge[de++] = u[3], ge[de++] = u[2], ge[de++] = u[1], ge[de++] = u[0], de;
  }
  function Ze(ge, ie, de) {
    return e(ee(ie), "num", "number"), g[0] = ie, ge[de++] = f[0], ge[de++] = f[1], ge[de++] = f[2], ge[de++] = f[3], de;
  }
  function Ft(ge, ie, de) {
    return e(ee(ie), "num", "number"), g[0] = ie, ge[de++] = f[3], ge[de++] = f[2], ge[de++] = f[1], ge[de++] = f[0], de;
  }
  const Qe = a ? Ft : Ze, st = a ? Ze : Ft, Kr = a ? We : Rt, ct = a ? Rt : We;
  function ut(ge, ie) {
    let de, Se;
    switch (we(ie < ge.length, ie), ge[ie]) {
      case 255:
        Se = 9, we(ie + Se <= ge.length, ie), de = i(ge, ie + 1), Ct(de > 4294967295, ie, "Non-canonical varint");
        break;
      case 254:
        Se = 5, we(ie + Se <= ge.length, ie), de = v(ge, ie + 1), Ct(de > 65535, ie, "Non-canonical varint");
        break;
      case 253:
        Se = 3, we(ie + Se <= ge.length, ie), de = h(ge, ie + 1), Ct(de >= 253, ie, "Non-canonical varint");
        break;
      default:
        Se = 1, de = ge[ie];
        break;
    }
    return new ye(Se, de);
  }
  function Vr(ge, ie, de) {
    return e(Number.isSafeInteger(ie), "num", "integer"), ie < 253 ? (ge[de++] = ie, de) : ie <= 65535 ? (ge[de++] = 253, L(ge, ie, de)) : ie <= 4294967295 ? (ge[de++] = 254, x(ge, ie, de)) : (ge[de++] = 255, T(ge, ie, de));
  }
  function rt(ge) {
    return e(Number.isSafeInteger(ge), "num", "integer"), ge < 253 ? 1 : ge <= 65535 ? 3 : ge <= 4294967295 ? 5 : 9;
  }
  function ht(ge, ie) {
    let de = 0, Se = 0;
    for (; ; ) {
      we(ie < ge.length, ie);
      const _e = ge[ie++];
      if (Se += 1, Ct(de <= 70368744177663 - (_e & 127), ie, "Number exceeds 2^53-1"), de = de * 128 + (_e & 127), (_e & 128) === 0)
        break;
      Ct(de !== w, ie, "Number exceeds 2^53-1"), de += 1;
    }
    return new ye(Se, de);
  }
  function $r(ge, ie, de) {
    e(Number.isSafeInteger(ie), "num", "integer");
    const Se = [];
    let _e = 0;
    for (; Se[_e] = ie & 127 | (_e ? 128 : 0), !(ie <= 127); )
      ie = (ie - ie % 128) / 128 - 1, _e += 1;
    we(de + _e + 1 <= ge.length, de);
    do
      ge[de++] = Se[_e];
    while (_e--);
    return de;
  }
  function lt(ge) {
    e(Number.isSafeInteger(ge), "num", "integer");
    let ie = 0;
    for (; ie += 1, !(ge <= 127); )
      ge = (ge - ge % 128) / 128 - 1;
    return ie;
  }
  function dt(ge, ie, de) {
    if (e(k.isBuffer(ge), "data", "buffer"), e(ie >>> 0 === ie, "off", "integer"), e(de >>> 0 === de, "size", "integer"), ie + de > ge.length)
      throw new c(ie, "Out of bounds read");
    return ge.slice(ie, ie + de);
  }
  function jr(ge, ie, de) {
    if (e(k.isBuffer(ge), "data", "buffer"), e(ie >>> 0 === ie, "off", "integer"), e(de >>> 0 === de, "size", "integer"), ie + de > ge.length)
      throw new c(ie, "Out of bounds read");
    const Se = k.allocUnsafeSlow(de);
    return ge.copy(Se, 0, ie, ie + de), Se;
  }
  function bt(ge, ie, de) {
    if (e(k.isBuffer(ge), "data", "buffer"), e(k.isBuffer(ie), "value", "buffer"), e(de >>> 0 === de, "off", "integer"), de + ie.length > ge.length)
      throw new c(de, "Out of bounds write");
    return ie.copy(ge, de, 0, ie.length);
  }
  function pt(ge, ie, de, Se) {
    if (Se == null && (Se = "binary"), e(k.isBuffer(ge), "data", "buffer"), e(ie >>> 0 === ie, "off", "integer"), e(de >>> 0 === de, "size", "integer"), e(typeof Se == "string", "enc", "string"), ie + de > ge.length)
      throw new c(ie, "Out of bounds read");
    return ge.toString(Se, ie, ie + de);
  }
  function Yr(ge, ie, de, Se) {
    if (Se == null && (Se = "binary"), e(k.isBuffer(ge), "data", "buffer"), e(typeof ie == "string", "str", "string"), e(de >>> 0 === de, "off", "integer"), e(typeof Se == "string", "enc", "string"), ie.length === 0)
      return 0;
    const _e = k.byteLength(ie, Se);
    if (de + _e > ge.length)
      throw new c(de, "Out of bounds write");
    return ge.write(ie, de, Se);
  }
  function ot(ge, ie) {
    e(k.isBuffer(ge), "data", "buffer");
    const de = k.allocUnsafeSlow(ie);
    return ge.copy(de, 0), de;
  }
  function mt(ge) {
    return e(k.isBuffer(ge), "data", "buffer"), ot(ge, ge.length);
  }
  function kr(ge, ie) {
    e(k.isBuffer(ge), "a", "buffer"), e(k.isBuffer(ie), "b", "buffer");
    const de = ge.length + ie.length, Se = k.allocUnsafeSlow(de);
    return ge.copy(Se, 0), ie.copy(Se, ge.length), Se;
  }
  function et(ge) {
    return e(k.isBuffer(ge), "data", "buffer"), rt(ge.length) + ge.length;
  }
  function at(ge) {
    return rt(ge) + ge;
  }
  function ir(ge, ie) {
    if (ie == null && (ie = "binary"), e(typeof ge == "string", "str", "string"), e(typeof ie == "string", "enc", "string"), ge.length === 0)
      return 1;
    const de = k.byteLength(ge, ie);
    return rt(de) + de;
  }
  function it(ge, ie) {
    return ge < 0 && (ge = ~ge, ie === 0 && (ge += 1)), (ge & 4292870144) === 0;
  }
  function tt(ge, ie, de, Se) {
    let _e = !1;
    ie < 0 && (ie = -ie, _e = !0);
    let Pe = ie * d | 0, Re = ie | 0;
    return _e && (Re === 0 ? Pe = ~Pe + 1 | 0 : (Pe = ~Pe, Re = ~Re + 1)), Se ? (de = qt(ge, Pe, de), de = qt(ge, Re, de)) : (de = Be(ge, Re, de), de = Be(ge, Pe, de)), de;
  }
  function Le(ge, ie, de, Se) {
    let _e = !1;
    ie < 0 && (ie = -ie, _e = !0);
    let Pe = ie * d | 0, Re = ie | 0;
    return _e && (Re === 0 ? Pe = ~Pe + 1 | 0 : (Pe = ~Pe, Re = ~Re + 1)), Se ? (de = Ge(ge, Pe, de), de = qt(ge, Re, de)) : (de = Be(ge, Re, de), de = ke(ge, Pe, de)), de;
  }
  class ye {
    constructor(ie, de) {
      this.size = ie, this.value = de;
    }
  }
  function ee(ge) {
    return typeof ge == "number" && isFinite(ge);
  }
  function we(ge, ie) {
    if (!ge)
      throw new c(ie, "Out of bounds read", we);
  }
  function Ct(ge, ie, de) {
    if (!ge)
      throw new c(ie, de, Ct);
  }
  return Fe.readU = s, Fe.readU64 = i, Fe.readU56 = p, Fe.readU48 = m, Fe.readU40 = E, Fe.readU32 = v, Fe.readU24 = b, Fe.readU16 = h, Fe.readU8 = o, Fe.readUBE = S, Fe.readU64BE = H, Fe.readU56BE = j, Fe.readU48BE = J, Fe.readU40BE = N, Fe.readU32BE = z, Fe.readU24BE = A, Fe.readU16BE = q, Fe.readI = _, Fe.readI64 = F, Fe.readI56 = R, Fe.readI48 = V, Fe.readI40 = fe, Fe.readI32 = ue, Fe.readI24 = ae, Fe.readI16 = D, Fe.readI8 = Q, Fe.readIBE = Z, Fe.readI64BE = oe, Fe.readI56BE = y, Fe.readI48BE = Y, Fe.readI40BE = he, Fe.readI32BE = be, Fe.readI24BE = xe, Fe.readI16BE = Ie, Fe.readFloat = t, Fe.readFloatBE = l, Fe.readDouble = B, Fe.readDoubleBE = U, Fe.writeU = G, Fe.writeU64 = T, Fe.writeU56 = M, Fe.writeU48 = $, Fe.writeU40 = r, Fe.writeU32 = x, Fe.writeU24 = O, Fe.writeU16 = L, Fe.writeU8 = X, Fe.writeUBE = P, Fe.writeU64BE = K, Fe.writeU56BE = re, Fe.writeU48BE = ce, Fe.writeU40BE = le, Fe.writeU32BE = me, Fe.writeU24BE = ne, Fe.writeU16BE = W, Fe.writeI = te, Fe.writeI64 = pe, Fe.writeI56 = Ee, Fe.writeI48 = Ae, Fe.writeI40 = Oe, Fe.writeI32 = Be, Fe.writeI24 = ke, Fe.writeI16 = Ne, Fe.writeI8 = Ke, Fe.writeIBE = Ce, Fe.writeI64BE = Ye, Fe.writeI56BE = vt, Fe.writeI48BE = Ve, Fe.writeI40BE = Xe, Fe.writeI32BE = qt, Fe.writeI24BE = Ge, Fe.writeI16BE = Je, Fe.writeFloat = Qe, Fe.writeFloatBE = st, Fe.writeDouble = Kr, Fe.writeDoubleBE = ct, Fe.readVarint = ut, Fe.writeVarint = Vr, Fe.sizeVarint = rt, Fe.readVarint2 = ht, Fe.writeVarint2 = $r, Fe.sizeVarint2 = lt, Fe.sliceBytes = dt, Fe.readBytes = jr, Fe.writeBytes = bt, Fe.readString = pt, Fe.writeString = Yr, Fe.realloc = ot, Fe.copy = mt, Fe.concat = kr, Fe.sizeVarBytes = et, Fe.sizeVarlen = at, Fe.sizeVarString = ir, Fe;
}
var Bo, Cl;
function Ts() {
  if (Cl) return Bo;
  Cl = 1;
  const e = fn(), c = zs(), d = Ln(), w = k.alloc(0);
  class g {
    /**
     * Create a buffer reader.
     * @constructor
     * @param {Buffer} data
     * @param {Boolean?} zeroCopy - Do not reallocate buffers when
     * slicing. Note that this can lead to memory leaks if not used
     * carefully.
     */
    constructor(n, u = !1) {
      e(k.isBuffer(n), "data", "buffer"), e(typeof u == "boolean", "zeroCopy", "boolean"), this.data = n, this.offset = 0, this.zeroCopy = u, this.stack = [];
    }
    /**
     * Assertion.
     * @param {Number} size
     */
    check(n) {
      if (this.offset + n > this.data.length)
        throw new d(this.offset, "Out of bounds read", this.check);
    }
    /**
     * Get total size of passed-in Buffer.
     * @returns {Buffer}
     */
    getSize() {
      return this.data.length;
    }
    /**
     * Calculate number of bytes left to read.
     * @returns {Number}
     */
    left() {
      return this.check(0), this.data.length - this.offset;
    }
    /**
     * Seek to a position to read from by offset.
     * @param {Number} off - Offset (positive or negative).
     */
    seek(n) {
      if (e(Number.isSafeInteger(n), "off", "integer"), this.offset + n < 0)
        throw new d(this.offset, "Out of bounds read");
      return this.check(n), this.offset += n, this;
    }
    /**
     * Mark the current starting position.
     */
    start() {
      return this.stack.push(this.offset), this.offset;
    }
    /**
     * Stop reading. Pop the start position off the stack
     * and calculate the size of the data read.
     * @returns {Number} Size.
     * @throws on empty stack.
     */
    end() {
      if (this.stack.length === 0)
        throw new Error("Cannot end without a stack item.");
      const n = this.stack.pop();
      return this.offset - n;
    }
    /**
     * Stop reading. Pop the start position off the stack
     * and return the data read.
     * @param {Bolean?} zeroCopy - Do a fast buffer
     * slice instead of allocating a new buffer (warning:
     * may cause memory leaks if not used with care).
     * @returns {Buffer} Data read.
     * @throws on empty stack.
     */
    endData(n = !1) {
      if (e(typeof n == "boolean", "zeroCopy", "boolean"), this.stack.length === 0)
        throw new Error("Cannot end without a stack item.");
      const u = this.stack.pop(), a = this.offset, s = a - u, i = this.data;
      if (s === i.length)
        return i;
      if (this.zeroCopy || n)
        return i.slice(u, a);
      const p = k.allocUnsafeSlow(s);
      return i.copy(p, 0, u, a), p;
    }
    /**
     * Destroy the reader. Remove references to the data.
     */
    destroy() {
      return this.data = w, this.offset = 0, this.stack.length = 0, this;
    }
    /**
     * Read uint8.
     * @returns {Number}
     */
    readU8() {
      this.check(1);
      const n = this.data[this.offset];
      return this.offset += 1, n;
    }
    /**
     * Read uint16le.
     * @returns {Number}
     */
    readU16() {
      this.check(2);
      const n = c.readU16(this.data, this.offset);
      return this.offset += 2, n;
    }
    /**
     * Read uint16be.
     * @returns {Number}
     */
    readU16BE() {
      this.check(2);
      const n = c.readU16BE(this.data, this.offset);
      return this.offset += 2, n;
    }
    /**
     * Read uint24le.
     * @returns {Number}
     */
    readU24() {
      this.check(3);
      const n = c.readU24(this.data, this.offset);
      return this.offset += 3, n;
    }
    /**
     * Read uint24be.
     * @returns {Number}
     */
    readU24BE() {
      this.check(3);
      const n = c.readU24BE(this.data, this.offset);
      return this.offset += 3, n;
    }
    /**
     * Read uint32le.
     * @returns {Number}
     */
    readU32() {
      this.check(4);
      const n = c.readU32(this.data, this.offset);
      return this.offset += 4, n;
    }
    /**
     * Read uint32be.
     * @returns {Number}
     */
    readU32BE() {
      this.check(4);
      const n = c.readU32BE(this.data, this.offset);
      return this.offset += 4, n;
    }
    /**
     * Read uint40le.
     * @returns {Number}
     */
    readU40() {
      this.check(5);
      const n = c.readU40(this.data, this.offset);
      return this.offset += 5, n;
    }
    /**
     * Read uint40be.
     * @returns {Number}
     */
    readU40BE() {
      this.check(5);
      const n = c.readU40BE(this.data, this.offset);
      return this.offset += 5, n;
    }
    /**
     * Read uint48le.
     * @returns {Number}
     */
    readU48() {
      this.check(6);
      const n = c.readU48(this.data, this.offset);
      return this.offset += 6, n;
    }
    /**
     * Read uint48be.
     * @returns {Number}
     */
    readU48BE() {
      this.check(6);
      const n = c.readU48BE(this.data, this.offset);
      return this.offset += 6, n;
    }
    /**
     * Read uint56le.
     * @returns {Number}
     */
    readU56() {
      this.check(7);
      const n = c.readU56(this.data, this.offset);
      return this.offset += 7, n;
    }
    /**
     * Read uint56be.
     * @returns {Number}
     */
    readU56BE() {
      this.check(7);
      const n = c.readU56BE(this.data, this.offset);
      return this.offset += 7, n;
    }
    /**
     * Read uint64le as a js number.
     * @returns {Number}
     * @throws on num > MAX_SAFE_INTEGER
     */
    readU64() {
      this.check(8);
      const n = c.readU64(this.data, this.offset);
      return this.offset += 8, n;
    }
    /**
     * Read uint64be as a js number.
     * @returns {Number}
     * @throws on num > MAX_SAFE_INTEGER
     */
    readU64BE() {
      this.check(8);
      const n = c.readU64BE(this.data, this.offset);
      return this.offset += 8, n;
    }
    /**
     * Read int8.
     * @returns {Number}
     */
    readI8() {
      this.check(1);
      const n = c.readI8(this.data, this.offset);
      return this.offset += 1, n;
    }
    /**
     * Read int16le.
     * @returns {Number}
     */
    readI16() {
      this.check(2);
      const n = c.readI16(this.data, this.offset);
      return this.offset += 2, n;
    }
    /**
     * Read int16be.
     * @returns {Number}
     */
    readI16BE() {
      this.check(2);
      const n = c.readI16BE(this.data, this.offset);
      return this.offset += 2, n;
    }
    /**
     * Read int24le.
     * @returns {Number}
     */
    readI24() {
      this.check(3);
      const n = c.readI24(this.data, this.offset);
      return this.offset += 3, n;
    }
    /**
     * Read int24be.
     * @returns {Number}
     */
    readI24BE() {
      this.check(3);
      const n = c.readI24BE(this.data, this.offset);
      return this.offset += 3, n;
    }
    /**
     * Read int32le.
     * @returns {Number}
     */
    readI32() {
      this.check(4);
      const n = c.readI32(this.data, this.offset);
      return this.offset += 4, n;
    }
    /**
     * Read int32be.
     * @returns {Number}
     */
    readI32BE() {
      this.check(4);
      const n = c.readI32BE(this.data, this.offset);
      return this.offset += 4, n;
    }
    /**
     * Read int40le.
     * @returns {Number}
     */
    readI40() {
      this.check(5);
      const n = c.readI40(this.data, this.offset);
      return this.offset += 5, n;
    }
    /**
     * Read int40be.
     * @returns {Number}
     */
    readI40BE() {
      this.check(5);
      const n = c.readI40BE(this.data, this.offset);
      return this.offset += 5, n;
    }
    /**
     * Read int48le.
     * @returns {Number}
     */
    readI48() {
      this.check(6);
      const n = c.readI48(this.data, this.offset);
      return this.offset += 6, n;
    }
    /**
     * Read int48be.
     * @returns {Number}
     */
    readI48BE() {
      this.check(6);
      const n = c.readI48BE(this.data, this.offset);
      return this.offset += 6, n;
    }
    /**
     * Read int56le.
     * @returns {Number}
     */
    readI56() {
      this.check(7);
      const n = c.readI56(this.data, this.offset);
      return this.offset += 7, n;
    }
    /**
     * Read int56be.
     * @returns {Number}
     */
    readI56BE() {
      this.check(7);
      const n = c.readI56BE(this.data, this.offset);
      return this.offset += 7, n;
    }
    /**
     * Read int64le as a js number.
     * @returns {Number}
     * @throws on num > MAX_SAFE_INTEGER
     */
    readI64() {
      this.check(8);
      const n = c.readI64(this.data, this.offset);
      return this.offset += 8, n;
    }
    /**
     * Read int64be as a js number.
     * @returns {Number}
     * @throws on num > MAX_SAFE_INTEGER
     */
    readI64BE() {
      this.check(8);
      const n = c.readI64BE(this.data, this.offset);
      return this.offset += 8, n;
    }
    /**
     * Read float le.
     * @returns {Number}
     */
    readFloat() {
      this.check(4);
      const n = c.readFloat(this.data, this.offset);
      return this.offset += 4, n;
    }
    /**
     * Read float be.
     * @returns {Number}
     */
    readFloatBE() {
      this.check(4);
      const n = c.readFloatBE(this.data, this.offset);
      return this.offset += 4, n;
    }
    /**
     * Read double float le.
     * @returns {Number}
     */
    readDouble() {
      this.check(8);
      const n = c.readDouble(this.data, this.offset);
      return this.offset += 8, n;
    }
    /**
     * Read double float be.
     * @returns {Number}
     */
    readDoubleBE() {
      this.check(8);
      const n = c.readDoubleBE(this.data, this.offset);
      return this.offset += 8, n;
    }
    /**
     * Read a varint.
     * @returns {Number}
     */
    readVarint() {
      const { size: n, value: u } = c.readVarint(this.data, this.offset);
      return this.offset += n, u;
    }
    /**
     * Read a varint (type 2).
     * @returns {Number}
     */
    readVarint2() {
      const { size: n, value: u } = c.readVarint2(this.data, this.offset);
      return this.offset += n, u;
    }
    /**
     * Read N bytes (will do a fast slice if zero copy).
     * @param {Number} size
     * @param {Bolean?} zeroCopy - Do a fast buffer
     * slice instead of allocating a new buffer (warning:
     * may cause memory leaks if not used with care).
     * @returns {Buffer}
     */
    readBytes(n, u = !1) {
      e(n >>> 0 === n, "size", "integer"), e(typeof u == "boolean", "zeroCopy", "boolean"), this.check(n);
      let a;
      return this.zeroCopy || u ? a = this.data.slice(this.offset, this.offset + n) : (a = k.allocUnsafeSlow(n), this.data.copy(a, 0, this.offset, this.offset + n)), this.offset += n, a;
    }
    /**
     * Read a varint number of bytes (will do a fast slice if zero copy).
     * @param {Bolean?} zeroCopy - Do a fast buffer
     * slice instead of allocating a new buffer (warning:
     * may cause memory leaks if not used with care).
     * @returns {Buffer}
     */
    readVarBytes(n = !1) {
      return this.readBytes(this.readVarint(), n);
    }
    /**
     * Slice N bytes and create a child reader.
     * @param {Number} size
     * @returns {BufferReader}
     */
    readChild(n) {
      e(n >>> 0 === n, "size", "integer"), this.check(n);
      const u = this.data.slice(0, this.offset + n), a = new this.constructor(u);
      return a.offset = this.offset, this.offset += n, a;
    }
    /**
     * Read a string.
     * @param {Number} size
     * @param {String} enc - Any buffer-supported encoding.
     * @returns {String}
     */
    readString(n, u) {
      u == null && (u = "binary"), e(n >>> 0 === n, "size", "integer"), e(typeof u == "string", "enc", "string"), this.check(n);
      const a = this.data.toString(u, this.offset, this.offset + n);
      return this.offset += n, a;
    }
    /**
     * Read a 32-byte hash.
     * @param {String} enc - `"hex"` or `null`.
     * @returns {Hash|Buffer}
     */
    readHash(n) {
      return n ? this.readString(32, n) : this.readBytes(32);
    }
    /**
     * Read string of a varint length.
     * @param {String} enc - Any buffer-supported encoding.
     * @param {Number?} limit - Size limit.
     * @returns {String}
     */
    readVarString(n, u = 0) {
      n == null && (n = "binary"), e(typeof n == "string", "enc", "string"), e(u >>> 0 === u, "limit", "integer");
      const a = this.readVarint();
      if (u !== 0 && a > u)
        throw new d(this.offset, "String exceeds limit");
      return this.readString(a, n);
    }
    /**
     * Read a null-terminated string.
     * @param {String} enc - Any buffer-supported encoding.
     * @returns {String}
     */
    readNullString(n) {
      n == null && (n = "binary"), e(typeof n == "string", "enc", "string");
      let u = this.offset;
      for (; u < this.data.length && this.data[u] !== 0; u++)
        ;
      if (u === this.data.length)
        throw new d(this.offset, "No NUL terminator");
      const a = this.readString(u - this.offset, n);
      return this.offset = u + 1, a;
    }
    /**
     * Create a checksum from the last start position.
     * @param {Function} hash
     * @returns {Number} Checksum.
     */
    createChecksum(n) {
      (!n || typeof n.digest != "function") && e(typeof n == "function", "hash", "function");
      let u = 0;
      this.stack.length > 0 && (u = this.stack[this.stack.length - 1]);
      const a = this.data.slice(u, this.offset), s = n.digest ? n.digest(a) : n(a);
      return c.readU32(s, 0);
    }
    /**
     * Verify a 4-byte checksum against a calculated checksum.
     * @param {Function} hash
     * @returns {Number} checksum
     * @throws on bad checksum
     */
    verifyChecksum(n) {
      const u = this.createChecksum(n), a = this.readU32();
      if (u !== a)
        throw new d(this.offset, "Checksum mismatch");
      return u;
    }
  }
  return Bo = g, Bo;
}
var Mo, Dl;
function Cs() {
  if (Dl) return Mo;
  Dl = 1;
  const e = fn(), c = zs(), d = Ln(), w = 0, g = 1, f = 2, n = 3, u = 4, a = 5, s = 6, i = 7, p = 8, m = 9, E = 10, v = 11, b = 12, h = 13, o = 14, S = 15, H = 16, j = 17, J = 18, N = 19, z = 20, A = 21, q = 22, _ = 23, F = 24, R = 25, V = 26, fe = 27, ue = 28, ae = 29, D = 30, Q = 31, Z = 32, oe = 33, y = 34, Y = 35, he = 36, be = 37, xe = 38, Ie = 39, ve = 40;
  class C {
    /**
     * Create a buffer writer.
     * @constructor
     */
    constructor() {
      this.ops = [], this.offset = 0;
    }
    /**
     * Allocate and render the final buffer.
     * @returns {Buffer} Rendered buffer.
     */
    render() {
      const T = k.allocUnsafeSlow(this.offset);
      let M = 0;
      for (const $ of this.ops)
        switch ($.type) {
          case w:
            M += $.value;
            break;
          case g:
            M = c.writeU8(T, $.value, M);
            break;
          case f:
            M = c.writeU16(T, $.value, M);
            break;
          case n:
            M = c.writeU16BE(T, $.value, M);
            break;
          case u:
            M = c.writeU24(T, $.value, M);
            break;
          case a:
            M = c.writeU24BE(T, $.value, M);
            break;
          case s:
            M = c.writeU32(T, $.value, M);
            break;
          case i:
            M = c.writeU32BE(T, $.value, M);
            break;
          case p:
            M = c.writeU40(T, $.value, M);
            break;
          case m:
            M = c.writeU40BE(T, $.value, M);
            break;
          case E:
            M = c.writeU48(T, $.value, M);
            break;
          case v:
            M = c.writeU48BE(T, $.value, M);
            break;
          case b:
            M = c.writeU56(T, $.value, M);
            break;
          case h:
            M = c.writeU56BE(T, $.value, M);
            break;
          case o:
            M = c.writeU64(T, $.value, M);
            break;
          case S:
            M = c.writeU64BE(T, $.value, M);
            break;
          case H:
            M = c.writeI8(T, $.value, M);
            break;
          case j:
            M = c.writeI16(T, $.value, M);
            break;
          case J:
            M = c.writeI16BE(T, $.value, M);
            break;
          case N:
            M = c.writeI24(T, $.value, M);
            break;
          case z:
            M = c.writeI24BE(T, $.value, M);
            break;
          case A:
            M = c.writeI32(T, $.value, M);
            break;
          case q:
            M = c.writeI32BE(T, $.value, M);
            break;
          case _:
            M = c.writeI40(T, $.value, M);
            break;
          case F:
            M = c.writeI40BE(T, $.value, M);
            break;
          case R:
            M = c.writeI48(T, $.value, M);
            break;
          case V:
            M = c.writeI48BE(T, $.value, M);
            break;
          case fe:
            M = c.writeI56(T, $.value, M);
            break;
          case ue:
            M = c.writeI56BE(T, $.value, M);
            break;
          case ae:
            M = c.writeI64(T, $.value, M);
            break;
          case D:
            M = c.writeI64BE(T, $.value, M);
            break;
          case Q:
            M = c.writeFloat(T, $.value, M);
            break;
          case Z:
            M = c.writeFloatBE(T, $.value, M);
            break;
          case oe:
            M = c.writeDouble(T, $.value, M);
            break;
          case y:
            M = c.writeDoubleBE(T, $.value, M);
            break;
          case Y:
            M = c.writeVarint(T, $.value, M);
            break;
          case he:
            M = c.writeVarint2(T, $.value, M);
            break;
          case be:
            M += $.data.copy(T, M);
            break;
          case xe:
            M += T.write($.value, M, $.enc);
            break;
          case Ie:
            M += $.func(T.slice(0, M)).copy(T, M, 0, 4);
            break;
          case ve:
            T.fill($.value, M, M + $.size), M += $.size;
            break;
          default:
            throw new Error("Invalid type.");
        }
      if (M !== T.length)
        throw new d(M, "Out of bounds write");
      return this.destroy(), T;
    }
    /**
     * Get size of data written so far.
     * @returns {Number}
     */
    getSize() {
      return this.offset;
    }
    /**
     * Seek to relative offset.
     * @param {Number} offset
     */
    seek(T) {
      if (e(Number.isSafeInteger(T), "off", "integer"), this.offset + T < 0)
        throw new d(this.offset, "Out of bounds write");
      return this.offset += T, this.ops.push(new se(w, T)), this;
    }
    /**
     * Destroy the buffer writer. Remove references to `ops`.
     */
    destroy() {
      return this.ops.length = 0, this.offset = 0, this;
    }
    /**
     * Write uint8.
     * @param {Number} value
     */
    writeU8(T) {
      return this.offset += 1, this.ops.push(new se(g, T)), this;
    }
    /**
     * Write uint16le.
     * @param {Number} value
     */
    writeU16(T) {
      return this.offset += 2, this.ops.push(new se(f, T)), this;
    }
    /**
     * Write uint16be.
     * @param {Number} value
     */
    writeU16BE(T) {
      return this.offset += 2, this.ops.push(new se(n, T)), this;
    }
    /**
     * Write uint24le.
     * @param {Number} value
     */
    writeU24(T) {
      return this.offset += 3, this.ops.push(new se(u, T)), this;
    }
    /**
     * Write uint24be.
     * @param {Number} value
     */
    writeU24BE(T) {
      return this.offset += 3, this.ops.push(new se(a, T)), this;
    }
    /**
     * Write uint32le.
     * @param {Number} value
     */
    writeU32(T) {
      return this.offset += 4, this.ops.push(new se(s, T)), this;
    }
    /**
     * Write uint32be.
     * @param {Number} value
     */
    writeU32BE(T) {
      return this.offset += 4, this.ops.push(new se(i, T)), this;
    }
    /**
     * Write uint40le.
     * @param {Number} value
     */
    writeU40(T) {
      return this.offset += 5, this.ops.push(new se(p, T)), this;
    }
    /**
     * Write uint40be.
     * @param {Number} value
     */
    writeU40BE(T) {
      return this.offset += 5, this.ops.push(new se(m, T)), this;
    }
    /**
     * Write uint48le.
     * @param {Number} value
     */
    writeU48(T) {
      return this.offset += 6, this.ops.push(new se(E, T)), this;
    }
    /**
     * Write uint48be.
     * @param {Number} value
     */
    writeU48BE(T) {
      return this.offset += 6, this.ops.push(new se(v, T)), this;
    }
    /**
     * Write uint56le.
     * @param {Number} value
     */
    writeU56(T) {
      return this.offset += 7, this.ops.push(new se(b, T)), this;
    }
    /**
     * Write uint56be.
     * @param {Number} value
     */
    writeU56BE(T) {
      return this.offset += 7, this.ops.push(new se(h, T)), this;
    }
    /**
     * Write uint64le.
     * @param {Number} value
     */
    writeU64(T) {
      return this.offset += 8, this.ops.push(new se(o, T)), this;
    }
    /**
     * Write uint64be.
     * @param {Number} value
     */
    writeU64BE(T) {
      return this.offset += 8, this.ops.push(new se(S, T)), this;
    }
    /**
     * Write int8.
     * @param {Number} value
     */
    writeI8(T) {
      return this.offset += 1, this.ops.push(new se(H, T)), this;
    }
    /**
     * Write int16le.
     * @param {Number} value
     */
    writeI16(T) {
      return this.offset += 2, this.ops.push(new se(j, T)), this;
    }
    /**
     * Write int16be.
     * @param {Number} value
     */
    writeI16BE(T) {
      return this.offset += 2, this.ops.push(new se(J, T)), this;
    }
    /**
     * Write int24le.
     * @param {Number} value
     */
    writeI24(T) {
      return this.offset += 3, this.ops.push(new se(N, T)), this;
    }
    /**
     * Write int24be.
     * @param {Number} value
     */
    writeI24BE(T) {
      return this.offset += 3, this.ops.push(new se(z, T)), this;
    }
    /**
     * Write int32le.
     * @param {Number} value
     */
    writeI32(T) {
      return this.offset += 4, this.ops.push(new se(A, T)), this;
    }
    /**
     * Write int32be.
     * @param {Number} value
     */
    writeI32BE(T) {
      return this.offset += 4, this.ops.push(new se(q, T)), this;
    }
    /**
     * Write int40le.
     * @param {Number} value
     */
    writeI40(T) {
      return this.offset += 5, this.ops.push(new se(_, T)), this;
    }
    /**
     * Write int40be.
     * @param {Number} value
     */
    writeI40BE(T) {
      return this.offset += 5, this.ops.push(new se(F, T)), this;
    }
    /**
     * Write int48le.
     * @param {Number} value
     */
    writeI48(T) {
      return this.offset += 6, this.ops.push(new se(R, T)), this;
    }
    /**
     * Write int48be.
     * @param {Number} value
     */
    writeI48BE(T) {
      return this.offset += 6, this.ops.push(new se(V, T)), this;
    }
    /**
     * Write int56le.
     * @param {Number} value
     */
    writeI56(T) {
      return this.offset += 7, this.ops.push(new se(fe, T)), this;
    }
    /**
     * Write int56be.
     * @param {Number} value
     */
    writeI56BE(T) {
      return this.offset += 7, this.ops.push(new se(ue, T)), this;
    }
    /**
     * Write int64le.
     * @param {Number} value
     */
    writeI64(T) {
      return this.offset += 8, this.ops.push(new se(ae, T)), this;
    }
    /**
     * Write int64be.
     * @param {Number} value
     */
    writeI64BE(T) {
      return this.offset += 8, this.ops.push(new se(D, T)), this;
    }
    /**
     * Write float le.
     * @param {Number} value
     */
    writeFloat(T) {
      return this.offset += 4, this.ops.push(new se(Q, T)), this;
    }
    /**
     * Write float be.
     * @param {Number} value
     */
    writeFloatBE(T) {
      return this.offset += 4, this.ops.push(new se(Z, T)), this;
    }
    /**
     * Write double le.
     * @param {Number} value
     */
    writeDouble(T) {
      return this.offset += 8, this.ops.push(new se(oe, T)), this;
    }
    /**
     * Write double be.
     * @param {Number} value
     */
    writeDoubleBE(T) {
      return this.offset += 8, this.ops.push(new se(y, T)), this;
    }
    /**
     * Write a varint.
     * @param {Number} value
     */
    writeVarint(T) {
      return this.offset += c.sizeVarint(T), this.ops.push(new se(Y, T)), this;
    }
    /**
     * Write a varint (type 2).
     * @param {Number} value
     */
    writeVarint2(T) {
      return this.offset += c.sizeVarint2(T), this.ops.push(new se(he, T)), this;
    }
    /**
     * Write bytes.
     * @param {Buffer} value
     */
    writeBytes(T) {
      return e(k.isBuffer(T), "value", "buffer"), T.length === 0 ? this : (this.offset += T.length, this.ops.push(new t(be, T)), this);
    }
    /**
     * Write bytes with a varint length before them.
     * @param {Buffer} value
     */
    writeVarBytes(T) {
      return e(k.isBuffer(T), "value", "buffer"), this.offset += c.sizeVarint(T.length), this.ops.push(new se(Y, T.length)), T.length === 0 ? this : (this.offset += T.length, this.ops.push(new t(be, T)), this);
    }
    /**
     * Copy bytes.
     * @param {Buffer} value
     * @param {Number} start
     * @param {Number} end
     */
    copy(T, M, $) {
      e(k.isBuffer(T), "value", "buffer"), e(M >>> 0 === M, "start", "integer"), e($ >>> 0 === $, "end", "integer"), e($ >= M, "start", "integer");
      const r = T.slice(M, $);
      return this.writeBytes(r), this;
    }
    /**
     * Write string to buffer.
     * @param {String} value
     * @param {String?} enc - Any buffer-supported encoding.
     */
    writeString(T, M) {
      return M == null && (M = "binary"), e(typeof T == "string", "value", "string"), e(typeof M == "string", "enc", "string"), T.length === 0 ? this : (this.offset += k.byteLength(T, M), this.ops.push(new l(xe, T, M)), this);
    }
    /**
     * Write a 32 byte hash.
     * @param {Hash} value
     */
    writeHash(T) {
      return typeof T != "string" ? (e(k.isBuffer(T), "value", "buffer"), e(T.length === 32, "value", "32-byte hash"), this.writeBytes(T), this) : (e(T.length === 64, "value", "32-byte hash"), this.writeString(T, "hex"), this);
    }
    /**
     * Write a string with a varint length before it.
     * @param {String}
     * @param {String?} enc - Any buffer-supported encoding.
     */
    writeVarString(T, M) {
      if (M == null && (M = "binary"), e(typeof T == "string", "value", "string"), e(typeof M == "string", "enc", "string"), T.length === 0)
        return this.ops.push(new se(Y, 0)), this;
      const $ = k.byteLength(T, M);
      return this.offset += c.sizeVarint($), this.offset += $, this.ops.push(new se(Y, $)), this.ops.push(new l(xe, T, M)), this;
    }
    /**
     * Write a null-terminated string.
     * @param {String|Buffer}
     * @param {String?} enc - Any buffer-supported encoding.
     */
    writeNullString(T, M) {
      return this.writeString(T, M), this.writeU8(0), this;
    }
    /**
     * Calculate and write a checksum for the data written so far.
     * @param {Function} hash
     */
    writeChecksum(T) {
      return T && typeof T.digest == "function" && (T = T.digest.bind(T)), e(typeof T == "function", "hash", "function"), this.offset += 4, this.ops.push(new B(Ie, T)), this;
    }
    /**
     * Fill N bytes with value.
     * @param {Number} value
     * @param {Number} size
     */
    fill(T, M) {
      return e((T & 255) === T, "value", "byte"), e(M >>> 0 === M, "size", "integer"), M === 0 ? this : (this.offset += M, this.ops.push(new U(ve, T, M)), this);
    }
  }
  class I {
    constructor(T) {
      this.type = T;
    }
  }
  class se extends I {
    constructor(T, M) {
      super(T), this.value = M;
    }
  }
  class t extends I {
    constructor(T, M) {
      super(T), this.data = M;
    }
  }
  class l extends I {
    constructor(T, M, $) {
      super(T), this.value = M, this.enc = $;
    }
  }
  class B extends I {
    constructor(T, M) {
      super(T), this.func = M;
    }
  }
  class U extends I {
    constructor(T, M, $) {
      super(T), this.value = M, this.size = $;
    }
  }
  return Mo = C, Mo;
}
var No, Ul;
function n8() {
  if (Ul) return No;
  Ul = 1;
  const e = fn(), c = zs(), d = Ln(), w = k.alloc(0), g = 102400;
  let f = null;
  class n {
    /**
     * Statically allocated buffer writer.
     * @constructor
     * @param {Number|Buffer} options
     */
    constructor(a) {
      this.data = w, this.offset = 0, a != null && this.init(a);
    }
    /**
     * Assertion.
     * @param {Number} size
     */
    check(a) {
      if (this.offset + a > this.data.length)
        throw new d(this.offset, "Out of bounds write", this.check);
    }
    /**
     * Initialize options.
     * @param {Object} options
     */
    init(a) {
      return k.isBuffer(a) ? (this.data = a, this.offset = 0, this) : (e(a >>> 0 === a, "size", "integer"), this.data = k.allocUnsafeSlow(a), this.offset = 0, this);
    }
    /**
     * Allocate writer from preallocated 100kb pool.
     * @param {Number} size
     * @returns {StaticWriter}
     */
    static pool(a) {
      if (e(a >>> 0 === a, "size", "integer"), a <= g) {
        f || (f = k.allocUnsafeSlow(g));
        const s = new n();
        return s.data = f.slice(0, a), s;
      }
      return new n(a);
    }
    /**
     * Allocate and render the final buffer.
     * @returns {Buffer} Rendered buffer.
     */
    render() {
      const { data: a, offset: s } = this;
      if (s !== a.length)
        throw new d(s, "Out of bounds write");
      return this.destroy(), a;
    }
    /**
     * Slice the final buffer at written offset.
     * @returns {Buffer} Rendered buffer.
     */
    slice() {
      const { data: a, offset: s } = this;
      if (s > a.length)
        throw new d(s, "Out of bounds write");
      return this.destroy(), a.slice(0, s);
    }
    /**
     * Get size of data written so far.
     * @returns {Number}
     */
    getSize() {
      return this.offset;
    }
    /**
     * Seek to relative offset.
     * @param {Number} off
     */
    seek(a) {
      if (e(Number.isSafeInteger(a), "off", "integer"), this.offset + a < 0)
        throw new d(this.offset, "Out of bounds write");
      return this.check(a), this.offset += a, this;
    }
    /**
     * Destroy the buffer writer.
     */
    destroy() {
      return this.data = w, this.offset = 0, this;
    }
    /**
     * Write uint8.
     * @param {Number} value
     */
    writeU8(a) {
      return this.check(1), this.offset = c.writeU8(this.data, a, this.offset), this;
    }
    /**
     * Write uint16le.
     * @param {Number} value
     */
    writeU16(a) {
      return this.check(2), this.offset = c.writeU16(this.data, a, this.offset), this;
    }
    /**
     * Write uint16be.
     * @param {Number} value
     */
    writeU16BE(a) {
      return this.check(2), this.offset = c.writeU16BE(this.data, a, this.offset), this;
    }
    /**
     * Write uint24le.
     * @param {Number} value
     */
    writeU24(a) {
      return this.check(3), this.offset = c.writeU24(this.data, a, this.offset), this;
    }
    /**
     * Write uint24be.
     * @param {Number} value
     */
    writeU24BE(a) {
      return this.check(3), this.offset = c.writeU24BE(this.data, a, this.offset), this;
    }
    /**
     * Write uint32le.
     * @param {Number} value
     */
    writeU32(a) {
      return this.check(4), this.offset = c.writeU32(this.data, a, this.offset), this;
    }
    /**
     * Write uint32be.
     * @param {Number} value
     */
    writeU32BE(a) {
      return this.check(4), this.offset = c.writeU32BE(this.data, a, this.offset), this;
    }
    /**
     * Write uint40le.
     * @param {Number} value
     */
    writeU40(a) {
      return this.check(5), this.offset = c.writeU40(this.data, a, this.offset), this;
    }
    /**
     * Write uint40be.
     * @param {Number} value
     */
    writeU40BE(a) {
      return this.check(5), this.offset = c.writeU40BE(this.data, a, this.offset), this;
    }
    /**
     * Write uint48le.
     * @param {Number} value
     */
    writeU48(a) {
      return this.check(6), this.offset = c.writeU48(this.data, a, this.offset), this;
    }
    /**
     * Write uint48be.
     * @param {Number} value
     */
    writeU48BE(a) {
      return this.check(6), this.offset = c.writeU48BE(this.data, a, this.offset), this;
    }
    /**
     * Write uint56le.
     * @param {Number} value
     */
    writeU56(a) {
      return this.check(7), this.offset = c.writeU56(this.data, a, this.offset), this;
    }
    /**
     * Write uint56be.
     * @param {Number} value
     */
    writeU56BE(a) {
      return this.check(7), this.offset = c.writeU56BE(this.data, a, this.offset), this;
    }
    /**
     * Write uint64le.
     * @param {Number} value
     */
    writeU64(a) {
      return this.check(8), this.offset = c.writeU64(this.data, a, this.offset), this;
    }
    /**
     * Write uint64be.
     * @param {Number} value
     */
    writeU64BE(a) {
      return this.check(8), this.offset = c.writeU64BE(this.data, a, this.offset), this;
    }
    /**
     * Write int8.
     * @param {Number} value
     */
    writeI8(a) {
      return this.check(1), this.offset = c.writeI8(this.data, a, this.offset), this;
    }
    /**
     * Write int16le.
     * @param {Number} value
     */
    writeI16(a) {
      return this.check(2), this.offset = c.writeI16(this.data, a, this.offset), this;
    }
    /**
     * Write int16be.
     * @param {Number} value
     */
    writeI16BE(a) {
      return this.check(2), this.offset = c.writeI16BE(this.data, a, this.offset), this;
    }
    /**
     * Write int24le.
     * @param {Number} value
     */
    writeI24(a) {
      return this.check(3), this.offset = c.writeI24(this.data, a, this.offset), this;
    }
    /**
     * Write int24be.
     * @param {Number} value
     */
    writeI24BE(a) {
      return this.check(3), this.offset = c.writeI24BE(this.data, a, this.offset), this;
    }
    /**
     * Write int32le.
     * @param {Number} value
     */
    writeI32(a) {
      return this.check(4), this.offset = c.writeI32(this.data, a, this.offset), this;
    }
    /**
     * Write int32be.
     * @param {Number} value
     */
    writeI32BE(a) {
      return this.check(4), this.offset = c.writeI32BE(this.data, a, this.offset), this;
    }
    /**
     * Write int40le.
     * @param {Number} value
     */
    writeI40(a) {
      return this.check(5), this.offset = c.writeI40(this.data, a, this.offset), this;
    }
    /**
     * Write int40be.
     * @param {Number} value
     */
    writeI40BE(a) {
      return this.check(5), this.offset = c.writeI40BE(this.data, a, this.offset), this;
    }
    /**
     * Write int48le.
     * @param {Number} value
     */
    writeI48(a) {
      return this.check(6), this.offset = c.writeI48(this.data, a, this.offset), this;
    }
    /**
     * Write int48be.
     * @param {Number} value
     */
    writeI48BE(a) {
      return this.check(6), this.offset = c.writeI48BE(this.data, a, this.offset), this;
    }
    /**
     * Write int56le.
     * @param {Number} value
     */
    writeI56(a) {
      return this.check(7), this.offset = c.writeI56(this.data, a, this.offset), this;
    }
    /**
     * Write int56be.
     * @param {Number} value
     */
    writeI56BE(a) {
      return this.check(7), this.offset = c.writeI56BE(this.data, a, this.offset), this;
    }
    /**
     * Write int64le.
     * @param {Number} value
     */
    writeI64(a) {
      return this.check(8), this.offset = c.writeI64(this.data, a, this.offset), this;
    }
    /**
     * Write int64be.
     * @param {Number} value
     */
    writeI64BE(a) {
      return this.check(8), this.offset = c.writeI64BE(this.data, a, this.offset), this;
    }
    /**
     * Write float le.
     * @param {Number} value
     */
    writeFloat(a) {
      return this.check(4), this.offset = c.writeFloat(this.data, a, this.offset), this;
    }
    /**
     * Write float be.
     * @param {Number} value
     */
    writeFloatBE(a) {
      return this.check(4), this.offset = c.writeFloatBE(this.data, a, this.offset), this;
    }
    /**
     * Write double le.
     * @param {Number} value
     */
    writeDouble(a) {
      return this.check(8), this.offset = c.writeDouble(this.data, a, this.offset), this;
    }
    /**
     * Write double be.
     * @param {Number} value
     */
    writeDoubleBE(a) {
      return this.check(8), this.offset = c.writeDoubleBE(this.data, a, this.offset), this;
    }
    /**
     * Write a varint.
     * @param {Number} value
     */
    writeVarint(a) {
      return this.offset = c.writeVarint(this.data, a, this.offset), this;
    }
    /**
     * Write a varint (type 2).
     * @param {Number} value
     */
    writeVarint2(a) {
      return this.offset = c.writeVarint2(this.data, a, this.offset), this;
    }
    /**
     * Write bytes.
     * @param {Buffer} value
     */
    writeBytes(a) {
      return e(k.isBuffer(a), "value", "buffer"), this.check(a.length), this.offset += a.copy(this.data, this.offset), this;
    }
    /**
     * Write bytes with a varint length before them.
     * @param {Buffer} value
     */
    writeVarBytes(a) {
      return e(k.isBuffer(a), "value", "buffer"), this.writeVarint(a.length), this.writeBytes(a), this;
    }
    /**
     * Copy bytes.
     * @param {Buffer} value
     * @param {Number} start
     * @param {Number} end
     */
    copy(a, s, i) {
      return e(k.isBuffer(a), "value", "buffer"), e(s >>> 0 === s, "start", "integer"), e(i >>> 0 === i, "end", "integer"), e(i >= s, "start", "integer"), this.check(i - s), this.offset += a.copy(this.data, this.offset, s, i), this;
    }
    /**
     * Write string to buffer.
     * @param {String} value
     * @param {String?} enc - Any buffer-supported encoding.
     */
    writeString(a, s) {
      if (s == null && (s = "binary"), e(typeof a == "string", "value", "string"), e(typeof s == "string", "enc", "string"), a.length === 0)
        return this;
      const i = k.byteLength(a, s);
      return this.check(i), this.offset += this.data.write(a, this.offset, s), this;
    }
    /**
     * Write a 32 byte hash.
     * @param {Hash} value
     */
    writeHash(a) {
      return typeof a != "string" ? (e(k.isBuffer(a), "value", "buffer"), e(a.length === 32, "value", "32-byte hash"), this.writeBytes(a), this) : (e(a.length === 64, "value", "32-byte hash"), this.check(32), this.offset += this.data.write(a, this.offset, "hex"), this);
    }
    /**
     * Write a string with a varint length before it.
     * @param {String}
     * @param {String?} enc - Any buffer-supported encoding.
     */
    writeVarString(a, s) {
      if (s == null && (s = "binary"), e(typeof a == "string", "value", "string"), e(typeof s == "string", "enc", "string"), a.length === 0)
        return this.writeVarint(0), this;
      const i = k.byteLength(a, s);
      return this.writeVarint(i), this.check(i), this.offset += this.data.write(a, this.offset, s), this;
    }
    /**
     * Write a null-terminated string.
     * @param {String|Buffer}
     * @param {String?} enc - Any buffer-supported encoding.
     */
    writeNullString(a, s) {
      return this.writeString(a, s), this.writeU8(0), this;
    }
    /**
     * Calculate and write a checksum for the data written so far.
     * @param {Function} hash
     */
    writeChecksum(a) {
      (!a || typeof a.digest != "function") && e(typeof a == "function", "hash", "function"), this.check(4);
      const s = this.data.slice(0, this.offset);
      return (a.digest ? a.digest(s) : a(s)).copy(this.data, this.offset, 0, 4), this.offset += 4, this;
    }
    /**
     * Fill N bytes with value.
     * @param {Number} value
     * @param {Number} size
     */
    fill(a, s) {
      return e((a & 255) === a, "value", "byte"), e(s >>> 0 === s, "size", "integer"), this.check(s), this.data.fill(a, this.offset, this.offset + s), this.offset += s, this;
    }
  }
  return No = n, No;
}
var qo, Fl;
function D7() {
  if (Fl) return qo;
  Fl = 1;
  const e = fn(), c = Ts(), d = Cs(), w = n8(), { custom: g } = i8();
  class f {
    constructor() {
    }
    inject(a) {
      return e(a instanceof this.constructor, "obj", "struct"), this.decode(a.encode());
    }
    clone() {
      return new this.constructor().inject(this);
    }
    /*
     * Bindable
     */
    getSize(a) {
      return -1;
    }
    write(a, s) {
      return a;
    }
    read(a, s) {
      return this;
    }
    toString() {
      return Object.prototype.toString.call(this);
    }
    fromString(a, s) {
      return this;
    }
    getJSON() {
      return this;
    }
    fromJSON(a, s) {
      return this;
    }
    fromOptions(a, s) {
      return this;
    }
    from(a, s) {
      return this.fromOptions(a, s);
    }
    format() {
      return this.getJSON();
    }
    /*
     * API
     */
    encode(a) {
      const s = this.getSize(a), i = s === -1 ? new d() : new w(s);
      return this.write(i, a), i.render();
    }
    decode(a, s) {
      const i = new c(a);
      return this.read(i, s), this;
    }
    toHex(a) {
      return this.encode(a).toString("hex");
    }
    fromHex(a, s) {
      e(typeof a == "string", "str", "string");
      const i = a.length >>> 1, p = k.from(a, "hex");
      if (p.length !== i)
        throw new Error("Invalid hex string.");
      return this.decode(p, s);
    }
    toBase64(a) {
      return this.encode(a).toString("base64");
    }
    fromBase64(a, s) {
      e(typeof a == "string", "str", "string");
      const i = k.from(a, "base64");
      if (a.length > n(i.length))
        throw new Error("Invalid base64 string.");
      return this.decode(i, s);
    }
    toJSON() {
      return this.getJSON();
    }
    [g]() {
      return this.format();
    }
    /*
     * Static API
     */
    static read(a, s) {
      return new this().read(a, s);
    }
    static decode(a, s) {
      return new this().decode(a, s);
    }
    static fromHex(a, s) {
      return new this().fromHex(a, s);
    }
    static fromBase64(a, s) {
      return new this().fromBase64(a, s);
    }
    static fromString(a, s) {
      return new this().fromString(a, s);
    }
    static fromJSON(a, s) {
      return new this().fromJSON(a, s);
    }
    static fromOptions(a, s) {
      return new this().fromOptions(a, s);
    }
    static from(a, s) {
      return new this().from(a, s);
    }
    /*
     * Aliases
     */
    toWriter(a, s) {
      return this.write(a, s);
    }
    fromReader(a, s) {
      return this.read(a, s);
    }
    toRaw(a) {
      return this.encode(a);
    }
    fromRaw(a, s) {
      return this.decode(a, s);
    }
    /*
     * Static Aliases
     */
    static fromReader(a, s) {
      return this.read(a, s);
    }
    static fromRaw(a, s) {
      return this.decode(a, s);
    }
  }
  function n(u) {
    return (4 * u / 3 + 3 & -4) >>> 0;
  }
  return qo = f, qo;
}
var Hl;
function At() {
  if (Hl) return ze;
  Hl = 1;
  const e = i8(), c = zs(), d = fn(), w = Ln(), g = Ts(), f = Cs(), n = n8(), u = D7();
  ze.custom = e, ze.encoding = c, ze.EncodingError = w, ze.BufferReader = g, ze.BufferWriter = f, ze.StaticWriter = n, ze.Struct = u, ze.read = function(b, h) {
    return new g(b, h);
  }, ze.write = function(b) {
    return b != null ? new n(b) : new f();
  }, ze.pool = function(b) {
    return n.pool(b);
  };
  function a(v, b) {
    return function(h, o) {
      if (d(k.isBuffer(h), "data", "buffer"), d(o >>> 0 === o, "off", "integer"), o + b > h.length)
        throw new w(o, "Out of bounds read");
      return v(h, o);
    };
  }
  function s(v) {
    return function(b, h, o) {
      if (d(k.isBuffer(b), "data", "buffer"), d(h >>> 0 === h, "off", "integer"), d(o >>> 0 === o, "len", "integer"), h + o > b.length)
        throw new w(h, "Out of bounds read");
      return v(b, h, o);
    };
  }
  function i(v) {
    return function(b, h) {
      return d(k.isBuffer(b), "data", "buffer"), d(h >>> 0 === h, "off", "integer"), v(b, h);
    };
  }
  function p(v, b) {
    return function(h, o, S) {
      if (d(k.isBuffer(h), "data", "buffer"), d(S >>> 0 === S, "off", "integer"), S + b > h.length)
        throw new w(S, "Out of bounds write");
      return v(h, o, S);
    };
  }
  function m(v) {
    return function(b, h, o, S) {
      if (d(k.isBuffer(b), "data", "buffer"), d(o >>> 0 === o, "off", "integer"), d(S >>> 0 === S, "len", "integer"), o + S > b.length)
        throw new w(o, "Out of bounds write");
      return v(b, h, o, S);
    };
  }
  function E(v, b) {
    return function(h, o, S) {
      if (d(k.isBuffer(h), "data", "buffer"), d(S >>> 0 === S, "off", "integer"), S + b(o) > h.length)
        throw new w(S, "Out of bounds write");
      return v(h, o, S);
    };
  }
  return ze.readU = s(c.readU), ze.readU64 = a(c.readU64, 8), ze.readU56 = a(c.readU56, 7), ze.readU48 = a(c.readU48, 6), ze.readU40 = a(c.readU40, 5), ze.readU32 = a(c.readU32, 4), ze.readU24 = a(c.readU24, 3), ze.readU16 = a(c.readU16, 2), ze.readU8 = a(c.readU8, 1), ze.readUBE = s(c.readUBE), ze.readU64BE = a(c.readU64BE, 8), ze.readU56BE = a(c.readU56BE, 7), ze.readU48BE = a(c.readU48BE, 6), ze.readU40BE = a(c.readU40BE, 5), ze.readU32BE = a(c.readU32BE, 4), ze.readU24BE = a(c.readU24BE, 3), ze.readU16BE = a(c.readU16BE, 2), ze.readI = s(c.readI), ze.readI64 = a(c.readI64, 8), ze.readI56 = a(c.readI56, 7), ze.readI48 = a(c.readI48, 6), ze.readI40 = a(c.readI40, 5), ze.readI32 = a(c.readI32, 4), ze.readI24 = a(c.readI24, 3), ze.readI16 = a(c.readI16, 2), ze.readI8 = a(c.readI8, 1), ze.readIBE = s(c.readIBE), ze.readI64BE = a(c.readI64BE, 8), ze.readI56BE = a(c.readI56BE, 7), ze.readI48BE = a(c.readI48BE, 6), ze.readI40BE = a(c.readI40BE, 5), ze.readI32BE = a(c.readI32BE, 4), ze.readI24BE = a(c.readI24BE, 3), ze.readI16BE = a(c.readI16BE, 2), ze.readFloat = a(c.readFloat, 4), ze.readFloatBE = a(c.readFloatBE, 4), ze.readDouble = a(c.readDouble, 8), ze.readDoubleBE = a(c.readDoubleBE, 8), ze.writeU = m(c.writeU), ze.writeU64 = p(c.writeU64, 8), ze.writeU56 = p(c.writeU56, 7), ze.writeU48 = p(c.writeU48, 6), ze.writeU40 = p(c.writeU40, 5), ze.writeU32 = p(c.writeU32, 4), ze.writeU24 = p(c.writeU24, 3), ze.writeU16 = p(c.writeU16, 2), ze.writeU8 = p(c.writeU8, 1), ze.writeUBE = m(c.writeUBE), ze.writeU64BE = p(c.writeU64BE, 8), ze.writeU56BE = p(c.writeU56BE, 7), ze.writeU48BE = p(c.writeU48BE, 6), ze.writeU40BE = p(c.writeU40BE, 5), ze.writeU32BE = p(c.writeU32BE, 4), ze.writeU24BE = p(c.writeU24BE, 3), ze.writeU16BE = p(c.writeU16BE, 2), ze.writeI = m(c.writeI), ze.writeI64 = p(c.writeI64, 8), ze.writeI56 = p(c.writeI56, 7), ze.writeI48 = p(c.writeI48, 6), ze.writeI40 = p(c.writeI40, 5), ze.writeI32 = p(c.writeI32, 4), ze.writeI24 = p(c.writeI24, 3), ze.writeI16 = p(c.writeI16, 2), ze.writeI8 = p(c.writeI8, 1), ze.writeIBE = m(c.writeIBE), ze.writeI64BE = p(c.writeI64BE, 8), ze.writeI56BE = p(c.writeI56BE, 7), ze.writeI48BE = p(c.writeI48BE, 6), ze.writeI40BE = p(c.writeI40BE, 5), ze.writeI32BE = p(c.writeI32BE, 4), ze.writeI24BE = p(c.writeI24BE, 3), ze.writeI16BE = p(c.writeI16BE, 2), ze.writeFloat = p(c.writeFloat, 4), ze.writeFloatBE = p(c.writeFloatBE, 4), ze.writeDouble = p(c.writeDouble, 8), ze.writeDoubleBE = p(c.writeDoubleBE, 8), ze.readVarint = i(c.readVarint), ze.writeVarint = E(c.writeVarint, c.sizeVarint), ze.sizeVarint = c.sizeVarint, ze.readVarint2 = i(c.readVarint2), ze.writeVarint2 = E(c.writeVarint2, c.sizeVarint2), ze.sizeVarint2 = c.sizeVarint2, ze.sliceBytes = c.sliceBytes, ze.readBytes = c.readBytes, ze.writeBytes = c.writeBytes, ze.readString = c.readString, ze.writeString = c.writeString, ze.realloc = c.realloc, ze.copy = c.copy, ze.concat = c.concat, ze.sizeVarBytes = c.sizeVarBytes, ze.sizeVarlen = c.sizeVarlen, ze.sizeVarString = c.sizeVarString, ze;
}
var U7 = At();
const kt = /* @__PURE__ */ Cr(U7);
var yn = {}, vn = {}, Ll;
function F7() {
  if (Ll) return vn;
  Ll = 1;
  const e = $e(), c = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz", d = [
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    16,
    -1,
    17,
    18,
    19,
    20,
    21,
    -1,
    22,
    23,
    24,
    25,
    26,
    27,
    28,
    29,
    30,
    31,
    32,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    33,
    34,
    35,
    36,
    37,
    38,
    39,
    40,
    41,
    42,
    43,
    -1,
    44,
    45,
    46,
    47,
    48,
    49,
    50,
    51,
    52,
    53,
    54,
    55,
    56,
    57,
    -1,
    -1,
    -1,
    -1,
    -1
  ];
  return vn.encode = function(g) {
    e(k.isBuffer(g));
    let f = 0, n = 0;
    for (; n < g.length && g[n] === 0; n++)
      f += 1;
    const u = k.allocUnsafe((g.length * 138 / 100 | 0) + 1);
    u.fill(0);
    let a = 0;
    for (; n < g.length; n++) {
      let i = g[n], p = 0;
      for (let m = u.length - 1; m >= 0 && !(i === 0 && p >= a); m--, p++)
        i += 256 * u[m], u[m] = i % 58, i = i / 58 | 0;
      e(i === 0), a = p;
    }
    for (n = u.length - a; n < u.length && u[n] === 0; )
      n += 1;
    let s = "";
    for (let i = 0; i < f; i++)
      s += "1";
    for (; n < u.length; n++)
      s += c[u[n]];
    return s;
  }, vn.decode = function(g) {
    e(typeof g == "string");
    let f = 0, n = 0;
    for (; n < g.length && g[n] === "1"; n++)
      f += 1;
    const u = k.allocUnsafe((g.length * 733 / 1e3 | 0) + 1);
    u.fill(0);
    let a = 0;
    for (; n < g.length; n++) {
      const p = g.charCodeAt(n), m = p & 65408 ? -1 : d[p];
      if (m === -1)
        throw new Error("Non-base58 character.");
      let E = m, v = 0;
      for (let b = u.length - 1; b >= 0 && !(E === 0 && v >= a); b--, v++)
        E += 58 * u[b], u[b] = E & 255, E >>>= 8;
      e(E === 0), a = v;
    }
    for (n = 0; n < u.length && u[n] === 0; )
      n += 1;
    const s = k.allocUnsafe(f + (u.length - n));
    let i;
    for (i = 0; i < f; i++)
      s[i] = 0;
    for (; n < u.length; )
      s[i++] = u[n++];
    return s;
  }, vn.test = function(g) {
    if (typeof g != "string")
      return !1;
    for (let f = 0; f < g.length; f++) {
      const n = g.charCodeAt(f);
      if (n & 65408 || d[n] === -1)
        return !1;
    }
    return !0;
  }, vn;
}
var Xr = {}, Kl;
function H7() {
  if (Kl) return Xr;
  Kl = 1;
  const e = $e(), c = k.allocUnsafe(66), d = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", w = [
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    15,
    -1,
    10,
    17,
    21,
    20,
    26,
    30,
    7,
    5,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    29,
    -1,
    24,
    13,
    25,
    9,
    8,
    23,
    -1,
    18,
    22,
    31,
    27,
    19,
    -1,
    1,
    0,
    3,
    16,
    11,
    28,
    12,
    14,
    6,
    4,
    2,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    29,
    -1,
    24,
    13,
    25,
    9,
    8,
    23,
    -1,
    18,
    22,
    31,
    27,
    19,
    -1,
    1,
    0,
    3,
    16,
    11,
    28,
    12,
    14,
    6,
    4,
    2,
    -1,
    -1,
    -1,
    -1,
    -1
  ];
  function g(b) {
    const h = b >>> 25;
    return (b & 33554431) << 5 ^ -(h >>> 0 & 1) & 996825010 ^ -(h >>> 1 & 1) & 642813549 ^ -(h >>> 2 & 1) & 513874426 ^ -(h >>> 3 & 1) & 1027748829 ^ -(h >>> 4 & 1) & 705979059;
  }
  function f(b, h) {
    e(typeof b == "string"), e(k.isBuffer(h));
    let o = 1, S;
    for (S = 0; S < b.length; S++) {
      const j = b.charCodeAt(S);
      if (j & 65280 || !(j >>> 5))
        throw new Error("Invalid bech32 character.");
      o = g(o) ^ j >>> 5;
    }
    if (S + 7 + h.length > 90)
      throw new Error("Invalid bech32 data length.");
    o = g(o);
    let H = "";
    for (let j = 0; j < b.length; j++) {
      const J = b.charCodeAt(j);
      o = g(o) ^ J & 31, H += b[j];
    }
    H += "1";
    for (let j = 0; j < h.length; j++) {
      const J = h[j];
      if (J >>> 5)
        throw new Error("Invalid bech32 value.");
      o = g(o) ^ J, H += d[J];
    }
    for (let j = 0; j < 6; j++)
      o = g(o);
    o ^= 1;
    for (let j = 0; j < 6; j++)
      H += d[o >>> (5 - j) * 5 & 31];
    return H;
  }
  function n(b) {
    if (e(typeof b == "string"), b.length < 8 || b.length > 90)
      throw new Error("Invalid bech32 string length.");
    let h = 0;
    for (; h < b.length && b[b.length - 1 - h] !== "1"; )
      h += 1;
    const o = b.length - (1 + h);
    if (1 + h >= b.length || h < 6)
      throw new Error("Invalid bech32 data length.");
    h -= 6;
    const S = k.allocUnsafe(h);
    let H = 1, j = !1, J = !1, N = "";
    for (let A = 0; A < o; A++) {
      let q = b.charCodeAt(A);
      if (q < 33 || q > 126)
        throw new Error("Invalid bech32 character.");
      q >= 97 && q <= 122 ? j = !0 : q >= 65 && q <= 90 && (J = !0, q = q - 65 + 97), N += String.fromCharCode(q), H = g(H) ^ q >>> 5;
    }
    H = g(H);
    let z;
    for (z = 0; z < o; z++)
      H = g(H) ^ b.charCodeAt(z) & 31;
    for (z += 1; z < b.length; ) {
      const A = b.charCodeAt(z), q = A & 65408 ? -1 : w[A];
      if (q === -1)
        throw new Error("Invalid bech32 character.");
      A >= 97 && A <= 122 ? j = !0 : A >= 65 && A <= 90 && (J = !0), H = g(H) ^ q, z + 6 < b.length && (S[z - (1 + o)] = q), z += 1;
    }
    if (j && J)
      throw new Error("Invalid bech32 casing.");
    if (H !== 1)
      throw new Error("Invalid bech32 checksum.");
    return [N, S.slice(0, h)];
  }
  function u(b) {
    if (typeof b != "string")
      return !1;
    try {
      n(b);
    } catch {
      return !1;
    }
    return !0;
  }
  function a(b, h, o, S, H, j, J) {
    e(k.isBuffer(b)), e(h >>> 0 === h), e(k.isBuffer(o)), e(S >>> 0 === S), e((H & 255) === H), e((j & 255) === j), e(typeof J == "boolean");
    const N = (1 << j) - 1;
    let z = 0, A = 0;
    for (; h < b.length; h++) {
      const q = b[h];
      if (q >>> H)
        throw new Error("Invalid bits.");
      for (z = z << H | q, A += H; A >= j; )
        A -= j, o[S++] = z >>> A & N;
    }
    if (J)
      A && (o[S++] = z << j - A & N);
    else if (A >= H || z << j - A & N)
      throw new Error("Invalid bits.");
    return e(S <= o.length), o.slice(0, S);
  }
  function s(b, h, o, S) {
    e(b >>> 0 === b), e((h & 255) === h), e((o & 255) === o), e(typeof S == "boolean"), e(o !== 0);
    let H = (b * h + (o - 1)) / o;
    return H >>>= 0, S && (H += 1), H;
  }
  function i(b, h, o, S) {
    e(k.isBuffer(b)), e((h & 255) === h), e((o & 255) === o), e(typeof S == "boolean");
    const H = s(b.length, h, o, S), j = k.allocUnsafe(H);
    return a(b, 0, j, 0, h, o, S);
  }
  function p(b, h, o) {
    if (e(typeof b == "string"), e((h & 255) === h), e(k.isBuffer(o)), h < 0 || h > 31)
      throw new Error("Invalid bech32 version.");
    if (o.length < 2 || o.length > 40)
      throw new Error("Invalid bech32 data length.");
    const S = c;
    S[0] = h;
    const H = a(o, 0, S, 1, 8, 5, !0);
    return f(b, H);
  }
  function m(b) {
    e(typeof b == "string");
    const [h, o] = n(b);
    if (o.length === 0 || o.length > 65)
      throw new Error("Invalid bech32 data length.");
    const S = o[0];
    if (S > 31)
      throw new Error("Invalid bech32 version.");
    const H = a(o, 1, o, 0, 5, 8, !1);
    if (H.length < 2 || H.length > 40)
      throw new Error("Invalid bech32 data length.");
    return new v(h, S, H);
  }
  function E(b) {
    if (typeof b != "string")
      return !1;
    let h;
    try {
      [, h] = n(b);
    } catch {
      return !1;
    }
    return !(h.length === 0 || h.length > 65 || h[0] > 31);
  }
  class v {
    constructor(h, o, S) {
      this.hrp = h, this.version = o, this.hash = S;
    }
  }
  return Xr.serialize = f, Xr.deserialize = n, Xr.is = u, Xr.convertBits = i, Xr.encode = p, Xr.decode = m, Xr.test = E, Xr;
}
var Sn = {}, Vl;
function L7() {
  if (Vl) return Sn;
  Vl = 1;
  const e = $e();
  class c {
    constructor(o, S) {
      this.hi = o | 0, this.lo = S | 0;
    }
    ushrn32(o) {
      o &= 63;
      let S = this.lo;
      return o === 0 || (o < 32 ? (S >>>= o, S |= this.hi << 32 - o) : S = this.hi >>> o - 32), S;
    }
  }
  const d = k.allocUnsafe(105), w = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", g = [
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    15,
    -1,
    10,
    17,
    21,
    20,
    26,
    30,
    7,
    5,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    29,
    -1,
    24,
    13,
    25,
    9,
    8,
    23,
    -1,
    18,
    22,
    31,
    27,
    19,
    -1,
    1,
    0,
    3,
    16,
    11,
    28,
    12,
    14,
    6,
    4,
    2,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    29,
    -1,
    24,
    13,
    25,
    9,
    8,
    23,
    -1,
    18,
    22,
    31,
    27,
    19,
    -1,
    1,
    0,
    3,
    16,
    11,
    28,
    12,
    14,
    6,
    4,
    2,
    -1,
    -1,
    -1,
    -1,
    -1
  ], f = new c(7, 4294967295), n = [
    new c(152, 4072443489),
    new c(121, 3077413346),
    new c(243, 1046459332),
    new c(174, 783016616),
    new c(30, 1329849456)
  ];
  function u(h, o) {
    const S = h, H = S.hi >>> 3;
    S.hi &= f.hi, S.lo &= f.lo, S.hi <<= 5, S.hi |= S.lo >>> 27, S.lo <<= 5;
    for (let j = 0; j < n.length; j++)
      H >>> j & 1 && (S.hi ^= n[j].hi, S.lo ^= n[j].lo);
    return S.lo ^= o, S;
  }
  function a(h, o) {
    e(typeof h == "string"), e(k.isBuffer(o));
    const S = new c(0, 1);
    let H = "", j = !1, J = !1;
    for (let N = 0; N < h.length; N++) {
      let z = h.charCodeAt(N);
      if (z & 65280 || !(z >>> 5))
        throw new Error("Invalid cashaddr character.");
      if (z >= 97 && z <= 122)
        J = !0;
      else if (z >= 65 && z <= 90)
        j = !0, z = z - 65 + 97;
      else if (z >= 48 && z <= 57)
        throw new Error("Invalid cashaddr prefix.");
      u(S, z & 31), H += String.fromCharCode(z);
    }
    if (J && j)
      throw new Error("Invalid cashaddr prefix.");
    u(S, 0), H += ":";
    for (let N = 0; N < o.length; N++) {
      const z = o[N];
      if (z >>> 5)
        throw new Error("Invalid cashaddr value.");
      u(S, z), H += w[z];
    }
    for (let N = 0; N < 8; N++)
      u(S, 0);
    S.lo ^= 1;
    for (let N = 0; N < 8; N++) {
      const z = S.ushrn32((7 - N) * 5) & 31;
      H += w[z];
    }
    return H;
  }
  function s(h, o) {
    if (e(typeof h == "string"), h.length < 8 || h.length > 196)
      throw new Error("Invalid cashaddr data length.");
    let S = !1, H = !1, j = !1, J = 0;
    for (let F = 0; F < h.length; F++) {
      const R = h.charCodeAt(F);
      if (R >= 97 && R <= 122) {
        S = !0;
        continue;
      }
      if (R >= 65 && R <= 90) {
        H = !0;
        continue;
      }
      if (R >= 48 && R <= 57) {
        j = !0;
        continue;
      }
      if (R === 58) {
        if (j || F === 0 || F > 83)
          throw new Error("Invalid cashaddr prefix.");
        if (J !== 0)
          throw new Error("Invalid cashaddr separators.");
        J = F;
        continue;
      }
      throw new Error("Invalid cashaddr character.");
    }
    if (H && S)
      throw new Error("Invalid cashaddr casing.");
    const N = new c(0, 1);
    let z;
    J === 0 ? z = o.toLowerCase() : (z = h.substring(0, J).toLowerCase(), J += 1);
    for (let F = 0; F < z.length; F++) {
      const R = z.charCodeAt(F);
      u(N, (R | 32) & 31);
    }
    u(N, 0);
    const A = h.length - J;
    if (A <= 8 || A > 112)
      throw new Error("Invalid cashaddr data length.");
    const q = k.allocUnsafe(A);
    for (let F = J; F < h.length; F++) {
      const R = h.charCodeAt(F), V = R & 65408 ? -1 : g[R];
      if (V === -1)
        throw new Error("Invalid cashaddr character.");
      u(N, V), F + 8 < h.length && (q[F - J] = V);
    }
    if (!(N.hi === 0 && N.lo === 1 && z === o))
      throw new Error("Invalid cashaddr checksum.");
    return [z, q.slice(0, -8)];
  }
  function i(h, o, S, H, j, J, N) {
    e(k.isBuffer(h)), e(o >>> 0 === o), e(k.isBuffer(S)), e(H >>> 0 === H), e((j & 255) === j), e((J & 255) === J), e(typeof N == "boolean");
    const z = (1 << J) - 1;
    let A = 0, q = 0;
    for (; o < h.length; o++) {
      const _ = h[o];
      if (_ >>> j)
        throw new Error("Invalid bits.");
      for (A = A << j | _, q += j; q >= J; )
        q -= J, S[H++] = A >>> q & z;
    }
    if (N)
      q && (S[H++] = A << J - q & z);
    else if (q >= j || A << J - q & z)
      throw new Error("Invalid bits.");
    return e(H <= S.length), S.slice(0, H);
  }
  function p(h) {
    switch (e(h >>> 0 === h), h) {
      case 20:
        return 0;
      case 24:
        return 1;
      case 28:
        return 2;
      case 32:
        return 3;
      case 40:
        return 4;
      case 48:
        return 5;
      case 56:
        return 6;
      case 64:
        return 7;
      default:
        throw new Error("Non standard length.");
    }
  }
  function m(h, o, S) {
    if (e(typeof h == "string"), e((o & 15) === o, "Invalid cashaddr type."), e(k.isBuffer(S)), h.length === 0 || h.length > 83)
      throw new Error("Invalid cashaddr prefix.");
    const H = p(S.length), j = k.allocUnsafe(S.length + 1);
    j[0] = o << 3 | H, S.copy(j, 1);
    const N = i(j, 0, d, 0, 8, 5, !0);
    return a(h, N);
  }
  function E(h, o = "bitcoincash") {
    e(typeof h == "string"), e(typeof o == "string");
    const [S, H] = s(h, o), j = H.length * 5 & 7;
    if (j >= 5)
      throw new Error("Invalid padding in data.");
    const J = H[H.length - 1], N = (1 << j) - 1;
    if (J & N)
      throw new Error("Non zero padding.");
    const A = i(H, 0, H, 0, 5, 8, !1), q = A[0] >>> 3 & 31, _ = A.slice(1);
    let F = 20 + 4 * (A[0] & 3);
    if (A[0] & 4 && (F *= 2), F !== _.length)
      throw new Error("Invalid cashaddr data length.");
    return new b(S, q, _);
  }
  function v(h, o = "bitcoincash") {
    try {
      E(h, o);
    } catch {
      return !1;
    }
    return !0;
  }
  class b {
    constructor(o, S, H) {
      this.prefix = o, this.type = S, this.hash = H;
    }
  }
  return Sn.encode = m, Sn.decode = E, Sn.test = v, Sn;
}
/*!
 * bstring
 * Copyright (c) 2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bstring
 */
var $l;
function cn() {
  return $l || ($l = 1, yn.base58 = F7(), yn.bech32 = H7(), yn.cashaddr = L7()), yn;
}
var K7 = cn();
const Ds = /* @__PURE__ */ Cr(K7);
var En = {}, os = {}, jl;
function Ih() {
  if (jl) return os;
  jl = 1;
  /**
   * @license
   * https://reviews.bitcoinabc.org
   * Copyright (c) 2017-2020 Emilio Almansi
   * Copyright (c) 2023 Bitcoin ABC
   * Distributed under the MIT software license, see the accompanying
   * file LICENSE or http://www.opensource.org/licenses/mit-license.php.
   */
  Object.defineProperty(os, "__esModule", { value: !0 });
  class e extends Error {
    constructor(w) {
      super(w), this.name = "ValidationError", Object.setPrototypeOf(this, e.prototype);
    }
  }
  function c(d, w) {
    if (!d)
      throw new e(w);
  }
  return os.default = {
    ValidationError: e,
    validate: c
  }, os;
}
var Yl;
function V7() {
  return Yl || (Yl = 1, function(e) {
    /**
     * @license
     * https://reviews.bitcoinabc.org
     * Copyright (c) 2017-2020 Emilio Almansi
     * Copyright (c) 2023-2024 Bitcoin ABC
     * Distributed under the MIT software license, see the accompanying
     * file LICENSE or http://www.opensource.org/licenses/mit-license.php.
     */
    var c = En && En.__importDefault || function(u) {
      return u && u.__esModule ? u : { default: u };
    };
    Object.defineProperty(e, "__esModule", { value: !0 }), e.CHARSET = void 0;
    const d = c(Ih()), { validate: w } = d.default;
    e.CHARSET = "qpzry9x8gf2tvdw0s3jn54khce6mua7l";
    const g = {
      q: 0,
      p: 1,
      z: 2,
      r: 3,
      y: 4,
      9: 5,
      x: 6,
      8: 7,
      g: 8,
      f: 9,
      2: 10,
      t: 11,
      v: 12,
      d: 13,
      w: 14,
      0: 15,
      s: 16,
      3: 17,
      j: 18,
      n: 19,
      5: 20,
      4: 21,
      k: 22,
      h: 23,
      c: 24,
      e: 25,
      6: 26,
      m: 27,
      u: 28,
      a: 29,
      7: 30,
      l: 31
    };
    function f(u) {
      w(u instanceof Uint8Array, "Invalid data: " + u + ".");
      let a = "";
      for (let s = 0; s < u.length; ++s) {
        const i = u[s];
        w(0 <= i && i < 32, "Invalid value: " + i + "."), a += e.CHARSET[i];
      }
      return a;
    }
    function n(u) {
      w(typeof u == "string", "Invalid base32-encoded string: " + u + ".");
      const a = new Uint8Array(u.length);
      for (let s = 0; s < u.length; ++s) {
        const i = u[s];
        w(i in g, "Invalid value: " + i + "."), a[s] = g[i];
      }
      return a;
    }
    e.default = {
      encode: f,
      decode: n
    };
  }(En)), En;
}
var Vi = {}, Xl;
function $7() {
  if (Xl) return Vi;
  Xl = 1;
  var e = Vi && Vi.__importDefault || function(g) {
    return g && g.__esModule ? g : { default: g };
  };
  Object.defineProperty(Vi, "__esModule", { value: !0 }), Vi.default = w;
  const c = e(Ih()), { validate: d } = c.default;
  function w(g, f, n, u = !1) {
    const a = u ? Math.floor(g.length * f / n) : Math.ceil(g.length * f / n), s = (1 << n) - 1, i = new Uint8Array(a);
    let p = 0, m = 0, E = 0;
    for (let v = 0; v < g.length; ++v) {
      const b = g[v];
      for (d(0 <= b && b >> f === 0, "Invalid value: " + b + "."), m = m << f | b, E += f; E >= n; )
        E -= n, i[p] = m >> E & s, ++p;
    }
    return u ? d(E < f && (m << n - E & s) === 0, "Input cannot be converted to " + n + " bits without padding, but strict mode was used.") : E > 0 && (i[p] = m << n - E & s, ++p), i;
  }
  return Vi;
}
var zo = { exports: {} }, Jl;
function j7() {
  return Jl || (Jl = 1, function(e) {
    var c = function(d) {
      var w = 1e7, g = 7, f = 9007199254740992, n = m(f), u = Math.log(f);
      function a(P, K) {
        return typeof P > "u" ? a[0] : typeof K < "u" ? +K == 10 ? L(P) : G(P, K) : L(P);
      }
      function s(P, K) {
        this.value = P, this.sign = K, this.isSmall = !1;
      }
      s.prototype = Object.create(a.prototype);
      function i(P) {
        this.value = P, this.sign = P < 0, this.isSmall = !0;
      }
      i.prototype = Object.create(a.prototype);
      function p(P) {
        return -f < P && P < f;
      }
      function m(P) {
        return P < 1e7 ? [P] : P < 1e14 ? [P % 1e7, Math.floor(P / 1e7)] : [P % 1e7, Math.floor(P / 1e7) % 1e7, Math.floor(P / 1e14)];
      }
      function E(P) {
        v(P);
        var K = P.length;
        if (K < 4 && Q(P, n) < 0)
          switch (K) {
            case 0:
              return 0;
            case 1:
              return P[0];
            case 2:
              return P[0] + P[1] * w;
            default:
              return P[0] + (P[1] + P[2] * w) * w;
          }
        return P;
      }
      function v(P) {
        for (var K = P.length; P[--K] === 0; ) ;
        P.length = K + 1;
      }
      function b(P) {
        for (var K = new Array(P), re = -1; ++re < P; )
          K[re] = 0;
        return K;
      }
      function h(P) {
        return P > 0 ? Math.floor(P) : Math.ceil(P);
      }
      function o(P, K) {
        var re = P.length, ce = K.length, le = new Array(re), me = 0, ne = w, W, te;
        for (te = 0; te < ce; te++)
          W = P[te] + K[te] + me, me = W >= ne ? 1 : 0, le[te] = W - me * ne;
        for (; te < re; )
          W = P[te] + me, me = W === ne ? 1 : 0, le[te++] = W - me * ne;
        return me > 0 && le.push(me), le;
      }
      function S(P, K) {
        return P.length >= K.length ? o(P, K) : o(K, P);
      }
      function H(P, K) {
        var re = P.length, ce = new Array(re), le = w, me, ne;
        for (ne = 0; ne < re; ne++)
          me = P[ne] - le + K, K = Math.floor(me / le), ce[ne] = me - K * le, K += 1;
        for (; K > 0; )
          ce[ne++] = K % le, K = Math.floor(K / le);
        return ce;
      }
      s.prototype.add = function(P) {
        var K = L(P);
        if (this.sign !== K.sign)
          return this.subtract(K.negate());
        var re = this.value, ce = K.value;
        return K.isSmall ? new s(H(re, Math.abs(ce)), this.sign) : new s(S(re, ce), this.sign);
      }, s.prototype.plus = s.prototype.add, i.prototype.add = function(P) {
        var K = L(P), re = this.value;
        if (re < 0 !== K.sign)
          return this.subtract(K.negate());
        var ce = K.value;
        if (K.isSmall) {
          if (p(re + ce)) return new i(re + ce);
          ce = m(Math.abs(ce));
        }
        return new s(H(ce, Math.abs(re)), re < 0);
      }, i.prototype.plus = i.prototype.add;
      function j(P, K) {
        var re = P.length, ce = K.length, le = new Array(re), me = 0, ne = w, W, te;
        for (W = 0; W < ce; W++)
          te = P[W] - me - K[W], te < 0 ? (te += ne, me = 1) : me = 0, le[W] = te;
        for (W = ce; W < re; W++) {
          if (te = P[W] - me, te < 0) te += ne;
          else {
            le[W++] = te;
            break;
          }
          le[W] = te;
        }
        for (; W < re; W++)
          le[W] = P[W];
        return v(le), le;
      }
      function J(P, K, re) {
        var ce;
        return Q(P, K) >= 0 ? ce = j(P, K) : (ce = j(K, P), re = !re), ce = E(ce), typeof ce == "number" ? (re && (ce = -ce), new i(ce)) : new s(ce, re);
      }
      function N(P, K, re) {
        var ce = P.length, le = new Array(ce), me = -K, ne = w, W, te;
        for (W = 0; W < ce; W++)
          te = P[W] + me, me = Math.floor(te / ne), te %= ne, le[W] = te < 0 ? te + ne : te;
        return le = E(le), typeof le == "number" ? (re && (le = -le), new i(le)) : new s(le, re);
      }
      s.prototype.subtract = function(P) {
        var K = L(P);
        if (this.sign !== K.sign)
          return this.add(K.negate());
        var re = this.value, ce = K.value;
        return K.isSmall ? N(re, Math.abs(ce), this.sign) : J(re, ce, this.sign);
      }, s.prototype.minus = s.prototype.subtract, i.prototype.subtract = function(P) {
        var K = L(P), re = this.value;
        if (re < 0 !== K.sign)
          return this.add(K.negate());
        var ce = K.value;
        return K.isSmall ? new i(re - ce) : N(ce, Math.abs(re), re >= 0);
      }, i.prototype.minus = i.prototype.subtract, s.prototype.negate = function() {
        return new s(this.value, !this.sign);
      }, i.prototype.negate = function() {
        var P = this.sign, K = new i(-this.value);
        return K.sign = !P, K;
      }, s.prototype.abs = function() {
        return new s(this.value, !1);
      }, i.prototype.abs = function() {
        return new i(Math.abs(this.value));
      };
      function z(P, K) {
        var re = P.length, ce = K.length, le = re + ce, me = b(le), ne = w, W, te, pe, Ee, Ae;
        for (pe = 0; pe < re; ++pe) {
          Ee = P[pe];
          for (var Oe = 0; Oe < ce; ++Oe)
            Ae = K[Oe], W = Ee * Ae + me[pe + Oe], te = Math.floor(W / ne), me[pe + Oe] = W - te * ne, me[pe + Oe + 1] += te;
        }
        return v(me), me;
      }
      function A(P, K) {
        var re = P.length, ce = new Array(re), le = w, me = 0, ne, W;
        for (W = 0; W < re; W++)
          ne = P[W] * K + me, me = Math.floor(ne / le), ce[W] = ne - me * le;
        for (; me > 0; )
          ce[W++] = me % le, me = Math.floor(me / le);
        return ce;
      }
      function q(P, K) {
        for (var re = []; K-- > 0; ) re.push(0);
        return re.concat(P);
      }
      function _(P, K) {
        var re = Math.max(P.length, K.length);
        if (re <= 30) return z(P, K);
        re = Math.ceil(re / 2);
        var ce = P.slice(re), le = P.slice(0, re), me = K.slice(re), ne = K.slice(0, re), W = _(le, ne), te = _(ce, me), pe = _(S(le, ce), S(ne, me)), Ee = S(S(W, q(j(j(pe, W), te), re)), q(te, 2 * re));
        return v(Ee), Ee;
      }
      function F(P, K) {
        return -0.012 * P - 0.012 * K + 15e-6 * P * K > 0;
      }
      s.prototype.multiply = function(P) {
        var K = L(P), re = this.value, ce = K.value, le = this.sign !== K.sign, me;
        if (K.isSmall) {
          if (ce === 0) return a[0];
          if (ce === 1) return this;
          if (ce === -1) return this.negate();
          if (me = Math.abs(ce), me < w)
            return new s(A(re, me), le);
          ce = m(me);
        }
        return F(re.length, ce.length) ? new s(_(re, ce), le) : new s(z(re, ce), le);
      }, s.prototype.times = s.prototype.multiply;
      function R(P, K, re) {
        return P < w ? new s(A(K, P), re) : new s(z(K, m(P)), re);
      }
      i.prototype._multiplyBySmall = function(P) {
        return p(P.value * this.value) ? new i(P.value * this.value) : R(Math.abs(P.value), m(Math.abs(this.value)), this.sign !== P.sign);
      }, s.prototype._multiplyBySmall = function(P) {
        return P.value === 0 ? a[0] : P.value === 1 ? this : P.value === -1 ? this.negate() : R(Math.abs(P.value), this.value, this.sign !== P.sign);
      }, i.prototype.multiply = function(P) {
        return L(P)._multiplyBySmall(this);
      }, i.prototype.times = i.prototype.multiply;
      function V(P) {
        var K = P.length, re = b(K + K), ce = w, le, me, ne, W, te;
        for (ne = 0; ne < K; ne++) {
          W = P[ne], me = 0 - W * W;
          for (var pe = ne; pe < K; pe++)
            te = P[pe], le = 2 * (W * te) + re[ne + pe] + me, me = Math.floor(le / ce), re[ne + pe] = le - me * ce;
          re[ne + K] = me;
        }
        return v(re), re;
      }
      s.prototype.square = function() {
        return new s(V(this.value), !1);
      }, i.prototype.square = function() {
        var P = this.value * this.value;
        return p(P) ? new i(P) : new s(V(m(Math.abs(this.value))), !1);
      };
      function fe(P, K) {
        var re = P.length, ce = K.length, le = w, me = b(K.length), ne = K[ce - 1], W = Math.ceil(le / (2 * ne)), te = A(P, W), pe = A(K, W), Ee, Ae, Oe, Be, ke, Ne, Ke;
        for (te.length <= re && te.push(0), pe.push(0), ne = pe[ce - 1], Ae = re - ce; Ae >= 0; Ae--) {
          for (Ee = le - 1, te[Ae + ce] !== ne && (Ee = Math.floor((te[Ae + ce] * le + te[Ae + ce - 1]) / ne)), Oe = 0, Be = 0, Ne = pe.length, ke = 0; ke < Ne; ke++)
            Oe += Ee * pe[ke], Ke = Math.floor(Oe / le), Be += te[Ae + ke] - (Oe - Ke * le), Oe = Ke, Be < 0 ? (te[Ae + ke] = Be + le, Be = -1) : (te[Ae + ke] = Be, Be = 0);
          for (; Be !== 0; ) {
            for (Ee -= 1, Oe = 0, ke = 0; ke < Ne; ke++)
              Oe += te[Ae + ke] - le + pe[ke], Oe < 0 ? (te[Ae + ke] = Oe + le, Oe = 0) : (te[Ae + ke] = Oe, Oe = 1);
            Be += Oe;
          }
          me[Ae] = Ee;
        }
        return te = ae(te, W)[0], [E(me), E(te)];
      }
      function ue(P, K) {
        for (var re = P.length, ce = K.length, le = [], me = [], ne = w, W, te, pe, Ee, Ae; re; ) {
          if (me.unshift(P[--re]), v(me), Q(me, K) < 0) {
            le.push(0);
            continue;
          }
          te = me.length, pe = me[te - 1] * ne + me[te - 2], Ee = K[ce - 1] * ne + K[ce - 2], te > ce && (pe = (pe + 1) * ne), W = Math.ceil(pe / Ee);
          do {
            if (Ae = A(K, W), Q(Ae, me) <= 0) break;
            W--;
          } while (W);
          le.push(W), me = j(me, Ae);
        }
        return le.reverse(), [E(le), E(me)];
      }
      function ae(P, K) {
        var re = P.length, ce = b(re), le = w, me, ne, W, te;
        for (W = 0, me = re - 1; me >= 0; --me)
          te = W * le + P[me], ne = h(te / K), W = te - ne * K, ce[me] = ne | 0;
        return [ce, W | 0];
      }
      function D(P, K) {
        var re, ce = L(K), le = P.value, me = ce.value, ne;
        if (me === 0) throw new Error("Cannot divide by zero");
        if (P.isSmall)
          return ce.isSmall ? [new i(h(le / me)), new i(le % me)] : [a[0], P];
        if (ce.isSmall) {
          if (me === 1) return [P, a[0]];
          if (me == -1) return [P.negate(), a[0]];
          var W = Math.abs(me);
          if (W < w) {
            re = ae(le, W), ne = E(re[0]);
            var te = re[1];
            return P.sign && (te = -te), typeof ne == "number" ? (P.sign !== ce.sign && (ne = -ne), [new i(ne), new i(te)]) : [new s(ne, P.sign !== ce.sign), new i(te)];
          }
          me = m(W);
        }
        var pe = Q(le, me);
        if (pe === -1) return [a[0], P];
        if (pe === 0) return [a[P.sign === ce.sign ? 1 : -1], a[0]];
        le.length + me.length <= 200 ? re = fe(le, me) : re = ue(le, me), ne = re[0];
        var Ee = P.sign !== ce.sign, Ae = re[1], Oe = P.sign;
        return typeof ne == "number" ? (Ee && (ne = -ne), ne = new i(ne)) : ne = new s(ne, Ee), typeof Ae == "number" ? (Oe && (Ae = -Ae), Ae = new i(Ae)) : Ae = new s(Ae, Oe), [ne, Ae];
      }
      s.prototype.divmod = function(P) {
        var K = D(this, P);
        return {
          quotient: K[0],
          remainder: K[1]
        };
      }, i.prototype.divmod = s.prototype.divmod, s.prototype.divide = function(P) {
        return D(this, P)[0];
      }, i.prototype.over = i.prototype.divide = s.prototype.over = s.prototype.divide, s.prototype.mod = function(P) {
        return D(this, P)[1];
      }, i.prototype.remainder = i.prototype.mod = s.prototype.remainder = s.prototype.mod, s.prototype.pow = function(P) {
        var K = L(P), re = this.value, ce = K.value, le, me, ne;
        if (ce === 0) return a[1];
        if (re === 0) return a[0];
        if (re === 1) return a[1];
        if (re === -1) return K.isEven() ? a[1] : a[-1];
        if (K.sign)
          return a[0];
        if (!K.isSmall) throw new Error("The exponent " + K.toString() + " is too large.");
        if (this.isSmall && p(le = Math.pow(re, ce)))
          return new i(h(le));
        for (me = this, ne = a[1]; ce & !0 && (ne = ne.times(me), --ce), ce !== 0; )
          ce /= 2, me = me.square();
        return ne;
      }, i.prototype.pow = s.prototype.pow, s.prototype.modPow = function(P, K) {
        if (P = L(P), K = L(K), K.isZero()) throw new Error("Cannot take modPow with modulus 0");
        for (var re = a[1], ce = this.mod(K); P.isPositive(); ) {
          if (ce.isZero()) return a[0];
          P.isOdd() && (re = re.multiply(ce).mod(K)), P = P.divide(2), ce = ce.square().mod(K);
        }
        return re;
      }, i.prototype.modPow = s.prototype.modPow;
      function Q(P, K) {
        if (P.length !== K.length)
          return P.length > K.length ? 1 : -1;
        for (var re = P.length - 1; re >= 0; re--)
          if (P[re] !== K[re]) return P[re] > K[re] ? 1 : -1;
        return 0;
      }
      s.prototype.compareAbs = function(P) {
        var K = L(P), re = this.value, ce = K.value;
        return K.isSmall ? 1 : Q(re, ce);
      }, i.prototype.compareAbs = function(P) {
        var K = L(P), re = Math.abs(this.value), ce = K.value;
        return K.isSmall ? (ce = Math.abs(ce), re === ce ? 0 : re > ce ? 1 : -1) : -1;
      }, s.prototype.compare = function(P) {
        if (P === 1 / 0)
          return -1;
        if (P === -1 / 0)
          return 1;
        var K = L(P), re = this.value, ce = K.value;
        return this.sign !== K.sign ? K.sign ? 1 : -1 : K.isSmall ? this.sign ? -1 : 1 : Q(re, ce) * (this.sign ? -1 : 1);
      }, s.prototype.compareTo = s.prototype.compare, i.prototype.compare = function(P) {
        if (P === 1 / 0)
          return -1;
        if (P === -1 / 0)
          return 1;
        var K = L(P), re = this.value, ce = K.value;
        return K.isSmall ? re == ce ? 0 : re > ce ? 1 : -1 : re < 0 !== K.sign ? re < 0 ? -1 : 1 : re < 0 ? 1 : -1;
      }, i.prototype.compareTo = i.prototype.compare, s.prototype.equals = function(P) {
        return this.compare(P) === 0;
      }, i.prototype.eq = i.prototype.equals = s.prototype.eq = s.prototype.equals, s.prototype.notEquals = function(P) {
        return this.compare(P) !== 0;
      }, i.prototype.neq = i.prototype.notEquals = s.prototype.neq = s.prototype.notEquals, s.prototype.greater = function(P) {
        return this.compare(P) > 0;
      }, i.prototype.gt = i.prototype.greater = s.prototype.gt = s.prototype.greater, s.prototype.lesser = function(P) {
        return this.compare(P) < 0;
      }, i.prototype.lt = i.prototype.lesser = s.prototype.lt = s.prototype.lesser, s.prototype.greaterOrEquals = function(P) {
        return this.compare(P) >= 0;
      }, i.prototype.geq = i.prototype.greaterOrEquals = s.prototype.geq = s.prototype.greaterOrEquals, s.prototype.lesserOrEquals = function(P) {
        return this.compare(P) <= 0;
      }, i.prototype.leq = i.prototype.lesserOrEquals = s.prototype.leq = s.prototype.lesserOrEquals, s.prototype.isEven = function() {
        return (this.value[0] & 1) === 0;
      }, i.prototype.isEven = function() {
        return (this.value & 1) === 0;
      }, s.prototype.isOdd = function() {
        return (this.value[0] & 1) === 1;
      }, i.prototype.isOdd = function() {
        return (this.value & 1) === 1;
      }, s.prototype.isPositive = function() {
        return !this.sign;
      }, i.prototype.isPositive = function() {
        return this.value > 0;
      }, s.prototype.isNegative = function() {
        return this.sign;
      }, i.prototype.isNegative = function() {
        return this.value < 0;
      }, s.prototype.isUnit = function() {
        return !1;
      }, i.prototype.isUnit = function() {
        return Math.abs(this.value) === 1;
      }, s.prototype.isZero = function() {
        return !1;
      }, i.prototype.isZero = function() {
        return this.value === 0;
      }, s.prototype.isDivisibleBy = function(P) {
        var K = L(P), re = K.value;
        return re === 0 ? !1 : re === 1 ? !0 : re === 2 ? this.isEven() : this.mod(K).equals(a[0]);
      }, i.prototype.isDivisibleBy = s.prototype.isDivisibleBy;
      function Z(P) {
        var K = P.abs();
        if (K.isUnit()) return !1;
        if (K.equals(2) || K.equals(3) || K.equals(5)) return !0;
        if (K.isEven() || K.isDivisibleBy(3) || K.isDivisibleBy(5)) return !1;
        if (K.lesser(49)) return !0;
      }
      function oe(P, K) {
        for (var re = P.prev(), ce = re, le = 0, me, ne, W; ce.isEven(); ) ce = ce.divide(2), le++;
        e: for (ne = 0; ne < K.length; ne++)
          if (!P.lesser(K[ne]) && (W = c(K[ne]).modPow(ce, P), !(W.equals(a[1]) || W.equals(re)))) {
            for (me = le - 1; me != 0; me--) {
              if (W = W.square().mod(P), W.isUnit()) return !1;
              if (W.equals(re)) continue e;
            }
            return !1;
          }
        return !0;
      }
      s.prototype.isPrime = function(P) {
        var K = Z(this);
        if (K !== d) return K;
        var re = this.abs(), ce = re.bitLength();
        if (ce <= 64)
          return oe(re, [2, 325, 9375, 28178, 450775, 9780504, 1795265022]);
        for (var le = Math.log(2) * ce, me = Math.ceil(P === !0 ? 2 * Math.pow(le, 2) : le), ne = [], W = 0; W < me; W++)
          ne.push(c(W + 2));
        return oe(re, ne);
      }, i.prototype.isPrime = s.prototype.isPrime, s.prototype.isProbablePrime = function(P) {
        var K = Z(this);
        if (K !== d) return K;
        for (var re = this.abs(), ce = P === d ? 5 : P, le = [], me = 0; me < ce; me++)
          le.push(c.randBetween(2, re.minus(2)));
        return oe(re, le);
      }, i.prototype.isProbablePrime = s.prototype.isProbablePrime, s.prototype.modInv = function(P) {
        for (var K = c.zero, re = c.one, ce = L(P), le = this.abs(), me, ne, W; !le.equals(c.zero); )
          me = ce.divide(le), ne = K, W = ce, K = re, ce = le, re = ne.subtract(me.multiply(re)), le = W.subtract(me.multiply(le));
        if (!ce.equals(1)) throw new Error(this.toString() + " and " + P.toString() + " are not co-prime");
        return K.compare(0) === -1 && (K = K.add(P)), this.isNegative() ? K.negate() : K;
      }, i.prototype.modInv = s.prototype.modInv, s.prototype.next = function() {
        var P = this.value;
        return this.sign ? N(P, 1, this.sign) : new s(H(P, 1), this.sign);
      }, i.prototype.next = function() {
        var P = this.value;
        return P + 1 < f ? new i(P + 1) : new s(n, !1);
      }, s.prototype.prev = function() {
        var P = this.value;
        return this.sign ? new s(H(P, 1), !0) : N(P, 1, this.sign);
      }, i.prototype.prev = function() {
        var P = this.value;
        return P - 1 > -f ? new i(P - 1) : new s(n, !0);
      };
      for (var y = [1]; 2 * y[y.length - 1] <= w; ) y.push(2 * y[y.length - 1]);
      var Y = y.length, he = y[Y - 1];
      function be(P) {
        return (typeof P == "number" || typeof P == "string") && +Math.abs(P) <= w || P instanceof s && P.value.length <= 1;
      }
      s.prototype.shiftLeft = function(P) {
        if (!be(P))
          throw new Error(String(P) + " is too large for shifting.");
        if (P = +P, P < 0) return this.shiftRight(-P);
        var K = this;
        if (K.isZero()) return K;
        for (; P >= Y; )
          K = K.multiply(he), P -= Y - 1;
        return K.multiply(y[P]);
      }, i.prototype.shiftLeft = s.prototype.shiftLeft, s.prototype.shiftRight = function(P) {
        var K;
        if (!be(P))
          throw new Error(String(P) + " is too large for shifting.");
        if (P = +P, P < 0) return this.shiftLeft(-P);
        for (var re = this; P >= Y; ) {
          if (re.isZero() || re.isNegative() && re.isUnit()) return re;
          K = D(re, he), re = K[1].isNegative() ? K[0].prev() : K[0], P -= Y - 1;
        }
        return K = D(re, y[P]), K[1].isNegative() ? K[0].prev() : K[0];
      }, i.prototype.shiftRight = s.prototype.shiftRight;
      function xe(P, K, re) {
        K = L(K);
        for (var ce = P.isNegative(), le = K.isNegative(), me = ce ? P.not() : P, ne = le ? K.not() : K, W = 0, te = 0, pe = null, Ee = null, Ae = []; !me.isZero() || !ne.isZero(); )
          pe = D(me, he), W = pe[1].toJSNumber(), ce && (W = he - 1 - W), Ee = D(ne, he), te = Ee[1].toJSNumber(), le && (te = he - 1 - te), me = pe[0], ne = Ee[0], Ae.push(re(W, te));
        for (var Oe = re(ce ? 1 : 0, le ? 1 : 0) !== 0 ? c(-1) : c(0), Be = Ae.length - 1; Be >= 0; Be -= 1)
          Oe = Oe.multiply(he).add(c(Ae[Be]));
        return Oe;
      }
      s.prototype.not = function() {
        return this.negate().prev();
      }, i.prototype.not = s.prototype.not, s.prototype.and = function(P) {
        return xe(this, P, function(K, re) {
          return K & re;
        });
      }, i.prototype.and = s.prototype.and, s.prototype.or = function(P) {
        return xe(this, P, function(K, re) {
          return K | re;
        });
      }, i.prototype.or = s.prototype.or, s.prototype.xor = function(P) {
        return xe(this, P, function(K, re) {
          return K ^ re;
        });
      }, i.prototype.xor = s.prototype.xor;
      var Ie = 1 << 30, ve = (w & -w) * (w & -w) | Ie;
      function C(P) {
        var K = P.value, re = typeof K == "number" ? K | Ie : K[0] + K[1] * w | ve;
        return re & -re;
      }
      function I(P, K) {
        if (K.compareTo(P) <= 0) {
          var re = I(P, K.square(K)), ce = re.p, le = re.e, me = ce.multiply(K);
          return me.compareTo(P) <= 0 ? { p: me, e: le * 2 + 1 } : { p: ce, e: le * 2 };
        }
        return { p: c(1), e: 0 };
      }
      s.prototype.bitLength = function() {
        var P = this;
        return P.compareTo(c(0)) < 0 && (P = P.negate().subtract(c(1))), P.compareTo(c(0)) === 0 ? c(0) : c(I(P, c(2)).e).add(c(1));
      }, i.prototype.bitLength = s.prototype.bitLength;
      function se(P, K) {
        return P = L(P), K = L(K), P.greater(K) ? P : K;
      }
      function t(P, K) {
        return P = L(P), K = L(K), P.lesser(K) ? P : K;
      }
      function l(P, K) {
        if (P = L(P).abs(), K = L(K).abs(), P.equals(K)) return P;
        if (P.isZero()) return K;
        if (K.isZero()) return P;
        for (var re = a[1], ce, le; P.isEven() && K.isEven(); )
          ce = Math.min(C(P), C(K)), P = P.divide(ce), K = K.divide(ce), re = re.multiply(ce);
        for (; P.isEven(); )
          P = P.divide(C(P));
        do {
          for (; K.isEven(); )
            K = K.divide(C(K));
          P.greater(K) && (le = K, K = P, P = le), K = K.subtract(P);
        } while (!K.isZero());
        return re.isUnit() ? P : P.multiply(re);
      }
      function B(P, K) {
        return P = L(P).abs(), K = L(K).abs(), P.divide(l(P, K)).multiply(K);
      }
      function U(P, K) {
        P = L(P), K = L(K);
        var re = t(P, K), ce = se(P, K), le = ce.subtract(re).add(1);
        if (le.isSmall) return re.add(Math.floor(Math.random() * le));
        for (var me = le.value.length - 1, ne = [], W = !0, te = me; te >= 0; te--) {
          var pe = W ? le.value[te] : w, Ee = h(Math.random() * pe);
          ne.unshift(Ee), Ee < pe && (W = !1);
        }
        return ne = E(ne), re.add(typeof ne == "number" ? new i(ne) : new s(ne, !1));
      }
      var G = function(P, K) {
        for (var re = P.length, ce, le = Math.abs(K), ce = 0; ce < re; ce++) {
          var me = P[ce].toLowerCase();
          if (me !== "-" && /[a-z0-9]/.test(me)) {
            if (/[0-9]/.test(me) && +me >= le) {
              if (me === "1" && le === 1) continue;
              throw new Error(me + " is not a valid digit in base " + K + ".");
            } else if (me.charCodeAt(0) - 87 >= le)
              throw new Error(me + " is not a valid digit in base " + K + ".");
          }
        }
        if (2 <= K && K <= 36 && re <= u / Math.log(K)) {
          var ne = parseInt(P, K);
          if (isNaN(ne))
            throw new Error(me + " is not a valid digit in base " + K + ".");
          return new i(parseInt(P, K));
        }
        K = L(K);
        var W = [], te = P[0] === "-";
        for (ce = te ? 1 : 0; ce < P.length; ce++) {
          var me = P[ce].toLowerCase(), pe = me.charCodeAt(0);
          if (48 <= pe && pe <= 57) W.push(L(me));
          else if (97 <= pe && pe <= 122) W.push(L(me.charCodeAt(0) - 87));
          else if (me === "<") {
            var Ee = ce;
            do
              ce++;
            while (P[ce] !== ">");
            W.push(L(P.slice(Ee + 1, ce)));
          } else throw new Error(me + " is not a valid character");
        }
        return T(W, K, te);
      };
      function T(P, K, re) {
        var ce = a[0], le = a[1], me;
        for (me = P.length - 1; me >= 0; me--)
          ce = ce.add(P[me].times(le)), le = le.times(K);
        return re ? ce.negate() : ce;
      }
      function M(P) {
        return P <= 35 ? "0123456789abcdefghijklmnopqrstuvwxyz".charAt(P) : "<" + P + ">";
      }
      function $(P, K) {
        if (K = c(K), K.isZero()) {
          if (P.isZero()) return { value: [0], isNegative: !1 };
          throw new Error("Cannot convert nonzero numbers to base 0.");
        }
        if (K.equals(-1)) {
          if (P.isZero()) return { value: [0], isNegative: !1 };
          if (P.isNegative())
            return {
              value: [].concat.apply(
                [],
                Array.apply(null, Array(-P)).map(Array.prototype.valueOf, [1, 0])
              ),
              isNegative: !1
            };
          var re = Array.apply(null, Array(+P - 1)).map(Array.prototype.valueOf, [0, 1]);
          return re.unshift([1]), {
            value: [].concat.apply([], re),
            isNegative: !1
          };
        }
        var ce = !1;
        if (P.isNegative() && K.isPositive() && (ce = !0, P = P.abs()), K.equals(1))
          return P.isZero() ? { value: [0], isNegative: !1 } : {
            value: Array.apply(null, Array(+P)).map(Number.prototype.valueOf, 1),
            isNegative: ce
          };
        for (var le = [], me = P, ne; me.isNegative() || me.compareAbs(K) >= 0; ) {
          ne = me.divmod(K), me = ne.quotient;
          var W = ne.remainder;
          W.isNegative() && (W = K.minus(W).abs(), me = me.next()), le.push(W.toJSNumber());
        }
        return le.push(me.toJSNumber()), { value: le.reverse(), isNegative: ce };
      }
      function r(P, K) {
        var re = $(P, K);
        return (re.isNegative ? "-" : "") + re.value.map(M).join("");
      }
      s.prototype.toArray = function(P) {
        return $(this, P);
      }, i.prototype.toArray = function(P) {
        return $(this, P);
      }, s.prototype.toString = function(P) {
        if (P === d && (P = 10), P !== 10) return r(this, P);
        for (var K = this.value, re = K.length, ce = String(K[--re]), le = "0000000", me; --re >= 0; )
          me = String(K[re]), ce += le.slice(me.length) + me;
        var ne = this.sign ? "-" : "";
        return ne + ce;
      }, i.prototype.toString = function(P) {
        return P === d && (P = 10), P != 10 ? r(this, P) : String(this.value);
      }, s.prototype.toJSON = i.prototype.toJSON = function() {
        return this.toString();
      }, s.prototype.valueOf = function() {
        return parseInt(this.toString(), 10);
      }, s.prototype.toJSNumber = s.prototype.valueOf, i.prototype.valueOf = function() {
        return this.value;
      }, i.prototype.toJSNumber = i.prototype.valueOf;
      function x(P) {
        if (p(+P)) {
          var K = +P;
          if (K === h(K))
            return new i(K);
          throw new Error("Invalid integer: " + P);
        }
        var re = P[0] === "-";
        re && (P = P.slice(1));
        var ce = P.split(/e/i);
        if (ce.length > 2) throw new Error("Invalid integer: " + ce.join("e"));
        if (ce.length === 2) {
          var le = ce[1];
          if (le[0] === "+" && (le = le.slice(1)), le = +le, le !== h(le) || !p(le)) throw new Error("Invalid integer: " + le + " is not a valid exponent.");
          var me = ce[0], ne = me.indexOf(".");
          if (ne >= 0 && (le -= me.length - ne - 1, me = me.slice(0, ne) + me.slice(ne + 1)), le < 0) throw new Error("Cannot include negative exponent part for integers");
          me += new Array(le + 1).join("0"), P = me;
        }
        var W = /^([0-9][0-9]*)$/.test(P);
        if (!W) throw new Error("Invalid integer: " + P);
        for (var te = [], pe = P.length, Ee = g, Ae = pe - Ee; pe > 0; )
          te.push(+P.slice(Ae, pe)), Ae -= Ee, Ae < 0 && (Ae = 0), pe -= Ee;
        return v(te), new s(te, re);
      }
      function O(P) {
        if (p(P)) {
          if (P !== h(P)) throw new Error(P + " is not an integer.");
          return new i(P);
        }
        return x(P.toString());
      }
      function L(P) {
        return typeof P == "number" ? O(P) : typeof P == "string" ? x(P) : P;
      }
      for (var X = 0; X < 1e3; X++)
        a[X] = new i(X), X > 0 && (a[-X] = new i(-X));
      return a.one = a[1], a.zero = a[0], a.minusOne = a[-1], a.max = se, a.min = t, a.gcd = l, a.lcm = B, a.isInstance = function(P) {
        return P instanceof s || P instanceof i;
      }, a.randBetween = U, a.fromArray = function(P, K, re) {
        return T(P.map(L), L(K || 10), re);
      }, a;
    }();
    e.hasOwnProperty("exports") && (e.exports = c);
  }(zo)), zo.exports;
}
var vr = {}, Nt = {}, Jt = {}, To = {}, In = {}, Gl;
function Y7() {
  return Gl || (Gl = 1, Object.defineProperty(In, "__esModule", { value: !0 }), In.crypto = void 0, In.crypto = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0), In;
}
var Wl;
function s8() {
  return Wl || (Wl = 1, function(e) {
    /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
    Object.defineProperty(e, "__esModule", { value: !0 }), e.wrapXOFConstructorWithOpts = e.wrapConstructorWithOpts = e.wrapConstructor = e.Hash = e.nextTick = e.swap32IfBE = e.byteSwapIfBE = e.swap8IfBE = e.isLE = void 0, e.isBytes = d, e.anumber = w, e.abytes = g, e.ahash = f, e.aexists = n, e.aoutput = u, e.u8 = a, e.u32 = s, e.clean = i, e.createView = p, e.rotr = m, e.rotl = E, e.byteSwap = v, e.byteSwap32 = b, e.bytesToHex = S, e.hexToBytes = J, e.asyncLoop = z, e.utf8ToBytes = A, e.bytesToUtf8 = q, e.toBytes = _, e.kdfInputToBytes = F, e.concatBytes = R, e.checkOpts = V, e.createHasher = ue, e.createOptHasher = ae, e.createXOFer = D, e.randomBytes = Q;
    const c = /* @__PURE__ */ Y7();
    function d(Z) {
      return Z instanceof Uint8Array || ArrayBuffer.isView(Z) && Z.constructor.name === "Uint8Array";
    }
    function w(Z) {
      if (!Number.isSafeInteger(Z) || Z < 0)
        throw new Error("positive integer expected, got " + Z);
    }
    function g(Z, ...oe) {
      if (!d(Z))
        throw new Error("Uint8Array expected");
      if (oe.length > 0 && !oe.includes(Z.length))
        throw new Error("Uint8Array expected of length " + oe + ", got length=" + Z.length);
    }
    function f(Z) {
      if (typeof Z != "function" || typeof Z.create != "function")
        throw new Error("Hash should be wrapped by utils.createHasher");
      w(Z.outputLen), w(Z.blockLen);
    }
    function n(Z, oe = !0) {
      if (Z.destroyed)
        throw new Error("Hash instance has been destroyed");
      if (oe && Z.finished)
        throw new Error("Hash#digest() has already been called");
    }
    function u(Z, oe) {
      g(Z);
      const y = oe.outputLen;
      if (Z.length < y)
        throw new Error("digestInto() expects output buffer of length at least " + y);
    }
    function a(Z) {
      return new Uint8Array(Z.buffer, Z.byteOffset, Z.byteLength);
    }
    function s(Z) {
      return new Uint32Array(Z.buffer, Z.byteOffset, Math.floor(Z.byteLength / 4));
    }
    function i(...Z) {
      for (let oe = 0; oe < Z.length; oe++)
        Z[oe].fill(0);
    }
    function p(Z) {
      return new DataView(Z.buffer, Z.byteOffset, Z.byteLength);
    }
    function m(Z, oe) {
      return Z << 32 - oe | Z >>> oe;
    }
    function E(Z, oe) {
      return Z << oe | Z >>> 32 - oe >>> 0;
    }
    e.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
    function v(Z) {
      return Z << 24 & 4278190080 | Z << 8 & 16711680 | Z >>> 8 & 65280 | Z >>> 24 & 255;
    }
    e.swap8IfBE = e.isLE ? (Z) => Z : (Z) => v(Z), e.byteSwapIfBE = e.swap8IfBE;
    function b(Z) {
      for (let oe = 0; oe < Z.length; oe++)
        Z[oe] = v(Z[oe]);
      return Z;
    }
    e.swap32IfBE = e.isLE ? (Z) => Z : b;
    const h = /* @ts-ignore */ typeof Uint8Array.from([]).toHex == "function" && typeof Uint8Array.fromHex == "function", o = /* @__PURE__ */ Array.from({ length: 256 }, (Z, oe) => oe.toString(16).padStart(2, "0"));
    function S(Z) {
      if (g(Z), h)
        return Z.toHex();
      let oe = "";
      for (let y = 0; y < Z.length; y++)
        oe += o[Z[y]];
      return oe;
    }
    const H = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
    function j(Z) {
      if (Z >= H._0 && Z <= H._9)
        return Z - H._0;
      if (Z >= H.A && Z <= H.F)
        return Z - (H.A - 10);
      if (Z >= H.a && Z <= H.f)
        return Z - (H.a - 10);
    }
    function J(Z) {
      if (typeof Z != "string")
        throw new Error("hex string expected, got " + typeof Z);
      if (h)
        return Uint8Array.fromHex(Z);
      const oe = Z.length, y = oe / 2;
      if (oe % 2)
        throw new Error("hex string expected, got unpadded hex of length " + oe);
      const Y = new Uint8Array(y);
      for (let he = 0, be = 0; he < y; he++, be += 2) {
        const xe = j(Z.charCodeAt(be)), Ie = j(Z.charCodeAt(be + 1));
        if (xe === void 0 || Ie === void 0) {
          const ve = Z[be] + Z[be + 1];
          throw new Error('hex string expected, got non-hex character "' + ve + '" at index ' + be);
        }
        Y[he] = xe * 16 + Ie;
      }
      return Y;
    }
    const N = async () => {
    };
    e.nextTick = N;
    async function z(Z, oe, y) {
      let Y = Date.now();
      for (let he = 0; he < Z; he++) {
        y(he);
        const be = Date.now() - Y;
        be >= 0 && be < oe || (await (0, e.nextTick)(), Y += be);
      }
    }
    function A(Z) {
      if (typeof Z != "string")
        throw new Error("string expected");
      return new Uint8Array(new TextEncoder().encode(Z));
    }
    function q(Z) {
      return new TextDecoder().decode(Z);
    }
    function _(Z) {
      return typeof Z == "string" && (Z = A(Z)), g(Z), Z;
    }
    function F(Z) {
      return typeof Z == "string" && (Z = A(Z)), g(Z), Z;
    }
    function R(...Z) {
      let oe = 0;
      for (let Y = 0; Y < Z.length; Y++) {
        const he = Z[Y];
        g(he), oe += he.length;
      }
      const y = new Uint8Array(oe);
      for (let Y = 0, he = 0; Y < Z.length; Y++) {
        const be = Z[Y];
        y.set(be, he), he += be.length;
      }
      return y;
    }
    function V(Z, oe) {
      if (oe !== void 0 && {}.toString.call(oe) !== "[object Object]")
        throw new Error("options should be object or undefined");
      return Object.assign(Z, oe);
    }
    class fe {
    }
    e.Hash = fe;
    function ue(Z) {
      const oe = (Y) => Z().update(_(Y)).digest(), y = Z();
      return oe.outputLen = y.outputLen, oe.blockLen = y.blockLen, oe.create = () => Z(), oe;
    }
    function ae(Z) {
      const oe = (Y, he) => Z(he).update(_(Y)).digest(), y = Z({});
      return oe.outputLen = y.outputLen, oe.blockLen = y.blockLen, oe.create = (Y) => Z(Y), oe;
    }
    function D(Z) {
      const oe = (Y, he) => Z(he).update(_(Y)).digest(), y = Z({});
      return oe.outputLen = y.outputLen, oe.blockLen = y.blockLen, oe.create = (Y) => Z(Y), oe;
    }
    e.wrapConstructor = ue, e.wrapConstructorWithOpts = ae, e.wrapXOFConstructorWithOpts = D;
    function Q(Z = 32) {
      if (c.crypto && typeof c.crypto.getRandomValues == "function")
        return c.crypto.getRandomValues(new Uint8Array(Z));
      if (c.crypto && typeof c.crypto.randomBytes == "function")
        return Uint8Array.from(c.crypto.randomBytes(Z));
      throw new Error("crypto.getRandomValues must be defined");
    }
  }(To)), To;
}
var Zl;
function X7() {
  if (Zl) return Jt;
  Zl = 1, Object.defineProperty(Jt, "__esModule", { value: !0 }), Jt.SHA512_IV = Jt.SHA384_IV = Jt.SHA224_IV = Jt.SHA256_IV = Jt.HashMD = void 0, Jt.setBigUint64 = c, Jt.Chi = d, Jt.Maj = w;
  const e = /* @__PURE__ */ s8();
  function c(f, n, u, a) {
    if (typeof f.setBigUint64 == "function")
      return f.setBigUint64(n, u, a);
    const s = BigInt(32), i = BigInt(4294967295), p = Number(u >> s & i), m = Number(u & i), E = a ? 4 : 0, v = a ? 0 : 4;
    f.setUint32(n + E, p, a), f.setUint32(n + v, m, a);
  }
  function d(f, n, u) {
    return f & n ^ ~f & u;
  }
  function w(f, n, u) {
    return f & n ^ f & u ^ n & u;
  }
  class g extends e.Hash {
    constructor(n, u, a, s) {
      super(), this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.blockLen = n, this.outputLen = u, this.padOffset = a, this.isLE = s, this.buffer = new Uint8Array(n), this.view = (0, e.createView)(this.buffer);
    }
    update(n) {
      (0, e.aexists)(this), n = (0, e.toBytes)(n), (0, e.abytes)(n);
      const { view: u, buffer: a, blockLen: s } = this, i = n.length;
      for (let p = 0; p < i; ) {
        const m = Math.min(s - this.pos, i - p);
        if (m === s) {
          const E = (0, e.createView)(n);
          for (; s <= i - p; p += s)
            this.process(E, p);
          continue;
        }
        a.set(n.subarray(p, p + m), this.pos), this.pos += m, p += m, this.pos === s && (this.process(u, 0), this.pos = 0);
      }
      return this.length += n.length, this.roundClean(), this;
    }
    digestInto(n) {
      (0, e.aexists)(this), (0, e.aoutput)(n, this), this.finished = !0;
      const { buffer: u, view: a, blockLen: s, isLE: i } = this;
      let { pos: p } = this;
      u[p++] = 128, (0, e.clean)(this.buffer.subarray(p)), this.padOffset > s - p && (this.process(a, 0), p = 0);
      for (let h = p; h < s; h++)
        u[h] = 0;
      c(a, s - 8, BigInt(this.length * 8), i), this.process(a, 0);
      const m = (0, e.createView)(n), E = this.outputLen;
      if (E % 4)
        throw new Error("_sha2: outputLen should be aligned to 32bit");
      const v = E / 4, b = this.get();
      if (v > b.length)
        throw new Error("_sha2: outputLen bigger than state");
      for (let h = 0; h < v; h++)
        m.setUint32(4 * h, b[h], i);
    }
    digest() {
      const { buffer: n, outputLen: u } = this;
      this.digestInto(n);
      const a = n.slice(0, u);
      return this.destroy(), a;
    }
    _cloneInto(n) {
      n || (n = new this.constructor()), n.set(...this.get());
      const { blockLen: u, buffer: a, length: s, finished: i, destroyed: p, pos: m } = this;
      return n.destroyed = p, n.finished = i, n.length = s, n.pos = m, s % u && n.buffer.set(a), n;
    }
    clone() {
      return this._cloneInto();
    }
  }
  return Jt.HashMD = g, Jt.SHA256_IV = Uint32Array.from([
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ]), Jt.SHA224_IV = Uint32Array.from([
    3238371032,
    914150663,
    812702999,
    4144912697,
    4290775857,
    1750603025,
    1694076839,
    3204075428
  ]), Jt.SHA384_IV = Uint32Array.from([
    3418070365,
    3238371032,
    1654270250,
    914150663,
    2438529370,
    812702999,
    355462360,
    4144912697,
    1731405415,
    4290775857,
    2394180231,
    1750603025,
    3675008525,
    1694076839,
    1203062813,
    3204075428
  ]), Jt.SHA512_IV = Uint32Array.from([
    1779033703,
    4089235720,
    3144134277,
    2227873595,
    1013904242,
    4271175723,
    2773480762,
    1595750129,
    1359893119,
    2917565137,
    2600822924,
    725511199,
    528734635,
    4215389547,
    1541459225,
    327033209
  ]), Jt;
}
var gt = {}, Ql;
function J7() {
  if (Ql) return gt;
  Ql = 1, Object.defineProperty(gt, "__esModule", { value: !0 }), gt.toBig = gt.shrSL = gt.shrSH = gt.rotrSL = gt.rotrSH = gt.rotrBL = gt.rotrBH = gt.rotr32L = gt.rotr32H = gt.rotlSL = gt.rotlSH = gt.rotlBL = gt.rotlBH = gt.add5L = gt.add5H = gt.add4L = gt.add4H = gt.add3L = gt.add3H = void 0, gt.add = o, gt.fromBig = d, gt.split = w;
  const e = /* @__PURE__ */ BigInt(2 ** 32 - 1), c = /* @__PURE__ */ BigInt(32);
  function d(q, _ = !1) {
    return _ ? { h: Number(q & e), l: Number(q >> c & e) } : { h: Number(q >> c & e) | 0, l: Number(q & e) | 0 };
  }
  function w(q, _ = !1) {
    const F = q.length;
    let R = new Uint32Array(F), V = new Uint32Array(F);
    for (let fe = 0; fe < F; fe++) {
      const { h: ue, l: ae } = d(q[fe], _);
      [R[fe], V[fe]] = [ue, ae];
    }
    return [R, V];
  }
  const g = (q, _) => BigInt(q >>> 0) << c | BigInt(_ >>> 0);
  gt.toBig = g;
  const f = (q, _, F) => q >>> F;
  gt.shrSH = f;
  const n = (q, _, F) => q << 32 - F | _ >>> F;
  gt.shrSL = n;
  const u = (q, _, F) => q >>> F | _ << 32 - F;
  gt.rotrSH = u;
  const a = (q, _, F) => q << 32 - F | _ >>> F;
  gt.rotrSL = a;
  const s = (q, _, F) => q << 64 - F | _ >>> F - 32;
  gt.rotrBH = s;
  const i = (q, _, F) => q >>> F - 32 | _ << 64 - F;
  gt.rotrBL = i;
  const p = (q, _) => _;
  gt.rotr32H = p;
  const m = (q, _) => q;
  gt.rotr32L = m;
  const E = (q, _, F) => q << F | _ >>> 32 - F;
  gt.rotlSH = E;
  const v = (q, _, F) => _ << F | q >>> 32 - F;
  gt.rotlSL = v;
  const b = (q, _, F) => _ << F - 32 | q >>> 64 - F;
  gt.rotlBH = b;
  const h = (q, _, F) => q << F - 32 | _ >>> 64 - F;
  gt.rotlBL = h;
  function o(q, _, F, R) {
    const V = (_ >>> 0) + (R >>> 0);
    return { h: q + F + (V / 2 ** 32 | 0) | 0, l: V | 0 };
  }
  const S = (q, _, F) => (q >>> 0) + (_ >>> 0) + (F >>> 0);
  gt.add3L = S;
  const H = (q, _, F, R) => _ + F + R + (q / 2 ** 32 | 0) | 0;
  gt.add3H = H;
  const j = (q, _, F, R) => (q >>> 0) + (_ >>> 0) + (F >>> 0) + (R >>> 0);
  gt.add4L = j;
  const J = (q, _, F, R, V) => _ + F + R + V + (q / 2 ** 32 | 0) | 0;
  gt.add4H = J;
  const N = (q, _, F, R, V) => (q >>> 0) + (_ >>> 0) + (F >>> 0) + (R >>> 0) + (V >>> 0);
  gt.add5L = N;
  const z = (q, _, F, R, V, fe) => _ + F + R + V + fe + (q / 2 ** 32 | 0) | 0;
  gt.add5H = z;
  const A = {
    fromBig: d,
    split: w,
    toBig: g,
    shrSH: f,
    shrSL: n,
    rotrSH: u,
    rotrSL: a,
    rotrBH: s,
    rotrBL: i,
    rotr32H: p,
    rotr32L: m,
    rotlSH: E,
    rotlSL: v,
    rotlBH: b,
    rotlBL: h,
    add: o,
    add3L: S,
    add3H: H,
    add4L: j,
    add4H: J,
    add5H: z,
    add5L: N
  };
  return gt.default = A, gt;
}
var e1;
function G7() {
  if (e1) return Nt;
  e1 = 1, Object.defineProperty(Nt, "__esModule", { value: !0 }), Nt.sha512_224 = Nt.sha512_256 = Nt.sha384 = Nt.sha512 = Nt.sha224 = Nt.sha256 = Nt.SHA512_256 = Nt.SHA512_224 = Nt.SHA384 = Nt.SHA512 = Nt.SHA224 = Nt.SHA256 = void 0;
  const e = /* @__PURE__ */ X7(), c = /* @__PURE__ */ J7(), d = /* @__PURE__ */ s8(), w = /* @__PURE__ */ Uint32Array.from([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ]), g = /* @__PURE__ */ new Uint32Array(64);
  class f extends e.HashMD {
    constructor(H = 32) {
      super(64, H, 8, !1), this.A = e.SHA256_IV[0] | 0, this.B = e.SHA256_IV[1] | 0, this.C = e.SHA256_IV[2] | 0, this.D = e.SHA256_IV[3] | 0, this.E = e.SHA256_IV[4] | 0, this.F = e.SHA256_IV[5] | 0, this.G = e.SHA256_IV[6] | 0, this.H = e.SHA256_IV[7] | 0;
    }
    get() {
      const { A: H, B: j, C: J, D: N, E: z, F: A, G: q, H: _ } = this;
      return [H, j, J, N, z, A, q, _];
    }
    // prettier-ignore
    set(H, j, J, N, z, A, q, _) {
      this.A = H | 0, this.B = j | 0, this.C = J | 0, this.D = N | 0, this.E = z | 0, this.F = A | 0, this.G = q | 0, this.H = _ | 0;
    }
    process(H, j) {
      for (let V = 0; V < 16; V++, j += 4)
        g[V] = H.getUint32(j, !1);
      for (let V = 16; V < 64; V++) {
        const fe = g[V - 15], ue = g[V - 2], ae = (0, d.rotr)(fe, 7) ^ (0, d.rotr)(fe, 18) ^ fe >>> 3, D = (0, d.rotr)(ue, 17) ^ (0, d.rotr)(ue, 19) ^ ue >>> 10;
        g[V] = D + g[V - 7] + ae + g[V - 16] | 0;
      }
      let { A: J, B: N, C: z, D: A, E: q, F: _, G: F, H: R } = this;
      for (let V = 0; V < 64; V++) {
        const fe = (0, d.rotr)(q, 6) ^ (0, d.rotr)(q, 11) ^ (0, d.rotr)(q, 25), ue = R + fe + (0, e.Chi)(q, _, F) + w[V] + g[V] | 0, D = ((0, d.rotr)(J, 2) ^ (0, d.rotr)(J, 13) ^ (0, d.rotr)(J, 22)) + (0, e.Maj)(J, N, z) | 0;
        R = F, F = _, _ = q, q = A + ue | 0, A = z, z = N, N = J, J = ue + D | 0;
      }
      J = J + this.A | 0, N = N + this.B | 0, z = z + this.C | 0, A = A + this.D | 0, q = q + this.E | 0, _ = _ + this.F | 0, F = F + this.G | 0, R = R + this.H | 0, this.set(J, N, z, A, q, _, F, R);
    }
    roundClean() {
      (0, d.clean)(g);
    }
    destroy() {
      this.set(0, 0, 0, 0, 0, 0, 0, 0), (0, d.clean)(this.buffer);
    }
  }
  Nt.SHA256 = f;
  class n extends f {
    constructor() {
      super(28), this.A = e.SHA224_IV[0] | 0, this.B = e.SHA224_IV[1] | 0, this.C = e.SHA224_IV[2] | 0, this.D = e.SHA224_IV[3] | 0, this.E = e.SHA224_IV[4] | 0, this.F = e.SHA224_IV[5] | 0, this.G = e.SHA224_IV[6] | 0, this.H = e.SHA224_IV[7] | 0;
    }
  }
  Nt.SHA224 = n;
  const u = c.split([
    "0x428a2f98d728ae22",
    "0x7137449123ef65cd",
    "0xb5c0fbcfec4d3b2f",
    "0xe9b5dba58189dbbc",
    "0x3956c25bf348b538",
    "0x59f111f1b605d019",
    "0x923f82a4af194f9b",
    "0xab1c5ed5da6d8118",
    "0xd807aa98a3030242",
    "0x12835b0145706fbe",
    "0x243185be4ee4b28c",
    "0x550c7dc3d5ffb4e2",
    "0x72be5d74f27b896f",
    "0x80deb1fe3b1696b1",
    "0x9bdc06a725c71235",
    "0xc19bf174cf692694",
    "0xe49b69c19ef14ad2",
    "0xefbe4786384f25e3",
    "0x0fc19dc68b8cd5b5",
    "0x240ca1cc77ac9c65",
    "0x2de92c6f592b0275",
    "0x4a7484aa6ea6e483",
    "0x5cb0a9dcbd41fbd4",
    "0x76f988da831153b5",
    "0x983e5152ee66dfab",
    "0xa831c66d2db43210",
    "0xb00327c898fb213f",
    "0xbf597fc7beef0ee4",
    "0xc6e00bf33da88fc2",
    "0xd5a79147930aa725",
    "0x06ca6351e003826f",
    "0x142929670a0e6e70",
    "0x27b70a8546d22ffc",
    "0x2e1b21385c26c926",
    "0x4d2c6dfc5ac42aed",
    "0x53380d139d95b3df",
    "0x650a73548baf63de",
    "0x766a0abb3c77b2a8",
    "0x81c2c92e47edaee6",
    "0x92722c851482353b",
    "0xa2bfe8a14cf10364",
    "0xa81a664bbc423001",
    "0xc24b8b70d0f89791",
    "0xc76c51a30654be30",
    "0xd192e819d6ef5218",
    "0xd69906245565a910",
    "0xf40e35855771202a",
    "0x106aa07032bbd1b8",
    "0x19a4c116b8d2d0c8",
    "0x1e376c085141ab53",
    "0x2748774cdf8eeb99",
    "0x34b0bcb5e19b48a8",
    "0x391c0cb3c5c95a63",
    "0x4ed8aa4ae3418acb",
    "0x5b9cca4f7763e373",
    "0x682e6ff3d6b2b8a3",
    "0x748f82ee5defb2fc",
    "0x78a5636f43172f60",
    "0x84c87814a1f0ab72",
    "0x8cc702081a6439ec",
    "0x90befffa23631e28",
    "0xa4506cebde82bde9",
    "0xbef9a3f7b2c67915",
    "0xc67178f2e372532b",
    "0xca273eceea26619c",
    "0xd186b8c721c0c207",
    "0xeada7dd6cde0eb1e",
    "0xf57d4f7fee6ed178",
    "0x06f067aa72176fba",
    "0x0a637dc5a2c898a6",
    "0x113f9804bef90dae",
    "0x1b710b35131c471b",
    "0x28db77f523047d84",
    "0x32caab7b40c72493",
    "0x3c9ebe0a15c9bebc",
    "0x431d67c49c100d4c",
    "0x4cc5d4becb3e42b6",
    "0x597f299cfc657e2a",
    "0x5fcb6fab3ad6faec",
    "0x6c44198c4a475817"
  ].map((S) => BigInt(S))), a = u[0], s = u[1], i = /* @__PURE__ */ new Uint32Array(80), p = /* @__PURE__ */ new Uint32Array(80);
  class m extends e.HashMD {
    constructor(H = 64) {
      super(128, H, 16, !1), this.Ah = e.SHA512_IV[0] | 0, this.Al = e.SHA512_IV[1] | 0, this.Bh = e.SHA512_IV[2] | 0, this.Bl = e.SHA512_IV[3] | 0, this.Ch = e.SHA512_IV[4] | 0, this.Cl = e.SHA512_IV[5] | 0, this.Dh = e.SHA512_IV[6] | 0, this.Dl = e.SHA512_IV[7] | 0, this.Eh = e.SHA512_IV[8] | 0, this.El = e.SHA512_IV[9] | 0, this.Fh = e.SHA512_IV[10] | 0, this.Fl = e.SHA512_IV[11] | 0, this.Gh = e.SHA512_IV[12] | 0, this.Gl = e.SHA512_IV[13] | 0, this.Hh = e.SHA512_IV[14] | 0, this.Hl = e.SHA512_IV[15] | 0;
    }
    // prettier-ignore
    get() {
      const { Ah: H, Al: j, Bh: J, Bl: N, Ch: z, Cl: A, Dh: q, Dl: _, Eh: F, El: R, Fh: V, Fl: fe, Gh: ue, Gl: ae, Hh: D, Hl: Q } = this;
      return [H, j, J, N, z, A, q, _, F, R, V, fe, ue, ae, D, Q];
    }
    // prettier-ignore
    set(H, j, J, N, z, A, q, _, F, R, V, fe, ue, ae, D, Q) {
      this.Ah = H | 0, this.Al = j | 0, this.Bh = J | 0, this.Bl = N | 0, this.Ch = z | 0, this.Cl = A | 0, this.Dh = q | 0, this.Dl = _ | 0, this.Eh = F | 0, this.El = R | 0, this.Fh = V | 0, this.Fl = fe | 0, this.Gh = ue | 0, this.Gl = ae | 0, this.Hh = D | 0, this.Hl = Q | 0;
    }
    process(H, j) {
      for (let y = 0; y < 16; y++, j += 4)
        i[y] = H.getUint32(j), p[y] = H.getUint32(j += 4);
      for (let y = 16; y < 80; y++) {
        const Y = i[y - 15] | 0, he = p[y - 15] | 0, be = c.rotrSH(Y, he, 1) ^ c.rotrSH(Y, he, 8) ^ c.shrSH(Y, he, 7), xe = c.rotrSL(Y, he, 1) ^ c.rotrSL(Y, he, 8) ^ c.shrSL(Y, he, 7), Ie = i[y - 2] | 0, ve = p[y - 2] | 0, C = c.rotrSH(Ie, ve, 19) ^ c.rotrBH(Ie, ve, 61) ^ c.shrSH(Ie, ve, 6), I = c.rotrSL(Ie, ve, 19) ^ c.rotrBL(Ie, ve, 61) ^ c.shrSL(Ie, ve, 6), se = c.add4L(xe, I, p[y - 7], p[y - 16]), t = c.add4H(se, be, C, i[y - 7], i[y - 16]);
        i[y] = t | 0, p[y] = se | 0;
      }
      let { Ah: J, Al: N, Bh: z, Bl: A, Ch: q, Cl: _, Dh: F, Dl: R, Eh: V, El: fe, Fh: ue, Fl: ae, Gh: D, Gl: Q, Hh: Z, Hl: oe } = this;
      for (let y = 0; y < 80; y++) {
        const Y = c.rotrSH(V, fe, 14) ^ c.rotrSH(V, fe, 18) ^ c.rotrBH(V, fe, 41), he = c.rotrSL(V, fe, 14) ^ c.rotrSL(V, fe, 18) ^ c.rotrBL(V, fe, 41), be = V & ue ^ ~V & D, xe = fe & ae ^ ~fe & Q, Ie = c.add5L(oe, he, xe, s[y], p[y]), ve = c.add5H(Ie, Z, Y, be, a[y], i[y]), C = Ie | 0, I = c.rotrSH(J, N, 28) ^ c.rotrBH(J, N, 34) ^ c.rotrBH(J, N, 39), se = c.rotrSL(J, N, 28) ^ c.rotrBL(J, N, 34) ^ c.rotrBL(J, N, 39), t = J & z ^ J & q ^ z & q, l = N & A ^ N & _ ^ A & _;
        Z = D | 0, oe = Q | 0, D = ue | 0, Q = ae | 0, ue = V | 0, ae = fe | 0, { h: V, l: fe } = c.add(F | 0, R | 0, ve | 0, C | 0), F = q | 0, R = _ | 0, q = z | 0, _ = A | 0, z = J | 0, A = N | 0;
        const B = c.add3L(C, se, l);
        J = c.add3H(B, ve, I, t), N = B | 0;
      }
      ({ h: J, l: N } = c.add(this.Ah | 0, this.Al | 0, J | 0, N | 0)), { h: z, l: A } = c.add(this.Bh | 0, this.Bl | 0, z | 0, A | 0), { h: q, l: _ } = c.add(this.Ch | 0, this.Cl | 0, q | 0, _ | 0), { h: F, l: R } = c.add(this.Dh | 0, this.Dl | 0, F | 0, R | 0), { h: V, l: fe } = c.add(this.Eh | 0, this.El | 0, V | 0, fe | 0), { h: ue, l: ae } = c.add(this.Fh | 0, this.Fl | 0, ue | 0, ae | 0), { h: D, l: Q } = c.add(this.Gh | 0, this.Gl | 0, D | 0, Q | 0), { h: Z, l: oe } = c.add(this.Hh | 0, this.Hl | 0, Z | 0, oe | 0), this.set(J, N, z, A, q, _, F, R, V, fe, ue, ae, D, Q, Z, oe);
    }
    roundClean() {
      (0, d.clean)(i, p);
    }
    destroy() {
      (0, d.clean)(this.buffer), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
  }
  Nt.SHA512 = m;
  class E extends m {
    constructor() {
      super(48), this.Ah = e.SHA384_IV[0] | 0, this.Al = e.SHA384_IV[1] | 0, this.Bh = e.SHA384_IV[2] | 0, this.Bl = e.SHA384_IV[3] | 0, this.Ch = e.SHA384_IV[4] | 0, this.Cl = e.SHA384_IV[5] | 0, this.Dh = e.SHA384_IV[6] | 0, this.Dl = e.SHA384_IV[7] | 0, this.Eh = e.SHA384_IV[8] | 0, this.El = e.SHA384_IV[9] | 0, this.Fh = e.SHA384_IV[10] | 0, this.Fl = e.SHA384_IV[11] | 0, this.Gh = e.SHA384_IV[12] | 0, this.Gl = e.SHA384_IV[13] | 0, this.Hh = e.SHA384_IV[14] | 0, this.Hl = e.SHA384_IV[15] | 0;
    }
  }
  Nt.SHA384 = E;
  const v = /* @__PURE__ */ Uint32Array.from([
    2352822216,
    424955298,
    1944164710,
    2312950998,
    502970286,
    855612546,
    1738396948,
    1479516111,
    258812777,
    2077511080,
    2011393907,
    79989058,
    1067287976,
    1780299464,
    286451373,
    2446758561
  ]), b = /* @__PURE__ */ Uint32Array.from([
    573645204,
    4230739756,
    2673172387,
    3360449730,
    596883563,
    1867755857,
    2520282905,
    1497426621,
    2519219938,
    2827943907,
    3193839141,
    1401305490,
    721525244,
    746961066,
    246885852,
    2177182882
  ]);
  class h extends m {
    constructor() {
      super(28), this.Ah = v[0] | 0, this.Al = v[1] | 0, this.Bh = v[2] | 0, this.Bl = v[3] | 0, this.Ch = v[4] | 0, this.Cl = v[5] | 0, this.Dh = v[6] | 0, this.Dl = v[7] | 0, this.Eh = v[8] | 0, this.El = v[9] | 0, this.Fh = v[10] | 0, this.Fl = v[11] | 0, this.Gh = v[12] | 0, this.Gl = v[13] | 0, this.Hh = v[14] | 0, this.Hl = v[15] | 0;
    }
  }
  Nt.SHA512_224 = h;
  class o extends m {
    constructor() {
      super(32), this.Ah = b[0] | 0, this.Al = b[1] | 0, this.Bh = b[2] | 0, this.Bl = b[3] | 0, this.Ch = b[4] | 0, this.Cl = b[5] | 0, this.Dh = b[6] | 0, this.Dl = b[7] | 0, this.Eh = b[8] | 0, this.El = b[9] | 0, this.Fh = b[10] | 0, this.Fl = b[11] | 0, this.Gh = b[12] | 0, this.Gl = b[13] | 0, this.Hh = b[14] | 0, this.Hl = b[15] | 0;
    }
  }
  return Nt.SHA512_256 = o, Nt.sha256 = (0, d.createHasher)(() => new f()), Nt.sha224 = (0, d.createHasher)(() => new n()), Nt.sha512 = (0, d.createHasher)(() => new m()), Nt.sha384 = (0, d.createHasher)(() => new E()), Nt.sha512_256 = (0, d.createHasher)(() => new o()), Nt.sha512_224 = (0, d.createHasher)(() => new h()), Nt;
}
var t1;
function W7() {
  if (t1) return vr;
  t1 = 1, Object.defineProperty(vr, "__esModule", { value: !0 }), vr.sha224 = vr.SHA224 = vr.sha256 = vr.SHA256 = void 0;
  const e = /* @__PURE__ */ G7();
  return vr.SHA256 = e.SHA256, vr.sha256 = e.sha256, vr.SHA224 = e.SHA224, vr.sha224 = e.sha224, vr;
}
var Co, r1;
function Z7() {
  if (r1) return Co;
  r1 = 1;
  function e(c) {
    if (c.length >= 255)
      throw new TypeError("Alphabet too long");
    for (var d = new Uint8Array(256), w = 0; w < d.length; w++)
      d[w] = 255;
    for (var g = 0; g < c.length; g++) {
      var f = c.charAt(g), n = f.charCodeAt(0);
      if (d[n] !== 255)
        throw new TypeError(f + " is ambiguous");
      d[n] = g;
    }
    var u = c.length, a = c.charAt(0), s = Math.log(u) / Math.log(256), i = Math.log(256) / Math.log(u);
    function p(v) {
      if (v instanceof Uint8Array || (ArrayBuffer.isView(v) ? v = new Uint8Array(v.buffer, v.byteOffset, v.byteLength) : Array.isArray(v) && (v = Uint8Array.from(v))), !(v instanceof Uint8Array))
        throw new TypeError("Expected Uint8Array");
      if (v.length === 0)
        return "";
      for (var b = 0, h = 0, o = 0, S = v.length; o !== S && v[o] === 0; )
        o++, b++;
      for (var H = (S - o) * i + 1 >>> 0, j = new Uint8Array(H); o !== S; ) {
        for (var J = v[o], N = 0, z = H - 1; (J !== 0 || N < h) && z !== -1; z--, N++)
          J += 256 * j[z] >>> 0, j[z] = J % u >>> 0, J = J / u >>> 0;
        if (J !== 0)
          throw new Error("Non-zero carry");
        h = N, o++;
      }
      for (var A = H - h; A !== H && j[A] === 0; )
        A++;
      for (var q = a.repeat(b); A < H; ++A)
        q += c.charAt(j[A]);
      return q;
    }
    function m(v) {
      if (typeof v != "string")
        throw new TypeError("Expected String");
      if (v.length === 0)
        return new Uint8Array();
      for (var b = 0, h = 0, o = 0; v[b] === a; )
        h++, b++;
      for (var S = (v.length - b) * s + 1 >>> 0, H = new Uint8Array(S); v[b]; ) {
        var j = v.charCodeAt(b);
        if (j > 255)
          return;
        var J = d[j];
        if (J === 255)
          return;
        for (var N = 0, z = S - 1; (J !== 0 || N < o) && z !== -1; z--, N++)
          J += u * H[z] >>> 0, H[z] = J % 256 >>> 0, J = J / 256 >>> 0;
        if (J !== 0)
          throw new Error("Non-zero carry");
        o = N, b++;
      }
      for (var A = S - o; A !== S && H[A] === 0; )
        A++;
      for (var q = new Uint8Array(h + (S - A)), _ = h; A !== S; )
        q[_++] = H[A++];
      return q;
    }
    function E(v) {
      var b = m(v);
      if (b)
        return b;
      throw new Error("Non-base" + u + " character");
    }
    return {
      encode: p,
      decodeUnsafe: m,
      decode: E
    };
  }
  return Co = e, Co;
}
var Do, i1;
function Q7() {
  return i1 || (i1 = 1, Do = Z7()("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz")), Do;
}
var Uo, n1;
function ep() {
  if (n1) return Uo;
  n1 = 1;
  var e = Q7();
  return Uo = function(c) {
    function d(n) {
      var u = Uint8Array.from(n), a = c(u), s = u.length + 4, i = new Uint8Array(s);
      return i.set(u, 0), i.set(a.subarray(0, 4), u.length), e.encode(i, s);
    }
    function w(n) {
      var u = n.slice(0, -4), a = n.slice(-4), s = c(u);
      if (!(a[0] ^ s[0] | a[1] ^ s[1] | a[2] ^ s[2] | a[3] ^ s[3]))
        return u;
    }
    function g(n) {
      var u = e.decodeUnsafe(n);
      if (u)
        return w(u);
    }
    function f(n) {
      var u = e.decode(n), a = w(u);
      if (!a) throw new Error("Invalid checksum");
      return a;
    }
    return {
      encode: d,
      decode: f,
      decodeUnsafe: g
    };
  }, Uo;
}
var Fo, s1;
function tp() {
  if (s1) return Fo;
  s1 = 1;
  var { sha256: e } = /* @__PURE__ */ W7(), c = ep();
  function d(w) {
    return e(e(w));
  }
  return Fo = c(d), Fo;
}
var An, o1;
function o8() {
  if (o1) return An;
  o1 = 1;
  /**
   * @license
   * https://reviews.bitcoinabc.org
   * Copyright (c) 2017-2020 Emilio Almansi
   * Copyright (c) 2023-2024 Bitcoin ABC
   * Distributed under the MIT software license, see the accompanying
   * file LICENSE or http://www.opensource.org/licenses/mit-license.php.
   */
  var e = An && An.__importDefault || function(D) {
    return D && D.__esModule ? D : { default: D };
  };
  const c = e(V7()), d = e($7()), w = e(j7()), g = e(tp()), f = e(Ih()), { validate: n, ValidationError: u } = f.default;
  function a(D, Q, Z) {
    n(typeof D == "string" && m(D), "Invalid prefix: " + D + "."), n(typeof Q == "string", "Invalid type: " + Q + "."), n(Z instanceof Uint8Array || typeof Z == "string", "Invalid hash: " + Z + ". Must be string or Uint8Array."), typeof Z == "string" && (Z = q(Z));
    const oe = J(E(D), new Uint8Array(1)), y = b(Q) + o(Z), Y = H(J(new Uint8Array([y]), Z)), he = J(J(oe, Y), new Uint8Array(8)), be = J(Y, v(N(he)));
    return D + ":" + c.default.encode(be);
  }
  function s(D, Q = !1) {
    n(typeof D == "string" && A(D), "Invalid address: " + D + ".");
    const Z = D.toLowerCase().split(":");
    let oe, y;
    if (Z.length === 1) {
      let Ie = !1;
      for (let ve = 0; ve < i.length; ve += 1) {
        const C = i[ve], I = c.default.decode(Z[0]);
        if (Ie = z(C, I), Ie) {
          oe = C, y = I;
          break;
        }
      }
      n(Ie, `Prefixless address ${D} does not have valid checksum for any valid prefix (${i.join(", ")})`);
    } else
      n(Z.length === 2, "Invalid address: " + D + "."), oe = Z[0], y = c.default.decode(Z[1]), n(z(oe, y), "Invalid checksum: " + D + ".");
    const Y = j(y.subarray(0, -8)), he = Y[0], be = Y.subarray(1);
    n(S(he) === be.length * 8, "Invalid hash size: " + D + ".");
    const xe = h(he);
    return {
      prefix: oe,
      type: Q ? xe.toLowerCase() : xe,
      hash: Q ? _(be) : be
    };
  }
  const i = [
    "ecash",
    "bitcoincash",
    "simpleledger",
    "etoken",
    "ectest",
    "ecregtest",
    "bchtest",
    "bchreg"
  ], p = [
    "ecash",
    "bitcoincash",
    "simpleledger",
    "etoken"
  ];
  function m(D) {
    return A(D) && i.indexOf(D.toLowerCase()) !== -1;
  }
  function E(D) {
    const Q = new Uint8Array(D.length);
    for (let Z = 0; Z < D.length; ++Z)
      Q[Z] = D[Z].charCodeAt(0) & 31;
    return Q;
  }
  function v(D) {
    const Q = new Uint8Array(8);
    for (let Z = 0; Z < 8; ++Z)
      Q[7 - Z] = D.and(31).toJSNumber(), D = D.shiftRight(5);
    return Q;
  }
  function b(D) {
    switch (D) {
      case "p2pkh":
      case "P2PKH":
        return 0;
      case "p2sh":
      case "P2SH":
        return 8;
      default:
        throw new u("Invalid type: " + D + ".");
    }
  }
  function h(D) {
    switch (D & 120) {
      case 0:
        return "P2PKH";
      case 8:
        return "P2SH";
      default:
        throw new u("Invalid address type in version byte: " + D + ".");
    }
  }
  function o(D) {
    switch (D.length * 8) {
      case 160:
        return 0;
      case 192:
        return 1;
      case 224:
        return 2;
      case 256:
        return 3;
      case 320:
        return 4;
      case 384:
        return 5;
      case 448:
        return 6;
      case 512:
        return 7;
      default:
        throw new u("Invalid hash size: " + D.length + ".");
    }
  }
  function S(D) {
    switch (D & 7) {
      case 0:
        return 160;
      case 1:
        return 192;
      case 2:
        return 224;
      case 3:
        return 256;
      case 4:
        return 320;
      case 5:
        return 384;
      case 6:
        return 448;
      case 7:
        return 512;
      default:
        throw new Error("Invalid input");
    }
  }
  function H(D) {
    return (0, d.default)(D, 8, 5);
  }
  function j(D) {
    return (0, d.default)(D, 5, 8, !0);
  }
  function J(D, Q) {
    const Z = new Uint8Array(D.length + Q.length);
    return Z.set(D), Z.set(Q, D.length), Z;
  }
  function N(D) {
    const Q = [
      656907472481,
      522768456162,
      1044723512260,
      748107326120,
      130178868336
    ];
    let Z = (0, w.default)(1);
    for (let oe = 0; oe < D.length; ++oe) {
      const y = D[oe], Y = Z.shiftRight(35);
      Z = Z.and(34359738367).shiftLeft(5).xor(y);
      for (let he = 0; he < Q.length; ++he)
        Y.shiftRight(he).and(1).equals(1) && (Z = Z.xor(Q[he]));
    }
    return Z.xor(1);
  }
  function z(D, Q) {
    const Z = J(E(D), new Uint8Array(1)), oe = J(Z, Q);
    return N(oe).equals(0);
  }
  function A(D) {
    return D === D.toLowerCase() || D === D.toUpperCase();
  }
  function q(D) {
    const Q = new Uint8Array(D.length / 2);
    for (let Z = 0; Z < D.length; Z += 2)
      Q[Z / 2] = parseInt(D.slice(Z, Z + 2), 16);
    return Q;
  }
  function _(D) {
    let Q = "";
    for (let Z = 0; Z < D.length; Z++) {
      let oe = D[Z].toString(16);
      oe = oe.length === 1 ? "0" + oe : oe, Q += oe;
    }
    return Q;
  }
  function F(D) {
    const Q = "76a914", Z = "88ac", oe = "a914";
    let Y, he;
    if (D.slice(0, Q.length) === Q && D.slice(-1 * Z.length) === Z)
      he = "p2pkh", Y = D.substring(D.indexOf(Q) + Q.length, D.lastIndexOf(Z));
    else if (D.slice(0, oe.length) === oe && D.slice(-2) === "87")
      he = "p2sh", Y = D.substring(D.indexOf(oe) + oe.length, D.lastIndexOf("87"));
    else
      throw new u("Unsupported outputScript: " + D);
    if (![20, 24, 28, 32, 40, 48, 56, 64].includes(Y.length / 2))
      throw new u("Invalid hash size in outputScript: " + D);
    return { type: he, hash: Y };
  }
  function R(D, Q = "ecash") {
    const { type: Z, hash: oe } = F(D);
    return a(Q, Z, oe);
  }
  function V(D) {
    const { prefix: Q, type: Z, hash: oe } = s(D), y = p.includes(Q);
    let Y;
    switch (Z) {
      case "P2PKH":
        Y = y ? 0 : 111;
        break;
      case "P2SH":
        Y = y ? 5 : 196;
        break;
      default:
        throw new u("Unsupported address type: " + Z);
    }
    const he = new Uint8Array(1 + oe.length);
    return he[0] = Y, he.set(oe, 1), g.default.encode(he);
  }
  function fe(D, Q = !1) {
    try {
      const { prefix: Z } = s(D);
      return Q ? Z === Q : !0;
    } catch {
      return !1;
    }
  }
  function ue(D) {
    const { type: Q, hash: Z } = s(D, !0);
    let oe;
    return Q === "p2pkh" ? oe = `76a914${Z}88ac` : oe = `a914${Z}87`, oe;
  }
  return An = {
    encode: a,
    decode: s,
    uint8arrayToHexString: _,
    encodeOutputScript: R,
    getTypeAndHashFromOutputScript: F,
    toLegacy: V,
    isValidCashAddress: fe,
    getOutputScriptFromAddress: ue
  }, An;
}
var rp = o8();
const Oi = /* @__PURE__ */ Cr(rp);
var On = {};
/*!
 * int64.js - int64 object for javascript.
 * Copyright (c) 2017, Christopher Jeffrey (MIT License).
 * https://github.com/chjj/n64
 */
var a1;
function Ah() {
  if (a1) return On;
  a1 = 1;
  function e(b) {
    n(this instanceof e, "this", "N64"), n(b === 0 || b === 1, "sign", "bit"), this.hi = 0, this.lo = 0, this.sign = b;
  }
  e.prototype._add = function(h, o) {
    const S = this.hi, H = this.lo, j = H + o | 0, J = j >> 31, N = H >> 31, z = o >> 31, A = (N & z | ~J & (N ^ z)) & 1, q = (S + h | 0) + A;
    return this.hi = q | 0, this.lo = j, this;
  }, e.prototype.iadd = function(h) {
    return n(e.isN64(h), "operand", "int64"), this._add(h.hi, h.lo);
  }, e.prototype.iaddn = function(h) {
    return n(u(h), "operand", "number"), this._add(h >> 31 & -this.sign, h | 0);
  }, e.prototype.add = function(h) {
    return this.clone().iadd(h);
  }, e.prototype.addn = function(h) {
    return this.clone().iaddn(h);
  }, e.prototype._sub = function(h, o) {
    return h = ~h, o = ~o, o === -1 ? (o = 0, h += 1, h |= 0) : o += 1, this._add(h, o);
  }, e.prototype.isub = function(h) {
    return n(e.isN64(h), "operand", "int64"), this._sub(h.hi, h.lo);
  }, e.prototype.isubn = function(h) {
    return n(u(h), "operand", "number"), this._sub(h >> 31 & -this.sign, h | 0);
  }, e.prototype.sub = function(h) {
    return this.clone().isub(h);
  }, e.prototype.subn = function(h) {
    return this.clone().isubn(h);
  }, e.prototype._mul = function(h, o) {
    const S = this.hi, H = this.lo, j = S >>> 16, J = S & 65535, N = H >>> 16, z = H & 65535, A = h >>> 16, q = h & 65535, _ = o >>> 16, F = o & 65535;
    let R = 0, V = 0, fe = 0, ue = 0;
    ue += z * F, fe += ue >>> 16, ue &= 65535, fe += N * F, V += fe >>> 16, fe &= 65535, fe += z * _, V += fe >>> 16, fe &= 65535, V += J * F, R += V >>> 16, V &= 65535, V += N * _, R += V >>> 16, V &= 65535, V += z * q, R += V >>> 16, V &= 65535, R += j * F + J * _ + N * q + z * A, R &= 65535;
    const ae = R << 16 | V, D = fe << 16 | ue;
    return this.hi = ae, this.lo = D, this;
  }, e.prototype.imul = function(h) {
    return n(e.isN64(h), "multiplicand", "int64"), this._mul(h.hi, h.lo);
  }, e.prototype.imuln = function(h) {
    return n(u(h), "multiplicand", "number"), this._mul(h >> 31 & -this.sign, h | 0);
  }, e.prototype.mul = function(h) {
    return this.clone().imul(h);
  }, e.prototype.muln = function(h) {
    return this.clone().imuln(h);
  }, e.prototype.idiv = function(h) {
    let o = this;
    if (n(e.isN64(h), "divisor", "int64"), h.isZero())
      throw new Error("Cannot divide by zero.");
    if (o.isZero())
      return o;
    if (o.eq(h))
      return o.set(1);
    if (o.isSafe() && h.isSafe()) {
      const A = o.toDouble(), q = h.toDouble(), _ = f(A / q);
      return o.set(_);
    }
    let S = !1;
    o.sign && (o.hi < 0 ? h.hi < 0 ? (o = o.ineg(), h = h.neg()) : (o = o.ineg(), S = !0) : h.hi < 0 && (h = h.neg(), S = !0));
    const H = o.toU64(), j = h.toU64();
    if (H.lt(j))
      return o.set(0);
    if (H.ushrn(1).lt(j))
      return o.set(S ? -1 : 1);
    const J = new c(), N = new c();
    let z = H.bitLength();
    for (; z--; )
      N.ishln(1), N.lo |= H.testn(z), N.gte(j) && (N.isub(j), J.setn(z, 1));
    return o.hi = J.hi, o.lo = J.lo, S && o.ineg(), o;
  }, e.prototype.idivn = function(h) {
    return n(u(h), "divisor", "number"), this.idiv(this._small(h));
  }, e.prototype.div = function(h) {
    return this.clone().idiv(h);
  }, e.prototype.divn = function(h) {
    return this.clone().idivn(h);
  }, e.prototype.imod = function(h) {
    const o = this;
    if (n(e.isN64(h), "divisor", "int64"), h.isZero())
      throw new Error("Cannot divide by zero.");
    if (o.isZero())
      return o;
    if (o.eq(h))
      return o.set(0);
    if (o.isSafe() && h.isSafe()) {
      const S = o.toDouble(), H = h.toDouble(), j = S % H;
      return o.set(j);
    }
    return o.isub(o.div(h).imul(h));
  }, e.prototype.imodn = function(h) {
    return n(u(h), "divisor", "number"), this.imod(this._small(h));
  }, e.prototype.mod = function(h) {
    return this.clone().imod(h);
  }, e.prototype.modn = function(h) {
    return this.clone().imodn(h);
  }, e.prototype.ipow = function(h) {
    return n(e.isN64(h), "exponent", "int64"), this.ipown(h.lo);
  }, e.prototype.ipown = function(h) {
    if (n(u(h), "exponent", "number"), this.isZero())
      return this;
    const o = this.clone(), S = this;
    let H = h >>> 0;
    for (S.set(1); H > 0; )
      H & 1 && S.imul(o), H >>>= 1, o.imul(o);
    return S;
  }, e.prototype.pow = function(h) {
    return this.clone().ipow(h);
  }, e.prototype.pown = function(h) {
    return this.clone().ipown(h);
  }, e.prototype.sqr = function() {
    return this.mul(this);
  }, e.prototype.isqr = function() {
    return this.imul(this);
  }, e.prototype.iand = function(h) {
    return n(e.isN64(h), "operand", "int64"), this.hi &= h.hi, this.lo &= h.lo, this;
  }, e.prototype.iandn = function(h) {
    return n(u(h), "operand", "number"), this.hi &= h >> 31 & -this.sign, this.lo &= h | 0, this;
  }, e.prototype.and = function(h) {
    return this.clone().iand(h);
  }, e.prototype.andn = function(h) {
    return this.clone().iandn(h);
  }, e.prototype.ior = function(h) {
    return n(e.isN64(h), "operand", "int64"), this.hi |= h.hi, this.lo |= h.lo, this;
  }, e.prototype.iorn = function(h) {
    return n(u(h), "operand", "number"), this.hi |= h >> 31 & -this.sign, this.lo |= h | 0, this;
  }, e.prototype.or = function(h) {
    return this.clone().ior(h);
  }, e.prototype.orn = function(h) {
    return this.clone().iorn(h);
  }, e.prototype.ixor = function(h) {
    return n(e.isN64(h), "operand", "int64"), this.hi ^= h.hi, this.lo ^= h.lo, this;
  }, e.prototype.ixorn = function(h) {
    return n(u(h), "operand", "number"), this.hi ^= h >> 31 & -this.sign, this.lo ^= h | 0, this;
  }, e.prototype.xor = function(h) {
    return this.clone().ixor(h);
  }, e.prototype.xorn = function(h) {
    return this.clone().ixorn(h);
  }, e.prototype.inot = function() {
    return this.hi = ~this.hi, this.lo = ~this.lo, this;
  }, e.prototype.not = function() {
    return this.clone().inot();
  }, e.prototype.ishl = function(h) {
    return n(e.isN64(h), "bits", "int64"), this.ishln(h.lo);
  }, e.prototype.ishln = function(h) {
    if (n(u(h), "bits", "number"), h &= 63, h === 0)
      return this;
    let o = this.hi, S = this.lo;
    return h < 32 ? (o <<= h, o |= S >>> 32 - h, S <<= h) : (o = S << h - 32, S = 0), this.hi = o, this.lo = S, this;
  }, e.prototype.shl = function(h) {
    return this.clone().ishl(h);
  }, e.prototype.shln = function(h) {
    return this.clone().ishln(h);
  }, e.prototype.ishr = function(h) {
    return n(e.isN64(h), "bits", "int64"), this.ishrn(h.lo);
  }, e.prototype.ishrn = function(h) {
    if (!this.sign)
      return this.iushrn(h);
    if (n(u(h), "bits", "number"), h &= 63, h === 0)
      return this;
    let o = this.hi, S = this.lo;
    return h < 32 ? (S >>>= h, S |= o << 32 - h, o >>= h) : (S = o >> h - 32, o = o >> 31), this.hi = o, this.lo = S, this;
  }, e.prototype.shr = function(h) {
    return this.clone().ishr(h);
  }, e.prototype.shrn = function(h) {
    return this.clone().ishrn(h);
  }, e.prototype.iushr = function(h) {
    return n(e.isN64(h), "bits", "int64"), this.iushrn(h.lo);
  }, e.prototype.iushrn = function(h) {
    if (n(u(h), "bits", "number"), h &= 63, h === 0)
      return this;
    let o = this.hi, S = this.lo;
    return h < 32 ? (S >>>= h, S |= o << 32 - h, o >>>= h) : (S = o >>> h - 32, o = 0), this.hi = o | 0, this.lo = S | 0, this;
  }, e.prototype.ushr = function(h) {
    return this.clone().iushr(h);
  }, e.prototype.ushrn = function(h) {
    return this.clone().iushrn(h);
  }, e.prototype.setn = function(h, o) {
    return n(u(h), "bit", "number"), h &= 63, h < 32 ? o ? this.lo |= 1 << h : this.lo &= ~(1 << h) : o ? this.hi |= 1 << h - 32 : this.hi &= ~(1 << h - 32), this;
  }, e.prototype.testn = function(h) {
    return n(u(h), "bit", "number"), h &= 63, h < 32 ? this.lo >>> h & 1 : this.hi >>> h - 32 & 1;
  }, e.prototype.setb = function(h, o) {
    return n(u(h), "pos", "number"), n(u(o), "ch", "number"), h &= 7, o &= 255, h < 4 ? (this.lo &= ~(255 << h * 8), this.lo |= o << h * 8) : (this.hi &= ~(255 << (h - 4) * 8), this.hi |= o << (h - 4) * 8), this;
  }, e.prototype.orb = function(h, o) {
    return n(u(h), "pos", "number"), n(u(o), "ch", "number"), h &= 7, o &= 255, h < 4 ? this.lo |= o << h * 8 : this.hi |= o << (h - 4) * 8, this;
  }, e.prototype.getb = function(h) {
    return n(u(h), "pos", "number"), h &= 7, h < 4 ? this.lo >> h * 8 & 255 : this.hi >> (h - 4) * 8 & 255;
  }, e.prototype.imaskn = function(h) {
    return n(u(h), "bit", "number"), h &= 63, h < 32 ? (this.hi = 0, this.lo &= (1 << h) - 1) : (this.hi &= (1 << h - 32) - 1, this.lo &= 4294967295), this;
  }, e.prototype.maskn = function(h) {
    return this.clone().imaskn(h);
  }, e.prototype.andln = function(h) {
    return n(u(h), "operand", "number"), this.lo & h;
  }, e.prototype.ineg = function() {
    let h = ~this.hi, o = ~this.lo;
    return o === -1 ? (o = 0, h += 1, h |= 0) : o += 1, this.hi = h, this.lo = o, this;
  }, e.prototype.neg = function() {
    return this.clone().ineg();
  }, e.prototype.iabs = function() {
    return this.isNeg() && this.ineg(), this;
  }, e.prototype.abs = function() {
    return this.clone().iabs();
  }, e.prototype._cmp = function(h, o) {
    const S = this;
    let H = S.hi, j = S.lo;
    if (H === h && j === o)
      return 0;
    let J = !1;
    if (S.sign) {
      const N = H < 0, z = h < 0;
      if (N && !z)
        return -1;
      if (!N && z)
        return 1;
      J = N;
    }
    return J || (H >>>= 0, h >>>= 0), H < h ? -1 : H > h ? 1 : (j >>>= 0, o >>>= 0, j < o ? -1 : 1);
  }, e.prototype.cmp = function(h) {
    return n(e.isN64(h), "value", "int64"), this._cmp(h.hi, h.lo);
  }, e.prototype.cmpn = function(h) {
    return n(u(h), "value", "number"), this._cmp(h >> 31 & -this.sign, h | 0);
  }, e.prototype.eq = function(h) {
    return n(e.isN64(h), "value", "int64"), this.hi === h.hi && this.lo === h.lo;
  }, e.prototype.eqn = function(h) {
    return n(u(h), "value", "number"), this.hi === (h >> 31 & -this.sign) && this.lo === (h | 0);
  }, e.prototype.gt = function(h) {
    return this.cmp(h) > 0;
  }, e.prototype.gtn = function(h) {
    return this.cmpn(h) > 0;
  }, e.prototype.gte = function(h) {
    return this.cmp(h) >= 0;
  }, e.prototype.gten = function(h) {
    return this.cmpn(h) >= 0;
  }, e.prototype.lt = function(h) {
    return this.cmp(h) < 0;
  }, e.prototype.ltn = function(h) {
    return this.cmpn(h) < 0;
  }, e.prototype.lte = function(h) {
    return this.cmp(h) <= 0;
  }, e.prototype.lten = function(h) {
    return this.cmpn(h) <= 0;
  }, e.prototype.isZero = function() {
    return this.hi === 0 && this.lo === 0;
  }, e.prototype.isNeg = function() {
    return this.sign === 1 && this.hi < 0;
  }, e.prototype.isOdd = function() {
    return (this.lo & 1) === 1;
  }, e.prototype.isEven = function() {
    return (this.lo & 1) === 0;
  }, e.prototype.clone = function() {
    const h = new this.constructor();
    return h.hi = this.hi, h.lo = this.lo, h;
  }, e.prototype.inject = function(h) {
    return n(e.isN64(h), "value", "int64"), this.hi = h.hi, this.lo = h.lo, this;
  }, e.prototype.set = function(h) {
    n(s(h), "number", "integer");
    let o = !1;
    return h < 0 && (h = -h, o = !0), this.hi = h * (1 / 4294967296) | 0, this.lo = h | 0, o && this.ineg(), this;
  }, e.prototype.join = function(h, o) {
    return n(u(h), "hi", "number"), n(u(o), "lo", "number"), this.hi = h | 0, this.lo = o | 0, this;
  }, e.prototype._small = function(h) {
    const o = new this.constructor();
    return o.hi = h >> 31 & -this.sign, o.lo = h | 0, o;
  }, e.prototype.bitLength = function() {
    let h = this;
    return this.isNeg() && (h = this.neg()), h.hi === 0 ? g(h.lo) : g(h.hi) + 32;
  }, e.prototype.byteLength = function() {
    return Math.ceil(this.bitLength() / 8);
  }, e.prototype.isSafe = function() {
    let h = this.hi;
    return this.isNeg() && (h = ~h, this.lo === 0 && (h += 1)), (h & 4292870144) === 0;
  }, e.prototype.inspect = function() {
    let h = "I64";
    return this.sign || (h = "U64"), `<${h}: ${this.toString(10)}>`;
  }, e.prototype.readLE = function(h, o) {
    return n(h && typeof h.length == "number", "data", "arraylike"), n(o >> 0 === o, "offset", "integer"), n(o + 8 <= h.length, "offset", "valid offset"), this.lo = p(h, o), this.hi = p(h, o + 4), o + 8;
  }, e.prototype.readBE = function(h, o) {
    return n(h && typeof h.length == "number", "data", "arraylike"), n(o >> 0 === o, "offset", "integer"), n(o + 8 <= h.length, "offset", "valid offset"), this.hi = m(h, o), this.lo = m(h, o + 4), o + 8;
  }, e.prototype.readRaw = function(h, o) {
    return this.readLE(h, o);
  }, e.prototype.writeLE = function(h, o) {
    return n(h && typeof h.length == "number", "data", "arraylike"), n(o >> 0 === o, "offset", "integer"), n(o + 8 <= h.length, "offset", "valid offset"), E(h, this.lo, o), E(h, this.hi, o + 4), o + 8;
  }, e.prototype.writeBE = function(h, o) {
    return n(h && typeof h.length == "number", "data", "arraylike"), n(o >> 0 === o, "offset", "integer"), n(o + 8 <= h.length, "offset", "valid offset"), v(h, this.hi, o), v(h, this.lo, o + 4), o + 8;
  }, e.prototype.writeRaw = function(h, o) {
    return this.writeLE(h, o);
  }, e.prototype.toU64 = function() {
    const h = new c();
    return h.hi = this.hi, h.lo = this.lo, h;
  }, e.prototype.toI64 = function() {
    const h = new d();
    return h.hi = this.hi, h.lo = this.lo, h;
  }, e.prototype.toNumber = function() {
    if (!this.isSafe())
      throw new Error("Number exceeds 53 bits.");
    return this.toDouble();
  }, e.prototype.toDouble = function() {
    let h = this.hi;
    return this.sign || (h >>>= 0), h * 4294967296 + (this.lo >>> 0);
  }, e.prototype.toInt = function() {
    return this.sign ? this.lo : this.lo >>> 0;
  }, e.prototype.toBool = function() {
    return !this.isZero();
  }, e.prototype.toBits = function() {
    return [this.hi, this.lo];
  }, e.prototype.toObject = function() {
    return { hi: this.hi, lo: this.lo };
  }, e.prototype.toString = function(h, o) {
    if (h = w(h), o == null && (o = 0), n(h >>> 0 === h, "base", "integer"), n(o >>> 0 === o, "pad", "integer"), h < 2 || h > 16)
      throw new Error("Base ranges between 2 and 16.");
    if (o > 64)
      throw new Error("Maximum padding is 64 characters.");
    let S = this, H = !1;
    S.isNeg() && (S = S.neg(), H = !0);
    let j = S.hi >>> 0, J = S.lo >>> 0, N = "";
    do {
      const z = j % h;
      j -= z, j /= h, J += z * 4294967296;
      const A = J % h;
      J -= A, J /= h;
      let q = A;
      q < 10 ? q += 48 : q += 87, N = String.fromCharCode(q) + N;
    } while (J > 0 || j > 0);
    for (; N.length < o; )
      N = "0" + N;
    return H && (N = "-" + N), N;
  }, e.prototype.toJSON = function() {
    return this.toString(16, 16);
  }, e.prototype.toBN = function(h) {
    const o = this.isNeg();
    let S = this.hi, H = this.lo;
    o && (S = ~S, H = ~H, H === -1 ? (H = 0, S += 1, S |= 0) : H += 1), S >>>= 0, H >>>= 0;
    const j = new h(S);
    return j.ishln(32), j.iadd(new h(H)), o && j.ineg(), j;
  }, e.prototype.toLE = function(h) {
    n(typeof h == "function", "ArrayLike", "constructor");
    const o = i(h, 8);
    return this.writeLE(o, 0), o;
  }, e.prototype.toBE = function(h) {
    n(typeof h == "function", "ArrayLike", "constructor");
    const o = i(h, 8);
    return this.writeBE(o, 0), o;
  }, e.prototype.toRaw = function(h) {
    return this.toLE(h);
  }, e.prototype.fromNumber = function(h) {
    return this.set(h);
  }, e.prototype.fromInt = function(h) {
    return n(u(h), "integer", "number"), this.join(h >> 31 & -this.sign, h);
  }, e.prototype.fromBool = function(h) {
    return n(typeof h == "boolean", "value", "boolean"), this.hi = 0, this.lo = h ? 1 : 0, this;
  }, e.prototype.fromBits = function(h, o) {
    return this.join(h, o);
  }, e.prototype.fromObject = function(h) {
    return n(h && typeof h == "object", "number", "object"), this.fromBits(h.hi, h.lo);
  }, e.prototype.fromString = function(h, o) {
    if (o = w(o), n(typeof h == "string", "string", "string"), n(o >>> 0 === o, "base", "integer"), o < 2 || o > 16)
      throw new Error("Base ranges between 2 and 16.");
    let S = !1, H = 0;
    if (h.length > 0 && h[0] === "-" && (H += 1, S = !0), h.length === H || h.length > H + 64)
      throw new Error("Invalid string (bad length).");
    let j = 0, J = 0;
    for (; H < h.length; H++) {
      let N = h.charCodeAt(H);
      if (N >= 48 && N <= 57 ? N -= 48 : N >= 65 && N <= 90 ? N -= 55 : N >= 97 && N <= 122 ? N -= 87 : N = o, N >= o)
        throw new Error("Invalid string (parse error).");
      if (J *= o, J += N, j *= o, J > 4294967295 && (N = J % 4294967296, j += (J - N) / 4294967296, J = N), j > 4294967295)
        throw new Error("Invalid string (overflow).");
    }
    return this.hi = j | 0, this.lo = J | 0, S && this.ineg(), this;
  }, e.prototype.fromJSON = function(h) {
    return this.fromString(h, 16);
  }, e.prototype.fromBN = function(h) {
    n(h && a(h.words), "number", "big number");
    const o = this, S = h.clone(), H = S.isNeg();
    if (o.sign && S.testn(63))
      throw new Error("Big number overflow.");
    let j = 0;
    for (; !S.isZero(); ) {
      if (j === 8)
        throw new Error("Big number overflow.");
      o.orb(j, S.andln(255)), S.iushrn(8), j++;
    }
    return H && o.ineg(), o;
  }, e.prototype.fromLE = function(h) {
    return this.readLE(h, 0), this;
  }, e.prototype.fromBE = function(h) {
    return this.readBE(h, 0), this;
  }, e.prototype.fromRaw = function(h) {
    return this.fromLE(h);
  }, e.prototype.from = function(h, o) {
    if (h == null)
      return this;
    if (typeof h == "number")
      return typeof o == "number" ? this.fromBits(h, o) : this.fromNumber(h);
    if (typeof h == "string")
      return this.fromString(h, o);
    if (typeof h == "object")
      return a(h.words) ? this.fromBN(h) : typeof h.length == "number" ? this.fromRaw(h) : this.fromObject(h);
    if (typeof h == "boolean")
      return this.fromBool(h);
    throw new TypeError("Non-numeric object passed to N64.");
  }, e.min = function(h, o) {
    return h.cmp(o) < 0 ? h : o;
  }, e.max = function(h, o) {
    return h.cmp(o) > 0 ? h : o;
  }, e.random = function() {
    const h = new this();
    return h.hi = Math.random() * 4294967296 | 0, h.lo = Math.random() * 4294967296 | 0, h;
  }, e.pow = function(h, o) {
    return new this().fromInt(h).ipown(o);
  }, e.shift = function(h, o) {
    return new this().fromInt(h).ishln(o);
  }, e.readLE = function(h, o) {
    const S = new this();
    return S.readLE(h, o), S;
  }, e.readBE = function(h, o) {
    const S = new this();
    return S.readBE(h, o), S;
  }, e.readRaw = function(h, o) {
    const S = new this();
    return S.readRaw(h, o), S;
  }, e.fromNumber = function(h) {
    return new this().fromNumber(h);
  }, e.fromInt = function(h) {
    return new this().fromInt(h);
  }, e.fromBool = function(h) {
    return new this().fromBool(h);
  }, e.fromBits = function(h, o) {
    return new this().fromBits(h, o);
  }, e.fromObject = function(h) {
    return new this().fromObject(h);
  }, e.fromString = function(h, o) {
    return new this().fromString(h, o);
  }, e.fromJSON = function(h) {
    return new this().fromJSON(h);
  }, e.fromBN = function(h) {
    return new this().fromBN(h);
  }, e.fromLE = function(h) {
    return new this().fromLE(h);
  }, e.fromBE = function(h) {
    return new this().fromBE(h);
  }, e.fromRaw = function(h) {
    return new this().fromRaw(h);
  }, e.from = function(h, o) {
    return new this().from(h, o);
  }, e.isN64 = function(h) {
    return h instanceof e;
  }, e.isU64 = function(h) {
    return h instanceof c;
  }, e.isI64 = function(h) {
    return h instanceof d;
  };
  function c(b, h) {
    if (!(this instanceof c))
      return new c(b, h);
    e.call(this, 0), this.from(b, h);
  }
  c.__proto__ = e, c.prototype.__proto__ = e.prototype, c.ULONG_MIN = 0, c.ULONG_MAX = 4294967295, c.UINT32_MIN = c(0, 0), c.UINT32_MAX = c(0, 4294967295), c.UINT64_MIN = c(0, 0), c.UINT64_MAX = c(4294967295, 4294967295);
  function d(b, h) {
    if (!(this instanceof d))
      return new d(b, h);
    e.call(this, 1), this.from(b, h);
  }
  d.__proto__ = e, d.prototype.__proto__ = e.prototype, d.LONG_MIN = -2147483648, d.LONG_MAX = 2147483647, d.INT32_MIN = d(4294967295, 2147483648), d.INT32_MAX = d(0, 2147483647), d.INT64_MIN = d(2147483648, 0), d.INT64_MAX = d(2147483647, 4294967295);
  function w(b) {
    if (b == null)
      return 10;
    if (typeof b == "number")
      return b;
    switch (b) {
      case "bin":
        return 2;
      case "oct":
        return 8;
      case "dec":
        return 10;
      case "hex":
        return 16;
    }
    return 0;
  }
  function g(b) {
    if (Math.clz32)
      return 32 - Math.clz32(b);
    let h = 31;
    for (; h >= 0 && (b & 1 << h) === 0; h--)
      ;
    return h + 1;
  }
  function f(b) {
    return b < 0 ? -Math.floor(-b) : Math.floor(b);
  }
  function n(b, h, o) {
    if (!b) {
      const S = new TypeError(`'${h}' must be a(n) ${o}.`);
      throw Error.captureStackTrace && Error.captureStackTrace(S, n), S;
    }
  }
  function u(b) {
    return typeof b == "number" && isFinite(b);
  }
  function a(b) {
    return Array.isArray ? Array.isArray(b) : {}.toString.call(b).slice(8, -1) === "Array";
  }
  function s(b) {
    return Number.isSafeInteger ? Number.isSafeInteger(b) : u(b) && Math.floor(b) === b && b >= -9007199254740991 && b <= 9007199254740991;
  }
  function i(b, h) {
    return b.allocUnsafe ? b.allocUnsafe(h) : new b(h);
  }
  function p(b, h) {
    return b[h] | b[h + 1] << 8 | b[h + 2] << 16 | b[h + 3] << 24;
  }
  function m(b, h) {
    return b[h] << 24 | b[h + 1] << 16 | b[h + 2] << 8 | b[h + 3];
  }
  function E(b, h, o) {
    b[o] = h & 255, b[o + 1] = h >>> 8 & 255, b[o + 2] = h >>> 16 & 255, b[o + 3] = h >>> 24 & 255;
  }
  function v(b, h, o) {
    b[o] = h >>> 24 & 255, b[o + 1] = h >>> 16 & 255, b[o + 2] = h >>> 8 & 255, b[o + 3] = h & 255;
  }
  return On.N64 = e, On.U64 = c, On.I64 = d, On;
}
var a8 = Ah();
const f8 = /* @__PURE__ */ Cr(a8);
var as = {}, Ho = {}, f1;
function ip() {
  return f1 || (f1 = 1, Ho.custom = "inspect"), Ho;
}
var c1;
function Dr() {
  if (c1) return as;
  c1 = 1;
  const { custom: e } = ip();
  class c {
    /**
     * @constructor
     * @param {Iterable<[BufferLike, V]>} [iterable]
     */
    constructor(p) {
      if (this.map = /* @__PURE__ */ new Map(), p != null)
        for (const [m, E] of p)
          this.set(m, E);
    }
    get size() {
      return this.map.size;
    }
    /**
     * @param {BufferLike} key
     * @returns {V?}
     */
    get(p) {
      const m = this.map.get(a(p));
      if (m)
        return m.value;
    }
    /**
     * @param {BufferLike} key
     * @returns {Boolean}
     */
    has(p) {
      return this.map.has(a(p));
    }
    /**
     * @param {BufferLike} key
     * @param {V} value
     * @returns {BufferMap<V>}
     */
    set(p, m) {
      return this.map.set(a(p), new w(p, m)), this;
    }
    /**
     * @param {BufferLike} key
     * @returns {Boolean}
     */
    delete(p) {
      return this.map.delete(a(p));
    }
    clear() {
      this.map.clear();
    }
    [Symbol.iterator]() {
      return this.entries();
    }
    *entries() {
      for (const { key: p, value: m } of this.map.values())
        yield [p, m];
    }
    *keys() {
      for (const { key: p } of this.map.values())
        yield p;
    }
    *values() {
      for (const { value: p } of this.map.values())
        yield p;
    }
    forEach(p, m) {
      if (typeof p != "function")
        throw new TypeError(`${typeof p} is not a function`);
      for (const { key: E, value: v } of this.map.values())
        p.call(m, v, E, this);
    }
    toKeys() {
      const p = [];
      for (const { key: m } of this.map.values())
        p.push(m);
      return p;
    }
    toValues() {
      const p = [];
      for (const { value: m } of this.map.values())
        p.push(m);
      return p;
    }
    toArray() {
      return this.toValues();
    }
    [e]() {
      const p = /* @__PURE__ */ new Map();
      for (const { key: m, value: E } of this.map.values())
        p.set(s(m), E);
      return p;
    }
  }
  class d {
    /**
     * @constructor
     * @param {Iterable<BufferLike>} [iterable]
     */
    constructor(p) {
      if (this.map = /* @__PURE__ */ new Map(), p != null)
        for (const m of p)
          this.add(m);
    }
    get size() {
      return this.map.size;
    }
    /**
     * @param {BufferLike} key
     * @returns {Boolean}
     */
    has(p) {
      return this.map.has(a(p));
    }
    /**
     * @param {BufferLike} key
     * @returns {BufferSet}
     */
    add(p) {
      return this.map.set(a(p), p), this;
    }
    /**
     * @param {BufferLike} key
     * @returns {Boolean}
     */
    delete(p) {
      return this.map.delete(a(p));
    }
    clear() {
      this.map.clear();
    }
    [Symbol.iterator]() {
      return this.keys();
    }
    *entries() {
      for (const p of this.map.values())
        yield [p, p];
    }
    keys() {
      return this.map.values();
    }
    values() {
      return this.map.values();
    }
    forEach(p, m) {
      if (typeof p != "function")
        throw new TypeError(`${typeof p} is not a function`);
      for (const E of this.map.values())
        p.call(m, E, E, this);
    }
    toKeys() {
      const p = [];
      for (const m of this.map.values())
        p.push(m);
      return p;
    }
    toValues() {
      return this.toKeys();
    }
    toArray() {
      return this.toKeys();
    }
    [e]() {
      const p = /* @__PURE__ */ new Set();
      for (const m of this.map.values())
        p.add(s(m));
      return p;
    }
  }
  class w {
    /**
     * @param {BufferLike} key
     * @param {V} value
     */
    constructor(p, m) {
      this.key = p, this.value = m;
    }
  }
  const g = typeof SharedArrayBuffer == "function";
  function f(i) {
    return !!(i instanceof ArrayBuffer || g && i instanceof SharedArrayBuffer);
  }
  function n(i) {
    if (ArrayBuffer.isView(i))
      return k.from(i.buffer, i.byteOffset, i.byteLength);
    if (f(i))
      return k.from(i, 0, i.byteLength);
    throw new TypeError("Non-buffer passed to buffer map/set.");
  }
  function u(i, p) {
    return k.isBuffer(i) || (i = n(i)), i.toString(p);
  }
  function a(i) {
    return u(i, "binary");
  }
  function s(i) {
    return u(i, "hex");
  }
  return as.BufferMap = c, as.BufferSet = d, as;
}
var np = Dr();
const un = /* @__PURE__ */ Cr(np);
/*!
 * lru.js - LRU cache for bcoin
 * Copyright (c) 2014-2018, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var Lo, u1;
function sp() {
  if (u1) return Lo;
  u1 = 1;
  const e = $e();
  class c {
    /**
     * Create an LRU cache.
     * @constructor
     * @param {Number} capacity
     * @param {Function?} getSize
     * @param {Function?} CustomMap
     */
    constructor(n, u, a) {
      e(typeof n == "number", "Capacity must be a number."), e(n >= 0, "Capacity cannot be negative."), e(!u || typeof u == "function", "Bad size callback."), e(!a || typeof a == "function"), this.map = a ? new a() : /* @__PURE__ */ new Map(), this.size = 0, this.items = 0, this.head = null, this.tail = null, this.pending = null, this.capacity = n, this.getSize = u;
    }
    /**
     * Calculate size of an item.
     * @private
     * @param {LRUItem} item
     * @returns {Number} Size.
     */
    _getSize(n) {
      return this.getSize ? 120 + this.getSize(n.value, n.key) : 1;
    }
    /**
     * Compact the LRU linked list.
     * @private
     */
    _compact() {
      if (this.size <= this.capacity)
        return;
      let n = null, u = null;
      for (n = this.head; n && !(this.size <= this.capacity); n = u)
        this.size -= this._getSize(n), this.items -= 1, this.map.delete(n.key), u = n.next, n.prev = null, n.next = null;
      if (!n) {
        this.head = null, this.tail = null;
        return;
      }
      this.head = n, n.prev = null;
    }
    /**
     * Reset the cache. Clear all items.
     */
    reset() {
      let n, u;
      for (n = this.head; n; n = u)
        this.map.delete(n.key), this.items -= 1, u = n.next, n.prev = null, n.next = null;
      e(!n), this.size = 0, this.head = null, this.tail = null;
    }
    /**
     * Add an item to the cache.
     * @param {String|Number} key
     * @param {Object} value
     */
    set(n, u) {
      if (this.capacity === 0)
        return;
      let a = this.map.get(n);
      if (a) {
        this.size -= this._getSize(a), a.value = u, this.size += this._getSize(a), this._removeList(a), this._appendList(a), this._compact();
        return;
      }
      a = new d(n, u), this.map.set(n, a), this._appendList(a), this.size += this._getSize(a), this.items += 1, this._compact();
    }
    /**
     * Retrieve an item from the cache.
     * @param {String|Number} key
     * @returns {Object} Item.
     */
    get(n) {
      if (this.capacity === 0)
        return null;
      const u = this.map.get(n);
      return u ? (this._removeList(u), this._appendList(u), u.value) : null;
    }
    /**
     * Test whether the cache contains a key.
     * @param {String|Number} key
     * @returns {Boolean}
     */
    has(n) {
      return this.capacity === 0 ? !1 : this.map.has(n);
    }
    /**
     * Remove an item from the cache.
     * @param {String|Number} key
     * @returns {Boolean} Whether an item was removed.
     */
    remove(n) {
      if (this.capacity === 0)
        return !1;
      const u = this.map.get(n);
      return u ? (this.size -= this._getSize(u), this.items -= 1, this.map.delete(n), this._removeList(u), !0) : !1;
    }
    /**
     * Prepend an item to the linked list (sets new head).
     * @private
     * @param {LRUItem}
     */
    _prependList(n) {
      this._insertList(null, n);
    }
    /**
     * Append an item to the linked list (sets new tail).
     * @private
     * @param {LRUItem}
     */
    _appendList(n) {
      this._insertList(this.tail, n);
    }
    /**
     * Insert item into the linked list.
     * @private
     * @param {LRUItem|null} ref
     * @param {LRUItem} item
     */
    _insertList(n, u) {
      if (e(!u.next), e(!u.prev), n == null) {
        this.head ? (this.head.prev = u, u.next = this.head, this.head = u) : (this.head = u, this.tail = u);
        return;
      }
      u.next = n.next, u.prev = n, n.next = u, u.next && (u.next.prev = u), n === this.tail && (this.tail = u);
    }
    /**
     * Remove item from the linked list.
     * @private
     * @param {LRUItem}
     */
    _removeList(n) {
      n.prev && (n.prev.next = n.next), n.next && (n.next.prev = n.prev), n === this.head && (this.head = n.next), n === this.tail && (this.tail = n.prev || this.head), this.head || e(!this.tail), this.tail || e(!this.head), n.prev = null, n.next = null;
    }
    /**
     * Collect all keys in the cache, sorted by LRU.
     * @returns {String[]}
     */
    keys() {
      const n = [];
      for (let u = this.head; u; u = u.next)
        u === this.head && e(!u.prev), u.prev || e(u === this.head), u.next || e(u === this.tail), n.push(u.key);
      return n;
    }
    /**
     * Collect all values in the cache, sorted by LRU.
     * @returns {String[]}
     */
    values() {
      const n = [];
      for (let u = this.head; u; u = u.next)
        n.push(u.value);
      return n;
    }
    /**
     * Convert the LRU cache to an array of items.
     * @returns {Object[]}
     */
    toArray() {
      const n = [];
      for (let u = this.head; u; u = u.next)
        n.push(u);
      return n;
    }
    /**
     * Create an atomic batch for the lru
     * (used for caching database writes).
     * @returns {LRUBatch}
     */
    batch() {
      return new w(this);
    }
    /**
     * Start the pending batch.
     */
    start() {
      e(!this.pending), this.pending = this.batch();
    }
    /**
     * Clear the pending batch.
     */
    clear() {
      e(this.pending), this.pending.clear();
    }
    /**
     * Drop the pending batch.
     */
    drop() {
      e(this.pending), this.pending = null;
    }
    /**
     * Commit the pending batch.
     */
    commit() {
      e(this.pending), this.pending.commit(), this.pending = null;
    }
    /**
     * Push an item onto the pending batch.
     * @param {String} key
     * @param {Object} value
     */
    push(n, u) {
      e(this.pending), this.capacity !== 0 && this.pending.set(n, u);
    }
    /**
     * Push a removal onto the pending batch.
     * @param {String} key
     */
    unpush(n) {
      e(this.pending), this.capacity !== 0 && this.pending.remove(n);
    }
  }
  class d {
    /**
     * Create an LRU item.
     * @constructor
     * @private
     * @param {String} key
     * @param {Object} value
     */
    constructor(n, u) {
      this.key = n, this.value = u, this.next = null, this.prev = null;
    }
  }
  class w {
    /**
     * Create an LRU batch.
     * @constructor
     * @param {LRU} lru
     */
    constructor(n) {
      this.lru = n, this.ops = [];
    }
    /**
     * Push an item onto the batch.
     * @param {String} key
     * @param {Object} value
     */
    set(n, u) {
      this.ops.push(new g(!1, n, u));
    }
    /**
     * Push a removal onto the batch.
     * @param {String} key
     */
    remove(n) {
      this.ops.push(new g(!0, n, null));
    }
    /**
     * Clear the batch.
     */
    clear() {
      this.ops.length = 0;
    }
    /**
     * Commit the batch.
     */
    commit() {
      for (const n of this.ops) {
        if (n.remove) {
          this.lru.remove(n.key);
          continue;
        }
        this.lru.set(n.key, n.value);
      }
      this.ops.length = 0;
    }
  }
  class g {
    /**
     * Create an LRU op.
     * @constructor
     * @param {Boolean} remove
     * @param {String} key
     * @param {Object} value
     */
    constructor(n, u, a) {
      this.remove = n, this.key = u, this.value = a;
    }
  }
  return Lo = c, Lo;
}
var Ko, h1;
function c8() {
  return h1 || (h1 = 1, Ko = sp()), Ko;
}
var op = c8();
const ap = /* @__PURE__ */ Cr(op);
var fp = Ts();
const cp = /* @__PURE__ */ Cr(fp);
var up = Cs();
const hp = /* @__PURE__ */ Cr(up);
var sn = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof Ps < "u" ? Ps : typeof self < "u" ? self : {};
function lp(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function Oh(e) {
  if (Object.prototype.hasOwnProperty.call(e, "__esModule")) return e;
  var c = e.default;
  if (typeof c == "function") {
    var d = function w() {
      return this instanceof w ? Reflect.construct(c, arguments, this.constructor) : c.apply(this, arguments);
    };
    d.prototype = c.prototype;
  } else d = {};
  return Object.defineProperty(d, "__esModule", { value: !0 }), Object.keys(e).forEach(function(w) {
    var g = Object.getOwnPropertyDescriptor(e, w);
    Object.defineProperty(d, w, g.get ? g : {
      enumerable: !0,
      get: function() {
        return e[w];
      }
    });
  }), d;
}
var fs = { exports: {} }, cs = {}, Vo = {};
/*!
 * fixed.js - fixed number parsing
 * Copyright (c) 2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var l1;
function u8() {
  return l1 || (l1 = 1, function(e) {
    const c = nt;
    e.encode = function(n, u) {
      c(Number.isSafeInteger(n), "Invalid integer value.");
      let a = "";
      n < 0 && (n = -n, a = "-");
      const s = d(u);
      let i = n % s, p = (n - i) / s;
      for (i = i.toString(10), p = p.toString(10); i.length < u; )
        i = "0" + i;
      return i = i.replace(/0+$/, ""), c(i.length <= u, "Invalid integer value."), i.length === 0 && (i = "0"), u === 0 ? `${a}${p}` : `${a}${p}.${i}`;
    }, e.decode = function(n, u) {
      c(typeof n == "string"), c(n.length <= 32, "Fixed number string too large.");
      let a = 1;
      n.length > 0 && n[0] === "-" && (n = n.substring(1), a = -1);
      let s = n, i = "0";
      const p = n.indexOf(".");
      for (p !== -1 && (s = n.substring(0, p), i = n.substring(p + 1)), s = s.replace(/^0+/, ""), i = i.replace(/0+$/, ""), c(
        s.length <= 16 - u,
        "Fixed number string exceeds 2^53-1."
      ), c(
        i.length <= u,
        "Too many decimal places in fixed number string."
      ), s.length === 0 && (s = "0"); i.length < u; )
        i += "0";
      i.length === 0 && (i = "0"), c(
        /^\d+$/.test(s) && /^\d+$/.test(i),
        "Non-numeric characters in fixed number string."
      ), s = parseInt(s, 10), i = parseInt(i, 10);
      const m = d(u), E = w(m), v = g(m);
      return c(
        s < v || s === v && i <= E,
        "Fixed number string exceeds 2^53-1."
      ), a * (s * m + i);
    }, e.toFloat = function(n, u) {
      return parseFloat(e.encode(n, u));
    }, e.fromFloat = function(n, u) {
      return c(typeof n == "number" && isFinite(n)), c(Number.isSafeInteger(u)), e.decode(n.toFixed(u), u);
    };
    function d(f) {
      switch (f) {
        case 0:
          return 1;
        case 1:
          return 10;
        case 2:
          return 100;
        case 3:
          return 1e3;
        case 4:
          return 1e4;
        case 5:
          return 1e5;
        case 6:
          return 1e6;
        case 7:
          return 1e7;
        case 8:
          return 1e8;
      }
      throw new Error("Exponent is too large.");
    }
    function w(f) {
      switch (f) {
        case 1:
          return 0;
        case 10:
          return 1;
        case 100:
          return 91;
        case 1e3:
          return 991;
        case 1e4:
          return 991;
        case 1e5:
          return 40991;
        case 1e6:
          return 740991;
        case 1e7:
          return 4740991;
        case 1e8:
          return 54740991;
      }
      throw new Error("Exponent is too large.");
    }
    function g(f) {
      switch (f) {
        case 1:
          return 9007199254740991;
        case 10:
          return 900719925474099;
        case 100:
          return 90071992547409;
        case 1e3:
          return 9007199254740;
        case 1e4:
          return 900719925474;
        case 1e5:
          return 90071992547;
        case 1e6:
          return 9007199254;
        case 1e7:
          return 900719925;
        case 1e8:
          return 90071992;
      }
      throw new Error("Exponent is too large.");
    }
  }(Vo)), Vo;
}
/*!
 * amount.js - amount object for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var $o, d1;
function Ni() {
  if (d1) return $o;
  d1 = 1;
  const e = nt, c = u8();
  class d {
    /**
     * Create an amount.
     * @constructor
     * @param {(String|Number)?} value
     * @param {String?} unit
     */
    constructor(g, f) {
      this.value = 0, g != null && this.fromOptions(g, f);
    }
    /**
     * Inject properties from options.
     * @private
     * @param {(String|Number)?} value
     * @param {String?} unit
     * @returns {Amount}
     */
    fromOptions(g, f) {
      return typeof f == "string" ? this.from(f, g) : typeof g == "number" ? this.fromValue(g) : this.fromBTC(g);
    }
    /**
     * Get satoshi value.
     * @returns {Amount}
     */
    toValue() {
      return this.value;
    }
    /**
     * Get satoshi string or value.
     * @param {Boolean?} num
     * @returns {String|Amount}
     */
    toSatoshis(g) {
      return g ? this.value : this.value.toString(10);
    }
    /**
     * Get bits string or value.
     * @param {Boolean?} num
     * @returns {String|Amount}
     */
    toBits(g) {
      return d.encode(this.value, 2, g);
    }
    /**
     * Get mbtc string or value.
     * @param {Boolean?} num
     * @returns {String|Amount}
     */
    toMBTC(g) {
      return d.encode(this.value, 5, g);
    }
    /**
     * Get btc string or value.
     * @param {Boolean?} num
     * @returns {String|Amount}
     */
    toBTC(g) {
      return d.encode(this.value, 8, g);
    }
    /**
     * Get unit string or value.
     * @param {String} unit - Can be `sat`,
     * `ubtc`, `bits`, `mbtc`, or `btc`.
     * @param {Boolean?} num
     * @returns {String|Amount}
     */
    to(g, f) {
      switch (g) {
        case "sat":
          return this.toSatoshis(f);
        case "ubtc":
        case "bits":
          return this.toBits(f);
        case "mbtc":
          return this.toMBTC(f);
        case "btc":
          return this.toBTC(f);
      }
      throw new Error(`Unknown unit "${g}".`);
    }
    /**
     * Convert amount to bitcoin string.
     * @returns {String}
     */
    toString() {
      return this.toBTC();
    }
    /**
     * Inject properties from value.
     * @private
     * @param {Amount} value
     * @returns {Amount}
     */
    fromValue(g) {
      return e(
        Number.isSafeInteger(g) && g >= 0,
        "Value must be an int64."
      ), this.value = g, this;
    }
    /**
     * Inject properties from satoshis.
     * @private
     * @param {Number|String} value
     * @returns {Amount}
     */
    fromSatoshis(g) {
      return this.value = d.decode(g, 0), this;
    }
    /**
     * Inject properties from bits.
     * @private
     * @param {Number|String} value
     * @returns {Amount}
     */
    fromBits(g) {
      return this.value = d.decode(g, 2), this;
    }
    /**
     * Inject properties from mbtc.
     * @private
     * @param {Number|String} value
     * @returns {Amount}
     */
    fromMBTC(g) {
      return this.value = d.decode(g, 5), this;
    }
    /**
     * Inject properties from btc.
     * @private
     * @param {Number|String} value
     * @returns {Amount}
     */
    fromBTC(g) {
      return this.value = d.decode(g, 8), this;
    }
    /**
     * Inject properties from unit.
     * @private
     * @param {String} unit
     * @param {Number|String} value
     * @returns {Amount}
     */
    from(g, f) {
      switch (g) {
        case "sat":
          return this.fromSatoshis(f);
        case "ubtc":
        case "bits":
          return this.fromBits(f);
        case "mbtc":
          return this.fromMBTC(f);
        case "btc":
          return this.fromBTC(f);
      }
      throw new Error(`Unknown unit "${g}".`);
    }
    /**
     * Instantiate amount from options.
     * @param {(String|Number)?} value
     * @param {String?} unit
     * @returns {Amount}
     */
    static fromOptions(g, f) {
      return new this().fromOptions(g, f);
    }
    /**
     * Instantiate amount from value.
     * @private
     * @param {Amount} value
     * @returns {Amount}
     */
    static fromValue(g) {
      return new this().fromValue(g);
    }
    /**
     * Instantiate amount from satoshis.
     * @param {Number|String} value
     * @returns {Amount}
     */
    static fromSatoshis(g) {
      return new this().fromSatoshis(g);
    }
    /**
     * Instantiate amount from bits.
     * @param {Number|String} value
     * @returns {Amount}
     */
    static fromBits(g) {
      return new this().fromBits(g);
    }
    /**
     * Instantiate amount from mbtc.
     * @param {Number|String} value
     * @returns {Amount}
     */
    static fromMBTC(g) {
      return new this().fromMBTC(g);
    }
    /**
     * Instantiate amount from btc.
     * @param {Number|String} value
     * @returns {Amount}
     */
    static fromBTC(g) {
      return new this().fromBTC(g);
    }
    /**
     * Instantiate amount from unit.
     * @param {String} unit
     * @param {Number|String} value
     * @returns {Amount}
     */
    static from(g, f) {
      return new this().from(g, f);
    }
    /**
     * Inspect amount.
     * @returns {String}
     */
    inspect() {
      return `<Amount: ${this.toString()}>`;
    }
    /**
     * Safely convert satoshis to a BTC string.
     * This function explicitly avoids any
     * floating point arithmetic.
     * @param {Amount} value - Satoshis.
     * @returns {String} BTC string.
     */
    static btc(g, f) {
      return typeof g == "string" ? g : d.encode(g, 8, f);
    }
    /**
     * Safely convert a BTC string to satoshis.
     * @param {String} str - BTC
     * @returns {Amount} Satoshis.
     * @throws on parse error
     */
    static value(g) {
      return typeof g == "number" ? g : d.decode(g, 8);
    }
    /**
     * Safely convert satoshis to a BTC string.
     * @param {Amount} value
     * @param {Number} exp - Exponent.
     * @param {Boolean} num - Return a number.
     * @returns {String|Number}
     */
    static encode(g, f, n) {
      return n ? c.toFloat(g, f) : c.encode(g, f);
    }
    /**
     * Safely convert a BTC string to satoshis.
     * @param {String|Number} value - BTC
     * @param {Number} exp - Exponent.
     * @returns {Amount} Satoshis.
     * @throws on parse error
     */
    static decode(g, f) {
      return typeof g == "number" ? c.fromFloat(g, f) : c.decode(g, f);
    }
  }
  return $o = d, $o;
}
/*!
 * assert.js - assert for bcrypto
 * Copyright (c) 2020, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var jo, b1;
function Bt() {
  if (b1) return jo;
  b1 = 1;
  function e(c, d) {
    if (!c) {
      const w = new Error(d || "Assertion failed");
      throw Error.captureStackTrace && Error.captureStackTrace(w, e), w;
    }
  }
  return jo = e, jo;
}
/*!
 * hmac.js - hmac for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/hash.js:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/hash.js
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/HMAC
 *   https://tools.ietf.org/html/rfc2104
 *   https://github.com/indutny/hash.js/blob/master/lib/hash/hmac.js
 */
var Yo, p1;
function ri() {
  if (p1) return Yo;
  p1 = 1;
  const e = Bt();
  class c {
    /**
     * Create an HMAC.
     * @param {Function} Hash
     * @param {Number} size
     * @param {Array} [x=[]]
     * @param {Array} [y=[]]
     */
    constructor(w, g, f = [], n = []) {
      e(typeof w == "function"), e(g >>> 0 === g), e(Array.isArray(f)), e(Array.isArray(n)), this.hash = w, this.size = g, this.x = f, this.y = n, this.inner = new w(), this.outer = new w();
    }
    /**
     * Initialize HMAC context.
     * @param {Buffer} data
     */
    init(w) {
      if (e(k.isBuffer(w)), w.length > this.size) {
        const f = this.hash, n = new f();
        n.init(...this.x), n.update(w), w = n.final(...this.y), e(w.length <= this.size);
      }
      const g = k.alloc(this.size);
      for (let f = 0; f < w.length; f++)
        g[f] = w[f] ^ 54;
      for (let f = w.length; f < g.length; f++)
        g[f] = 54;
      this.inner.init(...this.x), this.inner.update(g);
      for (let f = 0; f < w.length; f++)
        g[f] = w[f] ^ 92;
      for (let f = w.length; f < g.length; f++)
        g[f] = 92;
      return this.outer.init(...this.x), this.outer.update(g), this;
    }
    /**
     * Update HMAC context.
     * @param {Buffer} data
     */
    update(w) {
      return this.inner.update(w), this;
    }
    /**
     * Finalize HMAC context.
     * @returns {Buffer}
     */
    final() {
      return this.outer.update(this.inner.final(...this.y)), this.outer.final(...this.y);
    }
  }
  return Yo = c, Yo;
}
/*!
 * sha256.js - SHA256 implementation for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/hash.js:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/hash.js
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/SHA-2
 *   https://tools.ietf.org/html/rfc4634
 *   https://github.com/indutny/hash.js/blob/master/lib/hash/sha/256.js
 */
var Xo, m1;
function cr() {
  if (m1) return Xo;
  m1 = 1;
  const e = Bt(), c = ri(), d = -1, w = k.alloc(8, 0), g = k.alloc(64, 0);
  g[0] = 128;
  const f = new Uint32Array([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ]);
  class n {
    constructor() {
      this.state = new Uint32Array(8), this.msg = new Uint32Array(64), this.block = k.alloc(64), this.size = d;
    }
    init() {
      return this.state[0] = 1779033703, this.state[1] = 3144134277, this.state[2] = 1013904242, this.state[3] = 2773480762, this.state[4] = 1359893119, this.state[5] = 2600822924, this.state[6] = 528734635, this.state[7] = 1541459225, this.size = 0, this;
    }
    update(h) {
      return e(k.isBuffer(h)), this._update(h, h.length), this;
    }
    final() {
      return this._final(k.alloc(32));
    }
    _update(h, o) {
      e(this.size !== d, "Context is not initialized.");
      let S = this.size & 63, H = 0;
      if (this.size += o, S > 0) {
        let j = 64 - S;
        if (j > o && (j = o), h.copy(this.block, S, H, H + j), S += j, o -= j, H += j, S < 64)
          return;
        this._transform(this.block, 0);
      }
      for (; o >= 64; )
        this._transform(h, H), H += 64, o -= 64;
      o > 0 && h.copy(this.block, 0, H, H + o);
    }
    _final(h) {
      e(this.size !== d, "Context is not initialized.");
      const o = this.size & 63, S = this.size * 8;
      v(w, S * (1 / 4294967296) >>> 0, 0), v(w, S >>> 0, 4), this._update(g, 1 + (119 - o & 63)), this._update(w, 8);
      for (let H = 0; H < 8; H++)
        v(h, this.state[H], H * 4), this.state[H] = 0;
      for (let H = 0; H < 64; H++)
        this.msg[H] = 0;
      for (let H = 0; H < 64; H++)
        this.block[H] = 0;
      return this.size = d, h;
    }
    _transform(h, o) {
      const S = this.msg;
      let H = this.state[0], j = this.state[1], J = this.state[2], N = this.state[3], z = this.state[4], A = this.state[5], q = this.state[6], _ = this.state[7], F = 0;
      for (; F < 16; F++)
        S[F] = E(h, o + F * 4);
      for (; F < 64; F++)
        S[F] = i(S[F - 2]) + S[F - 7] + s(S[F - 15]) + S[F - 16];
      for (F = 0; F < 64; F++) {
        const R = _ + a(z) + p(z, A, q) + f[F] + S[F], V = u(H) + m(H, j, J);
        _ = q, q = A, A = z, z = N + R >>> 0, N = J, J = j, j = H, H = R + V >>> 0;
      }
      this.state[0] += H, this.state[1] += j, this.state[2] += J, this.state[3] += N, this.state[4] += z, this.state[5] += A, this.state[6] += q, this.state[7] += _;
    }
    static hash() {
      return new n();
    }
    static hmac() {
      return new c(n, 64);
    }
    static digest(h) {
      return n.ctx.init().update(h).final();
    }
    static root(h, o) {
      return e(k.isBuffer(h) && h.length === 32), e(k.isBuffer(o) && o.length === 32), n.ctx.init().update(h).update(o).final();
    }
    static multi(h, o, S) {
      const { ctx: H } = n;
      return H.init(), H.update(h), H.update(o), S && H.update(S), H.final();
    }
    static mac(h, o) {
      return n.hmac().init(o).update(h).final();
    }
  }
  n.native = 0, n.id = "SHA256", n.size = 32, n.bits = 256, n.blockSize = 64, n.zero = k.alloc(32, 0), n.ctx = new n();
  function u(b) {
    return (b >>> 2 | b << 30) ^ (b >>> 13 | b << 19) ^ (b >>> 22 | b << 10);
  }
  function a(b) {
    return (b >>> 6 | b << 26) ^ (b >>> 11 | b << 21) ^ (b >>> 25 | b << 7);
  }
  function s(b) {
    return (b >>> 7 | b << 25) ^ (b >>> 18 | b << 14) ^ b >>> 3;
  }
  function i(b) {
    return (b >>> 17 | b << 15) ^ (b >>> 19 | b << 13) ^ b >>> 10;
  }
  function p(b, h, o) {
    return o ^ b & (h ^ o);
  }
  function m(b, h, o) {
    return b & h | o & (b | h);
  }
  function E(b, h) {
    return b[h++] * 16777216 + b[h++] * 65536 + b[h++] * 256 + b[h];
  }
  function v(b, h, o) {
    return b[o++] = h >>> 24, b[o++] = h >>> 16, b[o++] = h >>> 8, b[o++] = h, o;
  }
  return Xo = n, Xo;
}
/*!
 * ripemd160.js - RIPEMD160 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/hash.js:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/hash.js
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/RIPEMD-160
 *   https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf
 *   https://github.com/indutny/hash.js/blob/master/lib/hash/ripemd.js
 */
var Jo, g1;
function _h() {
  if (g1) return Jo;
  g1 = 1;
  const e = Bt(), c = ri(), d = -1, w = k.alloc(8, 0), g = k.alloc(64, 0);
  g[0] = 128;
  const f = new Uint8Array([
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    7,
    4,
    13,
    1,
    10,
    6,
    15,
    3,
    12,
    0,
    9,
    5,
    2,
    14,
    11,
    8,
    3,
    10,
    14,
    4,
    9,
    15,
    8,
    1,
    2,
    7,
    0,
    6,
    13,
    11,
    5,
    12,
    1,
    9,
    11,
    10,
    0,
    8,
    12,
    4,
    13,
    3,
    7,
    15,
    14,
    5,
    6,
    2,
    4,
    0,
    5,
    9,
    7,
    12,
    2,
    10,
    14,
    1,
    3,
    8,
    11,
    6,
    15,
    13
  ]), n = new Uint8Array([
    5,
    14,
    7,
    0,
    9,
    2,
    11,
    4,
    13,
    6,
    15,
    8,
    1,
    10,
    3,
    12,
    6,
    11,
    3,
    7,
    0,
    13,
    5,
    10,
    14,
    15,
    8,
    12,
    4,
    9,
    1,
    2,
    15,
    5,
    1,
    3,
    7,
    14,
    6,
    9,
    11,
    8,
    12,
    2,
    10,
    0,
    4,
    13,
    8,
    6,
    4,
    1,
    3,
    11,
    15,
    0,
    5,
    12,
    2,
    13,
    9,
    7,
    10,
    14,
    12,
    15,
    10,
    4,
    1,
    5,
    8,
    7,
    6,
    2,
    13,
    14,
    0,
    3,
    9,
    11
  ]), u = new Uint8Array([
    11,
    14,
    15,
    12,
    5,
    8,
    7,
    9,
    11,
    13,
    14,
    15,
    6,
    7,
    9,
    8,
    7,
    6,
    8,
    13,
    11,
    9,
    7,
    15,
    7,
    12,
    15,
    9,
    11,
    7,
    13,
    12,
    11,
    13,
    6,
    7,
    14,
    9,
    13,
    15,
    14,
    8,
    13,
    6,
    5,
    12,
    7,
    5,
    11,
    12,
    14,
    15,
    14,
    15,
    9,
    8,
    9,
    14,
    5,
    6,
    8,
    6,
    5,
    12,
    9,
    15,
    5,
    11,
    6,
    8,
    13,
    12,
    5,
    12,
    13,
    14,
    11,
    8,
    5,
    6
  ]), a = new Uint8Array([
    8,
    9,
    9,
    11,
    13,
    15,
    15,
    5,
    7,
    7,
    8,
    11,
    14,
    14,
    12,
    6,
    9,
    13,
    15,
    7,
    12,
    8,
    9,
    11,
    7,
    7,
    12,
    7,
    6,
    15,
    13,
    11,
    9,
    7,
    15,
    11,
    8,
    6,
    6,
    14,
    12,
    13,
    5,
    14,
    13,
    13,
    7,
    5,
    15,
    5,
    8,
    11,
    14,
    14,
    6,
    14,
    6,
    9,
    12,
    9,
    12,
    5,
    15,
    8,
    8,
    5,
    12,
    9,
    12,
    5,
    14,
    6,
    8,
    13,
    6,
    5,
    15,
    13,
    11,
    11
  ]);
  class s {
    constructor() {
      this.state = new Uint32Array(5), this.msg = new Uint32Array(16), this.block = k.alloc(64), this.size = d;
    }
    init() {
      return this.state[0] = 1732584193, this.state[1] = 4023233417, this.state[2] = 2562383102, this.state[3] = 271733878, this.state[4] = 3285377520, this.size = 0, this;
    }
    update(o) {
      return e(k.isBuffer(o)), this._update(o, o.length), this;
    }
    final() {
      return this._final(k.alloc(20));
    }
    _update(o, S) {
      e(this.size !== d, "Context is not initialized.");
      let H = this.size & 63, j = 0;
      if (this.size += S, H > 0) {
        let J = 64 - H;
        if (J > S && (J = S), o.copy(this.block, H, j, j + J), H += J, S -= J, j += J, H < 64)
          return;
        this._transform(this.block, 0);
      }
      for (; S >= 64; )
        this._transform(o, j), j += 64, S -= 64;
      S > 0 && o.copy(this.block, 0, j, j + S);
    }
    _final(o) {
      e(this.size !== d, "Context is not initialized.");
      const S = this.size & 63, H = this.size * 8;
      b(w, H >>> 0, 0), b(w, H * (1 / 4294967296) >>> 0, 4), this._update(g, 1 + (119 - S & 63)), this._update(w, 8);
      for (let j = 0; j < 5; j++)
        b(o, this.state[j], j * 4), this.state[j] = 0;
      for (let j = 0; j < 16; j++)
        this.msg[j] = 0;
      for (let j = 0; j < 64; j++)
        this.block[j] = 0;
      return this.size = d, o;
    }
    _transform(o, S) {
      const H = this.msg;
      let j = this.state[0], J = this.state[1], N = this.state[2], z = this.state[3], A = this.state[4], q = j, _ = J, F = N, R = z, V = A;
      for (let ue = 0; ue < 16; ue++)
        H[ue] = v(o, S + ue * 4);
      for (let ue = 0; ue < 80; ue++) {
        let ae = j + p(ue, J, N, z) + H[f[ue]] + m(ue), D = i(ae, u[ue]), Q = D + A;
        j = A, A = z, z = i(N, 10), N = J, J = Q, ae = q + p(79 - ue, _, F, R) + H[n[ue]] + E(ue), D = i(ae, a[ue]), Q = D + V, q = V, V = R, R = i(F, 10), F = _, _ = Q;
      }
      const fe = this.state[1] + N + R;
      this.state[1] = this.state[2] + z + V, this.state[2] = this.state[3] + A + q, this.state[3] = this.state[4] + j + _, this.state[4] = this.state[0] + J + F, this.state[0] = fe;
    }
    static hash() {
      return new s();
    }
    static hmac() {
      return new c(s, 64);
    }
    static digest(o) {
      return s.ctx.init().update(o).final();
    }
    static root(o, S) {
      return e(k.isBuffer(o) && o.length === 20), e(k.isBuffer(S) && S.length === 20), s.ctx.init().update(o).update(S).final();
    }
    static multi(o, S, H) {
      const { ctx: j } = s;
      return j.init(), j.update(o), j.update(S), H && j.update(H), j.final();
    }
    static mac(o, S) {
      return s.hmac().init(S).update(o).final();
    }
  }
  s.native = 0, s.id = "RIPEMD160", s.size = 20, s.bits = 160, s.blockSize = 64, s.zero = k.alloc(20, 0), s.ctx = new s();
  function i(h, o) {
    return h << o | h >>> 32 - o;
  }
  function p(h, o, S, H) {
    return h <= 15 ? o ^ S ^ H : h <= 31 ? o & S | ~o & H : h <= 47 ? (o | ~S) ^ H : h <= 63 ? o & H | S & ~H : o ^ (S | ~H);
  }
  function m(h) {
    return h <= 15 ? 0 : h <= 31 ? 1518500249 : h <= 47 ? 1859775393 : h <= 63 ? 2400959708 : 2840853838;
  }
  function E(h) {
    return h <= 15 ? 1352829926 : h <= 31 ? 1548603684 : h <= 47 ? 1836072691 : h <= 63 ? 2053994217 : 0;
  }
  function v(h, o) {
    return h[o++] + h[o++] * 256 + h[o++] * 65536 + h[o] * 16777216;
  }
  function b(h, o, S) {
    return h[S++] = o, o >>>= 8, h[S++] = o, o >>>= 8, h[S++] = o, o >>>= 8, h[S++] = o, S;
  }
  return Jo = s, Jo;
}
/*!
 * hash160.js - Hash160 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://github.com/bitcoin/bitcoin/blob/master/src/hash.h
 */
var Go, x1;
function hn() {
  if (x1) return Go;
  x1 = 1;
  const e = Bt(), c = cr(), d = _h(), w = ri(), g = new d();
  class f {
    constructor() {
      this.ctx = new c();
    }
    init() {
      return this.ctx.init(), this;
    }
    update(u) {
      return this.ctx.update(u), this;
    }
    final() {
      const u = k.alloc(32);
      return this.ctx._final(u), g.init(), g.update(u), g._final(u), u.slice(0, 20);
    }
    static hash() {
      return new f();
    }
    static hmac() {
      return new w(f, 64);
    }
    static digest(u) {
      return f.ctx.init().update(u).final();
    }
    static root(u, a) {
      return e(k.isBuffer(u) && u.length === 20), e(k.isBuffer(a) && a.length === 20), f.ctx.init().update(u).update(a).final();
    }
    static multi(u, a, s) {
      const { ctx: i } = f;
      return i.init(), i.update(u), i.update(a), s && i.update(s), i.final();
    }
    static mac(u, a) {
      return f.hmac().init(a).update(u).final();
    }
  }
  return f.native = 0, f.id = "HASH160", f.size = 20, f.bits = 160, f.blockSize = 64, f.zero = k.alloc(20, 0), f.ctx = new f(), Go = f, Go;
}
/*!
 * hash256.js - Hash256 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://github.com/bitcoin/bitcoin/blob/master/src/hash.h
 */
var Wo, w1;
function Or() {
  if (w1) return Wo;
  w1 = 1;
  const e = Bt(), c = cr(), d = ri();
  class w {
    constructor() {
      this.ctx = new c();
    }
    init() {
      return this.ctx.init(), this;
    }
    update(f) {
      return this.ctx.update(f), this;
    }
    final() {
      const f = k.alloc(32);
      return this.ctx._final(f), this.ctx.init(), this.ctx.update(f), this.ctx._final(f), f;
    }
    static hash() {
      return new w();
    }
    static hmac() {
      return new d(w, 64);
    }
    static digest(f) {
      return w.ctx.init().update(f).final();
    }
    static root(f, n) {
      return e(k.isBuffer(f) && f.length === 32), e(k.isBuffer(n) && n.length === 32), w.ctx.init().update(f).update(n).final();
    }
    static multi(f, n, u) {
      const { ctx: a } = w;
      return a.init(), a.update(f), a.update(n), u && a.update(u), a.final();
    }
    static mac(f, n) {
      return w.hmac().init(n).update(f).final();
    }
  }
  return w.native = 0, w.id = "HASH256", w.size = 32, w.bits = 256, w.blockSize = 64, w.zero = k.alloc(32, 0), w.ctx = new w(), Wo = w, Wo;
}
var Zo = {};
/*!
 * binary.js - binary search utils for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var y1;
function Rh() {
  return y1 || (y1 = 1, function(e) {
    e.search = function(w, g, f, n) {
      let u = 0, a = w.length - 1;
      for (; u <= a; ) {
        const s = u + a >>> 1, i = f(w[s], g);
        if (i === 0)
          return s;
        i < 0 ? u = s + 1 : a = s - 1;
      }
      return n ? u : -1;
    }, e.insert = function(w, g, f, n) {
      const u = e.search(w, g, f, !0);
      return n && u < w.length && f(w[u], g) === 0 ? -1 : (u === 0 ? w.unshift(g) : u === w.length ? w.push(g) : w.splice(u, 0, g), u);
    }, e.remove = function(w, g, f) {
      const n = e.search(w, g, f, !1);
      return n === -1 ? !1 : (c(w, n), !0);
    };
    function c(d, w) {
      if (w === 0) {
        d.shift();
        return;
      }
      let g = w + 1;
      for (; g < d.length; )
        d[w++] = d[g++];
      d.pop();
    }
  }(Zo)), Zo;
}
var Qo = {}, e0 = {}, Bi = typeof Ps < "u" ? Ps : typeof self < "u" ? self : typeof window < "u" ? window : {}, qr = [], gr = [], dp = typeof Uint8Array < "u" ? Uint8Array : Array, Ph = !1;
function h8() {
  Ph = !0;
  for (var e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", c = 0, d = e.length; c < d; ++c)
    qr[c] = e[c], gr[e.charCodeAt(c)] = c;
  gr[45] = 62, gr[95] = 63;
}
function bp(e) {
  Ph || h8();
  var c, d, w, g, f, n, u = e.length;
  if (u % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  f = e[u - 2] === "=" ? 2 : e[u - 1] === "=" ? 1 : 0, n = new dp(u * 3 / 4 - f), w = f > 0 ? u - 4 : u;
  var a = 0;
  for (c = 0, d = 0; c < w; c += 4, d += 3)
    g = gr[e.charCodeAt(c)] << 18 | gr[e.charCodeAt(c + 1)] << 12 | gr[e.charCodeAt(c + 2)] << 6 | gr[e.charCodeAt(c + 3)], n[a++] = g >> 16 & 255, n[a++] = g >> 8 & 255, n[a++] = g & 255;
  return f === 2 ? (g = gr[e.charCodeAt(c)] << 2 | gr[e.charCodeAt(c + 1)] >> 4, n[a++] = g & 255) : f === 1 && (g = gr[e.charCodeAt(c)] << 10 | gr[e.charCodeAt(c + 1)] << 4 | gr[e.charCodeAt(c + 2)] >> 2, n[a++] = g >> 8 & 255, n[a++] = g & 255), n;
}
function pp(e) {
  return qr[e >> 18 & 63] + qr[e >> 12 & 63] + qr[e >> 6 & 63] + qr[e & 63];
}
function mp(e, c, d) {
  for (var w, g = [], f = c; f < d; f += 3)
    w = (e[f] << 16) + (e[f + 1] << 8) + e[f + 2], g.push(pp(w));
  return g.join("");
}
function v1(e) {
  Ph || h8();
  for (var c, d = e.length, w = d % 3, g = "", f = [], n = 16383, u = 0, a = d - w; u < a; u += n)
    f.push(mp(e, u, u + n > a ? a : u + n));
  return w === 1 ? (c = e[d - 1], g += qr[c >> 2], g += qr[c << 4 & 63], g += "==") : w === 2 && (c = (e[d - 2] << 8) + e[d - 1], g += qr[c >> 10], g += qr[c >> 4 & 63], g += qr[c << 2 & 63], g += "="), f.push(g), f.join("");
}
function Us(e, c, d, w, g) {
  var f, n, u = g * 8 - w - 1, a = (1 << u) - 1, s = a >> 1, i = -7, p = d ? g - 1 : 0, m = d ? -1 : 1, E = e[c + p];
  for (p += m, f = E & (1 << -i) - 1, E >>= -i, i += u; i > 0; f = f * 256 + e[c + p], p += m, i -= 8)
    ;
  for (n = f & (1 << -i) - 1, f >>= -i, i += w; i > 0; n = n * 256 + e[c + p], p += m, i -= 8)
    ;
  if (f === 0)
    f = 1 - s;
  else {
    if (f === a)
      return n ? NaN : (E ? -1 : 1) * (1 / 0);
    n = n + Math.pow(2, w), f = f - s;
  }
  return (E ? -1 : 1) * n * Math.pow(2, f - w);
}
function l8(e, c, d, w, g, f) {
  var n, u, a, s = f * 8 - g - 1, i = (1 << s) - 1, p = i >> 1, m = g === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, E = w ? 0 : f - 1, v = w ? 1 : -1, b = c < 0 || c === 0 && 1 / c < 0 ? 1 : 0;
  for (c = Math.abs(c), isNaN(c) || c === 1 / 0 ? (u = isNaN(c) ? 1 : 0, n = i) : (n = Math.floor(Math.log(c) / Math.LN2), c * (a = Math.pow(2, -n)) < 1 && (n--, a *= 2), n + p >= 1 ? c += m / a : c += m * Math.pow(2, 1 - p), c * a >= 2 && (n++, a /= 2), n + p >= i ? (u = 0, n = i) : n + p >= 1 ? (u = (c * a - 1) * Math.pow(2, g), n = n + p) : (u = c * Math.pow(2, p - 1) * Math.pow(2, g), n = 0)); g >= 8; e[d + E] = u & 255, E += v, u /= 256, g -= 8)
    ;
  for (n = n << g | u, s += g; s > 0; e[d + E] = n & 255, E += v, n /= 256, s -= 8)
    ;
  e[d + E - v] |= b * 128;
}
var gp = {}.toString, d8 = Array.isArray || function(e) {
  return gp.call(e) == "[object Array]";
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
var xp = 50;
Te.TYPED_ARRAY_SUPPORT = Bi.TYPED_ARRAY_SUPPORT !== void 0 ? Bi.TYPED_ARRAY_SUPPORT : !0;
ks();
function ks() {
  return Te.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
}
function Qr(e, c) {
  if (ks() < c)
    throw new RangeError("Invalid typed array length");
  return Te.TYPED_ARRAY_SUPPORT ? (e = new Uint8Array(c), e.__proto__ = Te.prototype) : (e === null && (e = new Te(c)), e.length = c), e;
}
function Te(e, c, d) {
  if (!Te.TYPED_ARRAY_SUPPORT && !(this instanceof Te))
    return new Te(e, c, d);
  if (typeof e == "number") {
    if (typeof c == "string")
      throw new Error(
        "If encoding is specified then the first argument must be a string"
      );
    return kh(this, e);
  }
  return b8(this, e, c, d);
}
Te.poolSize = 8192;
Te._augment = function(e) {
  return e.__proto__ = Te.prototype, e;
};
function b8(e, c, d, w) {
  if (typeof c == "number")
    throw new TypeError('"value" argument must not be a number');
  return typeof ArrayBuffer < "u" && c instanceof ArrayBuffer ? vp(e, c, d, w) : typeof c == "string" ? yp(e, c, d) : Sp(e, c);
}
Te.from = function(e, c, d) {
  return b8(null, e, c, d);
};
Te.TYPED_ARRAY_SUPPORT && (Te.prototype.__proto__ = Uint8Array.prototype, Te.__proto__ = Uint8Array, typeof Symbol < "u" && Symbol.species && Te[Symbol.species]);
function p8(e) {
  if (typeof e != "number")
    throw new TypeError('"size" argument must be a number');
  if (e < 0)
    throw new RangeError('"size" argument must not be negative');
}
function wp(e, c, d, w) {
  return p8(c), c <= 0 ? Qr(e, c) : d !== void 0 ? typeof w == "string" ? Qr(e, c).fill(d, w) : Qr(e, c).fill(d) : Qr(e, c);
}
Te.alloc = function(e, c, d) {
  return wp(null, e, c, d);
};
function kh(e, c) {
  if (p8(c), e = Qr(e, c < 0 ? 0 : Bh(c) | 0), !Te.TYPED_ARRAY_SUPPORT)
    for (var d = 0; d < c; ++d)
      e[d] = 0;
  return e;
}
Te.allocUnsafe = function(e) {
  return kh(null, e);
};
Te.allocUnsafeSlow = function(e) {
  return kh(null, e);
};
function yp(e, c, d) {
  if ((typeof d != "string" || d === "") && (d = "utf8"), !Te.isEncoding(d))
    throw new TypeError('"encoding" must be a valid string encoding');
  var w = m8(c, d) | 0;
  e = Qr(e, w);
  var g = e.write(c, d);
  return g !== w && (e = e.slice(0, g)), e;
}
function xh(e, c) {
  var d = c.length < 0 ? 0 : Bh(c.length) | 0;
  e = Qr(e, d);
  for (var w = 0; w < d; w += 1)
    e[w] = c[w] & 255;
  return e;
}
function vp(e, c, d, w) {
  if (c.byteLength, d < 0 || c.byteLength < d)
    throw new RangeError("'offset' is out of bounds");
  if (c.byteLength < d + (w || 0))
    throw new RangeError("'length' is out of bounds");
  return d === void 0 && w === void 0 ? c = new Uint8Array(c) : w === void 0 ? c = new Uint8Array(c, d) : c = new Uint8Array(c, d, w), Te.TYPED_ARRAY_SUPPORT ? (e = c, e.__proto__ = Te.prototype) : e = xh(e, c), e;
}
function Sp(e, c) {
  if (Tr(c)) {
    var d = Bh(c.length) | 0;
    return e = Qr(e, d), e.length === 0 || c.copy(e, 0, 0, d), e;
  }
  if (c) {
    if (typeof ArrayBuffer < "u" && c.buffer instanceof ArrayBuffer || "length" in c)
      return typeof c.length != "number" || Hp(c.length) ? Qr(e, 0) : xh(e, c);
    if (c.type === "Buffer" && d8(c.data))
      return xh(e, c.data);
  }
  throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
}
function Bh(e) {
  if (e >= ks())
    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + ks().toString(16) + " bytes");
  return e | 0;
}
Te.isBuffer = Zi;
function Tr(e) {
  return !!(e != null && e._isBuffer);
}
Te.compare = function(c, d) {
  if (!Tr(c) || !Tr(d))
    throw new TypeError("Arguments must be Buffers");
  if (c === d) return 0;
  for (var w = c.length, g = d.length, f = 0, n = Math.min(w, g); f < n; ++f)
    if (c[f] !== d[f]) {
      w = c[f], g = d[f];
      break;
    }
  return w < g ? -1 : g < w ? 1 : 0;
};
Te.isEncoding = function(c) {
  switch (String(c).toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "latin1":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return !0;
    default:
      return !1;
  }
};
Te.concat = function(c, d) {
  if (!d8(c))
    throw new TypeError('"list" argument must be an Array of Buffers');
  if (c.length === 0)
    return Te.alloc(0);
  var w;
  if (d === void 0)
    for (d = 0, w = 0; w < c.length; ++w)
      d += c[w].length;
  var g = Te.allocUnsafe(d), f = 0;
  for (w = 0; w < c.length; ++w) {
    var n = c[w];
    if (!Tr(n))
      throw new TypeError('"list" argument must be an Array of Buffers');
    n.copy(g, f), f += n.length;
  }
  return g;
};
function m8(e, c) {
  if (Tr(e))
    return e.length;
  if (typeof ArrayBuffer < "u" && typeof ArrayBuffer.isView == "function" && (ArrayBuffer.isView(e) || e instanceof ArrayBuffer))
    return e.byteLength;
  typeof e != "string" && (e = "" + e);
  var d = e.length;
  if (d === 0) return 0;
  for (var w = !1; ; )
    switch (c) {
      case "ascii":
      case "latin1":
      case "binary":
        return d;
      case "utf8":
      case "utf-8":
      case void 0:
        return Bs(e).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return d * 2;
      case "hex":
        return d >>> 1;
      case "base64":
        return E8(e).length;
      default:
        if (w) return Bs(e).length;
        c = ("" + c).toLowerCase(), w = !0;
    }
}
Te.byteLength = m8;
function Ep(e, c, d) {
  var w = !1;
  if ((c === void 0 || c < 0) && (c = 0), c > this.length || ((d === void 0 || d > this.length) && (d = this.length), d <= 0) || (d >>>= 0, c >>>= 0, d <= c))
    return "";
  for (e || (e = "utf8"); ; )
    switch (e) {
      case "hex":
        return Np(this, c, d);
      case "utf8":
      case "utf-8":
        return w8(this, c, d);
      case "ascii":
        return Bp(this, c, d);
      case "latin1":
      case "binary":
        return Mp(this, c, d);
      case "base64":
        return Pp(this, c, d);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return qp(this, c, d);
      default:
        if (w) throw new TypeError("Unknown encoding: " + e);
        e = (e + "").toLowerCase(), w = !0;
    }
}
Te.prototype._isBuffer = !0;
function _i(e, c, d) {
  var w = e[c];
  e[c] = e[d], e[d] = w;
}
Te.prototype.swap16 = function() {
  var c = this.length;
  if (c % 2 !== 0)
    throw new RangeError("Buffer size must be a multiple of 16-bits");
  for (var d = 0; d < c; d += 2)
    _i(this, d, d + 1);
  return this;
};
Te.prototype.swap32 = function() {
  var c = this.length;
  if (c % 4 !== 0)
    throw new RangeError("Buffer size must be a multiple of 32-bits");
  for (var d = 0; d < c; d += 4)
    _i(this, d, d + 3), _i(this, d + 1, d + 2);
  return this;
};
Te.prototype.swap64 = function() {
  var c = this.length;
  if (c % 8 !== 0)
    throw new RangeError("Buffer size must be a multiple of 64-bits");
  for (var d = 0; d < c; d += 8)
    _i(this, d, d + 7), _i(this, d + 1, d + 6), _i(this, d + 2, d + 5), _i(this, d + 3, d + 4);
  return this;
};
Te.prototype.toString = function() {
  var c = this.length | 0;
  return c === 0 ? "" : arguments.length === 0 ? w8(this, 0, c) : Ep.apply(this, arguments);
};
Te.prototype.equals = function(c) {
  if (!Tr(c)) throw new TypeError("Argument must be a Buffer");
  return this === c ? !0 : Te.compare(this, c) === 0;
};
Te.prototype.inspect = function() {
  var c = "", d = xp;
  return this.length > 0 && (c = this.toString("hex", 0, d).match(/.{2}/g).join(" "), this.length > d && (c += " ... ")), "<Buffer " + c + ">";
};
Te.prototype.compare = function(c, d, w, g, f) {
  if (!Tr(c))
    throw new TypeError("Argument must be a Buffer");
  if (d === void 0 && (d = 0), w === void 0 && (w = c ? c.length : 0), g === void 0 && (g = 0), f === void 0 && (f = this.length), d < 0 || w > c.length || g < 0 || f > this.length)
    throw new RangeError("out of range index");
  if (g >= f && d >= w)
    return 0;
  if (g >= f)
    return -1;
  if (d >= w)
    return 1;
  if (d >>>= 0, w >>>= 0, g >>>= 0, f >>>= 0, this === c) return 0;
  for (var n = f - g, u = w - d, a = Math.min(n, u), s = this.slice(g, f), i = c.slice(d, w), p = 0; p < a; ++p)
    if (s[p] !== i[p]) {
      n = s[p], u = i[p];
      break;
    }
  return n < u ? -1 : u < n ? 1 : 0;
};
function g8(e, c, d, w, g) {
  if (e.length === 0) return -1;
  if (typeof d == "string" ? (w = d, d = 0) : d > 2147483647 ? d = 2147483647 : d < -2147483648 && (d = -2147483648), d = +d, isNaN(d) && (d = g ? 0 : e.length - 1), d < 0 && (d = e.length + d), d >= e.length) {
    if (g) return -1;
    d = e.length - 1;
  } else if (d < 0)
    if (g) d = 0;
    else return -1;
  if (typeof c == "string" && (c = Te.from(c, w)), Tr(c))
    return c.length === 0 ? -1 : S1(e, c, d, w, g);
  if (typeof c == "number")
    return c = c & 255, Te.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf == "function" ? g ? Uint8Array.prototype.indexOf.call(e, c, d) : Uint8Array.prototype.lastIndexOf.call(e, c, d) : S1(e, [c], d, w, g);
  throw new TypeError("val must be string, number or Buffer");
}
function S1(e, c, d, w, g) {
  var f = 1, n = e.length, u = c.length;
  if (w !== void 0 && (w = String(w).toLowerCase(), w === "ucs2" || w === "ucs-2" || w === "utf16le" || w === "utf-16le")) {
    if (e.length < 2 || c.length < 2)
      return -1;
    f = 2, n /= 2, u /= 2, d /= 2;
  }
  function a(E, v) {
    return f === 1 ? E[v] : E.readUInt16BE(v * f);
  }
  var s;
  if (g) {
    var i = -1;
    for (s = d; s < n; s++)
      if (a(e, s) === a(c, i === -1 ? 0 : s - i)) {
        if (i === -1 && (i = s), s - i + 1 === u) return i * f;
      } else
        i !== -1 && (s -= s - i), i = -1;
  } else
    for (d + u > n && (d = n - u), s = d; s >= 0; s--) {
      for (var p = !0, m = 0; m < u; m++)
        if (a(e, s + m) !== a(c, m)) {
          p = !1;
          break;
        }
      if (p) return s;
    }
  return -1;
}
Te.prototype.includes = function(c, d, w) {
  return this.indexOf(c, d, w) !== -1;
};
Te.prototype.indexOf = function(c, d, w) {
  return g8(this, c, d, w, !0);
};
Te.prototype.lastIndexOf = function(c, d, w) {
  return g8(this, c, d, w, !1);
};
function Ip(e, c, d, w) {
  d = Number(d) || 0;
  var g = e.length - d;
  w ? (w = Number(w), w > g && (w = g)) : w = g;
  var f = c.length;
  if (f % 2 !== 0) throw new TypeError("Invalid hex string");
  w > f / 2 && (w = f / 2);
  for (var n = 0; n < w; ++n) {
    var u = parseInt(c.substr(n * 2, 2), 16);
    if (isNaN(u)) return n;
    e[d + n] = u;
  }
  return n;
}
function Ap(e, c, d, w) {
  return Ls(Bs(c, e.length - d), e, d, w);
}
function x8(e, c, d, w) {
  return Ls(Up(c), e, d, w);
}
function Op(e, c, d, w) {
  return x8(e, c, d, w);
}
function _p(e, c, d, w) {
  return Ls(E8(c), e, d, w);
}
function Rp(e, c, d, w) {
  return Ls(Fp(c, e.length - d), e, d, w);
}
Te.prototype.write = function(c, d, w, g) {
  if (d === void 0)
    g = "utf8", w = this.length, d = 0;
  else if (w === void 0 && typeof d == "string")
    g = d, w = this.length, d = 0;
  else if (isFinite(d))
    d = d | 0, isFinite(w) ? (w = w | 0, g === void 0 && (g = "utf8")) : (g = w, w = void 0);
  else
    throw new Error(
      "Buffer.write(string, encoding, offset[, length]) is no longer supported"
    );
  var f = this.length - d;
  if ((w === void 0 || w > f) && (w = f), c.length > 0 && (w < 0 || d < 0) || d > this.length)
    throw new RangeError("Attempt to write outside buffer bounds");
  g || (g = "utf8");
  for (var n = !1; ; )
    switch (g) {
      case "hex":
        return Ip(this, c, d, w);
      case "utf8":
      case "utf-8":
        return Ap(this, c, d, w);
      case "ascii":
        return x8(this, c, d, w);
      case "latin1":
      case "binary":
        return Op(this, c, d, w);
      case "base64":
        return _p(this, c, d, w);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return Rp(this, c, d, w);
      default:
        if (n) throw new TypeError("Unknown encoding: " + g);
        g = ("" + g).toLowerCase(), n = !0;
    }
};
Te.prototype.toJSON = function() {
  return {
    type: "Buffer",
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};
function Pp(e, c, d) {
  return c === 0 && d === e.length ? v1(e) : v1(e.slice(c, d));
}
function w8(e, c, d) {
  d = Math.min(e.length, d);
  for (var w = [], g = c; g < d; ) {
    var f = e[g], n = null, u = f > 239 ? 4 : f > 223 ? 3 : f > 191 ? 2 : 1;
    if (g + u <= d) {
      var a, s, i, p;
      switch (u) {
        case 1:
          f < 128 && (n = f);
          break;
        case 2:
          a = e[g + 1], (a & 192) === 128 && (p = (f & 31) << 6 | a & 63, p > 127 && (n = p));
          break;
        case 3:
          a = e[g + 1], s = e[g + 2], (a & 192) === 128 && (s & 192) === 128 && (p = (f & 15) << 12 | (a & 63) << 6 | s & 63, p > 2047 && (p < 55296 || p > 57343) && (n = p));
          break;
        case 4:
          a = e[g + 1], s = e[g + 2], i = e[g + 3], (a & 192) === 128 && (s & 192) === 128 && (i & 192) === 128 && (p = (f & 15) << 18 | (a & 63) << 12 | (s & 63) << 6 | i & 63, p > 65535 && p < 1114112 && (n = p));
      }
    }
    n === null ? (n = 65533, u = 1) : n > 65535 && (n -= 65536, w.push(n >>> 10 & 1023 | 55296), n = 56320 | n & 1023), w.push(n), g += u;
  }
  return kp(w);
}
var E1 = 4096;
function kp(e) {
  var c = e.length;
  if (c <= E1)
    return String.fromCharCode.apply(String, e);
  for (var d = "", w = 0; w < c; )
    d += String.fromCharCode.apply(
      String,
      e.slice(w, w += E1)
    );
  return d;
}
function Bp(e, c, d) {
  var w = "";
  d = Math.min(e.length, d);
  for (var g = c; g < d; ++g)
    w += String.fromCharCode(e[g] & 127);
  return w;
}
function Mp(e, c, d) {
  var w = "";
  d = Math.min(e.length, d);
  for (var g = c; g < d; ++g)
    w += String.fromCharCode(e[g]);
  return w;
}
function Np(e, c, d) {
  var w = e.length;
  (!c || c < 0) && (c = 0), (!d || d < 0 || d > w) && (d = w);
  for (var g = "", f = c; f < d; ++f)
    g += Dp(e[f]);
  return g;
}
function qp(e, c, d) {
  for (var w = e.slice(c, d), g = "", f = 0; f < w.length; f += 2)
    g += String.fromCharCode(w[f] + w[f + 1] * 256);
  return g;
}
Te.prototype.slice = function(c, d) {
  var w = this.length;
  c = ~~c, d = d === void 0 ? w : ~~d, c < 0 ? (c += w, c < 0 && (c = 0)) : c > w && (c = w), d < 0 ? (d += w, d < 0 && (d = 0)) : d > w && (d = w), d < c && (d = c);
  var g;
  if (Te.TYPED_ARRAY_SUPPORT)
    g = this.subarray(c, d), g.__proto__ = Te.prototype;
  else {
    var f = d - c;
    g = new Te(f, void 0);
    for (var n = 0; n < f; ++n)
      g[n] = this[n + c];
  }
  return g;
};
function $t(e, c, d) {
  if (e % 1 !== 0 || e < 0) throw new RangeError("offset is not uint");
  if (e + c > d) throw new RangeError("Trying to access beyond buffer length");
}
Te.prototype.readUIntLE = function(c, d, w) {
  c = c | 0, d = d | 0, w || $t(c, d, this.length);
  for (var g = this[c], f = 1, n = 0; ++n < d && (f *= 256); )
    g += this[c + n] * f;
  return g;
};
Te.prototype.readUIntBE = function(c, d, w) {
  c = c | 0, d = d | 0, w || $t(c, d, this.length);
  for (var g = this[c + --d], f = 1; d > 0 && (f *= 256); )
    g += this[c + --d] * f;
  return g;
};
Te.prototype.readUInt8 = function(c, d) {
  return d || $t(c, 1, this.length), this[c];
};
Te.prototype.readUInt16LE = function(c, d) {
  return d || $t(c, 2, this.length), this[c] | this[c + 1] << 8;
};
Te.prototype.readUInt16BE = function(c, d) {
  return d || $t(c, 2, this.length), this[c] << 8 | this[c + 1];
};
Te.prototype.readUInt32LE = function(c, d) {
  return d || $t(c, 4, this.length), (this[c] | this[c + 1] << 8 | this[c + 2] << 16) + this[c + 3] * 16777216;
};
Te.prototype.readUInt32BE = function(c, d) {
  return d || $t(c, 4, this.length), this[c] * 16777216 + (this[c + 1] << 16 | this[c + 2] << 8 | this[c + 3]);
};
Te.prototype.readIntLE = function(c, d, w) {
  c = c | 0, d = d | 0, w || $t(c, d, this.length);
  for (var g = this[c], f = 1, n = 0; ++n < d && (f *= 256); )
    g += this[c + n] * f;
  return f *= 128, g >= f && (g -= Math.pow(2, 8 * d)), g;
};
Te.prototype.readIntBE = function(c, d, w) {
  c = c | 0, d = d | 0, w || $t(c, d, this.length);
  for (var g = d, f = 1, n = this[c + --g]; g > 0 && (f *= 256); )
    n += this[c + --g] * f;
  return f *= 128, n >= f && (n -= Math.pow(2, 8 * d)), n;
};
Te.prototype.readInt8 = function(c, d) {
  return d || $t(c, 1, this.length), this[c] & 128 ? (255 - this[c] + 1) * -1 : this[c];
};
Te.prototype.readInt16LE = function(c, d) {
  d || $t(c, 2, this.length);
  var w = this[c] | this[c + 1] << 8;
  return w & 32768 ? w | 4294901760 : w;
};
Te.prototype.readInt16BE = function(c, d) {
  d || $t(c, 2, this.length);
  var w = this[c + 1] | this[c] << 8;
  return w & 32768 ? w | 4294901760 : w;
};
Te.prototype.readInt32LE = function(c, d) {
  return d || $t(c, 4, this.length), this[c] | this[c + 1] << 8 | this[c + 2] << 16 | this[c + 3] << 24;
};
Te.prototype.readInt32BE = function(c, d) {
  return d || $t(c, 4, this.length), this[c] << 24 | this[c + 1] << 16 | this[c + 2] << 8 | this[c + 3];
};
Te.prototype.readFloatLE = function(c, d) {
  return d || $t(c, 4, this.length), Us(this, c, !0, 23, 4);
};
Te.prototype.readFloatBE = function(c, d) {
  return d || $t(c, 4, this.length), Us(this, c, !1, 23, 4);
};
Te.prototype.readDoubleLE = function(c, d) {
  return d || $t(c, 8, this.length), Us(this, c, !0, 52, 8);
};
Te.prototype.readDoubleBE = function(c, d) {
  return d || $t(c, 8, this.length), Us(this, c, !1, 52, 8);
};
function ar(e, c, d, w, g, f) {
  if (!Tr(e)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (c > g || c < f) throw new RangeError('"value" argument is out of bounds');
  if (d + w > e.length) throw new RangeError("Index out of range");
}
Te.prototype.writeUIntLE = function(c, d, w, g) {
  if (c = +c, d = d | 0, w = w | 0, !g) {
    var f = Math.pow(2, 8 * w) - 1;
    ar(this, c, d, w, f, 0);
  }
  var n = 1, u = 0;
  for (this[d] = c & 255; ++u < w && (n *= 256); )
    this[d + u] = c / n & 255;
  return d + w;
};
Te.prototype.writeUIntBE = function(c, d, w, g) {
  if (c = +c, d = d | 0, w = w | 0, !g) {
    var f = Math.pow(2, 8 * w) - 1;
    ar(this, c, d, w, f, 0);
  }
  var n = w - 1, u = 1;
  for (this[d + n] = c & 255; --n >= 0 && (u *= 256); )
    this[d + n] = c / u & 255;
  return d + w;
};
Te.prototype.writeUInt8 = function(c, d, w) {
  return c = +c, d = d | 0, w || ar(this, c, d, 1, 255, 0), Te.TYPED_ARRAY_SUPPORT || (c = Math.floor(c)), this[d] = c & 255, d + 1;
};
function Fs(e, c, d, w) {
  c < 0 && (c = 65535 + c + 1);
  for (var g = 0, f = Math.min(e.length - d, 2); g < f; ++g)
    e[d + g] = (c & 255 << 8 * (w ? g : 1 - g)) >>> (w ? g : 1 - g) * 8;
}
Te.prototype.writeUInt16LE = function(c, d, w) {
  return c = +c, d = d | 0, w || ar(this, c, d, 2, 65535, 0), Te.TYPED_ARRAY_SUPPORT ? (this[d] = c & 255, this[d + 1] = c >>> 8) : Fs(this, c, d, !0), d + 2;
};
Te.prototype.writeUInt16BE = function(c, d, w) {
  return c = +c, d = d | 0, w || ar(this, c, d, 2, 65535, 0), Te.TYPED_ARRAY_SUPPORT ? (this[d] = c >>> 8, this[d + 1] = c & 255) : Fs(this, c, d, !1), d + 2;
};
function Hs(e, c, d, w) {
  c < 0 && (c = 4294967295 + c + 1);
  for (var g = 0, f = Math.min(e.length - d, 4); g < f; ++g)
    e[d + g] = c >>> (w ? g : 3 - g) * 8 & 255;
}
Te.prototype.writeUInt32LE = function(c, d, w) {
  return c = +c, d = d | 0, w || ar(this, c, d, 4, 4294967295, 0), Te.TYPED_ARRAY_SUPPORT ? (this[d + 3] = c >>> 24, this[d + 2] = c >>> 16, this[d + 1] = c >>> 8, this[d] = c & 255) : Hs(this, c, d, !0), d + 4;
};
Te.prototype.writeUInt32BE = function(c, d, w) {
  return c = +c, d = d | 0, w || ar(this, c, d, 4, 4294967295, 0), Te.TYPED_ARRAY_SUPPORT ? (this[d] = c >>> 24, this[d + 1] = c >>> 16, this[d + 2] = c >>> 8, this[d + 3] = c & 255) : Hs(this, c, d, !1), d + 4;
};
Te.prototype.writeIntLE = function(c, d, w, g) {
  if (c = +c, d = d | 0, !g) {
    var f = Math.pow(2, 8 * w - 1);
    ar(this, c, d, w, f - 1, -f);
  }
  var n = 0, u = 1, a = 0;
  for (this[d] = c & 255; ++n < w && (u *= 256); )
    c < 0 && a === 0 && this[d + n - 1] !== 0 && (a = 1), this[d + n] = (c / u >> 0) - a & 255;
  return d + w;
};
Te.prototype.writeIntBE = function(c, d, w, g) {
  if (c = +c, d = d | 0, !g) {
    var f = Math.pow(2, 8 * w - 1);
    ar(this, c, d, w, f - 1, -f);
  }
  var n = w - 1, u = 1, a = 0;
  for (this[d + n] = c & 255; --n >= 0 && (u *= 256); )
    c < 0 && a === 0 && this[d + n + 1] !== 0 && (a = 1), this[d + n] = (c / u >> 0) - a & 255;
  return d + w;
};
Te.prototype.writeInt8 = function(c, d, w) {
  return c = +c, d = d | 0, w || ar(this, c, d, 1, 127, -128), Te.TYPED_ARRAY_SUPPORT || (c = Math.floor(c)), c < 0 && (c = 255 + c + 1), this[d] = c & 255, d + 1;
};
Te.prototype.writeInt16LE = function(c, d, w) {
  return c = +c, d = d | 0, w || ar(this, c, d, 2, 32767, -32768), Te.TYPED_ARRAY_SUPPORT ? (this[d] = c & 255, this[d + 1] = c >>> 8) : Fs(this, c, d, !0), d + 2;
};
Te.prototype.writeInt16BE = function(c, d, w) {
  return c = +c, d = d | 0, w || ar(this, c, d, 2, 32767, -32768), Te.TYPED_ARRAY_SUPPORT ? (this[d] = c >>> 8, this[d + 1] = c & 255) : Fs(this, c, d, !1), d + 2;
};
Te.prototype.writeInt32LE = function(c, d, w) {
  return c = +c, d = d | 0, w || ar(this, c, d, 4, 2147483647, -2147483648), Te.TYPED_ARRAY_SUPPORT ? (this[d] = c & 255, this[d + 1] = c >>> 8, this[d + 2] = c >>> 16, this[d + 3] = c >>> 24) : Hs(this, c, d, !0), d + 4;
};
Te.prototype.writeInt32BE = function(c, d, w) {
  return c = +c, d = d | 0, w || ar(this, c, d, 4, 2147483647, -2147483648), c < 0 && (c = 4294967295 + c + 1), Te.TYPED_ARRAY_SUPPORT ? (this[d] = c >>> 24, this[d + 1] = c >>> 16, this[d + 2] = c >>> 8, this[d + 3] = c & 255) : Hs(this, c, d, !1), d + 4;
};
function y8(e, c, d, w, g, f) {
  if (d + w > e.length) throw new RangeError("Index out of range");
  if (d < 0) throw new RangeError("Index out of range");
}
function v8(e, c, d, w, g) {
  return g || y8(e, c, d, 4), l8(e, c, d, w, 23, 4), d + 4;
}
Te.prototype.writeFloatLE = function(c, d, w) {
  return v8(this, c, d, !0, w);
};
Te.prototype.writeFloatBE = function(c, d, w) {
  return v8(this, c, d, !1, w);
};
function S8(e, c, d, w, g) {
  return g || y8(e, c, d, 8), l8(e, c, d, w, 52, 8), d + 8;
}
Te.prototype.writeDoubleLE = function(c, d, w) {
  return S8(this, c, d, !0, w);
};
Te.prototype.writeDoubleBE = function(c, d, w) {
  return S8(this, c, d, !1, w);
};
Te.prototype.copy = function(c, d, w, g) {
  if (w || (w = 0), !g && g !== 0 && (g = this.length), d >= c.length && (d = c.length), d || (d = 0), g > 0 && g < w && (g = w), g === w || c.length === 0 || this.length === 0) return 0;
  if (d < 0)
    throw new RangeError("targetStart out of bounds");
  if (w < 0 || w >= this.length) throw new RangeError("sourceStart out of bounds");
  if (g < 0) throw new RangeError("sourceEnd out of bounds");
  g > this.length && (g = this.length), c.length - d < g - w && (g = c.length - d + w);
  var f = g - w, n;
  if (this === c && w < d && d < g)
    for (n = f - 1; n >= 0; --n)
      c[n + d] = this[n + w];
  else if (f < 1e3 || !Te.TYPED_ARRAY_SUPPORT)
    for (n = 0; n < f; ++n)
      c[n + d] = this[n + w];
  else
    Uint8Array.prototype.set.call(
      c,
      this.subarray(w, w + f),
      d
    );
  return f;
};
Te.prototype.fill = function(c, d, w, g) {
  if (typeof c == "string") {
    if (typeof d == "string" ? (g = d, d = 0, w = this.length) : typeof w == "string" && (g = w, w = this.length), c.length === 1) {
      var f = c.charCodeAt(0);
      f < 256 && (c = f);
    }
    if (g !== void 0 && typeof g != "string")
      throw new TypeError("encoding must be a string");
    if (typeof g == "string" && !Te.isEncoding(g))
      throw new TypeError("Unknown encoding: " + g);
  } else typeof c == "number" && (c = c & 255);
  if (d < 0 || this.length < d || this.length < w)
    throw new RangeError("Out of range index");
  if (w <= d)
    return this;
  d = d >>> 0, w = w === void 0 ? this.length : w >>> 0, c || (c = 0);
  var n;
  if (typeof c == "number")
    for (n = d; n < w; ++n)
      this[n] = c;
  else {
    var u = Tr(c) ? c : Bs(new Te(c, g).toString()), a = u.length;
    for (n = 0; n < w - d; ++n)
      this[n + d] = u[n % a];
  }
  return this;
};
var zp = /[^+\/0-9A-Za-z-_]/g;
function Tp(e) {
  if (e = Cp(e).replace(zp, ""), e.length < 2) return "";
  for (; e.length % 4 !== 0; )
    e = e + "=";
  return e;
}
function Cp(e) {
  return e.trim ? e.trim() : e.replace(/^\s+|\s+$/g, "");
}
function Dp(e) {
  return e < 16 ? "0" + e.toString(16) : e.toString(16);
}
function Bs(e, c) {
  c = c || 1 / 0;
  for (var d, w = e.length, g = null, f = [], n = 0; n < w; ++n) {
    if (d = e.charCodeAt(n), d > 55295 && d < 57344) {
      if (!g) {
        if (d > 56319) {
          (c -= 3) > -1 && f.push(239, 191, 189);
          continue;
        } else if (n + 1 === w) {
          (c -= 3) > -1 && f.push(239, 191, 189);
          continue;
        }
        g = d;
        continue;
      }
      if (d < 56320) {
        (c -= 3) > -1 && f.push(239, 191, 189), g = d;
        continue;
      }
      d = (g - 55296 << 10 | d - 56320) + 65536;
    } else g && (c -= 3) > -1 && f.push(239, 191, 189);
    if (g = null, d < 128) {
      if ((c -= 1) < 0) break;
      f.push(d);
    } else if (d < 2048) {
      if ((c -= 2) < 0) break;
      f.push(
        d >> 6 | 192,
        d & 63 | 128
      );
    } else if (d < 65536) {
      if ((c -= 3) < 0) break;
      f.push(
        d >> 12 | 224,
        d >> 6 & 63 | 128,
        d & 63 | 128
      );
    } else if (d < 1114112) {
      if ((c -= 4) < 0) break;
      f.push(
        d >> 18 | 240,
        d >> 12 & 63 | 128,
        d >> 6 & 63 | 128,
        d & 63 | 128
      );
    } else
      throw new Error("Invalid code point");
  }
  return f;
}
function Up(e) {
  for (var c = [], d = 0; d < e.length; ++d)
    c.push(e.charCodeAt(d) & 255);
  return c;
}
function Fp(e, c) {
  for (var d, w, g, f = [], n = 0; n < e.length && !((c -= 2) < 0); ++n)
    d = e.charCodeAt(n), w = d >> 8, g = d % 256, f.push(g), f.push(w);
  return f;
}
function E8(e) {
  return bp(Tp(e));
}
function Ls(e, c, d, w) {
  for (var g = 0; g < w && !(g + d >= c.length || g >= e.length); ++g)
    c[g + d] = e[g];
  return g;
}
function Hp(e) {
  return e !== e;
}
function Zi(e) {
  return e != null && (!!e._isBuffer || I8(e) || Lp(e));
}
function I8(e) {
  return !!e.constructor && typeof e.constructor.isBuffer == "function" && e.constructor.isBuffer(e);
}
function Lp(e) {
  return typeof e.readFloatLE == "function" && typeof e.slice == "function" && I8(e.slice(0, 0));
}
function A8() {
  throw new Error("setTimeout has not been defined");
}
function O8() {
  throw new Error("clearTimeout has not been defined");
}
var hi = A8, li = O8;
typeof Bi.setTimeout == "function" && (hi = setTimeout);
typeof Bi.clearTimeout == "function" && (li = clearTimeout);
function _8(e) {
  if (hi === setTimeout)
    return setTimeout(e, 0);
  if ((hi === A8 || !hi) && setTimeout)
    return hi = setTimeout, setTimeout(e, 0);
  try {
    return hi(e, 0);
  } catch {
    try {
      return hi.call(null, e, 0);
    } catch {
      return hi.call(this, e, 0);
    }
  }
}
function Kp(e) {
  if (li === clearTimeout)
    return clearTimeout(e);
  if ((li === O8 || !li) && clearTimeout)
    return li = clearTimeout, clearTimeout(e);
  try {
    return li(e);
  } catch {
    try {
      return li.call(null, e);
    } catch {
      return li.call(this, e);
    }
  }
}
var ei = [], tn = !1, Ri, Rs = -1;
function Vp() {
  !tn || !Ri || (tn = !1, Ri.length ? ei = Ri.concat(ei) : Rs = -1, ei.length && R8());
}
function R8() {
  if (!tn) {
    var e = _8(Vp);
    tn = !0;
    for (var c = ei.length; c; ) {
      for (Ri = ei, ei = []; ++Rs < c; )
        Ri && Ri[Rs].run();
      Rs = -1, c = ei.length;
    }
    Ri = null, tn = !1, Kp(e);
  }
}
function $p(e) {
  var c = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var d = 1; d < arguments.length; d++)
      c[d - 1] = arguments[d];
  ei.push(new P8(e, c)), ei.length === 1 && !tn && _8(R8);
}
function P8(e, c) {
  this.fun = e, this.array = c;
}
P8.prototype.run = function() {
  this.fun.apply(null, this.array);
};
var jp = "browser", Yp = "browser", Xp = !0, Jp = {}, Gp = [], Wp = "", Zp = {}, Qp = {}, em = {};
function qi() {
}
var tm = qi, rm = qi, im = qi, nm = qi, sm = qi, om = qi, am = qi;
function fm(e) {
  throw new Error("process.binding is not supported");
}
function cm() {
  return "/";
}
function um(e) {
  throw new Error("process.chdir is not supported");
}
function hm() {
  return 0;
}
var Wi = Bi.performance || {}, lm = Wi.now || Wi.mozNow || Wi.msNow || Wi.oNow || Wi.webkitNow || function() {
  return (/* @__PURE__ */ new Date()).getTime();
};
function dm(e) {
  var c = lm.call(Wi) * 1e-3, d = Math.floor(c), w = Math.floor(c % 1 * 1e9);
  return e && (d = d - e[0], w = w - e[1], w < 0 && (d--, w += 1e9)), [d, w];
}
var bm = /* @__PURE__ */ new Date();
function pm() {
  var e = /* @__PURE__ */ new Date(), c = e - bm;
  return c / 1e3;
}
var rn = {
  nextTick: $p,
  title: jp,
  browser: Xp,
  env: Jp,
  argv: Gp,
  version: Wp,
  versions: Zp,
  on: tm,
  addListener: rm,
  once: im,
  off: nm,
  removeListener: sm,
  removeAllListeners: om,
  emit: am,
  binding: fm,
  cwd: cm,
  chdir: um,
  umask: hm,
  hrtime: dm,
  platform: Yp,
  release: Qp,
  config: em,
  uptime: pm
}, Fn;
typeof Object.create == "function" ? Fn = function(c, d) {
  c.super_ = d, c.prototype = Object.create(d.prototype, {
    constructor: {
      value: c,
      enumerable: !1,
      writable: !0,
      configurable: !0
    }
  });
} : Fn = function(c, d) {
  c.super_ = d;
  var w = function() {
  };
  w.prototype = d.prototype, c.prototype = new w(), c.prototype.constructor = c;
};
var k8 = Object.getOwnPropertyDescriptors || function(c) {
  for (var d = Object.keys(c), w = {}, g = 0; g < d.length; g++)
    w[d[g]] = Object.getOwnPropertyDescriptor(c, d[g]);
  return w;
}, mm = /%[sdj%]/g;
function Ks(e) {
  if (!Vn(e)) {
    for (var c = [], d = 0; d < arguments.length; d++)
      c.push(Ar(arguments[d]));
    return c.join(" ");
  }
  for (var d = 1, w = arguments, g = w.length, f = String(e).replace(mm, function(u) {
    if (u === "%%") return "%";
    if (d >= g) return u;
    switch (u) {
      case "%s":
        return String(w[d++]);
      case "%d":
        return Number(w[d++]);
      case "%j":
        try {
          return JSON.stringify(w[d++]);
        } catch {
          return "[Circular]";
        }
      default:
        return u;
    }
  }), n = w[d]; d < g; n = w[++d])
    Kn(n) || !zi(n) ? f += " " + n : f += " " + Ar(n);
  return f;
}
function Mh(e, c) {
  if (zr(Bi.process))
    return function() {
      return Mh(e, c).apply(this, arguments);
    };
  if (rn.noDeprecation === !0)
    return e;
  var d = !1;
  function w() {
    if (!d) {
      if (rn.throwDeprecation)
        throw new Error(c);
      rn.traceDeprecation ? console.trace(c) : console.error(c), d = !0;
    }
    return e.apply(this, arguments);
  }
  return w;
}
var us = {}, t0;
function B8(e) {
  if (zr(t0) && (t0 = rn.env.NODE_DEBUG || ""), e = e.toUpperCase(), !us[e])
    if (new RegExp("\\b" + e + "\\b", "i").test(t0)) {
      var c = 0;
      us[e] = function() {
        var d = Ks.apply(null, arguments);
        console.error("%s %d: %s", e, c, d);
      };
    } else
      us[e] = function() {
      };
  return us[e];
}
function Ar(e, c) {
  var d = {
    seen: [],
    stylize: xm
  };
  return arguments.length >= 3 && (d.depth = arguments[2]), arguments.length >= 4 && (d.colors = arguments[3]), Vs(c) ? d.showHidden = c : c && Th(d, c), zr(d.showHidden) && (d.showHidden = !1), zr(d.depth) && (d.depth = 2), zr(d.colors) && (d.colors = !1), zr(d.customInspect) && (d.customInspect = !0), d.colors && (d.stylize = gm), Ms(d, e, d.depth);
}
Ar.colors = {
  bold: [1, 22],
  italic: [3, 23],
  underline: [4, 24],
  inverse: [7, 27],
  white: [37, 39],
  grey: [90, 39],
  black: [30, 39],
  blue: [34, 39],
  cyan: [36, 39],
  green: [32, 39],
  magenta: [35, 39],
  red: [31, 39],
  yellow: [33, 39]
};
Ar.styles = {
  special: "cyan",
  number: "yellow",
  boolean: "yellow",
  undefined: "grey",
  null: "bold",
  string: "green",
  date: "magenta",
  // "name": intentionally not styling
  regexp: "red"
};
function gm(e, c) {
  var d = Ar.styles[c];
  return d ? "\x1B[" + Ar.colors[d][0] + "m" + e + "\x1B[" + Ar.colors[d][1] + "m" : e;
}
function xm(e, c) {
  return e;
}
function wm(e) {
  var c = {};
  return e.forEach(function(d, w) {
    c[d] = !0;
  }), c;
}
function Ms(e, c, d) {
  if (e.customInspect && c && ki(c.inspect) && // Filter out the util module, it's inspect function is special
  c.inspect !== Ar && // Also filter out any prototype objects using the circular check.
  !(c.constructor && c.constructor.prototype === c)) {
    var w = c.inspect(d, e);
    return Vn(w) || (w = Ms(e, w, d)), w;
  }
  var g = ym(e, c);
  if (g)
    return g;
  var f = Object.keys(c), n = wm(f);
  if (e.showHidden && (f = Object.getOwnPropertyNames(c)), nn(c) && (f.indexOf("message") >= 0 || f.indexOf("description") >= 0))
    return r0(c);
  if (f.length === 0) {
    if (ki(c)) {
      var u = c.name ? ": " + c.name : "";
      return e.stylize("[Function" + u + "]", "special");
    }
    if (Pi(c))
      return e.stylize(RegExp.prototype.toString.call(c), "regexp");
    if (on(c))
      return e.stylize(Date.prototype.toString.call(c), "date");
    if (nn(c))
      return r0(c);
  }
  var a = "", s = !1, i = ["{", "}"];
  if (Nh(c) && (s = !0, i = ["[", "]"]), ki(c)) {
    var p = c.name ? ": " + c.name : "";
    a = " [Function" + p + "]";
  }
  if (Pi(c) && (a = " " + RegExp.prototype.toString.call(c)), on(c) && (a = " " + Date.prototype.toUTCString.call(c)), nn(c) && (a = " " + r0(c)), f.length === 0 && (!s || c.length == 0))
    return i[0] + a + i[1];
  if (d < 0)
    return Pi(c) ? e.stylize(RegExp.prototype.toString.call(c), "regexp") : e.stylize("[Object]", "special");
  e.seen.push(c);
  var m;
  return s ? m = vm(e, c, d, n, f) : m = f.map(function(E) {
    return wh(e, c, d, n, E, s);
  }), e.seen.pop(), Sm(m, a, i);
}
function ym(e, c) {
  if (zr(c))
    return e.stylize("undefined", "undefined");
  if (Vn(c)) {
    var d = "'" + JSON.stringify(c).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
    return e.stylize(d, "string");
  }
  if (qh(c))
    return e.stylize("" + c, "number");
  if (Vs(c))
    return e.stylize("" + c, "boolean");
  if (Kn(c))
    return e.stylize("null", "null");
}
function r0(e) {
  return "[" + Error.prototype.toString.call(e) + "]";
}
function vm(e, c, d, w, g) {
  for (var f = [], n = 0, u = c.length; n < u; ++n)
    T8(c, String(n)) ? f.push(wh(
      e,
      c,
      d,
      w,
      String(n),
      !0
    )) : f.push("");
  return g.forEach(function(a) {
    a.match(/^\d+$/) || f.push(wh(
      e,
      c,
      d,
      w,
      a,
      !0
    ));
  }), f;
}
function wh(e, c, d, w, g, f) {
  var n, u, a;
  if (a = Object.getOwnPropertyDescriptor(c, g) || { value: c[g] }, a.get ? a.set ? u = e.stylize("[Getter/Setter]", "special") : u = e.stylize("[Getter]", "special") : a.set && (u = e.stylize("[Setter]", "special")), T8(w, g) || (n = "[" + g + "]"), u || (e.seen.indexOf(a.value) < 0 ? (Kn(d) ? u = Ms(e, a.value, null) : u = Ms(e, a.value, d - 1), u.indexOf(`
`) > -1 && (f ? u = u.split(`
`).map(function(s) {
    return "  " + s;
  }).join(`
`).substr(2) : u = `
` + u.split(`
`).map(function(s) {
    return "   " + s;
  }).join(`
`))) : u = e.stylize("[Circular]", "special")), zr(n)) {
    if (f && g.match(/^\d+$/))
      return u;
    n = JSON.stringify("" + g), n.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (n = n.substr(1, n.length - 2), n = e.stylize(n, "name")) : (n = n.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), n = e.stylize(n, "string"));
  }
  return n + ": " + u;
}
function Sm(e, c, d) {
  var w = e.reduce(function(g, f) {
    return f.indexOf(`
`) >= 0, g + f.replace(/\u001b\[\d\d?m/g, "").length + 1;
  }, 0);
  return w > 60 ? d[0] + (c === "" ? "" : c + `
 `) + " " + e.join(`,
  `) + " " + d[1] : d[0] + c + " " + e.join(", ") + " " + d[1];
}
function Nh(e) {
  return Array.isArray(e);
}
function Vs(e) {
  return typeof e == "boolean";
}
function Kn(e) {
  return e === null;
}
function M8(e) {
  return e == null;
}
function qh(e) {
  return typeof e == "number";
}
function Vn(e) {
  return typeof e == "string";
}
function N8(e) {
  return typeof e == "symbol";
}
function zr(e) {
  return e === void 0;
}
function Pi(e) {
  return zi(e) && zh(e) === "[object RegExp]";
}
function zi(e) {
  return typeof e == "object" && e !== null;
}
function on(e) {
  return zi(e) && zh(e) === "[object Date]";
}
function nn(e) {
  return zi(e) && (zh(e) === "[object Error]" || e instanceof Error);
}
function ki(e) {
  return typeof e == "function";
}
function Ns(e) {
  return e === null || typeof e == "boolean" || typeof e == "number" || typeof e == "string" || typeof e == "symbol" || // ES6 symbol
  typeof e > "u";
}
function q8(e) {
  return Te.isBuffer(e);
}
function zh(e) {
  return Object.prototype.toString.call(e);
}
function i0(e) {
  return e < 10 ? "0" + e.toString(10) : e.toString(10);
}
var Em = [
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "May",
  "Jun",
  "Jul",
  "Aug",
  "Sep",
  "Oct",
  "Nov",
  "Dec"
];
function Im() {
  var e = /* @__PURE__ */ new Date(), c = [
    i0(e.getHours()),
    i0(e.getMinutes()),
    i0(e.getSeconds())
  ].join(":");
  return [e.getDate(), Em[e.getMonth()], c].join(" ");
}
function z8() {
  console.log("%s - %s", Im(), Ks.apply(null, arguments));
}
function Th(e, c) {
  if (!c || !zi(c)) return e;
  for (var d = Object.keys(c), w = d.length; w--; )
    e[d[w]] = c[d[w]];
  return e;
}
function T8(e, c) {
  return Object.prototype.hasOwnProperty.call(e, c);
}
var Ii = typeof Symbol < "u" ? Symbol("util.promisify.custom") : void 0;
function Ch(e) {
  if (typeof e != "function")
    throw new TypeError('The "original" argument must be of type Function');
  if (Ii && e[Ii]) {
    var c = e[Ii];
    if (typeof c != "function")
      throw new TypeError('The "util.promisify.custom" argument must be of type Function');
    return Object.defineProperty(c, Ii, {
      value: c,
      enumerable: !1,
      writable: !1,
      configurable: !0
    }), c;
  }
  function c() {
    for (var d, w, g = new Promise(function(u, a) {
      d = u, w = a;
    }), f = [], n = 0; n < arguments.length; n++)
      f.push(arguments[n]);
    f.push(function(u, a) {
      u ? w(u) : d(a);
    });
    try {
      e.apply(this, f);
    } catch (u) {
      w(u);
    }
    return g;
  }
  return Object.setPrototypeOf(c, Object.getPrototypeOf(e)), Ii && Object.defineProperty(c, Ii, {
    value: c,
    enumerable: !1,
    writable: !1,
    configurable: !0
  }), Object.defineProperties(
    c,
    k8(e)
  );
}
Ch.custom = Ii;
function Am(e, c) {
  if (!e) {
    var d = new Error("Promise was rejected with a falsy value");
    d.reason = e, e = d;
  }
  return c(e);
}
function C8(e) {
  if (typeof e != "function")
    throw new TypeError('The "original" argument must be of type Function');
  function c() {
    for (var d = [], w = 0; w < arguments.length; w++)
      d.push(arguments[w]);
    var g = d.pop();
    if (typeof g != "function")
      throw new TypeError("The last argument must be of type Function");
    var f = this, n = function() {
      return g.apply(f, arguments);
    };
    e.apply(this, d).then(
      function(u) {
        rn.nextTick(n.bind(null, null, u));
      },
      function(u) {
        rn.nextTick(Am.bind(null, u, n));
      }
    );
  }
  return Object.setPrototypeOf(c, Object.getPrototypeOf(e)), Object.defineProperties(c, k8(e)), c;
}
var Om = {
  inherits: Fn,
  _extend: Th,
  log: z8,
  isBuffer: q8,
  isPrimitive: Ns,
  isFunction: ki,
  isError: nn,
  isDate: on,
  isObject: zi,
  isRegExp: Pi,
  isUndefined: zr,
  isSymbol: N8,
  isString: Vn,
  isNumber: qh,
  isNullOrUndefined: M8,
  isNull: Kn,
  isBoolean: Vs,
  isArray: Nh,
  inspect: Ar,
  deprecate: Mh,
  format: Ks,
  debuglog: B8,
  promisify: Ch,
  callbackify: C8
}, _m = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  _extend: Th,
  callbackify: C8,
  debuglog: B8,
  default: Om,
  deprecate: Mh,
  format: Ks,
  inherits: Fn,
  inspect: Ar,
  isArray: Nh,
  isBoolean: Vs,
  isBuffer: q8,
  isDate: on,
  isError: nn,
  isFunction: ki,
  isNull: Kn,
  isNullOrUndefined: M8,
  isNumber: qh,
  isObject: zi,
  isPrimitive: Ns,
  isRegExp: Pi,
  isString: Vn,
  isSymbol: N8,
  isUndefined: zr,
  log: z8,
  promisify: Ch
}), D8 = /* @__PURE__ */ Oh(_m);
/*!
 * custom.js - custom inspect symbol for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var I1;
function U8() {
  if (I1) return e0;
  I1 = 1;
  const { inspect: e } = D8;
  return e0.custom = e.custom || "inspect", e0;
}
/*!
 * bn.js - big numbers for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/bn.js:
 *   Copyright (c) 2015, Fedor Indutny (MIT License).
 *   https://github.com/indutny/bn.js
 *
 * Parts of this software are based on golang/go:
 *   Copyright (c) 2009, The Go Authors. All rights reserved.
 *   https://github.com/golang/go
 *
 * Parts of this software are based on openssl/openssl:
 *   Copyright (c) 1998-2018, The OpenSSL Project (Apache License v2.0).
 *   Copyright (c) 1995-1998, Eric A. Young, Tim J. Hudson. All rights reserved.
 *   https://github.com/openssl/openssl
 *
 * Parts of this software are based on libgmp:
 *   Copyright (c) 1991-1997, 1999-2014, Free Software Foundation, Inc.
 *   https://gmplib.org/
 *
 * Parts of this software are based on v8/v8:
 *   Copyright (c) 2017, The V8 Project Authors (BSD-Style License).
 *   https://github.com/v8/v8
 *
 * Resources:
 *   https://github.com/indutny/bn.js/blob/master/lib/bn.js
 *   https://github.com/indutny/miller-rabin/blob/master/lib/mr.js
 *   https://github.com/golang/go/blob/master/src/math/big/int.go
 *   https://github.com/golang/go/blob/master/src/math/big/nat.go
 *   https://github.com/golang/go/blob/master/src/math/big/prime.go
 *   https://github.com/openssl/openssl/tree/master/crypto/bn
 *   https://github.com/openssl/openssl/blob/master/crypto/bn/bn_kron.c
 *   https://github.com/gnutls/nettle/blob/master/mini-gmp.c
 *   https://github.com/v8/v8/blob/master/src/objects/bigint.cc
 */
var n0, A1;
function Ur() {
  if (A1) return n0;
  A1 = 1;
  const { custom: e } = U8(), c = [
    "",
    "0",
    "00",
    "000",
    "0000",
    "00000",
    "000000",
    "0000000",
    "00000000",
    "000000000",
    "0000000000",
    "00000000000",
    "000000000000",
    "0000000000000",
    "00000000000000",
    "000000000000000",
    "0000000000000000",
    "00000000000000000",
    "000000000000000000",
    "0000000000000000000",
    "00000000000000000000",
    "000000000000000000000",
    "0000000000000000000000",
    "00000000000000000000000",
    "000000000000000000000000",
    "0000000000000000000000000"
  ], d = [
    0,
    25,
    16,
    12,
    11,
    10,
    9,
    8,
    8,
    7,
    7,
    7,
    7,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5
  ], w = [
    0,
    33554432,
    43046721,
    16777216,
    48828125,
    60466176,
    40353607,
    16777216,
    43046721,
    1e7,
    19487171,
    35831808,
    62748517,
    7529536,
    11390625,
    16777216,
    24137569,
    34012224,
    47045881,
    64e6,
    4084101,
    5153632,
    6436343,
    7962624,
    9765625,
    11881376,
    14348907,
    17210368,
    20511149,
    243e5,
    28629151,
    33554432,
    39135393,
    45435424,
    52521875,
    60466176
  ], g = {
    p192: null,
    p224: null,
    p521: null,
    k256: null,
    p251: null,
    p25519: null,
    p448: null
  }, f = {
    NONE: 0,
    QUO: 1,
    REM: 2,
    BOTH: 3,
    EUCLID: 4,
    ALL: 7
  }, n = 4, u = 1 << n - 1, a = typeof BigInt == "function";
  class s {
    constructor(t, l, B) {
      this.words = [0], this.length = 1, this.negative = 0, this.red = null, this.from(t, l, B);
    }
    /*
     * Addition Engine
     */
    _iadd(t, l) {
      let B = 0, U = 0;
      for (t.length < l.length && ([t, l] = [l, t]), t !== this && this._alloc(t.length); U < l.length; U++) {
        const G = (t.words[U] | 0) + (l.words[U] | 0) + B;
        this.words[U] = G & 67108863, B = G >>> 26;
      }
      for (; B !== 0 && U < t.length; U++) {
        const G = (t.words[U] | 0) + B;
        this.words[U] = G & 67108863, B = G >>> 26;
      }
      if (this.length = t.length, B !== 0)
        this._alloc(this.length + 1), this.words[this.length++] = B;
      else if (t !== this)
        for (; U < t.length; U++)
          this.words[U] = t.words[U];
      return this;
    }
    _iaddn(t) {
      if (this.words[0] += t, this.words[0] < 67108864)
        return this;
      let l = 0;
      for (this._alloc(this.length + 1), this.words[this.length] = 0; l < this.length && this.words[l] >= 67108864; l++)
        this.words[l] -= 67108864, this.words[l + 1] += 1;
      return this.length = Math.max(this.length, l + 1), this;
    }
    /*
     * Addition
     */
    iadd(t) {
      if (_(s.isBN(t), "num", "bignum"), this.negative === t.negative)
        this._iadd(this, t);
      else {
        const l = this.ucmp(t);
        if (l === 0)
          return this.words[0] = 0, this.length = 1, this.negative = 0, this;
        l < 0 ? (this._isub(t, this), this.negative ^= 1) : this._isub(this, t);
      }
      return this;
    }
    iaddn(t) {
      _(D(t), "num", "smi");
      const l = t < 0 | 0;
      return l && (t = -t), this.negative === l ? this._iaddn(t) : this.length === 1 && this.words[0] < t ? (this.words[0] = t - this.words[0], this.negative ^= 1) : this._isubn(t), this;
    }
    add(t) {
      return _(s.isBN(t), "num", "bignum"), t.length > this.length ? t.clone().iadd(this) : this.clone().iadd(t);
    }
    addn(t) {
      return this.clone().iaddn(t);
    }
    /*
     * Subtraction Engine
     */
    _isub(t, l) {
      let B = 0, U = 0;
      for (q(t.length >= l.length), t !== this && this._alloc(t.length); U < l.length; U++) {
        const G = (t.words[U] | 0) - (l.words[U] | 0) + B;
        B = G >> 26, this.words[U] = G & 67108863;
      }
      for (; B !== 0 && U < t.length; U++) {
        const G = (t.words[U] | 0) + B;
        B = G >> 26, this.words[U] = G & 67108863;
      }
      if (q(B === 0), t !== this)
        for (; U < t.length; U++)
          this.words[U] = t.words[U];
      return this.length = Math.max(this.length, U), this._strip();
    }
    _isubn(t) {
      if (this.words[0] -= t, this.words[0] >= 0)
        return this._normalize();
      q(this.length !== 1), this._alloc(this.length + 1);
      for (let l = 0; l < this.length && this.words[l] < 0; l++)
        this.words[l] += 67108864, this.words[l + 1] -= 1;
      return this.words[this.length] = 0, this._strip();
    }
    /*
     * Subtraction
     */
    isub(t) {
      if (_(s.isBN(t), "num", "bignum"), this.negative !== t.negative)
        this._iadd(this, t);
      else {
        const l = this.ucmp(t);
        if (l === 0)
          return this.words[0] = 0, this.length = 1, this.negative = 0, this;
        l < 0 ? (this._isub(t, this), this.negative ^= 1) : this._isub(this, t);
      }
      return this;
    }
    isubn(t) {
      _(D(t), "num", "smi");
      const l = t < 0 | 0;
      return l && (t = -t), this.negative !== l ? this._iaddn(t) : this.length === 1 && this.words[0] < t ? (this.words[0] = t - this.words[0], this.negative ^= 1) : this._isubn(t), this;
    }
    sub(t) {
      return this.clone().isub(t);
    }
    subn(t) {
      return this.clone().isubn(t);
    }
    /*
     * Multiplication Engine
     */
    _mul(t, l) {
      if (_(s.isBN(t), "num", "bignum"), _(s.isBN(l), "out", "bignum"), this.length === 10 && t.length === 10)
        return I(this, t, l);
      const B = this.length + t.length;
      return B < 63 ? Ie(this, t, l) : B < 1024 ? ve(this, t, l) : C(this, t, l);
    }
    /*
     * Multiplication
     */
    imul(t) {
      return this.mul(t)._move(this);
    }
    imuln(t) {
      _(D(t), "num", "smi");
      const l = t < 0 | 0;
      l && (t = -t);
      let B = 0;
      for (let U = 0; U < this.length; U++) {
        const G = this.words[U] * t, T = (G & 67108863) + (B & 67108863);
        B >>= 26, B += G / 67108864 | 0, B += T >>> 26, this.words[U] = T & 67108863;
      }
      return this.negative ^= l, B !== 0 ? (this._alloc(this.length + 1), this.words[this.length++] = B) : this._strip(), this;
    }
    mul(t) {
      _(s.isBN(t), "num", "bignum");
      const l = this.length + t.length, B = new s();
      B.words = new Array(l);
      for (let U = 0; U < l; U++)
        B.words[U] = 0;
      return this._mul(t, B);
    }
    muln(t) {
      return this.clone().imuln(t);
    }
    /*
     * Multiplication + Shift
     */
    mulShift(t, l) {
      _(s.isBN(t), "num", "bignum"), _(l >>> 0 === l, "bits", "uint32");
      const B = this.mul(t), U = B.utestn(l - 1);
      return B.iushrn(l), this.negative ^ t.negative ? B.isubn(U) : B.iaddn(U);
    }
    /*
     * Division Engine
     */
    _div(t, l) {
      _(s.isBN(t), "num", "bignum"), q((l & f.ALL) === l), q(l !== f.NONE);
      const B = this, U = t;
      if (fe(!U.isZero()), B.isZero())
        return [new s(0), new s(0)];
      const G = B.negative, T = U.negative;
      B.negative = 0, U.negative = 0;
      let M = null, $ = null;
      return B.ucmp(U) < 0 ? (l & f.QUO && (M = new s(0)), l & f.REM && ($ = B.clone())) : U.length === 1 ? (l & f.QUO && (M = B.quon(U.words[0])), l & f.REM && ($ = B.remn(U.words[0]))) : [M, $] = B._wordDiv(U, l), B.negative = G, U.negative = T, l & f.QUO && (M.negative = B.negative ^ U.negative, M._normalize()), l & f.REM && ($.negative = B.negative, $._normalize()), l & f.EUCLID && (l & f.QUO && (q((l & f.REM) !== 0), $.negative !== 0 && (U.negative !== 0 ? M.iaddn(1) : M.isubn(1))), l & f.REM && $.negative !== 0 && (U.negative !== 0 ? $.isub(U) : $.iadd(U))), [M, $];
    }
    _wordDiv(t, l) {
      let B = this.clone(), U = t, G = null, T;
      const M = U.words[U.length - 1] | 0, $ = 26 - oe(M);
      $ !== 0 ? (U = U.clone(), B.iushln($), U.iushln($), T = U.words[U.length - 1] | 0) : T = M;
      const r = B.length - U.length;
      if (q(r >= 0), l & f.QUO) {
        G = new s(0), G.length = r + 1, G.words = new Array(G.length);
        for (let O = 0; O < G.length; O++)
          G.words[O] = 0;
      }
      const x = B.clone();
      x._ishlnsubmul(U, 1, r), x.negative === 0 && (G && (G.words[r] = 1), B = x);
      for (let O = r - 1; O >= 0; O--) {
        const L = B.words[U.length + O], X = B.words[U.length + O - 1], P = (L * 67108864 + X) / T | 0;
        let K = Math.min(P, 67108863);
        for (B._ishlnsubmul(U, K, O); B.negative !== 0; )
          K -= 1, B.negative = 0, B._ishlnsubmul(U, 1, O), B.ineg();
        G && (G.words[O] = K);
      }
      return G && G._strip(), l & f.REM && $ !== 0 && B.iushrn($), [G, B];
    }
    _ishlnsubmul(t, l, B) {
      let U = 0, G = 0;
      for (this._expand(t.length + B); G < t.length; G++) {
        const T = (this.words[G + B] | 0) + U, M = t.words[G] * l, $ = T - (M & 67108863);
        U = ($ >> 26) - (M / 67108864 | 0), this.words[G + B] = $ & 67108863;
      }
      for (; G < this.length - B; G++) {
        const T = (this.words[G + B] | 0) + U;
        U = T >> 26, this.words[G + B] = T & 67108863;
      }
      if (U === 0)
        return this._strip();
      q(U === -1), U = 0;
      for (let T = 0; T < this.length; T++) {
        const M = -(this.words[T] | 0) + U;
        U = M >> 26, this.words[T] = M & 67108863;
      }
      return this.negative = 1, this._strip();
    }
    /*
     * Truncation Division + Modulo
     */
    quorem(t) {
      return this._div(t, f.BOTH);
    }
    /*
     * Truncation Division
     */
    iquo(t) {
      return this.quo(t)._move(this);
    }
    iquon(t) {
      _(D(t), "num", "smi"), fe(t !== 0);
      const l = t < 0 | 0;
      l && (t = -t);
      let B = 0;
      for (let U = this.length - 1; U >= 0; U--) {
        const G = (this.words[U] | 0) + B * 67108864;
        this.words[U] = G / t | 0, B = G % t;
      }
      return this.negative ^= l, this._strip();
    }
    quo(t) {
      return this._div(t, f.QUO)[0];
    }
    quon(t) {
      return this.clone().iquon(t);
    }
    /*
     * Truncation Modulo
     */
    irem(t) {
      return this.rem(t)._move(this);
    }
    iremn(t) {
      let l = this.remrn(t);
      return l < 0 && (l = -l), this.words[0] = l, this.length = 1, this._normalize();
    }
    rem(t) {
      return this._div(t, f.REM)[1];
    }
    remn(t) {
      return this.clone().iremn(t);
    }
    remrn(t) {
      _(D(t), "num", "smi"), fe(t !== 0), t < 0 && (t = -t);
      const l = (1 << 26) % t;
      let B = 0;
      for (let U = this.length - 1; U >= 0; U--)
        B = (l * B + (this.words[U] | 0)) % t;
      return this.negative !== 0 ? -B | 0 : B;
    }
    /*
     * Euclidean Division + Modulo
     */
    divmod(t) {
      return this._div(t, f.BOTH | f.EUCLID);
    }
    /*
     * Euclidean Division
     */
    idiv(t) {
      return this.div(t)._move(this);
    }
    idivn(t) {
      if (this.negative === 0)
        return this.iquon(t);
      const l = this.remrn(t);
      return this.iquon(t), l < 0 && (t < 0 ? this.iaddn(1) : this.isubn(1)), this;
    }
    div(t) {
      return this._div(t, f.BOTH | f.EUCLID)[0];
    }
    divn(t) {
      return this.clone().idivn(t);
    }
    /*
     * Euclidean Modulo
     */
    imod(t) {
      return this.ucmp(t) < 0 ? (this.negative !== 0 && (this._isub(t, this), this.negative = 0), this) : this.mod(t)._move(this);
    }
    imodn(t) {
      return this.words[0] = this.modrn(t), this.length = 1, this.negative = 0, this;
    }
    mod(t) {
      return this._div(t, f.REM | f.EUCLID)[1];
    }
    modn(t) {
      return this.clone().imodn(t);
    }
    modrn(t) {
      _(D(t), "num", "smi");
      let l = this.remrn(t);
      return l < 0 && (t < 0 ? l -= t : l += t), l;
    }
    /*
     * Round Division
     */
    divRound(t) {
      const [l, B] = this.quorem(t);
      if (B.isZero())
        return l;
      const U = t.words[0] & 1;
      t.iushrn(1);
      const G = B.ucmp(t);
      return t.iushln(1), t.words[0] |= U, G < 0 || t.isOdd() && G === 0 ? l : this.negative ^ t.negative ? l.isubn(1) : l.iaddn(1);
    }
    /*
     * Exponentiation
     */
    ipow(t) {
      return this.pow(t)._move(this);
    }
    ipown(t) {
      return this.pown(t)._move(this);
    }
    pow(t) {
      _(s.isBN(t), "num", "bignum");
      let l = oe(t.words[t.length - 1]), B = new s(1);
      for (let U = t.length - 1; U >= 0; U--) {
        const G = t.words[U];
        for (let T = l - 1; T >= 0; T--)
          B = B.sqr(), G >> T & 1 && (B = B.mul(this));
        l = 26;
      }
      return B;
    }
    pown(t) {
      if (_(D(t), "num", "smi"), t < 0 && (t = -t), t === 0)
        return new s(1);
      if (t === 1)
        return this.clone();
      const l = oe(t);
      let B = this;
      for (let U = l - 2; U >= 0; U--)
        B = B.sqr(), t >> U & 1 && (B = B.mul(this));
      return B;
    }
    isqr() {
      return this.imul(this);
    }
    sqr() {
      return this.mul(this);
    }
    /*
     * Roots Engine
     */
    _rootrem(t, l) {
      if (_(t >>> 0 === t, "num", "uint32"), t === 0)
        throw new RangeError("Zeroth root.");
      if (~t & this.negative)
        throw new RangeError("Negative with even root.");
      if (this.ucmpn(1) <= 0)
        return [this.clone(), new s(0)];
      let B = new s(0), U = s.shift(1, this.bitLength() / t + 1 | 0), G, T;
      if (this.negative !== 0 && U.ineg(), t === 2)
        do
          B = U, U = this.quo(B), U.iadd(B), U.iushrn(1);
        while (U.ucmp(B) < 0);
      else
        do
          B = U, U = B.pown(t - 1), U = this.quo(U), G = B.muln(t - 1), U.iadd(G), U = U.quon(t);
        while (U.ucmp(B) < 0);
      return l && (U = B.pown(t), T = this.sub(U)), [B, T];
    }
    /*
     * Roots
     */
    rootrem(t) {
      return this._rootrem(t, 1);
    }
    iroot(t) {
      return this.root(t)._move(this);
    }
    root(t) {
      return this._rootrem(t, 0)[0];
    }
    isPower(t) {
      if (_(t >>> 0 === t, "num", "uint32"), t === 0 || ~t & this.negative)
        return !1;
      const [, l] = this.rootrem(t);
      return l.sign() === 0;
    }
    sqrtrem() {
      return this.rootrem(2);
    }
    isqrt() {
      return this.sqrt()._move(this);
    }
    sqrt() {
      return this.root(2);
    }
    isSquare() {
      return this.isPower(2);
    }
    /*
     * AND
     */
    iand(t) {
      _(s.isBN(t), "num", "bignum");
      let l = this, B = t;
      if (l === B)
        return l;
      if ((l.negative | B.negative) === 0)
        return l.iuand(B);
      if ((l.negative & B.negative) === 1)
        return l.iaddn(1), B.iaddn(1), l.iuor(B), l.isubn(1), B.isubn(1), l;
      l.negative !== 0 && ([l, B] = [B.clone(), l]);
      const U = l.bitLength();
      return B.iaddn(1), B.inotn(U), l.iuand(B), B.inotn(U), B.isubn(1), l._move(this);
    }
    iandn(t) {
      return _(D(t), "num", "smi"), (this.negative | t < 0) !== 0 ? this.iand(new s(t)) : (this.words[0] &= t, this.length = 1, this);
    }
    and(t) {
      return this.clone().iand(t);
    }
    andn(t) {
      return this.clone().iandn(t);
    }
    andrn(t) {
      if (_(D(t), "num", "smi"), (this.negative | t < 0) !== 0) {
        const l = this.iand(new s(t));
        if (l.length > 1)
          throw new RangeError("Number exceeds 26 bits.");
        return l.negative !== 0 ? -l.words[0] : l.words[0];
      }
      return this.words[0] & t;
    }
    /*
     * Unsigned AND
     */
    iuand(t) {
      _(s.isBN(t), "num", "bignum"), this.length = Math.min(this.length, t.length);
      for (let l = 0; l < this.length; l++)
        this.words[l] &= t.words[l];
      return this._strip();
    }
    iuandn(t) {
      return _(D(t), "num", "smi"), this.words[0] &= Math.abs(t), this.length = 1, this._normalize();
    }
    uand(t) {
      return this.clone().iuand(t);
    }
    uandn(t) {
      return this.clone().iuandn(t);
    }
    uandrn(t) {
      _(D(t), "num", "smi");
      const l = this.words[0] & Math.abs(t);
      return this.negative !== 0 ? -l | 0 : l;
    }
    /*
     * OR
     */
    ior(t) {
      _(s.isBN(t), "num", "bignum");
      let l = this, B = t;
      return l === B ? l : (l.negative | B.negative) === 0 ? l.iuor(B) : (l.negative & B.negative) === 1 ? (l.iaddn(1), B.iaddn(1), l.iuand(B), l.isubn(1), B.isubn(1), l) : (B = B.clone(), l.negative !== 0 && ([l, B] = [B, l]), B.iaddn(1), l.inotn(B.bitLength()), B.iuand(l), B.isubn(1), B._move(this));
    }
    iorn(t) {
      return _(D(t), "num", "smi"), (this.negative | t < 0) !== 0 ? this.ior(new s(t)) : (this.words[0] |= t, this);
    }
    or(t) {
      return this.clone().ior(t);
    }
    orn(t) {
      return this.clone().iorn(t);
    }
    /*
     * Unsigned OR
     */
    iuor(t) {
      _(s.isBN(t), "num", "bignum"), this._expand(t.length);
      for (let l = 0; l < t.length; l++)
        this.words[l] |= t.words[l];
      return this;
    }
    iuorn(t) {
      return _(D(t), "num", "smi"), this.words[0] |= Math.abs(t), this;
    }
    uor(t) {
      return this.clone().iuor(t);
    }
    uorn(t) {
      return this.clone().iuorn(t);
    }
    /*
     * XOR
     */
    ixor(t) {
      _(s.isBN(t), "num", "bignum");
      let l = this, B = t;
      return l === B ? (l.words[0] = 0, l.length = 1, l.negative = 0, l) : (l.negative | B.negative) === 0 ? l.iuxor(B) : (l.negative & B.negative) === 1 ? (l.iaddn(1), B.iaddn(1), l.iuxor(B), l.ineg(), B.isubn(1), l) : (l.negative !== 0 && ([l, B] = [B.clone(), l]), B.iaddn(1), l.iuxor(B), l.iaddn(1), l.ineg(), B.isubn(1), l._move(this));
    }
    ixorn(t) {
      return _(D(t), "num", "smi"), (this.negative | t < 0) !== 0 ? this.ixor(new s(t)) : (this.words[0] ^= t, this);
    }
    xor(t) {
      return this.clone().ixor(t);
    }
    xorn(t) {
      return this.clone().ixorn(t);
    }
    /*
     * Unsigned XOR
     */
    iuxor(t) {
      _(s.isBN(t), "num", "bignum");
      let l = this, B = t;
      l.length < B.length && ([l, B] = [B, l]);
      let U = 0;
      for (; U < B.length; U++)
        this.words[U] = l.words[U] ^ B.words[U];
      if (l !== this)
        for (this._alloc(l.length); U < l.length; U++)
          this.words[U] = l.words[U];
      return this.length = l.length, this._strip();
    }
    iuxorn(t) {
      return _(D(t), "num", "smi"), this.words[0] ^= Math.abs(t), this._normalize();
    }
    uxor(t) {
      return this.clone().iuxor(t);
    }
    uxorn(t) {
      return this.clone().iuxorn(t);
    }
    /*
     * NOT
     */
    inot() {
      return this.negative !== 0 ? this.ineg().isubn(1) : this.iaddn(1).ineg(), this;
    }
    not() {
      return this.clone().inot();
    }
    inotn(t) {
      _(t >>> 0 === t, "width", "uint32");
      const l = t % 26;
      let B = Math.ceil(t / 26), U = 0;
      for (this._expand(B), l > 0 && (B -= 1); U < B; U++)
        this.words[U] ^= 67108863;
      return l > 0 && (this.words[U] ^= (1 << l) - 1), this._strip();
    }
    notn(t) {
      return this.clone().inotn(t);
    }
    /*
     * Left Shift
     */
    ishl(t) {
      return _(s.isBN(t), "bits", "bignum"), _(t.bitLength() <= 32, "bits", "uint32"), this.ishln(t.toNumber());
    }
    ishln(t) {
      return this.iushln(t);
    }
    shl(t) {
      return this.clone().ishl(t);
    }
    shln(t) {
      return this.clone().ishln(t);
    }
    /*
     * Unsigned Left Shift
     */
    iushl(t) {
      return _(s.isBN(t), "bits", "bignum"), _(t.bitLength() <= 32, "bits", "uint32"), this.iushln(t.toNumber());
    }
    iushln(t) {
      _(t >>> 0 === t, "bits", "uint32");
      const l = t % 26, B = (t - l) / 26, U = (1 << l) - 1 << 26 - l;
      if (l !== 0) {
        let G = 0;
        for (let T = 0; T < this.length; T++) {
          const M = this.words[T] & U, $ = (this.words[T] | 0) - M << l;
          this.words[T] = $ | G, G = M >>> 26 - l;
        }
        G !== 0 && (this._alloc(this.length + 1), this.words[this.length++] = G);
      }
      if (B !== 0) {
        this._alloc(this.length + B);
        for (let G = this.length - 1; G >= 0; G--)
          this.words[G + B] = this.words[G];
        for (let G = 0; G < B; G++)
          this.words[G] = 0;
        this.length += B;
      }
      return this._strip();
    }
    ushl(t) {
      return this.clone().iushl(t);
    }
    ushln(t) {
      return this.clone().iushln(t);
    }
    /*
     * Right Shift Engine
     */
    _split(t, l) {
      const B = t % 26, U = Math.min((t - B) / 26, this.length), G = (1 << B) - 1;
      if (l) {
        l._alloc(U);
        for (let M = 0; M < U; M++)
          l.words[M] = this.words[M];
        l.length = U;
      }
      if (U !== 0) if (this.length > U) {
        this.length -= U;
        for (let M = 0; M < this.length; M++)
          this.words[M] = this.words[M + U];
      } else
        this.words[0] = 0, this.length = 1;
      let T = 0;
      if (B !== 0)
        for (let M = this.length - 1; M >= 0; M--) {
          const $ = this.words[M] | 0;
          this.words[M] = T << 26 - B | $ >>> B, T = $ & G;
        }
      return l && (T !== 0 ? (l._alloc(l.length + 1), l.words[l.length++] = T) : (l.length === 0 && (l.words[l.length++] = 0), l._strip())), this._strip();
    }
    /*
     * Right Shift
     */
    ishr(t) {
      return _(s.isBN(t), "bits", "bignum"), _(t.bitLength() <= 32, "bits", "uint32"), this.ishrn(t.toNumber());
    }
    ishrn(t) {
      return _(t >>> 0 === t, "bits", "uint32"), this.negative !== 0 ? (this.iaddn(1), this.iushrn(t), this.isubn(1), this) : this.iushrn(t);
    }
    shr(t) {
      return this.clone().ishr(t);
    }
    shrn(t) {
      return this.clone().ishrn(t);
    }
    /*
     * Unsigned Right Shift
     */
    iushr(t) {
      return _(s.isBN(t), "bits", "bignum"), _(t.bitLength() <= 32, "bits", "uint32"), this.iushrn(t.toNumber());
    }
    iushrn(t) {
      return _(t >>> 0 === t, "bits", "uint32"), this._split(t, null);
    }
    ushr(t) {
      return this.clone().iushr(t);
    }
    ushrn(t) {
      return this.clone().iushrn(t);
    }
    /*
     * Bit Manipulation
     */
    setn(t, l) {
      return _(t >>> 0 === t, "bit", "uint32"), this.negative !== 0 ? (this.iaddn(1), this.usetn(t, !l), this.isubn(1), this) : this.usetn(t, l);
    }
    usetn(t, l) {
      _(t >>> 0 === t, "bit", "uint32");
      const B = t % 26, U = (t - B) / 26;
      return this._expand(U + 1), l ? this.words[U] |= 1 << B : this.words[U] &= ~(1 << B), this._strip();
    }
    testn(t) {
      _(t >>> 0 === t, "bit", "uint32");
      const l = t % 26, B = (t - l) / 26;
      if (this.length <= B)
        return this.negative;
      const U = this.words[B], G = U >> l & 1;
      if (this.negative !== 0) {
        if (l > 0 && U & (1 << l) - 1)
          return G ^ 1;
        let T = B;
        for (; T--; )
          if (this.words[T] > 0)
            return G ^ 1;
      }
      return G;
    }
    utestn(t) {
      _(t >>> 0 === t, "bit", "uint32");
      const l = t % 26, B = (t - l) / 26;
      return this.length <= B ? 0 : this.words[B] >> l & 1;
    }
    imaskn(t) {
      return _(t >>> 0 === t, "bits", "uint32"), this.negative !== 0 && (this.iaddn(1), this.inotn(t + 1), this.ineg()), this.iumaskn(t);
    }
    maskn(t) {
      return this.clone().imaskn(t);
    }
    iumaskn(t) {
      _(t >>> 0 === t, "bits", "uint32");
      const l = t % 26;
      let B = (t - l) / 26;
      return this.length <= B ? this : (l !== 0 && (B += 1), this.length = Math.min(B, this.length), l !== 0 && (this.words[this.length - 1] &= (1 << l) - 1), this.length === 0 && (this.words[this.length++] = 0), this._strip());
    }
    umaskn(t) {
      return this.clone().iumaskn(t);
    }
    andln(t) {
      return this.words[0] & t;
    }
    bit(t) {
      return this.utestn(t);
    }
    bits(t, l) {
      _(t >>> 0 === t, "pos", "uint32"), _(l >>> 0 === l, "width", "uint32"), _(l <= 26, "width", "width");
      const B = t % 26, U = (t - B) / 26;
      if (U >= this.length)
        return 0;
      let G = this.words[U] >> B & (1 << l) - 1;
      if (B + l > 26 && U + 1 < this.length) {
        const T = B + l - 26, M = this.words[U + 1] & (1 << T) - 1;
        G |= M << 26 - B;
      }
      return G;
    }
    /*
     * Negation
     */
    ineg() {
      return this.isZero() || (this.negative ^= 1), this;
    }
    neg() {
      return this.clone().ineg();
    }
    iabs() {
      return this.negative = 0, this;
    }
    abs() {
      return this.clone().iabs();
    }
    /*
     * Comparison
     */
    cmp(t) {
      if (_(s.isBN(t), "num", "bignum"), this.negative !== t.negative)
        return t.negative - this.negative;
      const l = this.ucmp(t);
      return this.negative !== 0 ? -l | 0 : l;
    }
    cmpn(t) {
      _(D(t), "num", "smi");
      const l = t < 0 | 0;
      if (this.negative !== l)
        return l - this.negative;
      const B = this.ucmpn(t);
      return this.negative !== 0 ? -B | 0 : B;
    }
    eq(t) {
      return this.cmp(t) === 0;
    }
    eqn(t) {
      return this.cmpn(t) === 0;
    }
    gt(t) {
      return this.cmp(t) > 0;
    }
    gtn(t) {
      return this.cmpn(t) > 0;
    }
    gte(t) {
      return this.cmp(t) >= 0;
    }
    gten(t) {
      return this.cmpn(t) >= 0;
    }
    lt(t) {
      return this.cmp(t) < 0;
    }
    ltn(t) {
      return this.cmpn(t) < 0;
    }
    lte(t) {
      return this.cmp(t) <= 0;
    }
    lten(t) {
      return this.cmpn(t) <= 0;
    }
    sign() {
      return this.negative !== 0 ? -1 : this.length === 1 && this.words[0] === 0 ? 0 : 1;
    }
    isZero() {
      return this.length === 1 && this.words[0] === 0;
    }
    isNeg() {
      return this.negative !== 0;
    }
    isPos() {
      return this.negative === 0;
    }
    isOdd() {
      return (this.words[0] & 1) === 1;
    }
    isEven() {
      return (this.words[0] & 1) === 0;
    }
    /*
     * Unsigned Comparison
     */
    ucmp(t) {
      if (_(s.isBN(t), "num", "bignum"), this.length < t.length)
        return -1;
      if (this.length > t.length)
        return 1;
      for (let l = this.length - 1; l >= 0; l--) {
        const B = this.words[l] | 0, U = t.words[l] | 0;
        if (B !== U)
          return (B > U) - (B < U);
      }
      return 0;
    }
    ucmpn(t) {
      if (_(D(t), "num", "smi"), this.length > 1)
        return 1;
      const l = this.words[0] | 0;
      return t < 0 && (t = -t), (l > t) - (l < t);
    }
    /*
     * Number Theoretic Functions
     */
    legendre(t) {
      const l = a ? s.red(t) : s.mont(t);
      return this.toRed(l).redLegendre();
    }
    jacobi(t) {
      if (_(s.isBN(t), "num", "bignum"), t.isZero() || t.isEven())
        throw new Error("jacobi: `num` must be odd.");
      let l = this._cloneNormal(), B = t.clone(), U = 1;
      for (B.isNeg() && (l.isNeg() && (U = -1), B.ineg()), (l.isNeg() || l.ucmp(B) >= 0) && l.imod(B); !l.isZero(); ) {
        if (l._makeOdd() & 1) {
          const M = B.andln(7);
          (M === 3 || M === 5) && (U = -U);
        }
        l.ucmp(B) < 0 && ([l, B] = [B, l], l.andln(3) === 3 && B.andln(3) === 3 && (U = -U)), l._isub(l, B).iushrn(1);
        const T = B.andln(7);
        (T === 3 || T === 5) && (U = -U);
      }
      return B.cmpn(1) !== 0 ? 0 : U;
    }
    kronecker(t) {
      if (_(s.isBN(t), "num", "bignum"), this.isZero())
        return t.ucmpn(1) === 0 ? 1 : 0;
      if (t.isZero())
        return this.ucmpn(1) === 0 ? 1 : 0;
      if (((this.words[0] | t.words[0]) & 1) === 0)
        return 0;
      const l = this, B = t.clone(), U = B._makeOdd(), G = [0, 1, 0, -1, 0, -1, 0, 1];
      let T = l.jacobi(B);
      return U & 1 && (T *= G[l.andln(7)]), T | 0;
    }
    igcd(t) {
      return this.gcd(t)._move(this);
    }
    gcd(t) {
      if (_(s.isBN(t), "num", "bignum"), this.isZero())
        return t.abs();
      if (t.isZero())
        return this.abs();
      let l = this.clone(), B = t.clone();
      l.negative = 0, B.negative = 0;
      const U = l._factor2(B);
      for (U !== 0 && (l.iushrn(U), B.iushrn(U)); ; ) {
        l._makeOdd(), B._makeOdd();
        const G = l.ucmp(B);
        if (G < 0)
          [l, B] = [B, l];
        else if (G === 0 || B.ucmpn(1) === 0)
          break;
        l._isub(l, B);
      }
      return B.iushln(U);
    }
    ilcm(t) {
      return this.lcm(t)._move(this);
    }
    lcm(t) {
      return _(s.isBN(t), "num", "bignum"), this.isZero() || t.isZero() ? new s(0) : this.quo(this.gcd(t)).mul(t).iabs();
    }
    egcd(t) {
      if (_(s.isBN(t), "num", "bignum"), this.isZero())
        return [
          new s(0),
          new s(t.sign()),
          t.abs()
        ];
      if (t.isZero())
        return [
          new s(this.sign()),
          new s(0),
          this.abs()
        ];
      const l = this.clone(), B = t.clone();
      l.negative = 0, B.negative = 0;
      const U = new s(1), G = new s(0), T = new s(0), M = new s(1), $ = l._factor2(B);
      $ > 0 && (l.iushrn($), B.iushrn($));
      const r = l.clone(), x = B.clone();
      for (; !l.isZero(); ) {
        let O = l._makeOdd(), L = B._makeOdd();
        for (; O--; )
          (U.isOdd() || G.isOdd()) && (U.iadd(x), G.isub(r)), U.iushrn(1), G.iushrn(1);
        for (; L--; )
          (T.isOdd() || M.isOdd()) && (T.iadd(x), M.isub(r)), T.iushrn(1), M.iushrn(1);
        l.cmp(B) >= 0 ? (l.isub(B), U.isub(T), G.isub(M)) : (B.isub(l), T.isub(U), M.isub(G));
      }
      return this.negative !== 0 && T.ineg(), t.negative !== 0 && M.ineg(), [T, M, B.iushln($)];
    }
    iinvert(t) {
      return this.invert(t)._move(this);
    }
    invert(t) {
      if (_(s.isBN(t), "num", "bignum"), F(t.sign() > 0, "invert"), t.isOdd())
        return this._invertp(t);
      if (t.cmpn(1) === 0)
        throw new RangeError("Not invertible.");
      const [l, , B] = this.egcd(t);
      if (B.cmpn(1) !== 0)
        throw new RangeError("Not invertible.");
      return l.imod(t);
    }
    ifermat(t) {
      return this.fermat(t)._move(this);
    }
    fermat(t) {
      const l = a ? s.red(t) : s.mont(t);
      return this.toRed(l).redFermat().fromRed();
    }
    ipowm(t, l, B) {
      return this.powm(t, l, B)._move(this);
    }
    powm(t, l, B) {
      const U = !a && B ? s.mont(l) : s.red(l);
      return this.toRed(U).redPow(t).fromRed();
    }
    ipowmn(t, l, B) {
      return this.powmn(t, l, B)._move(this);
    }
    powmn(t, l, B) {
      const U = B ? s.mont(l) : s.red(l);
      return this.toRed(U).redPown(t).fromRed();
    }
    isqrtm(t) {
      return this.sqrtm(t)._move(this);
    }
    sqrtm(t) {
      _(s.isBN(t), "p", "bignum");
      let l;
      return t.andln(3) === 3 || t.andln(7) === 5 ? l = s.red(t) : l = s.mont(t), this.toRed(l).redSqrt().fromRed();
    }
    isqrtpq(t, l) {
      return this.sqrtpq(t, l)._move(this);
    }
    sqrtpq(t, l) {
      const B = this.sqrtm(t), U = this.sqrtm(l), [G, T] = t.egcd(l), M = U.mul(G).mul(t), $ = B.mul(T).mul(l), r = t.mul(l);
      return M.iadd($).imod(r);
    }
    /*
     * Primality Testing
     */
    isPrime(t, l, B) {
      return _(l >>> 0 === l, "reps", "uint32"), !(!this.isPrimeMR(t, l + 1, !0) || !this.isPrimeLucas(B));
    }
    isPrimeMR(t, l, B = !1) {
      _(l >>> 0 === l, "reps", "uint32"), _(l > 0, "reps", "integer"), _(typeof B == "boolean", "force2", "boolean");
      const U = this;
      if (U.cmpn(7) < 0)
        return U.cmpn(2) === 0 || U.cmpn(3) === 0 || U.cmpn(5) === 0;
      if (U.isEven())
        return !1;
      const G = U.subn(1), T = G.subn(2), M = G.zeroBits(), $ = G.ushrn(M), r = s.red(U), x = G.toRed(r), O = new s(1).toRed(r);
      e:
        for (let L = 0; L < l; L++) {
          let X;
          L === l - 1 && B ? X = new s(2) : (X = s.random(t, 0, T), X.iaddn(2));
          let P = X.toRed(r).redPow($);
          if (!(P.cmp(O) === 0 || P.cmp(x) === 0)) {
            for (let K = 1; K < M; K++) {
              if (P = P.redSqr(), P.cmp(x) === 0)
                continue e;
              if (P.cmp(O) === 0)
                return !1;
            }
            return !1;
          }
        }
      return !0;
    }
    isPrimeLucas(t = 0) {
      _(t >>> 0 === t, "limit", "uint32");
      const l = this;
      if (l.cmpn(1) <= 0)
        return !1;
      if (l.isEven())
        return l.cmpn(2) === 0;
      let B = 3;
      for (; ; ) {
        if (B > 1e4)
          throw new Error(`Cannot find (D/n) = -1 for ${l.toString(10)}.`);
        if (t !== 0 && B > t)
          return !1;
        const r = new s(B * B - 4).jacobi(l);
        if (r === -1)
          break;
        if (r === 0)
          return l.cmpn(B + 2) === 0;
        if (B === 40 && l.isSquare())
          return !1;
        B += 1;
      }
      const U = l.addn(1), G = U._makeOdd();
      let T = new s(2), M = new s(B);
      for (let $ = U.bitLength(); $ >= 0; $--)
        U.utestn($) ? (T = T.mul(M).isubn(B).imod(l), M = M.sqr().isubn(2).imod(l)) : (M = M.mul(T).isubn(B).imod(l), T = T.sqr().isubn(2).imod(l));
      if (T.cmpn(2) === 0 || T.cmp(l.subn(2)) === 0) {
        const $ = T.muln(B).imod(l), r = M.ushln(1).imod(l);
        if ($.cmp(r) === 0)
          return !0;
      }
      for (let $ = 0; $ < G - 1; $++) {
        if (T.isZero())
          return !0;
        if (T.cmpn(2) === 0)
          return !1;
        T = T.sqr().isubn(2).imod(l);
      }
      return !1;
    }
    /*
     * Twos Complement
     */
    toTwos(t) {
      return this.negative !== 0 ? this.abs().inotn(t).iaddn(1) : this.clone();
    }
    fromTwos(t) {
      return _(t >>> 0 === t, "width", "uint32"), F(t > 0, "width"), this.testn(t - 1) ? this.notn(t).iaddn(1).ineg() : this.clone();
    }
    /*
     * Reduction Context
     */
    toRed(t) {
      if (_(t instanceof J, "ctx", "reduction context"), this.red)
        throw new Error("Already in reduction context.");
      return t.convertTo(this);
    }
    fromRed() {
      return R(this.red, "fromRed"), this.red.convertFrom(this);
    }
    forceRed(t) {
      if (_(t instanceof J, "ctx", "reduction context"), this.red) {
        if (!t.m.eq(this.red.m) || t.mont !== this.red.mont)
          throw new Error("Already in reduction context.");
      } else
        F(this.negative === 0, "red"), F(this.ucmp(t.m) < 0, "red");
      return this.clone()._forceRed(t);
    }
    redIAdd(t) {
      return _(s.isBN(t), "num", "bignum"), R(this.red, "redIAdd"), this.red.iadd(this, t);
    }
    redAdd(t) {
      return _(s.isBN(t), "num", "bignum"), R(this.red, "redAdd"), this.red.add(this, t);
    }
    redIAddn(t) {
      return _(D(t), "num", "smi"), R(this.red, "redIAddn"), this.red.iaddn(this, t);
    }
    redAddn(t) {
      return _(D(t), "num", "smi"), R(this.red, "redAddn"), this.red.addn(this, t);
    }
    redISub(t) {
      return _(s.isBN(t), "num", "bignum"), R(this.red, "redISub"), this.red.isub(this, t);
    }
    redSub(t) {
      return _(s.isBN(t), "num", "bignum"), R(this.red, "redSub"), this.red.sub(this, t);
    }
    redISubn(t) {
      return _(D(t), "num", "smi"), R(this.red, "redISubn"), this.red.isubn(this, t);
    }
    redSubn(t) {
      return _(D(t), "num", "smi"), R(this.red, "redSubn"), this.red.subn(this, t);
    }
    redIMul(t) {
      return _(s.isBN(t), "num", "bignum"), R(this.red, "redIMul"), this.red.imul(this, t);
    }
    redMul(t) {
      return _(s.isBN(t), "num", "bignum"), R(this.red, "redMul"), this.red.mul(this, t);
    }
    redIMuln(t) {
      return _(D(t), "num", "smi"), R(this.red, "redIMuln"), this.red.imuln(this, t);
    }
    redMuln(t) {
      return _(D(t), "num", "smi"), R(this.red, "redMuln"), this.red.muln(this, t);
    }
    redIDiv(t) {
      return _(s.isBN(t), "num", "bignum"), R(this.red, "redIDiv"), this.red.idiv(this, t);
    }
    redDiv(t) {
      return _(s.isBN(t), "num", "bignum"), R(this.red, "redDiv"), this.red.div(this, t);
    }
    redIDivn(t) {
      return _(D(t), "num", "smi"), R(this.red, "redIDivn"), this.red.idivn(this, t);
    }
    redDivn(t) {
      return _(D(t), "num", "smi"), R(this.red, "redDivn"), this.red.divn(this, t);
    }
    redIPow(t) {
      return _(s.isBN(t), "num", "bignum"), R(this.red, "redIPow"), V(!t.red, "redIPow"), this.red.ipow(this, t);
    }
    redPow(t) {
      return _(s.isBN(t), "num", "bignum"), R(this.red, "redPow"), V(!t.red, "redPow"), this.red.pow(this, t);
    }
    redIPown(t) {
      return _(D(t), "num", "smi"), R(this.red, "redIPown"), this.red.ipown(this, t);
    }
    redPown(t) {
      return _(D(t), "num", "smi"), R(this.red, "redPown"), this.red.pown(this, t);
    }
    redISqr() {
      return R(this.red, "redISqr"), this.red.isqr(this);
    }
    redSqr() {
      return R(this.red, "redSqr"), this.red.sqr(this);
    }
    redISqrt() {
      return R(this.red, "redISqrt"), this.red.isqrt(this);
    }
    redSqrt() {
      return R(this.red, "redSqrt"), this.red.sqrt(this);
    }
    redIDivSqrt(t) {
      return R(this.red, "redIDivSqrt"), this.red.idivsqrt(this, t);
    }
    redDivSqrt(t) {
      return R(this.red, "redDivSqrt"), this.red.divsqrt(this, t);
    }
    redIsSquare() {
      return R(this.red, "redIsSquare"), this.red.isSquare(this);
    }
    redIShl(t) {
      return _(s.isBN(t), "num", "bignum"), R(this.red, "redIShl"), V(!t.red, "redIShl"), this.red.ishl(this, t);
    }
    redShl(t) {
      return _(s.isBN(t), "num", "bignum"), R(this.red, "redShl"), V(!t.red, "redShl"), this.red.shl(this, t);
    }
    redIShln(t) {
      return _(t >>> 0 === t, "num", "uint32"), R(this.red, "redIShln"), this.red.ishln(this, t);
    }
    redShln(t) {
      return _(t >>> 0 === t, "num", "uint32"), R(this.red, "redShln"), this.red.shln(this, t);
    }
    redINeg() {
      return R(this.red, "redINeg"), this.red.ineg(this);
    }
    redNeg() {
      return R(this.red, "redNeg"), this.red.neg(this);
    }
    redEq(t) {
      return _(s.isBN(t), "num", "bignum"), R(this.red, "redEq"), this.red.eq(this, t);
    }
    redEqn(t) {
      return _(D(t), "num", "smi"), R(this.red, "redEqn"), this.red.eqn(this, t);
    }
    redIsHigh() {
      return R(this.red, "redIsHigh"), this.red.isHigh(this);
    }
    redIsLow() {
      return R(this.red, "redIsLow"), this.red.isLow(this);
    }
    redIsOdd() {
      return R(this.red, "redIsOdd"), this.red.isOdd(this);
    }
    redIsEven() {
      return R(this.red, "redIsEven"), this.red.isEven(this);
    }
    redLegendre() {
      return R(this.red, "redLegendre"), this.red.legendre(this);
    }
    redJacobi() {
      return R(this.red, "redJacobi"), this.red.jacobi(this);
    }
    redKronecker() {
      return R(this.red, "redKronecker"), this.red.kronecker(this);
    }
    redIInvert() {
      return R(this.red, "redIInvert"), this.red.iinvert(this);
    }
    redInvert() {
      return R(this.red, "redInvert"), this.red.invert(this);
    }
    redIFermat() {
      return R(this.red, "redIFermat"), this.red.ifermat(this);
    }
    redFermat() {
      return R(this.red, "redFermat"), this.red.fermat(this);
    }
    /*
     * Internal
     */
    _move(t) {
      return t.words = this.words, t.length = this.length, t.negative = this.negative, t.red = this.red, t;
    }
    _alloc(t) {
      for (; this.words.length < t; )
        this.words.push(0);
      return this;
    }
    _expand(t) {
      for (this._alloc(t); this.length < t; )
        this.words[this.length++] = 0;
      return this;
    }
    _strip() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length -= 1;
      return this._normalize();
    }
    _normalize() {
      return q(this.length > 0), this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }
    _check() {
      return q(this.length > 0), q(this.length <= this.words.length), this.length === 1 ? (this.words[0] === 0 && q(this.negative === 0), this) : (q(this.words[this.length - 1] !== 0), this);
    }
    _invertp(t) {
      if (_(s.isBN(t), "p", "bignum"), F(t.sign() > 0, "invert"), q(t.isOdd()), t.cmpn(1) === 0)
        throw new RangeError("Not invertible.");
      const l = this.clone(), B = t.clone(), U = new s(1), G = new s(0);
      for ((l.isNeg() || l.ucmp(B) >= 0) && l.imod(B); !l.isZero(); ) {
        let T = l._makeOdd(), M = B._makeOdd();
        for (; T--; )
          U.isOdd() && U._iadd(U, t), U.iushrn(1);
        for (; M--; )
          G.isOdd() && G._iadd(G, t), G.iushrn(1);
        l.ucmp(B) >= 0 ? (l._isub(l, B), U.ucmp(G) < 0 ? (U._isub(G, U), U._isub(t, U)) : U._isub(U, G)) : (B._isub(B, l), G.ucmp(U) < 0 ? (G._isub(U, G), G._isub(t, G)) : G._isub(G, U));
      }
      if (B.cmpn(1) !== 0)
        throw new RangeError("Not invertible.");
      return q(G.negative === 0), q(G.ucmp(t) < 0), G;
    }
    _makeOdd() {
      const t = this.zeroBits();
      return t > 0 && this.iushrn(t), t;
    }
    _factor2(t) {
      if ((this.words[0] | t.words[0]) & 1)
        return 0;
      const l = Math.min(this.length, t.length);
      let B = 0;
      for (let U = 0; U < l; U++) {
        const G = y(this.words[U] | t.words[U]);
        if (B += G, G !== 26)
          break;
      }
      return B;
    }
    _cloneNormal() {
      return this.red ? this.fromRed() : this.clone();
    }
    _forceRed(t) {
      return this.red = t, this;
    }
    /*
     * Helpers
     */
    clone() {
      const t = new s();
      t.words = new Array(this.length);
      for (let l = 0; l < this.length; l++)
        t.words[l] = this.words[l];
      return t.length = this.length, t.negative = this.negative, t.red = this.red, t;
    }
    inject(t) {
      _(s.isBN(t), "num", "bignum"), this._alloc(t.length);
      for (let l = 0; l < t.length; l++)
        this.words[l] = t.words[l];
      return this.length = t.length, this.negative = t.negative, this.red = t.red, this;
    }
    set(t, l) {
      return this.fromNumber(t, l);
    }
    swap(t) {
      _(s.isBN(t), "num", "bignum");
      const l = this, B = t;
      return [l.words, B.words] = [B.words, l.words], [l.length, B.length] = [B.length, l.length], [l.negative, B.negative] = [B.negative, l.negative], [l.red, B.red] = [B.red, l.red], l;
    }
    reverse() {
      const t = this.negative;
      return this.fromBuffer(this.toBuffer("be"), "le"), this.negative = t, this;
    }
    byteLength() {
      return Math.ceil(this.bitLength() / 8);
    }
    bitLength() {
      const t = this.words[this.length - 1], l = oe(t);
      return (this.length - 1) * 26 + l;
    }
    zeroBits() {
      if (this.isZero() || this.isOdd())
        return 0;
      let t = 0;
      for (let l = 0; l < this.length; l++) {
        const B = y(this.words[l]);
        if (t += B, B !== 26)
          break;
      }
      return t;
    }
    isSafe() {
      return this.length <= 2 || this.length === 3 && this.words[2] === 1;
    }
    word(t) {
      return _(t >>> 0 === t, "pos", "uint32"), t >= this.length ? 0 : this.words[t];
    }
    [e]() {
      let t = "BN";
      return this.red && (t = "BN-R"), `<${t}: ${this.toString(10)}>`;
    }
    /*
     * Conversion
     */
    toNumber() {
      let t = this.words[0];
      if (this.length === 2)
        t += this.words[1] * 67108864;
      else if (this.length === 3 && this.words[2] === 1)
        t += 4503599627370496 + this.words[1] * 67108864;
      else if (this.length > 2)
        throw new RangeError("Number can only safely store up to 53 bits.");
      return this.negative !== 0 ? -t : t;
    }
    toDouble() {
      let t = 0;
      for (let l = this.length - 1; l >= 0; l--)
        t = t * 67108864 + this.words[l];
      return this.negative !== 0 ? -t : t;
    }
    valueOf() {
      return this.toDouble();
    }
    toBigInt() {
      if (!a)
        throw new Error("BigInt is not supported!");
      const t = BigInt(52), l = BigInt(26);
      let B = this.length - 1, U = BigInt(0);
      for (; B >= 1; B -= 2) {
        const G = this.words[B] * 67108864, T = this.words[B - 1];
        U = U << t | BigInt(G + T);
      }
      return B >= 0 && (U = U << l | BigInt(this.words[0])), this.negative !== 0 ? -U : U;
    }
    toBool() {
      return !this.isZero();
    }
    toString(t, l) {
      if (t = Z(t), l == null && (l = 0), l === 0 && (l = 1), _(t >>> 0 === t, "base", "uint32"), _(l >>> 0 === l, "padding", "uint32"), t < 2 || t > 36)
        throw new RangeError("Base ranges between 2 and 36.");
      if (this._check(), t === 16) {
        let M = "", $ = 0, r = 0;
        for (let x = 0; x < this.length; x++) {
          const O = this.words[x], L = ((O << $ | r) & 16777215).toString(16);
          r = O >>> 24 - $ & 16777215, r !== 0 || x !== this.length - 1 ? M = c[6 - L.length] + L + M : M = L + M, $ += 2, $ >= 26 && ($ -= 26, x -= 1);
        }
        for (r !== 0 && (M = r.toString(16) + M); M.length % l !== 0; )
          M = "0" + M;
        return this.negative !== 0 && (M = "-" + M), M;
      }
      const B = d[t - 1], U = w[t - 1], G = this.clone();
      let T = "";
      for (G.negative = 0; !G.isZero(); ) {
        const M = G.remrn(U).toString(t);
        G.iquon(U), G.isZero() ? T = M + T : T = c[B - M.length] + M + T;
      }
      for (this.isZero() && (T = "0"); T.length % l !== 0; )
        T = "0" + T;
      return this.negative !== 0 && (T = "-" + T), T;
    }
    toJSON() {
      return this.toString(16, 2);
    }
    toArray(t, l) {
      return this.toArrayLike(Array, t, l);
    }
    toBuffer(t, l) {
      return this.toArrayLike(k, t, l);
    }
    toArrayLike(t, l, B) {
      l == null && (l = "be"), B == null && (B = 0), _(typeof t == "function", "ArrayType", "function"), _(l === "be" || l === "le", "endian", "endianness"), _(B >>> 0 === B, "length", "uint32"), this._check();
      const U = this.byteLength(), G = B || Math.max(1, U);
      if (U > G)
        throw new RangeError("Byte array longer than desired length.");
      const T = Q(t, G);
      if (l === "be") {
        let M = T.length - 1, $ = 0;
        for (let r = 0; r < this.length; r++) {
          const x = (r & 3) << 1, O = this.words[r] << x | $;
          T[M--] = O & 255, M >= 0 && (T[M--] = O >>> 8 & 255), M >= 0 && (T[M--] = O >>> 16 & 255), x === 6 ? (M >= 0 && (T[M--] = O >>> 24 & 255), $ = 0) : $ = O >>> 24;
        }
        if (M >= 0) {
          for (T[M--] = $; M >= 0; )
            T[M--] = 0;
          $ = 0;
        }
        q($ === 0);
      } else {
        let M = 0, $ = 0;
        for (let r = 0; r < this.length; r++) {
          const x = (r & 3) << 1, O = this.words[r] << x | $;
          T[M++] = O & 255, M < T.length && (T[M++] = O >>> 8 & 255), M < T.length && (T[M++] = O >>> 16 & 255), x === 6 ? (M < T.length && (T[M++] = O >>> 24 & 255), $ = 0) : $ = O >>> 24;
        }
        if (M < T.length) {
          for (T[M++] = $; M < T.length; )
            T[M++] = 0;
          $ = 0;
        }
        q($ === 0);
      }
      return T;
    }
    encode(t, l) {
      return this.toBuffer(t, l);
    }
    /*
     * Instantiation
     */
    of(t, l) {
      return this.fromNumber(t, l);
    }
    fromNumber(t, l) {
      l == null && (l = "be"), _(ae(t), "num", "integer"), _(l === "be" || l === "le", "endian", "endianness");
      const B = t < 0 | 0;
      return B && (t = -t), t < 67108864 ? (this.words[0] = t & 67108863, this.length = 1) : t < 4503599627370496 ? (this.words = [
        t & 67108863,
        t / 67108864 & 67108863
      ], this.length = 2) : (this.words = [
        t & 67108863,
        t / 67108864 & 67108863,
        1
      ], this.length = 3), this.negative = B, l === "le" && this.reverse(), this;
    }
    fromDouble(t, l) {
      l == null && (l = "be"), _(typeof t == "number", "num", "double"), _(l === "be" || l === "le", "endian", "endianness"), isFinite(t) || (t = 0);
      const B = t <= -1 | 0;
      for (t < 0 && (t = -t), t = Math.floor(t), this.words = []; t > 0; ) {
        const U = t % 67108864, G = (t - U) / 67108864;
        this.words.push(U), t = G;
      }
      return this.words.length === 0 && this.words.push(0), this.length = this.words.length, this.negative = B, l === "le" && this.reverse(), this;
    }
    fromBigInt(t, l) {
      if (l == null && (l = "be"), _(typeof t == "bigint", "num", "bigint"), _(l === "be" || l === "le", "endian", "endianness"), !a)
        throw new Error("BigInt is not supported!");
      const B = t < BigInt(0) | 0;
      return this._fromHex(t.toString(16), B), this.negative = B, l === "le" && this.reverse(), this;
    }
    fromBool(t) {
      return _(typeof t == "boolean", "value", "boolean"), this.words[0] = t | 0, this.length = 1, this.negative = 0, this;
    }
    fromString(t, l, B) {
      if ((l === "le" || l === "be") && ([l, B] = [B, l]), l = Z(l), B == null && (B = "be"), _(typeof t == "string", "string", "string"), _(l >>> 0 === l, "base", "uint32"), _(B === "be" || B === "le", "endian", "endianness"), l < 2 || l > 36)
        throw new Error("Base ranges between 2 and 36.");
      t = t.replace(/\s+/g, "");
      let U = 0;
      return t.length > 0 && t.charCodeAt(0) === 45 && (U = 1), l === 16 ? this._fromHex(t, U) : this._fromBase(t, l, U), this.negative = U, this._normalize(), B === "le" && this.reverse(), this;
    }
    _fromHex(t, l) {
      this.length = Math.max(2, Math.ceil((t.length - l) / 6)), this.words = new Array(this.length);
      for (let T = 0; T < this.length; T++)
        this.words[T] = 0;
      let B = 0, U = t.length - 6, G = 0;
      for (; U >= l; U -= 6) {
        const T = Y(t, U, U + 6);
        this.words[G] |= T << B & 67108863, this.words[G + 1] |= T >>> 26 - B & 4194303, B += 24, B >= 26 && (B -= 26, G += 1);
      }
      if (U + 6 !== l) {
        const T = Y(t, l, U + 6);
        this.words[G] |= T << B & 67108863, this.words[G + 1] |= T >>> 26 - B & 4194303;
      }
      return this._strip();
    }
    _fromBase(t, l, B) {
      this.words[0] = 0, this.length = 1, this.negative = 0;
      let U = 0, G = 1;
      for (; G <= 67108863; G *= l)
        U += 1;
      U -= 1, G = G / l | 0;
      const T = t.length - B, M = T % U, $ = Math.min(T, T - M) + B;
      let r = B;
      for (; r < $; r += U) {
        const x = he(t, r, r + U, l);
        this.imuln(G), this._iaddn(x);
      }
      if (M !== 0) {
        const x = Math.pow(l, M), O = he(t, r, t.length, l);
        this.imuln(x), this._iaddn(O);
      }
      return this;
    }
    fromJSON(t) {
      if (s.isBN(t))
        return t.red ? t.fromRed() : t.clone();
      if (Array.isArray(t)) {
        for (const l of t)
          _(typeof l == "string", "chunk", "string");
        t = t.join("");
      }
      return this.fromString(t, 16);
    }
    fromBN(t) {
      return this.inject(t);
    }
    fromArray(t, l) {
      return _(Array.isArray(t), "data", "array"), this.fromArrayLike(t, l);
    }
    fromBuffer(t, l) {
      return _(k.isBuffer(t), "data", "buffer"), this.fromArrayLike(t, l);
    }
    fromArrayLike(t, l) {
      if (l == null && (l = "be"), _(t && t.length >>> 0 === t.length, "data", "array-like"), _(l === "be" || l === "le", "endian", "endianness"), t.length === 0)
        return this.words[0] = 0, this.length = 1, this.negative = 0, this;
      this.length = Math.max(2, Math.ceil(t.length / 3)), this.words = new Array(this.length), this.negative = 0;
      for (let M = 0; M < this.length; M++)
        this.words[M] = 0;
      const B = t.length % 3;
      let U = 0, G = 0, T = 0;
      if (l === "be") {
        for (let M = t.length - 1; M >= 2; M -= 3) {
          const $ = t[M] | t[M - 1] << 8 | t[M - 2] << 16;
          this.words[G] |= $ << U & 67108863, this.words[G + 1] = $ >>> 26 - U & 67108863, U += 24, U >= 26 && (U -= 26, G += 1);
        }
        switch (B) {
          case 2:
            T = t[1] | t[0] << 8;
            break;
          case 1:
            T = t[0];
            break;
        }
      } else {
        const M = t.length - B;
        for (let $ = 0; $ < M; $ += 3) {
          const r = t[$] | t[$ + 1] << 8 | t[$ + 2] << 16;
          this.words[G] |= r << U & 67108863, this.words[G + 1] = r >>> 26 - U & 67108863, U += 24, U >= 26 && (U -= 26, G += 1);
        }
        switch (B) {
          case 2:
            T = t[M] | t[M + 1] << 8;
            break;
          case 1:
            T = t[M];
            break;
        }
      }
      return B > 0 && (this.words[G] |= T << U & 67108863, this.words[G + 1] = T >>> 26 - U & 67108863), this._strip();
    }
    decode(t, l) {
      return this.fromBuffer(t, l);
    }
    from(t, l, B) {
      if (t == null)
        return this;
      if ((l === "le" || l === "be") && ([l, B] = [B, l]), typeof t == "number")
        return this.fromNumber(t, B);
      if (typeof t == "bigint")
        return this.fromBigInt(t, B);
      if (typeof t == "string")
        return this.fromString(t, l, B);
      if (typeof t == "object") {
        if (s.isBN(t))
          return this.fromBN(t, B);
        if (t.length >>> 0 === t.length)
          return this.fromArrayLike(t, B);
      }
      if (typeof t == "boolean")
        return this.fromBool(t);
      throw new TypeError("Non-numeric object passed to BN.");
    }
    /*
     * Static Methods
     */
    static min(...t) {
      let l = null;
      for (const B of t)
        _(s.isBN(B), "num", "bignum"), (!l || B.cmp(l) < 0) && (l = B);
      return l || new s(0);
    }
    static max(...t) {
      let l = null;
      for (const B of t)
        _(s.isBN(B), "num", "bignum"), (!l || B.cmp(l) > 0) && (l = B);
      return l || new s(0);
    }
    static cmp(t, l) {
      return _(s.isBN(t), "a", "bignum"), t.cmp(l);
    }
    static ucmp(t, l) {
      return _(s.isBN(t), "a", "bignum"), t.ucmp(l);
    }
    static red(t) {
      return new J(t);
    }
    static barrett(t) {
      return new N(t);
    }
    static mont(t) {
      return new z(t);
    }
    static _prime(t) {
      if (g[t])
        return g[t];
      let l;
      if (t === "p192")
        l = new v();
      else if (t === "p224")
        l = new b();
      else if (t === "p521")
        l = new h();
      else if (t === "k256")
        l = new o();
      else if (t === "p251")
        l = new S();
      else if (t === "p25519")
        l = new H();
      else if (t === "p448")
        l = new j();
      else
        throw new Error(`Unknown prime: "${t}".`);
      return g[t] = l, l;
    }
    static prime(t) {
      return s._prime(t).p.clone();
    }
    static pow(t, l) {
      return t === 2 ? s.shift(1, l) : new s().fromNumber(t).pown(l);
    }
    static shift(t, l) {
      return t === 1 ? new s(0).usetn(l, 1) : new s().fromNumber(t).ishln(l);
    }
    static mask(t) {
      return s.shift(1, t).isubn(1);
    }
    static randomBits(t, l) {
      if (_(t != null, "rng", "rng"), _(l >>> 0 === l, "bits", "uint32"), typeof t == "object") {
        _(typeof t.randomBytes == "function", "rng", "rng");
        const U = l + 7 >>> 3, G = U * 8, T = t.randomBytes(U);
        if (_(k.isBuffer(T), "bytes", "buffer"), T.length !== U)
          throw new RangeError("Invalid number of bytes returned from RNG.");
        const M = s.fromBuffer(T);
        return G > l && M.iushrn(G - l), M;
      }
      _(typeof t == "function", "rng", "rng");
      const B = t(l);
      if (_(s.isBN(B), "num", "bignum"), F(B.negative === 0, "RNG"), V(!B.red, "RNG"), B.bitLength() > l)
        throw new RangeError("Invalid number of bits returned from RNG.");
      return B;
    }
    static random(t, l, B) {
      if (l = s.cast(l, 16), B = s.cast(B, 16), l.cmp(B) > 0)
        throw new RangeError("Minimum cannot be greater than maximum.");
      const U = B.sub(l).iabs(), G = U.bitLength();
      if (G === 0)
        return l.clone();
      for (; ; ) {
        const T = s.randomBits(t, G);
        if (!(T.cmp(U) >= 0))
          return T.iadd(l), T;
      }
    }
    static of(t, l) {
      return new s().of(t, l);
    }
    static fromNumber(t, l) {
      return new s().fromNumber(t, l);
    }
    static fromDouble(t, l) {
      return new s().fromDouble(t, l);
    }
    static fromBigInt(t, l) {
      return new s().fromBigInt(t, l);
    }
    static fromBool(t) {
      return new s().fromBool(t);
    }
    static fromString(t, l, B) {
      return new s().fromString(t, l, B);
    }
    static fromJSON(t) {
      return new s().fromJSON(t);
    }
    static fromBN(t) {
      return new s().fromBN(t);
    }
    static fromArray(t, l) {
      return new s().fromArray(t, l);
    }
    static fromBuffer(t, l) {
      return new s().fromBuffer(t, l);
    }
    static fromArrayLike(t, l) {
      return new s().fromArrayLike(t, l);
    }
    static decode(t, l) {
      return new s().decode(t, l);
    }
    static from(t, l, B) {
      return new s().from(t, l, B);
    }
    static cast(t, l, B) {
      return s.isBN(t) ? t : new s(t, l, B);
    }
    static isBN(t) {
      return t instanceof s;
    }
  }
  s.BN = s, s.wordSize = 26, s.native = 0;
  class i {
    constructor(t, l) {
      this.name = t, this.p = new s(l, 16), this.n = this.p.bitLength(), this.k = s.shift(1, this.n).isub(this.p), this.lo = this.p.clone(), this.one = this.p.clone();
    }
    ireduce(t) {
      const l = t.negative !== 0;
      let B = t.bitLength();
      for (q(B <= this.n * 2), t.negative = 0; B > this.n; )
        this.split(t, this.lo), this.imulK(t), t._iadd(t, this.lo), B = t.bitLength();
      const U = B < this.n ? -1 : t.ucmp(this.p);
      return U === 0 ? (t.words[0] = 0, t.length = 1) : U > 0 && t._isub(t, this.p), l && !t.isZero() && t._isub(this.p, t), t;
    }
    split(t, l) {
      t._split(this.n, l);
    }
    imulK(t) {
      return t.imul(this.k);
    }
    pm2(t) {
      throw new Error("Not implemented.");
    }
    fermat(t) {
      return this.pm2(t);
    }
  }
  class p extends i {
    constructor(t, l) {
      super(t, l);
    }
    pm3d4(t) {
      throw new Error("Not implemented.");
    }
    pp1d4(t) {
      throw new Error("Not implemented.");
    }
    sqrt(t) {
      const { red: l } = t, B = this.pp1d4(t);
      if (!l.sqr(B).eq(t))
        throw new ue(B);
      return B;
    }
    divsqrt(t, l) {
      const { red: B } = t, U = B.sqr(t), G = B.mul(U, t), T = B.mul(G, U), M = B.mul(B.sqr(l), l), $ = this.pm3d4(B.mul(T, M)), r = B.mul(B.mul(G, l), $);
      if (B.mul(l, B.sqr(r)).eq(t))
        return r;
      throw new ue(r);
    }
  }
  class m extends i {
    constructor(t, l, B) {
      super(t, l), this.sm1 = new s(B, 16);
    }
    pm5d8(t) {
      throw new Error("Not implemented.");
    }
    pp3d8(t) {
      throw new Error("Not implemented.");
    }
    sqrt(t) {
      const { red: l } = t, B = this.sm1._forceRed(l), U = this.pp3d8(t);
      if (l.sqr(U).eq(t))
        return U;
      const G = l.mul(U, B);
      if (l.sqr(G).eq(t))
        return G;
      throw new ue(U);
    }
    divsqrt(t, l) {
      const { red: B } = t, U = this.sm1._forceRed(B), G = B.mul(B.sqr(l), l), T = B.mul(B.sqr(G), l), M = this.pm5d8(B.mul(t, T)), $ = B.mul(B.mul(t, G), M), r = B.mul(l, B.sqr($));
      if (r.eq(t))
        return $;
      const x = B.ineg(r);
      if (x.eq(t))
        return B.mul($, U);
      throw x.eq(B.mul(t, U)) ? new ue(B.mul($, U)) : new ue($);
    }
  }
  class E extends i {
    constructor(t, l, B) {
      super(t, l), this.g = new s(B, 16), this.z = this.p.subn(1).zeroBits();
    }
    powS(t) {
      throw new Error("Not implemented.");
    }
    powE(t) {
      throw new Error("Not implemented.");
    }
    sqrt(t) {
      const { red: l } = t;
      switch (l.jacobi(t)) {
        case -1:
          throw new ue(t);
        case 0:
          return t.clone();
      }
      let B = this.g._forceRed(l), U = this.powE(t), G = this.powS(t), T = this.z;
      for (; ; ) {
        let M = G, $ = 0;
        for (; M.cmpn(1) !== 0 && $ < T; )
          M = l.sqr(M), $ += 1;
        if ($ === 0)
          break;
        q($ < T), M = l.sqrn(B, T - $ - 1), B = l.sqr(M), U = l.mul(U, M), G = l.mul(G, B), T = $;
      }
      return U;
    }
    divsqrt(t, l) {
      const { red: B } = t;
      if (l.isZero())
        throw new ue(l);
      return this.sqrt(B.div(t, l));
    }
  }
  class v extends p {
    constructor() {
      super("p192", "ffffffff ffffffff ffffffff fffffffeffffffff ffffffff");
    }
    imulK(t) {
      const l = this.one.inject(t);
      return t.iushln(64)._iadd(t, l);
    }
    core(t) {
      const { red: l } = t, B = l.sqrnmul(t, 1, t), U = l.sqrnmul(B, 1, t), G = l.sqrnmul(U, 3, U), T = l.sqrnmul(G, 6, G), M = l.sqrnmul(T, 12, T), $ = l.sqrnmul(M, 6, G), r = l.sqrnmul($, 1, t), x = l.sqrnmul(r, 31, r), O = l.sqrnmul(x, 62, x), L = l.sqrnmul(O, 3, U), X = l.sqrn(L, 1);
      return l.sqrnmul(X, 62, x);
    }
    pm3d4(t) {
      return this.core(t);
    }
    pm2(t) {
      const { red: l } = t, B = this.core(t), U = l.sqrn(B, 1);
      return l.sqrnmul(U, 1, t);
    }
    pp1d4(t) {
      const { red: l } = t, B = l.sqrnmul(t, 1, t), U = l.sqrnmul(B, 2, B), G = l.sqrnmul(U, 4, U), T = l.sqrnmul(G, 8, G), M = l.sqrnmul(T, 16, T), $ = l.sqrnmul(M, 32, M), r = l.sqrnmul($, 64, $);
      return l.sqrn(r, 62);
    }
  }
  class b extends E {
    constructor() {
      super(
        "p224",
        "ffffffff ffffffff ffffffff ffffffff00000000 00000000 00000001",
        "6a0fec67 8598a792 0c55b2d4 0b2d6ffbbea3d8ce f3fb3632 dc691b74"
      );
    }
    imulK(t) {
      const l = this.one.inject(t);
      return t.iushln(96)._isub(t, l);
    }
    powS(t) {
      const { red: l } = t, B = l.sqrnmul(t, 1, t), U = l.sqrnmul(B, 2, B), G = l.sqrnmul(U, 4, U), T = l.sqrnmul(G, 8, G), M = l.sqrnmul(T, 16, T), $ = l.sqrnmul(M, 32, M);
      return l.sqrnmul($, 64, $);
    }
    powE(t) {
      const { red: l } = t;
      return l.sqrn(t, 127);
    }
    pm2(t) {
      const { red: l } = t, B = l.sqrnmul(t, 1, t), U = l.sqrnmul(B, 1, t), G = l.sqrnmul(U, 3, U), T = l.sqrnmul(G, 6, G), M = l.sqrnmul(T, 12, T), $ = l.sqrnmul(M, 24, M), r = l.sqrnmul($, 48, $), x = l.sqrnmul(r, 24, M), O = l.sqrnmul(x, 6, G), L = l.sqrnmul(O, 1, t), X = l.sqrn(L, 1);
      return l.sqrnmul(X, 96, r);
    }
  }
  class h extends p {
    constructor() {
      super("p521", "000001ff ffffffff ffffffff ffffffffffffffff ffffffff ffffffff ffffffffffffffff ffffffff ffffffff ffffffffffffffff ffffffff ffffffff ffffffffffffffff");
    }
    imulK(t) {
      return t;
    }
    core(t) {
      const { red: l } = t, B = l.sqrnmul(t, 1, t), U = l.sqrnmul(B, 1, t), G = l.sqrnmul(U, 3, U), T = l.sqrnmul(G, 1, t), M = l.sqrnmul(T, 1, t), $ = l.sqrnmul(M, 8, M), r = l.sqrnmul($, 16, $), x = l.sqrnmul(r, 32, r), O = l.sqrnmul(x, 64, x), L = l.sqrnmul(O, 128, O), X = l.sqrnmul(L, 256, L);
      return l.sqrnmul(X, 7, T);
    }
    pm3d4(t) {
      return this.core(t);
    }
    pm2(t) {
      const { red: l } = t, B = this.core(t), U = l.sqrn(B, 1);
      return l.sqrnmul(U, 1, t);
    }
    pp1d4(t) {
      const { red: l } = t;
      return l.sqrn(t, 519);
    }
  }
  class o extends p {
    constructor() {
      super("k256", "ffffffff ffffffff ffffffff ffffffffffffffff ffffffff fffffffe fffffc2f");
    }
    split(t, l) {
      const U = Math.min(t.length, 9);
      l._alloc(U + 1);
      for (let M = 0; M < U; M++)
        l.words[M] = t.words[M];
      if (l.length = U, t.length <= 9) {
        l._strip(), t.words[0] = 0, t.length = 1;
        return;
      }
      let G = t.words[9], T = 10;
      for (l.words[l.length++] = G & 4194303, l._strip(); T < t.length; T++) {
        const M = t.words[T] | 0;
        t.words[T - 10] = (M & 4194303) << 4 | G >>> 22, G = M;
      }
      G >>>= 22, t.words[T - 10] = G, G === 0 && t.length > 10 ? t.length -= 10 : t.length -= 9, t._strip();
    }
    imulK(t) {
      t._expand(t.length + 2);
      let l = 0;
      for (let B = 0; B < t.length; B++) {
        const U = t.words[B];
        l += U * 977, t.words[B] = l & 67108863, l = U * 64 + Math.floor(l / 67108864);
      }
      return t.words[t.length - 1] === 0 && (t.length -= 1, t.words[t.length - 1] === 0 && (t.length -= 1)), t;
    }
    core(t, l) {
      const { red: B } = t, U = B.sqrnmul(l, 1, t), G = B.sqrnmul(U, 3, U), T = B.sqrnmul(G, 3, U), M = B.sqrnmul(T, 2, l), $ = B.sqrnmul(M, 11, M), r = B.sqrnmul($, 22, $), x = B.sqrnmul(r, 44, r), O = B.sqrnmul(x, 88, x), L = B.sqrnmul(O, 44, r), X = B.sqrnmul(L, 3, U), P = B.sqrn(X, 1), K = B.sqrnmul(P, 22, $);
      return B.sqrn(K, 4);
    }
    pm3d4(t) {
      const { red: l } = t, B = l.sqrnmul(t, 1, t), U = this.core(t, B), G = l.sqrnmul(U, 1, t), T = l.sqrn(G, 1);
      return l.sqrnmul(T, 2, B);
    }
    pm2(t) {
      const { red: l } = t, B = l.sqrnmul(t, 1, t), U = this.core(t, B), G = l.sqrnmul(U, 1, t), T = l.sqrn(G, 1), M = l.sqrnmul(T, 2, B), $ = l.sqrn(M, 1);
      return l.sqrnmul($, 1, t);
    }
    pp1d4(t) {
      const { red: l } = t, B = l.sqrnmul(t, 1, t), U = this.core(t, B), G = l.sqrnmul(U, 2, B);
      return l.sqrn(G, 2);
    }
  }
  class S extends p {
    constructor() {
      super("p251", "07ffffff ffffffff ffffffff ffffffffffffffff ffffffff ffffffff fffffff7");
    }
    imulK(t) {
      if (t.isZero())
        return t;
      let l = 0;
      for (let B = 0; B < t.length; B++) {
        const U = t.words[B] * 9 + l;
        l = U >>> 26, t.words[B] = U & 67108863;
      }
      return l !== 0 && (t._alloc(t.length + 1), t.words[t.length++] = l), t;
    }
    core(t) {
      const { red: l } = t, B = l.sqrnmul(t, 1, t), U = l.sqrnmul(B, 1, t), G = l.sqrnmul(U, 3, U), T = l.sqrnmul(G, 6, G), M = l.sqrnmul(T, 12, T), $ = l.sqrnmul(M, 24, M), r = l.sqrnmul($, 48, $), x = l.sqrnmul(r, 96, r), O = l.sqrnmul(x, 48, $), L = l.sqrnmul(O, 6, G);
      return l.sqrnmul(L, 1, t);
    }
    pm3d4(t) {
      const { red: l } = t, B = this.core(t), U = l.sqrn(B, 1);
      return l.sqrnmul(U, 1, t);
    }
    pm2(t) {
      const { red: l } = t, B = this.core(t), U = l.sqrn(B, 1), G = l.sqrnmul(U, 1, t), T = l.sqrn(G, 1);
      return l.sqrnmul(T, 1, t);
    }
    pp1d4(t) {
      const { red: l } = t, B = this.core(t), U = l.sqrnmul(B, 1, t);
      return l.sqrn(U, 1);
    }
  }
  class H extends m {
    constructor() {
      super(
        "p25519",
        "7fffffff ffffffff ffffffff ffffffffffffffff ffffffff ffffffff ffffffed",
        "2b832480 4fc1df0b 2b4d0099 3dfbd7a72f431806 ad2fe478 c4ee1b27 4a0ea0b0"
      );
    }
    imulK(t) {
      let l = 0;
      for (let B = 0; B < t.length; B++) {
        const U = t.words[B] * 19 + l;
        l = U >>> 26, t.words[B] = U & 67108863;
      }
      return l !== 0 && (t._alloc(t.length + 1), t.words[t.length++] = l), t;
    }
    core(t, l) {
      const { red: B } = t, U = B.sqrnmul(l, 2, l), G = B.sqrnmul(U, 1, t), T = B.sqrnmul(G, 5, G), M = B.sqrnmul(T, 10, T), $ = B.sqrnmul(M, 20, M), r = B.sqrnmul($, 10, T), x = B.sqrnmul(r, 50, r), O = B.sqrnmul(x, 100, x);
      return B.sqrnmul(O, 50, r);
    }
    pm5d8(t) {
      const { red: l } = t, B = l.sqrnmul(t, 1, t), U = this.core(t, B), G = l.sqrn(U, 1);
      return l.sqrnmul(G, 1, t);
    }
    pm2(t) {
      const { red: l } = t, B = l.sqrnmul(t, 1, t), U = this.core(t, B), G = l.sqrn(U, 1), T = l.sqrnmul(G, 1, t), M = l.sqrn(T, 1);
      return l.sqrnmul(M, 2, B);
    }
    pp3d8(t) {
      const { red: l } = t, B = l.sqrnmul(t, 1, t), U = this.core(t, B), G = l.sqrnmul(U, 1, t);
      return l.sqrn(G, 1);
    }
  }
  class j extends p {
    constructor() {
      super("p448", "ffffffff ffffffff ffffffff ffffffffffffffff ffffffff fffffffe ffffffffffffffff ffffffff ffffffff ffffffffffffffff ffffffff");
    }
    imulK(t) {
      const l = this.one.inject(t);
      return t.iushln(224)._iadd(t, l);
    }
    core(t, l) {
      const { red: B } = t, U = B.sqrnmul(l, 1, t), G = B.sqrnmul(U, 3, U), T = B.sqrnmul(G, 3, U), M = B.sqrnmul(T, 2, l), $ = B.sqrnmul(M, 11, M), r = B.sqrnmul($, 22, $), x = B.sqrnmul(r, 44, r), O = B.sqrnmul(x, 88, x), L = B.sqrnmul(O, 44, r);
      return B.sqrnmul(L, 2, l);
    }
    pm3d4(t) {
      const { red: l } = t, B = l.sqrnmul(t, 1, t), U = this.core(t, B), G = l.sqrnmul(U, 1, t), T = l.sqrn(G, 1);
      return l.sqrnmul(T, 222, U);
    }
    pm2(t) {
      const { red: l } = t, B = this.pm3d4(t), U = l.sqrn(B, 1);
      return l.sqrnmul(U, 1, t);
    }
    pp1d4(t) {
      const { red: l } = t, B = l.sqrnmul(t, 1, t), U = this.core(t, B), G = l.sqrnmul(U, 2, B);
      return l.sqrn(G, 222);
    }
  }
  class J {
    constructor(t) {
      let l = null;
      typeof t == "string" && (l = s._prime(t), t = l.p), _(s.isBN(t), "m", "bignum"), V(!t.red, "reduction"), F(t.sign() > 0, "reduction"), this.m = t, this.prime = l, this.mb = null, this.sm1 = null;
    }
    _verify1(t) {
      F(t.negative === 0, "red"), R(t.red != null, "red");
    }
    _verify2(t, l) {
      F((t.negative | l.negative) === 0, "red"), R(t.red != null && t.red === l.red, "red");
    }
    get mont() {
      return !1;
    }
    precompute() {
      if (this.sm1 === null && this.m.andln(7) === 5)
        if (this.prime)
          this.sm1 = this.prime.sm1.clone()._forceRed(this);
        else {
          const t = new s(2).toRed(this), l = this.m.subn(1).iushrn(2);
          this.sm1 = this.pow(t, l);
        }
      return this;
    }
    convertTo(t) {
      const l = t.mod(this.m);
      return l.red = this, l;
    }
    convertFrom(t) {
      const l = t.clone();
      return l.red = null, l;
    }
    intTo(t) {
      return t;
    }
    intFrom(t) {
      return t;
    }
    imod(t) {
      return this.prime ? this.prime.ireduce(t)._forceRed(this) : t.imod(this.m)._forceRed(this);
    }
    iadd(t, l) {
      return this._verify2(t, l), t._iadd(t, l), t.ucmp(this.m) >= 0 && t._isub(t, this.m), t;
    }
    add(t, l) {
      return t.length < l.length ? this.iadd(l.clone(), t) : this.iadd(t.clone(), l);
    }
    iaddn(t, l) {
      return this._verify1(t), l < 0 ? this.isubn(t, -l) : (this.m.length === 1 && (l %= this.m.words[0]), t._iaddn(l), t.ucmp(this.m) >= 0 && t._isub(t, this.m), t);
    }
    addn(t, l) {
      return this.iaddn(t.clone(), l);
    }
    isub(t, l) {
      this._verify2(t, l);
      const B = t.ucmp(l);
      return B === 0 ? (t.words[0] = 0, t.length = 1, t) : (B < 0 ? (t._isub(l, t), t._isub(this.m, t)) : t._isub(t, l), t);
    }
    sub(t, l) {
      return this.isub(t.clone(), l);
    }
    isubn(t, l) {
      return this._verify1(t), l < 0 ? this.iaddn(t, -l) : (this.m.length === 1 && (l %= this.m.words[0]), t.length === 1 && t.words[0] < l ? (t.words[0] = l - t.words[0], t._isub(this.m, t)) : t._isubn(l), t);
    }
    subn(t, l) {
      return this.isubn(t.clone(), l);
    }
    imul(t, l) {
      return this._verify2(t, l), this.imod(t.imul(l));
    }
    mul(t, l) {
      return this._verify2(t, l), this.imod(t.mul(l));
    }
    imuln(t, l) {
      if (this._verify1(t), t.isZero())
        return t;
      if (l === 0)
        return t.words[0] = 0, t.length = 1, t;
      const B = l < 0;
      if (B && (l = -l), this.m.length === 1 && (l %= this.m.words[0]), t.imuln(l), l <= 16)
        for (; t.ucmp(this.m) >= 0; )
          t._isub(t, this.m);
      else
        this.imod(t);
      return B && this.ineg(t), t;
    }
    muln(t, l) {
      return this.imuln(t.clone(), l);
    }
    idiv(t, l) {
      return this.div(t, l)._move(t);
    }
    div(t, l) {
      return this.mul(t, this.invert(l));
    }
    idivn(t, l) {
      return this.divn(t, l)._move(t);
    }
    divn(t, l) {
      return this.div(t, this.convertTo(new s(l)));
    }
    ipow(t, l) {
      return this.pow(t, l)._move(t);
    }
    pow(t, l) {
      return this._verify1(t), l.isNeg() && (t = this.invert(t)), l.length === 1 ? this.pown(t, l.words[0]) : a && !this.prime ? this.powInt(t, l) : this.powNum(t, l);
    }
    powNum(t, l) {
      const B = new s(1).toRed(this), U = new Array(u), G = this.sqr(t);
      U[0] = t;
      for (let $ = 1; $ < u; $++)
        U[$] = this.mul(U[$ - 1], G);
      let T = l.bitLength(), M = B;
      for (; T >= n; ) {
        let $ = n, r = l.bits(T - $, $);
        if (r < u) {
          M = this.sqr(M), T -= 1;
          continue;
        }
        for (; (r & 1) === 0; )
          $ -= 1, r >>= 1;
        M === B ? M = U[r >> 1].clone() : (M = this.sqrn(M, $), M = this.mul(M, U[r >> 1])), T -= $;
      }
      if (T > 0) {
        const $ = l.bits(0, T);
        for (; T--; )
          M = this.sqr(M), $ >> T & 1 && (M = this.mul(M, t));
      }
      return M;
    }
    powInt(t, l) {
      this.mb === null && (this.mb = this.m.toBigInt());
      const B = this.intFrom(t.toBigInt()), U = be(B, l, this.mb), G = this.intTo(U);
      return s.fromBigInt(G)._forceRed(this);
    }
    sqrn(t, l) {
      for (; l--; )
        t = this.sqr(t);
      return t;
    }
    sqrnmul(t, l, B) {
      return this.mul(this.sqrn(t, l), B);
    }
    ipown(t, l) {
      return this.pown(t, l)._move(t);
    }
    pown(t, l) {
      if (this._verify1(t), l < 0 && (t = this.invert(t), l = -l), l === 0)
        return new s(1).toRed(this);
      if (l === 1)
        return t.clone();
      const B = oe(l);
      let U = t;
      for (let G = B - 2; G >= 0; G--)
        U = this.sqr(U), l >> G & 1 && (U = this.mul(U, t));
      return U;
    }
    isqr(t) {
      return this.imul(t, t);
    }
    sqr(t) {
      return this.mul(t, t);
    }
    isqrt(t) {
      return this.sqrt(t)._move(t);
    }
    sqrt(t) {
      return this._verify1(t), this.prime ? this.prime.sqrt(t) : this.m.andln(3) === 3 ? this.sqrt3mod4(t) : this.m.andln(7) === 5 ? this.sm1 != null ? this.sqrt5mod8sm1(t) : this.sqrt5mod8(t) : this.sqrt0(t);
    }
    sqrt3mod4(t) {
      const l = this.m.addn(1).iushrn(2), B = this.pow(t, l);
      if (!this.sqr(B).eq(t))
        throw new ue(B);
      return B;
    }
    sqrt5mod8(t) {
      const l = new s(1).toRed(this), B = this.m.ushrn(3), U = this.add(t, t), G = this.pow(U, B), T = this.mul(U, this.sqr(G)), M = this.mul(this.mul(G, t), this.isub(T, l));
      if (!this.sqr(M).eq(t))
        throw new ue(M);
      return M;
    }
    sqrt5mod8sm1(t) {
      const l = this.m.addn(3).iushrn(3), B = this.pow(t, l);
      if (this.sqr(B).eq(t))
        return B;
      const U = this.mul(B, this.sm1);
      if (this.sqr(U).eq(t))
        return U;
      throw new ue(B);
    }
    sqrt0(t) {
      if (this.m.cmpn(1) === 0 || !this.m.isOdd())
        throw new Error("Invalid prime.");
      switch (this.jacobi(t)) {
        case -1:
          throw new ue(t);
        case 0:
          return t.clone();
      }
      const l = new s(1).toRed(this), B = this.m.subn(1), U = B._makeOdd(), G = new s(2).toRed(this);
      for (; this.jacobi(G) !== -1; )
        this.iadd(G, l);
      let T = this.pow(G, B), M = this.pow(t, B), $ = this.pow(t, B.iaddn(1).iushrn(1)), r = U;
      for (; ; ) {
        let x = M, O = 0;
        for (; !x.eq(l) && O < r; )
          x = this.sqr(x), O += 1;
        if (O === 0)
          break;
        q(O < r), x = this.sqrn(T, r - O - 1), T = this.sqr(x), $ = this.mul($, x), M = this.mul(M, T), r = O;
      }
      return $;
    }
    idivsqrt(t, l) {
      return this.divsqrt(t, l)._move(t);
    }
    divsqrt(t, l) {
      if (this._verify2(t, l), t.isZero() && l.isZero())
        throw new ue(l);
      if (this.prime)
        return this.prime.divsqrt(t, l);
      if (this.m.andln(3) === 3)
        return this.divsqrt3mod4(t, l);
      if (this.sm1 != null && this.m.andln(7) === 5)
        return this.divsqrt5mod8(t, l);
      if (l.isZero())
        throw new ue(l);
      return this.sqrt(this.div(t, l));
    }
    divsqrt3mod4(t, l) {
      const B = this.m.subn(3).iushrn(2), U = this.sqr(t), G = this.mul(U, t), T = this.mul(G, U), M = this.mul(this.sqr(l), l), $ = this.pow(this.mul(T, M), B), r = this.mul(this.mul(G, l), $);
      if (this.mul(l, this.sqr(r)).eq(t))
        return r;
      throw new ue(r);
    }
    divsqrt5mod8(t, l) {
      const B = this.m.subn(5).iushrn(3), U = this.mul(this.sqr(l), l), G = this.mul(this.sqr(U), l), T = this.pow(this.mul(t, G), B), M = this.mul(this.mul(t, U), T), $ = this.mul(l, this.sqr(M));
      if ($.eq(t))
        return M;
      const r = this.ineg($);
      if (r.eq(t))
        return this.mul(M, this.sm1);
      throw r.eq(this.mul(t, this.sm1)) ? new ue(this.mul(M, this.sm1)) : new ue(M);
    }
    isSquare(t) {
      return this.m.isOdd() ? this.jacobi(t) >= 0 : this.kronecker(t) >= 0;
    }
    ishl(t, l) {
      return this._verify1(t), this.imod(t.iushl(l));
    }
    shl(t, l) {
      return this.ishl(t.clone(), l);
    }
    ishln(t, l) {
      if (this._verify1(t), t.iushln(l), l <= 4)
        for (; t.ucmp(this.m) >= 0; )
          t._isub(t, this.m);
      else
        this.imod(t);
      return t;
    }
    shln(t, l) {
      return this.ishln(t.clone(), l);
    }
    ineg(t) {
      return this._verify1(t), t.isZero() || t._isub(this.m, t), t;
    }
    neg(t) {
      return this.ineg(t.clone());
    }
    eq(t, l) {
      return this._verify2(t, l), t.ucmp(l) === 0;
    }
    eqn(t, l) {
      if (this._verify1(t), this.m.length === 1)
        return l %= this.m.words[0], l < 0 && (l += this.m.words[0]), t.ucmpn(l) === 0;
      if (l < 0) {
        this.m._isubn(-l);
        const B = t.ucmp(this.m);
        return this.m._iaddn(-l), B === 0;
      }
      return t.ucmpn(l) === 0;
    }
    isHigh(t) {
      return !this.isLow(t);
    }
    isLow(t) {
      return this._verify1(t), t.ucmp(this.m.ushrn(1)) <= 0;
    }
    isOdd(t) {
      return this._verify1(t), t.isOdd();
    }
    isEven(t) {
      return this._verify1(t), t.isEven();
    }
    legendre(t) {
      if (this._verify1(t), this.m.isEven())
        throw new Error("legendre: `num` must be odd.");
      const l = this.m.subn(1).iushrn(1), B = this.pow(t, l);
      if (B.isZero())
        return 0;
      const U = new s(1).toRed(this);
      if (B.eq(U))
        return 1;
      if (B.eq(this.ineg(U)))
        return -1;
      throw new Error("Invalid prime.");
    }
    jacobi(t) {
      return this._verify1(t), t.jacobi(this.m);
    }
    kronecker(t) {
      return this._verify1(t), t.kronecker(this.m);
    }
    iinvert(t) {
      return this.invert(t)._move(t);
    }
    invert(t) {
      return this._verify1(t), t.invert(this.m)._forceRed(this);
    }
    ifermat(t) {
      return this.fermat(t)._move(t);
    }
    fermat(t) {
      if (this._verify1(t), t.isZero() || this.m.cmpn(1) === 0)
        throw new RangeError("Not invertible.");
      return this.prime ? this.prime.fermat(t) : this.pow(t, this.m.subn(2));
    }
    invertAll(t) {
      _(Array.isArray(t), "elems", "array");
      for (const G of t)
        _(s.isBN(G), "elem", "bignum"), this._verify1(G);
      if (this.m.cmpn(1) === 0 || this.m.isEven())
        throw new RangeError("Not invertible.");
      const l = t.length, B = new Array(l);
      if (l === 0)
        return B;
      let U = new s(1).toRed(this);
      for (let G = 0; G < l; G++) {
        if (t[G].isZero()) {
          B[G] = t[G].clone();
          continue;
        }
        B[G] = U, U = this.mul(U, t[G]);
      }
      U = this.invert(U);
      for (let G = l - 1; G >= 0; G--)
        t[G].isZero() || (B[G] = this.mul(U, B[G]), U = this.mul(U, t[G]));
      return B;
    }
    [e]() {
      return this.prime ? `<Red: ${this.prime.name}>` : `<Red: ${this.m.toString(10)}>`;
    }
  }
  class N extends J {
    constructor(t) {
      super(t), this.prime = null, this.n = this.m.bitLength(), this.n % 26 !== 0 && (this.n += 26 - this.n % 26), this.k = this.n * 2, this.w = this.k / 26, this.b = s.shift(1, this.k).div(this.m);
    }
    convertTo(t) {
      return t.length > this.w ? super.convertTo(t) : this.imod(t.clone());
    }
    _shift(t) {
      let l = 0, B = this.w;
      for (; B < t.length; )
        t.words[l++] = t.words[B++];
      l === 0 && (t.words[l++] = 0), t.length = l;
    }
    imod(t) {
      const l = t.negative;
      q(t.length <= this.w), t.negative = 0;
      const B = t.mul(this.b);
      return this._shift(B), t._isub(t, B.mul(this.m)), t.ucmp(this.m) >= 0 && t._isub(t, this.m), l && !t.isZero() && t._isub(this.m, t), t.red = this, t;
    }
  }
  class z extends J {
    constructor(t) {
      super(t), this.prime = null, this.n = this.m.length * 26, this.r = s.shift(1, this.n), this.r2 = s.shift(1, this.n * 2).imod(this.m), this.ri = this.r.invert(this.m), this.mi = this.r.mul(this.ri).isubn(1).div(this.m), this.rib = null;
    }
    get mont() {
      return !0;
    }
    convertTo(t) {
      return t.isNeg() || t.ucmp(this.m) >= 0 ? this.imod(t.ushln(this.n)) : this.mul(t, this.r2);
    }
    convertFrom(t) {
      const l = this.mul(t, new s(1));
      return l.red = null, l;
    }
    intTo(t) {
      return (t << BigInt(this.n)) % this.mb;
    }
    intFrom(t) {
      return this.rib === null && (this.rib = this.ri.toBigInt()), t * this.rib % this.mb;
    }
    iaddn(t, l) {
      return this.iadd(t, this.convertTo(new s(l)));
    }
    isubn(t, l) {
      return this.isub(t, this.convertTo(new s(l)));
    }
    imul(t, l) {
      return this.mul(t, l)._move(t);
    }
    mul(t, l) {
      if (t.isZero() || l.isZero())
        return new s(0)._forceRed(this);
      const B = t.mul(l), U = B.umaskn(this.n).mul(this.mi).iumaskn(this.n), G = B.iadd(U.mul(this.m)).iushrn(this.n);
      return G.ucmp(this.m) >= 0 && G._isub(G, this.m), G._forceRed(this);
    }
    imuln(t, l) {
      if (this._verify1(t), t.isZero())
        return t;
      if (l === 0)
        return t.words[0] = 0, t.length = 1, t;
      const B = l < 0;
      B && (l = -l), this.m.length === 1 && (l %= this.m.words[0]);
      const U = oe(l);
      if (U > 5)
        this.imul(t, this.convertTo(new s(l)));
      else if ((l & l - 1) === 0)
        for (let G = 0; G < U - 1; G++)
          this.iadd(t, t);
      else {
        const G = t.clone();
        for (let T = U - 2; T >= 0; T--)
          this.iadd(t, t), l >> T & 1 && this.iadd(t, G);
      }
      return B && this.ineg(t), t;
    }
    eqn(t, l) {
      return this._verify1(t), l === 0 ? t.isZero() : t.ucmp(this.convertTo(new s(l))) === 0;
    }
    isLow(t) {
      return this._verify1(t), this.convertFrom(t).ucmp(this.m.ushrn(1)) <= 0;
    }
    isOdd(t) {
      return this._verify1(t), this.convertFrom(t).isOdd();
    }
    isEven(t) {
      return this._verify1(t), this.convertFrom(t).isEven();
    }
    invert(t) {
      return this._verify1(t), this.imod(t.invert(this.m).mul(this.r2));
    }
  }
  function A(se, t, l) {
    const B = new se(t);
    return se.captureStackTrace && se.captureStackTrace(B, l), B;
  }
  function q(se, t) {
    if (!se)
      throw A(Error, t || "Assertion failed.", q);
  }
  function _(se, t, l) {
    if (!se) {
      const B = `"${t}" must be a(n) ${l}.`;
      throw A(TypeError, B, _);
    }
  }
  function F(se, t) {
    if (!se) {
      const l = `"${t}" only works with positive numbers.`;
      throw A(RangeError, l, F);
    }
  }
  function R(se, t) {
    if (!se) {
      const l = `"${t}" only works with red numbers.`;
      throw A(TypeError, l, R);
    }
  }
  function V(se, t) {
    if (!se) {
      const l = `"${t}" only works with normal numbers.`;
      throw A(TypeError, l, V);
    }
  }
  function fe(se) {
    if (!se)
      throw A(RangeError, "Cannot divide by zero.", fe);
  }
  class ue extends Error {
    constructor(t) {
      super(), this.name = "SquareRootError", this.message = "X is not a square mod P.", this.result = t.fromRed(), Error.captureStackTrace && Error.captureStackTrace(this, ue);
    }
  }
  function ae(se) {
    return Number.isSafeInteger(se);
  }
  function D(se) {
    return ae(se) && se >= -67108863 && se <= 67108863;
  }
  function Q(se, t) {
    return se.allocUnsafeSlow ? se.allocUnsafeSlow(t) : new se(t);
  }
  function Z(se) {
    if (se == null)
      return 10;
    if (typeof se == "number")
      return se;
    switch (se) {
      case "bin":
        return 2;
      case "oct":
        return 8;
      case "dec":
        return 10;
      case "hex":
        return 16;
    }
    return 0;
  }
  function oe(se) {
    if (Math.clz32)
      return 32 - Math.clz32(se);
    let t = se, l = 0;
    return t >= 4096 && (l += 13, t >>>= 13), t >= 64 && (l += 7, t >>>= 7), t >= 8 && (l += 4, t >>>= 4), t >= 2 && (l += 2, t >>>= 2), l + t;
  }
  function y(se) {
    if (se === 0)
      return 26;
    let t = se, l = 0;
    return (t & 8191) === 0 && (l += 13, t >>>= 13), (t & 127) === 0 && (l += 7, t >>>= 7), (t & 15) === 0 && (l += 4, t >>>= 4), (t & 3) === 0 && (l += 2, t >>>= 2), (t & 1) === 0 && (l += 1), l;
  }
  function Y(se, t, l) {
    const B = Math.min(se.length, l);
    let U = 0, G = 0;
    for (let T = t; T < B; T++) {
      const M = se.charCodeAt(T) - 48;
      U <<= 4;
      let $;
      M >= 49 && M <= 54 ? $ = M - 49 + 10 : M >= 17 && M <= 22 ? $ = M - 17 + 10 : $ = M, U |= $, G |= $;
    }
    if (G & -16)
      throw new Error("Invalid string.");
    return U;
  }
  function he(se, t, l, B) {
    const U = Math.min(se.length, l);
    let G = 0;
    for (let T = t; T < U; T++) {
      const M = se.charCodeAt(T) - 48;
      G *= B;
      let $;
      if (M >= 49 ? $ = M - 49 + 10 : M >= 17 ? $ = M - 17 + 10 : $ = M, M < 0 || M > 207 || $ >= B)
        throw new Error("Invalid string.");
      G += $;
    }
    return G;
  }
  function be(se, t, l) {
    const B = BigInt(1), U = new Array(u), G = se * se % l;
    U[0] = se;
    for (let $ = 1; $ < u; $++)
      U[$] = U[$ - 1] * G % l;
    let T = t.bitLength(), M = B;
    for (; T >= n; ) {
      let $ = n, r = t.bits(T - $, $);
      if (r < u) {
        M = M * M % l, T -= 1;
        continue;
      }
      for (; (r & 1) === 0; )
        $ -= 1, r >>= 1;
      M === B ? M = U[r >> 1] : (M = xe(M, $, l), M = M * U[r >> 1] % l), T -= $;
    }
    if (T > 0) {
      const $ = t.bits(0, T);
      for (; T--; )
        M = M * M % l, $ >> T & 1 && (M = M * se % l);
    }
    return M;
  }
  function xe(se, t, l) {
    for (let B = 0; B < t; B++)
      se = se * se % l;
    return se;
  }
  function Ie(se, t, l) {
    const B = se.length + t.length;
    l.negative = se.negative ^ t.negative, l._alloc(B), l.length = B;
    const U = se.words[0], G = t.words[0], T = U * G, M = T & 67108863;
    let $ = T / 67108864 | 0, r = 1;
    for (l.words[0] = M; r < l.length - 1; r++) {
      let x = $ >>> 26, O = $ & 67108863;
      const L = Math.max(0, r - se.length + 1), X = Math.min(r, t.length - 1);
      for (let P = L; P <= X; P++) {
        const K = r - P, re = se.words[K], ce = t.words[P], le = re * ce + O;
        x += le / 67108864 | 0, O = le & 67108863;
      }
      l.words[r] = O | 0, $ = x | 0;
    }
    return $ !== 0 ? l.words[r] = $ | 0 : l.length -= 1, l._strip();
  }
  function ve(se, t, l) {
    const B = se.length + t.length;
    l.negative = se.negative ^ t.negative, l._alloc(B), l.length = B;
    let U = 0, G = 0, T = 0;
    for (; T < l.length - 1; T++) {
      let M = G;
      G = 0;
      let $ = U & 67108863;
      const r = Math.max(0, T - se.length + 1), x = Math.min(T, t.length - 1);
      for (let O = r; O <= x; O++) {
        const L = T - O, X = se.words[L], P = t.words[O], K = X * P;
        let re = K & 67108863;
        M = M + (K / 67108864 | 0) | 0, re = re + $ | 0, $ = re & 67108863, M = M + (re >>> 26) | 0, G += M >>> 26, M &= 67108863;
      }
      l.words[T] = $, U = M, M = G;
    }
    return U !== 0 ? l.words[T] = U : l.length -= 1, l._strip();
  }
  function C(se, t, l) {
    if (!a || se.length + t.length > 82595519)
      return ve(se, t, l);
    const B = BigInt(0), U = BigInt(67108863), G = BigInt(26);
    let T = se.toBigInt() * t.toBigInt();
    const M = T < B | 0;
    M && (T = -T);
    let $ = 0;
    for (; T > B; )
      l.words[$++] = Number(T & U), T >>= G;
    return $ === 0 && (l.words[$++] = 0), l.length = $, l.negative = M, l;
  }
  function I(se, t, l) {
    const B = se.words, U = t.words, G = l.words, T = B[0] | 0, M = T & 8191, $ = T >>> 13, r = B[1] | 0, x = r & 8191, O = r >>> 13, L = B[2] | 0, X = L & 8191, P = L >>> 13, K = B[3] | 0, re = K & 8191, ce = K >>> 13, le = B[4] | 0, me = le & 8191, ne = le >>> 13, W = B[5] | 0, te = W & 8191, pe = W >>> 13, Ee = B[6] | 0, Ae = Ee & 8191, Oe = Ee >>> 13, Be = B[7] | 0, ke = Be & 8191, Ne = Be >>> 13, Ke = B[8] | 0, Ce = Ke & 8191, Ye = Ke >>> 13, vt = B[9] | 0, Ve = vt & 8191, Xe = vt >>> 13, qt = U[0] | 0, Ge = qt & 8191, Je = qt >>> 13, Rt = U[1] | 0, We = Rt & 8191, Ze = Rt >>> 13, Ft = U[2] | 0, Qe = Ft & 8191, st = Ft >>> 13, Kr = U[3] | 0, ct = Kr & 8191, ut = Kr >>> 13, Vr = U[4] | 0, rt = Vr & 8191, ht = Vr >>> 13, $r = U[5] | 0, lt = $r & 8191, dt = $r >>> 13, jr = U[6] | 0, bt = jr & 8191, pt = jr >>> 13, Yr = U[7] | 0, ot = Yr & 8191, mt = Yr >>> 13, kr = U[8] | 0, et = kr & 8191, at = kr >>> 13, ir = U[9] | 0, it = ir & 8191, tt = ir >>> 13;
    let Le = 0, ye, ee, we;
    l.negative = se.negative ^ t.negative, l._alloc(20), l.length = 19, ye = Math.imul(M, Ge), ee = Math.imul(M, Je), ee = ee + Math.imul($, Ge) | 0, we = Math.imul($, Je);
    let Ct = (Le + ye | 0) + ((ee & 8191) << 13) | 0;
    Le = (we + (ee >>> 13) | 0) + (Ct >>> 26) | 0, Ct &= 67108863, ye = Math.imul(x, Ge), ee = Math.imul(x, Je), ee = ee + Math.imul(O, Ge) | 0, we = Math.imul(O, Je), ye = ye + Math.imul(M, We) | 0, ee = ee + Math.imul(M, Ze) | 0, ee = ee + Math.imul($, We) | 0, we = we + Math.imul($, Ze) | 0;
    let ge = (Le + ye | 0) + ((ee & 8191) << 13) | 0;
    Le = (we + (ee >>> 13) | 0) + (ge >>> 26) | 0, ge &= 67108863, ye = Math.imul(X, Ge), ee = Math.imul(X, Je), ee = ee + Math.imul(P, Ge) | 0, we = Math.imul(P, Je), ye = ye + Math.imul(x, We) | 0, ee = ee + Math.imul(x, Ze) | 0, ee = ee + Math.imul(O, We) | 0, we = we + Math.imul(O, Ze) | 0, ye = ye + Math.imul(M, Qe) | 0, ee = ee + Math.imul(M, st) | 0, ee = ee + Math.imul($, Qe) | 0, we = we + Math.imul($, st) | 0;
    let ie = (Le + ye | 0) + ((ee & 8191) << 13) | 0;
    Le = (we + (ee >>> 13) | 0) + (ie >>> 26) | 0, ie &= 67108863, ye = Math.imul(re, Ge), ee = Math.imul(re, Je), ee = ee + Math.imul(ce, Ge) | 0, we = Math.imul(ce, Je), ye = ye + Math.imul(X, We) | 0, ee = ee + Math.imul(X, Ze) | 0, ee = ee + Math.imul(P, We) | 0, we = we + Math.imul(P, Ze) | 0, ye = ye + Math.imul(x, Qe) | 0, ee = ee + Math.imul(x, st) | 0, ee = ee + Math.imul(O, Qe) | 0, we = we + Math.imul(O, st) | 0, ye = ye + Math.imul(M, ct) | 0, ee = ee + Math.imul(M, ut) | 0, ee = ee + Math.imul($, ct) | 0, we = we + Math.imul($, ut) | 0;
    let de = (Le + ye | 0) + ((ee & 8191) << 13) | 0;
    Le = (we + (ee >>> 13) | 0) + (de >>> 26) | 0, de &= 67108863, ye = Math.imul(me, Ge), ee = Math.imul(me, Je), ee = ee + Math.imul(ne, Ge) | 0, we = Math.imul(ne, Je), ye = ye + Math.imul(re, We) | 0, ee = ee + Math.imul(re, Ze) | 0, ee = ee + Math.imul(ce, We) | 0, we = we + Math.imul(ce, Ze) | 0, ye = ye + Math.imul(X, Qe) | 0, ee = ee + Math.imul(X, st) | 0, ee = ee + Math.imul(P, Qe) | 0, we = we + Math.imul(P, st) | 0, ye = ye + Math.imul(x, ct) | 0, ee = ee + Math.imul(x, ut) | 0, ee = ee + Math.imul(O, ct) | 0, we = we + Math.imul(O, ut) | 0, ye = ye + Math.imul(M, rt) | 0, ee = ee + Math.imul(M, ht) | 0, ee = ee + Math.imul($, rt) | 0, we = we + Math.imul($, ht) | 0;
    let Se = (Le + ye | 0) + ((ee & 8191) << 13) | 0;
    Le = (we + (ee >>> 13) | 0) + (Se >>> 26) | 0, Se &= 67108863, ye = Math.imul(te, Ge), ee = Math.imul(te, Je), ee = ee + Math.imul(pe, Ge) | 0, we = Math.imul(pe, Je), ye = ye + Math.imul(me, We) | 0, ee = ee + Math.imul(me, Ze) | 0, ee = ee + Math.imul(ne, We) | 0, we = we + Math.imul(ne, Ze) | 0, ye = ye + Math.imul(re, Qe) | 0, ee = ee + Math.imul(re, st) | 0, ee = ee + Math.imul(ce, Qe) | 0, we = we + Math.imul(ce, st) | 0, ye = ye + Math.imul(X, ct) | 0, ee = ee + Math.imul(X, ut) | 0, ee = ee + Math.imul(P, ct) | 0, we = we + Math.imul(P, ut) | 0, ye = ye + Math.imul(x, rt) | 0, ee = ee + Math.imul(x, ht) | 0, ee = ee + Math.imul(O, rt) | 0, we = we + Math.imul(O, ht) | 0, ye = ye + Math.imul(M, lt) | 0, ee = ee + Math.imul(M, dt) | 0, ee = ee + Math.imul($, lt) | 0, we = we + Math.imul($, dt) | 0;
    let _e = (Le + ye | 0) + ((ee & 8191) << 13) | 0;
    Le = (we + (ee >>> 13) | 0) + (_e >>> 26) | 0, _e &= 67108863, ye = Math.imul(Ae, Ge), ee = Math.imul(Ae, Je), ee = ee + Math.imul(Oe, Ge) | 0, we = Math.imul(Oe, Je), ye = ye + Math.imul(te, We) | 0, ee = ee + Math.imul(te, Ze) | 0, ee = ee + Math.imul(pe, We) | 0, we = we + Math.imul(pe, Ze) | 0, ye = ye + Math.imul(me, Qe) | 0, ee = ee + Math.imul(me, st) | 0, ee = ee + Math.imul(ne, Qe) | 0, we = we + Math.imul(ne, st) | 0, ye = ye + Math.imul(re, ct) | 0, ee = ee + Math.imul(re, ut) | 0, ee = ee + Math.imul(ce, ct) | 0, we = we + Math.imul(ce, ut) | 0, ye = ye + Math.imul(X, rt) | 0, ee = ee + Math.imul(X, ht) | 0, ee = ee + Math.imul(P, rt) | 0, we = we + Math.imul(P, ht) | 0, ye = ye + Math.imul(x, lt) | 0, ee = ee + Math.imul(x, dt) | 0, ee = ee + Math.imul(O, lt) | 0, we = we + Math.imul(O, dt) | 0, ye = ye + Math.imul(M, bt) | 0, ee = ee + Math.imul(M, pt) | 0, ee = ee + Math.imul($, bt) | 0, we = we + Math.imul($, pt) | 0;
    let Pe = (Le + ye | 0) + ((ee & 8191) << 13) | 0;
    Le = (we + (ee >>> 13) | 0) + (Pe >>> 26) | 0, Pe &= 67108863, ye = Math.imul(ke, Ge), ee = Math.imul(ke, Je), ee = ee + Math.imul(Ne, Ge) | 0, we = Math.imul(Ne, Je), ye = ye + Math.imul(Ae, We) | 0, ee = ee + Math.imul(Ae, Ze) | 0, ee = ee + Math.imul(Oe, We) | 0, we = we + Math.imul(Oe, Ze) | 0, ye = ye + Math.imul(te, Qe) | 0, ee = ee + Math.imul(te, st) | 0, ee = ee + Math.imul(pe, Qe) | 0, we = we + Math.imul(pe, st) | 0, ye = ye + Math.imul(me, ct) | 0, ee = ee + Math.imul(me, ut) | 0, ee = ee + Math.imul(ne, ct) | 0, we = we + Math.imul(ne, ut) | 0, ye = ye + Math.imul(re, rt) | 0, ee = ee + Math.imul(re, ht) | 0, ee = ee + Math.imul(ce, rt) | 0, we = we + Math.imul(ce, ht) | 0, ye = ye + Math.imul(X, lt) | 0, ee = ee + Math.imul(X, dt) | 0, ee = ee + Math.imul(P, lt) | 0, we = we + Math.imul(P, dt) | 0, ye = ye + Math.imul(x, bt) | 0, ee = ee + Math.imul(x, pt) | 0, ee = ee + Math.imul(O, bt) | 0, we = we + Math.imul(O, pt) | 0, ye = ye + Math.imul(M, ot) | 0, ee = ee + Math.imul(M, mt) | 0, ee = ee + Math.imul($, ot) | 0, we = we + Math.imul($, mt) | 0;
    let Re = (Le + ye | 0) + ((ee & 8191) << 13) | 0;
    Le = (we + (ee >>> 13) | 0) + (Re >>> 26) | 0, Re &= 67108863, ye = Math.imul(Ce, Ge), ee = Math.imul(Ce, Je), ee = ee + Math.imul(Ye, Ge) | 0, we = Math.imul(Ye, Je), ye = ye + Math.imul(ke, We) | 0, ee = ee + Math.imul(ke, Ze) | 0, ee = ee + Math.imul(Ne, We) | 0, we = we + Math.imul(Ne, Ze) | 0, ye = ye + Math.imul(Ae, Qe) | 0, ee = ee + Math.imul(Ae, st) | 0, ee = ee + Math.imul(Oe, Qe) | 0, we = we + Math.imul(Oe, st) | 0, ye = ye + Math.imul(te, ct) | 0, ee = ee + Math.imul(te, ut) | 0, ee = ee + Math.imul(pe, ct) | 0, we = we + Math.imul(pe, ut) | 0, ye = ye + Math.imul(me, rt) | 0, ee = ee + Math.imul(me, ht) | 0, ee = ee + Math.imul(ne, rt) | 0, we = we + Math.imul(ne, ht) | 0, ye = ye + Math.imul(re, lt) | 0, ee = ee + Math.imul(re, dt) | 0, ee = ee + Math.imul(ce, lt) | 0, we = we + Math.imul(ce, dt) | 0, ye = ye + Math.imul(X, bt) | 0, ee = ee + Math.imul(X, pt) | 0, ee = ee + Math.imul(P, bt) | 0, we = we + Math.imul(P, pt) | 0, ye = ye + Math.imul(x, ot) | 0, ee = ee + Math.imul(x, mt) | 0, ee = ee + Math.imul(O, ot) | 0, we = we + Math.imul(O, mt) | 0, ye = ye + Math.imul(M, et) | 0, ee = ee + Math.imul(M, at) | 0, ee = ee + Math.imul($, et) | 0, we = we + Math.imul($, at) | 0;
    let Me = (Le + ye | 0) + ((ee & 8191) << 13) | 0;
    Le = (we + (ee >>> 13) | 0) + (Me >>> 26) | 0, Me &= 67108863, ye = Math.imul(Ve, Ge), ee = Math.imul(Ve, Je), ee = ee + Math.imul(Xe, Ge) | 0, we = Math.imul(Xe, Je), ye = ye + Math.imul(Ce, We) | 0, ee = ee + Math.imul(Ce, Ze) | 0, ee = ee + Math.imul(Ye, We) | 0, we = we + Math.imul(Ye, Ze) | 0, ye = ye + Math.imul(ke, Qe) | 0, ee = ee + Math.imul(ke, st) | 0, ee = ee + Math.imul(Ne, Qe) | 0, we = we + Math.imul(Ne, st) | 0, ye = ye + Math.imul(Ae, ct) | 0, ee = ee + Math.imul(Ae, ut) | 0, ee = ee + Math.imul(Oe, ct) | 0, we = we + Math.imul(Oe, ut) | 0, ye = ye + Math.imul(te, rt) | 0, ee = ee + Math.imul(te, ht) | 0, ee = ee + Math.imul(pe, rt) | 0, we = we + Math.imul(pe, ht) | 0, ye = ye + Math.imul(me, lt) | 0, ee = ee + Math.imul(me, dt) | 0, ee = ee + Math.imul(ne, lt) | 0, we = we + Math.imul(ne, dt) | 0, ye = ye + Math.imul(re, bt) | 0, ee = ee + Math.imul(re, pt) | 0, ee = ee + Math.imul(ce, bt) | 0, we = we + Math.imul(ce, pt) | 0, ye = ye + Math.imul(X, ot) | 0, ee = ee + Math.imul(X, mt) | 0, ee = ee + Math.imul(P, ot) | 0, we = we + Math.imul(P, mt) | 0, ye = ye + Math.imul(x, et) | 0, ee = ee + Math.imul(x, at) | 0, ee = ee + Math.imul(O, et) | 0, we = we + Math.imul(O, at) | 0, ye = ye + Math.imul(M, it) | 0, ee = ee + Math.imul(M, tt) | 0, ee = ee + Math.imul($, it) | 0, we = we + Math.imul($, tt) | 0;
    let qe = (Le + ye | 0) + ((ee & 8191) << 13) | 0;
    Le = (we + (ee >>> 13) | 0) + (qe >>> 26) | 0, qe &= 67108863, ye = Math.imul(Ve, We), ee = Math.imul(Ve, Ze), ee = ee + Math.imul(Xe, We) | 0, we = Math.imul(Xe, Ze), ye = ye + Math.imul(Ce, Qe) | 0, ee = ee + Math.imul(Ce, st) | 0, ee = ee + Math.imul(Ye, Qe) | 0, we = we + Math.imul(Ye, st) | 0, ye = ye + Math.imul(ke, ct) | 0, ee = ee + Math.imul(ke, ut) | 0, ee = ee + Math.imul(Ne, ct) | 0, we = we + Math.imul(Ne, ut) | 0, ye = ye + Math.imul(Ae, rt) | 0, ee = ee + Math.imul(Ae, ht) | 0, ee = ee + Math.imul(Oe, rt) | 0, we = we + Math.imul(Oe, ht) | 0, ye = ye + Math.imul(te, lt) | 0, ee = ee + Math.imul(te, dt) | 0, ee = ee + Math.imul(pe, lt) | 0, we = we + Math.imul(pe, dt) | 0, ye = ye + Math.imul(me, bt) | 0, ee = ee + Math.imul(me, pt) | 0, ee = ee + Math.imul(ne, bt) | 0, we = we + Math.imul(ne, pt) | 0, ye = ye + Math.imul(re, ot) | 0, ee = ee + Math.imul(re, mt) | 0, ee = ee + Math.imul(ce, ot) | 0, we = we + Math.imul(ce, mt) | 0, ye = ye + Math.imul(X, et) | 0, ee = ee + Math.imul(X, at) | 0, ee = ee + Math.imul(P, et) | 0, we = we + Math.imul(P, at) | 0, ye = ye + Math.imul(x, it) | 0, ee = ee + Math.imul(x, tt) | 0, ee = ee + Math.imul(O, it) | 0, we = we + Math.imul(O, tt) | 0;
    let De = (Le + ye | 0) + ((ee & 8191) << 13) | 0;
    Le = (we + (ee >>> 13) | 0) + (De >>> 26) | 0, De &= 67108863, ye = Math.imul(Ve, Qe), ee = Math.imul(Ve, st), ee = ee + Math.imul(Xe, Qe) | 0, we = Math.imul(Xe, st), ye = ye + Math.imul(Ce, ct) | 0, ee = ee + Math.imul(Ce, ut) | 0, ee = ee + Math.imul(Ye, ct) | 0, we = we + Math.imul(Ye, ut) | 0, ye = ye + Math.imul(ke, rt) | 0, ee = ee + Math.imul(ke, ht) | 0, ee = ee + Math.imul(Ne, rt) | 0, we = we + Math.imul(Ne, ht) | 0, ye = ye + Math.imul(Ae, lt) | 0, ee = ee + Math.imul(Ae, dt) | 0, ee = ee + Math.imul(Oe, lt) | 0, we = we + Math.imul(Oe, dt) | 0, ye = ye + Math.imul(te, bt) | 0, ee = ee + Math.imul(te, pt) | 0, ee = ee + Math.imul(pe, bt) | 0, we = we + Math.imul(pe, pt) | 0, ye = ye + Math.imul(me, ot) | 0, ee = ee + Math.imul(me, mt) | 0, ee = ee + Math.imul(ne, ot) | 0, we = we + Math.imul(ne, mt) | 0, ye = ye + Math.imul(re, et) | 0, ee = ee + Math.imul(re, at) | 0, ee = ee + Math.imul(ce, et) | 0, we = we + Math.imul(ce, at) | 0, ye = ye + Math.imul(X, it) | 0, ee = ee + Math.imul(X, tt) | 0, ee = ee + Math.imul(P, it) | 0, we = we + Math.imul(P, tt) | 0;
    let Ue = (Le + ye | 0) + ((ee & 8191) << 13) | 0;
    Le = (we + (ee >>> 13) | 0) + (Ue >>> 26) | 0, Ue &= 67108863, ye = Math.imul(Ve, ct), ee = Math.imul(Ve, ut), ee = ee + Math.imul(Xe, ct) | 0, we = Math.imul(Xe, ut), ye = ye + Math.imul(Ce, rt) | 0, ee = ee + Math.imul(Ce, ht) | 0, ee = ee + Math.imul(Ye, rt) | 0, we = we + Math.imul(Ye, ht) | 0, ye = ye + Math.imul(ke, lt) | 0, ee = ee + Math.imul(ke, dt) | 0, ee = ee + Math.imul(Ne, lt) | 0, we = we + Math.imul(Ne, dt) | 0, ye = ye + Math.imul(Ae, bt) | 0, ee = ee + Math.imul(Ae, pt) | 0, ee = ee + Math.imul(Oe, bt) | 0, we = we + Math.imul(Oe, pt) | 0, ye = ye + Math.imul(te, ot) | 0, ee = ee + Math.imul(te, mt) | 0, ee = ee + Math.imul(pe, ot) | 0, we = we + Math.imul(pe, mt) | 0, ye = ye + Math.imul(me, et) | 0, ee = ee + Math.imul(me, at) | 0, ee = ee + Math.imul(ne, et) | 0, we = we + Math.imul(ne, at) | 0, ye = ye + Math.imul(re, it) | 0, ee = ee + Math.imul(re, tt) | 0, ee = ee + Math.imul(ce, it) | 0, we = we + Math.imul(ce, tt) | 0;
    let He = (Le + ye | 0) + ((ee & 8191) << 13) | 0;
    Le = (we + (ee >>> 13) | 0) + (He >>> 26) | 0, He &= 67108863, ye = Math.imul(Ve, rt), ee = Math.imul(Ve, ht), ee = ee + Math.imul(Xe, rt) | 0, we = Math.imul(Xe, ht), ye = ye + Math.imul(Ce, lt) | 0, ee = ee + Math.imul(Ce, dt) | 0, ee = ee + Math.imul(Ye, lt) | 0, we = we + Math.imul(Ye, dt) | 0, ye = ye + Math.imul(ke, bt) | 0, ee = ee + Math.imul(ke, pt) | 0, ee = ee + Math.imul(Ne, bt) | 0, we = we + Math.imul(Ne, pt) | 0, ye = ye + Math.imul(Ae, ot) | 0, ee = ee + Math.imul(Ae, mt) | 0, ee = ee + Math.imul(Oe, ot) | 0, we = we + Math.imul(Oe, mt) | 0, ye = ye + Math.imul(te, et) | 0, ee = ee + Math.imul(te, at) | 0, ee = ee + Math.imul(pe, et) | 0, we = we + Math.imul(pe, at) | 0, ye = ye + Math.imul(me, it) | 0, ee = ee + Math.imul(me, tt) | 0, ee = ee + Math.imul(ne, it) | 0, we = we + Math.imul(ne, tt) | 0;
    let je = (Le + ye | 0) + ((ee & 8191) << 13) | 0;
    Le = (we + (ee >>> 13) | 0) + (je >>> 26) | 0, je &= 67108863, ye = Math.imul(Ve, lt), ee = Math.imul(Ve, dt), ee = ee + Math.imul(Xe, lt) | 0, we = Math.imul(Xe, dt), ye = ye + Math.imul(Ce, bt) | 0, ee = ee + Math.imul(Ce, pt) | 0, ee = ee + Math.imul(Ye, bt) | 0, we = we + Math.imul(Ye, pt) | 0, ye = ye + Math.imul(ke, ot) | 0, ee = ee + Math.imul(ke, mt) | 0, ee = ee + Math.imul(Ne, ot) | 0, we = we + Math.imul(Ne, mt) | 0, ye = ye + Math.imul(Ae, et) | 0, ee = ee + Math.imul(Ae, at) | 0, ee = ee + Math.imul(Oe, et) | 0, we = we + Math.imul(Oe, at) | 0, ye = ye + Math.imul(te, it) | 0, ee = ee + Math.imul(te, tt) | 0, ee = ee + Math.imul(pe, it) | 0, we = we + Math.imul(pe, tt) | 0;
    let ft = (Le + ye | 0) + ((ee & 8191) << 13) | 0;
    Le = (we + (ee >>> 13) | 0) + (ft >>> 26) | 0, ft &= 67108863, ye = Math.imul(Ve, bt), ee = Math.imul(Ve, pt), ee = ee + Math.imul(Xe, bt) | 0, we = Math.imul(Xe, pt), ye = ye + Math.imul(Ce, ot) | 0, ee = ee + Math.imul(Ce, mt) | 0, ee = ee + Math.imul(Ye, ot) | 0, we = we + Math.imul(Ye, mt) | 0, ye = ye + Math.imul(ke, et) | 0, ee = ee + Math.imul(ke, at) | 0, ee = ee + Math.imul(Ne, et) | 0, we = we + Math.imul(Ne, at) | 0, ye = ye + Math.imul(Ae, it) | 0, ee = ee + Math.imul(Ae, tt) | 0, ee = ee + Math.imul(Oe, it) | 0, we = we + Math.imul(Oe, tt) | 0;
    let St = (Le + ye | 0) + ((ee & 8191) << 13) | 0;
    Le = (we + (ee >>> 13) | 0) + (St >>> 26) | 0, St &= 67108863, ye = Math.imul(Ve, ot), ee = Math.imul(Ve, mt), ee = ee + Math.imul(Xe, ot) | 0, we = Math.imul(Xe, mt), ye = ye + Math.imul(Ce, et) | 0, ee = ee + Math.imul(Ce, at) | 0, ee = ee + Math.imul(Ye, et) | 0, we = we + Math.imul(Ye, at) | 0, ye = ye + Math.imul(ke, it) | 0, ee = ee + Math.imul(ke, tt) | 0, ee = ee + Math.imul(Ne, it) | 0, we = we + Math.imul(Ne, tt) | 0;
    let Et = (Le + ye | 0) + ((ee & 8191) << 13) | 0;
    Le = (we + (ee >>> 13) | 0) + (Et >>> 26) | 0, Et &= 67108863, ye = Math.imul(Ve, et), ee = Math.imul(Ve, at), ee = ee + Math.imul(Xe, et) | 0, we = Math.imul(Xe, at), ye = ye + Math.imul(Ce, it) | 0, ee = ee + Math.imul(Ce, tt) | 0, ee = ee + Math.imul(Ye, it) | 0, we = we + Math.imul(Ye, tt) | 0;
    let Pt = (Le + ye | 0) + ((ee & 8191) << 13) | 0;
    Le = (we + (ee >>> 13) | 0) + (Pt >>> 26) | 0, Pt &= 67108863, ye = Math.imul(Ve, it), ee = Math.imul(Ve, tt), ee = ee + Math.imul(Xe, it) | 0, we = Math.imul(Xe, tt);
    let Ot = (Le + ye | 0) + ((ee & 8191) << 13) | 0;
    return Le = (we + (ee >>> 13) | 0) + (Ot >>> 26) | 0, Ot &= 67108863, G[0] = Ct, G[1] = ge, G[2] = ie, G[3] = de, G[4] = Se, G[5] = _e, G[6] = Pe, G[7] = Re, G[8] = Me, G[9] = qe, G[10] = De, G[11] = Ue, G[12] = He, G[13] = je, G[14] = ft, G[15] = St, G[16] = Et, G[17] = Pt, G[18] = Ot, Le !== 0 && (G[19] = Le, l.length += 1), l;
  }
  return Math.imul || (I = Ie), s.Red = J, n0 = s, n0;
}
/*!
 * network.js - bitcoin networks for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * Copyright (c) 2019-2020, Jonathan Gonzalez (MIT License).
 * https://github.com/cash-org/cashnode
 */
var O1;
function Dh() {
  return O1 || (O1 = 1, function(e) {
    const c = Ur(), d = e;
    function w(a) {
      return k.from(a, "hex");
    }
    d.types = ["main", "testnet", "regtest", "simnet"];
    const g = {};
    g.type = "main", g.seeds = [
      "seed.flowee.cash",
      "seed-bch.bitcoinforks.org",
      "btccash-seeder.bitcoinunlimited.info",
      "seed.bchd.cash",
      "seed.bch.loping.net",
      "dnsseed.electroncash.de"
    ], g.magic = 3908297187, g.port = 8333, g.checkpointMap = {
      11111: w("1d7c6eb2fd42f55925e92efad68b61edd22fba29fde8783df744e26900000000"),
      33333: w("a6d0b5df7d0df069ceb1e736a216ad187a50b07aaa4e78748a58d52d00000000"),
      74e3: w("201a66b853f9e7814a820e2af5f5dc79c07144e31ce4c9a39339570000000000"),
      105e3: w("97dc6b1d15fbeef373a744fee0b254b0d2c820a3ae7f0228ce91020000000000"),
      134444: w("feb0d2420d4a18914c81ac30f494a5d4ff34cd15d34cfd2fb105000000000000"),
      168e3: w("63b703835cb735cb9a89d733cbe66f212f63795e0172ea619e09000000000000"),
      193e3: w("17138bca83bdc3e6f60f01177c3877a98266de40735f2a459f05000000000000"),
      21e4: w("2e3471a19b8e22b7f939c63663076603cf692f19837e34958b04000000000000"),
      216116: w("4edf231bf170234e6a811460f95c94af9464e41ee833b4f4b401000000000000"),
      225430: w("32595730b165f097e7b806a679cf7f3e439040f750433808c101000000000000"),
      25e4: w("14d2f24d29bed75354f3f88a5fb50022fc064b02291fdf873800000000000000"),
      279e3: w("407ebde958e44190fa9e810ea1fc3a7ef601c3b0a0728cae0100000000000000"),
      295e3: w("83a93246c67003105af33ae0b29dd66f689d0f0ff54e9b4d0000000000000000"),
      300255: w("b2f3a0f0de4120c1089d5f5280a263059f9b6e7c520428160000000000000000"),
      319400: w("3bf115fd057391587ca39a531c5d4989e1adec9b2e05c6210000000000000000"),
      343185: w("548536d48e7678fcfa034202dd45d4a76b1ad061f38b2b070000000000000000"),
      352940: w("ffc9520143e41c94b6e03c2fa3e62bb76b55ba2df45d75100000000000000000"),
      382320: w("b28afdde92b0899715e40362f56afdb20e3d135bedc68d0a0000000000000000"),
      401465: w("eed16cb3e893ed9366f27c39a9ecd95465d02e3ef40e45010000000000000000"),
      42e4: w("a1ff746b2d42b834cb7d6b8981b09c265c2cabc016e8cc020000000000000000"),
      44e4: w("9bf296b8de5f834f7635d5e258a434ad51b4dbbcf7c08c030000000000000000"),
      45e4: w("0ba2070c62cd9da1f8cef88a0648c661a411d33e728340010000000000000000"),
      46e4: w("8c25fc7e414d3e868d6ce0ec473c30ad44e7e8bc1b75ef000000000000000000"),
      47e4: w("89756d1ed75901437300af10d5ab69070a282e729c536c000000000000000000"),
      // UAHF fork block:
      478559: w("ec5e1a193601f25ff1d94b421ddead0dbefcb99cf91e65000000000000000000"),
      48e4: w("f93408ffca92d88a6e46d3b90046f97bde6be0c08e7ed40c0000000000000000"),
      49e4: w("d1c65d766c6dc270b8ff4f1edb052fb71dc2b4750ede8a010000000000000000"),
      5e5: w("01b2328355f4a4dc9efa5c610687304507b7df9f3f4de1050000000000000000"),
      // DAA fork block
      504031: w("9cabb6ee1b1a4c3b659d70be75810be83d0a0db665bf1e010000000000000000"),
      51e4: w("040e6b1f2f4cb198a5780d366bf81e591de257642b9267030000000000000000"),
      525e3: w("c994fba2bf168333fd969bcfa64f03ca1b62074f9a8f1b010000000000000000"),
      // Monolith Activation
      530359: w("0391c40195cf8ae3436f3955f1a8444f07468fd08bda1a010000000000000000"),
      // Magnetic Anomaly Activation:
      556767: w("6cd5e644acccee5743ce2e93c541d34169933b6eff2646000000000000000000"),
      // Great Wall Activation:
      582680: w("18cc7d8c39ca16dc749acb7278a471964f7dec6ae3b8b4010000000000000000"),
      // Graviton Activation:
      609136: w("b1c55b4f69aa2e3209c91ae413c355c65aacfa07b28bb4000000000000000000"),
      // Phonon Activation:
      635259: w("f73075b2c598f49b3a19558c070b52d5a5d6c21fefdf33000000000000000000"),
      // Axion Activation:
      661648: w("7d7510f907bdc9bd2907e56beceaef31f78f2c8b9d4c28040000000000000000"),
      664198: w("60824622a1d2b689fbb234ce2c5939ff92e8ed8c57902f0c0000000000000000"),
      680140: w("0b7c2ff6c3658cb3f846aa092145c44a1d45638b56482c230000000000000000"),
      // Tachyon Activation
      686621: w("45b7e5be980bd6e98a22f895fcdc80546d9f0a57f7e68f3c0000000000000000"),
      // Selectron Activation
      713661: w("8defaaea383ab73c75ceea3f08190f3ab5ccc70743f876060000000000000000"),
      // Gluon activation
      739536: w("617bfc596bce59b129242fe67b5afe0509560946cd04db060000000000000000"),
      // Jefferson activation
      766195: w("94e0246db72955957dedb431eb1096de9a5b715348c92b100000000000000000")
    }, g.lastCheckpoint = 525e3, g.halvingInterval = 21e4, g.genesis = {
      version: 1,
      hash: w("6fe28c0ab6f1b372c1a6a246ae63f74f931e8365e15a089c68d6190000000000"),
      prevBlock: w("0000000000000000000000000000000000000000000000000000000000000000"),
      merkleRoot: w("3ba3edfd7a7b12b27ac72c3e67768f617fc81bc3888a51323a9fb8aa4b1e5e4a"),
      time: 1231006505,
      bits: 486604799,
      nonce: 2083236893,
      height: 0
    }, g.genesisBlock = "0100000000000000000000000000000000000000000000000000000000000000000000003ba3edfd7a7b12b27ac72c3e67768f617fc81bc3888a51323a9fb8aa4b1e5e4a29ab5f49ffff001d1dac2b7c0101000000010000000000000000000000000000000000000000000000000000000000000000ffffffff4d04ffff001d0104455468652054696d65732030332f4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66207365636f6e64206261696c6f757420666f722062616e6b73ffffffff0100f2052a01000000434104678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5fac00000000", g.pow = {
      /**
       * Default target.
       * @const {BN}
       */
      limit: new c(
        "00000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
        "hex"
      ),
      /**
       * Compact pow limit.
       * @const {Number}
       * @default
       */
      bits: 486604799,
      /**
       * Half Life value used in DAA.
       * Represents the value of two days in seconds
       * @const {Number}
       * @default
       */
      halfLife: 172800,
      /**
       * Minimum chainwork for best chain.
       * @const {BN}
       */
      chainwork: new c(
        "0000000000000000000000000000000000000000013c95e14d4d9db91d671020",
        "hex"
      ),
      /**
       * Desired retarget period in seconds.
       * @const {Number}
       * @default
       */
      targetTimespan: 336 * 60 * 60,
      /**
       * Average block time.
       * @const {Number}
       * @default
       */
      targetSpacing: 600,
      /**
       * Retarget interval in blocks.
       * @const {Number}
       * @default
       */
      retargetInterval: 2016,
      /**
       * Whether to reset target if a block
       * has not been mined recently.
       * @const {Boolean}
       * @default
       */
      targetReset: !1,
      /**
       * Do not allow retargetting.
       * @const {Boolean}
       * @default
       */
      noRetargeting: !1
    }, g.block = {
      /**
       * Height at which bip34 was activated.
       * Used for avoiding bip30 checks.
       */
      bip34height: 227931,
      /**
       * Hash of the block that activated bip34.
       */
      bip34hash: w("b808089c756add1591b1d17bab44bba3fed9e02f942ab4894b02000000000000"),
      /**
       * Height at which bip65 was activated.
       */
      bip65height: 388381,
      /**
       * Hash of the block that activated bip65.
       */
      bip65hash: w("f035476cfaeb9f677c2cdad00fd908c556775ded24b6c2040000000000000000"),
      /**
       * Height at which bip66 was activated.
       */
      bip66height: 363725,
      /**
       * Hash of the block that activated bip66.
       */
      bip66hash: w("3109b588941188a9f1c2576aae462d729b8cce9da1ea79030000000000000000"),
      /**
       * Height at which UAHF was activated.
       */
      uahfHeight: 478558,
      /**
       * Hash of the block that activated UAHF.
       */
      uahfHash: w("432d350741fbf28f2e1486eabe2c4e143bfe2241af6518010000000000000000"),
      /**
       * Height at which DAA was activated.
       * November 13, 2017 hard fork
       */
      daaHeight: 504031,
      /**
       * Hash of the block that activated DAA
       */
      daaHash: w("9cabb6ee1b1a4c3b659d70be75810be83d0a0db665bf1e010000000000000000"),
      /**
       * Height at which Magnetic Anomaly was activated.
       * Nov 15, 2018 hard fork
       */
      magneticAnomalyHeight: 556767,
      /**
       * Hash of the block that activatd Magnetic Anomaly.
       * November 15, 2018
       */
      maaHash: w("6cd5e644acccee5743ce2e93c541d34169933b6eff2646000000000000000000"),
      /**
       * Height at which Great Wall was activated.
       * Wed, 15 May 2019 hard fork
       */
      greatWallActivationHeight: 582680,
      /**
       * Hash of the block that activated Great Wall.
       * May 15, 2019
       */
      gwaHash: w("18cc7d8c39ca16dc749acb7278a471964f7dec6ae3b8b4010000000000000000"),
      /**
       * Graviton Hard Fork activation time.
       * Nov 15, 2019 12:00:00 UTC
       */
      gravitonActivationTime: 1573819200,
      /**
       * Height at which Graviton was activated.
       * Friday, 15 November 2019 hard fork
       */
      gravitonHeight: 609136,
      /**
       * Hash of the block that activated Graviton.
       * November 15th, 2019
       */
      gravitonHash: w("b1c55b4f69aa2e3209c91ae413c355c65aacfa07b28bb4000000000000000000"),
      /**
       * Time at which Phonon was activated.
       * May 15, 2020 12:00:00 UTC
       */
      phononActivationTime: 1589544e3,
      /**
      * Height at which Phonon Activation occured.
      * May 15, 2020
      */
      phononHeight: 635259,
      /**
      * Hash of the block that activated Phonon.
      * May 15th 2020
      */
      phononHash: w("f73075b2c598f49b3a19558c070b52d5a5d6c21fefdf33000000000000000000"),
      /**
       * Time at which Asert3d-2i was activated.
       * November 15, 2020 12:00:00 UTC
       */
      asertActivationTime: 1605441600,
      /**
       * Time at which Axion was activated.
       * November 15, 2020 12:00:00 UTC
       */
      axionActivationTime: 1605441600,
      /**
      * Height at which Axion Activation occured.
      * November 15, 2020
      */
      axionHeight: 661648,
      /**
      * Hash of the block that activated Axion.
      * November 15th 2020
      */
      axionHash: w("7d7510f907bdc9bd2907e56beceaef31f78f2c8b9d4c28040000000000000000"),
      /**
       * Time at which Tachyon was activated.
       * May 15, 2021 12:00:00 UTC
       */
      tachyonActivationTime: 162108e4,
      /**
      * Height at which Tachyon Activation occured.
      * May 15, 2021 12:00:00 UTC
      */
      tachyonHeight: 686621,
      /**
      * Hash of the block that activated Tachyon.
      * May 15, 2021 12:00:00 UTC
      */
      tachyonHash: w("45b7e5be980bd6e98a22f895fcdc80546d9f0a57f7e68f3c0000000000000000"),
      /**
       * Time at which Selectron was activated.
       * November 15, 2021 12:00:00 UTC
       */
      selectronActivationTime: 1636977600,
      /**
      * Height at which Selectron Activation occured.
      *  November 15, 2021 12:00:00 UTC
      */
      selectronHeight: 713661,
      /**
      * Hash of the block that activated Selectron.
      * November 15, 2021 12:00:00 UTC
      */
      selectronHash: w("8defaaea383ab73c75ceea3f08190f3ab5ccc70743f876060000000000000000"),
      /**
       * Time at which Gluon was activated.
       * May 15, 2022 12:00:00 UTC
       */
      gluonActivationTime: 1652572800,
      /**
      * Height at which Gluon activation occured.
      *  May 15, 2022 12:00:00 UTC
      */
      gluonHeight: 739536,
      /**
      * Hash of the block that activated Gluon.
      * May 15, 2022 12:00:00 UTC
      */
      gluonHash: w("617bfc596bce59b129242fe67b5afe0509560946cd04db060000000000000000"),
      /**
       * Time at which Jefferson was activated.
       * November 15, 2022 12:00:00 UTC
       */
      jeffersonActivationTime: 1668470400,
      /**
      * Height at which Gluon activation occured.
      *  November 15, 2022 12:00:00 UTC
      */
      jeffersonHeight: 766195,
      /**
      * Hash of the block that activated Gluon.
      * November 15, 2022 12:00:00 UTC
      */
      jeffersonHash: w("94e0246db72955957dedb431eb1096de9a5b715348c92b100000000000000000"),
      /**
       * Time at which Wellington was activated.
       * May 15, 2023 12:00:00 UTC
       */
      wellingtonActivationTime: 1684108800,
      /**
       * Safe height to start pruning.
       */
      pruneAfterHeight: 1e3,
      /**
       * Safe number of blocks to keep.
       */
      keepBlocks: 288,
      /**
       * Age used for the time delta to
       * determine whether the chain is synced.
       */
      maxTipAge: 1440 * 60,
      /**
       * Height at which block processing is
       * slow enough that we can output
       * logs without spamming.
       */
      slowHeight: 325e3
    }, g.bip30 = {
      91842: w("eccae000e3c8e4e093936360431f3b7603c563c1ff6181390a4d0a0000000000"),
      91880: w("21d77ccb4c08386a04ac0196ae10f6a1d2c2a377558ca190f143070000000000")
    }, g.activationThreshold = 1916, g.minerWindow = 2016, g.deployments = {
      csv: {
        name: "csv",
        bit: 0,
        startTime: 1462060800,
        // May 1st, 2016
        timeout: 1493596800,
        // May 1st, 2017
        threshold: -1,
        window: -1,
        required: !1,
        force: !0
      },
      testdummy: {
        name: "testdummy",
        bit: 28,
        startTime: 1199145601,
        // January 1, 2008
        timeout: 1230767999,
        // December 31, 2008
        threshold: -1,
        window: -1,
        required: !1,
        force: !0
      }
    }, g.deploys = [
      g.deployments.csv,
      g.deployments.testdummy
    ], g.keyPrefix = {
      privkey: 128,
      xpubkey: 76067358,
      xprivkey: 76066276,
      xpubkey58: "xpub",
      xprivkey58: "xprv",
      coinType: 0
    }, g.addressPrefix = {
      pubkeyhash: 0,
      scripthash: 5,
      cashaddr: "ecash"
    }, g.requireStandard = !0, g.rpcPort = 8332, g.walletPort = 8334, g.minRelay = 1e3, g.feeRate = 1e5, g.maxFeeRate = 4e5, g.selfConnect = !1, g.requestMempool = !1;
    const f = {};
    f.type = "testnet", f.seeds = [
      "testnet-seed.bitcoinabc.org",
      // Bitcoin ABC seeder
      "testnet-seed-abc.bitcoinforks.org",
      // bitcoinforks seeders
      "testnet-seed.deadalnix.me",
      // Amaury SCHET
      "testnet-seed.bchd.cash"
    ], f.magic = 4109624820, f.port = 18333, f.checkpointMap = {
      546: w("70cb6af7ebbcb1315d3414029c556c55f3e2fc353c4c9063a76c932a00000000"),
      1e4: w("02a1b43f52591e53b660069173ac83b675798e12599dbb0442b7580000000000"),
      5e4: w("0c6ceabe803cec55ba2831e445956d0a43ba9521743a802cddac7e0700000000"),
      9e4: w("cafc21e17faf90461a5905aa03302c394912651ed9475ae711723e0d00000000"),
      1e5: w("1e0a16bbadccde1d80c66597b1939e45f91b570d29f95fc158299e0000000000"),
      14e4: w("92c0877b54c556889b72175ccbe0c91a1208f6ef7efb2c006101062300000000"),
      17e4: w("508125560d202b89757889bb0e49c712477be20440058f05db4f0e0000000000"),
      21e4: w("32365454b5f29a826bff8ad9b0448cad0072fc73d50e482d91a3dece00000000"),
      23e4: w("b11a447e62643e0b27406eb0fc270cb8126d7b5b70822fb642d9513400000000"),
      27e4: w("1c42b811cf9c163932f6e95ec55bf9b5e2cb5324e7e93001572e000000000000"),
      3e5: w("a141bf3972424853f04367b47995e220e0b5a2706e5618766f22000000000000"),
      34e4: w("67edd4d92e405608109164b15f92b193377d49325b0ed036739c010000000000"),
      35e4: w("592b44bc0f7a4286cf07ead8497114c6952c1c7dea7305193deacf8e00000000"),
      39e4: w("f217e183484fb6d695609cc71fa2ae24c3020943407e0150b298030000000000"),
      42e4: w("de9e73a3b91fbb014e036e8583a17d6b638a699aeb2de8573d12580800000000"),
      46e4: w("2e8baaffc107f15c87aebe01664b63d07476afa53bcbada1281a030000000000"),
      5e5: w("06f60922a2aab2757317820fc6ffaf6a470e2cbb0f63a2aac0a7010000000000"),
      54e4: w("8dd0bebfbc4878f5af09d3e848dcc57827d2c1cebea8ec5d8cbe420500000000"),
      57e4: w("87acbd4cd3c40ec9bd648f8698ed226b31187274c06cc7a9af79030000000000"),
      6e5: w("169a05b3bb04b7d13ad628915630900a5ed2e89f3a9dc6064f62000000000000"),
      63e4: w("bbbe117035432a6a4effcb297207a02b031735b43e0d19a9217c000000000000"),
      67e4: w("080bfe75caed8624fcfdfbc65973c8f962d7bdc495a891f5d16b7d0000000000"),
      7e5: w("c14d3f6a1e7c7d66fd940951e44f3c3be1273bea4d2ab1786140000000000000"),
      74e4: w("b3b423f0462fd78a01e4f1a59a2737a0525b5dbb9bba0b4634f9000000000000"),
      78e4: w("0381582e34c3755964dc2813e2b33e521e5596367144e1670851050000000000"),
      8e5: w("03b5f8ab257e02903f509f5ff2935220eec2e77b1819651d099b200000000000"),
      84e4: w("dac1648107bd4394e57e4083c86d42b548b1cfb119665f179ea80a0000000000"),
      88e4: w("ff90b4bb07eded8e96715bf595c09c7d21dd8c61b8306ff48705d60000000000"),
      9e5: w("9bd8ac418beeb1a2cf5d68c8b5c6ebaa947a5b766e5524898d6f350000000000"),
      94e4: w("c98f1651a475b00d12f8c25eb166ee843affaa90610e36a19d68030000000000"),
      98e4: w("cc8e9774542d044a9698ca2336ae02d5987157e676f1c76aa3877c0000000000"),
      101e4: w("9d9fb11abc2712d80368229e97b8d827b2a07d27eb5335e5c924000000000000"),
      105e4: w("d8190cf0af7f08e179cab51d67db0b44b87951a78f7fdc31b4a01a0000000000"),
      109e4: w("41f83c47e02a8852d033ac884df7cca877726b384a461fb9e802000000000000"),
      113e4: w("b8d63c3830e3c5685d3f7d2c2271fdb2ce3315619a473c324ea1a4ce00000000"),
      // UAHF fork block.
      1155875: w("38f1ae7f0ea8c1b589884c5fbd0b83721e3ab6759a4b897206857cf100000000"),
      // DAA fork block.
      1188697: w("fb47e0ab0d2448f71192a09fe61bc9c46cd3b4e7bd778091d00e170000000000"),
      // GWA fork block.
      1303885: w("d323ee8d7ede5bef62f84db98f93cc8c47fae4f02e8938914700000000000000"),
      // Graviton fork block
      1341712: w("5ba3af2992073940ed9e5a9d9eef9194bbfba905d92b202eea44fcff00000000"),
      // Phonon fork block.
      1378461: w("d715e9fab7bbdf301081eeadbe6e931db282cf6b92b1365f9b50f59900000000")
    }, f.lastCheckpoint = 1341712, f.halvingInterval = 21e4, f.genesis = {
      version: 1,
      hash: w("43497fd7f826957108f4a30fd9cec3aeba79972084e90ead01ea330900000000"),
      prevBlock: w("0000000000000000000000000000000000000000000000000000000000000000"),
      merkleRoot: w("3ba3edfd7a7b12b27ac72c3e67768f617fc81bc3888a51323a9fb8aa4b1e5e4a"),
      time: 1296688602,
      bits: 486604799,
      nonce: 414098458,
      height: 0
    }, f.genesisBlock = "0100000000000000000000000000000000000000000000000000000000000000000000003ba3edfd7a7b12b27ac72c3e67768f617fc81bc3888a51323a9fb8aa4b1e5e4adae5494dffff001d1aa4ae180101000000010000000000000000000000000000000000000000000000000000000000000000ffffffff4d04ffff001d0104455468652054696d65732030332f4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66207365636f6e64206261696c6f757420666f722062616e6b73ffffffff0100f2052a01000000434104678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5fac00000000", f.pow = {
      limit: new c(
        "00000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
        "hex"
      ),
      bits: 486604799,
      chainwork: new c(
        "00000000000000000000000000000000000000000000006956e7298fb096a1cc",
        "hex"
      ),
      halfLife: 172800,
      targetTimespan: 336 * 60 * 60,
      targetSpacing: 600,
      retargetInterval: 2016,
      targetReset: !0,
      noRetargeting: !1
    }, f.block = {
      bip34height: 21111,
      bip34hash: w("f88ecd9912d00d3f5c2a8e0f50417d3e415c75b3abe584346da9b32300000000"),
      bip65height: 581885,
      bip65hash: w("b61e864fbec41dfaf09da05d1d76dc068b0dd82ee7982ff255667f0000000000"),
      bip66height: 330776,
      bip66hash: w("82a14b9e5ea81d4832b8e2cd3c2a6092b5a3853285a8995ec4c8042100000000"),
      uahfHeight: 1155875,
      uahfHash: w("38f1ae7f0ea8c1b589884c5fbd0b83721e3ab6759a4b897206857cf100000000"),
      daaHeight: 1188697,
      daaHash: w("fb47e0ab0d2448f71192a09fe61bc9c46cd3b4e7bd778091d00e170000000000"),
      magneticAnomalyHeight: 1267996,
      maaHash: w("244b485f4871816d3ca060f6f363abe81c6fa1bed45c09e0fa01000000000000"),
      greatWallActivationHeight: 1303885,
      gwaHash: w("d323ee8d7ede5bef62f84db98f93cc8c47fae4f02e8938914700000000000000"),
      gravitonActivationTime: 1573819200,
      gravitonHeight: 1341712,
      gravitonHash: w("5ba3af2992073940ed9e5a9d9eef9194bbfba905d92b202eea44fcff00000000"),
      phononActivationTime: 1589544e3,
      asertActivationTime: 1605441600,
      pruneAfterHeight: 1e3,
      keepBlocks: 1e4,
      maxTipAge: 1440 * 60,
      slowHeight: 95e4
    }, f.bip30 = {}, f.activationThreshold = 1512, f.minerWindow = 2016, f.deployments = {
      csv: {
        name: "csv",
        bit: 0,
        startTime: 1456790400,
        // March 1st, 2016
        timeout: 1493596800,
        // May 1st, 2017
        threshold: -1,
        window: -1,
        required: !1,
        force: !0
      },
      testdummy: {
        name: "testdummy",
        bit: 28,
        startTime: 1199145601,
        // January 1, 2008
        timeout: 1230767999,
        // December 31, 2008
        threshold: -1,
        window: -1,
        required: !1,
        force: !0
      }
    }, f.deploys = [
      f.deployments.csv,
      f.deployments.testdummy
    ], f.keyPrefix = {
      privkey: 239,
      xpubkey: 70617039,
      xprivkey: 70615956,
      xpubkey58: "tpub",
      xprivkey58: "tprv",
      coinType: 1
    }, f.addressPrefix = {
      pubkeyhash: 111,
      scripthash: 196,
      cashaddr: "xectest"
    }, f.requireStandard = !1, f.rpcPort = 18332, f.walletPort = 18334, f.minRelay = 1e3, f.feeRate = 2e4, f.maxFeeRate = 6e4, f.selfConnect = !1, f.requestMempool = !1;
    const n = {};
    n.type = "regtest", n.seeds = [
      "127.0.0.1"
    ], n.magic = 4206867930, n.port = 48444, n.checkpointMap = {}, n.lastCheckpoint = 0, n.halvingInterval = 150, n.genesis = {
      version: 1,
      hash: w("06226e46111a0b59caaf126043eb5bbf28c34f3a5e332a1fc7b2b73cf188910f"),
      prevBlock: w("0000000000000000000000000000000000000000000000000000000000000000"),
      merkleRoot: w("3ba3edfd7a7b12b27ac72c3e67768f617fc81bc3888a51323a9fb8aa4b1e5e4a"),
      time: 1296688602,
      bits: 545259519,
      nonce: 2,
      height: 0
    }, n.genesisBlock = "0100000000000000000000000000000000000000000000000000000000000000000000003ba3edfd7a7b12b27ac72c3e67768f617fc81bc3888a51323a9fb8aa4b1e5e4adae5494dffff7f20020000000101000000010000000000000000000000000000000000000000000000000000000000000000ffffffff4d04ffff001d0104455468652054696d65732030332f4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66207365636f6e64206261696c6f757420666f722062616e6b73ffffffff0100f2052a01000000434104678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5fac00000000", n.pow = {
      limit: new c(
        "7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
        "hex"
      ),
      bits: 545259519,
      chainwork: new c(
        "0000000000000000000000000000000000000000000000000000000000000002",
        "hex"
      ),
      halfLife: 172800,
      targetTimespan: 336 * 60 * 60,
      targetSpacing: 600,
      retargetInterval: 2016,
      targetReset: !0,
      noRetargeting: !0
    }, n.block = {
      bip34height: 1e8,
      bip34hash: null,
      bip65height: 1351,
      bip65hash: null,
      bip66height: 1251,
      bip66hash: null,
      uahfHeight: 0,
      uahfHash: null,
      daaHeight: 0,
      daaHash: null,
      magneticAnomalyHeight: 0,
      maaHash: null,
      greatWallActivationHeight: 0,
      gwaHash: null,
      gravitonHeight: 0,
      gravitonHash: null,
      phononActivationTime: 0,
      asertActivationTime: 0,
      pruneAfterHeight: 1e3,
      keepBlocks: 1e4,
      maxTipAge: 4294967295,
      slowHeight: 0
    }, n.bip30 = {}, n.activationThreshold = 108, n.minerWindow = 144, n.deployments = {
      csv: {
        name: "csv",
        bit: 0,
        startTime: 0,
        timeout: 4294967295,
        threshold: -1,
        window: -1,
        required: !1,
        force: !0
      },
      testdummy: {
        name: "testdummy",
        bit: 28,
        startTime: 0,
        timeout: 4294967295,
        threshold: -1,
        window: -1,
        required: !1,
        force: !0
      }
    }, n.deploys = [
      n.deployments.csv,
      n.deployments.testdummy
    ], n.keyPrefix = {
      privkey: 90,
      xpubkey: 3937729029,
      xprivkey: 3937666247,
      xpubkey58: "rpub",
      xprivkey58: "rprv",
      coinType: 1
    }, n.addressPrefix = {
      pubkeyhash: 60,
      scripthash: 38,
      cashaddr: "xecreg"
    }, n.requireStandard = !1, n.rpcPort = 48332, n.walletPort = 48334, n.minRelay = 1e3, n.feeRate = 2e4, n.maxFeeRate = 6e4, n.selfConnect = !0, n.requestMempool = !0;
    const u = {};
    u.type = "simnet", u.seeds = [
      "127.0.0.1"
    ], u.magic = 4076531172, u.port = 18555, u.checkpointMap = {}, u.lastCheckpoint = 0, u.halvingInterval = 21e4, u.genesis = {
      version: 1,
      hash: w("f67ad7695d9b662a72ff3d8edbbb2de0bfa67b13974bb9910d116d5cbd863e68"),
      prevBlock: w("0000000000000000000000000000000000000000000000000000000000000000"),
      merkleRoot: w("3ba3edfd7a7b12b27ac72c3e67768f617fc81bc3888a51323a9fb8aa4b1e5e4a"),
      time: 1401292357,
      bits: 545259519,
      nonce: 2,
      height: 0
    }, u.genesisBlock = "0100000000000000000000000000000000000000000000000000000000000000000000003ba3edfd7a7b12b27ac72c3e67768f617fc81bc3888a51323a9fb8aa4b1e5e4a45068653ffff7f20020000000101000000010000000000000000000000000000000000000000000000000000000000000000ffffffff4d04ffff001d0104455468652054696d65732030332f4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66207365636f6e64206261696c6f757420666f722062616e6b73ffffffff0100f2052a01000000434104678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5fac00000000", u.pow = {
      limit: new c(
        // High target of 0x207fffff (545259519)
        "7fffff0000000000000000000000000000000000000000000000000000000000",
        "hex"
      ),
      bits: 545259519,
      chainwork: new c(
        "0000000000000000000000000000000000000000000000000000000000000002",
        "hex"
      ),
      halfLife: 172800,
      targetTimespan: 336 * 60 * 60,
      targetSpacing: 600,
      retargetInterval: 2016,
      targetReset: !0,
      noRetargeting: !1
    }, u.block = {
      bip34height: 0,
      bip34hash: w("f67ad7695d9b662a72ff3d8edbbb2de0bfa67b13974bb9910d116d5cbd863e68"),
      bip65height: 0,
      bip65hash: w("f67ad7695d9b662a72ff3d8edbbb2de0bfa67b13974bb9910d116d5cbd863e68"),
      bip66height: 0,
      bip66hash: w("f67ad7695d9b662a72ff3d8edbbb2de0bfa67b13974bb9910d116d5cbd863e68"),
      uahfHeight: 0,
      uahfHash: null,
      daaHeight: 0,
      daaHash: null,
      magneticAnomalyActivationTime: 15423e5,
      greatWallActivationTime: 1557921600,
      pruneAfterHeight: 1e3,
      keepBlocks: 1e4,
      maxTipAge: 4294967295,
      slowHeight: 0
    }, u.bip30 = {}, u.activationThreshold = 75, u.minerWindow = 100, u.deployments = {
      csv: {
        name: "csv",
        bit: 0,
        startTime: 0,
        // March 1st, 2016
        timeout: 4294967295,
        // May 1st, 2017
        threshold: -1,
        window: -1,
        required: !1,
        force: !0
      },
      testdummy: {
        name: "testdummy",
        bit: 28,
        startTime: 1199145601,
        // January 1, 2008
        timeout: 1230767999,
        // December 31, 2008
        threshold: -1,
        window: -1,
        required: !1,
        force: !0
      }
    }, u.deploys = [
      u.deployments.csv,
      u.deployments.testdummy
    ], u.keyPrefix = {
      privkey: 100,
      xpubkey: 69254458,
      xprivkey: 69253376,
      xpubkey58: "spub",
      xprivkey58: "sprv",
      coinType: 115
    }, u.addressPrefix = {
      pubkeyhash: 63,
      scripthash: 123,
      cashaddr: "xecsim"
    }, u.requireStandard = !1, u.rpcPort = 18556, u.walletPort = 18558, u.minRelay = 1e3, u.feeRate = 2e4, u.maxFeeRate = 6e4, u.selfConnect = !1, u.requestMempool = !1, d.main = g, d.testnet = f, d.regtest = n, d.simnet = u;
  }(Qo)), Qo;
}
var s0 = {};
/*!
 * consensus.js - consensus constants and helpers for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var _1;
function Xt() {
  return _1 || (_1 = 1, function(e) {
    const c = nt, d = Ur();
    e.COIN = 1e8, e.MAX_MONEY = 21e6 * e.COIN, e.BASE_REWARD = 50 * e.COIN, e.HALF_REWARD = Math.floor(e.BASE_REWARD / 2), e.MAX_BLOCK_SIZE = 1e6, e.MAX_FORK_BLOCK_SIZE = 32e6, e.MAX_TX_VERSION = 2, e.MAX_TX_SIZE = 1e6, e.MAX_TX_SIGCHECKS = 3e3, e.MAX_BLOCK_SIGCHECKS_RATIO = 141, e.MIN_TX_SIZE = 100, e.MAX_RAW_BLOCK_SIZE = 32e6, e.MAX_BLOCK_SIGOPS_PER_MB = 2e4, e.MAX_TX_SIGOPS = 2e4, e.MAX_BLOCK_SIGOPS_COST = 8e4, e.MAX_COINBASE_SCRIPTSIG_SIZE = 100, e.COINBASE_RULE_ADDR = [
      "ecash:pqnqv9lt7e5vjyp0w88zf2af0l92l8rxdg2jj94l5j",
      "ecash:prfhcnyqnl5cgrnmlfmms675w93ld7mvvqd0y8lz07"
    ], e.MEDIAN_TIMESPAN = 11, e.VERSION_TOP_BITS = 536870912, e.VERSION_TOP_MASK = 3758096384, e.COINBASE_MATURITY = 100, e.LOCKTIME_THRESHOLD = 5e8, e.SEQUENCE_DISABLE_FLAG = 1 << 31 >>> 0, e.SEQUENCE_TYPE_FLAG = 1 << 22, e.SEQUENCE_GRANULARITY = 9, e.SEQUENCE_MASK = 65535, e.MAX_SCRIPT_SIZE = 1e4, e.MAX_SCRIPT_STACK = 1e3, e.MAX_SCRIPT_PUSH = 520, e.MAX_SCRIPT_OPS = 201, e.MAX_MULTISIG_PUBKEYS = 20, e.BIP16_TIME = 1333238400, e.ZERO_HASH = k.alloc(32, 0), e.NULL_HASH = "0000000000000000000000000000000000000000000000000000000000000000", e.ANTI_REPLAY_COMMITMENT = "Bitcoin: A Peer-to-Peer Electronic Cash System", e.fromCompact = function(g) {
      if (g === 0)
        return new d(0);
      const f = g >>> 24, n = g >>> 23 & 1;
      let u = g & 8388607, a;
      return f <= 3 ? (u >>>= 8 * (3 - f), a = new d(u)) : (a = new d(u), a.iushln(8 * (f - 3))), n && a.ineg(), a;
    }, e.toCompact = function(g) {
      if (g.isZero())
        return 0;
      let f = g.byteLength(), n;
      f <= 3 ? (n = g.toNumber(), n <<= 8 * (3 - f)) : n = g.ushrn(8 * (f - 3)).toNumber(), n & 8388608 && (n >>= 8, f++);
      let u = f << 24 | n;
      return g.isNeg() && (u |= 8388608), u >>>= 0, u;
    }, e.verifyPOW = function(g, f) {
      const n = e.fromCompact(f);
      return !(n.isNeg() || n.isZero() || n.bitLength() > 256 || new d(g, "le").gt(n));
    }, e.getReward = function(g, f) {
      c(g >= 0, "Bad height for reward.");
      const n = Math.floor(g / f);
      return n >= 33 ? 0 : n === 0 ? e.BASE_REWARD : e.HALF_REWARD >>> n - 1;
    }, e.hasBit = function(g, f) {
      const n = e.VERSION_TOP_MASK, u = e.VERSION_TOP_BITS, a = (g & n) >>> 0, s = 1 << f;
      return a === u && (g & s) !== 0;
    }, e.maxBlockSigops = function(g) {
      return (1 + ((g - 1) / 1e6 | 0)) * e.MAX_BLOCK_SIGOPS_PER_MB;
    }, e.maxBlockSigchecks = function(g) {
      return g / e.MAX_BLOCK_SIGCHECKS_RATIO;
    };
  }(s0)), s0;
}
var o0;
function di() {
}
di.prototype = /* @__PURE__ */ Object.create(null);
function _t() {
  _t.init.call(this);
}
_t.EventEmitter = _t;
_t.usingDomains = !1;
_t.prototype.domain = void 0;
_t.prototype._events = void 0;
_t.prototype._maxListeners = void 0;
_t.defaultMaxListeners = 10;
_t.init = function() {
  this.domain = null, _t.usingDomains && o0.active && !(this instanceof o0.Domain) && (this.domain = o0.active), (!this._events || this._events === Object.getPrototypeOf(this)._events) && (this._events = new di(), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
};
_t.prototype.setMaxListeners = function(c) {
  if (typeof c != "number" || c < 0 || isNaN(c))
    throw new TypeError('"n" argument must be a positive number');
  return this._maxListeners = c, this;
};
function F8(e) {
  return e._maxListeners === void 0 ? _t.defaultMaxListeners : e._maxListeners;
}
_t.prototype.getMaxListeners = function() {
  return F8(this);
};
function Rm(e, c, d) {
  if (c)
    e.call(d);
  else
    for (var w = e.length, g = $n(e, w), f = 0; f < w; ++f)
      g[f].call(d);
}
function Pm(e, c, d, w) {
  if (c)
    e.call(d, w);
  else
    for (var g = e.length, f = $n(e, g), n = 0; n < g; ++n)
      f[n].call(d, w);
}
function km(e, c, d, w, g) {
  if (c)
    e.call(d, w, g);
  else
    for (var f = e.length, n = $n(e, f), u = 0; u < f; ++u)
      n[u].call(d, w, g);
}
function Bm(e, c, d, w, g, f) {
  if (c)
    e.call(d, w, g, f);
  else
    for (var n = e.length, u = $n(e, n), a = 0; a < n; ++a)
      u[a].call(d, w, g, f);
}
function Mm(e, c, d, w) {
  if (c)
    e.apply(d, w);
  else
    for (var g = e.length, f = $n(e, g), n = 0; n < g; ++n)
      f[n].apply(d, w);
}
_t.prototype.emit = function(c) {
  var d, w, g, f, n, u, a, s = c === "error";
  if (u = this._events, u)
    s = s && u.error == null;
  else if (!s)
    return !1;
  if (a = this.domain, s) {
    if (d = arguments[1], a)
      d || (d = new Error('Uncaught, unspecified "error" event')), d.domainEmitter = this, d.domain = a, d.domainThrown = !1, a.emit("error", d);
    else {
      if (d instanceof Error)
        throw d;
      var i = new Error('Uncaught, unspecified "error" event. (' + d + ")");
      throw i.context = d, i;
    }
    return !1;
  }
  if (w = u[c], !w)
    return !1;
  var p = typeof w == "function";
  switch (g = arguments.length, g) {
    // fast cases
    case 1:
      Rm(w, p, this);
      break;
    case 2:
      Pm(w, p, this, arguments[1]);
      break;
    case 3:
      km(w, p, this, arguments[1], arguments[2]);
      break;
    case 4:
      Bm(w, p, this, arguments[1], arguments[2], arguments[3]);
      break;
    // slower
    default:
      for (f = new Array(g - 1), n = 1; n < g; n++)
        f[n - 1] = arguments[n];
      Mm(w, p, this, f);
  }
  return !0;
};
function H8(e, c, d, w) {
  var g, f, n;
  if (typeof d != "function")
    throw new TypeError('"listener" argument must be a function');
  if (f = e._events, f ? (f.newListener && (e.emit(
    "newListener",
    c,
    d.listener ? d.listener : d
  ), f = e._events), n = f[c]) : (f = e._events = new di(), e._eventsCount = 0), !n)
    n = f[c] = d, ++e._eventsCount;
  else if (typeof n == "function" ? n = f[c] = w ? [d, n] : [n, d] : w ? n.unshift(d) : n.push(d), !n.warned && (g = F8(e), g && g > 0 && n.length > g)) {
    n.warned = !0;
    var u = new Error("Possible EventEmitter memory leak detected. " + n.length + " " + c + " listeners added. Use emitter.setMaxListeners() to increase limit");
    u.name = "MaxListenersExceededWarning", u.emitter = e, u.type = c, u.count = n.length, Nm(u);
  }
  return e;
}
function Nm(e) {
  typeof console.warn == "function" ? console.warn(e) : console.log(e);
}
_t.prototype.addListener = function(c, d) {
  return H8(this, c, d, !1);
};
_t.prototype.on = _t.prototype.addListener;
_t.prototype.prependListener = function(c, d) {
  return H8(this, c, d, !0);
};
function L8(e, c, d) {
  var w = !1;
  function g() {
    e.removeListener(c, g), w || (w = !0, d.apply(e, arguments));
  }
  return g.listener = d, g;
}
_t.prototype.once = function(c, d) {
  if (typeof d != "function")
    throw new TypeError('"listener" argument must be a function');
  return this.on(c, L8(this, c, d)), this;
};
_t.prototype.prependOnceListener = function(c, d) {
  if (typeof d != "function")
    throw new TypeError('"listener" argument must be a function');
  return this.prependListener(c, L8(this, c, d)), this;
};
_t.prototype.removeListener = function(c, d) {
  var w, g, f, n, u;
  if (typeof d != "function")
    throw new TypeError('"listener" argument must be a function');
  if (g = this._events, !g)
    return this;
  if (w = g[c], !w)
    return this;
  if (w === d || w.listener && w.listener === d)
    --this._eventsCount === 0 ? this._events = new di() : (delete g[c], g.removeListener && this.emit("removeListener", c, w.listener || d));
  else if (typeof w != "function") {
    for (f = -1, n = w.length; n-- > 0; )
      if (w[n] === d || w[n].listener && w[n].listener === d) {
        u = w[n].listener, f = n;
        break;
      }
    if (f < 0)
      return this;
    if (w.length === 1) {
      if (w[0] = void 0, --this._eventsCount === 0)
        return this._events = new di(), this;
      delete g[c];
    } else
      qm(w, f);
    g.removeListener && this.emit("removeListener", c, u || d);
  }
  return this;
};
_t.prototype.off = function(e, c) {
  return this.removeListener(e, c);
};
_t.prototype.removeAllListeners = function(c) {
  var d, w;
  if (w = this._events, !w)
    return this;
  if (!w.removeListener)
    return arguments.length === 0 ? (this._events = new di(), this._eventsCount = 0) : w[c] && (--this._eventsCount === 0 ? this._events = new di() : delete w[c]), this;
  if (arguments.length === 0) {
    for (var g = Object.keys(w), f = 0, n; f < g.length; ++f)
      n = g[f], n !== "removeListener" && this.removeAllListeners(n);
    return this.removeAllListeners("removeListener"), this._events = new di(), this._eventsCount = 0, this;
  }
  if (d = w[c], typeof d == "function")
    this.removeListener(c, d);
  else if (d)
    do
      this.removeListener(c, d[d.length - 1]);
    while (d[0]);
  return this;
};
_t.prototype.listeners = function(c) {
  var d, w, g = this._events;
  return g ? (d = g[c], d ? typeof d == "function" ? w = [d.listener || d] : w = zm(d) : w = []) : w = [], w;
};
_t.listenerCount = function(e, c) {
  return typeof e.listenerCount == "function" ? e.listenerCount(c) : K8.call(e, c);
};
_t.prototype.listenerCount = K8;
function K8(e) {
  var c = this._events;
  if (c) {
    var d = c[e];
    if (typeof d == "function")
      return 1;
    if (d)
      return d.length;
  }
  return 0;
}
_t.prototype.eventNames = function() {
  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
};
function qm(e, c) {
  for (var d = c, w = d + 1, g = e.length; w < g; d += 1, w += 1)
    e[d] = e[w];
  e.pop();
}
function $n(e, c) {
  for (var d = new Array(c); c--; )
    d[c] = e[c];
  return d;
}
function zm(e) {
  for (var c = new Array(e.length), d = 0; d < c.length; ++d)
    c[d] = e[d].listener || e[d];
  return c;
}
var Tm = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  EventEmitter: _t,
  default: _t
}), Cm = /* @__PURE__ */ Oh(Tm), a0 = {};
/*!
 * util.js - utils for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var R1;
function ur() {
  return R1 || (R1 = 1, function(e) {
    const c = nt, d = e;
    d.bench = function(g) {
      if (!It.hrtime) {
        const f = Date.now();
        if (g) {
          const [s, i] = g, p = s * 1e3 + i / 1e6;
          return f - p;
        }
        const n = f % 1e3, u = (f - n) / 1e3, a = n * 1e6;
        return [u, a];
      }
      if (g) {
        const [f, n] = It.hrtime(g);
        return f * 1e3 + n / 1e6;
      }
      return It.hrtime();
    }, d.now = function() {
      return Math.floor(Date.now() / 1e3);
    }, d.ms = function() {
      return Date.now();
    }, d.date = function(g) {
      return g == null && (g = d.now()), new Date(g * 1e3).toISOString().slice(0, -5) + "Z";
    }, d.time = function(g) {
      return g == null ? d.now() : new Date(g) / 1e3 | 0;
    }, d.revHex = function(g) {
      return c(k.isBuffer(g)), k.from(g).reverse().toString("hex");
    }, d.fromRev = function(g) {
      return c(typeof g == "string"), c((g.length & 1) === 0), k.from(g, "hex").reverse();
    };
  }(a0)), a0;
}
/*!
 * timedata.js - time management for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var f0, P1;
function V8() {
  if (P1) return f0;
  P1 = 1;
  const e = Cm, c = ur(), d = Rh();
  class w extends e {
    /**
     * Create time data.
     * @constructor
     * @param {Number} [limit=200]
     */
    constructor(n) {
      super(), n == null && (n = 200), this.samples = [], this.known = /* @__PURE__ */ new Map(), this.limit = n, this.offset = 0, this.checked = !1;
    }
    /**
     * Add time data.
     * @param {String} id
     * @param {Number} time
     */
    add(n, u) {
      if (this.samples.length >= this.limit || this.known.has(n))
        return;
      const a = u - c.now();
      if (this.known.set(n, a), d.insert(this.samples, a, g), this.emit("sample", a, this.samples.length), this.samples.length >= 5 && this.samples.length % 2 === 1) {
        let s = this.samples[this.samples.length >>> 1];
        if (Math.abs(s) >= 4200) {
          if (!this.checked) {
            let i = !1;
            for (const p of this.samples)
              if (p !== 0 && Math.abs(p) < 300) {
                i = !0;
                break;
              }
            i || (this.checked = !0, this.emit("mismatch"));
          }
          s = 0;
        }
        this.offset = s, this.emit("offset", this.offset);
      }
    }
    /**
     * Get the current adjusted time.
     * @returns {Number} Adjusted Time.
     */
    now() {
      return c.now() + this.offset;
    }
    /**
     * Adjust a timestamp.
     * @param {Number} time
     * @returns {Number} Adjusted Time.
     */
    adjust(n) {
      return n + this.offset;
    }
    /**
     * Unadjust a timestamp.
     * @param {Number} time
     * @returns {Number} Local Time.
     */
    local(n) {
      return n - this.offset;
    }
    /**
     * Get the current adjusted time in milliseconds.
     * @returns {Number} Adjusted Time.
     */
    ms() {
      return Date.now() + this.offset * 1e3;
    }
  }
  function g(f, n) {
    return f - n;
  }
  return f0 = w, f0;
}
/*!
 * network.js - network object for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var c0, k1;
function _r() {
  if (k1) return c0;
  k1 = 1;
  const e = nt, c = Rh(), d = Dh(), w = Xt(), g = V8();
  class f {
    /**
     * Create a network.
     * @constructor
     * @param {Object} options
     */
    constructor(o) {
      e(!f[o.type], "Cannot create two networks."), this.type = o.type, this.seeds = o.seeds, this.magic = o.magic, this.port = o.port, this.checkpointMap = o.checkpointMap, this.lastCheckpoint = o.lastCheckpoint, this.checkpoints = [], this.halvingInterval = o.halvingInterval, this.genesis = o.genesis, this.genesisBlock = o.genesisBlock, this.pow = o.pow, this.block = o.block, this.bip30 = o.bip30, this.activationThreshold = o.activationThreshold, this.minerWindow = o.minerWindow, this.deployments = o.deployments, this.deploys = o.deploys, this.unknownBits = ~w.VERSION_TOP_MASK, this.keyPrefix = o.keyPrefix, this.addressPrefix = o.addressPrefix, this.requireStandard = o.requireStandard, this.rpcPort = o.rpcPort, this.walletPort = o.walletPort, this.minRelay = o.minRelay, this.feeRate = o.feeRate, this.maxFeeRate = o.maxFeeRate, this.selfConnect = o.selfConnect, this.requestMempool = o.requestMempool, this.time = new g(), this.init();
    }
    /**
     * Get a deployment by bit index.
     * @param {Number} bit
     * @returns {Object}
     */
    init() {
      let o = 0;
      for (const S of this.deploys)
        o |= 1 << S.bit;
      o |= w.VERSION_TOP_MASK, this.unknownBits = ~o >>> 0;
      for (const S of Object.keys(this.checkpointMap)) {
        const H = this.checkpointMap[S], j = Number(S);
        this.checkpoints.push({ hash: H, height: j });
      }
      this.checkpoints.sort(u);
    }
    /**
     * Get a deployment by bit index.
     * @param {Number} bit
     * @returns {Object}
     */
    byBit(o) {
      const S = c.search(this.deploys, o, n);
      return S === -1 ? null : this.deploys[S];
    }
    /**
     * Get network adjusted time.
     * @returns {Number}
     */
    now() {
      return this.time.now();
    }
    /**
     * Get network adjusted time in milliseconds.
     * @returns {Number}
     */
    ms() {
      return this.time.ms();
    }
    /**
     * Create a network. Get existing network if possible.
     * @param {NetworkType|Object} options
     * @returns {Network}
     */
    static create(o) {
      if (typeof o == "string" && (o = d[o]), e(o, "Unknown network."), f[o.type])
        return f[o.type];
      const S = new f(o);
      return f[S.type] = S, f.primary || (f.primary = S), S;
    }
    /**
     * Set the default network. This network will be used
     * if nothing is passed as the `network` option for
     * certain objects.
     * @param {NetworkType} type - Network type.
     * @returns {Network}
     */
    static set(o) {
      return e(typeof o == "string", "Bad network."), f.primary = f.get(o), f.type = o, f.primary;
    }
    /**
     * Get a network with a string or a Network object.
     * @param {NetworkType|Network} type - Network type.
     * @returns {Network}
     */
    static get(o) {
      if (!o)
        return e(f.primary, "No default network."), f.primary;
      if (o instanceof f)
        return o;
      if (typeof o == "string")
        return f.create(o);
      throw new Error("Unknown network.");
    }
    /**
     * Get a network with a string or a Network object.
     * @param {NetworkType|Network} type - Network type.
     * @returns {Network}
     */
    static ensure(o) {
      return o ? o instanceof f ? o : typeof o == "string" && d[o] ? f.create(o) : (e(f.primary, "No default network."), f.primary) : (e(f.primary, "No default network."), f.primary);
    }
    /**
     * Get a network by an associated comparator.
     * @private
     * @param {Object} value
     * @param {Function} compare
     * @param {Network|null} network
     * @param {String} name
     * @returns {Network}
     */
    static by(o, S, H, j) {
      if (H) {
        if (H = f.get(H), S(H, o))
          return H;
        throw new Error(`Network mismatch for ${j}.`);
      }
      for (const J of d.types)
        if (H = d[J], S(H, o))
          return f.get(J);
      throw new Error(`Network not found for ${j}.`);
    }
    /**
     * Get a network by its magic number.
     * @param {Number} value
     * @param {Network?} network
     * @returns {Network}
     */
    static fromMagic(o, S) {
      return f.by(o, a, S, "magic number");
    }
    /**
     * Get a network by its WIF prefix.
     * @param {Number} value
     * @param {Network?} network
     * @returns {Network}
     */
    static fromWIF(o, S) {
      return f.by(o, s, S, "WIF");
    }
    /**
     * Get a network by its xpubkey prefix.
     * @param {Number} value
     * @param {Network?} network
     * @returns {Network}
     */
    static fromPublic(o, S) {
      return f.by(o, i, S, "xpubkey");
    }
    /**
     * Get a network by its xprivkey prefix.
     * @param {Number} value
     * @param {Network?} network
     * @returns {Network}
     */
    static fromPrivate(o, S) {
      return f.by(o, p, S, "xprivkey");
    }
    /**
     * Get a network by its xpubkey base58 prefix.
     * @param {String} prefix
     * @param {Network?} network
     * @returns {Network}
     */
    static fromPublic58(o, S) {
      return f.by(o, m, S, "xpubkey");
    }
    /**
     * Get a network by its xprivkey base58 prefix.
     * @param {String} prefix
     * @param {Network?} network
     * @returns {Network}
     */
    static fromPrivate58(o, S) {
      return f.by(o, E, S, "xprivkey");
    }
    /**
     * Get a network by its base58 address prefix.
     * @param {Number} value
     * @param {Network?} network
     * @returns {Network}
     */
    static fromAddress(o, S) {
      return f.by(o, v, S, "base58 address");
    }
    /**
     * Get a network by its cashaddr address prefix.
     * @param {String} hrp
     * @param {Network?} network
     * @returns {Network}
     */
    static fromCashAddr(o, S) {
      return f.by(o, b, S, "cashaddr address");
    }
    /**
     * Convert the network to a string.
     * @returns {String}
     */
    toString() {
      return this.type;
    }
    /**
     * Inspect the network.
     * @returns {String}
     */
    inspect() {
      return `<Network: ${this.type}>`;
    }
    /**
     * Test an object to see if it is a Network.
     * @param {Object} obj
     * @returns {Boolean}
     */
    static isNetwork(o) {
      return o instanceof f;
    }
  }
  f.primary = null, f.type = null, f.main = null, f.testnet = null, f.regtest = null, f.segnet4 = null, f.simnet = null, f.set(It.env.BCASH_NETWORK || "main");
  function n(h, o) {
    return h.bit - o;
  }
  function u(h, o) {
    return h.height - o.height;
  }
  function a(h, o) {
    return h.magic === o;
  }
  function s(h, o) {
    return h.keyPrefix.privkey === o;
  }
  function i(h, o) {
    return h.keyPrefix.xpubkey === o;
  }
  function p(h, o) {
    return h.keyPrefix.xprivkey === o;
  }
  function m(h, o) {
    return h.keyPrefix.xpubkey58 === o;
  }
  function E(h, o) {
    return h.keyPrefix.xprivkey58 === o;
  }
  function v(h, o) {
    const S = h.addressPrefix;
    switch (o) {
      case S.pubkeyhash:
      case S.scripthash:
        return !0;
    }
    return !1;
  }
  function b(h, o) {
    return h.addressPrefix.cashaddr === o;
  }
  return c0 = f, c0;
}
var wi = {}, u0 = {}, yi = {};
/*!
 * random.js - random number generator for bcrypto
 * Copyright (c) 2014-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://wiki.openssl.org/index.php/Random_Numbers
 *   https://csrc.nist.gov/projects/random-bit-generation/
 *   http://www.pcg-random.org/posts/bounded-rands.html
 *   https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues
 */
var B1;
function Ti() {
  if (B1) return yi;
  B1 = 1;
  const e = Bt(), c = sn.crypto || sn.msCrypto, d = c && typeof c.getRandomValues == "function", w = d ? c.getRandomValues.bind(c) : null, g = new Uint32Array(16), f = 65536;
  let n = 0;
  function u(E) {
    e(E >>> 0 === E);
    const v = k.alloc(E);
    return m(v, 0, E), v;
  }
  function a(E, v, b) {
    return e(k.isBuffer(E)), v == null && (v = 0), e(v >>> 0 === v), b == null && (b = E.length - v), e(b >>> 0 === b), e(v + b <= E.length), m(E, v, b), E;
  }
  function s() {
    return (n & 15) === 0 && (p(g), n = 0), g[n++];
  }
  function i(E, v) {
    e(E >>> 0 === E), e(v >>> 0 === v), e(v >= E);
    const b = v - E;
    if (b === 0)
      return E;
    const h = -b >>> 0;
    let o, S;
    do
      o = s(), S = o % b;
    while (o - S > h);
    return S + E;
  }
  function p(E) {
    if (!d)
      throw new Error("Entropy source not available.");
    return w(E);
  }
  function m(E, v, b) {
    if (e(k.isBuffer(E)), e(E.buffer instanceof ArrayBuffer), e(E.byteOffset >>> 0 === E.byteOffset), e(E.byteLength >>> 0 === E.byteLength), e(v >>> 0 === v), e(b >>> 0 === b), e(v + b <= E.byteLength), b > 2 ** 31 - 1)
      throw new RangeError('The value "size" is out of range.');
    const h = E.byteOffset + v, o = new Uint8Array(E.buffer, h, b);
    if (o.length > f)
      for (let S = 0; S < o.length; S += f) {
        let H = S + f;
        H > o.length && (H = o.length), p(o.subarray(S, H));
      }
    else
      o.length > 0 && p(o);
  }
  return yi.native = 0, yi.randomBytes = u, yi.randomFill = a, yi.randomInt = s, yi.randomRange = i, yi;
}
var nr = {};
function M1(e, c) {
  if (e === c)
    return 0;
  for (var d = e.length, w = c.length, g = 0, f = Math.min(d, w); g < f; ++g)
    if (e[g] !== c[g]) {
      d = e[g], w = c[g];
      break;
    }
  return d < w ? -1 : w < d ? 1 : 0;
}
var Dm = Object.prototype.hasOwnProperty, N1 = Object.keys || function(e) {
  var c = [];
  for (var d in e)
    Dm.call(e, d) && c.push(d);
  return c;
}, q1 = Array.prototype.slice, h0;
function $8() {
  return typeof h0 < "u" ? h0 : h0 = function() {
    return (function() {
    }).name === "foo";
  }();
}
function z1(e) {
  return Object.prototype.toString.call(e);
}
function T1(e) {
  return Zi(e) || typeof Bi.ArrayBuffer != "function" ? !1 : typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(e) : e ? !!(e instanceof DataView || e.buffer && e.buffer instanceof ArrayBuffer) : !1;
}
function rr(e, c) {
  e || tr(e, !0, c, "==", Hn);
}
var Um = /\s*function\s+([^\(\s]*)\s*/;
function j8(e) {
  if (ki(e)) {
    if ($8())
      return e.name;
    var c = e.toString(), d = c.match(Um);
    return d && d[1];
  }
}
rr.AssertionError = $s;
function $s(e) {
  this.name = "AssertionError", this.actual = e.actual, this.expected = e.expected, this.operator = e.operator, e.message ? (this.message = e.message, this.generatedMessage = !1) : (this.message = Fm(this), this.generatedMessage = !0);
  var c = e.stackStartFunction || tr;
  if (Error.captureStackTrace)
    Error.captureStackTrace(this, c);
  else {
    var d = new Error();
    if (d.stack) {
      var w = d.stack, g = j8(c), f = w.indexOf(`
` + g);
      if (f >= 0) {
        var n = w.indexOf(`
`, f + 1);
        w = w.substring(n + 1);
      }
      this.stack = w;
    }
  }
}
Fn($s, Error);
function C1(e, c) {
  return typeof e == "string" ? e.length < c ? e : e.slice(0, c) : e;
}
function D1(e) {
  if ($8() || !ki(e))
    return Ar(e);
  var c = j8(e), d = c ? ": " + c : "";
  return "[Function" + d + "]";
}
function Fm(e) {
  return C1(D1(e.actual), 128) + " " + e.operator + " " + C1(D1(e.expected), 128);
}
function tr(e, c, d, w, g) {
  throw new $s({
    message: d,
    actual: e,
    expected: c,
    operator: w,
    stackStartFunction: g
  });
}
rr.fail = tr;
function Hn(e, c) {
  e || tr(e, !0, c, "==", Hn);
}
rr.ok = Hn;
rr.equal = Uh;
function Uh(e, c, d) {
  e != c && tr(e, c, d, "==", Uh);
}
rr.notEqual = Fh;
function Fh(e, c, d) {
  e == c && tr(e, c, d, "!=", Fh);
}
rr.deepEqual = Hh;
function Hh(e, c, d) {
  an(e, c, !1) || tr(e, c, d, "deepEqual", Hh);
}
rr.deepStrictEqual = Lh;
function Lh(e, c, d) {
  an(e, c, !0) || tr(e, c, d, "deepStrictEqual", Lh);
}
function an(e, c, d, w) {
  if (e === c)
    return !0;
  if (Zi(e) && Zi(c))
    return M1(e, c) === 0;
  if (on(e) && on(c))
    return e.getTime() === c.getTime();
  if (Pi(e) && Pi(c))
    return e.source === c.source && e.global === c.global && e.multiline === c.multiline && e.lastIndex === c.lastIndex && e.ignoreCase === c.ignoreCase;
  if ((e === null || typeof e != "object") && (c === null || typeof c != "object"))
    return d ? e === c : e == c;
  if (T1(e) && T1(c) && z1(e) === z1(c) && !(e instanceof Float32Array || e instanceof Float64Array))
    return M1(
      new Uint8Array(e.buffer),
      new Uint8Array(c.buffer)
    ) === 0;
  if (Zi(e) !== Zi(c))
    return !1;
  w = w || { actual: [], expected: [] };
  var g = w.actual.indexOf(e);
  return g !== -1 && g === w.expected.indexOf(c) ? !0 : (w.actual.push(e), w.expected.push(c), Hm(e, c, d, w));
}
function U1(e) {
  return Object.prototype.toString.call(e) == "[object Arguments]";
}
function Hm(e, c, d, w) {
  if (e == null || c === null || c === void 0)
    return !1;
  if (Ns(e) || Ns(c))
    return e === c;
  if (d && Object.getPrototypeOf(e) !== Object.getPrototypeOf(c))
    return !1;
  var g = U1(e), f = U1(c);
  if (g && !f || !g && f)
    return !1;
  if (g)
    return e = q1.call(e), c = q1.call(c), an(e, c, d);
  var n = N1(e), u = N1(c), a, s;
  if (n.length !== u.length)
    return !1;
  for (n.sort(), u.sort(), s = n.length - 1; s >= 0; s--)
    if (n[s] !== u[s])
      return !1;
  for (s = n.length - 1; s >= 0; s--)
    if (a = n[s], !an(e[a], c[a], d, w))
      return !1;
  return !0;
}
rr.notDeepEqual = Kh;
function Kh(e, c, d) {
  an(e, c, !1) && tr(e, c, d, "notDeepEqual", Kh);
}
rr.notDeepStrictEqual = Vh;
function Vh(e, c, d) {
  an(e, c, !0) && tr(e, c, d, "notDeepStrictEqual", Vh);
}
rr.strictEqual = $h;
function $h(e, c, d) {
  e !== c && tr(e, c, d, "===", $h);
}
rr.notStrictEqual = jh;
function jh(e, c, d) {
  e === c && tr(e, c, d, "!==", jh);
}
function F1(e, c) {
  if (!e || !c)
    return !1;
  if (Object.prototype.toString.call(c) == "[object RegExp]")
    return c.test(e);
  try {
    if (e instanceof c)
      return !0;
  } catch {
  }
  return Error.isPrototypeOf(c) ? !1 : c.call({}, e) === !0;
}
function Lm(e) {
  var c;
  try {
    e();
  } catch (d) {
    c = d;
  }
  return c;
}
function Y8(e, c, d, w) {
  var g;
  if (typeof c != "function")
    throw new TypeError('"block" argument must be a function');
  typeof d == "string" && (w = d, d = null), g = Lm(c), w = (d && d.name ? " (" + d.name + ")." : ".") + (w ? " " + w : "."), e && !g && tr(g, d, "Missing expected exception" + w);
  var f = typeof w == "string", n = !e && nn(g), u = !e && g && !d;
  if ((n && f && F1(g, d) || u) && tr(g, d, "Got unwanted exception" + w), e && g && d && !F1(g, d) || !e && g)
    throw g;
}
rr.throws = X8;
function X8(e, c, d) {
  Y8(!0, e, c, d);
}
rr.doesNotThrow = J8;
function J8(e, c, d) {
  Y8(!1, e, c, d);
}
rr.ifError = G8;
function G8(e) {
  if (e) throw e;
}
var Km = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  AssertionError: $s,
  assert: Hn,
  deepEqual: Hh,
  deepStrictEqual: Lh,
  default: rr,
  doesNotThrow: J8,
  equal: Uh,
  fail: tr,
  ifError: G8,
  notDeepEqual: Kh,
  notDeepStrictEqual: Vh,
  notEqual: Fh,
  notStrictEqual: jh,
  ok: Hn,
  strictEqual: $h,
  throws: X8
}), Vm = /* @__PURE__ */ Oh(Km);
/*!
 * asn1.js - asn1 parsing for bcrypto
 * Copyright (c) 2020, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var H1;
function W8() {
  if (H1) return nr;
  H1 = 1;
  const e = Vm, c = Ur();
  function d(v, b, h) {
    if (e(k.isBuffer(v)), e(b >>> 0 === b), e(typeof h == "boolean"), b >= v.length)
      throw new Error("Invalid size.");
    const o = v[b], S = o & 127;
    if (b += 1, (o & 128) === 0)
      return [S, b];
    if (h && S === 0)
      throw new Error("Indefinite length.");
    let H = 0;
    for (let j = 0; j < S; j++) {
      e(b < v.length);
      const J = v[b];
      if (b += 1, H >= 1 << 24)
        throw new Error("Length too large.");
      if (H *= 256, H += J, h && H === 0)
        throw new Error("Unexpected leading zeroes.");
    }
    if (h && H < 128)
      throw new Error("Non-minimal length.");
    return [H, b];
  }
  function w(v, b, h = !0) {
    if (e(k.isBuffer(v)), e(b >>> 0 === b), e(typeof h == "boolean"), b >= v.length || v[b] !== 48)
      throw new Error("Invalid sequence tag.");
    b += 1;
    let o;
    if ([o, b] = d(v, b, h), h && b + o !== v.length)
      throw new Error("Trailing bytes.");
    return b;
  }
  function g(v, b, h = !0) {
    if (e(k.isBuffer(v)), e(b >>> 0 === b), e(typeof h == "boolean"), b >= v.length || v[b] !== 2)
      throw new Error("Invalid integer tag.");
    b += 1;
    let o;
    if ([o, b] = d(v, b, h), b + o > v.length)
      throw new Error("Integer body out of bounds.");
    if (h) {
      if (o === 0)
        throw new Error("Zero length integer.");
      if (v[b] & 128)
        throw new Error("Integers must be positive.");
      if (o > 1 && v[b] === 0 && (v[b + 1] & 128) === 0)
        throw new Error("Unexpected leading zeroes.");
    }
    for (; o > 0 && v[b] === 0; )
      b += 1, o -= 1;
    if (o > 2048)
      throw new Error("Invalid integer size.");
    const S = c.decode(v.slice(b, b + o));
    return b += o, [S, b];
  }
  function f(v, b, h, o = !0) {
    e(k.isBuffer(v)), e(b >>> 0 === b), e((h & 255) === h), e(typeof o == "boolean");
    let S;
    if ([S, b] = g(v, b, o), S.cmpn(h) !== 0)
      throw new Error("Invalid version.");
    return b;
  }
  function n(v) {
    return e(v >>> 0 === v), v <= 127 ? 1 : v <= 255 ? 2 : (e(v <= 65535), 3);
  }
  function u(v) {
    return 1 + n(v) + v;
  }
  function a(v) {
    e(v instanceof c);
    const b = v.bitLength();
    let h = b + 7 >>> 3;
    return b > 0 && (b & 7) === 0 && (h += v.testn(b - 1)), b === 0 && (h = 1), 1 + n(h) + h;
  }
  function s(v) {
    return e((v & 255) === v), 3;
  }
  function i(v, b, h) {
    return e(k.isBuffer(v)), e(b >>> 0 === b), e(h >>> 0 === h), h <= 127 ? v[b++] = h : h <= 255 ? (v[b++] = 129, v[b++] = h) : (e(h <= 65535), v[b++] = 130, v[b++] = h >> 8, v[b++] = h & 255), e(b <= v.length), b;
  }
  function p(v, b, h) {
    return e(k.isBuffer(v)), e(b >>> 0 === b), v[b++] = 48, i(v, b, h);
  }
  function m(v, b, h) {
    e(k.isBuffer(v)), e(b >>> 0 === b), e(h instanceof c);
    const o = h.bitLength();
    let S = o + 7 >>> 3, H = 0;
    return o > 0 && (o & 7) === 0 && (H = h.testn(o - 1)), o === 0 && (S = 1), v[b++] = 2, b = i(v, b, H + S), H && (v[b++] = 0), o !== 0 ? h.encode().copy(v, b) : v[b] = 0, b += S, e(b <= v.length), b;
  }
  function E(v, b, h) {
    return e(k.isBuffer(v)), e(b >>> 0 === b), e((h & 255) === h), e(b + 3 <= v.length), v[b++] = 2, v[b++] = 1, v[b++] = h, b;
  }
  return nr.readSize = d, nr.readSeq = w, nr.readInt = g, nr.readVersion = f, nr.sizeSize = n, nr.sizeSeq = u, nr.sizeInt = a, nr.sizeVersion = s, nr.writeSize = i, nr.writeSeq = p, nr.writeInt = m, nr.writeVersion = E, nr;
}
/*!
 * chacha20.js - chacha20 for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources
 *   https://en.wikipedia.org/wiki/Chacha20
 *   https://tools.ietf.org/html/rfc7539#section-2
 *   https://cr.yp.to/chacha.html
 */
var l0, L1;
function Z8() {
  if (L1) return l0;
  L1 = 1;
  const e = Bt(), c = new Int8Array(new Int16Array([1]).buffer)[0] === 0;
  class d {
    /**
     * Create a ChaCha20 context.
     * @constructor
     */
    constructor() {
      this.state = new Uint32Array(16), this.stream = new Uint32Array(16), this.bytes = new Uint8Array(this.stream.buffer), this.pos = -1, c && (this.bytes = k.alloc(64));
    }
    /**
     * Initialize chacha20 with a key, nonce, and counter.
     * @param {Buffer} key
     * @param {Buffer} nonce
     * @param {Number} counter
     */
    init(a, s, i) {
      if (i == null && (i = 0), e(k.isBuffer(a)), e(k.isBuffer(s)), e(Number.isSafeInteger(i)), a.length !== 16 && a.length !== 32)
        throw new RangeError("Invalid key size.");
      if (s.length >= 24 && (a = d.derive(a, s.slice(0, 16)), s = s.slice(16)), this.state[0] = 1634760805, this.state[1] = a.length < 32 ? 824206446 : 857760878, this.state[2] = a.length < 32 ? 2036477238 : 2036477234, this.state[3] = 1797285236, this.state[4] = f(a, 0), this.state[5] = f(a, 4), this.state[6] = f(a, 8), this.state[7] = f(a, 12), this.state[8] = f(a, 16 % a.length), this.state[9] = f(a, 20 % a.length), this.state[10] = f(a, 24 % a.length), this.state[11] = f(a, 28 % a.length), this.state[12] = i >>> 0, s.length === 8)
        this.state[13] = i / 4294967296 >>> 0, this.state[14] = f(s, 0), this.state[15] = f(s, 4);
      else if (s.length === 12)
        this.state[13] = f(s, 0), this.state[14] = f(s, 4), this.state[15] = f(s, 8);
      else if (s.length === 16)
        this.state[12] = f(s, 0), this.state[13] = f(s, 4), this.state[14] = f(s, 8), this.state[15] = f(s, 12);
      else
        throw new RangeError("Invalid nonce size.");
      return this.pos = 0, this;
    }
    /**
     * Encrypt/decrypt data.
     * @param {Buffer} data - Will be mutated.
     * @returns {Buffer}
     */
    encrypt(a) {
      if (e(k.isBuffer(a)), this.pos === -1)
        throw new Error("Context is not initialized.");
      for (let s = 0; s < a.length; s++)
        (this.pos & 63) === 0 && (this._block(), this.pos = 0), a[s] ^= this.bytes[this.pos++];
      return a;
    }
    /**
     * Stir the stream.
     */
    _block() {
      for (let a = 0; a < 16; a++)
        this.stream[a] = this.state[a];
      for (let a = 0; a < 10; a++)
        w(this.stream, 0, 4, 8, 12), w(this.stream, 1, 5, 9, 13), w(this.stream, 2, 6, 10, 14), w(this.stream, 3, 7, 11, 15), w(this.stream, 0, 5, 10, 15), w(this.stream, 1, 6, 11, 12), w(this.stream, 2, 7, 8, 13), w(this.stream, 3, 4, 9, 14);
      for (let a = 0; a < 16; a++)
        this.stream[a] += this.state[a];
      if (c)
        for (let a = 0; a < 16; a++)
          n(this.bytes, this.stream[a], a * 4);
      this.state[12] += 1, this.state[12] === 0 && (this.state[13] += 1);
    }
    /**
     * Destroy context.
     */
    destroy() {
      for (let a = 0; a < 16; a++)
        this.state[a] = 0, this.stream[a] = 0;
      if (c)
        for (let a = 0; a < 64; a++)
          this.bytes[a] = 0;
      return this.pos = -1, this;
    }
    /**
     * Derive key with XChaCha20.
     * @param {Buffer} key
     * @param {Buffer} nonce
     * @returns {Buffer}
     */
    static derive(a, s) {
      if (e(k.isBuffer(a)), e(k.isBuffer(s)), a.length !== 16 && a.length !== 32)
        throw new RangeError("Invalid key size.");
      if (s.length !== 16)
        throw new RangeError("Invalid nonce size.");
      const i = new Uint32Array(16);
      i[0] = 1634760805, i[1] = a.length < 32 ? 824206446 : 857760878, i[2] = a.length < 32 ? 2036477238 : 2036477234, i[3] = 1797285236, i[4] = f(a, 0), i[5] = f(a, 4), i[6] = f(a, 8), i[7] = f(a, 12), i[8] = f(a, 16 % a.length), i[9] = f(a, 20 % a.length), i[10] = f(a, 24 % a.length), i[11] = f(a, 28 % a.length), i[12] = f(s, 0), i[13] = f(s, 4), i[14] = f(s, 8), i[15] = f(s, 12);
      for (let m = 0; m < 10; m++)
        w(i, 0, 4, 8, 12), w(i, 1, 5, 9, 13), w(i, 2, 6, 10, 14), w(i, 3, 7, 11, 15), w(i, 0, 5, 10, 15), w(i, 1, 6, 11, 12), w(i, 2, 7, 8, 13), w(i, 3, 4, 9, 14);
      const p = k.alloc(32);
      return n(p, i[0], 0), n(p, i[1], 4), n(p, i[2], 8), n(p, i[3], 12), n(p, i[12], 16), n(p, i[13], 20), n(p, i[14], 24), n(p, i[15], 28), p;
    }
  }
  d.native = 0;
  function w(u, a, s, i, p) {
    u[a] += u[s], u[p] = g(u[p] ^ u[a], 16), u[i] += u[p], u[s] = g(u[s] ^ u[i], 12), u[a] += u[s], u[p] = g(u[p] ^ u[a], 8), u[i] += u[p], u[s] = g(u[s] ^ u[i], 7);
  }
  function g(u, a) {
    return u << a | u >>> 32 - a;
  }
  function f(u, a) {
    return u[a++] + u[a++] * 256 + u[a++] * 65536 + u[a] * 16777216;
  }
  function n(u, a, s) {
    return u[s++] = a, a >>>= 8, u[s++] = a, a >>>= 8, u[s++] = a, a >>>= 8, u[s++] = a, s;
  }
  return l0 = d, l0;
}
/*!
 * batch-rng.js - batch rng for bcrypto
 * Copyright (c) 2019-2020, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on ElementsProject/secp256k1-zkp:
 *   Copyright (c) 2013, Pieter Wuille.
 *   https://github.com/ElementsProject/secp256k1-zkp
 *
 * Resources:
 *   https://github.com/ElementsProject/secp256k1-zkp/blob/11af701/src/modules/schnorrsig/main_impl.h#L166
 *   https://github.com/ElementsProject/secp256k1-zkp/blob/11af701/src/scalar_4x64_impl.h#L972
 *   https://github.com/ElementsProject/secp256k1-zkp/blob/11af701/src/scalar_8x32_impl.h#L747
 */
var d0, K1;
function $m() {
  if (K1) return d0;
  K1 = 1;
  const e = Bt(), c = Ur(), d = Z8(), w = cr();
  class g {
    constructor(n, u = (a) => a) {
      this.curve = n, this.encode = u, this.hash = new w(), this.chacha = new d(), this.key = k.alloc(32, 0), this.iv = k.alloc(8, 0), this.cache = [new c(1), new c(1)];
    }
    init(n) {
      e(Array.isArray(n)), this.hash.init();
      for (const [u, a, s] of n)
        this.hash.update(w.digest(u)), this.hash.update(a), this.hash.update(this.encode(s));
      return this.key = this.hash.final(), this.cache[0] = new c(1), this.cache[1] = new c(1), this;
    }
    encrypt(n) {
      const u = this.curve.scalarSize * 2, a = k.alloc(u, 0), s = a.slice(0, this.curve.scalarSize), i = a.slice(this.curve.scalarSize);
      return this.chacha.init(this.key, this.iv, n), this.chacha.encrypt(a), [
        this.curve.decodeScalar(s),
        this.curve.decodeScalar(i)
      ];
    }
    refresh(n) {
      let u = 0;
      for (; ; ) {
        this.iv[4] = u, this.iv[5] = u >>> 8, this.iv[6] = u >>> 16, this.iv[7] = u >>> 24, u += 1;
        const [a, s] = this.encrypt(n);
        if (!(a.isZero() || a.cmp(this.curve.n) >= 0) && !(s.isZero() || s.cmp(this.curve.n) >= 0)) {
          this.cache[0] = a, this.cache[1] = s;
          break;
        }
      }
    }
    generate(n) {
      return e(n >>> 0 === n), n & 1 && this.refresh(n >>> 1), this.cache[n & 1];
    }
  }
  return d0 = g, d0;
}
/*!
 * schnorr-legacy.js - bip-schnorr for bcrypto
 * Copyright (c) 2019-2020, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on sipa/bip-schnorr:
 *   Copyright (c) 2018-2019, Pieter Wuille (2-clause BSD License).
 *   https://github.com/sipa/bips/blob/d194620/bip-schnorr/reference.py
 *
 * Parts of this software are based on ElementsProject/secp256k1-zkp:
 *   Copyright (c) 2013, Pieter Wuille.
 *   https://github.com/ElementsProject/secp256k1-zkp
 *
 * Resources:
 *   https://github.com/sipa/bips/blob/d194620/bip-schnorr.mediawiki
 *   https://github.com/sipa/bips/blob/d194620/bip-schnorr/reference.py
 *   https://github.com/sipa/bips/blob/d194620/bip-schnorr/test-vectors.csv
 *   https://github.com/ElementsProject/secp256k1-zkp/tree/11af701/src/modules/schnorrsig
 *   https://github.com/bitcoincashorg/bitcoincash.org/blob/master/spec/2019-05-15-schnorr.md
 *
 * References:
 *
 *   [SCHNORR] Schnorr Signatures for secp256k1
 *     Pieter Wuille
 *     https://github.com/sipa/bips/blob/d194620/bip-schnorr.mediawiki
 *
 *   [CASH] Schnorr Signature specification
 *     Mark B. Lundeberg
 *     https://github.com/bitcoincashorg/bitcoincash.org/blob/master/spec/2019-05-15-schnorr.md
 */
var b0, V1;
function jm() {
  if (V1) return b0;
  V1 = 1;
  const e = Bt(), c = $m(), d = Ur();
  class w {
    constructor(f, n) {
      this.curve = f, this.hash = n, this.rng = new c(this.curve, this.encode.bind(this));
    }
    check() {
      if (this.curve.p.andln(3) !== 3)
        throw new Error(`Schnorr is not supported for ${this.curve.id}.`);
    }
    encode(f) {
      e(k.isBuffer(f));
      const { fieldSize: n } = this.curve;
      if (f.length === 1 + n)
        return f;
      if (f.length !== 1 + n * 2)
        throw new Error("Invalid point.");
      const u = k.alloc(1 + n);
      return u[0] = 2 | f[f.length - 1] & 1, f.copy(u, 1, 1, 1 + n), u;
    }
    hashInt(...f) {
      const n = new this.hash();
      n.init();
      for (const s of f)
        n.update(s);
      let u = n.final(this.curve.scalarSize);
      u.length > this.curve.scalarSize && (u = u.slice(0, this.curve.scalarSize));
      const a = d.decode(u, this.curve.endian);
      return a.iumaskn(this.curve.scalarBits), a.imod(this.curve.n);
    }
    hashNonce(f, n) {
      return this.hashInt(f, n);
    }
    hashChallenge(f, n, u) {
      return this.hashInt(f, this.encode(n), u);
    }
    sign(f, n) {
      return e(k.isBuffer(f)), this.check(), this._sign(f, n);
    }
    _sign(f, n) {
      const { n: u } = this.curve, a = this.curve.g, s = this.curve.decodeScalar(n);
      if (s.isZero() || s.cmp(u) >= 0)
        throw new Error("Invalid private key.");
      const i = a.mulBlind(s), p = this.hashNonce(n, f);
      if (p.isZero())
        throw new Error("Signing failed (k' = 0).");
      const m = a.mulBlind(p);
      m.isSquare() || p.ineg().imod(u);
      const E = m.encodeX(), v = i.encode(), b = this.hashChallenge(E, v, f), h = p.add(b.mul(s)).imod(u);
      return k.concat([E, this.curve.encodeScalar(h)]);
    }
    verify(f, n, u) {
      if (e(k.isBuffer(f)), e(k.isBuffer(n)), e(k.isBuffer(u)), this.check(), n.length !== this.curve.fieldSize + this.curve.scalarSize)
        return !1;
      try {
        return this._verify(f, n, u);
      } catch {
        return !1;
      }
    }
    _verify(f, n, u) {
      const { p: a, n: s } = this.curve, i = this.curve.g, p = n.slice(0, this.curve.fieldSize), m = n.slice(this.curve.fieldSize), E = this.curve.decodeField(p), v = this.curve.decodeScalar(m), b = this.curve.decodePoint(u);
      if (E.cmp(a) >= 0 || v.cmp(s) >= 0)
        return !1;
      const h = this.hashChallenge(p, u, f), o = i.jmulAdd(v, b, h.ineg().imod(s));
      return !(!o.isSquare() || !o.eqX(E));
    }
    verifyBatch(f) {
      e(Array.isArray(f)), this.check();
      for (const n of f) {
        e(Array.isArray(n) && n.length === 3);
        const [u, a, s] = n;
        if (e(k.isBuffer(u)), e(k.isBuffer(a)), e(k.isBuffer(s)), a.length !== this.curve.fieldSize + this.curve.scalarSize)
          return !1;
      }
      try {
        return this._verifyBatch(f);
      } catch {
        return !1;
      }
    }
    _verifyBatch(f) {
      const { n } = this.curve, u = this.curve.g, a = new Array(1 + f.length * 2), s = new Array(1 + f.length * 2), i = new d(0);
      this.rng.init(f), a[0] = u, s[0] = i;
      for (let p = 0; p < f.length; p++) {
        const [m, E, v] = f[p], b = E.slice(0, this.curve.fieldSize), h = E.slice(this.curve.fieldSize), o = this.curve.decodeSquare(b), S = this.curve.decodeScalar(h), H = this.curve.decodePoint(v);
        if (S.cmp(n) >= 0)
          return !1;
        const j = this.hashChallenge(b, v, m), J = this.rng.generate(p), N = j.mul(J).imod(n);
        i.iadd(S.mul(J)).imod(n), a[1 + p * 2 + 0] = o, s[1 + p * 2 + 0] = J, a[1 + p * 2 + 1] = H, s[1 + p * 2 + 1] = N;
      }
      return i.ineg().imod(n), this.curve.jmulAll(a, s).isInfinity();
    }
  }
  return b0 = w, b0;
}
/*!
 * hmac-drbg.js - hmac-drbg implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/hmac-drbg:
 *   Copyright Fedor Indutny, 2017.
 *   https://github.com/indutny/hmac-drbg
 *
 * Resources:
 *   https://tools.ietf.org/html/rfc6979
 *   https://csrc.nist.gov/publications/detail/sp/800-90a/archive/2012-01-23
 *   https://github.com/indutny/hmac-drbg/blob/master/lib/hmac-drbg.js
 */
var p0, $1;
function Q8() {
  if ($1) return p0;
  $1 = 1;
  const e = Bt(), c = 281474976710656, d = k.from([0]), w = k.from([1]);
  class g {
    constructor(n, u, a, s) {
      e(n && typeof n.id == "string"), this.hash = n, this.minEntropy = n.id === "SHA1" ? 10 : 24, this.K = k.alloc(n.size), this.V = k.alloc(n.size), this.rounds = 0, u && this.init(u, a, s);
    }
    init(n, u, a) {
      u == null && (u = k.alloc(0)), a == null && (a = k.alloc(0)), e(k.isBuffer(n)), e(k.isBuffer(u)), e(k.isBuffer(a));
      for (let i = 0; i < this.V.length; i++)
        this.K[i] = 0, this.V[i] = 1;
      const s = k.concat([n, u, a]);
      if (s.length < this.minEntropy)
        throw new Error("Not enough entropy.");
      return this.update(s), this.rounds = 1, this;
    }
    reseed(n, u) {
      if (u == null && (u = k.alloc(0)), e(k.isBuffer(n)), e(k.isBuffer(u)), this.rounds === 0)
        throw new Error("DRBG not initialized.");
      const a = k.concat([n, u]);
      if (a.length < this.minEntropy)
        throw new Error("Not enough entropy.");
      return this.update(a), this.rounds = 1, this;
    }
    generate(n, u) {
      if (e(n >>> 0 === n), e(u == null || k.isBuffer(u)), this.rounds === 0)
        throw new Error("DRBG not initialized.");
      if (this.rounds > c)
        throw new Error("Reseed is required.");
      u && u.length > 0 && this.update(u);
      const a = Math.ceil(n / this.hash.size), s = k.alloc(a * this.hash.size);
      for (let i = 0; i < a; i++)
        this.V = this.mac(this.V), this.V.copy(s, i * this.hash.size);
      return this.update(u), this.rounds += 1, s.slice(0, n);
    }
    randomBytes(n) {
      return this.generate(n);
    }
    /*
     * Helpers
     */
    mac(n) {
      return this.hash.mac(n, this.K);
    }
    hmac() {
      return this.hash.hmac().init(this.K);
    }
    update(n) {
      e(n == null || k.isBuffer(n));
      const u = this.hmac();
      if (u.update(this.V), u.update(d), n && u.update(n), this.K = u.final(), this.V = this.mac(this.V), n && n.length > 0) {
        const a = this.hmac();
        a.update(this.V), a.update(w), a.update(n), this.K = a.final(), this.V = this.mac(this.V);
      }
      return this;
    }
  }
  return g.native = 0, p0 = g, p0;
}
var Qt = {};
/*!
 * elliptic.js - elliptic curves for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/elliptic:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/elliptic
 *
 * Formulas from DJB and Tanja Lange [EFD].
 *
 * References:
 *
 *   [GECC] Guide to Elliptic Curve Cryptography
 *     D. Hankerson, A. Menezes, and S. Vanstone
 *     https://tinyurl.com/guide-to-ecc
 *
 *   [GLV] Faster Point Multiplication on Elliptic Curves
 *     R. Gallant, R. Lambert, and S. Vanstone
 *     https://link.springer.com/content/pdf/10.1007/3-540-44647-8_11.pdf
 *
 *   [MONT1] Montgomery curves and the Montgomery ladder
 *     Daniel J. Bernstein, Tanja Lange
 *     https://eprint.iacr.org/2017/293.pdf
 *
 *   [SQUARED] Elligator Squared
 *     Mehdi Tibouchi
 *     https://eprint.iacr.org/2014/043.pdf
 *
 *   [SEC1] SEC 1 - Standards for Efficient Cryptography Group
 *     Certicom Research
 *     https://www.secg.org/sec1-v2.pdf
 *
 *   [SEC2] SEC 2: Recommended Elliptic Curve Domain Parameters
 *     Certicom Research
 *     https://www.secg.org/sec2-v2.pdf
 *
 *   [SIDE1] Elliptic Curves and Side-Channel Attacks
 *     Marc Joye
 *     https://pdfs.semanticscholar.org/8d69/9645033e25d74fcfd4cbf07a770d2e943e14.pdf
 *
 *   [BLIND] Side-Channel Analysis on Blinding Regular Scalar Multiplications
 *     B. Feix, M. Roussellet, A. Venelli
 *     https://eprint.iacr.org/2014/191.pdf
 *
 *   [ALT] Alternative Elliptic Curve Representations
 *     R. Struik
 *     https://tools.ietf.org/id/draft-ietf-lwig-curve-representations-02.html
 *
 *   [ARITH1] Arithmetic of Elliptic Curves
 *     Christophe Doche, Tanja Lange
 *     Handbook of Elliptic and Hyperelliptic Curve Cryptography
 *     Page 267, Section 13 (978-1-58488-518-4)
 *     https://hyperelliptic.org/HEHCC/index.html
 *
 *   [ARITH2] The Arithmetic of Elliptic Curves, 2nd Edition
 *     Joseph H. Silverman
 *     http://www.pdmi.ras.ru/~lowdimma/BSD/Silverman-Arithmetic_of_EC.pdf
 *
 *   [EFD] Explicit-Formulas Database
 *     Daniel J. Bernstein, Tanja Lange
 *     https://hyperelliptic.org/EFD/index.html
 *
 *   [SAFE] SafeCurves: choosing safe curves for elliptic-curve cryptography
 *     Daniel J. Bernstein
 *     https://safecurves.cr.yp.to/
 *
 *   [4GLV] Refinement of the Four-Dimensional GLV Method on Elliptic Curves
 *     Hairong Yi, Yuqing Zhu, and Dongdai Lin
 *     http://www.site.uottawa.ca/~cadams/papers/prepro/paper_19_slides.pdf
 *
 *   [SSWU1] Efficient Indifferentiable Hashing into Ordinary Elliptic Curves
 *     E. Brier, J. Coron, T. Icart, D. Madore, H. Randriam, M. Tibouchi
 *     https://eprint.iacr.org/2009/340.pdf
 *
 *   [SSWU2] Rational points on certain hyperelliptic curves over finite fields
 *     Maciej Ulas
 *     https://arxiv.org/abs/0706.1448
 *
 *   [H2EC] Hashing to Elliptic Curves
 *     A. Faz-Hernandez, S. Scott, N. Sullivan, R. S. Wahby, C. A. Wood
 *     https://git.io/JeWz6
 *     https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve
 *
 *   [SVDW1] Construction of Rational Points on Elliptic Curves
 *     A. Shallue, C. E. van de Woestijne
 *     https://works.bepress.com/andrew_shallue/1/download/
 *
 *   [SVDW2] Indifferentiable Hashing to Barreto-Naehrig Curves
 *     Pierre-Alain Fouque, Mehdi Tibouchi
 *     https://www.di.ens.fr/~fouque/pub/latincrypt12.pdf
 *
 *   [SVDW3] Covert ECDH over secp256k1
 *     Pieter Wuille
 *     https://gist.github.com/sipa/29118d3fcfac69f9930d57433316c039
 *
 *   [MONT2] Montgomery Curve (wikipedia)
 *     https://en.wikipedia.org/wiki/Montgomery_curve
 *
 *   [MONT3] Montgomery Curves and their arithmetic
 *     C. Costello, B. Smith
 *     https://eprint.iacr.org/2017/212.pdf
 *
 *   [ELL2] Elliptic-curve points indistinguishable from uniform random strings
 *     D. Bernstein, M. Hamburg, A. Krasnova, T. Lange
 *     https://elligator.cr.yp.to/elligator-20130828.pdf
 *
 *   [RFC7748] Elliptic Curves for Security
 *     A. Langley, M. Hamburg, S. Turner
 *     https://tools.ietf.org/html/rfc7748
 *
 *   [TWISTED] Twisted Edwards Curves
 *     D. Bernstein, P. Birkner, M. Joye, T. Lange, C. Peters
 *     https://eprint.iacr.org/2008/013.pdf
 *
 *   [ELL1] Injective Encodings to Elliptic Curves
 *     P. Fouque, A. Joux, M. Tibouchi
 *     https://eprint.iacr.org/2013/373.pdf
 *
 *   [ISOGENY] Twisting Edwards curves with isogenies
 *     Mike Hamburg
 *     https://www.shiftleft.org/papers/isogeny/isogeny.pdf
 *
 *   [RFC8032] Edwards-Curve Digital Signature Algorithm (EdDSA)
 *     S. Josefsson, SJD AB, I. Liusvaara
 *     https://tools.ietf.org/html/rfc8032
 *
 *   [SCHNORR] Schnorr Signatures for secp256k1
 *     Pieter Wuille
 *     https://github.com/sipa/bips/blob/d194620/bip-schnorr.mediawiki
 *
 *   [BIP340] Schnorr Signatures for secp256k1
 *     Pieter Wuille, Jonas Nick, Tim Ruffing
 *     https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki
 *
 *   [JCEN12] Efficient Software Implementation of Public-Key Cryptography
 *            on Sensor Networks Using the MSP430X Microcontroller
 *     C. P. L. Gouvea, L. B. Oliveira, J. Lopez
 *     http://conradoplg.cryptoland.net/files/2010/12/jcen12.pdf
 *
 *   [FIPS186] Federal Information Processing Standards Publication
 *     National Institute of Standards and Technology
 *     https://tinyurl.com/fips-186-3
 *
 *   [RFC5639] Elliptic Curve Cryptography (ECC) Brainpool
 *             Standard Curves and Curve Generation
 *     M. Lochter, BSI, J. Merkle
 *     https://tools.ietf.org/html/rfc5639
 *
 *   [TWISTEQ] Twisted Edwards & Short Weierstrass Equivalence
 *     Christopher Jeffrey
 *     https://gist.github.com/chjj/16ba7fa08d64e8dda269a9fe5b2a8bbc
 *
 *   [ECPM] Elliptic Curve Point Multiplication (wikipedia)
 *     https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication
 */
var j1;
function Ym() {
  if (j1) return Qt;
  j1 = 1;
  const { custom: e } = U8(), c = Ur(), d = {
    AFFINE: 0,
    JACOBIAN: 1,
    PROJECTIVE: 2,
    EXTENDED: 3
  }, w = [
    -3,
    // -1 -1
    -1,
    // -1 0
    -5,
    // -1 1
    -7,
    // 0 -1
    0,
    // 0 0
    7,
    // 0 1
    5,
    // 1 -1
    1,
    // 1 0
    3
    // 1 1
  ];
  let g = 0;
  class f {
    constructor(r, x, O) {
      this.Point = null, this.id = null, this.uid = g++, this.ossl = null, this.type = "base", this.endian = "be", this.hash = null, this.prefix = null, this.context = !1, this.prime = null, this.p = null, this.red = null, this.fieldSize = 0, this.fieldBits = 0, this.adjustedSize = 0, this.signBit = 0, this.mask = 0, this.n = null, this.h = null, this.q = null, this.z = null, this.g = null, this.nh = null, this.scalarSize = 0, this.scalarBits = 0, this.zero = null, this.one = null, this.two = null, this.three = null, this.four = null, this.i2 = null, this.i3 = null, this.i4 = null, this.i6 = null, this.torsion = null, this.endo = null, this.hi = null, this._init(r, x, O);
    }
    _init(r, x, O) {
      I(typeof r == "function"), I(typeof x == "string"), I(O && typeof O == "object"), I(O.red == null || O.red instanceof c.Red), I(O.p != null, "Must pass a prime."), I(O.id == null || typeof O.id == "string"), I(O.ossl == null || typeof O.ossl == "string"), I(O.endian == null || typeof O.endian == "string"), I(O.hash == null || typeof O.hash == "string"), I(O.prefix == null || typeof O.prefix == "string"), I(O.context == null || typeof O.context == "boolean"), I(O.prime == null || typeof O.prime == "string"), I(O.torsion == null || Array.isArray(O.torsion)), this.Point = r, this.id = O.id || null, this.ossl = O.ossl || null, this.type = x, this.endian = O.endian || (x === "short" ? "be" : "le"), this.hash = O.hash || null, this.prefix = O.prefix ? k.from(O.prefix, "binary") : null, this.context = O.context || !1, this.prime = O.prime || null, this.p = c.fromJSON(O.p), O.red ? this.red = O.red : (this.red = O.prime ? c.red(O.prime) : c.mont(this.p), this.red.precompute()), this.fieldSize = this.p.byteLength(), this.fieldBits = this.p.bitLength(), this.adjustedSize = this.fieldSize + ((this.fieldBits & 7) === 0), this.signBit = this.adjustedSize * 8 - 1, this.mask = 255, (this.fieldBits & 7) !== 0 && (this.mask = (1 << (this.fieldBits & 7)) - 1), this.n = c.fromJSON(O.n || "0"), this.h = c.fromJSON(O.h || "1"), this.q = this.n.mul(this.h), this.z = c.fromJSON(O.z || "0").toRed(this.red), this.g = null, this.nh = this.n.ushrn(1), this.scalarSize = this.n.byteLength(), this.scalarBits = this.n.bitLength(), this.zero = new c(0).toRed(this.red), this.one = new c(1).toRed(this.red), this.two = new c(2).toRed(this.red), this.three = new c(3).toRed(this.red), this.four = new c(4).toRed(this.red), this.i2 = this.two.redInvert(), this.i3 = this.three.redInvert(), this.i4 = this.i2.redSqr(), this.i6 = this.i2.redMul(this.i3), this.torsion = new Array(this.h.word(0));
      for (let L = 0; L < this.torsion.length; L++)
        this.torsion[L] = this.point();
      return this.endo = null, this.hi = null, this._scale = T(this._scale, this), this.isIsomorphic = T(this.isIsomorphic, this), this.isIsogenous = T(this.isIsogenous, this), I(this.p.sign() > 0 && this.p.isOdd()), I(this.n.sign() >= 0), I(this.h.sign() > 0 && this.h.cmpn(255) <= 0), I(this.endian === "be" || this.endian === "le"), this;
    }
    _finalize(r) {
      if (I(r && typeof r == "object"), this.g = r.g ? this.pointFromJSON(r.g) : this.point(), r.torsion) {
        I(r.torsion.length === this.torsion.length);
        for (let x = 0; x < this.torsion.length; x++)
          this.torsion[x] = this.pointFromJSON(r.torsion[x]);
      }
      return this;
    }
    _findTorsion() {
      I(!this.n.isZero());
      const r = this.h.word(0), x = this.one.redNeg(), O = [this.point()], L = /* @__PURE__ */ new Set();
      let X = r;
      for (; O.length < X; ) {
        let P;
        x.redIAdd(this.one);
        try {
          P = this.pointFromX(x.clone());
        } catch {
          continue;
        }
        try {
          P = P.mul(this.n);
        } catch {
          X = 2;
          continue;
        }
        if (!P.isInfinity()) {
          P.normalize();
          for (const K of [P, P.neg()]) {
            const re = K.key();
            L.has(re) || (O.push(K), L.add(re));
          }
        }
      }
      for (O.sort((P, K) => P.cmp(K)); O.length < r; )
        O.push(this.point());
      return O;
    }
    _fixedMul(r, x) {
      I(r instanceof n), I(x instanceof c), I(r.pre && r.pre.windows);
      const { width: O, points: L } = r._getWindows(0, 0), X = 1 << O, K = (x.bitLength() + O - 1) / O >>> 0;
      let re = this.jpoint();
      for (let ce = 0; ce < K; ce++) {
        const le = x.bits(ce * O, O);
        re = re.add(L[ce * X + le]);
      }
      return x.isNeg() && (re = re.neg()), re;
    }
    _fixedNafMul(r, x) {
      I(r instanceof n), I(x instanceof c), I(r.pre && r.pre.doubles);
      const { step: O, points: L } = r._getDoubles(0, 0), X = Ie(x, 2, x.bitLength() + 1, O), P = ((1 << O + 1) - (O % 2 === 0 ? 2 : 1)) / 3;
      let K = this.jpoint(), re = this.jpoint();
      for (let ce = P; ce > 0; ce--) {
        for (let le = 0; le < X.length; le++) {
          const me = X[le];
          me === ce ? re = re.add(L[le]) : me === -ce && (re = re.sub(L[le]));
        }
        K = K.add(re);
      }
      return K;
    }
    _wnafMul(r, x, O) {
      I(x instanceof n), I(O instanceof c);
      const { width: L, points: X } = x._safeNAF(r), P = xe(O, L, O.bitLength() + 1);
      let K = this.jpoint();
      for (let re = P.length - 1; re >= 0; re--) {
        const ce = P[re];
        re !== P.length - 1 && (K = K.dbl()), ce > 0 ? K = K.add(X[ce - 1 >> 1]) : ce < 0 && (K = K.sub(X[-ce - 1 >> 1]));
      }
      return K;
    }
    _wnafMulAdd(r, x, O) {
      I(r >>> 0 === r), I(Array.isArray(x)), I(Array.isArray(O)), I(x.length === O.length);
      const L = x.length, X = new Array(L), P = new Array(L);
      let K = 0;
      for (let ne = 0; ne < L; ne++) {
        const W = x[ne], te = O[ne];
        if (I(W instanceof n), I(te instanceof c), ne > 0 && W.type !== x[ne - 1].type)
          throw new Error("Cannot mix points.");
        X[ne] = null, P[ne] = null, K = Math.max(K, te.bitLength() + 1);
      }
      let re = null, ce = null, le = 0;
      for (let ne = 0; ne < L; ne++) {
        const W = x[ne], te = O[ne], pe = W._getNAF(0);
        if (pe) {
          X[le] = pe.points, P[le] = xe(te, pe.width, K), le += 1;
          continue;
        }
        if (!re) {
          re = W, ce = te;
          continue;
        }
        X[le] = re._getJNAF(W), P[le] = C(ce, te, K), re = null, ce = null, le += 1;
      }
      if (re) {
        const ne = re._safeNAF(r);
        X[le] = ne.points, P[le] = xe(ce, ne.width, K), le += 1;
      }
      let me = this.jpoint();
      for (let ne = K - 1; ne >= 0; ne--) {
        ne !== K - 1 && (me = me.dbl());
        for (let W = 0; W < le; W++) {
          const te = P[W][ne];
          te > 0 ? me = me.add(X[W][te - 1 >> 1]) : te < 0 && (me = me.sub(X[W][-te - 1 >> 1]));
        }
      }
      return me;
    }
    _endoWnafMulAdd(r, x) {
      throw new Error("Not implemented.");
    }
    _scale(r, x) {
      switch (I(r instanceof f), I(r.p.eq(this.p)), r.type) {
        case "short":
          return this._scaleShort(r, x);
        case "mont":
          return this._scaleMont(r, x);
        case "edwards":
          return this._scaleEdwards(r, x);
        default:
          throw new Error("Not implemented.");
      }
    }
    _scaleShort(r, x) {
      throw new Error("Not implemented.");
    }
    _scaleMont(r, x) {
      throw new Error("Not implemented.");
    }
    _scaleEdwards(r, x) {
      throw new Error("Not implemented.");
    }
    isElliptic() {
      throw new Error("Not implemented.");
    }
    jinv() {
      throw new Error("Not implemented.");
    }
    isComplete() {
      return !1;
    }
    precompute(r) {
      return I(!this.g.isInfinity(), "Must have base point."), I(!this.n.isZero(), "Must have order."), this.g.precompute(this.n.bitLength(), r), this;
    }
    scalar(r, x, O) {
      const L = new c(r, x, O);
      return I(!L.red), this.n.isZero() ? L : L.imod(this.n);
    }
    field(r, x, O) {
      const L = c.cast(r, x, O);
      return L.red ? L.forceRed(this.red) : L.toRed(this.red);
    }
    point(r, x) {
      throw new Error("Not implemented.");
    }
    jpoint(r, x, O) {
      throw new Error("Not implemented.");
    }
    xpoint(r, x) {
      throw new Error("Not implemented.");
    }
    cpoint(r, x, O, L) {
      if (I(r instanceof c), I(x instanceof c), I(O instanceof c), I(L instanceof c), x.isZero() || L.isZero())
        return this.point();
      const X = x.redMul(L).redInvert(), P = r.redMul(L).redMul(X), K = O.redMul(x).redMul(X);
      return this.point(P, K);
    }
    solveX2(r) {
      throw new Error("Not implemented.");
    }
    solveX(r) {
      return this.solveX2(r).redSqrt();
    }
    solveY2(r) {
      throw new Error("Not implemented.");
    }
    solveY(r) {
      return this.solveY2(r).redSqrt();
    }
    validate(r) {
      throw new Error("Not implemented.");
    }
    pointFromX(r, x) {
      throw new Error("Not implemented.");
    }
    pointFromY(r, x) {
      throw new Error("Not implemented.");
    }
    isIsomorphic(r) {
      throw new Error("Not implemented.");
    }
    isIsogenous(r) {
      throw new Error("Not implemented.");
    }
    pointFromShort(r) {
      throw new Error("Not implemented.");
    }
    pointFromMont(r, x) {
      throw new Error("Not implemented.");
    }
    pointFromEdwards(r) {
      throw new Error("Not implemented.");
    }
    pointFromUniform(r) {
      throw new Error("Not implemented.");
    }
    pointToUniform(r) {
      throw new Error("Not implemented.");
    }
    pointFromHash(r, x = !1) {
      if (I(k.isBuffer(r)), I(typeof x == "boolean"), r.length !== this.fieldSize * 2)
        throw new Error("Invalid hash size.");
      const O = r.slice(0, this.fieldSize), L = r.slice(this.fieldSize), X = this.decodeUniform(O), P = this.decodeUniform(L), K = this.pointFromUniform(X), re = this.pointFromUniform(P), ce = K.add(re);
      return x ? ce.mulH() : ce;
    }
    pointToHash(r, x, O) {
      I(r instanceof this.Point), I(x >>> 0 === x);
      const L = x % this.torsion.length, X = r.add(this.torsion[L]);
      for (; ; ) {
        const P = this.randomField(O), K = this.pointFromUniform(P);
        if (K.neg().eq(K))
          continue;
        const re = X.sub(K), ce = G(O);
        let le;
        try {
          le = this.pointToUniform(re, ce & 15);
        } catch (W) {
          if (W.message === "Invalid point.")
            continue;
          throw W;
        }
        const me = this.encodeUniform(P, ce >>> 8), ne = this.encodeUniform(le, ce >>> 16);
        return k.concat([me, ne]);
      }
    }
    randomScalar(r) {
      const x = this.n.isZero() ? this.p : this.n;
      return c.random(r, 1, x);
    }
    randomField(r) {
      return c.random(r, 1, this.p).toRed(this.red);
    }
    randomPoint(r) {
      let x;
      for (; ; ) {
        const O = this.randomField(r), L = (G(r) & 1) !== 0;
        try {
          x = this.pointFromX(O, L);
        } catch {
          continue;
        }
        return I(x.validate()), x.mulH();
      }
    }
    mulAll(r, x) {
      return this.jmulAll(r, x);
    }
    jmulAll(r, x) {
      return I(Array.isArray(r)), I(r.length === 0 || r[0] instanceof n), this.endo && r.length > 0 && r[0].type === d.AFFINE ? this._endoWnafMulAdd(r, x) : this._wnafMulAdd(5, r, x);
    }
    mulH(r) {
      return I(r instanceof c), this.imulH(r.clone());
    }
    imulH(r) {
      I(r instanceof c), I(!r.red);
      const x = this.h.word(0);
      if ((x & x - 1) === 0) {
        const O = this.h.bitLength();
        return r.iushln(O - 1).imod(this.n);
      }
      return r.imuln(x).imod(this.n);
    }
    normalizeAll(r) {
      I(Array.isArray(r));
      const x = r.length, O = new Array(x);
      for (let P = 0; P < x; P++) {
        const K = r[P];
        if (I(K instanceof n), I(K.curve === this), K.type === d.AFFINE) {
          O[P] = this.one;
          continue;
        }
        O[P] = K.z;
      }
      const L = this.red.invertAll(O), X = new Array(x);
      for (let P = 0; P < x; P++)
        X[P] = r[P].scale(L[P]);
      return X;
    }
    affinizeAll(r) {
      return this.normalizeAll(r);
    }
    clamp(r) {
      I(k.isBuffer(r)), I(r.length === this.scalarSize), I(this.scalarSize <= this.fieldSize);
      let x = this.fieldBits & 7 || 8, O = 0, L = this.scalarSize - 1;
      return this.endian === "be" && ([O, L] = [L, O]), this.scalarSize < this.fieldSize && (x = 8), r[O] &= -this.h.word(0) & 255, r[L] &= (1 << x) - 1, r[L] |= 1 << x - 1, r;
    }
    splitHash(r) {
      I(k.isBuffer(r)), I(r.length === this.adjustedSize * 2), I(this.scalarSize <= this.adjustedSize);
      let x = 0;
      this.endian === "be" && (x = this.adjustedSize - this.scalarSize);
      const O = r.slice(x, x + this.scalarSize), L = r.slice(this.adjustedSize);
      return this.clamp(O), [O, L];
    }
    encodeField(r) {
      return I(r instanceof c), I(!r.red), r.encode(this.endian, this.fieldSize);
    }
    decodeField(r) {
      if (I(k.isBuffer(r)), r.length !== this.fieldSize)
        throw new Error("Invalid field element size.");
      return c.decode(r, this.endian);
    }
    encodeAdjusted(r) {
      return I(r instanceof c), I(!r.red), r.encode(this.endian, this.adjustedSize);
    }
    decodeAdjusted(r) {
      if (I(k.isBuffer(r)), r.length !== this.adjustedSize)
        throw new Error("Invalid field element size.");
      return c.decode(r, this.endian);
    }
    encodeScalar(r) {
      return I(r instanceof c), I(!r.red), r.encode(this.endian, this.scalarSize);
    }
    decodeScalar(r) {
      if (I(k.isBuffer(r)), r.length !== this.scalarSize)
        throw new Error("Invalid scalar size.");
      return c.decode(r, this.endian);
    }
    encodeClamped(r) {
      return this.clamp(this.encodeScalar(r));
    }
    decodeClamped(r) {
      if (I(k.isBuffer(r)), r.length !== this.scalarSize)
        throw new Error("Invalid scalar size.");
      const x = this.clamp(k.from(r));
      return c.decode(x, this.endian);
    }
    encodeUniform(r, x) {
      I(r instanceof c), I(x >>> 0 === x);
      const O = this.endian === "le" ? this.fieldSize - 1 : 0, L = r.fromRed().encode(this.endian, this.fieldSize);
      return L[O] |= x & ~this.mask & 255, L;
    }
    decodeUniform(r) {
      if (I(k.isBuffer(r)), r.length !== this.fieldSize)
        throw new Error("Invalid field size.");
      const x = c.decode(r, this.endian);
      return x.iumaskn(this.fieldBits), x.toRed(this.red);
    }
    encodePoint(r, x) {
      return I(r instanceof n), r.encode(x);
    }
    decodePoint(r) {
      throw new Error("Not implemented.");
    }
    encodeX(r) {
      throw new Error("Not implemented.");
    }
    decodeX(r) {
      throw new Error("Not implemented.");
    }
    decodeEven(r) {
      throw new Error("Not implemented.");
    }
    decodeSquare(r) {
      throw new Error("Not implemented.");
    }
    toShort() {
      throw new Error("Not implemented.");
    }
    toMont(r) {
      throw new Error("Not implemented.");
    }
    toEdwards(r) {
      throw new Error("Not implemented.");
    }
    pointToJSON(r, x) {
      return I(r instanceof n), r.toJSON(x);
    }
    pointFromJSON(r) {
      throw new Error("Not implemented.");
    }
    toJSON(r) {
      let x, O, L, X, P;
      return this.type === "edwards" && (x = this.prefix ? this.prefix.toString() : null, O = this.context), this.n.isZero() || (L = this.n.toJSON()), this.z.isZero() || (X = this.z.fromRed(), this.z.redIsHigh() && X.isub(this.p), X = X.toString(16)), this.endo && (P = this.endo.toJSON()), {
        id: this.id,
        ossl: this.ossl,
        type: this.type,
        endian: this.endian,
        hash: this.hash,
        prefix: x,
        context: O,
        prime: this.prime,
        p: this.p.toJSON(),
        a: void 0,
        b: void 0,
        d: void 0,
        n: L,
        h: this.h.toString(16),
        s: void 0,
        z: X,
        c: void 0,
        g: this.g.toJSON(r),
        endo: P
      };
    }
    static fromJSON(r) {
      return new this(r);
    }
  }
  class n {
    constructor(r, x) {
      I(r instanceof f), I(x >>> 0 === x), this.curve = r, this.type = x, this.pre = null;
    }
    _init() {
      throw new Error("Not implemented.");
    }
    _safeNAF(r) {
      if (I(r >>> 0 === r), this.pre && this.pre.naf)
        return this.pre.naf;
      if (r === 0)
        return null;
      const x = 1 << r - 2, O = new Array(x), L = this.toJ(), X = x === 1 ? null : L.dbl();
      O[0] = L;
      for (let P = 1; P < x; P++)
        O[P] = O[P - 1].add(X);
      return new h(r, O);
    }
    _getNAF(r) {
      if (I(r >>> 0 === r), this.pre && this.pre.naf)
        return this.pre.naf;
      if (r === 0)
        return null;
      const x = this._safeNAF(r).points, O = this.curve.affinizeAll(x);
      return new h(r, O);
    }
    _getWindows(r, x) {
      if (I(r >>> 0 === r), I(x >>> 0 === x), this.pre && this.pre.windows)
        return this.pre.windows;
      if (r === 0)
        return null;
      const O = 1 << r, L = (x + r - 1) / r >>> 0, X = new Array(L * O);
      let P = this.toJ();
      for (let re = 0; re < L; re++) {
        X[re * O] = this.curve.jpoint();
        for (let ce = 1; ce < O; ce++)
          X[re * O + ce] = X[re * O + ce - 1].add(P);
        P = P.dblp(r);
      }
      const K = this.curve.affinizeAll(X);
      return new o(r, x, K);
    }
    _getDoubles(r, x) {
      if (I(r >>> 0 === r), I(x >>> 0 === x), this.pre && this.pre.doubles)
        return this.pre.doubles;
      if (r === 0)
        return null;
      const O = Math.ceil(x / r) + 1, L = new Array(O);
      let X = this.toJ(), P = 0;
      L[P++] = X;
      for (let re = 0; re < x; re += r) {
        for (let ce = 0; ce < r; ce++)
          X = X.dbl();
        L[P++] = X;
      }
      I(P === O);
      const K = this.curve.affinizeAll(L);
      return new S(r, K);
    }
    _getBeta() {
      return null;
    }
    _getBlinding(r) {
      if (this.pre && this.pre.blinding)
        return this.pre.blinding;
      if (!r || this.curve.n.isZero())
        return null;
      const x = this.curve.randomScalar(r), O = this.mul(x);
      return new H(x, O);
    }
    _hasWindows(r) {
      if (I(r instanceof c), !this.pre || !this.pre.windows)
        return !1;
      const { width: x, bits: O } = this.pre.windows, L = (O + x - 1) / x >>> 0;
      return r.bitLength() <= L * x;
    }
    _hasDoubles(r) {
      if (I(r instanceof c), !this.pre || !this.pre.doubles)
        return !1;
      const { step: x, points: O } = this.pre.doubles, L = r.bitLength() + 1;
      return O.length >= Math.ceil(L / x) + 1;
    }
    _getJNAF(r) {
      return I(r instanceof n), I(r.type === this.type), [
        this,
        // 1
        this.add(r),
        // 3
        this.sub(r),
        // 5
        r
        // 7
      ];
    }
    _blind(r, x) {
      if (I(r instanceof c), I(!r.red), this.pre && this.pre.blinding) {
        const { blind: L, unblind: X } = this.pre.blinding, P = r.sub(L);
        return [this, P, X];
      }
      if (!x)
        return [this, r, null];
      if (this.pre) {
        if (this.curve.n.isZero())
          return [this, r, null];
        const P = this.curve.randomScalar(x).mul(this.curve.n).iadd(r);
        return [this, P, null];
      }
      return [this.randomize(x), r, null];
    }
    clone() {
      throw new Error("Not implemented.");
    }
    precompute(r, x) {
      return I(r >>> 0 === r), this.pre || (this.pre = new b()), this.pre.naf || (this.pre.naf = this._getNAF(9)), this.pre.doubles || (this.pre.doubles = this._getDoubles(4, r + 1)), this.pre.beta || (this.pre.beta = this._getBeta()), this.pre.blinding || (this.pre.blinding = this._getBlinding(x)), this;
    }
    validate() {
      return this.curve.validate(this);
    }
    normalize() {
      return this;
    }
    scale(r) {
      throw new Error("Not implemented.");
    }
    randomize(r) {
      const x = this.curve.randomField(r);
      return this.scale(x);
    }
    neg() {
      throw new Error("Not implemented.");
    }
    add(r) {
      throw new Error("Not implemented.");
    }
    sub(r) {
      return I(r instanceof n), this.add(r.neg());
    }
    dbl() {
      throw new Error("Not implemented.");
    }
    dblp(r) {
      I(r >>> 0 === r);
      let x = this;
      for (let O = 0; O < r; O++)
        x = x.dbl();
      return x;
    }
    diffAddDbl(r, x) {
      throw new Error("Not implemented.");
    }
    getX() {
      throw new Error("Not implemented.");
    }
    getY() {
      throw new Error("Not implemented.");
    }
    eq(r) {
      throw new Error("Not implemented.");
    }
    cmp(r) {
      throw new Error("Not implemented.");
    }
    isInfinity() {
      throw new Error("Not implemented.");
    }
    isOrder2() {
      throw new Error("Not implemented.");
    }
    isOdd() {
      throw new Error("Not implemented.");
    }
    isEven() {
      throw new Error("Not implemented.");
    }
    isSquare() {
      throw new Error("Not implemented.");
    }
    eqX(r) {
      throw new Error("Not implemented.");
    }
    eqR(r) {
      throw new Error("Not implemented.");
    }
    isSmall() {
      return this.isInfinity() ? !1 : this.jmulH().isInfinity();
    }
    hasTorsion() {
      return this.isInfinity() ? !1 : !this.jmul(this.curve.n).isInfinity();
    }
    order() {
      const { h: r, n: x } = this.curve;
      let O = this.toJ(), L = new c(1);
      for (; !O.isInfinity(); ) {
        if (L.iaddn(1), L.cmp(r) > 0) {
          L = x.clone();
          break;
        }
        O = O.add(this);
      }
      return L;
    }
    mul(r) {
      return this.jmul(r);
    }
    muln(r) {
      return this.jmuln(r);
    }
    mulBlind(r, x) {
      return this.jmulBlind(r, x);
    }
    mulAdd(r, x, O) {
      return this.jmulAdd(r, x, O);
    }
    mulH() {
      return this.jmulH();
    }
    div(r) {
      return this.jdiv(r);
    }
    divn(r) {
      return this.jdivn(r);
    }
    divH() {
      return this.jdivH();
    }
    jmul(r) {
      return this._hasDoubles(r) ? this.curve._fixedNafMul(this, r) : this.curve.endo && this.type === d.AFFINE ? this.curve._endoWnafMulAdd([this], [r]) : this.curve._wnafMul(5, this, r);
    }
    jmuln(r) {
      return I((r | 0) === r), this.jmul(new c(r));
    }
    jmulBlind(r, x = null) {
      const [O, L, X] = this._blind(r, x), P = O.jmul(L);
      return X ? P.add(X) : P;
    }
    jmulAdd(r, x, O) {
      return this.curve.endo && this.type === d.AFFINE ? this.curve._endoWnafMulAdd([this, x], [r, O]) : this.curve._wnafMulAdd(5, [this, x], [r, O]);
    }
    jmulH() {
      const r = this.curve.h.word(0);
      if ((r & r - 1) === 0) {
        const x = this.curve.h.bitLength();
        return this.toJ().dblp(x - 1);
      }
      return this.jmul(this.curve.h);
    }
    jdiv(r) {
      return I(r instanceof c), I(!r.red), this.jmul(r.invert(this.curve.n));
    }
    jdivn(r) {
      return I(!this.curve.n.isZero()), this.curve.h.cmpn(r) === 0 ? this.jdivH() : this.jdiv(new c(r));
    }
    jdivH() {
      return this.curve.n.isZero() ? this.toJ() : this.curve.h.cmpn(1) === 0 ? this.toJ() : (this.curve.hi === null && (this.curve.hi = this.curve.h.invert(this.curve.n)), this.jmul(this.curve.hi));
    }
    toP() {
      return this.normalize();
    }
    toJ() {
      return this;
    }
    toX() {
      return this;
    }
    key() {
      if (this.isInfinity())
        return `${this.curve.uid}:oo`;
      this.normalize();
      const r = this.getX().toString(16), x = this.getY().toString(16);
      return `${this.curve.uid}:${r},${x}`;
    }
    encode(r) {
      throw new Error("Not implemented.");
    }
    static decode(r, x) {
      throw new Error("Not implemented.");
    }
    encodeX() {
      throw new Error("Not implemented.");
    }
    static decodeX(r, x) {
      throw new Error("Not implemented.");
    }
    static decodeEven(r, x) {
      throw new Error("Not implemented.");
    }
    static decodeSquare(r, x) {
      throw new Error("Not implemented.");
    }
    toJSON(r) {
      throw new Error("Not implemented.");
    }
    static fromJSON(r, x) {
      throw new Error("Not implemented.");
    }
    [e]() {
      return "<Point>";
    }
  }
  class u extends f {
    constructor(r) {
      super(a, "short", r), this.a = c.fromJSON(r.a).toRed(this.red), this.b = c.fromJSON(r.b).toRed(this.red), this.c = c.fromJSON(r.c || "0").toRed(this.red), this.ai = this.a.isZero() ? this.zero : this.a.redInvert(), this.zi = this.z.isZero() ? this.zero : this.z.redInvert(), this.zeroA = this.a.isZero(), this.threeA = this.a.eq(this.three.redNeg()), this.redN = this.n.toRed(this.red), this.pmodn = this.p.clone(), this.highOrder = this.n.cmp(this.p) >= 0, this.smallGap = !1, this._finalize(r);
    }
    _finalize(r) {
      return super._finalize(r), r.endo != null ? this.endo = j.fromJSON(this, r.endo) : this.endo = this._getEndomorphism(), this.n.isZero() || (this.pmodn = this.p.mod(this.n), this.smallGap = this.p.div(this.n).cmpn(1) <= 0), this;
    }
    static _isomorphism(r, x, O, L) {
      if (I(r instanceof c), I(x instanceof c), I(O instanceof c), I(L == null || typeof L == "boolean"), I(!r.isZero() || !x.isZero()), O.isZero())
        throw new Error("Invalid coefficient.");
      if (r.isZero()) {
        const me = O, ne = me.redDiv(x), W = U(ne);
        return I(W.redJacobi() === 1), [r.clone(), me.clone()];
      }
      if (x.isZero()) {
        const me = O, W = me.redDiv(r).redSqrt();
        if (W.redJacobi() !== 1 && W.redINeg(), W.redJacobi() !== 1)
          throw new Error("Invalid `a` coefficient.");
        return [me.clone(), x.clone()];
      }
      const X = O, P = X.redDiv(r), K = P.redSqrt();
      if (L != null ? K.redIsOdd() !== L && K.redINeg() : K.redJacobi() !== 1 && K.redINeg(), K.redJacobi() !== 1)
        throw new Error("Invalid `a` coefficient.");
      const re = P.redMul(K), ce = r.redMul(P), le = x.redMul(re);
      return I(ce.eq(X)), [ce, le];
    }
    _short(r, x) {
      return u._isomorphism(this.a, this.b, r, x);
    }
    _mont(r, x) {
      const [O, L] = this._findRS(x), X = L.redInvert(), P = O.redMuln(3).redMul(X);
      return r != null ? i._isomorphism(P, X, r) : [P, X];
    }
    _edwards(r, x) {
      const [O, L] = this._findRS(x), X = O.redMuln(3), P = L.redMuln(2), K = X.redAdd(P), re = X.redSub(P);
      return r != null ? E._isomorphism(K, re, r) : [K, re];
    }
    _findRS(r) {
      I(r == null || typeof r == "boolean"), I(this.h.word(0) >= 4), I(!this.n.isZero());
      const x = this.one.redNeg();
      let O;
      for (; ; ) {
        x.redIAdd(this.one);
        try {
          O = this.pointFromX(x.clone());
        } catch {
          continue;
        }
        if (O = O.mul(this.n), !O.isInfinity() && O.y.isZero())
          break;
      }
      const L = O.x, P = L.redSqr().redMuln(3).redIAdd(this.a).redSqrt();
      return r != null && P.redIsOdd() !== r && P.redINeg(), [L, P];
    }
    _scale0(r, x) {
      if (I(this.a.isZero() === r.isZero()), I(this.b.isZero() === x.isZero()), this.a.isZero()) {
        const re = this.b.redDiv(this.field(x)), ce = U(re), le = ce.redSqrt(), me = ce.redMul(le);
        return I(me.redSqr().eq(re)), I(!le.isZero()), [ce, me];
      }
      if (this.b.isZero()) {
        const re = this.a.redDiv(this.field(r)), ce = re.redSqrt();
        ce.redJacobi() !== 1 && ce.redINeg();
        const le = ce.redSqrt(), me = ce.redMul(le);
        return I(me.redMul(le).eq(re)), I(!le.isZero()), [ce, me];
      }
      const O = this.a.redDiv(this.field(r)), L = this.b.redDiv(this.field(x)), X = O.redSqrt();
      O.redMul(X).eq(L) || X.redINeg(), I(O.redMul(X).eq(L));
      const P = X.redSqrt(), K = X.redMul(P);
      return I(!P.isZero()), [X, K];
    }
    _scale1(r, x) {
      const O = this.g.x.redDiv(this.field(r)), L = this.g.y.redDiv(this.field(x)), X = O.redSqrt();
      return O.redMul(X).eq(L) || X.redINeg(), I(O.redMul(X).eq(L)), I(!X.isZero()), [O, L];
    }
    _scaleShort(r) {
      return I(r instanceof u), this.g.isInfinity() || r.g.isInfinity() ? this._scale0(r.a, r.b) : this._scale1(r.g.x, r.g.y);
    }
    _scaleMont(r) {
      if (I(r instanceof i), this.g.isInfinity() || r.g.isInfinity()) {
        const [P, K] = r._short();
        return this._scale0(P, K);
      }
      const { x, y: O } = r.g, L = x.redAdd(r.a3).redMul(r.bi), X = O.redMul(r.bi);
      return this._scale1(L, X);
    }
    _scaleEdwards(r) {
      if (I(r instanceof E), this.g.isInfinity() || r.g.isInfinity()) {
        const [Be, ke] = r._short();
        return this._scale0(Be, ke);
      }
      const { x, y: O, z: L } = r.g, X = r.a.redMuln(5), P = r.d.redMuln(5), K = r.d.redSub(r.a), re = P.redSub(r.a), ce = r.d.redSub(X), le = O.redAdd(L), me = O.redSub(L), ne = re.redMul(O).redIAdd(ce.redMul(L)), W = me.redMuln(12), te = K.redMul(le).redMul(L), pe = me.redMul(x).redIMuln(4), Ee = W.redMul(pe).redInvert(), Ae = ne.redMul(pe).redMul(Ee), Oe = te.redMul(W).redMul(Ee);
      return this._scale1(Ae, Oe);
    }
    _getEndomorphism(r = 0) {
      if (this.n.isZero() || this.g.isInfinity() || !this.zeroA || this.p.modrn(3) !== 1 || this.n.modrn(3) !== 1)
        return null;
      const [x, O] = this._getEndoRoots(this.p), L = [x, O][r & 1].toRed(this.red), [X, P] = this._getEndoRoots(this.n), K = this.point(this.g.x.redMul(L), this.g.y);
      let re;
      this.g.mul(X).eq(K) ? re = X : (I(this.g.mul(P).eq(K)), re = P);
      const ce = this._getEndoBasis(re), le = this._getEndoPrecomp(ce);
      return new j(L, re, ce, le);
    }
    _getEndoRoots(r) {
      const x = r === this.p ? this.red : c.mont(r), O = new c(2).toRed(x), L = new c(3).toRed(x), X = O.redInvert(), P = L.redNeg().redSqrt().redMul(X), K = P.redNeg(), re = P.redSub(X).fromRed(), ce = K.redSub(X).fromRed();
      return [re, ce].sort(c.cmp);
    }
    _getEndoBasis(r) {
      const [x, O, L, X, P, K] = this._egcdSqrt(r), re = L, ce = X.neg(), le = x.sqr().iadd(O.sqr()), me = P.sqr().iadd(K.sqr());
      let ne, W;
      return le.cmp(me) <= 0 ? (ne = x, W = O.neg()) : (ne = P, W = K.neg()), [
        new J(re, ce),
        new J(ne, W)
      ];
    }
    _egcdSqrt(r) {
      I(r instanceof c), I(!r.red), I(r.sign() > 0), I(this.n.sign() > 0);
      const x = this.n.ushrn(this.n.bitLength() >>> 1);
      let O = r, L = this.n.clone(), X = new c(1), P = new c(0), K = new c(0), re = new c(1), ce, le, me, ne, W = 0, te = 0, pe;
      for (; !O.isZero() && W < 2; ) {
        const Oe = L.quo(O), Be = L.sub(Oe.mul(O)), ke = K.sub(Oe.mul(X)), Ne = re.sub(Oe.mul(P));
        te === 0 && Be.cmp(x) < 0 && (ce = pe, le = X, me = Be, ne = ke, te = 1), pe = Be, L = O, O = Be, K = X, X = ke, re = P, P = Ne, W += te;
      }
      return I(te !== 0, "Could not find r < sqrt(n)."), [
        ce,
        le,
        me,
        ne,
        K,
        X
      ];
    }
    _getEndoPrecomp(r) {
      I(Array.isArray(r)), I(r.length === 2), I(r[0] instanceof J), I(r[1] instanceof J);
      const [x, O] = r, L = x.a.mul(O.b).isub(x.b.mul(O.a)), X = L.bitLength(), P = X >= 160;
      I(L.eq(this.n));
      let K = X + Math.ceil(X / 2) + 1, re, ce;
      for (P && (K -= K & 63); K > X && (re = O.b.ushln(K).divRound(L), ce = x.b.ushln(K).divRound(L), !(re.ucmp(L) < 0 && ce.ucmp(L) < 0)); )
        P ? K -= 64 : K -= 1;
      if (K <= X)
        throw new Error("Could not calculate g1 and g2.");
      return [K, re, ce];
    }
    _endoSplit(r) {
      I(r instanceof c), I(!r.red), I(!this.n.isZero());
      const [x, O] = this.endo.basis, L = O.b.mul(r).divRound(this.n), X = x.b.neg().mul(r).divRound(this.n), P = L.mul(x.a), K = X.mul(O.a), re = L.ineg().mul(x.b), ce = X.mul(O.b), le = r.sub(P).isub(K), me = re.isub(ce);
      return [le, me];
    }
    _endoBeta(r) {
      return I(r instanceof a), [r, r._getBeta()];
    }
    _endoWnafMulAdd(r, x) {
      I(Array.isArray(r)), I(Array.isArray(x)), I(r.length === x.length), I(this.endo != null);
      const O = r.length, L = new Array(O * 2), X = new Array(O * 2);
      for (let P = 0; P < O; P++) {
        const [K, re] = this._endoBeta(r[P]), [ce, le] = this._endoSplit(x[P]);
        L[P * 2 + 0] = K, X[P * 2 + 0] = ce, L[P * 2 + 1] = re, X[P * 2 + 1] = le;
      }
      return this._wnafMulAdd(5, L, X);
    }
    _sswu(r) {
      const { b: x, z: O, ai: L, zi: X, one: P } = this, K = O.redSqr(), re = x.redNeg().redMul(L), ce = x.redMul(X).redMul(L), le = r.redSqr(), me = le.redSqr(), ne = K.redMul(me).redIAdd(O.redMul(le)), W = ne.isZero() ? ne : ne.redInvert(), te = W.isZero() ? ce : re.redMul(P.redAdd(W)), pe = O.redMul(le).redMul(te), Ee = this.solveY2(te), Ae = this.solveY2(pe), Oe = Ee.redIsSquare() | 0, Be = [te, pe][Oe ^ 1], ke = [Ee, Ae][Oe ^ 1].redSqrt();
      return ke.redIsOdd() !== r.redIsOdd() && ke.redINeg(), this.point(Be, ke);
    }
    _sswui(r, x) {
      const { a: O, b: L, z: X } = this, { x: P, y: K } = r, re = x & 3, ce = O.redSqr().redMul(P.redSqr()), le = O.redMul(L).redMul(P).redIMuln(2), me = L.redSqr().redMuln(3), ne = O.redMul(P).redIAdd(L), W = ce.redISub(le).redISub(me).redSqrt(), te = ne.redSub(W).redINeg(), pe = ne.redAdd(W).redINeg(), Ee = ne.redMul(X).redIMuln(2), Ae = L.redMul(X).redIMuln(2), Oe = [te, pe][re & 1], Be = [Ee, Ae][re >>> 1], ke = Oe.redDivSqrt(Be);
      return ke.redIsOdd() !== K.redIsOdd() && ke.redINeg(), ke;
    }
    _svdwf(r) {
      const { c: x, z: O, zi: L, i2: X, i3: P } = this, K = this.solveY2(O), re = P.redMul(L.redSqr()), ce = r.redSqr(), le = ce.redSqr(), me = ce.redAdd(K), ne = ce.redMul(me), W = ne.isZero() ? ne : ne.redInvert(), te = le.redMul(W).redMul(x), pe = me.redSqr().redMul(me), Ee = x.redSub(O).redMul(X).redISub(te), Ae = te.redSub(x.redAdd(O).redMul(X)), Oe = O.redSub(pe.redMul(W).redMul(re)), Be = this.solveY2(Ee), ke = this.solveY2(Ae), Ne = this.solveY2(Oe), Ke = Be.redJacobi() | 1, Ce = ke.redJacobi() | 1, Ye = t((Ke - 1) * Ce, 3), vt = [Ee, Ae, Oe][Ye], Ve = [Be, ke, Ne][Ye];
      return [vt, Ve];
    }
    _svdw(r) {
      const [x, O] = this._svdwf(r), L = O.redSqrt();
      return L.redIsOdd() !== r.redIsOdd() && L.redINeg(), this.point(x, L);
    }
    _svdwi(r, x) {
      const { b: O, c: L, z: X, zero: P, two: K } = this, { x: re, y: ce } = r, le = x & 3, me = X.redSqr(), ne = me.redMul(X), W = me.redSqr(), te = ne.redAdd(O), pe = te.redMuln(2), Ee = re.redSqr(), Ae = re.redMuln(2).redIAdd(X), Oe = re.redMul(me), Be = L.redSub(Ae), ke = L.redAdd(Ae), Ne = Ee.redMul(me).redIAdd(W).redIMuln(9), Ke = re.redMul(ne).redIMuln(18), Ce = te.redMul(re.redSub(X)).redIMuln(12), vt = (le >= 2 ? Ne.redISub(Ke).redIAdd(Ce).redSqrt() : P).redMul(X), Ve = ne.redISub(Oe).redIMuln(3).redISub(pe), Xe = te.redMul(Be), qt = te.redMul(ke), Ge = Ve.redAdd(vt), Je = Ve.redSub(vt), Rt = K, We = [Xe, qt, Ge, Je][le], Ze = [ke, Be, Rt, Rt][le], Ft = We.redDivSqrt(Ze), [Qe] = this._svdwf(Ft);
      if (!Qe.eq(re))
        throw new Error("Invalid point.");
      return Ft.redIsOdd() !== ce.redIsOdd() && Ft.redINeg(), Ft;
    }
    isElliptic() {
      const { a: r, b: x } = this, L = r.redSqr().redMul(r);
      return !x.redSqr().redMuln(27).redIAdd(L.redMuln(4)).isZero();
    }
    jinv() {
      const { a: r, b: x } = this, L = r.redSqr().redMul(r), X = x.redSqr(), P = L.redMuln(4), K = P.redMuln(1728), re = X.redMuln(27).redIAdd(P);
      if (re.isZero())
        throw new Error("Curve is not elliptic.");
      return K.redDiv(re).fromRed();
    }
    point(r, x) {
      return new a(this, r, x);
    }
    jpoint(r, x, O) {
      return new s(this, r, x, O);
    }
    solveX(r) {
      if (I(r instanceof c), !this.a.isZero())
        throw new Error("Not implemented.");
      const O = r.redSqr().redSub(this.b);
      return B(O);
    }
    solveY2(r) {
      I(r instanceof c);
      const O = r.redSqr().redMul(r).redIAdd(this.b);
      return this.zeroA || (this.threeA ? O.redIAdd(r.redMuln(-3)) : O.redIAdd(this.a.redMul(r))), O;
    }
    validate(r) {
      if (I(r instanceof a), r.inf)
        return !0;
      const { x, y: O } = r, L = this.solveY2(x);
      return O.redSqr().eq(L);
    }
    pointFromX(r, x = null) {
      I(r instanceof c), I(x == null || typeof x == "boolean"), r.red || (r = r.toRed(this.red));
      const O = this.solveY(r);
      if (x != null) {
        if (this.h.cmpn(1) > 0 && O.isZero() && x)
          throw new Error("Invalid point.");
        O.redIsOdd() !== x && O.redINeg();
      }
      return this.point(r, O);
    }
    pointFromY(r, x = 0) {
      I(r instanceof c), I(x >>> 0 === x), r.red || (r = r.toRed(this.red));
      const O = this.solveX(r);
      if (x >= O.length)
        throw new Error("Invalid X coordinate index.");
      const L = O[x];
      return this.point(L, r);
    }
    isIsomorphic(r) {
      if (I(r instanceof f), !r.p.eq(this.p))
        return !1;
      let x, O;
      try {
        [x, O] = this._scale(r);
      } catch {
        return !1;
      }
      if (r.type === "short") {
        const L = this.field(r.a).redMul(x.redSqr()), X = this.field(r.b).redMul(O.redSqr());
        return this.a.eq(L) && this.b.eq(X);
      }
      if (r.type === "mont") {
        const { a3: L, bi: X } = r, P = this.field(L.redMul(X)).redMul(x);
        return this.solveY2(P).isZero();
      }
      if (r.type === "edwards") {
        const L = this.field(r.ad6).redMul(x);
        return this.solveY2(L).isZero();
      }
      return !1;
    }
    isIsogenous(r) {
      return I(r instanceof f), !1;
    }
    pointFromShort(r) {
      if (I(r instanceof a), this.isIsomorphic(r.curve)) {
        if (r.isInfinity())
          return this.point();
        const [x, O] = this._scale(r.curve), L = this.field(r.x), X = this.field(r.y), P = L.redMul(x), K = X.redMul(O);
        return this.point(P, K);
      }
      throw new Error("Not implemented.");
    }
    pointFromMont(r) {
      if (I(r instanceof p), this.isIsomorphic(r.curve)) {
        if (r.isInfinity())
          return this.point();
        const { a3: x, bi: O } = r.curve, [L, X] = this._scale(r.curve), P = r.x.redAdd(x).redMul(O), K = r.y.redMul(O);
        return this.point(
          this.field(P).redMul(L),
          this.field(K).redMul(X)
        );
      }
      throw new Error("Not implemented.");
    }
    pointFromEdwards(r) {
      if (I(r instanceof v), this.isIsomorphic(r.curve)) {
        const { a: x, d: O, ad6: L } = r.curve, [X, P] = this._scale(r.curve);
        if (r.isInfinity())
          return this.point();
        if (r.x.isZero()) {
          const Ne = this.field(L).redMul(X);
          return this.point(Ne, this.zero);
        }
        const { x: K, y: re, z: ce } = r, le = x.redMuln(5), me = O.redMuln(5), ne = O.redSub(x), W = me.redSub(x), te = O.redSub(le), pe = re.redAdd(ce), Ee = re.redSub(ce), Ae = W.redMul(re).redIAdd(te.redMul(ce)), Oe = Ee.redMuln(12), Be = ne.redMul(pe).redMul(ce), ke = Ee.redMul(K).redIMuln(4);
        return this.cpoint(
          this.field(Ae).redMul(X),
          this.field(Oe),
          this.field(Be).redMul(P),
          this.field(ke)
        );
      }
      throw new Error("Not implemented.");
    }
    pointFromUniform(r) {
      if (I(r instanceof c), this.z.isZero() || this.b.isZero())
        throw new Error("Not implemented.");
      if (!this.a.isZero())
        return this._sswu(r);
      if (!this.c.isZero())
        return this._svdw(r);
      throw new Error("Not implemented.");
    }
    pointToUniform(r, x) {
      if (I(r instanceof a), I(x >>> 0 === x), this.z.isZero() || this.b.isZero())
        throw new Error("Not implemented.");
      if (r.isInfinity())
        throw new Error("Invalid point.");
      const O = (x >>> 4 & 15) % this.torsion.length, L = r.add(this.torsion[O]);
      return se(() => {
        if (!this.a.isZero())
          return this._sswui(L, x);
        if (!this.c.isZero())
          return this._svdwi(L, x);
        throw new Error("Not implemented.");
      });
    }
    mulAll(r, x) {
      return super.mulAll(r, x).toP();
    }
    affinizeAll(r) {
      const x = this.normalizeAll(r);
      for (let O = 0; O < x.length; O++)
        x[O] = x[O].toP();
      return x;
    }
    decodePoint(r) {
      return a.decode(this, r);
    }
    encodeX(r) {
      return I(r instanceof n), r.encodeX();
    }
    decodeEven(r) {
      return a.decodeEven(this, r);
    }
    decodeSquare(r) {
      return a.decodeSquare(this, r);
    }
    toShort(r, x, O = null) {
      const [L, X] = this._short(r, x), P = new u({
        red: this.red,
        prime: this.prime,
        p: this.p,
        a: L,
        b: X,
        n: this.n,
        h: this.h
      });
      if (O != null) {
        const [, K] = P._scale(this);
        K.redIsOdd() !== O && K.redINeg();
      }
      this.g.isInfinity() || (P.g = P.pointFromShort(this.g));
      for (let K = 0; K < this.h.word(0); K++)
        P.torsion[K] = P.pointFromShort(this.torsion[K]);
      return P;
    }
    toMont(r, x, O = null) {
      const [L, X] = this._mont(r, x), P = new i({
        red: this.red,
        prime: this.prime,
        p: this.p,
        a: L,
        b: X,
        n: this.n,
        h: this.h
      });
      if (O != null) {
        const [, K] = this._scale(P);
        K.redIsOdd() !== O && K.redINeg();
      }
      this.g.isInfinity() || (P.g = P.pointFromShort(this.g));
      for (let K = 0; K < this.h.word(0); K++)
        P.torsion[K] = P.pointFromShort(this.torsion[K]);
      return P;
    }
    toEdwards(r, x, O = null) {
      const [L, X] = this._edwards(r, x), P = new E({
        red: this.red,
        prime: this.prime,
        p: this.p,
        a: L,
        d: X,
        n: this.n,
        h: this.h
      });
      if (O != null) {
        const [, K] = this._scale(P);
        K.redIsOdd() !== O && K.redINeg();
      }
      if (this.g.isInfinity() || (P.g = P.pointFromShort(this.g), P.g.normalize()), P.isComplete())
        for (let K = 0; K < this.h.word(0); K++)
          P.torsion[K] = P.pointFromShort(this.torsion[K]), P.torsion[K].normalize();
      return P;
    }
    pointFromJSON(r) {
      return a.fromJSON(this, r);
    }
    toJSON(r) {
      const x = super.toJSON(r);
      return x.a = this.a.fromRed().toJSON(), x.b = this.b.fromRed().toJSON(), this.c.isZero() || (x.c = this.c.fromRed().toJSON()), x;
    }
  }
  class a extends n {
    constructor(r, x, O) {
      I(r instanceof u), super(r, d.AFFINE), this.x = this.curve.zero, this.y = this.curve.zero, this.inf = !0, x != null && this._init(x, O);
    }
    _init(r, x) {
      I(r instanceof c), I(x instanceof c), this.x = r, this.y = x, this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1;
    }
    _getBeta() {
      if (!this.curve.endo)
        return null;
      if (this.pre && this.pre.beta)
        return this.pre.beta;
      const r = this.x.redMul(this.curve.endo.beta), x = this.curve.point(r, this.y);
      return this.pre && (x.pre = this.pre.map((O) => {
        const L = O.x.redMul(this.curve.endo.beta);
        return this.curve.point(L, O.y);
      }), this.pre.beta = x), x;
    }
    _getJNAF(r) {
      if (I(r instanceof a), this.inf || r.inf)
        return super._getJNAF(r);
      const x = [
        this,
        // 1
        null,
        // 3
        null,
        // 5
        r
        // 7
      ];
      return this.y.eq(r.y) ? (x[1] = this.add(r), x[2] = this.toJ().sub(r)) : this.y.eq(r.y.redNeg()) ? (x[1] = this.toJ().add(r), x[2] = this.sub(r)) : (x[1] = this.toJ().add(r), x[2] = this.toJ().sub(r)), x;
    }
    clone() {
      return this.inf ? this.curve.point() : this.curve.point(this.x, this.y);
    }
    scale(r) {
      return this.toJ().scale(r);
    }
    neg() {
      return this.inf ? this : this.curve.point(this.x, this.y.redNeg());
    }
    add(r) {
      if (I(r instanceof a), this.inf)
        return r;
      if (r.inf)
        return this;
      if (this.x.eq(r.x))
        return this.y.eq(r.y) ? this.dbl() : this.curve.point();
      if (this.y.eq(r.y)) {
        const K = this.x.redNeg().redISub(r.x), re = this.y.redNeg();
        return this.curve.point(K, re);
      }
      const x = this.x.redSub(r.x), L = this.y.redSub(r.y).redDiv(x), X = L.redSqr().redISub(this.x).redISub(r.x), P = L.redMul(this.x.redSub(X)).redISub(this.y);
      return this.curve.point(X, P);
    }
    dbl() {
      if (this.inf)
        return this;
      if (this.y.isZero())
        return this.curve.point();
      const x = this.x.redSqr().redIMuln(3).redIAdd(this.curve.a), O = this.y.redMuln(2), L = x.redDiv(O), X = L.redSqr().redISub(this.x).redISub(this.x), P = L.redMul(this.x.redSub(X)).redISub(this.y);
      return this.curve.point(X, P);
    }
    dblp(r) {
      return this.toJ().dblp(r).toP();
    }
    getX() {
      if (this.inf)
        throw new Error("Invalid point.");
      return this.x.fromRed();
    }
    getY() {
      if (this.inf)
        throw new Error("Invalid point.");
      return this.y.fromRed();
    }
    eq(r) {
      return I(r instanceof a), this === r ? !0 : this.inf ? r.inf : r.inf ? !1 : this.x.eq(r.x) && this.y.eq(r.y);
    }
    cmp(r) {
      return I(r instanceof a), this.inf && !r.inf ? -1 : !this.inf && r.inf ? 1 : this.inf && r.inf ? 0 : this.order().cmp(r.order()) || this.getX().cmp(r.getX()) || this.getY().cmp(r.getY());
    }
    isInfinity() {
      return this.inf;
    }
    isOrder2() {
      return this.inf ? !1 : this.y.isZero();
    }
    isOdd() {
      return this.inf ? !1 : this.y.redIsOdd();
    }
    isEven() {
      return this.inf ? !1 : this.y.redIsEven();
    }
    isSquare() {
      return this.inf ? !1 : this.y.redJacobi() !== -1;
    }
    eqX(r) {
      return I(r instanceof c), I(!r.red), this.inf ? !1 : this.getX().eq(r);
    }
    eqR(r) {
      return I(r instanceof c), I(!r.red), I(!this.curve.n.isZero()), this.inf ? !1 : this.getX().imod(this.curve.n).eq(r);
    }
    mul(r) {
      return super.mul(r).toP();
    }
    muln(r) {
      return super.muln(r).toP();
    }
    mulBlind(r, x) {
      return super.mulBlind(r, x).toP();
    }
    mulAdd(r, x, O) {
      return super.mulAdd(r, x, O).toP();
    }
    mulH() {
      return super.mulH().toP();
    }
    div(r) {
      return super.div(r).toP();
    }
    divn(r) {
      return super.divn(r).toP();
    }
    divH() {
      return super.divH().toP();
    }
    toP() {
      return this;
    }
    toJ() {
      return this.inf ? this.curve.jpoint() : this.curve.jpoint(this.x, this.y, this.curve.one);
    }
    encode(r) {
      r == null && (r = !0), I(typeof r == "boolean");
      const { fieldSize: x } = this.curve;
      if (this.inf)
        throw new Error("Invalid point.");
      if (r) {
        const P = k.alloc(1 + x), K = this.curve.encodeField(this.getX());
        return P[0] = 2 | this.y.redIsOdd(), K.copy(P, 1), P;
      }
      const O = k.alloc(1 + x * 2), L = this.curve.encodeField(this.getX()), X = this.curve.encodeField(this.getY());
      return O[0] = 4, L.copy(O, 1), X.copy(O, 1 + x), O;
    }
    static decode(r, x) {
      I(r instanceof u), I(k.isBuffer(x));
      const O = r.fieldSize;
      if (x.length < 1 + O)
        throw new Error("Not a point.");
      const L = x[0];
      switch (L) {
        case 2:
        case 3: {
          if (x.length !== 1 + O)
            throw new Error("Invalid point size for compressed.");
          const X = r.decodeField(x.slice(1, 1 + O));
          if (X.cmp(r.p) >= 0)
            throw new Error("Invalid point.");
          const P = r.pointFromX(X, L === 3);
          return I(!P.isInfinity()), P;
        }
        case 4:
        case 6:
        case 7: {
          if (x.length !== 1 + O * 2)
            throw new Error("Invalid point size for uncompressed.");
          const X = r.decodeField(x.slice(1, 1 + O)), P = r.decodeField(x.slice(1 + O, 1 + 2 * O));
          if (X.cmp(r.p) >= 0 || P.cmp(r.p) >= 0)
            throw new Error("Invalid point.");
          if (L !== 4 && L !== (6 | P.isOdd()))
            throw new Error("Invalid hybrid encoding.");
          const K = r.point(X, P);
          if (!K.validate())
            throw new Error("Invalid point.");
          return I(!K.isInfinity()), K;
        }
        default:
          throw new Error("Unknown point format.");
      }
    }
    encodeX() {
      return this.curve.encodeField(this.getX());
    }
    static decodeEven(r, x) {
      I(r instanceof u);
      const O = r.decodeField(x);
      if (O.cmp(r.p) >= 0)
        throw new Error("Invalid point.");
      return r.pointFromX(O, !1);
    }
    static decodeSquare(r, x) {
      I(r instanceof u);
      const O = r.decodeField(x);
      if (O.cmp(r.p) >= 0)
        throw new Error("Invalid point.");
      return r.pointFromX(O);
    }
    toJSON(r) {
      if (this.inf)
        return [];
      const x = this.getX().toJSON(), O = this.getY().toJSON();
      return r === !0 && this.pre ? [x, O, this.pre.toJSON()] : [x, O];
    }
    toPretty() {
      if (this.inf)
        return [];
      const r = this.curve.fieldSize * 2, x = M(this.getX(), r), O = M(this.getY(), r);
      return [x, O];
    }
    static fromJSON(r, x) {
      if (I(r instanceof u), I(Array.isArray(x)), I(x.length === 0 || x.length === 2 || x.length === 3), x.length === 0)
        return r.point();
      const O = c.fromJSON(x[0]), L = c.fromJSON(x[1]), X = r.point(O, L);
      return x.length > 2 && x[2] != null && (X.pre = b.fromJSON(X, x[2])), X;
    }
    [e]() {
      return this.inf ? "<ShortPoint: Infinity>" : "<ShortPoint: x=" + this.x.fromRed().toString(16, 2) + " y=" + this.y.fromRed().toString(16, 2) + ">";
    }
  }
  class s extends n {
    constructor(r, x, O, L) {
      I(r instanceof u), super(r, d.JACOBIAN), this.x = this.curve.one, this.y = this.curve.one, this.z = this.curve.zero, this.zOne = !1, x != null && this._init(x, O, L);
    }
    _init(r, x, O) {
      I(r instanceof c), I(x instanceof c), I(O == null || O instanceof c), this.x = r, this.y = x, this.z = O || this.curve.one, this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z.eq(this.curve.one);
    }
    clone() {
      return this.curve.jpoint(this.x, this.y, this.z);
    }
    validate() {
      const { a: r, b: x } = this.curve;
      if (this.isInfinity())
        return !0;
      if (this.zOne)
        return this.curve.validate(this.toP());
      const O = this.y.redSqr(), L = this.x.redSqr().redMul(this.x), X = this.z.redSqr(), P = X.redSqr(), K = P.redMul(X), re = L.redIAdd(x.redMul(K));
      return this.curve.zeroA || (this.curve.threeA ? re.redIAdd(P.redIMuln(-3).redMul(this.x)) : re.redIAdd(r.redMul(P).redMul(this.x))), O.eq(re);
    }
    normalize() {
      if (this.zOne)
        return this;
      if (this.isInfinity())
        return this;
      const r = this.z.redInvert(), x = r.redSqr();
      return this.x = this.x.redMul(x), this.y = this.y.redMul(x).redMul(r), this.z = this.curve.one, this.zOne = !0, this;
    }
    scale(r) {
      if (I(r instanceof c), this.isInfinity())
        return this.curve.jpoint();
      const x = r.redSqr(), O = this.x.redMul(x), L = this.y.redMul(x).redMul(r), X = this.z.redMul(r);
      return this.curve.jpoint(O, L, X);
    }
    neg() {
      return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
    }
    add(r) {
      return I(r instanceof n), r.type === d.AFFINE ? this._mixedAdd(r) : this._add(r);
    }
    _add(r) {
      return I(r instanceof s), this.isInfinity() ? r : r.isInfinity() ? this : this.zOne ? r._addJA(this) : r.zOne ? this._addJA(r) : this._addJJ(r);
    }
    _mixedAdd(r) {
      return I(r instanceof a), this.isInfinity() ? r.toJ() : r.isInfinity() ? this : this._addJA(r);
    }
    _addJJ(r) {
      const x = this.z.redSqr(), O = r.z.redSqr(), L = this.x.redMul(O), X = r.x.redMul(x), P = this.y.redMul(r.z).redMul(O), K = r.y.redMul(this.z).redMul(x), re = X.redISub(L), ce = K.redISub(P);
      if (re.isZero())
        return ce.isZero() ? this.dbl() : this.curve.jpoint();
      const le = re.redSqr(), me = re.redMul(le), ne = L.redMul(le), W = ce.redSqr().redISub(me).redISub(ne).redISub(ne), te = ce.redMul(ne.redISub(W)).redISub(P.redMul(me)), pe = this.z.redMul(r.z).redMul(re);
      return this.curve.jpoint(W, te, pe);
    }
    _addJA(r) {
      const x = this.z.redSqr(), O = r.x.redMul(x), L = r.y.redMul(this.z).redMul(x), X = O.redISub(this.x), P = L.redISub(this.y).redIMuln(2);
      if (X.isZero())
        return P.isZero() ? this.dbl() : this.curve.jpoint();
      const K = X.redMuln(2).redSqr(), re = X.redMul(K), ce = this.x.redMul(K), le = P.redSqr().redISub(re).redISub(ce).redISub(ce), me = P.redMul(ce.redISub(le)).redISub(this.y.redMul(re).redIMuln(2)), ne = this.z.redMul(X).redIMuln(2);
      return this.curve.jpoint(le, me, ne);
    }
    dbl() {
      return this.isInfinity() ? this : this.y.isZero() ? this.curve.jpoint() : this.curve.zeroA ? this._dbl0() : this.curve.threeA ? this._dbl3() : this._dblJ();
    }
    _dblJ() {
      const r = this.x.redSqr(), x = this.y.redSqr(), O = this.z.redSqr(), L = this.x.redMul(x).redIMuln(4), X = r.redIMuln(3).redIAdd(this.curve.a.redMul(O.redSqr())), P = X.redSqr().redISub(L).redISub(L), K = P, re = X.redMul(L.redISub(P)).redISub(x.redSqr().redIMuln(8)), ce = this.y.redMul(this.z).redIMuln(2);
      return this.curve.jpoint(K, re, ce);
    }
    _dbl0() {
      const r = this.x.redSqr(), x = this.y.redSqr(), O = x.redSqr(), X = x.redIAdd(this.x).redSqr().redISub(r).redISub(O).redIMuln(2), P = r.redIMuln(3), re = P.redSqr().redISub(X).redISub(X), ce = P.redMul(X.redISub(re)).redISub(O.redIMuln(8)), le = this.y.redMul(this.z).redIMuln(2);
      return this.curve.jpoint(re, ce, le);
    }
    _dbl3() {
      const r = this.z.redSqr(), x = this.y.redSqr(), O = this.x.redMul(x), L = this.x.redSub(r), X = this.x.redAdd(r), P = L.redMul(X).redIMuln(3), K = O.redIMuln(4), re = K.redMuln(2), ce = x.redSqr().redIMuln(8), le = P.redSqr().redISub(re), me = this.y.redAdd(this.z).redSqr().redISub(x).redISub(r), ne = P.redMul(K.redISub(le)).redISub(ce);
      return this.curve.jpoint(le, ne, me);
    }
    getX() {
      if (this.isInfinity())
        throw new Error("Invalid point.");
      return this.normalize(), this.x.fromRed();
    }
    getY() {
      if (this.isInfinity())
        throw new Error("Invalid point.");
      return this.normalize(), this.y.fromRed();
    }
    eq(r) {
      if (I(r instanceof s), this === r)
        return !0;
      if (this.isInfinity())
        return r.isInfinity();
      if (r.isInfinity())
        return !1;
      if (this.z.eq(r.z))
        return this.x.eq(r.x) && this.y.eq(r.y);
      const x = this.z.redSqr(), O = r.z.redSqr(), L = this.x.redMul(O), X = r.x.redMul(x);
      if (!L.eq(X))
        return !1;
      const P = x.redMul(this.z), K = O.redMul(r.z), re = this.y.redMul(K), ce = r.y.redMul(P);
      return re.eq(ce);
    }
    cmp(r) {
      I(r instanceof s);
      const x = this.isInfinity(), O = r.isInfinity();
      return x && !O ? -1 : !x && O ? 1 : x && O ? 0 : this.order().cmp(r.order()) || this.getX().cmp(r.getX()) || this.getY().cmp(r.getY());
    }
    isInfinity() {
      return this.z.isZero();
    }
    isOrder2() {
      return this.isInfinity() ? !1 : this.y.isZero();
    }
    isOdd() {
      return this.isInfinity() ? !1 : (this.normalize(), this.y.redIsOdd());
    }
    isEven() {
      return this.isInfinity() ? !1 : (this.normalize(), this.y.redIsEven());
    }
    isSquare() {
      return this.isInfinity() ? !1 : this.y.redMul(this.z).redJacobi() !== -1;
    }
    eqX(r) {
      if (I(r instanceof c), I(!r.red), this.isInfinity())
        return !1;
      const x = this.z.redSqr(), O = r.toRed(this.curve.red).redMul(x);
      return this.x.eq(O);
    }
    eqR(r) {
      if (I(r instanceof c), I(!r.red), !this.curve.smallGap)
        return this.toP().eqR(r);
      if (this.isInfinity() || r.cmp(this.curve.p) >= 0)
        return !1;
      const x = this.z.redSqr(), O = r.toRed(this.curve.red).redMul(x);
      if (this.x.eq(O))
        return !0;
      if (this.curve.highOrder || r.cmp(this.curve.pmodn) >= 0)
        return !1;
      const L = this.curve.redN.redMul(x);
      return O.redIAdd(L), this.x.eq(O);
    }
    toP() {
      return this.isInfinity() ? this.curve.point() : (this.normalize(), this.curve.point(this.x, this.y));
    }
    toJ() {
      return this;
    }
    encode(r) {
      return this.toP().encode(r);
    }
    static decode(r, x) {
      return a.decode(r, x).toJ();
    }
    encodeX() {
      return this.toP().encodeX();
    }
    static decodeEven(r, x) {
      return a.decodeEven(r, x).toJ();
    }
    static decodeSquare(r, x) {
      return a.decodeSquare(r, x).toJ();
    }
    toJSON(r) {
      return this.toP().toJSON(r);
    }
    toPretty() {
      return this.toP().toPretty();
    }
    static fromJSON(r, x) {
      return a.fromJSON(r, x).toJ();
    }
    [e]() {
      return this.isInfinity() ? "<JPoint: Infinity>" : "<JPoint: x=" + this.x.fromRed().toString(16, 2) + " y=" + this.y.fromRed().toString(16, 2) + " z=" + this.z.fromRed().toString(16, 2) + ">";
    }
  }
  class i extends f {
    constructor(r) {
      super(p, "mont", r), this.a = c.fromJSON(r.a).toRed(this.red), this.b = c.fromJSON(r.b).toRed(this.red), this.bi = this.b.redInvert(), this.a2 = this.a.redAdd(this.two), this.a24 = this.a2.redMul(this.i4), this.a3 = this.a.redMul(this.i3), this.a0 = this.a.redMul(this.bi), this.b0 = this.bi.redSqr(), this._finalize(r);
    }
    static _isomorphism(r, x, O) {
      I(r instanceof c), I(x instanceof c), I(O instanceof c);
      const L = r.clone(), X = O.clone();
      if (x.redDiv(O).redJacobi() !== 1)
        throw new Error("Invalid `b` coefficient.");
      return [L, X];
    }
    _short(r, x) {
      const { a: O, b: L, three: X } = this, P = O.redSqr(), K = P.redMul(O), re = L.redSqr(), ce = re.redMul(L), le = X.redSub(P), me = re.redMuln(3), ne = K.redMuln(2).redISub(O.redMuln(9)), W = ce.redMuln(27), te = le.redDiv(me), pe = ne.redDiv(W);
      return r != null ? u._isomorphism(te, pe, r, x) : [te, pe];
    }
    _mont(r) {
      return i._isomorphism(this.a, this.b, r);
    }
    _edwards(r, x = !1) {
      I(typeof x == "boolean");
      const { two: O, bi: L } = this, X = this.a.redAdd(O).redMul(L), P = this.a.redSub(O).redMul(L);
      return x && X.swap(P), r != null ? E._isomorphism(X, P, r) : [X, P];
    }
    _scaleShort(r) {
      I(r instanceof u);
      const [x, O] = r._scale(this);
      return [
        this.field(x.redInvert()),
        this.field(O.redInvert())
      ];
    }
    _scaleMont(r) {
      return I(r instanceof i), this.g.isInfinity() || r.g.isInfinity() ? this.field(r.b).redDivSqrt(this.b) : this.g.y.redDiv(this.field(r.g.y));
    }
    _scaleEdwards(r, x) {
      I(r instanceof E);
      const O = r._scale(this, x);
      return this.field(O);
    }
    _solveY0(r) {
      I(r instanceof c);
      const x = this.a0, O = this.b0, L = r.redSqr();
      return L.redMul(r).redIAdd(x.redMul(L)).redIAdd(O.redMul(r));
    }
    _elligator2(r) {
      const x = this.a0.redNeg(), O = this.one.redAdd(this.z.redMul(r.redSqr()));
      O.isZero() && O.inject(this.one);
      const L = x.redMul(O.redInvert()), X = L.redNeg().redISub(this.a0), P = this._solveY0(L), K = this._solveY0(X), re = P.redIsSquare() | 0, ce = [L, X][re ^ 1], le = [P, K][re ^ 1].redSqrt();
      le.redIsOdd() !== r.redIsOdd() && le.redINeg();
      const me = this.b.redMul(ce), ne = this.b.redMul(le);
      return this.point(me, ne);
    }
    _invert2(r, x) {
      const { x: O, y: L } = r, X = x & 1, P = O.redMul(this.bi), K = L.redMul(this.bi), re = P.redAdd(this.a0), ce = P, le = [re, ce][X].redINeg(), me = [ce, re][X].redMul(this.z), ne = le.redDivSqrt(me);
      return ne.redIsOdd() !== K.redIsOdd() && ne.redINeg(), ne;
    }
    isElliptic() {
      const r = this.a.redSqr();
      return !this.b.redMul(r.redSub(this.four)).isZero();
    }
    jinv() {
      const { a: r, three: x, four: O } = this, L = r.redSqr(), P = L.redSub(x).redPown(3).redIMuln(256), K = L.redSub(O);
      if (K.isZero())
        throw new Error("Curve is not elliptic.");
      return P.redDiv(K).fromRed();
    }
    point(r, x) {
      return new p(this, r, x);
    }
    jpoint(r, x, O) {
      return I(r == null && x == null && O == null), this.point();
    }
    xpoint(r, x) {
      return new m(this, r, x);
    }
    solveY2(r) {
      I(r instanceof c);
      const x = r.redSqr();
      return x.redMul(r).redIAdd(this.a.redMul(x)).redIAdd(r).redMul(this.bi);
    }
    validate(r) {
      if (I(r instanceof p), r.isInfinity())
        return !0;
      const { x, y: O } = r, L = this.solveY2(x);
      return O.redSqr().eq(L);
    }
    pointFromX(r, x = null) {
      I(r instanceof c), I(x == null || typeof x == "boolean"), r.red || (r = r.toRed(this.red));
      const O = this.solveY(r);
      if (x != null) {
        if (O.isZero() && x)
          throw new Error("Invalid point.");
        O.redIsOdd() !== x && O.redINeg();
      }
      return this.point(r, O);
    }
    isIsomorphic(r, x) {
      if (I(r instanceof f), !r.p.eq(this.p))
        return !1;
      if (r.type === "mont") {
        const O = this.field(r.a), L = this.field(r.b);
        return !this.a.eq(O) || this.b.isZero() ? !1 : L.redDiv(this.b).redJacobi() === 1;
      }
      return r.isIsomorphic(this, x);
    }
    isIsogenous(r) {
      return I(r instanceof f), r.type === "mont" ? !1 : r.isIsogenous(this);
    }
    pointFromShort(r) {
      if (I(r instanceof a), this.isIsomorphic(r.curve)) {
        if (r.isInfinity())
          return this.point();
        const { a3: x, b: O } = this, [L, X] = this._scale(r.curve), P = this.field(r.x).redMul(L), K = this.field(r.y).redMul(X), re = O.redMul(P).redISub(x), ce = O.redMul(K);
        return this.point(re, ce);
      }
      throw new Error("Not implemented.");
    }
    pointFromMont(r) {
      if (I(r instanceof p), this.isIsomorphic(r.curve)) {
        if (r.isInfinity())
          return this.point();
        const x = this._scale(r.curve), O = this.field(r.x), L = this.field(r.y), X = O, P = x.redMul(L);
        return this.point(X, P);
      }
      throw new Error("Not implemented.");
    }
    pointFromEdwards(r) {
      I(r instanceof v), I(r.curve.p.eq(this.p));
      const x = this.field(r.x), O = this.field(r.y), L = this.field(r.z);
      if (this.isIsogenous(r.curve)) {
        if (r.isInfinity())
          return this.point();
        if (r.x.isZero())
          return this.point(this.zero, this.zero);
        const X = L.redSqr().redIMuln(2), P = O.redSqr(), K = x.redSqr(), re = X.redISub(K).redISub(P).redMul(O), ce = K.redMul(x);
        return this.cpoint(P, K, re, ce);
      }
      if (this.isIsomorphic(r.curve, !0)) {
        if (r.isInfinity())
          return this.point();
        if (r.x.isZero())
          return this.point(this.zero, this.zero);
        const X = this._scale(r.curve, !0), P = O.redAdd(L), K = O.redSub(L), re = X.redMul(L).redMul(P), ce = x.redMul(K);
        return this.cpoint(P, K, re, ce);
      }
      if (this.isIsomorphic(r.curve, !1)) {
        if (r.isInfinity())
          return this.point();
        if (r.x.isZero())
          return this.point(this.zero, this.zero);
        const X = this._scale(r.curve, !1), P = L.redAdd(O), K = L.redSub(O), re = X.redMul(L).redMul(P), ce = x.redMul(K);
        return this.cpoint(P, K, re, ce);
      }
      throw new Error("Not implemented.");
    }
    pointFromUniform(r) {
      if (I(r instanceof c), this.z.isZero() || this.a.isZero())
        throw new Error("Not implemented.");
      return this._elligator2(r);
    }
    pointToUniform(r, x) {
      if (I(r instanceof p), I(x >>> 0 === x), this.z.isZero() || this.a.isZero())
        throw new Error("Not implemented.");
      if (r.isInfinity())
        throw new Error("Invalid point.");
      const O = (x >>> 4 & 15) % this.torsion.length, L = r.add(this.torsion[O]);
      return se(() => this._invert2(L, x));
    }
    decodePoint(r, x) {
      return p.decode(this, r, x);
    }
    encodeX(r) {
      return I(r instanceof m), r.encode();
    }
    decodeX(r) {
      return m.decode(this, r);
    }
    toShort(r, x, O = null) {
      const [L, X] = this._short(r, x), P = new u({
        red: this.red,
        prime: this.prime,
        p: this.p,
        a: L,
        b: X,
        n: this.n,
        h: this.h
      });
      if (O != null) {
        const [, K] = P._scale(this);
        K.redIsOdd() !== O && K.redINeg();
      }
      this.g.isInfinity() || (P.g = P.pointFromMont(this.g));
      for (let K = 0; K < this.h.word(0); K++)
        P.torsion[K] = P.pointFromMont(this.torsion[K]);
      return P;
    }
    toMont(r, x = null) {
      const [O, L] = this._mont(r), X = new i({
        red: this.red,
        prime: this.prime,
        p: this.p,
        a: O,
        b: L,
        n: this.n,
        h: this.h,
        z: this.z
      });
      if (x != null) {
        const P = X._scale(this);
        P.redIsOdd() !== x && P.redINeg();
      }
      this.g.isInfinity() || (X.g = X.pointFromMont(this.g));
      for (let P = 0; P < this.h.word(0); P++)
        X.torsion[P] = X.pointFromMont(this.torsion[P]);
      return X;
    }
    toEdwards(r, x, O = null) {
      const [L, X] = this._edwards(r, x), P = new E({
        red: this.red,
        prime: this.prime,
        p: this.p,
        a: L,
        d: X,
        n: this.n,
        h: this.h,
        z: this.z
      });
      if (O != null) {
        const K = P._scale(this, x);
        K.redIsOdd() !== O && K.redINeg();
      }
      if (this.g.isInfinity() || (P.g = P.pointFromMont(this.g), P.g.normalize()), P.isComplete())
        for (let K = 0; K < this.h.word(0); K++)
          P.torsion[K] = P.pointFromMont(this.torsion[K]), P.torsion[K].normalize();
      return P;
    }
    pointFromJSON(r) {
      return p.fromJSON(this, r);
    }
    toJSON(r) {
      const x = super.toJSON(r);
      return x.a = this.a.fromRed().toJSON(), x.b = this.b.fromRed().toJSON(), x;
    }
  }
  class p extends n {
    constructor(r, x, O) {
      I(r instanceof i), super(r, d.AFFINE), this.x = this.curve.zero, this.y = this.curve.zero, this.inf = !0, x != null && this._init(x, O);
    }
    _init(r, x) {
      I(r instanceof c), I(x instanceof c), this.x = r, this.y = x, this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1;
    }
    clone() {
      return this.inf ? this.curve.point() : this.curve.point(this.x, this.y);
    }
    scale(r) {
      return this.clone();
    }
    randomize(r) {
      return this.clone();
    }
    neg() {
      return this.inf ? this : this.curve.point(this.x, this.y.redNeg());
    }
    add(r) {
      if (I(r instanceof p), this.inf)
        return r;
      if (r.inf)
        return this;
      if (this.x.eq(r.x))
        return this.y.eq(r.y) ? this.dbl() : this.curve.point();
      const x = r.x.redSub(this.x), L = r.y.redSub(this.y).redDiv(x), P = this.curve.b.redMul(L.redSqr()).redISub(this.curve.a).redISub(this.x).redISub(r.x), K = L.redMul(this.x.redSub(P)).redISub(this.y);
      return this.curve.point(P, K);
    }
    dbl() {
      if (this.inf)
        return this;
      if (this.y.isZero())
        return this.curve.point();
      const r = this.x.redSqr().redIMuln(3), x = this.curve.a.redMul(this.x).redIMuln(2), O = r.redIAdd(x).redIAdd(this.curve.one), L = this.curve.b.redMul(this.y).redIMuln(2), X = O.redDiv(L), K = this.curve.b.redMul(X.redSqr()).redISub(this.curve.a).redISub(this.x).redISub(this.x), re = X.redMul(this.x.redSub(K)).redISub(this.y);
      return this.curve.point(K, re);
    }
    getX() {
      if (this.inf)
        throw new Error("Invalid point.");
      return this.x.fromRed();
    }
    getY() {
      if (this.inf)
        throw new Error("Invalid point.");
      return this.y.fromRed();
    }
    eq(r) {
      return I(r instanceof p), this === r ? !0 : this.inf ? r.inf : r.inf ? !1 : this.x.eq(r.x) && this.y.eq(r.y);
    }
    cmp(r) {
      return I(r instanceof p), this.inf && !r.inf ? -1 : !this.inf && r.inf ? 1 : this.inf && r.inf ? 0 : this.order().cmp(r.order()) || this.getX().cmp(r.getX()) || this.getY().cmp(r.getY());
    }
    isInfinity() {
      return this.inf;
    }
    isOrder2() {
      return this.inf ? !1 : this.y.isZero();
    }
    isOdd() {
      return this.inf ? !1 : this.y.redIsOdd();
    }
    isEven() {
      return this.inf ? !1 : this.y.redIsEven();
    }
    toP() {
      return this;
    }
    toJ() {
      return this;
    }
    toX() {
      return this.inf ? this.curve.xpoint() : this.curve.xpoint(this.x, this.curve.one);
    }
    encode() {
      return this.toX().encode();
    }
    static decode(r, x, O) {
      return I(r instanceof i), r.decodeX(x).toP(O);
    }
    toJSON(r) {
      if (this.inf)
        return [];
      const x = this.getX().toJSON(), O = this.getY().toJSON();
      return [x, O];
    }
    toPretty() {
      if (this.inf)
        return [];
      const r = this.curve.fieldSize * 2, x = M(this.getX(), r), O = M(this.getY(), r);
      return [x, O];
    }
    static fromJSON(r, x) {
      if (I(r instanceof i), I(Array.isArray(x)), I(x.length === 0 || x.length === 2 || x.length === 3), x.length === 0)
        return r.point();
      const O = c.fromJSON(x[0]), L = c.fromJSON(x[1]);
      return r.point(O, L);
    }
    [e]() {
      return this.inf ? "<MontPoint: Infinity>" : "<MontPoint: x=" + this.x.fromRed().toString(16, 2) + " y=" + this.y.fromRed().toString(16, 2) + ">";
    }
  }
  class m extends n {
    constructor(r, x, O) {
      I(r instanceof i), super(r, d.PROJECTIVE), this.x = this.curve.one, this.z = this.curve.zero, x != null && this._init(x, O);
    }
    _init(r, x) {
      I(r instanceof c), I(x == null || x instanceof c), this.x = r, this.z = x || this.curve.one, this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red));
    }
    clone() {
      return this.curve.xpoint(this.x, this.z);
    }
    precompute(r, x) {
      return this;
    }
    validate() {
      if (this.isInfinity())
        return !0;
      const { x: r, z: x } = this, O = r.redSqr(), L = O.redMul(r), X = x.redSqr(), P = this.curve.a.redMul(O).redMul(x);
      return L.redIAdd(P).redIAdd(r.redMul(X)).redMul(this.curve.bi).redMul(x).redJacobi() !== -1;
    }
    normalize() {
      return this.isInfinity() ? this : this.z.eq(this.curve.one) ? this : (this.x = this.x.redDiv(this.z), this.z = this.curve.one, this);
    }
    scale(r) {
      if (I(r instanceof c), this.isInfinity())
        return this.curve.xpoint();
      const x = this.x.redMul(r), O = this.z.redMul(r);
      return this.curve.xpoint(x, O);
    }
    neg() {
      return this;
    }
    dbl() {
      const x = this.x.redAdd(this.z).redSqr(), L = this.x.redSub(this.z).redSqr(), X = x.redSub(L), P = x.redMul(L), K = X.redMul(L.redIAdd(this.curve.a24.redMul(X)));
      return this.curve.xpoint(P, K);
    }
    diffAddDbl(r, x) {
      I(r instanceof m), I(x instanceof m);
      const O = r.x.redAdd(r.z), L = O.redSqr(), X = r.x.redSub(r.z), P = X.redSqr(), K = L.redSub(P), re = x.x.redAdd(x.z), le = x.x.redSub(x.z).redMul(O), me = re.redMul(X), ne = this.z.redMul(le.redAdd(me).redSqr()), W = this.x.redMul(le.redISub(me).redSqr()), te = L.redMul(P), pe = K.redMul(P.redIAdd(this.curve.a24.redMul(K)));
      return [
        this.curve.xpoint(te, pe),
        this.curve.xpoint(ne, W)
      ];
    }
    getX() {
      if (this.isInfinity())
        throw new Error("Invalid point.");
      return this.normalize(), this.x.fromRed();
    }
    getY(r) {
      return this.toP(r).getY();
    }
    eq(r) {
      if (I(r instanceof m), this === r)
        return !0;
      if (this.isInfinity())
        return r.isInfinity();
      if (r.isInfinity())
        return !1;
      if (this.z.eq(r.z))
        return this.x.eq(r.x);
      const x = this.x.redMul(r.z), O = r.x.redMul(this.z);
      return x.eq(O);
    }
    cmp(r) {
      I(r instanceof m);
      const x = this.isInfinity(), O = r.isInfinity();
      return x && !O ? -1 : !x && O ? 1 : x && O ? 0 : this.order().cmp(r.order()) || this.getX().cmp(r.getX());
    }
    isInfinity() {
      return this.z.isZero();
    }
    isOrder2() {
      return this.isInfinity() ? !1 : this.x.isZero();
    }
    isOdd() {
      return !1;
    }
    isEven() {
      return !1;
    }
    hasTorsion() {
      return this.isInfinity() ? !1 : this.x.isZero() ? !0 : super.hasTorsion();
    }
    order() {
      try {
        return this.toP().order();
      } catch {
        return new c(1);
      }
    }
    jmul(r) {
      I(r instanceof c), I(!r.red);
      const x = r.bitLength();
      let O = this.curve.xpoint(), L = this;
      for (let X = x - 1; X >= 0; X--)
        r.bit(X) === 0 ? [O, L] = this.diffAddDbl(O, L) : [L, O] = this.diffAddDbl(L, O);
      return O;
    }
    jmulBlind(r, x) {
      return x ? this.randomize(x).jmul(r) : this.jmul(r);
    }
    jmulAdd(r, x, O) {
      throw new Error("Not implemented.");
    }
    toP(r = null) {
      return I(r == null || typeof r == "boolean"), this.isInfinity() ? this.curve.point() : (this.normalize(), this.curve.pointFromX(this.x, r));
    }
    toJ() {
      return this;
    }
    toX() {
      return this;
    }
    key() {
      if (this.isInfinity())
        return `${this.curve.uid}:oo`;
      this.normalize();
      const r = this.getX().toString(16);
      return `${this.curve.uid}:${r}`;
    }
    encode() {
      return this.curve.encodeField(this.getX());
    }
    static decode(r, x) {
      I(r instanceof i);
      const O = r.decodeField(x);
      O.iumaskn(r.fieldBits);
      const L = r.xpoint(O, r.one);
      return I(!L.isInfinity()), L;
    }
    toJSON(r) {
      return this.toP().toJSON(r);
    }
    toPretty() {
      return this.toP().toPretty();
    }
    static fromJSON(r, x) {
      return p.fromJSON(r, x).toX();
    }
    [e]() {
      return this.isInfinity() ? "<XPoint: Infinity>" : "<XPoint: x=" + this.x.fromRed().toString(16, 2) + " z=" + this.z.fromRed().toString(16, 2) + ">";
    }
  }
  class E extends f {
    constructor(r) {
      super(v, "edwards", r), this.a = c.fromJSON(r.a).toRed(this.red), this.d = c.fromJSON(r.d).toRed(this.red), this.s = c.fromJSON(r.s || "0").toRed(this.red), this.si = this.s.isZero() ? this.zero : this.s.redInvert(), this.k = this.d.redMuln(2), this.smi = -this.d.redNeg().word(0), this.ad6 = this.a.redAdd(this.d).redMul(this.i6), this.twisted = !this.a.eq(this.one), this.oneA = this.a.eq(this.one), this.mOneA = this.a.eq(this.one.redNeg()), this.smallD = this.prime != null && this.d.redNeg().length === 1, this.alt = null, this._finalize(r);
    }
    static _isomorphism(r, x, O) {
      I(r instanceof c), I(x instanceof c), I(O instanceof c);
      const L = O.clone(), X = O.redMul(x).redDiv(r);
      if (r.redDiv(O).redJacobi() !== 1)
        throw new Error("Invalid `a` coefficient.");
      return [L, X];
    }
    _short(r, x) {
      const { a: O, d: L } = this, X = O.redSqr(), P = X.redMul(O), K = L.redSqr(), re = K.redMul(L), ce = O.redMul(L).redIMuln(14), le = X.redMul(L), me = O.redMul(K), ne = le.redIAdd(me).redIMuln(33), W = X.redAdd(ce).redIAdd(K).redDivn(-48), te = ne.redISub(P).redISub(re).redDivn(864);
      return r != null ? u._isomorphism(W, te, r, x) : [W, te];
    }
    _mont(r, x = !1) {
      I(typeof x == "boolean");
      let O, L;
      x ? (O = this.d.redAdd(this.a), L = this.d.redSub(this.a)) : (O = this.a.redAdd(this.d), L = this.a.redSub(this.d));
      const X = L.redInvert(), P = O.redMuln(2).redMul(X), K = X.redMuln(4);
      return r != null ? i._isomorphism(P, K, r) : [P, K];
    }
    _edwards(r) {
      return E._isomorphism(this.a, this.d, r);
    }
    _scaleShort(r) {
      I(r instanceof u);
      const [x, O] = r._scale(this);
      return [
        this.field(x.redInvert()),
        this.field(O.redInvert())
      ];
    }
    _scaleMont(r, x = !1) {
      if (I(r instanceof i), I(typeof x == "boolean"), this.g.isInfinity() || r.g.isInfinity()) {
        const [L] = r._edwards(null, x);
        return this.field(L).redDivSqrt(this.a);
      }
      const O = r.g.x.redDiv(r.g.y);
      return this.g.x.redDiv(this.field(O));
    }
    _scaleEdwards(r) {
      return I(r instanceof E), this.g.isInfinity() || r.g.isInfinity() ? this.field(r.a).redDivSqrt(this.a) : this.g.x.redDiv(this.field(r.g.x));
    }
    _mulA(r) {
      return I(r instanceof c), this.oneA ? r.clone() : this.mOneA ? r.redNeg() : this.a.redMul(r);
    }
    _mulD(r) {
      return I(r instanceof c), this.smallD ? r.redMuln(this.smi) : this.d.redMul(r);
    }
    _elligator1(r) {
      const { s: x, si: O, i2: L, one: X, two: P } = this, K = O.redSqr().redIMuln(2), re = x.redSqr().redMul(L), ce = re.redSqr(), le = K.redAdd(re), me = le.redSqr().redISub(P), ne = K.redSub(X), W = X.redSub(r), te = X.redAdd(r), pe = te.isZero() ? te : W.redDiv(te), Ee = pe.redSqr(), Ae = Ee.redMul(pe), Be = Ae.redMul(Ee).redAdd(me.redMul(Ae)).redIAdd(pe), ke = this.field(Be.redJacobi()), Ne = this.field(Ee.redAdd(ce).redJacobi()), Ke = ke.redMul(Ne), Ce = ke.redMul(pe), Ye = ke.redMul(Be).redSqrt().redMul(Ke), vt = X.redAdd(Ce), Ve = le.redMul(Ce), Xe = vt.redSqr(), qt = ne.redMul(x).redMul(Ce).redMul(vt), Ge = pe.isZero() ? this.one : Ye, Je = Ve.redSub(Xe), Rt = Ve.redAdd(Xe);
      return this.cpoint(qt, Ge, Je, Rt);
    }
    _invert1(r, x) {
      const { s: O, si: L, i2: X, one: P } = this, { x: K, y: re, z: ce } = r, le = x & 1, me = L.redSqr().redIMuln(2), ne = O.redSqr().redMul(X), W = ne.redSqr(), te = me.redAdd(ne), pe = me.redSub(P), Ee = re.redSub(ce), Ae = re.redAdd(ce).redIMuln(2), Oe = Ae.isZero() ? Ae : Ee.redDiv(Ae), Be = P.redAdd(Oe.redMul(te)), Ke = Be.redSqr().redISub(P).redSqrt().redSub(Be), Ce = P.redAdd(Ke), vt = pe.redMul(O).redMul(Ke).redMul(Ce).redMul(K.redMul(ce)), Ve = Ke.redSqr().redIAdd(W), qt = this.field(vt.redMul(Ve).redJacobi()).redMul(Ke), Ge = P.redSub(qt), Je = P.redAdd(qt), Rt = Je.isZero() ? Je : Ge.redDiv(Je);
      return Rt.redIsOdd() !== !!le && Rt.redINeg(), Rt;
    }
    _alt() {
      return this.alt || (this.alt = this.toMont()), this.alt;
    }
    isElliptic() {
      const r = this.a.redMul(this.d), x = this.a.redSub(this.d);
      return !r.redMul(x).isZero();
    }
    jinv() {
      const { a: r, d: x } = this, O = r.redMul(x), L = r.redSub(x).redPown(4), X = r.redSqr(), P = x.redSqr(), re = X.redAdd(O.redMuln(14)).redIAdd(P).redPown(3).redIMuln(16), ce = O.redMul(L);
      if (ce.isZero())
        throw new Error("Curve is not elliptic.");
      return re.redDiv(ce).fromRed();
    }
    isComplete() {
      return this.a.redJacobi() === 1 && this.d.redJacobi() === -1;
    }
    point(r, x, O, L) {
      return new v(this, r, x, O, L);
    }
    jpoint(r, x, O) {
      return I(r == null && x == null && O == null), this.point();
    }
    cpoint(r, x, O, L) {
      I(r instanceof c), I(x instanceof c), I(O instanceof c), I(L instanceof c);
      const X = r.redMul(L), P = O.redMul(x), K = x.redMul(L), re = r.redMul(O);
      return this.point(X, P, K, re);
    }
    solveX2(r) {
      I(r instanceof c);
      const x = r.redSqr(), O = this._mulD(x).redISub(this.a);
      return x.redISub(this.one).redDiv(O);
    }
    solveX(r) {
      const x = r.redSqr(), O = this._mulD(x).redISub(this.a);
      return x.redISub(this.one).redDivSqrt(O);
    }
    solveY2(r) {
      I(r instanceof c);
      const x = r.redSqr(), O = this._mulA(x).redISub(this.one), L = this._mulD(x).redISub(this.one);
      return O.redDiv(L);
    }
    solveY(r) {
      const x = r.redSqr(), O = this._mulA(x).redISub(this.one), L = this._mulD(x).redISub(this.one);
      return O.redDivSqrt(L);
    }
    validate(r) {
      if (I(r instanceof v), r.zOne) {
        const me = r.x.redSqr(), ne = r.y.redSqr(), W = this._mulD(me).redMul(ne), te = this._mulA(me).redIAdd(ne), pe = this.one.redAdd(W), Ee = r.t, Ae = r.x.redMul(r.y);
        return te.eq(pe) && Ee.eq(Ae);
      }
      const x = r.x.redSqr(), O = r.y.redSqr(), L = r.z.redSqr(), X = L.redSqr(), P = this._mulD(x).redMul(O), K = this._mulA(x).redIAdd(O).redMul(L), re = X.redIAdd(P), ce = r.t.redMul(r.z), le = r.x.redMul(r.y);
      return K.eq(re) && ce.eq(le);
    }
    pointFromX(r, x = null) {
      I(r instanceof c), I(x == null || typeof x == "boolean"), r.red || (r = r.toRed(this.red));
      const O = this.solveY(r);
      if (x != null) {
        if (O.isZero() && x)
          throw new Error("Invalid point.");
        O.redIsOdd() !== x && O.redINeg();
      }
      return this.point(r, O);
    }
    pointFromY(r, x = null) {
      I(r instanceof c), I(x == null || typeof x == "boolean"), r.red || (r = r.toRed(this.red));
      const O = this.solveX(r);
      if (x != null) {
        if (O.isZero() && x)
          throw new Error("Invalid point.");
        O.redIsOdd() !== x && O.redINeg();
      }
      return this.point(O, r);
    }
    isIsomorphic(r, x = !1) {
      if (I(r instanceof f), I(typeof x == "boolean"), !r.p.eq(this.p))
        return !1;
      if (r.type === "short")
        return r.isIsomorphic(this);
      if (r.type === "mont") {
        const O = this.field(r.a);
        let L, X;
        return x ? (L = this.d.redAdd(this.a), X = this.d.redSub(this.a)) : (L = this.a.redAdd(this.d), X = this.a.redSub(this.d)), O.redMul(X).eq(L.redIMuln(2));
      }
      if (r.type === "edwards") {
        const O = this.field(r.a), L = this.field(r.d);
        return this.a.redMul(L).eq(O.redMul(this.d));
      }
      return !1;
    }
    isIsogenous(r) {
      if (I(r instanceof f), !r.p.eq(this.p))
        return !1;
      if (r.type === "mont") {
        if (!this.a.eq(this.one))
          return !1;
        const x = this.field(r.a), O = this.field(r.b), L = this.two.redSub(this.d.redMuln(4));
        return x.eq(L) && O.eq(this.one);
      }
      if (r.type === "edwards") {
        const x = this.field(r.a), O = this.field(r.d);
        return x.eq(this.a.redNeg()) && O.eq(this.d.redSub(this.a));
      }
      return !1;
    }
    pointFromShort(r) {
      if (I(r instanceof a), this.isIsomorphic(r.curve)) {
        if (r.isInfinity())
          return this.point();
        if (r.y.isZero())
          return this.point(this.zero, this.one.redNeg());
        const { a: x, d: O } = this, [L, X] = this._scale(r.curve), P = x.redMuln(5), K = O.redMuln(5), re = this.field(r.x).redMul(L), ce = this.field(r.y).redMul(X), le = re.redMuln(6), me = re.redMuln(12), ne = le.redSub(x).redISub(O), W = ce.redMuln(6), te = me.redSub(P).redIAdd(O), pe = me.redAdd(x).redISub(K);
        return this.cpoint(ne, W, te, pe);
      }
      throw new Error("Not implemented.");
    }
    pointFromMont(r) {
      I(r instanceof p), I(r.curve.p.eq(this.p));
      const x = this.field(r.x), O = this.field(r.y);
      if (this.isIsogenous(r.curve)) {
        if (r.isInfinity())
          return this.point();
        if (r.x.isZero())
          return this.point();
        const L = x.redSqr(), X = L.redMul(x), P = X.redMul(x), K = P.redMul(x), re = O.redSqr(), ce = O.redMuln(4), le = L.redSub(this.one), me = L.redMuln(2), ne = re.redMuln(4), W = X.redIMuln(2), te = x.redMul(re).redIMuln(4), pe = L.redMul(re).redIMuln(2), Ee = re.redIMuln(2), Ae = ce.redMul(le), Oe = P.redISub(me).redIAdd(ne).redIAdd(this.one), Be = K.redSub(W).redISub(te).redIAdd(x).redINeg(), ke = K.redISub(pe).redISub(W).redISub(Ee).redIAdd(x);
        return this.cpoint(Ae, Oe, Be, ke).divn(4);
      }
      if (this.isIsomorphic(r.curve, !0)) {
        if (r.isInfinity())
          return this.point();
        if (r.x.isZero())
          return this.point(this.zero, this.one.redNeg());
        const X = this._scale(r.curve, !0).redMul(x), P = O, K = x.redAdd(this.one), re = x.redSub(this.one);
        return this.cpoint(X, P, K, re);
      }
      if (this.isIsomorphic(r.curve, !1)) {
        if (r.isInfinity())
          return this.point();
        if (r.x.isZero())
          return this.point(this.zero, this.one.redNeg());
        const X = this._scale(r.curve, !1).redMul(x), P = O, K = x.redSub(this.one), re = x.redAdd(this.one);
        return this.cpoint(X, P, K, re);
      }
      throw new Error("Not implemented.");
    }
    pointFromEdwards(r) {
      I(r instanceof v), I(r.curve.p.eq(this.p));
      const x = this.field(r.curve.a), O = this.field(r.x), L = this.field(r.y), X = this.field(r.z), P = this.field(r.t);
      if (this.isIsogenous(r.curve)) {
        const K = O.redMul(L), re = O.redSqr(), ce = L.redSqr(), le = X.redSqr(), me = x.redMul(re), ne = K.redIMuln(2), W = ce.redSub(me), te = ce.redAdd(me), pe = le.redIMuln(2).redISub(te), Ee = this.cpoint(ne, W, te, pe);
        return this.twisted ? Ee : Ee.divn(4);
      }
      if (this.isIsomorphic(r.curve)) {
        const K = this._scale(r.curve), re = K.redMul(O), ce = L, le = X, me = K.redMul(P);
        return this.point(re, ce, le, me);
      }
      throw new Error("Not implemented.");
    }
    pointFromUniform(r, x = null) {
      I(r instanceof c), I(r.red === this.red), I(x == null || x instanceof i), x || (x = this._alt());
      const O = x.field(r), L = x.pointFromUniform(O);
      return this.pointFromMont(L);
    }
    pointToUniform(r, x, O = null) {
      I(r instanceof v), I(x >>> 0 === x), I(O == null || O instanceof i), O || (O = this._alt());
      const L = (x >> 4 & 15) % this.torsion.length, X = r.add(this.torsion[L]), P = O.pointFromEdwards(X), K = O.pointToUniform(P, x & 15);
      return this.field(K);
    }
    pointFromHash(r, x, O = null) {
      I(O == null || O instanceof i), O || (O = this._alt());
      const L = O.pointFromHash(r, x);
      return this.pointFromMont(L);
    }
    pointToHash(r, x, O, L = null) {
      I(r instanceof v), I(x >>> 0 === x), I(L == null || L instanceof i), L || (L = this._alt());
      const X = x % this.torsion.length, P = r.add(this.torsion[X]), K = L.pointFromEdwards(P);
      return L.pointToHash(K, 0, O);
    }
    decodePoint(r) {
      return v.decode(this, r);
    }
    toShort(r, x, O = null) {
      const [L, X] = this._short(r, x), P = new u({
        red: this.red,
        prime: this.prime,
        p: this.p,
        a: L,
        b: X,
        n: this.n,
        h: this.h
      });
      if (O != null) {
        const [, K] = P._scale(this);
        K.redIsOdd() !== O && K.redINeg();
      }
      this.g.isInfinity() || (P.g = P.pointFromEdwards(this.g));
      for (let K = 0; K < this.h.word(0); K++)
        P.torsion[K] = P.pointFromEdwards(this.torsion[K]);
      return P;
    }
    toMont(r, x, O = null) {
      const [L, X] = this._mont(r, x), P = new i({
        red: this.red,
        prime: this.prime,
        p: this.p,
        a: L,
        b: X,
        n: this.n,
        h: this.h,
        z: this.z
      });
      if (O != null) {
        const K = this._scale(P, x);
        K.redIsOdd() !== O && K.redINeg();
      }
      this.g.isInfinity() || (P.g = P.pointFromEdwards(this.g));
      for (let K = 0; K < this.h.word(0); K++)
        P.torsion[K] = P.pointFromEdwards(this.torsion[K]);
      return P;
    }
    toEdwards(r, x = null) {
      const [O, L] = this._edwards(r), X = new E({
        red: this.red,
        prime: this.prime,
        p: this.p,
        a: O,
        d: L,
        n: this.n,
        h: this.h,
        z: this.z
      });
      if (x != null) {
        const P = X._scale(this);
        P.redIsOdd() !== x && P.redINeg();
      }
      if (this.g.isInfinity() || (X.g = X.pointFromEdwards(this.g), X.g.normalize()), X.isComplete())
        for (let P = 0; P < this.h.word(0); P++)
          X.torsion[P] = X.pointFromEdwards(this.torsion[P]), X.torsion[P].normalize();
      return X;
    }
    pointFromJSON(r) {
      return v.fromJSON(this, r);
    }
    toJSON(r) {
      const x = super.toJSON(r);
      return x.a = this.a.fromRed().toJSON(), x.d = this.d.fromRed().toJSON(), this.s.isZero() || (x.s = this.s.fromRed().toJSON()), x;
    }
  }
  class v extends n {
    constructor(r, x, O, L, X) {
      I(r instanceof E), super(r, d.EXTENDED), this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = !0, x != null && this._init(x, O, L, X);
    }
    _init(r, x, O, L) {
      I(r instanceof c), I(x instanceof c), I(O == null || O instanceof c), I(L == null || L instanceof c), this.x = r, this.y = x, this.z = O || this.curve.one, this.t = L || null, this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z.eq(this.curve.one), this._check(), this.t || (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redDiv(this.z)));
    }
    _check() {
      if (this.z.isZero())
        throw new Error("Invalid point.");
    }
    clone() {
      return this.curve.point(this.x, this.y, this.z, this.t);
    }
    normalize() {
      if (this.zOne)
        return this;
      const r = this.z.redInvert();
      return this.x = this.x.redMul(r), this.y = this.y.redMul(r), this.t = this.t.redMul(r), this.z = this.curve.one, this.zOne = !0, this;
    }
    scale(r) {
      I(r instanceof c);
      const x = this.x.redMul(r), O = this.y.redMul(r), L = this.z.redMul(r), X = this.t.redMul(r);
      return this.curve.point(x, O, L, X);
    }
    neg() {
      const r = this.x.redNeg(), x = this.y, O = this.z, L = this.t.redNeg();
      return this.curve.point(r, x, O, L);
    }
    add(r) {
      return I(r instanceof v), this.isInfinity() ? r : r.isInfinity() ? this : this.zOne ? r._add(this) : this._add(r);
    }
    _add(r) {
      return this.curve.mOneA ? this._addM1(r) : this._addA(r);
    }
    _addM1(r) {
      const x = this.y.redSub(this.x).redMul(r.y.redSub(r.x)), O = this.y.redAdd(this.x).redMul(r.y.redAdd(r.x)), L = this.t.redMul(this.curve.k).redMul(r.t), X = r.zOne ? this.z.redAdd(this.z) : this.z.redMul(r.z).redIMuln(2), P = O.redSub(x), K = X.redSub(L), re = X.redIAdd(L), ce = O.redIAdd(x), le = P.redMul(K), me = re.redMul(ce), ne = P.redMul(ce), W = K.redMul(re);
      return this.curve.point(le, me, W, ne);
    }
    _addA(r) {
      const x = this.x.redMul(r.x), O = this.y.redMul(r.y), L = this.curve._mulD(this.t).redMul(r.t), X = r.zOne ? this.z.clone() : this.z.redMul(r.z), K = this.x.redAdd(this.y).redMul(r.x.redAdd(r.y)).redISub(x).redISub(O), re = X.redSub(L), ce = X.redIAdd(L), le = O.redISub(this.curve._mulA(x)), me = K.redMul(re), ne = ce.redMul(le), W = K.redMul(le), te = re.redMul(ce);
      return this.curve.point(me, ne, te, W);
    }
    dbl() {
      return this.isInfinity() ? this : this._dbl();
    }
    _dbl() {
      const r = this.x.redSqr(), x = this.y.redSqr(), O = this.zOne ? this.curve.two : this.z.redSqr().redIMuln(2), L = this.curve._mulA(r), X = this.x.redAdd(this.y).redSqr().redISub(r).redISub(x), P = L.redAdd(x), K = P.redSub(O), re = L.redISub(x), ce = X.redMul(K), le = P.redMul(re), me = X.redMul(re), ne = K.redMul(P);
      return this.curve.point(ce, le, ne, me);
    }
    getX() {
      return this.normalize(), this.x.fromRed();
    }
    getY() {
      return this.normalize(), this.y.fromRed();
    }
    eq(r) {
      if (I(r instanceof v), I(!this.z.isZero()), I(!r.z.isZero()), this === r)
        return !0;
      if (this.z.eq(r.z))
        return this.x.eq(r.x) && this.y.eq(r.y);
      const x = this.x.redMul(r.z), O = r.x.redMul(this.z);
      if (!x.eq(O))
        return !1;
      const L = this.y.redMul(r.z), X = r.y.redMul(this.z);
      return L.eq(X);
    }
    cmp(r) {
      return I(r instanceof v), this.order().cmp(r.order()) || this.getY().cmp(r.getY()) || this.getX().cmp(r.getX());
    }
    isInfinity() {
      return I(!this.z.isZero()), this.x.isZero() ? this.y.eq(this.z) : !1;
    }
    isOrder2() {
      return this.isInfinity() ? !1 : this.x.isZero();
    }
    isOdd() {
      return this.normalize(), this.x.redIsOdd();
    }
    isEven() {
      return this.normalize(), this.x.redIsEven();
    }
    toP() {
      return this.normalize();
    }
    toJ() {
      return this;
    }
    encode() {
      const r = this.getY();
      return r.setn(this.curve.signBit, this.x.redIsOdd()), this.curve.encodeAdjusted(r);
    }
    static decode(r, x) {
      I(r instanceof E);
      const O = r.decodeAdjusted(x), L = O.testn(r.signBit) !== 0;
      if (O.setn(r.signBit, 0), O.cmp(r.p) >= 0)
        throw new Error("Invalid point.");
      return r.pointFromY(O, L);
    }
    toJSON(r) {
      if (this.isInfinity())
        return [];
      const x = this.getX().toJSON(), O = this.getY().toJSON();
      return r === !0 && this.pre ? [x, O, this.pre.toJSON()] : [x, O];
    }
    toPretty() {
      const r = this.curve.fieldSize * 2, x = M(this.getX(), r), O = M(this.getY(), r);
      return [x, O];
    }
    static fromJSON(r, x) {
      if (I(r instanceof E), I(Array.isArray(x)), I(x.length === 0 || x.length === 2 || x.length === 3), x.length === 0)
        return r.point();
      const O = c.fromJSON(x[0]), L = c.fromJSON(x[1]), X = r.point(O, L);
      return x.length > 2 && x[2] != null && (X.pre = b.fromJSON(X, x[2])), X;
    }
    [e]() {
      return this.isInfinity() ? "<EdwardsPoint: Infinity>" : "<EdwardsPoint: x=" + this.x.fromRed().toString(16, 2) + " y=" + this.y.fromRed().toString(16, 2) + " z=" + this.z.fromRed().toString(16, 2) + ">";
    }
  }
  class b {
    constructor() {
      this.naf = null, this.windows = null, this.doubles = null, this.blinding = null, this.beta = null;
    }
    map(r) {
      I(typeof r == "function");
      const x = new this.constructor();
      return this.naf && (x.naf = this.naf.map(r)), this.doubles && (x.doubles = this.doubles.map(r)), x;
    }
    toJSON() {
      return {
        naf: this.naf ? this.naf.toJSON() : null,
        windows: this.windows ? this.windows.toJSON() : null,
        doubles: this.doubles ? this.doubles.toJSON() : null,
        blinding: this.blinding ? this.blinding.toJSON() : void 0
      };
    }
    fromJSON(r, x) {
      return I(r instanceof n), I(x && typeof x == "object"), x.naf != null && (this.naf = h.fromJSON(r, x.naf)), x.windows != null && (this.windows = o.fromJSON(r, x.windows)), x.doubles != null && (this.doubles = S.fromJSON(r, x.doubles)), x.blinding != null && (this.blinding = H.fromJSON(r, x.blinding)), this;
    }
    static fromJSON(r, x) {
      return new this().fromJSON(r, x);
    }
  }
  class h {
    constructor(r, x) {
      this.width = r, this.points = x;
    }
    map(r) {
      I(typeof r == "function");
      const { width: x } = this, O = [];
      for (const L of this.points)
        O.push(r(L));
      return new this.constructor(x, O);
    }
    toJSON() {
      return {
        width: this.width,
        points: this.points.slice(1).map((r) => r.toJSON())
      };
    }
    static fromJSON(r, x) {
      I(r instanceof n), I(x && typeof x == "object"), I(x.width >>> 0 === x.width), I(Array.isArray(x.points));
      const { curve: O } = r, { width: L } = x, X = [r];
      for (const P of x.points)
        X.push(O.pointFromJSON(P));
      return new this(L, X);
    }
  }
  class o {
    constructor(r, x, O) {
      this.width = r, this.bits = x, this.points = O;
    }
    toJSON() {
      return {
        width: this.width,
        bits: this.bits,
        points: this.points.slice(1).map((r) => r.toJSON())
      };
    }
    static fromJSON(r, x) {
      I(r instanceof n), I(x && typeof x == "object"), I(x.width >>> 0 === x.width), I(x.bits >>> 0 === x.bits), I(Array.isArray(x.points));
      const { curve: O } = r, { width: L, bits: X } = x, P = [r];
      for (const K of x.points)
        P.push(O.pointFromJSON(K));
      return new this(L, X, P);
    }
  }
  class S {
    constructor(r, x) {
      this.step = r, this.points = x;
    }
    map(r) {
      I(typeof r == "function");
      const { step: x } = this, O = [];
      for (const L of this.points)
        O.push(r(L));
      return new this.constructor(x, O);
    }
    toJSON() {
      return {
        step: this.step,
        points: this.points.slice(1).map((r) => r.toJSON())
      };
    }
    static fromJSON(r, x) {
      I(r instanceof n), I(x && typeof x == "object"), I(x.step >>> 0 === x.step), I(Array.isArray(x.points));
      const { curve: O } = r, { step: L } = x, X = [r];
      for (const P of x.points)
        X.push(O.pointFromJSON(P));
      return new this(L, X);
    }
  }
  class H {
    constructor(r, x) {
      this.blind = r, this.unblind = x;
    }
    toJSON() {
      return {
        blind: this.blind.toJSON(),
        unblind: this.unblind.toJSON()
      };
    }
    static fromJSON(r, x) {
      I(r instanceof n), I(x && typeof x == "object");
      const { curve: O } = r, L = c.fromJSON(x.blind), X = O.pointFromJSON(x.unblind);
      return new this(L, X);
    }
  }
  class j {
    constructor(r, x, O, L) {
      this.beta = r, this.lambda = x, this.basis = O, this.pre = L;
    }
    toJSON() {
      return {
        beta: this.beta.fromRed().toJSON(),
        lambda: this.lambda.toJSON(),
        basis: [
          this.basis[0].toJSON(),
          this.basis[1].toJSON()
        ],
        pre: [
          this.pre[0],
          this.pre[1].toJSON(),
          this.pre[2].toJSON()
        ]
      };
    }
    static fromJSON(r, x) {
      I(r instanceof f), I(x && typeof x == "object"), I(Array.isArray(x.basis)), I(Array.isArray(x.pre)), I(x.basis.length === 2), I(x.pre.length === 3), I(x.pre[0] >>> 0 === x.pre[0]);
      const O = c.fromJSON(x.beta).toRed(r.red), L = c.fromJSON(x.lambda), X = [
        J.fromJSON(x.basis[0]),
        J.fromJSON(x.basis[1])
      ], P = [
        x.pre[0],
        c.fromJSON(x.pre[1]),
        c.fromJSON(x.pre[2])
      ];
      return new this(O, L, X, P);
    }
  }
  class J {
    constructor(r, x) {
      this.a = r, this.b = x;
    }
    toJSON() {
      return {
        a: this.a.toJSON(),
        b: this.b.toJSON()
      };
    }
    static fromJSON(r) {
      I(r && typeof r == "object");
      const x = c.fromJSON(r.a), O = c.fromJSON(r.b);
      return new this(x, O);
    }
  }
  class N extends u {
    constructor(r) {
      super({
        id: "P192",
        ossl: "prime192v1",
        type: "short",
        endian: "be",
        hash: "SHA256",
        prime: "p192",
        // 2^192 - 2^64 - 1 (= 3 mod 4)
        p: [
          "ffffffff ffffffff ffffffff fffffffe",
          "ffffffff ffffffff"
        ],
        // -3 mod p
        a: [
          "ffffffff ffffffff ffffffff fffffffe",
          "ffffffff fffffffc"
        ],
        b: [
          "64210519 e59c80e7 0fa7e9ab 72243049",
          "feb8deec c146b9b1"
        ],
        n: [
          "ffffffff ffffffff ffffffff 99def836",
          "146bc9b1 b4d22831"
        ],
        h: "1",
        // Icart
        z: "-5",
        g: [
          [
            "188da80e b03090f6 7cbf20eb 43a18800",
            "f4ff0afd 82ff1012"
          ],
          [
            "07192b95 ffc8da78 631011ed 6b24cdd5",
            "73f977a1 1e794811"
          ],
          r
        ]
      });
    }
  }
  class z extends u {
    constructor(r) {
      super({
        id: "P224",
        ossl: "secp224r1",
        type: "short",
        endian: "be",
        hash: "SHA256",
        prime: "p224",
        // 2^224 - 2^96 + 1 (1 mod 16)
        p: [
          "ffffffff ffffffff ffffffff ffffffff",
          "00000000 00000000 00000001"
        ],
        // -3 mod p
        a: [
          "ffffffff ffffffff ffffffff fffffffe",
          "ffffffff ffffffff fffffffe"
        ],
        b: [
          "b4050a85 0c04b3ab f5413256 5044b0b7",
          "d7bfd8ba 270b3943 2355ffb4"
        ],
        n: [
          "ffffffff ffffffff ffffffff ffff16a2",
          "e0b8f03e 13dd2945 5c5c2a3d"
        ],
        h: "1",
        // SSWU
        z: "1f",
        g: [
          [
            "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3",
            "56c21122 343280d6 115c1d21"
          ],
          [
            "bd376388 b5f723fb 4c22dfe6 cd4375a0",
            "5a074764 44d58199 85007e34"
          ],
          r
        ]
      });
    }
  }
  class A extends u {
    constructor(r) {
      super({
        id: "P256",
        ossl: "prime256v1",
        type: "short",
        endian: "be",
        hash: "SHA256",
        prime: null,
        // 2^256 - 2^224 + 2^192 + 2^96 - 1 (= 3 mod 4)
        p: [
          "ffffffff 00000001 00000000 00000000",
          "00000000 ffffffff ffffffff ffffffff"
        ],
        // -3 mod p
        a: [
          "ffffffff 00000001 00000000 00000000",
          "00000000 ffffffff ffffffff fffffffc"
        ],
        b: [
          "5ac635d8 aa3a93e7 b3ebbd55 769886bc",
          "651d06b0 cc53b0f6 3bce3c3e 27d2604b"
        ],
        n: [
          "ffffffff 00000000 ffffffff ffffffff",
          "bce6faad a7179e84 f3b9cac2 fc632551"
        ],
        h: "1",
        // SSWU
        z: "-a",
        g: [
          [
            "6b17d1f2 e12c4247 f8bce6e5 63a440f2",
            "77037d81 2deb33a0 f4a13945 d898c296"
          ],
          [
            "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16",
            "2bce3357 6b315ece cbb64068 37bf51f5"
          ],
          r
        ]
      });
    }
  }
  class q extends u {
    constructor(r) {
      super({
        id: "P384",
        ossl: "secp384r1",
        type: "short",
        endian: "be",
        hash: "SHA384",
        prime: null,
        // 2^384 - 2^128 - 2^96 + 2^32 - 1 (= 3 mod 4)
        p: [
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff ffffffff fffffffe",
          "ffffffff 00000000 00000000 ffffffff"
        ],
        // -3 mod p
        a: [
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff ffffffff fffffffe",
          "ffffffff 00000000 00000000 fffffffc"
        ],
        b: [
          "b3312fa7 e23ee7e4 988e056b e3f82d19",
          "181d9c6e fe814112 0314088f 5013875a",
          "c656398d 8a2ed19d 2a85c8ed d3ec2aef"
        ],
        n: [
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff c7634d81 f4372ddf",
          "581a0db2 48b0a77a ecec196a ccc52973"
        ],
        h: "1",
        // Icart
        z: "-c",
        g: [
          [
            "aa87ca22 be8b0537 8eb1c71e f320ad74",
            "6e1d3b62 8ba79b98 59f741e0 82542a38",
            "5502f25d bf55296c 3a545e38 72760ab7"
          ],
          [
            "3617de4a 96262c6f 5d9e98bf 9292dc29",
            "f8f41dbd 289a147c e9da3113 b5f0b8c0",
            "0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
          ],
          r
        ]
      });
    }
  }
  class _ extends u {
    constructor(r) {
      super({
        id: "P521",
        ossl: "secp521r1",
        type: "short",
        endian: "be",
        hash: "SHA512",
        prime: "p521",
        // 2^521 - 1 (= 3 mod 4)
        p: [
          "000001ff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff"
        ],
        // -3 mod p
        a: [
          "000001ff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff ffffffff ffffffff",
          "fffffffc"
        ],
        b: [
          "00000051 953eb961 8e1c9a1f 929a21a0",
          "b68540ee a2da725b 99b315f3 b8b48991",
          "8ef109e1 56193951 ec7e937b 1652c0bd",
          "3bb1bf07 3573df88 3d2c34f1 ef451fd4",
          "6b503f00"
        ],
        n: [
          "000001ff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff ffffffff ffffffff",
          "fffffffa 51868783 bf2f966b 7fcc0148",
          "f709a5d0 3bb5c9b8 899c47ae bb6fb71e",
          "91386409"
        ],
        h: "1",
        // SSWU
        z: "-4",
        g: [
          [
            "000000c6 858e06b7 0404e9cd 9e3ecb66",
            "2395b442 9c648139 053fb521 f828af60",
            "6b4d3dba a14b5e77 efe75928 fe1dc127",
            "a2ffa8de 3348b3c1 856a429b f97e7e31",
            "c2e5bd66"
          ],
          [
            "00000118 39296a78 9a3bc004 5c8a5fb4",
            "2c7d1bd9 98f54449 579b4468 17afbd17",
            "273e662c 97ee7299 5ef42640 c550b901",
            "3fad0761 353c7086 a272c240 88be9476",
            "9fd16650"
          ],
          r
        ]
      });
    }
  }
  class F extends u {
    constructor(r) {
      super({
        id: "SECP256K1",
        ossl: "secp256k1",
        type: "short",
        endian: "be",
        hash: "SHA256",
        prime: "k256",
        // 2^256 - 2^32 - 977 (= 3 mod 4)
        p: [
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff fffffffe fffffc2f"
        ],
        a: "0",
        b: "7",
        n: [
          "ffffffff ffffffff ffffffff fffffffe",
          "baaedce6 af48a03b bfd25e8c d0364141"
        ],
        h: "1",
        // SVDW
        z: "1",
        // sqrt(-3)
        c: [
          "0a2d2ba9 3507f1df 233770c2 a797962c",
          "c61f6d15 da14ecd4 7d8d27ae 1cd5f852"
        ],
        g: [
          [
            "79be667e f9dcbbac 55a06295 ce870b07",
            "029bfcdb 2dce28d9 59f2815b 16f81798"
          ],
          [
            "483ada77 26a3c465 5da4fbfc 0e1108a8",
            "fd17b448 a6855419 9c47d08f fb10d4b8"
          ],
          r
        ],
        // Precomputed endomorphism.
        endo: {
          beta: [
            "7ae96a2b 657c0710 6e64479e ac3434e9",
            "9cf04975 12f58995 c1396c28 719501ee"
          ],
          lambda: [
            "5363ad4c c05c30e0 a5261c02 8812645a",
            "122e22ea 20816678 df02967c 1b23bd72"
          ],
          basis: [
            {
              a: "3086d221a7d46bcde86c90e49284eb15",
              b: "-e4437ed6010e88286f547fa90abfe4c3"
            },
            {
              a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
              b: "3086d221a7d46bcde86c90e49284eb15"
            }
          ],
          pre: [
            384,
            [
              "3086d221 a7d46bcd e86c90e4 9284eb15",
              "3daa8a14 71e8ca7f e893209a 45dbb031"
            ],
            [
              "-",
              "e4437ed6 010e8828 6f547fa9 0abfe4c4",
              "221208ac 9df506c6 1571b4ae 8ac47f71"
            ]
          ]
        }
      });
    }
  }
  class R extends u {
    constructor(r) {
      super({
        id: "BRAINPOOLP256",
        ossl: "brainpoolP256r1",
        type: "short",
        endian: "be",
        hash: "SHA256",
        prime: null,
        // (= 3 mod 4)
        p: [
          "a9fb57db a1eea9bc 3e660a90 9d838d72",
          "6e3bf623 d5262028 2013481d 1f6e5377"
        ],
        a: [
          "7d5a0975 fc2c3057 eef67530 417affe7",
          "fb8055c1 26dc5c6c e94a4b44 f330b5d9"
        ],
        b: [
          "26dc5c6c e94a4b44 f330b5d9 bbd77cbf",
          "95841629 5cf7e1ce 6bccdc18 ff8c07b6"
        ],
        n: [
          "a9fb57db a1eea9bc 3e660a90 9d838d71",
          "8c397aa3 b561a6f7 901e0e82 974856a7"
        ],
        h: "1",
        // Icart
        z: "-2",
        g: [
          [
            "8bd2aeb9 cb7e57cb 2c4b482f fc81b7af",
            "b9de27e1 e3bd23c2 3a4453bd 9ace3262"
          ],
          [
            "547ef835 c3dac4fd 97f8461a 14611dc9",
            "c2774513 2ded8e54 5c1d54c7 2f046997"
          ],
          r
        ]
      });
    }
  }
  class V extends u {
    constructor(r) {
      super({
        id: "BRAINPOOLP384",
        ossl: "brainpoolP384r1",
        type: "short",
        endian: "be",
        hash: "SHA384",
        prime: null,
        // (= 3 mod 4)
        p: [
          "8cb91e82 a3386d28 0f5d6f7e 50e641df",
          "152f7109 ed5456b4 12b1da19 7fb71123",
          "acd3a729 901d1a71 87470013 3107ec53"
        ],
        a: [
          "7bc382c6 3d8c150c 3c72080a ce05afa0",
          "c2bea28e 4fb22787 139165ef ba91f90f",
          "8aa5814a 503ad4eb 04a8c7dd 22ce2826"
        ],
        b: [
          "04a8c7dd 22ce2826 8b39b554 16f0447c",
          "2fb77de1 07dcd2a6 2e880ea5 3eeb62d5",
          "7cb43902 95dbc994 3ab78696 fa504c11"
        ],
        n: [
          "8cb91e82 a3386d28 0f5d6f7e 50e641df",
          "152f7109 ed5456b3 1f166e6c ac0425a7",
          "cf3ab6af 6b7fc310 3b883202 e9046565"
        ],
        h: "1",
        // SSWU
        z: "-5",
        g: [
          [
            "1d1c64f0 68cf45ff a2a63a81 b7c13f6b",
            "8847a3e7 7ef14fe3 db7fcafe 0cbd10e8",
            "e826e034 36d646aa ef87b2e2 47d4af1e"
          ],
          [
            "8abe1d75 20f9c2a4 5cb1eb8e 95cfd552",
            "62b70b29 feec5864 e19c054f f9912928",
            "0e464621 77918111 42820341 263c5315"
          ],
          r
        ]
      });
    }
  }
  class fe extends u {
    constructor(r) {
      super({
        id: "BRAINPOOLP512",
        ossl: "brainpoolP512r1",
        type: "short",
        endian: "be",
        hash: "SHA512",
        prime: null,
        // (= 3 mod 4)
        p: [
          "aadd9db8 dbe9c48b 3fd4e6ae 33c9fc07",
          "cb308db3 b3c9d20e d6639cca 70330871",
          "7d4d9b00 9bc66842 aecda12a e6a380e6",
          "2881ff2f 2d82c685 28aa6056 583a48f3"
        ],
        a: [
          "7830a331 8b603b89 e2327145 ac234cc5",
          "94cbdd8d 3df91610 a83441ca ea9863bc",
          "2ded5d5a a8253aa1 0a2ef1c9 8b9ac8b5",
          "7f1117a7 2bf2c7b9 e7c1ac4d 77fc94ca"
        ],
        b: [
          "3df91610 a83441ca ea9863bc 2ded5d5a",
          "a8253aa1 0a2ef1c9 8b9ac8b5 7f1117a7",
          "2bf2c7b9 e7c1ac4d 77fc94ca dc083e67",
          "984050b7 5ebae5dd 2809bd63 8016f723"
        ],
        n: [
          "aadd9db8 dbe9c48b 3fd4e6ae 33c9fc07",
          "cb308db3 b3c9d20e d6639cca 70330870",
          "553e5c41 4ca92619 41866119 7fac1047",
          "1db1d381 085ddadd b5879682 9ca90069"
        ],
        h: "1",
        // Icart
        z: "7",
        g: [
          [
            "81aee4bd d82ed964 5a21322e 9c4c6a93",
            "85ed9f70 b5d916c1 b43b62ee f4d0098e",
            "ff3b1f78 e2d0d48d 50d1687b 93b97d5f",
            "7c6d5047 406a5e68 8b352209 bcb9f822"
          ],
          [
            "7dde385d 566332ec c0eabfa9 cf7822fd",
            "f209f700 24a57b1a a000c55b 881f8111",
            "b2dcde49 4a5f485e 5bca4bd8 8a2763ae",
            "d1ca2b2f a8f05406 78cd1e0f 3ad80892"
          ],
          r
        ]
      });
    }
  }
  class ue extends i {
    constructor() {
      super({
        id: "X25519",
        ossl: "X25519",
        type: "mont",
        endian: "le",
        hash: "SHA512",
        prime: "p25519",
        // 2^255 - 19 (= 5 mod 8)
        p: [
          "7fffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff ffffffff ffffffed"
        ],
        // 486662
        a: "76d06",
        b: "1",
        n: [
          "10000000 00000000 00000000 00000000",
          "14def9de a2f79cd6 5812631a 5cf5d3ed"
        ],
        h: "8",
        // Elligator 2
        z: "2",
        g: [
          [
            "00000000 00000000 00000000 00000000",
            "00000000 00000000 00000000 00000009"
          ],
          // See: https://www.rfc-editor.org/errata/eid4730
          [
            "5f51e65e 475f794b 1fe122d3 88b72eb3",
            "6dc2b281 92839e4d d6163a5d 81312c14"
          ]
        ],
        torsion: [
          [],
          [
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000"
            ],
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000"
            ]
          ],
          [
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000001"
            ],
            [
              "6be4f497 f9a9c2af c21fa77a d7f4a6ef",
              "635a11c7 284a9363 e9a248ef 9c884415"
            ]
          ],
          [
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000001"
            ],
            [
              "141b0b68 06563d50 3de05885 280b5910",
              "9ca5ee38 d7b56c9c 165db710 6377bbd8"
            ]
          ],
          [
            [
              "57119fd0 dd4e22d8 868e1c58 c45c4404",
              "5bef839c 55b1d0b1 248c50a3 bc959c5f"
            ],
            [
              "68c59389 3d458e64 31c6ca00 45fb5015",
              "20a44346 8eaa68dd 0f103842 048065b7"
            ]
          ],
          [
            [
              "57119fd0 dd4e22d8 868e1c58 c45c4404",
              "5bef839c 55b1d0b1 248c50a3 bc959c5f"
            ],
            [
              "173a6c76 c2ba719b ce3935ff ba04afea",
              "df5bbcb9 71559722 f0efc7bd fb7f9a36"
            ]
          ],
          [
            [
              "00b8495f 16056286 fdb1329c eb8d09da",
              "6ac49ff1 fae35616 aeb8413b 7c7aebe0"
            ],
            [
              "3931c129 569e83a5 29482c14 e628b457",
              "933bfc29 ed801b4d 68871483 92507b1a"
            ]
          ],
          [
            [
              "00b8495f 16056286 fdb1329c eb8d09da",
              "6ac49ff1 fae35616 aeb8413b 7c7aebe0"
            ],
            [
              "46ce3ed6 a9617c5a d6b7d3eb 19d74ba8",
              "6cc403d6 127fe4b2 9778eb7c 6daf84d3"
            ]
          ]
        ]
      });
    }
  }
  class ae extends i {
    constructor() {
      super({
        id: "X448",
        ossl: "X448",
        type: "mont",
        endian: "le",
        hash: "SHAKE256",
        prime: "p448",
        // 2^448 - 2^224 - 1 (= 3 mod 4)
        p: [
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff fffffffe ffffffff",
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff"
        ],
        // 156326
        a: "262a6",
        b: "1",
        n: [
          "3fffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff ffffffff 7cca23e9",
          "c44edb49 aed63690 216cc272 8dc58f55",
          "2378c292 ab5844f3"
        ],
        h: "4",
        // Elligator 2
        z: "-1",
        g: [
          [
            "00000000 00000000 00000000 00000000",
            "00000000 00000000 00000000 00000000",
            "00000000 00000000 00000000 00000000",
            "00000000 00000005"
          ],
          [
            "7d235d12 95f5b1f6 6c98ab6e 58326fce",
            "cbae5d34 f55545d0 60f75dc2 8df3f6ed",
            "b8027e23 46430d21 1312c4b1 50677af7",
            "6fd7223d 457b5b1a"
          ]
        ],
        torsion: [
          [],
          [
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000"
            ],
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000"
            ]
          ],
          [
            [
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff ffffffff fffffffe ffffffff",
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff fffffffe"
            ],
            [
              "ba4d3a08 29b6112f 8812e51b a0bb2abe",
              "bc1cb08e b48e5569 36ba50fd d2e7d68a",
              "f8cb3216 0522425b 3f990812 abbe635a",
              "d37a21e1 7551b193"
            ]
          ],
          [
            [
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff ffffffff fffffffe ffffffff",
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff fffffffe"
            ],
            [
              "45b2c5f7 d649eed0 77ed1ae4 5f44d541",
              "43e34f71 4b71aa96 c945af01 2d182975",
              "0734cde9 faddbda4 c066f7ed 54419ca5",
              "2c85de1e 8aae4e6c"
            ]
          ]
        ]
      });
    }
  }
  class D extends i {
    constructor() {
      super({
        id: "MONT448",
        ossl: null,
        type: "mont",
        endian: "le",
        hash: "SHAKE256",
        prime: "p448",
        // 2^448 - 2^224 - 1 (= 3 mod 4)
        p: [
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff fffffffe ffffffff",
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff"
        ],
        // -78160 / -39082 mod p
        a: [
          "b2cf97d2 d43459a9 31ed36b1 fc4e3cb5",
          "5d93f8d2 22746997 60ccffc6 49961ed6",
          "c5b05fca c24864ed 6fb59697 931b78da",
          "84ddecd8 ca2b5cfb"
        ],
        b: "1",
        n: [
          "3fffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff ffffffff 7cca23e9",
          "c44edb49 aed63690 216cc272 8dc58f55",
          "2378c292 ab5844f3"
        ],
        h: "4",
        // Elligator 2
        z: "-1",
        g: [
          [
            "ac0d24cc c6c75cb0 eb71f81e 7a6edf51",
            "48e88aee 009a2a24 e795687e c28e125a",
            "3e6730a6 0d46367b aa7fe99d 152128dc",
            "41321bc7 7817f059"
          ],
          [
            "5a4437f6 80c0d0db 9b061276 d5d0ffcc",
            "e786ff33 b6a53d30 98746425 82e66f09",
            "4433dae7 7244a6e2 6b11e905 7228f483",
            "556c41a5 913f55fe"
          ]
        ],
        torsion: [
          [],
          [
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000"
            ],
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000"
            ]
          ],
          [
            [
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff ffffffff fffffffe ffffffff",
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff fffffffe"
            ],
            [
              "bec92fd0 6da2acf2 b4e261e8 7cef0d34",
              "22e75c18 3c589857 b71924e5 73c2f9ce",
              "e18da5f2 466e2f39 3c2eedf0 f105a60a",
              "b40c717d 4f1e1fd7"
            ]
          ],
          [
            [
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff ffffffff fffffffe ffffffff",
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff fffffffe"
            ],
            [
              "4136d02f 925d530d 4b1d9e17 8310f2cb",
              "dd18a3e7 c3a767a8 48e6db19 8c3d0631",
              "1e725a0d b991d0c6 c3d1120f 0efa59f5",
              "4bf38e82 b0e1e028"
            ]
          ]
        ]
      });
    }
  }
  class Q extends E {
    constructor(r) {
      super({
        id: "ED25519",
        ossl: "ED25519",
        type: "edwards",
        endian: "le",
        hash: "SHA512",
        prefix: "SigEd25519 no Ed25519 collisions",
        context: !1,
        prime: "p25519",
        // 2^255 - 19 (= 5 mod 8)
        p: [
          "7fffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff ffffffff ffffffed"
        ],
        a: "-1",
        // -121665 / 121666 mod p
        d: [
          "52036cee 2b6ffe73 8cc74079 7779e898",
          "00700a4d 4141d8ab 75eb4dca 135978a3"
        ],
        n: [
          "10000000 00000000 00000000 00000000",
          "14def9de a2f79cd6 5812631a 5cf5d3ed"
        ],
        h: "8",
        // Elligator 2
        z: "2",
        g: [
          [
            "216936d3 cd6e53fe c0a4e231 fdd6dc5c",
            "692cc760 9525a7b2 c9562d60 8f25d51a"
          ],
          // 4/5
          [
            "66666666 66666666 66666666 66666666",
            "66666666 66666666 66666666 66666658"
          ],
          r
        ],
        torsion: [
          [
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000"
            ],
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000001"
            ]
          ],
          [
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000"
            ],
            [
              "7fffffff ffffffff ffffffff ffffffff",
              "ffffffff ffffffff ffffffff ffffffec"
            ]
          ],
          [
            [
              "2b832480 4fc1df0b 2b4d0099 3dfbd7a7",
              "2f431806 ad2fe478 c4ee1b27 4a0ea0b0"
            ],
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000"
            ]
          ],
          [
            [
              "547cdb7f b03e20f4 d4b2ff66 c2042858",
              "d0bce7f9 52d01b87 3b11e4d8 b5f15f3d"
            ],
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000"
            ]
          ],
          [
            [
              "1fd5b9a0 06394a28 e9339932 38de4abb",
              "5c193c70 13e5e238 dea14646 c545d14a"
            ],
            [
              "05fc536d 880238b1 3933c6d3 05acdfd5",
              "f098eff2 89f4c345 b027b2c2 8f95e826"
            ]
          ],
          [
            [
              "602a465f f9c6b5d7 16cc66cd c721b544",
              "a3e6c38f ec1a1dc7 215eb9b9 3aba2ea3"
            ],
            [
              "05fc536d 880238b1 3933c6d3 05acdfd5",
              "f098eff2 89f4c345 b027b2c2 8f95e826"
            ]
          ],
          [
            [
              "1fd5b9a0 06394a28 e9339932 38de4abb",
              "5c193c70 13e5e238 dea14646 c545d14a"
            ],
            [
              "7a03ac92 77fdc74e c6cc392c fa53202a",
              "0f67100d 760b3cba 4fd84d3d 706a17c7"
            ]
          ],
          [
            [
              "602a465f f9c6b5d7 16cc66cd c721b544",
              "a3e6c38f ec1a1dc7 215eb9b9 3aba2ea3"
            ],
            [
              "7a03ac92 77fdc74e c6cc392c fa53202a",
              "0f67100d 760b3cba 4fd84d3d 706a17c7"
            ]
          ]
        ]
      });
    }
  }
  class Z extends E {
    constructor(r) {
      super({
        id: "ISO448",
        ossl: null,
        type: "edwards",
        endian: "le",
        hash: "SHAKE256",
        prefix: "SigEd448",
        context: !0,
        prime: "p448",
        // 2^448 - 2^224 - 1 (= 3 mod 4)
        p: [
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff fffffffe ffffffff",
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff"
        ],
        a: "1",
        // 39082 / 39081 mod p
        d: [
          "d78b4bdc 7f0daf19 f24f38c2 9373a2cc",
          "ad461572 42a50f37 809b1da3 412a12e7",
          "9ccc9c81 264cfe9a d0809970 58fb61c4",
          "243cc32d baa156b9"
        ],
        n: [
          "3fffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff ffffffff 7cca23e9",
          "c44edb49 aed63690 216cc272 8dc58f55",
          "2378c292 ab5844f3"
        ],
        h: "4",
        // Elligator 2
        z: "-1",
        g: [
          [
            "79a70b2b 70400553 ae7c9df4 16c792c6",
            "1128751a c9296924 0c25a07d 728bdc93",
            "e21f7787 ed697224 9de732f3 8496cd11",
            "69871309 3e9c04fc"
          ],
          // Note: the RFC has this wrong.
          [
            "7fffffff ffffffff ffffffff ffffffff",
            "ffffffff ffffffff ffffffff 80000000",
            "00000000 00000000 00000000 00000000",
            "00000000 00000001"
          ],
          r
        ],
        torsion: [
          [
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000"
            ],
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000001"
            ]
          ],
          [
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000"
            ],
            [
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff ffffffff fffffffe ffffffff",
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff fffffffe"
            ]
          ],
          [
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000001"
            ],
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000"
            ]
          ],
          [
            [
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff ffffffff fffffffe ffffffff",
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff fffffffe"
            ],
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000"
            ]
          ]
        ]
      });
    }
  }
  class oe extends E {
    constructor(r) {
      super({
        id: "ED448",
        ossl: "ED448",
        type: "edwards",
        endian: "le",
        hash: "SHAKE256",
        prefix: "SigEd448",
        context: !0,
        prime: "p448",
        // 2^448 - 2^224 - 1 (= 3 mod 4)
        p: [
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff fffffffe ffffffff",
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff"
        ],
        a: "1",
        // -39081 mod p
        d: [
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff fffffffe ffffffff",
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffff6756"
        ],
        n: [
          "3fffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff ffffffff 7cca23e9",
          "c44edb49 aed63690 216cc272 8dc58f55",
          "2378c292 ab5844f3"
        ],
        h: "4",
        // Elligator 2
        z: "-1",
        g: [
          [
            "4f1970c6 6bed0ded 221d15a6 22bf36da",
            "9e146570 470f1767 ea6de324 a3d3a464",
            "12ae1af7 2ab66511 433b80e1 8b00938e",
            "2626a82b c70cc05e"
          ],
          [
            "693f4671 6eb6bc24 88762037 56c9c762",
            "4bea7373 6ca39840 87789c1e 05a0c2d7",
            "3ad3ff1c e67c39c4 fdbd132c 4ed7c8ad",
            "9808795b f230fa14"
          ],
          r
        ],
        torsion: [
          [
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000"
            ],
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000001"
            ]
          ],
          [
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000"
            ],
            [
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff ffffffff fffffffe ffffffff",
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff fffffffe"
            ]
          ],
          [
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000001"
            ],
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000"
            ]
          ],
          [
            [
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff ffffffff fffffffe ffffffff",
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff fffffffe"
            ],
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000"
            ]
          ]
        ]
      });
    }
  }
  const y = {
    __proto__: null,
    P192: N,
    P224: z,
    P256: A,
    P384: q,
    P521: _,
    SECP256K1: F,
    BRAINPOOLP256: R,
    BRAINPOOLP384: V,
    BRAINPOOLP512: fe,
    X25519: ue,
    X448: ae,
    MONT448: D,
    ED25519: Q,
    ISO448: Z,
    ED448: oe
  }, Y = {
    __proto__: null,
    P192: null,
    P224: null,
    P256: null,
    P384: null,
    P521: null,
    SECP256K1: null,
    BRAINPOOLP256: null,
    BRAINPOOLP384: null,
    BRAINPOOLP512: null,
    X25519: null,
    X448: null,
    MONT448: null,
    ED25519: null,
    ISO448: null,
    ED448: null
  };
  function he($, ...r) {
    I(typeof $ == "string");
    const x = $.toUpperCase();
    let O = Y[x];
    if (!O) {
      const L = y[x];
      if (!L)
        throw new Error(`Curve not found: "${$}".`);
      O = new L(...r), Y[x] = O;
    }
    return O;
  }
  function be($, r) {
    I(typeof $ == "string"), I(typeof r == "function");
    const x = $.toUpperCase();
    if (y[x])
      throw new Error(`Curve already registered: "${$}".`);
    y[x] = r, Y[x] = null;
  }
  function xe($, r, x) {
    I($ instanceof c), I(!$.red), I(r >>> 0 === r), I(x >>> 0 === x);
    const O = new Array(x), L = $.bitLength() + 1, X = $.sign() | 1;
    I(L <= x);
    for (let ce = 0; ce < x; ce++)
      O[ce] = 0;
    let P = 0, K = 0, re;
    for (; P < L; ) {
      if ($.bit(P) === K) {
        P += 1;
        continue;
      }
      re = $.bits(P, r) + K, K = re >> r - 1 & 1, re -= K << r, O[P] = X * re, P += r;
    }
    return I(K === 0), O;
  }
  function Ie($, r, x, O) {
    I(O >>> 0 === O);
    const L = xe($, r, x), X = Math.ceil(L.length / O), P = new Array(X);
    let K = 0;
    for (let re = 0; re < L.length; re += O) {
      let ce = 0;
      for (let le = re + O - 1; le >= re; le--)
        ce = (ce << 1) + L[le];
      P[K++] = ce;
    }
    return I(K === X), P;
  }
  function ve($, r, x) {
    I($ instanceof c), I(r instanceof c), I(!$.red), I(!r.red), I(x >>> 0 === x);
    const O = [new Array(x), new Array(x)], L = Math.max($.bitLength(), r.bitLength()) + 1, X = $.sign() | 1, P = r.sign() | 1;
    I(L <= x);
    let K = 0, re = 0;
    for (let ce = 0; ce < L; ce++) {
      const le = $.bits(ce, 3), me = r.bits(ce, 3);
      let ne = (le & 3) + K & 3, W = (me & 3) + re & 3, te = 0, pe = 0;
      if (ne === 3 && (ne = -1), W === 3 && (W = -1), ne & 1) {
        const Ee = (le & 7) + K & 7;
        (Ee === 3 || Ee === 5) && W === 2 ? te = -ne : te = ne;
      }
      if (W & 1) {
        const Ee = (me & 7) + re & 7;
        (Ee === 3 || Ee === 5) && ne === 2 ? pe = -W : pe = W;
      }
      O[0][ce] = te * X, O[1][ce] = pe * P, 2 * K === 1 + te && (K = 1 - K), 2 * re === 1 + pe && (re = 1 - re);
    }
    for (let ce = L; ce < x; ce++)
      O[0][ce] = 0, O[1][ce] = 0;
    return O;
  }
  function C($, r, x) {
    const O = ve($, r, x), L = new Array(x);
    for (let X = 0; X < x; X++) {
      const P = O[0][X], K = O[1][X];
      L[X] = w[(P + 1) * 3 + (K + 1)];
    }
    return L;
  }
  function I($, r) {
    if (!$) {
      const x = new Error(r || "Assertion failed");
      throw Error.captureStackTrace && Error.captureStackTrace(x, I), x;
    }
  }
  function se($) {
    I(typeof $ == "function");
    try {
      return $();
    } catch (r) {
      throw r.message === "X is not a square mod P." || r.message === "Not invertible." ? new Error("Invalid point.") : r;
    }
  }
  function t($, r) {
    let x = $ % r;
    return x < 0 && (x += r), x;
  }
  function l($) {
    I($ instanceof c), I($.red);
    const r = $.red.m;
    if (r.cmpn(3) <= 0)
      return $.clone();
    if (r.modrn(3) === 2) {
      const O = r.ushln(1).isubn(1).idivn(3);
      return $.redPow(O);
    }
    const x = r.modrn(9);
    if (x === 4) {
      const O = r.ushln(1).iaddn(1).idivn(9), L = $.redPow(O);
      if (!L.redSqr().redMul(L).eq($))
        throw new Error("X is not a cube mod P.");
      return L;
    }
    if (x === 7) {
      const O = r.addn(2).idivn(9), L = $.redPow(O);
      if (!L.redSqr().redMul(L).eq($))
        throw new Error("X is not a cube mod P.");
      return L;
    }
    throw new Error("Not implemented.");
  }
  function B($) {
    const r = l($);
    if ($.red.m.modrn(3) === 1) {
      const x = new c(2).toRed($.red), O = new c(3).toRed($.red), L = x.redInvert(), X = O.redNeg().redSqrt().redMul(L), P = X.redNeg(), K = X.redSub(L), re = P.redSub(L), ce = r.redMul(K), le = r.redMul(re);
      return [r, ce, le];
    }
    return [r];
  }
  function U($) {
    for (const r of B($))
      if (r.redJacobi() >= 0)
        return r;
    throw new Error("X^(1/3) is not a square mod P.");
  }
  function G($) {
    return c.randomBits($, 32).toNumber();
  }
  function T($, r) {
    const x = /* @__PURE__ */ new WeakMap();
    return function(L, X) {
      const P = X & 1, K = x.get(L);
      if (K && K[P] !== null)
        return K[P];
      const re = $.call(r, L, X);
      return x.has(L) || x.set(L, [null, null]), x.get(L)[P] = re, re;
    };
  }
  function M($, r) {
    I($ instanceof c), I(r >>> 0 === r), r & 7 && (r += 8 - (r & 7));
    const x = $.toString(16, r), O = [], L = [];
    I((x.length & 7) === 0);
    for (let X = 0; X < x.length; X += 8)
      O.push(x.slice(X, X + 8));
    for (let X = 0; X < O.length; X += 4)
      L.push(O.slice(X, X + 4).join(" "));
    return L;
  }
  return Qt.Curve = f, Qt.Point = n, Qt.ShortCurve = u, Qt.ShortPoint = a, Qt.JPoint = s, Qt.MontCurve = i, Qt.MontPoint = p, Qt.XPoint = m, Qt.EdwardsCurve = E, Qt.EdwardsPoint = v, Qt.curves = y, Qt.curve = he, Qt.register = be, Qt;
}
/*!
 * ecdsa.js - ECDSA for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/elliptic:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/elliptic
 *
 * References:
 *
 *   [SEC1] SEC 1: Elliptic Curve Cryptography, Version 2.0
 *     Certicom Research
 *     http://www.secg.org/sec1-v2.pdf
 *
 *   [FIPS186] Suite B Implementer's Guide to FIPS 186-3 (ECDSA)
 *     https://tinyurl.com/fips186-guide
 *
 *   [GECC] Guide to Elliptic Curve Cryptography
 *     D. Hankerson, A. Menezes, and S. Vanstone
 *     https://tinyurl.com/guide-to-ecc
 *
 *   [RFC6979] Deterministic Usage of the Digital Signature
 *             Algorithm (DSA) and Elliptic Curve Digital
 *             Signature Algorithm (ECDSA)
 *     T. Pornin
 *     https://tools.ietf.org/html/rfc6979
 */
var m0, Y1;
function jn() {
  if (Y1) return m0;
  Y1 = 1;
  const e = Bt(), c = Ur(), d = Ti(), w = W8(), g = jm(), f = Q8(), n = Ym();
  class u {
    constructor(s, i, p, m) {
      e(typeof s == "string"), e(i), e(p), this.id = s, this.type = "ecdsa", this.hash = i, this.xof = p, this.native = 0, this._pre = m || null, this._curve = null, this._schnorr = null;
    }
    get curve() {
      return this._curve || (this._curve = n.curve(this.id, this._pre), this._curve.precompute(d), this._pre = null), this._curve;
    }
    get schnorr() {
      return this._schnorr || (this._schnorr = new g(this.curve, this.xof)), this._schnorr;
    }
    get size() {
      return this.curve.fieldSize;
    }
    get bits() {
      return this.curve.fieldBits;
    }
    privateKeyGenerate() {
      const s = this.curve.randomScalar(d);
      return this.curve.encodeScalar(s);
    }
    privateKeyVerify(s) {
      e(k.isBuffer(s));
      let i;
      try {
        i = this.curve.decodeScalar(s);
      } catch {
        return !1;
      }
      return !i.isZero() && i.cmp(this.curve.n) < 0;
    }
    privateKeyExport(s) {
      const i = this.publicKeyCreate(s, !1), { x: p, y: m } = this.publicKeyExport(i);
      return {
        d: k.from(s),
        x: p,
        y: m
      };
    }
    privateKeyImport(s) {
      e(s && typeof s == "object");
      const i = c.decode(s.d, this.curve.endian);
      if (i.isZero() || i.cmp(this.curve.n) >= 0)
        throw new Error("Invalid private key.");
      return this.curve.encodeScalar(i);
    }
    privateKeyTweakAdd(s, i) {
      const p = this.curve.decodeScalar(i);
      if (p.cmp(this.curve.n) >= 0)
        throw new Error("Invalid scalar.");
      const m = this.curve.decodeScalar(s);
      if (m.isZero() || m.cmp(this.curve.n) >= 0)
        throw new Error("Invalid private key.");
      const E = m.add(p).imod(this.curve.n);
      if (E.isZero())
        throw new Error("Invalid private key.");
      return this.curve.encodeScalar(E);
    }
    privateKeyTweakMul(s, i) {
      const p = this.curve.decodeScalar(i);
      if (p.isZero() || p.cmp(this.curve.n) >= 0)
        throw new Error("Invalid scalar.");
      const m = this.curve.decodeScalar(s);
      if (m.isZero() || m.cmp(this.curve.n) >= 0)
        throw new Error("Invalid private key.");
      const E = m.mul(p).imod(this.curve.n);
      if (E.isZero())
        throw new Error("Invalid private key.");
      return this.curve.encodeScalar(E);
    }
    privateKeyNegate(s) {
      const i = this.curve.decodeScalar(s);
      if (i.isZero() || i.cmp(this.curve.n) >= 0)
        throw new Error("Invalid private key.");
      const p = i.neg().imod(this.curve.n);
      return this.curve.encodeScalar(p);
    }
    privateKeyInvert(s) {
      const i = this.curve.decodeScalar(s);
      if (i.isZero() || i.cmp(this.curve.n) >= 0)
        throw new Error("Invalid private key.");
      const p = i.invert(this.curve.n);
      return this.curve.encodeScalar(p);
    }
    publicKeyCreate(s, i) {
      const p = this.curve.decodeScalar(s);
      if (p.isZero() || p.cmp(this.curve.n) >= 0)
        throw new Error("Invalid private key.");
      return this.curve.g.mulBlind(p).encode(i);
    }
    publicKeyConvert(s, i) {
      return this.curve.decodePoint(s).encode(i);
    }
    publicKeyFromUniform(s, i) {
      const p = this.curve.decodeUniform(s);
      return this.curve.pointFromUniform(p).encode(i);
    }
    publicKeyToUniform(s, i = d.randomInt()) {
      const p = this.curve.decodePoint(s), m = this.curve.pointToUniform(p, i);
      return this.curve.encodeUniform(m, i >>> 8);
    }
    publicKeyFromHash(s, i) {
      return this.curve.pointFromHash(s).encode(i);
    }
    publicKeyToHash(s) {
      const i = this.curve.decodePoint(s);
      return this.curve.pointToHash(i, 0, d);
    }
    publicKeyVerify(s) {
      e(k.isBuffer(s));
      try {
        this.curve.decodePoint(s);
      } catch {
        return !1;
      }
      return !0;
    }
    publicKeyExport(s) {
      const { x: i, y: p } = this.curve.decodePoint(s);
      return {
        x: this.curve.encodeField(i.fromRed()),
        y: this.curve.encodeField(p.fromRed())
      };
    }
    publicKeyImport(s, i) {
      e(s && typeof s == "object");
      const p = c.decode(s.x, this.curve.endian);
      if (p.cmp(this.curve.p) >= 0)
        throw new Error("Invalid point.");
      if (s.y != null) {
        const E = c.decode(s.y, this.curve.endian);
        if (E.cmp(this.curve.p) >= 0)
          throw new Error("Invalid point.");
        const v = this.curve.point(p, E);
        if (!v.validate())
          throw new Error("Invalid point.");
        return v.encode(i);
      }
      return this.curve.pointFromX(p, s.sign).encode(i);
    }
    publicKeyTweakAdd(s, i, p) {
      const m = this.curve.decodeScalar(i);
      if (m.cmp(this.curve.n) >= 0)
        throw new Error("Invalid scalar.");
      const E = this.curve.decodePoint(s);
      return this.curve.g.jmul(m).add(E).encode(p);
    }
    publicKeyTweakMul(s, i, p) {
      const m = this.curve.decodeScalar(i);
      if (m.isZero() || m.cmp(this.curve.n) >= 0)
        throw new Error("Invalid scalar.");
      return this.curve.decodePoint(s).mul(m).encode(p);
    }
    publicKeyCombine(s, i) {
      e(Array.isArray(s));
      let p = this.curve.jpoint();
      for (const m of s) {
        const E = this.curve.decodePoint(m);
        p = p.add(E);
      }
      return p.encode(i);
    }
    publicKeyNegate(s, i) {
      return this.curve.decodePoint(s).neg().encode(i);
    }
    signatureNormalize(s) {
      const [i, p] = this._decodeCompact(s);
      return p.cmp(this.curve.nh) > 0 && p.ineg().imod(this.curve.n), this._encodeCompact(i, p);
    }
    signatureNormalizeDER(s) {
      const [i, p] = this._decodeDER(s, !1);
      return p.cmp(this.curve.nh) > 0 && p.ineg().imod(this.curve.n), this._encodeDER(i, p);
    }
    signatureExport(s) {
      const [i, p] = this._decodeCompact(s);
      return this._encodeDER(i, p);
    }
    signatureImport(s) {
      const [i, p] = this._decodeDER(s, !1);
      return this._encodeCompact(i, p);
    }
    isLowS(s) {
      e(k.isBuffer(s));
      let i;
      try {
        [, i] = this._decodeCompact(s);
      } catch {
        return !1;
      }
      return i.cmp(this.curve.nh) <= 0;
    }
    isLowDER(s) {
      e(k.isBuffer(s));
      let i;
      try {
        [, i] = this._decodeDER(s, !1);
      } catch {
        return !1;
      }
      return i.cmp(this.curve.nh) <= 0;
    }
    sign(s, i) {
      const [p, m] = this._sign(s, i);
      return this._encodeCompact(p, m);
    }
    signRecoverable(s, i) {
      const [p, m, E] = this._sign(s, i);
      return [this._encodeCompact(p, m), E];
    }
    signDER(s, i) {
      const [p, m] = this._sign(s, i);
      return this._encodeDER(p, m);
    }
    signRecoverableDER(s, i) {
      const [p, m, E] = this._sign(s, i);
      return [this._encodeDER(p, m), E];
    }
    _sign(s, i) {
      const { n: p, nh: m } = this.curve, E = this.curve.g, v = this.curve.decodeScalar(i);
      if (v.isZero() || v.cmp(p) >= 0)
        throw new Error("Invalid private key.");
      const b = this._reduce(s), h = this.curve.encodeScalar(b), o = new f(this.hash, i, h);
      for (; ; ) {
        const S = o.generate(this.curve.scalarSize), H = this._truncate(S);
        if (H.isZero() || H.cmp(p) >= 0)
          continue;
        const j = E.mulBlind(H);
        if (j.isInfinity())
          continue;
        const J = j.getX(), N = J.mod(p);
        if (N.isZero())
          continue;
        const z = this.curve.randomScalar(d), A = H.mul(z).fermat(p), q = v.mul(z).imod(p), _ = b.mul(z).imod(p), R = N.mul(q).iadd(_).imod(p).mul(A).imod(p);
        if (R.isZero())
          continue;
        let V = j.isOdd() | !J.eq(N) << 1;
        return R.cmp(m) > 0 && (R.ineg().imod(p), V ^= 1), [N, R, V];
      }
    }
    verify(s, i, p) {
      e(k.isBuffer(s)), e(k.isBuffer(i)), e(k.isBuffer(p));
      let m, E;
      try {
        [m, E] = this._decodeCompact(i);
      } catch {
        return !1;
      }
      try {
        return this._verify(s, m, E, p);
      } catch {
        return !1;
      }
    }
    verifyDER(s, i, p) {
      e(k.isBuffer(s)), e(k.isBuffer(i)), e(k.isBuffer(p));
      let m, E;
      try {
        [m, E] = this._decodeDER(i, !1);
      } catch {
        return !1;
      }
      try {
        return this._verify(s, m, E, p);
      } catch {
        return !1;
      }
    }
    _verify(s, i, p, m) {
      const { n: E } = this.curve, v = this.curve.g, b = this._reduce(s), h = this.curve.decodePoint(m);
      if (i.isZero() || i.cmp(E) >= 0 || p.isZero() || p.cmp(E) >= 0)
        return !1;
      const o = p.invert(E), S = b.mul(o).imod(E), H = i.mul(o).imod(E);
      return v.jmulAdd(S, h, H).eqR(i);
    }
    recover(s, i, p, m) {
      e(k.isBuffer(s)), e(k.isBuffer(i)), e(p >>> 0 === p), e((p & 3) === p, "The recovery param is more than two bits.");
      let E, v;
      try {
        [E, v] = this._decodeCompact(i);
      } catch {
        return null;
      }
      let b;
      try {
        b = this._recover(s, E, v, p);
      } catch {
        return null;
      }
      return b.encode(m);
    }
    recoverDER(s, i, p, m) {
      e(k.isBuffer(s)), e(k.isBuffer(i)), e(p >>> 0 === p), e((p & 3) === p, "The recovery param is more than two bits.");
      let E, v;
      try {
        [E, v] = this._decodeDER(i, !1);
      } catch {
        return null;
      }
      let b;
      try {
        b = this._recover(s, E, v, p);
      } catch {
        return null;
      }
      return b.encode(m);
    }
    _recover(s, i, p, m) {
      const { n: E, pmodn: v } = this.curve, b = this.curve.g, h = this._reduce(s);
      if (i.isZero() || i.cmp(E) >= 0)
        throw new Error("Invalid R value.");
      if (p.isZero() || p.cmp(E) >= 0)
        throw new Error("Invalid S value.");
      const o = (m & 1) !== 0, S = m >>> 1;
      let H = i;
      if (S) {
        if (this.curve.highOrder)
          throw new Error("Invalid high bit.");
        if (H.cmp(v) >= 0)
          throw new Error("Invalid R value.");
        H = H.add(E);
      }
      const j = this.curve.pointFromX(H, o), J = i.invert(E), N = h.mul(J).ineg().imod(E), z = p.mul(J).imod(E), A = b.mulAdd(N, j, z);
      if (A.isInfinity())
        throw new Error("Invalid point.");
      return A;
    }
    derive(s, i, p) {
      const m = this.curve.decodePoint(s), E = this.curve.decodeScalar(i);
      if (E.isZero() || E.cmp(this.curve.n) >= 0)
        throw new Error("Invalid private key.");
      if (this.curve.h.cmpn(1) > 0 && m.isSmall())
        throw new Error("Invalid point.");
      return m.mulBlind(E, d).encode(p);
    }
    /*
     * Schnorr
     */
    schnorrSign(s, i) {
      return this.schnorr.sign(s, i);
    }
    schnorrVerify(s, i, p) {
      return this.schnorr.verify(s, i, p);
    }
    schnorrVerifyBatch(s) {
      return this.schnorr.verifyBatch(s);
    }
    /*
     * Helpers
     */
    _encodeCompact(s, i) {
      return k.concat([
        this.curve.encodeScalar(s),
        this.curve.encodeScalar(i)
      ]);
    }
    _decodeCompact(s) {
      e(k.isBuffer(s));
      const { n: i } = this.curve, p = this.curve.scalarSize;
      if (s.length !== p * 2)
        throw new Error("Invalid signature size.");
      const m = s.slice(0, p), E = s.slice(p, p * 2), v = this.curve.decodeScalar(m), b = this.curve.decodeScalar(E);
      if (v.cmp(i) >= 0 || b.cmp(i) >= 0)
        throw new Error("Invalid signature.");
      return [v, b];
    }
    _encodeDER(s, i) {
      const p = w.sizeInt(s) + w.sizeInt(i), m = k.alloc(w.sizeSeq(p));
      let E = 0;
      return E = w.writeSeq(m, E, p), E = w.writeInt(m, E, s), E = w.writeInt(m, E, i), e(E === m.length), m;
    }
    _decodeDER(s, i) {
      e(k.isBuffer(s)), e(typeof i == "boolean");
      const { n: p } = this.curve;
      let m = 0, E, v;
      if (m = w.readSeq(s, m, i), [E, m] = w.readInt(s, m, i), [v, m] = w.readInt(s, m, i), i && m !== s.length)
        throw new Error("Trailing bytes.");
      if (E.cmp(p) >= 0 || v.cmp(p) >= 0)
        throw new Error("Invalid signature.");
      return [E, v];
    }
    _truncate(s) {
      e(k.isBuffer(s));
      const i = this.curve.n.bitLength(), p = i + 7 >>> 3;
      s.length > p && (s = s.slice(0, p));
      const m = c.decode(s, this.curve.endian), E = s.length * 8 - i;
      return E > 0 && m.iushrn(E), m;
    }
    _reduce(s) {
      return this._truncate(s).imod(this.curve.n);
    }
  }
  return m0 = u, m0;
}
var Xm = {
  width: 9,
  points: [
    [
      "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
      "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
    ],
    [
      "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
      "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
    ],
    [
      "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
      "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
    ],
    [
      "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
      "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
    ],
    [
      "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
      "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
    ],
    [
      "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
      "0ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
    ],
    [
      "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
      "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
    ],
    [
      "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
      "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
    ],
    [
      "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
      "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
    ],
    [
      "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
      "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
    ],
    [
      "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
      "02de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
    ],
    [
      "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
      "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
    ],
    [
      "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
      "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
    ],
    [
      "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
      "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
    ],
    [
      "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
      "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
    ],
    [
      "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
      "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
    ],
    [
      "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
      "02972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
    ],
    [
      "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
      "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
    ],
    [
      "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
      "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
    ],
    [
      "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
      "0d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
    ],
    [
      "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
      "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
    ],
    [
      "049370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
      "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
    ],
    [
      "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
      "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
    ],
    [
      "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
      "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
    ],
    [
      "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
      "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
    ],
    [
      "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
      "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
    ],
    [
      "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
      "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
    ],
    [
      "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
      "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
    ],
    [
      "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
      "091b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
    ],
    [
      "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
      "0673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
    ],
    [
      "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
      "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
    ],
    [
      "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
      "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
    ],
    [
      "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
      "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
    ],
    [
      "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
      "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
    ],
    [
      "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
      "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
    ],
    [
      "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
      "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
    ],
    [
      "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
      "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
    ],
    [
      "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
      "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
    ],
    [
      "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
      "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
    ],
    [
      "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
      "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
    ],
    [
      "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
      "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
    ],
    [
      "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
      "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
    ],
    [
      "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
      "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
    ],
    [
      "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
      "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
    ],
    [
      "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
      "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
    ],
    [
      "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
      "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
    ],
    [
      "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
      "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
    ],
    [
      "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
      "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
    ],
    [
      "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
      "0a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
    ],
    [
      "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
      "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
    ],
    [
      "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
      "09414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
    ],
    [
      "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
      "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
    ],
    [
      "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
      "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
    ],
    [
      "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
      "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
    ],
    [
      "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
      "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
    ],
    [
      "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
      "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
    ],
    [
      "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
      "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
    ],
    [
      "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
      "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
    ],
    [
      "078c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
      "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
    ],
    [
      "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
      "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
    ],
    [
      "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
      "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
    ],
    [
      "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
      "04f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
    ],
    [
      "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
      "073867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
    ],
    [
      "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
      "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
    ],
    [
      "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
      "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
    ],
    [
      "0336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
      "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
    ],
    [
      "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
      "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
    ],
    [
      "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
      "060660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
    ],
    [
      "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
      "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
    ],
    [
      "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
      "0b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
    ],
    [
      "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
      "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
    ],
    [
      "04e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
      "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
    ],
    [
      "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
      "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
    ],
    [
      "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
      "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
    ],
    [
      "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
      "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
    ],
    [
      "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
      "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
    ],
    [
      "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
      "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
    ],
    [
      "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
      "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
    ],
    [
      "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
      "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
    ],
    [
      "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
      "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
    ],
    [
      "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
      "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
    ],
    [
      "0c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
      "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
    ],
    [
      "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
      "021ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
    ],
    [
      "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
      "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
    ],
    [
      "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
      "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
    ],
    [
      "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
      "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
    ],
    [
      "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
      "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
    ],
    [
      "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
      "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
    ],
    [
      "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
      "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
    ],
    [
      "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
      "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
    ],
    [
      "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
      "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
    ],
    [
      "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
      "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
    ],
    [
      "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
      "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
    ],
    [
      "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
      "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
    ],
    [
      "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
      "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
    ],
    [
      "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
      "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
    ],
    [
      "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
      "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
    ],
    [
      "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
      "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
    ],
    [
      "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
      "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
    ],
    [
      "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
      "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
    ],
    [
      "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
      "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
    ],
    [
      "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
      "0c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
    ],
    [
      "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
      "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
    ],
    [
      "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
      "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
    ],
    [
      "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
      "09731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
    ],
    [
      "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
      "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
    ],
    [
      "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
      "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
    ],
    [
      "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
      "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
    ],
    [
      "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
      "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
    ],
    [
      "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
      "0cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
    ],
    [
      "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
      "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
    ],
    [
      "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
      "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
    ],
    [
      "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
      "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
    ],
    [
      "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
      "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
    ],
    [
      "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
      "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
    ],
    [
      "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
      "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
    ],
    [
      "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
      "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
    ],
    [
      "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
      "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
    ],
    [
      "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
      "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
    ],
    [
      "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
      "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
    ],
    [
      "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
      "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
    ],
    [
      "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
      "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
    ],
    [
      "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
      "0712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
    ],
    [
      "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
      "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
    ],
    [
      "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
      "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
    ],
    [
      "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
      "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
    ],
    [
      "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
      "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
    ]
  ]
}, Jm = {
  step: 4,
  points: [
    [
      "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
      "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
    ],
    [
      "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
      "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
    ],
    [
      "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
      "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
    ],
    [
      "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
      "04e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
    ],
    [
      "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
      "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
    ],
    [
      "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
      "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
    ],
    [
      "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
      "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
    ],
    [
      "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
      "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
    ],
    [
      "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
      "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
    ],
    [
      "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
      "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
    ],
    [
      "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
      "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
    ],
    [
      "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
      "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
    ],
    [
      "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
      "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
    ],
    [
      "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
      "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
    ],
    [
      "06f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
      "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
    ],
    [
      "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
      "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
    ],
    [
      "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
      "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
    ],
    [
      "0948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
      "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
    ],
    [
      "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
      "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
    ],
    [
      "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
      "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
    ],
    [
      "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
      "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
    ],
    [
      "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
      "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
    ],
    [
      "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
      "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
    ],
    [
      "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
      "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
    ],
    [
      "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
      "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
    ],
    [
      "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
      "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
    ],
    [
      "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
      "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
    ],
    [
      "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
      "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
    ],
    [
      "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
      "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
    ],
    [
      "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
      "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
    ],
    [
      "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
      "0e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
    ],
    [
      "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
      "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
    ],
    [
      "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
      "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
    ],
    [
      "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
      "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
    ],
    [
      "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
      "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
    ],
    [
      "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
      "067c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
    ],
    [
      "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
      "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
    ],
    [
      "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
      "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
    ],
    [
      "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
      "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
    ],
    [
      "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
      "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
    ],
    [
      "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
      "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
    ],
    [
      "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
      "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
    ],
    [
      "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
      "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
    ],
    [
      "0928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
      "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
    ],
    [
      "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
      "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
    ],
    [
      "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
      "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
    ],
    [
      "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
      "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
    ],
    [
      "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
      "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
    ],
    [
      "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
      "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
    ],
    [
      "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
      "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
    ],
    [
      "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
      "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
    ],
    [
      "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
      "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
    ],
    [
      "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
      "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
    ],
    [
      "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
      "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
    ],
    [
      "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
      "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
    ],
    [
      "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
      "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
    ],
    [
      "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
      "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
    ],
    [
      "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
      "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
    ],
    [
      "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
      "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
    ],
    [
      "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
      "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
    ],
    [
      "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
      "0d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
    ],
    [
      "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
      "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
    ],
    [
      "08ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
      "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
    ],
    [
      "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
      "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
    ],
    [
      "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
      "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
    ]
  ]
}, Gm = {
  naf: Xm,
  doubles: Jm
};
/*!
 * secp256k1.js - secp256k1 for bcrypto
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var g0, X1;
function Fr() {
  if (X1) return g0;
  X1 = 1;
  const e = jn(), c = cr(), d = Gm;
  return g0 = new e("SECP256K1", c, c, d), g0;
}
/*!
 * message.js - message signing utilities.
 * Copyright (c) 2019, The Bcoin Developers (MIT License).
 */
var J1;
function Wm() {
  return J1 || (J1 = 1, function(e) {
    const c = nt, d = kt, w = Or(), g = Fr(), f = e;
    f.MAGIC_STRING = `eCash Signed Message:
`, f.magicHash = (n, u = f.MAGIC_STRING) => {
      c(typeof u == "string", "prefix must be a string."), c(typeof n == "string", "message must be a string");
      const a = d.write();
      return a.writeVarString(u), a.writeVarString(n, "utf8"), w.digest(a.render());
    }, f.sign = (n, u, a) => {
      c(u.getPrivateKey(), "Cannot sign without private key.");
      const s = f.magicHash(n, a), i = u.getPublicKey().readInt8(0) !== 4, [
        p,
        m
      ] = g.signRecoverable(s, u.getPrivateKey()), E = d.write();
      return E.writeI8(m + 27 + (i ? 4 : 0)), E.writeBytes(p), E.render();
    }, f.recover = (n, u, a) => {
      c(typeof n == "string", "msg must be a string"), c(k.isBuffer(u), "sig must be a buffer");
      const s = f.magicHash(n, a);
      c.strictEqual(u.length, 65, "Invalid signature length");
      const i = u.readUInt8(0) - 27;
      c(i < 8, "Invalid signature parameter");
      const p = !!(i & 4), m = i & 3;
      return g.recover(s, u.slice(1), m, p);
    }, f.verify = (n, u, a, s) => {
      const i = f.recover(n, u);
      return c(k.isBuffer(a), "publicKey must be a buffer"), k.compare(a, i) !== 0 ? !1 : g.verify(
        f.magicHash(n, s),
        u.slice(1),
        a
      );
    };
  }(u0)), u0;
}
/*!
 * utils/index.js - utils for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var G1;
function fr() {
  if (G1) return wi;
  G1 = 1, wi.binary = Rh(), wi.fixed = u8(), wi.util = ur(), wi.message = Wm();
  const { inspect: { custom: e } } = D8;
  return wi.inspectSymbol = e || "inspect", wi;
}
/*!
 * address.js - address object for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var x0, W1;
function Ci() {
  if (W1) return x0;
  W1 = 1;
  const e = nt, c = kt, { base58: d, cashaddr: w } = Ds, g = Oi, f = hn(), n = Or(), u = _r(), a = Xt(), { inspectSymbol: s } = fr(), i = k.alloc(20, 0);
  class p {
    /**
     * Create an address.
     * @constructor
     * @param {Object?} options
     */
    constructor(v, b) {
      this.type = p.types.PUBKEYHASH, this.hash = i, v && this.fromOptions(v, b);
    }
    /**
     * Inject properties from options object.
     * @private
     * @param {Object} options
     */
    fromOptions(v, b) {
      if (typeof v == "string")
        return this.fromString(v, b);
      e(v);
      const { hash: h, type: o } = v;
      return this.fromHash(h, o);
    }
    /**
     * Insantiate address from options.
     * @param {Object} options
     * @returns {Address}
     */
    static fromOptions(v, b) {
      return new this().fromOptions(v, b);
    }
    /**
     * Get the address hash.
     * @param {String?} enc - Can be `"hex"` or `null`.
     * @returns {Hash|Buffer}
     */
    getHash(v) {
      return v === "hex" ? this.hash.toString("hex") : this.hash;
    }
    /**
     * Test whether the address is null.
     * @returns {Boolean}
     */
    isNull() {
      if (this.hash.length === 20)
        return this.hash.equals(i);
      if (this.hash.length === 32)
        return this.hash.equals(a.ZERO_HASH);
      for (let v = 0; v < this.hash.length; v++)
        if (this.hash[v] !== 0)
          return !1;
      return !0;
    }
    /**
     * Test equality against another address.
     * @param {Address} addr
     * @returns {Boolean}
     */
    equals(v) {
      return e(v instanceof p), this.type === v.type && this.hash.equals(v.hash);
    }
    /**
     * Get the address type as a string.
     * @returns {String}
     */
    getType() {
      return p.typesByVal[this.type].toLowerCase();
    }
    /**
     * Get a network address prefix for the address.
     * @param {Network?} network
     * @returns {Number}
     */
    getPrefix(v) {
      v = u.get(v);
      const b = v.addressPrefix;
      switch (this.type) {
        case p.types.PUBKEYHASH:
          return b.pubkeyhash;
        case p.types.SCRIPTHASH:
          return b.scripthash;
      }
      return -1;
    }
    /**
     * Calculate size of serialized address.
     * @returns {Number}
     */
    getSize() {
      return 5 + this.hash.length;
    }
    /**
     * Compile the address object to its raw serialization.
     * @param {{NetworkType|Network)?} network
     * @returns {Buffer}
     * @throws Error on bad hash/prefix.
     */
    toRaw(v) {
      const b = this.getSize(), h = c.write(b), o = this.getPrefix(v);
      return e(o !== -1, "Not a valid address prefix."), h.writeU8(o), h.writeBytes(this.hash), h.writeChecksum(n.digest), h.render();
    }
    /**
     * Compile the address object to a base58 address.
     * @param {{NetworkType|Network)?} network
     * @returns {AddressString}
     * @throws Error on bad hash/prefix.
     */
    toBase58(v) {
      return d.encode(this.toRaw(v));
    }
    /**
     * Compile the address object to a cashaddr address.
     * @param {{NetworkType|Network)?} network
     * @returns {String}
     * @throws Error on bad hash/prefix.
     */
    toCashAddr(v) {
      const b = this.type, h = this.hash;
      v = u.get(v);
      const o = v.addressPrefix.cashaddr;
      return w.encode(o, b, h);
    }
    /**
     * Inject properties from string.
     * @private
     * @param {String} addr
     * @param {(Network|NetworkType)?} network
     * @returns {Address}
     */
    fromString(v, b) {
      if (e(typeof v == "string"), e(v.length > 0), e(v.length <= 100), m(v))
        return this.fromBase58(v, b);
      try {
        return this.fromCashAddr(v, b);
      } catch {
        return this.fromBase58(v, b);
      }
    }
    /**
     * Instantiate address from string.
     * @param {String} addr
     * @param {(Network|NetworkType)?} network
     * @returns {Address}
     */
    static fromString(v, b) {
      return new this().fromString(v, b);
    }
    /**
     * Return cashaddr by default
     * @param {(Network|NetworkType)?} network
     * @returns {AddressString}
     */
    toString(v) {
      return this.toCashAddr(v);
    }
    /**
     * Inspect the Address.
     * @returns {Object}
     */
    [s]() {
      return `<Address: type=${this.getType()} str=${this.toString()}>`;
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     * @throws Parse error
     */
    fromRaw(v, b) {
      const h = c.read(v, !0), o = h.readU8();
      b = u.fromAddress(o, b);
      const S = p.getType(o, b);
      if (v.length !== 25)
        throw new Error("Address is too long.");
      const H = h.readBytes(h.left() - 4);
      return h.verifyChecksum(n.digest), this.fromHash(H, S);
    }
    /**
     * Create an address object from a serialized address.
     * @param {Buffer} data
     * @returns {Address}
     * @throws Parse error.
     */
    static fromRaw(v, b) {
      return new this().fromRaw(v, b);
    }
    /**
     * Inject properties from base58 address.
     * @private
     * @param {AddressString} data
     * @param {Network?} network
     * @throws Parse error
     */
    fromBase58(v, b) {
      if (e(typeof v == "string"), v.length > 55)
        throw new Error("Address is too long.");
      return this.fromRaw(d.decode(v), b);
    }
    /**
     * Create an address object from a base58 address.
     * @param {AddressString} data
     * @param {Network?} network
     * @returns {Address}
     * @throws Parse error.
     */
    static fromBase58(v, b) {
      return new this().fromBase58(v, b);
    }
    /**
     * Inject properties from cashaddr address.
     * @private
     * @param {String} data
     * @param {Network?} network
     * @throws Parse error
     */
    fromCashAddr(v, b) {
      e(typeof v == "string"), b = u.get(b), b.addressPrefix.cashaddr;
      const h = g.decode(v);
      return h.type = h.type === "P2PKH" ? "PUBKEYHASH" : "SCRIPTHASH", u.fromCashAddr(h.prefix, b), this.fromHash(k.from(h.hash), h.type);
    }
    /**
     * Create an address object from a cashaddr address.
     * @param {String} data
     * @param {Network?} network
     * @returns {Address}
     * @throws Parse error.
     */
    static fromCashAddr(v, b) {
      return new this().fromCashAddr(v, b);
    }
    /**
     * Inject properties from output script.
     * @private
     * @param {Script} script
     */
    fromScript(v) {
      const b = v.getPubkey();
      if (b)
        return this.hash = f.digest(b), this.type = p.types.PUBKEYHASH, this;
      const h = v.getPubkeyhash();
      if (h)
        return this.hash = h, this.type = p.types.PUBKEYHASH, this;
      const o = v.getScripthash();
      return o ? (this.hash = o, this.type = p.types.SCRIPTHASH, this) : v.isMultisig() ? (this.hash = v.hash160(), this.type = p.types.SCRIPTHASH, this) : null;
    }
    /**
     * Inject properties from input script.
     * @private
     * @param {Script} script
     */
    fromInputScript(v) {
      const [, b] = v.getPubkeyhashInput();
      if (b)
        return this.hash = f.digest(b), this.type = p.types.PUBKEYHASH, this;
      const h = v.getScripthashInput();
      return h ? (this.hash = f.digest(h), this.type = p.types.SCRIPTHASH, this) : null;
    }
    /**
     * Create an Address from an input script.
     * Attempt to extract address
     * properties from an input script.
     * @param {Script}
     * @returns {Address|null}
     */
    static fromInputScript(v) {
      return new this().fromInputScript(v);
    }
    /**
     * Create an Address from an output script.
     * Parse an output script and extract address
     * properties. Converts pubkey and multisig
     * scripts to pubkeyhash and scripthash addresses.
     * @param {Script}
     * @returns {Address|null}
     */
    static fromScript(v) {
      return new this().fromScript(v);
    }
    /**
     * Inject properties from a hash.
     * @private
     * @param {Buffer|Hash} hash
     * @param {AddressPrefix} type
     * @throws on bad hash size
     */
    fromHash(v, b) {
      return typeof b == "string" && (b = p.types[b.toUpperCase()], e(b != null, "Not a valid address type.")), b == null && (b = p.types.PUBKEYHASH), e(k.isBuffer(v)), e(b >>> 0 === b), e(
        b >= p.types.PUBKEYHASH && b <= p.types.SCRIPTHASH,
        "Not a valid address type."
      ), e(v.length === 20, "Hash is the wrong size."), this.hash = v, this.type = b, this;
    }
    /**
     * Create a naked address from hash/type.
     * @param {Hash} hash
     * @param {AddressPrefix} type
     * @returns {Address}
     * @throws on bad hash size
     */
    static fromHash(v, b) {
      return new this().fromHash(v, b);
    }
    /**
     * Inject properties from pubkeyhash.
     * @private
     * @param {Buffer} hash
     * @returns {Address}
     */
    fromPubkeyhash(v) {
      const b = p.types.PUBKEYHASH;
      return e(v.length === 20, "P2PKH must be 20 bytes."), this.fromHash(v, b, -1);
    }
    /**
     * Instantiate address from pubkeyhash.
     * @param {Buffer} hash
     * @returns {Address}
     */
    static fromPubkeyhash(v) {
      return new this().fromPubkeyhash(v);
    }
    /**
     * Inject properties from scripthash.
     * @private
     * @param {Buffer} hash
     * @returns {Address}
     */
    fromScripthash(v) {
      const b = p.types.SCRIPTHASH;
      return e(v && v.length === 20, "P2SH must be 20 bytes."), this.fromHash(v, b, -1);
    }
    /**
     * Instantiate address from scripthash.
     * @param {Buffer} hash
     * @returns {Address}
     */
    static fromScripthash(v) {
      return new this().fromScripthash(v);
    }
    /**
     * Test whether the address is pubkeyhash.
     * @returns {Boolean}
     */
    isPubkeyhash() {
      return this.type === p.types.PUBKEYHASH;
    }
    /**
     * Test whether the address is scripthash.
     * @returns {Boolean}
     */
    isScripthash() {
      return this.type === p.types.SCRIPTHASH;
    }
    /**
     * Get the hash of a base58 address or address-related object.
     * @param {Address|Hash} data
     * @param {String?} enc - Can be `"hex"` or `null`.
     * @returns {Hash}
     */
    static getHash(v, b) {
      if (!v)
        throw new Error("Object is not an address.");
      let h;
      if (k.isBuffer(v)) {
        if (v.length !== 20)
          throw new Error("Object is not an address.");
        h = v;
      } else if (v instanceof p)
        h = v.hash;
      else
        throw new Error("Object is not an address.");
      return b === "hex" ? h.toString("hex") : h;
    }
    /**
     * Get an address type for a specified network address prefix.
     * @param {Number} prefix
     * @param {Network} network
     * @returns {AddressType}
     */
    static getType(v, b) {
      const h = b.addressPrefix;
      switch (v) {
        case h.pubkeyhash:
          return p.types.PUBKEYHASH;
        case h.scripthash:
          return p.types.SCRIPTHASH;
        default:
          throw new Error("Unknown address prefix.");
      }
    }
  }
  p.types = {
    PUBKEYHASH: 0,
    SCRIPTHASH: 1
  }, p.typesByVal = [
    "PUBKEYHASH",
    "SCRIPTHASH"
  ];
  function m(E) {
    let v = !1, b = !1;
    for (let h = 0; h < E.length; h++) {
      const o = E.charCodeAt(h);
      if (!(o >= 48 && o <= 57) && o !== 58 && (o & 32 ? (e(o >= 97 && o <= 122), v = !0) : (e(o >= 65 && o <= 90), b = !0), v && b))
        return !0;
    }
    return !1;
  }
  return x0 = p, x0;
}
var w0, Z1;
function eb() {
  if (Z1) return w0;
  Z1 = 1;
  const e = nt, c = Ci(), d = Ni();
  class w {
    /**
     * Create a bitcoin URI.
     * @alias module:btc.URI
     * @constructor
     * @param {Object|String} options
     */
    constructor(s) {
      this.address = new c(), this.amount = -1, this.label = null, this.message = null, this.request = null, s && this.fromOptions(s);
    }
    /**
     * Inject properties from options object.
     * @private
     * @param {Object|String} options
     * @returns {URI}
     */
    fromOptions(s) {
      return typeof s == "string" ? this.fromString(s) : (s.address && this.address.fromOptions(s.address), s.amount != null && (e(
        Number.isSafeInteger(s.amount) && s.amount >= 0,
        "Amount must be a uint64."
      ), this.amount = s.amount), s.label && (e(typeof s.label == "string", "Label must be a string."), this.label = s.label), s.message && (e(typeof s.message == "string", "Message must be a string."), this.message = s.message), s.request && (e(typeof s.request == "string", "Request must be a string."), this.request = s.request), this);
    }
    /**
     * Instantiate URI from options.
     * @param {Object|String} options
     * @returns {URI}
     */
    static fromOptions(s) {
      return new this().fromOptions(s);
    }
    /**
     * Parse and inject properties from string.
     * @private
     * @param {String} str
     * @param {Network?} network
     * @returns {URI}
     */
    fromString(s, i) {
      e(typeof s == "string"), e(s.length > 8, "Not a bitcoin URI.");
      const p = s.substring(0, 8);
      e(p === "bitcoin:", "Not a bitcoin URI."), s = s.substring(8);
      const m = s.indexOf("?");
      let E, v;
      if (m === -1 ? E = s : (E = s.substring(0, m), v = s.substring(m + 1)), this.address.fromString(E, i), !v)
        return this;
      const b = f(v);
      return b.amount && (e(b.amount.length > 0, "Value is empty."), e(b.amount[0] !== "-", "Value is negative."), this.amount = d.value(b.amount)), b.label && (this.label = b.label), b.message && (this.message = b.message), b.r && (this.request = b.r), this;
    }
    /**
     * Instantiate uri from string.
     * @param {String} str
     * @param {Network?} network
     * @returns {URI}
     */
    static fromString(s, i) {
      return new this().fromString(s, i);
    }
    /**
     * Serialize uri to a string.
     * @returns {String}
     */
    toString() {
      let s = "bitcoin:";
      s += this.address.toString();
      const i = [];
      return this.amount !== -1 && i.push(`amount=${d.btc(this.amount)}`), this.label && i.push(`label=${u(this.label)}`), this.message && i.push(`message=${u(this.message)}`), this.request && i.push(`r=${u(this.request)}`), i.length > 0 && (s += "?" + i.join("&")), s;
    }
    /**
     * Inspect bitcoin uri.
     * @returns {String}
     */
    inspect() {
      return `<URI: ${this.toString()}>`;
    }
  }
  class g {
    constructor() {
      this.amount = null, this.label = null, this.message = null, this.r = null;
    }
  }
  function f(a) {
    const s = a.split("&"), i = new g();
    let p = 0;
    for (const m of s) {
      const E = m.indexOf("=");
      let v, b;
      if (E === -1 ? (v = m, b = "") : (v = m.substring(0, E), b = m.substring(E + 1)), v.length === 0) {
        e(b.length === 0, "Empty key in querystring.");
        continue;
      }
      switch (e(p < 4, "Too many keys in querystring."), v) {
        case "amount":
          e(i.amount == null, "Duplicate key in querystring (amount)."), i.amount = n(b);
          break;
        case "label":
          e(i.label == null, "Duplicate key in querystring (label)."), i.label = n(b);
          break;
        case "message":
          e(i.message == null, "Duplicate key in querystring (message)."), i.message = n(b);
          break;
        case "r":
          e(i.r == null, "Duplicate key in querystring (r)."), i.r = n(b);
          break;
        default:
          e(!1, `Unknown querystring key: ${b}.`);
          break;
      }
      p += 1;
    }
    return i;
  }
  function n(a) {
    try {
      a = decodeURIComponent(a), a = a.replace(/\+/g, " ");
    } catch {
      throw new Error("Malformed URI.");
    }
    if (a.indexOf("\0") !== -1)
      throw new Error("Malformed URI.");
    return a;
  }
  function u(a) {
    return a = encodeURIComponent(a), a = a.replace(/%20/g, "+"), a;
  }
  return w0 = w, w0;
}
/*!
 * btc/index.js - high-level btc objects for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var Q1;
function Zm() {
  return Q1 || (Q1 = 1, cs.Amount = Ni(), cs.URI = eb()), cs;
}
var $i = {};
/*!
 * sha1.js - SHA1 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/hash.js:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/hash.js
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/SHA-1
 *   https://tools.ietf.org/html/rfc3174
 *   http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf
 *   https://github.com/indutny/hash.js/blob/master/lib/hash/sha/1.js
 */
var y0, ed;
function tb() {
  if (ed) return y0;
  ed = 1;
  const e = Bt(), c = ri(), d = -1, w = k.alloc(8, 0), g = k.alloc(64, 0);
  g[0] = 128;
  const f = new Uint32Array([
    1518500249,
    1859775393,
    2400959708,
    3395469782
  ]);
  class n {
    constructor() {
      this.state = new Uint32Array(5), this.msg = new Uint32Array(80), this.block = k.alloc(64), this.size = d;
    }
    init() {
      return this.state[0] = 1732584193, this.state[1] = 4023233417, this.state[2] = 2562383102, this.state[3] = 271733878, this.state[4] = 3285377520, this.size = 0, this;
    }
    update(b) {
      return e(k.isBuffer(b)), this._update(b, b.length), this;
    }
    final() {
      return this._final(k.alloc(20));
    }
    _update(b, h) {
      e(this.size !== d, "Context is not initialized.");
      let o = this.size & 63, S = 0;
      if (this.size += h, o > 0) {
        let H = 64 - o;
        if (H > h && (H = h), b.copy(this.block, o, S, S + H), o += H, h -= H, S += H, o < 64)
          return;
        this._transform(this.block, 0);
      }
      for (; h >= 64; )
        this._transform(b, S), S += 64, h -= 64;
      h > 0 && b.copy(this.block, 0, S, S + h);
    }
    _final(b) {
      e(this.size !== d, "Context is not initialized.");
      const h = this.size & 63, o = this.size * 8;
      E(w, o * (1 / 4294967296) >>> 0, 0), E(w, o >>> 0, 4), this._update(g, 1 + (119 - h & 63)), this._update(w, 8);
      for (let S = 0; S < 5; S++)
        E(b, this.state[S], S * 4), this.state[S] = 0;
      for (let S = 0; S < 80; S++)
        this.msg[S] = 0;
      for (let S = 0; S < 64; S++)
        this.block[S] = 0;
      return this.size = d, b;
    }
    _transform(b, h) {
      const o = this.msg;
      let S = this.state[0], H = this.state[1], j = this.state[2], J = this.state[3], N = this.state[4], z = 0;
      for (; z < 16; z++)
        o[z] = m(b, h + z * 4);
      for (; z < 80; z++)
        o[z] = u(o[z - 3] ^ o[z - 8] ^ o[z - 14] ^ o[z - 16], 1);
      for (z = 0; z < 80; z++) {
        const A = z / 20 | 0, q = u(S, 5) + a(A, H, j, J) + N + o[z] + f[A];
        N = J, J = j, j = u(H, 30), H = S, S = q >>> 0;
      }
      this.state[0] += S, this.state[1] += H, this.state[2] += j, this.state[3] += J, this.state[4] += N;
    }
    static hash() {
      return new n();
    }
    static hmac() {
      return new c(n, 64);
    }
    static digest(b) {
      return n.ctx.init().update(b).final();
    }
    static root(b, h) {
      return e(k.isBuffer(b) && b.length === 20), e(k.isBuffer(h) && h.length === 20), n.ctx.init().update(b).update(h).final();
    }
    static multi(b, h, o) {
      const { ctx: S } = n;
      return S.init(), S.update(b), S.update(h), o && S.update(o), S.final();
    }
    static mac(b, h) {
      return n.hmac().init(h).update(b).final();
    }
  }
  n.native = 0, n.id = "SHA1", n.size = 20, n.bits = 160, n.blockSize = 64, n.zero = k.alloc(20, 0), n.ctx = new n();
  function u(v, b) {
    return v << b | v >>> 32 - b;
  }
  function a(v, b, h, o) {
    return v === 0 ? s(b, h, o) : v === 1 || v === 3 ? p(b, h, o) : v === 2 ? i(b, h, o) : 0;
  }
  function s(v, b, h) {
    return v & b ^ ~v & h;
  }
  function i(v, b, h) {
    return v & b ^ v & h ^ b & h;
  }
  function p(v, b, h) {
    return v ^ b ^ h;
  }
  function m(v, b) {
    return v[b++] * 16777216 + v[b++] * 65536 + v[b++] * 256 + v[b];
  }
  function E(v, b, h) {
    return v[h++] = b >>> 24, v[h++] = b >>> 16, v[h++] = b >>> 8, v[h++] = b, h;
  }
  return y0 = n, y0;
}
var v0 = {};
/*!
 * policy.js - bitcoin constants for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var td;
function ln() {
  return td || (td = 1, function(e) {
    const c = nt, d = Xt();
    e.MAX_TX_VERSION = d.MAX_TX_VERSION, e.MAX_TX_SIZE = d.MAX_TX_SIZE / 10, e.MAX_TX_SIGOPS = d.MAX_TX_SIGOPS / 5, e.BYTES_PER_SIGOP = 20, e.MIN_RELAY = 1e3, e.BARE_MULTISIG = !0, e.FREE_THRESHOLD = d.COIN * 144 / 250, e.MAX_P2SH_SIGOPS = 15, e.MAX_OP_RETURN_BYTES = 223, e.MAX_OP_RETURN = 220, e.MAX_P2WSH_STACK = 100, e.MAX_P2WSH_PUSH = 80, e.MAX_P2WSH_SIZE = 3600, e.MEMPOOL_MAX_ANCESTORS = 50, e.MEMPOOL_MAX_SIZE = 100 * 1e6, e.MEMPOOL_EXPIRY_TIME = 4320 * 60, e.MEMPOOL_MAX_ORPHANS = 100, e.MIN_BLOCK_SIZE = 0, e.MAX_BLOCK_SIZE = d.MAX_FORK_BLOCK_SIZE, e.BLOCK_PRIORITY_SIZE = 0, e.BLOCK_PRIORITY_THRESHOLD = e.FREE_THRESHOLD, e.getMinFee = function(g, f) {
      if (f == null && (f = e.MIN_RELAY), c(g >= 0), c(f >= 0), g === 0)
        return 0;
      let n = Math.floor(f * g / 1e3);
      return n === 0 && f > 0 && (n = f), n;
    }, e.getRoundFee = function(g, f) {
      if (f == null && (f = e.MIN_RELAY), c(g >= 0), c(f >= 0), g === 0)
        return 0;
      let n = f * Math.ceil(g / 1e3);
      return n === 0 && f > 0 && (n = f), n;
    }, e.getRate = function(g, f) {
      return c(g >= 0), c(f >= 0), g === 0 ? 0 : Math.floor(f * 1e3 / g);
    };
  }(v0)), v0;
}
/*!
 * scripterror.js - script error for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var S0, rd;
function js() {
  if (rd) return S0;
  rd = 1;
  class e extends Error {
    /**
     * Create an error.
     * @constructor
     * @param {String} code - Error code.
     * @param {Opcode} op - Opcode.
     * @param {Number?} ip - Instruction pointer.
     */
    constructor(d, w, g) {
      super(), this.type = "ScriptError", this.code = d, this.message = d, this.op = -1, this.ip = -1, typeof w == "string" ? this.message = w : w && (this.message = `${d} (op=${w.toSymbol()}, ip=${g})`, this.op = w.value, this.ip = g), Error.captureStackTrace && Error.captureStackTrace(this, e);
    }
  }
  return S0 = e, S0;
}
/*!
 * scriptnum.js - script number object for bcoin.
 * Copyright (c) 2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var E0, id;
function Di() {
  if (id) return E0;
  id = 1;
  const e = nt, { I64: c } = f8, d = js(), w = k.alloc(0);
  class g extends c {
    /**
     * Create a script number.
     * @constructor
     * @param {(Number|String|Buffer|Object)?} num
     * @param {(String|Number)?} base
     */
    constructor(n, u) {
      super(n, u);
    }
    /**
     * Cast to int32.
     * @returns {Number}
     */
    getInt() {
      return this.lt(c.INT32_MIN) ? c.LONG_MIN : this.gt(c.INT32_MAX) ? c.LONG_MAX : this.toInt();
    }
    /**
     * Serialize script number.
     * @returns {Buffer}
     */
    toRaw() {
      let n = this;
      if (n.isZero())
        return w;
      let u = !1;
      n.isNeg() && (n = n.neg(), u = !0);
      const a = n.byteLength();
      let s = 0;
      n.testn(a * 8 - 1) && (s = 1);
      const i = k.allocUnsafe(a + s);
      switch (a) {
        case 8:
          i[7] = n.hi >>> 24 & 255;
        case 7:
          i[6] = n.hi >> 16 & 255;
        case 6:
          i[5] = n.hi >> 8 & 255;
        case 5:
          i[4] = n.hi & 255;
        case 4:
          i[3] = n.lo >>> 24 & 255;
        case 3:
          i[2] = n.lo >> 16 & 255;
        case 2:
          i[1] = n.lo >> 8 & 255;
        case 1:
          i[0] = n.lo & 255;
      }
      return i[a - 1] & 128 ? (e(s === 1), e(i.length === a + s), i[a] = u ? 128 : 0) : u ? (e(s === 0), e(i.length === a), i[a - 1] |= 128) : (e(s === 0), e(i.length === a)), i;
    }
    /**
     * Instantiate script number from serialized data.
     * @private
     * @param {Buffer} data
     * @returns {ScriptNum}
     */
    fromRaw(n) {
      if (e(k.isBuffer(n)), n.length === 0)
        return this;
      switch (n.length) {
        case 8:
          this.hi |= n[7] << 24;
        case 7:
          this.hi |= n[6] << 16;
        case 6:
          this.hi |= n[5] << 8;
        case 5:
          this.hi |= n[4];
        case 4:
          this.lo |= n[3] << 24;
        case 3:
          this.lo |= n[2] << 16;
        case 2:
          this.lo |= n[1] << 8;
        case 1:
          this.lo |= n[0];
          break;
        default:
          for (let u = 0; u < n.length; u++)
            this.orb(u, n[u]);
          break;
      }
      return n[n.length - 1] & 128 && (this.setn(n.length * 8 - 1, 0), this.ineg()), this;
    }
    /**
     * Serialize script number.
     * @returns {Buffer}
     */
    encode() {
      return this.toRaw();
    }
    /**
     * Decode and verify script number.
     * @private
     * @param {Buffer} data
     * @param {Boolean?} minimal - Require minimal encoding.
     * @param {Number?} limit - Size limit.
     * @returns {ScriptNum}
     */
    decode(n, u, a) {
      if (e(k.isBuffer(n)), a != null && n.length > a)
        throw new d("UNKNOWN_ERROR", "Script number overflow.");
      if (u && !g.isMinimal(n))
        throw new d("UNKNOWN_ERROR", "Non-minimal script number.");
      return this.fromRaw(n);
    }
    /**
     * Inspect script number.
     * @returns {String}
     */
    inspect() {
      return `<ScriptNum: ${this.toString(10)}>`;
    }
    /**
     * Test wether a serialized script
     * number is in its most minimal form.
     * @param {Buffer} data
     * @returns {Boolean}
     */
    static isMinimal(n) {
      return e(k.isBuffer(n)), n.length === 0 ? !0 : !((n[n.length - 1] & 127) === 0 && (n.length === 1 || (n[n.length - 2] & 128) === 0));
    }
    /**
     * Encode serialized script number in its most minimal form.
     * @param {Buffer} data
     * @returns {Buffer} minimal encoded data
     */
    static toMinimal(n) {
      if (e(k.isBuffer(n)), this.isMinimal(n))
        return n;
      const u = n[n.length - 1];
      for (let a = n.length - 1; a > 0; a--)
        if (n[a - 1] !== 0)
          return n[a - 1] & 128 ? n[a++] = u : n[a - 1] |= u, n = n.slice(0, a), n;
      return n = k.alloc(0), n;
    }
    /**
     * Decode and verify script number.
     * @param {Buffer} data
     * @param {Boolean?} minimal - Require minimal encoding.
     * @param {Number?} limit - Size limit.
     * @returns {ScriptNum}
     */
    static decode(n, u, a) {
      return new this().decode(n, u, a);
    }
    /**
     * Test whether object is a script number.
     * @param {Object} obj
     * @returns {Boolean}
     */
    static isScriptNum(n) {
      return n instanceof g;
    }
  }
  return E0 = g, E0;
}
var I0 = {};
/*!
 * common.js - common script functions for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var nd;
function Yn() {
  return nd || (nd = 1, function(e) {
    const c = nt, d = Fr(), w = Di();
    e.opcodes = {
      // Push
      OP_0: 0,
      OP_PUSHDATA1: 76,
      OP_PUSHDATA2: 77,
      OP_PUSHDATA4: 78,
      OP_1NEGATE: 79,
      OP_RESERVED: 80,
      OP_1: 81,
      OP_2: 82,
      OP_3: 83,
      OP_4: 84,
      OP_5: 85,
      OP_6: 86,
      OP_7: 87,
      OP_8: 88,
      OP_9: 89,
      OP_10: 90,
      OP_11: 91,
      OP_12: 92,
      OP_13: 93,
      OP_14: 94,
      OP_15: 95,
      OP_16: 96,
      // Control
      OP_NOP: 97,
      OP_VER: 98,
      OP_IF: 99,
      OP_NOTIF: 100,
      OP_VERIF: 101,
      OP_VERNOTIF: 102,
      OP_ELSE: 103,
      OP_ENDIF: 104,
      OP_VERIFY: 105,
      OP_RETURN: 106,
      // Stack
      OP_TOALTSTACK: 107,
      OP_FROMALTSTACK: 108,
      OP_2DROP: 109,
      OP_2DUP: 110,
      OP_3DUP: 111,
      OP_2OVER: 112,
      OP_2ROT: 113,
      OP_2SWAP: 114,
      OP_IFDUP: 115,
      OP_DEPTH: 116,
      OP_DROP: 117,
      OP_DUP: 118,
      OP_NIP: 119,
      OP_OVER: 120,
      OP_PICK: 121,
      OP_ROLL: 122,
      OP_ROT: 123,
      OP_SWAP: 124,
      OP_TUCK: 125,
      // Splice
      OP_CAT: 126,
      OP_SPLIT: 127,
      OP_NUM2BIN: 128,
      OP_BIN2NUM: 129,
      OP_SIZE: 130,
      // Bit
      OP_INVERT: 131,
      OP_AND: 132,
      OP_OR: 133,
      OP_XOR: 134,
      OP_EQUAL: 135,
      OP_EQUALVERIFY: 136,
      OP_RESERVED1: 137,
      OP_RESERVED2: 138,
      // Numeric
      OP_1ADD: 139,
      OP_1SUB: 140,
      OP_2MUL: 141,
      OP_2DIV: 142,
      OP_NEGATE: 143,
      OP_ABS: 144,
      OP_NOT: 145,
      OP_0NOTEQUAL: 146,
      OP_ADD: 147,
      OP_SUB: 148,
      OP_MUL: 149,
      OP_DIV: 150,
      OP_MOD: 151,
      OP_LSHIFT: 152,
      OP_RSHIFT: 153,
      OP_BOOLAND: 154,
      OP_BOOLOR: 155,
      OP_NUMEQUAL: 156,
      OP_NUMEQUALVERIFY: 157,
      OP_NUMNOTEQUAL: 158,
      OP_LESSTHAN: 159,
      OP_GREATERTHAN: 160,
      OP_LESSTHANOREQUAL: 161,
      OP_GREATERTHANOREQUAL: 162,
      OP_MIN: 163,
      OP_MAX: 164,
      OP_WITHIN: 165,
      // Crypto
      OP_RIPEMD160: 166,
      OP_SHA1: 167,
      OP_SHA256: 168,
      OP_HASH160: 169,
      OP_HASH256: 170,
      OP_CODESEPARATOR: 171,
      OP_CHECKSIG: 172,
      OP_CHECKSIGVERIFY: 173,
      OP_CHECKMULTISIG: 174,
      OP_CHECKMULTISIGVERIFY: 175,
      // Expansion
      OP_NOP1: 176,
      OP_CHECKLOCKTIMEVERIFY: 177,
      OP_CHECKSEQUENCEVERIFY: 178,
      OP_NOP4: 179,
      OP_NOP5: 180,
      OP_NOP6: 181,
      OP_NOP7: 182,
      OP_NOP8: 183,
      OP_NOP9: 184,
      OP_NOP10: 185,
      // More Crypto
      OP_CHECKDATASIG: 186,
      OP_CHECKDATASIGVERIFY: 187,
      // additional byte-string operations
      OP_REVERSEBYTES: 188,
      // Custom
      OP_INVALIDOPCODE: 255
    }, e.opcodesByVal = {
      // Push
      0: "OP_0",
      76: "OP_PUSHDATA1",
      77: "OP_PUSHDATA2",
      78: "OP_PUSHDATA4",
      79: "OP_1NEGATE",
      80: "OP_RESERVED",
      81: "OP_1",
      82: "OP_2",
      83: "OP_3",
      84: "OP_4",
      85: "OP_5",
      86: "OP_6",
      87: "OP_7",
      88: "OP_8",
      89: "OP_9",
      90: "OP_10",
      91: "OP_11",
      92: "OP_12",
      93: "OP_13",
      94: "OP_14",
      95: "OP_15",
      96: "OP_16",
      // Control
      97: "OP_NOP",
      98: "OP_VER",
      99: "OP_IF",
      100: "OP_NOTIF",
      101: "OP_VERIF",
      102: "OP_VERNOTIF",
      103: "OP_ELSE",
      104: "OP_ENDIF",
      105: "OP_VERIFY",
      106: "OP_RETURN",
      // Stack
      107: "OP_TOALTSTACK",
      108: "OP_FROMALTSTACK",
      109: "OP_2DROP",
      110: "OP_2DUP",
      111: "OP_3DUP",
      112: "OP_2OVER",
      113: "OP_2ROT",
      114: "OP_2SWAP",
      115: "OP_IFDUP",
      116: "OP_DEPTH",
      117: "OP_DROP",
      118: "OP_DUP",
      119: "OP_NIP",
      120: "OP_OVER",
      121: "OP_PICK",
      122: "OP_ROLL",
      123: "OP_ROT",
      124: "OP_SWAP",
      125: "OP_TUCK",
      // Splice
      126: "OP_CAT",
      127: "OP_SPLIT",
      128: "OP_NUM2BIN",
      129: "OP_BIN2NUM",
      130: "OP_SIZE",
      // Bit
      131: "OP_INVERT",
      132: "OP_AND",
      133: "OP_OR",
      134: "OP_XOR",
      135: "OP_EQUAL",
      136: "OP_EQUALVERIFY",
      137: "OP_RESERVED1",
      138: "OP_RESERVED2",
      // Numeric
      139: "OP_1ADD",
      140: "OP_1SUB",
      141: "OP_2MUL",
      142: "OP_2DIV",
      143: "OP_NEGATE",
      144: "OP_ABS",
      145: "OP_NOT",
      146: "OP_0NOTEQUAL",
      147: "OP_ADD",
      148: "OP_SUB",
      149: "OP_MUL",
      150: "OP_DIV",
      151: "OP_MOD",
      152: "OP_LSHIFT",
      153: "OP_RSHIFT",
      154: "OP_BOOLAND",
      155: "OP_BOOLOR",
      156: "OP_NUMEQUAL",
      157: "OP_NUMEQUALVERIFY",
      158: "OP_NUMNOTEQUAL",
      159: "OP_LESSTHAN",
      160: "OP_GREATERTHAN",
      161: "OP_LESSTHANOREQUAL",
      162: "OP_GREATERTHANOREQUAL",
      163: "OP_MIN",
      164: "OP_MAX",
      165: "OP_WITHIN",
      // Crypto
      166: "OP_RIPEMD160",
      167: "OP_SHA1",
      168: "OP_SHA256",
      169: "OP_HASH160",
      170: "OP_HASH256",
      171: "OP_CODESEPARATOR",
      172: "OP_CHECKSIG",
      173: "OP_CHECKSIGVERIFY",
      174: "OP_CHECKMULTISIG",
      175: "OP_CHECKMULTISIGVERIFY",
      // Expansion
      176: "OP_NOP1",
      177: "OP_CHECKLOCKTIMEVERIFY",
      178: "OP_CHECKSEQUENCEVERIFY",
      179: "OP_NOP4",
      180: "OP_NOP5",
      181: "OP_NOP6",
      182: "OP_NOP7",
      183: "OP_NOP8",
      184: "OP_NOP9",
      185: "OP_NOP10",
      // More Crypto
      186: "OP_CHECKDATASIG",
      187: "OP_CHECKDATASIGVERIFY",
      // Additional byte-string operation
      188: "OP_REVERSEBYTES",
      // Custom
      255: "OP_INVALIDOPCODE"
    }, e.small = [
      k.from([129]),
      k.from([]),
      k.from([1]),
      k.from([2]),
      k.from([3]),
      k.from([4]),
      k.from([5]),
      k.from([6]),
      k.from([7]),
      k.from([8]),
      k.from([9]),
      k.from([10]),
      k.from([11]),
      k.from([12]),
      k.from([13]),
      k.from([14]),
      k.from([15]),
      k.from([16])
    ], e.flags = {
      VERIFY_NONE: 0,
      VERIFY_P2SH: 1,
      VERIFY_STRICTENC: 2,
      VERIFY_DERSIG: 4,
      VERIFY_LOW_S: 8,
      VERIFY_SIGPUSHONLY: 32,
      VERIFY_MINIMALDATA: 64,
      VERIFY_DISCOURAGE_UPGRADABLE_NOPS: 128,
      VERIFY_CLEANSTACK: 256,
      VERIFY_CHECKLOCKTIMEVERIFY: 512,
      VERIFY_CHECKSEQUENCEVERIFY: 1024,
      VERIFY_MINIMALIF: 8192,
      VERIFY_NULLFAIL: 16384,
      VERIFY_COMPRESSED_PUBKEYTYPE: 32768,
      VERIFY_SIGHASH_FORKID: 65536,
      VERIFY_REPLAY_PROTECTION: 1 << 17,
      VERIFY_CHECKDATASIG: 1 << 18,
      VERIFY_SCHNORR: 1 << 19,
      VERIFY_DISALLOW_SEGWIT_RECOVERY: 1 << 20,
      VERIFY_SCHNORR_MULTISIG: 1 << 21,
      VERIFY_INPUT_SIGCHECKS: 1 << 22,
      VERIFY_REVERSEBYTES: 1 << 23,
      VERIFY_ZERO_SIGOPS: 1 << 30,
      REPORT_SIGCHECKS: 1 << 31
    }, e.flags.MANDATORY_VERIFY_FLAGS = e.flags.VERIFY_P2SH, e.flags.STANDARD_VERIFY_FLAGS = 0 | e.flags.MANDATORY_VERIFY_FLAGS | e.flags.VERIFY_DERSIG | e.flags.VERIFY_STRICTENC | e.flags.VERIFY_MINIMALDATA | e.flags.VERIFY_SIGPUSHONLY | e.flags.VERIFY_DISCOURAGE_UPGRADABLE_NOPS | e.flags.VERIFY_CLEANSTACK | e.flags.VERIFY_MINIMALIF | e.flags.VERIFY_NULLFAIL | e.flags.VERIFY_CHECKLOCKTIMEVERIFY | e.flags.VERIFY_CHECKSEQUENCEVERIFY | e.flags.VERIFY_LOW_S | e.flags.VERIFY_SIGHASH_FORKID | e.flags.VERIFY_CHECKDATASIG | e.flags.VERIFY_DISALLOW_SEGWIT_RECOVERY | e.flags.VERIFY_SCHNORR_MULTISIG, e.flags.ONLY_STANDARD_VERIFY_FLAGS = e.flags.STANDARD_VERIFY_FLAGS & ~e.flags.MANDATORY_VERIFY_FLAGS, e.hashType = {
      /*
       * Sign all outputs.
       */
      ALL: 1,
      /*
       * Do not sign outputs (zero sequences).
       */
      NONE: 2,
      /*
       * Sign output at the same index (zero sequences).
       */
      SINGLE: 3,
      /*
       * Sighash fork ID.
       */
      SIGHASH_FORKID: 64,
      /*
       * Sign only the current input (mask).
       */
      ANYONECANPAY: 128
    }, e.hashTypeByVal = {
      1: "ALL",
      2: "NONE",
      3: "SINGLE",
      128: "ANYONECANPAY"
    }, e.types = {
      NONSTANDARD: 0,
      PUBKEY: 1,
      PUBKEYHASH: 2,
      SCRIPTHASH: 3,
      MULTISIG: 4,
      NULLDATA: 5
    }, e.typesByVal = {
      0: "NONSTANDARD",
      1: "PUBKEY",
      2: "PUBKEYHASH",
      3: "SCRIPTHASH",
      4: "MULTISIG",
      5: "NULLDATA"
    }, e.isHashType = function(f) {
      if (c(k.isBuffer(f)), f.length === 0)
        return !1;
      const n = f[f.length - 1] & ~(e.hashType.ANYONECANPAY | e.hashType.SIGHASH_FORKID);
      return !(n < e.hashType.ALL || n > e.hashType.SINGLE);
    }, e.countBits = function(f) {
      return f = f - (f >> 1 & 1431655765), f = (f & 858993459) + (f >> 2 & 858993459), (f + (f >> 4) & 252645135) * 16843009 >> 24;
    }, e.isSchnorr = function(f) {
      return c(k.isBuffer(f)), f.length === 64;
    }, e.isLowDER = function(f) {
      return e.isDERSignatureEncoding(f) ? d.isLowDER(f) : !1;
    }, e.isKeyEncoding = function(f) {
      if (c(k.isBuffer(f)), f.length < 33)
        return !1;
      if (f[0] === 4) {
        if (f.length !== 65)
          return !1;
      } else if (f[0] === 2 || f[0] === 3) {
        if (f.length !== 33)
          return !1;
      } else
        return !1;
      return !0;
    }, e.isCompressedEncoding = function(f) {
      return c(k.isBuffer(f)), !(f.length !== 33 || f[0] !== 2 && f[0] !== 3);
    }, e.isDERSignatureEncoding = function(f) {
      if (c(k.isBuffer(f)), f.length < 8 || f.length > 72 || f[0] !== 48 || f[1] !== f.length - 2)
        return !1;
      const n = f[3];
      if (5 + n >= f.length)
        return !1;
      const u = f[5 + n];
      return !(n + u + 6 !== f.length || f[2] !== 2 || n === 0 || f[4] & 128 || n > 1 && f[4] === 0 && !(f[5] & 128) || f[n + 4] !== 2 || u === 0 || f[n + 6] & 128 || u > 1 && f[n + 6] === 0 && !(f[n + 7] & 128));
    }, e.toASM = function(f, n) {
      if (f.length <= 4)
        return w.decode(f).toString(10);
      if (n && e.isDERSignatureEncoding(f.slice(0, -1))) {
        const u = f[f.length - 1];
        let a = e.hashTypeByVal[u & 31] || "";
        return a && (u & e.hashType.ANYONECANPAY && (a += "|ANYONECANPAY"), a = `[${a}]`), f.slice(0, -1).toString("hex") + a;
      }
      return f.toString("hex");
    }, e.hashTypeWithForkValue = function(f, n) {
      return n << 8 | f & 255;
    }, e.getHashTypeForkValue = function(f) {
      return f >>> 8;
    };
  }(I0)), I0;
}
/*!
 * opcode.js - opcode object for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var A0, sd;
function Yh() {
  if (sd) return A0;
  sd = 1;
  const e = nt, c = kt, d = Di(), w = Yn(), g = w.opcodes, f = [];
  let n = null;
  class u {
    /**
     * Create an opcode.
     * Note: this should not be called directly.
     * @constructor
     * @param {Number} value - Opcode.
     * @param {Buffer?} data - Pushdata buffer.
     */
    constructor(i, p) {
      this.value = i || 0, this.data = p || null;
    }
    /**
     * Test whether a pushdata abides by minimaldata.
     * @returns {Boolean}
     */
    isMinimal() {
      return e(0 <= this.value && this.value <= g.OP_PUSHDATA4), this.data ? this.data.length === 1 && (this.data[0] === 129 || this.data[0] >= 1 && this.data[0] <= 16) ? !1 : this.data.length <= 75 ? this.value === this.data.length : this.data.length <= 255 ? this.value === g.OP_PUSHDATA1 : this.data.length <= 65535 ? this.value === g.OP_PUSHDATA2 : !0 : !0;
    }
    /**
     * Test whether opcode is a disabled opcode.
     * @param {Number?} flags - Script standard flags.
     * @returns {Boolean}
     */
    isDisabled(i) {
      switch (this.value) {
        case g.OP_INVERT:
        case g.OP_2MUL:
        case g.OP_2DIV:
        case g.OP_MUL:
        case g.OP_LSHIFT:
        case g.OP_RSHIFT:
          return !0;
      }
      return !1;
    }
    /**
     * Test whether opcode is a branch (if/else/endif).
     * @returns {Boolean}
     */
    isBranch() {
      return this.value >= g.OP_IF && this.value <= g.OP_ENDIF;
    }
    /**
     * Test opcode equality.
     * @param {Opcode} op
     * @returns {Boolean}
     */
    equals(i) {
      return e(u.isOpcode(i)), this.value !== i.value ? !1 : this.data ? (e(i.data), this.data.equals(i.data)) : (e(!i.data), !0);
    }
    /**
     * Convert Opcode to opcode value.
     * @returns {Number}
     */
    toOp() {
      return this.value;
    }
    /**
     * Covert opcode to data push.
     * @returns {Buffer|null}
     */
    toData() {
      return this.data;
    }
    /**
     * Covert opcode to data length.
     * @returns {Number}
     */
    toLength() {
      return this.data ? this.data.length : -1;
    }
    /**
     * Covert and _cast_ opcode to data push.
     * @returns {Buffer|null}
     */
    toPush() {
      return this.value === g.OP_0 ? w.small[1] : this.value === g.OP_1NEGATE ? w.small[0] : this.value >= g.OP_1 && this.value <= g.OP_16 ? w.small[this.value - 80 + 1] : this.toData();
    }
    /**
     * Get string for opcode.
     * @param {String?} enc
     * @returns {Buffer|null}
     */
    toString(i) {
      const p = this.toPush();
      return p ? p.toString(i || "utf8") : null;
    }
    /**
     * Convert opcode to small integer.
     * @returns {Number}
     */
    toSmall() {
      return this.value === g.OP_0 ? 0 : this.value >= g.OP_1 && this.value <= g.OP_16 ? this.value - 80 : -1;
    }
    /**
     * Convert opcode to script number.
     * @param {Boolean?} minimal
     * @param {Number?} limit
     * @returns {ScriptNum|null}
     */
    toNum(i, p) {
      return this.value === g.OP_0 ? d.fromInt(0) : this.value === g.OP_1NEGATE ? d.fromInt(-1) : this.value >= g.OP_1 && this.value <= g.OP_16 ? d.fromInt(this.value - 80) : this.data ? d.decode(this.data, i, p) : null;
    }
    /**
     * Convert opcode to integer.
     * @param {Boolean?} minimal
     * @param {Number?} limit
     * @returns {Number}
     */
    toInt(i, p) {
      const m = this.toNum(i, p);
      return m ? m.getInt() : -1;
    }
    /**
     * Convert opcode to boolean.
     * @returns {Boolean}
     */
    toBool() {
      const i = this.toSmall();
      return i === -1 ? !1 : i === 1;
    }
    /**
     * Convert opcode to its symbolic representation.
     * @returns {String}
     */
    toSymbol() {
      if (this.value === -1)
        return "OP_INVALIDOPCODE";
      const i = w.opcodesByVal[this.value];
      return i || `0x${a(this.value)}`;
    }
    /**
     * Calculate opcode size.
     * @returns {Number}
     */
    getSize() {
      if (!this.data)
        return 1;
      switch (this.value) {
        case g.OP_PUSHDATA1:
          return 2 + this.data.length;
        case g.OP_PUSHDATA2:
          return 3 + this.data.length;
        case g.OP_PUSHDATA4:
          return 5 + this.data.length;
        default:
          return 1 + this.data.length;
      }
    }
    /**
     * Encode the opcode to a buffer writer.
     * @param {BufferWriter} bw
     */
    toWriter(i) {
      if (this.value === -1)
        throw new Error("Cannot reserialize a parse error.");
      if (!this.data)
        return i.writeU8(this.value), i;
      switch (this.value) {
        case g.OP_PUSHDATA1:
          i.writeU8(this.value), i.writeU8(this.data.length), i.writeBytes(this.data);
          break;
        case g.OP_PUSHDATA2:
          i.writeU8(this.value), i.writeU16(this.data.length), i.writeBytes(this.data);
          break;
        case g.OP_PUSHDATA4:
          i.writeU8(this.value), i.writeU32(this.data.length), i.writeBytes(this.data);
          break;
        default:
          e(this.value === this.data.length), i.writeU8(this.value), i.writeBytes(this.data);
          break;
      }
      return i;
    }
    /**
     * Encode the opcode.
     * @returns {Buffer}
     */
    toRaw() {
      const i = this.getSize();
      return this.toWriter(c.write(i)).render();
    }
    /**
     * Convert the opcode to a bitcoind test string.
     * @returns {String} Human-readable script code.
     */
    toFormat() {
      if (this.value === -1)
        return "0x01";
      if (this.data) {
        if (this.data.length <= 4) {
          const b = this.toNum();
          if (this.equals(u.fromNum(b)))
            return b.toString(10);
        }
        const m = w.opcodesByVal[this.value], E = this.data.toString("hex");
        if (!m)
          return `0x${a(this.value)} 0x${E}`;
        let v = this.data.length.toString(16);
        for (; v.length % 2 !== 0; )
          v = "0" + v;
        return `${m} 0x${v} 0x${E}`;
      }
      const i = w.opcodesByVal[this.value];
      return i || `0x${a(this.value)}`;
    }
    /**
     * Format the opcode as bitcoind asm.
     * @param {Boolean?} decode - Attempt to decode hash types.
     * @returns {String} Human-readable script.
     */
    toASM(i) {
      return this.value === -1 ? "[error]" : this.data ? w.toASM(this.data, i) : w.opcodesByVal[this.value] || "OP_UNKNOWN";
    }
    /**
     * Instantiate an opcode from a number opcode.
     * @param {Number} op
     * @returns {Opcode}
     */
    static fromOp(i) {
      e(typeof i == "number");
      const p = f[i];
      return e(p, "Bad opcode."), p;
    }
    /**
     * Instantiate a pushdata opcode from
     * a buffer (will encode minimaldata).
     * @param {Buffer} data
     * @returns {Opcode}
     */
    static fromData(i) {
      if (e(k.isBuffer(i)), i.length === 1) {
        if (i[0] === 129)
          return this.fromOp(g.OP_1NEGATE);
        if (i[0] >= 1 && i[0] <= 16)
          return this.fromOp(i[0] + 80);
      }
      return this.fromPush(i);
    }
    /**
     * Instantiate a pushdata opcode from a
     * buffer (this differs from fromData in
     * that it will _always_ be a pushdata op).
     * @param {Buffer} data
     * @returns {Opcode}
     */
    static fromPush(i) {
      if (e(k.isBuffer(i)), i.length === 0)
        return this.fromOp(g.OP_0);
      if (i.length <= 75)
        return new this(i.length, i);
      if (i.length <= 255)
        return new this(g.OP_PUSHDATA1, i);
      if (i.length <= 65535)
        return new this(g.OP_PUSHDATA2, i);
      if (i.length <= 4294967295)
        return new this(g.OP_PUSHDATA4, i);
      throw new Error("Pushdata size too large.");
    }
    /**
     * Instantiate a pushdata opcode from a string.
     * @param {String} str
     * @param {String} [enc=utf8]
     * @returns {Opcode}
     */
    static fromString(i, p) {
      e(typeof i == "string");
      const m = k.from(i, p || "utf8");
      return this.fromData(m);
    }
    /**
     * Instantiate an opcode from a small number.
     * @param {Number} num
     * @returns {Opcode}
     */
    static fromSmall(i) {
      return e((i & 255) === i && i >= 0 && i <= 16), this.fromOp(i === 0 ? 0 : i + 80);
    }
    /**
     * Instantiate an opcode from a ScriptNum.
     * @param {ScriptNumber} num
     * @returns {Opcode}
     */
    static fromNum(i) {
      return e(d.isScriptNum(i)), this.fromData(i.encode());
    }
    /**
     * Instantiate an opcode from a Number.
     * @param {Number} num
     * @returns {Opcode}
     */
    static fromInt(i) {
      return e(Number.isSafeInteger(i)), i === 0 ? this.fromOp(g.OP_0) : i === -1 ? this.fromOp(g.OP_1NEGATE) : i >= 1 && i <= 16 ? this.fromOp(i + 80) : this.fromNum(d.fromNumber(i));
    }
    /**
     * Instantiate an opcode from a Number.
     * @param {Boolean} value
     * @returns {Opcode}
     */
    static fromBool(i) {
      return e(typeof i == "boolean"), this.fromSmall(i ? 1 : 0);
    }
    /**
     * Instantiate a pushdata opcode from symbolic name.
     * @example
     *   Opcode.fromSymbol('checksequenceverify')
     * @param {String} name
     * @returns {Opcode}
     */
    static fromSymbol(i) {
      e(typeof i == "string"), e(i.length > 0), i.charCodeAt(0) & 32 && (i = i.toUpperCase()), /^OP_/.test(i) || (i = `OP_${i}`);
      const p = w.opcodes[i];
      if (p != null)
        return this.fromOp(p);
      e(/^OP_0X/.test(i), "Unknown opcode."), e(i.length === 7, "Unknown opcode.");
      const m = parseInt(i.substring(5), 16);
      return e((m & 255) === m, "Unknown opcode."), this.fromOp(m);
    }
    /**
     * Instantiate opcode from buffer reader.
     * @param {BufferReader} br
     * @returns {Opcode}
     */
    static fromReader(i) {
      const p = i.readU8(), m = f[p];
      if (m)
        return m;
      switch (p) {
        case g.OP_PUSHDATA1: {
          if (i.left() < 1)
            return n;
          const E = i.readU8();
          if (i.left() < E)
            return i.seek(i.left()), n;
          const v = i.readBytes(E);
          return new this(p, v);
        }
        case g.OP_PUSHDATA2: {
          if (i.left() < 2)
            return i.seek(i.left()), n;
          const E = i.readU16();
          if (i.left() < E)
            return i.seek(i.left()), n;
          const v = i.readBytes(E);
          return new this(p, v);
        }
        case g.OP_PUSHDATA4: {
          if (i.left() < 4)
            return i.seek(i.left()), n;
          const E = i.readU32();
          if (i.left() < E)
            return i.seek(i.left()), n;
          const v = i.readBytes(E);
          return new this(p, v);
        }
        default: {
          if (i.left() < p)
            return i.seek(i.left()), n;
          const E = i.readBytes(p);
          return new this(p, E);
        }
      }
    }
    /**
     * Instantiate opcode from serialized data.
     * @param {Buffer} data
     * @returns {Opcode}
     */
    static fromRaw(i) {
      return this.fromReader(c.read(i));
    }
    /**
     * Test whether an object an Opcode.
     * @param {Object} obj
     * @returns {Boolean}
     */
    static isOpcode(i) {
      return i instanceof u;
    }
  }
  function a(s) {
    return s <= 15 ? "0" + s.toString(16) : s.toString(16);
  }
  n = Object.freeze(new u(-1));
  for (let s = 0; s <= 255; s++) {
    if (s >= 1 && s <= 78) {
      f.push(null);
      continue;
    }
    const i = new u(s);
    f.push(Object.freeze(i));
  }
  return A0 = u, A0;
}
/*!
 * stack.js - stack object for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var O0, od;
function Ys() {
  if (od) return O0;
  od = 1;
  const e = nt, c = Yn(), d = Di();
  class w {
    /**
     * Create a stack.
     * @constructor
     * @param {Buffer[]?} items - Stack items.
     */
    constructor(f) {
      this.items = f || [];
    }
    /**
     * Get length.
     * @returns {Number}
     */
    get length() {
      return this.items.length;
    }
    /**
     * Set length.
     * @param {Number} value
     */
    set length(f) {
      this.items.length = f;
    }
    /**
     * Instantiate a value-only iterator.
     * @returns {StackIterator}
     */
    [Symbol.iterator]() {
      return this.items[Symbol.iterator]();
    }
    /**
     * Instantiate a value-only iterator.
     * @returns {StackIterator}
     */
    values() {
      return this.items.values();
    }
    /**
     * Instantiate a key and value iterator.
     * @returns {StackIterator}
     */
    entries() {
      return this.items.entries();
    }
    /**
     * Inspect the stack.
     * @returns {String} Human-readable stack.
     */
    inspect() {
      return `<Stack: ${this.toString()}>`;
    }
    /**
     * Convert the stack to a string.
     * @returns {String} Human-readable stack.
     */
    toString() {
      const f = [];
      for (const n of this.items)
        f.push(n.toString("hex"));
      return f.join(" ");
    }
    /**
     * Format the stack as bitcoind asm.
     * @param {Boolean?} decode - Attempt to decode hash types.
     * @returns {String} Human-readable script.
     */
    toASM(f) {
      const n = [];
      for (const u of this.items)
        n.push(c.toASM(u, f));
      return n.join(" ");
    }
    /**
     * Clone the stack.
     * @returns {Stack} Cloned stack.
     */
    clone() {
      return new this.constructor(this.items.slice());
    }
    /**
     * Clear the stack.
     * @returns {Stack}
     */
    clear() {
      return this.items.length = 0, this;
    }
    /**
     * Get a stack item by index.
     * @param {Number} index
     * @returns {Buffer|null}
     */
    get(f) {
      return f < 0 && (f += this.items.length), f < 0 || f >= this.items.length ? null : this.items[f];
    }
    /**
     * Pop a stack item.
     * @see Array#pop
     * @returns {Buffer|null}
     */
    pop() {
      return this.items.pop() || null;
    }
    /**
     * Shift a stack item.
     * @see Array#shift
     * @returns {Buffer|null}
     */
    shift() {
      return this.items.shift() || null;
    }
    /**
     * Remove an item.
     * @param {Number} index
     * @returns {Buffer}
     */
    remove(f) {
      if (f < 0 && (f += this.items.length), f < 0 || f >= this.items.length)
        return null;
      const n = this.items.splice(f, 1);
      return n.length === 0 ? null : n[0];
    }
    /**
     * Set stack item at index.
     * @param {Number} index
     * @param {Buffer} value
     * @returns {Buffer}
     */
    set(f, n) {
      return f < 0 && (f += this.items.length), e(k.isBuffer(n)), e(f >= 0 && f <= this.items.length), this.items[f] = n, this;
    }
    /**
     * Push item onto stack.
     * @see Array#push
     * @param {Buffer} item
     * @returns {Number} Stack size.
     */
    push(f) {
      return e(k.isBuffer(f)), this.items.push(f), this;
    }
    /**
     * Unshift item from stack.
     * @see Array#unshift
     * @param {Buffer} item
     * @returns {Number}
     */
    unshift(f) {
      return e(k.isBuffer(f)), this.items.unshift(f), this;
    }
    /**
     * Insert an item.
     * @param {Number} index
     * @param {Buffer} item
     * @returns {Buffer}
     */
    insert(f, n) {
      return f < 0 && (f += this.items.length), e(k.isBuffer(n)), e(f >= 0 && f <= this.items.length), this.items.splice(f, 0, n), this;
    }
    /**
     * Erase stack items.
     * @param {Number} start
     * @param {Number} end
     * @returns {Buffer[]}
     */
    erase(f, n) {
      f < 0 && (f = this.items.length + f), n < 0 && (n = this.items.length + n), this.items.splice(f, n - f);
    }
    /**
     * Swap stack values.
     * @param {Number} i1 - Index 1.
     * @param {Number} i2 - Index 2.
     */
    swap(f, n) {
      f < 0 && (f = this.items.length + f), n < 0 && (n = this.items.length + n);
      const u = this.items[f], a = this.items[n];
      this.items[f] = a, this.items[n] = u;
    }
    /*
     * Data
     */
    getData(f) {
      return this.get(f);
    }
    popData() {
      return this.pop();
    }
    shiftData() {
      return this.shift();
    }
    removeData(f) {
      return this.remove(f);
    }
    setData(f, n) {
      return this.set(f, n);
    }
    pushData(f) {
      return this.push(f);
    }
    unshiftData(f) {
      return this.unshift(f);
    }
    insertData(f, n) {
      return this.insert(f, n);
    }
    /*
     * Length
     */
    getLength(f) {
      const n = this.get(f);
      return n ? n.length : -1;
    }
    /*
     * String
     */
    getString(f, n) {
      const u = this.get(f);
      return u ? w.toString(u, n) : null;
    }
    popString(f) {
      const n = this.pop();
      return n ? w.toString(n, f) : null;
    }
    shiftString(f) {
      const n = this.shift();
      return n ? w.toString(n, f) : null;
    }
    removeString(f, n) {
      const u = this.remove(f);
      return u ? w.toString(u, n) : null;
    }
    setString(f, n, u) {
      return this.set(f, w.fromString(n, u));
    }
    pushString(f, n) {
      return this.push(w.fromString(f, n));
    }
    unshiftString(f, n) {
      return this.unshift(w.fromString(f, n));
    }
    insertString(f, n, u) {
      return this.insert(f, w.fromString(n, u));
    }
    /*
     * Num
     */
    getNum(f, n, u) {
      const a = this.get(f);
      return a ? w.toNum(a, n, u) : null;
    }
    popNum(f, n) {
      const u = this.pop();
      return u ? w.toNum(u, f, n) : null;
    }
    shiftNum(f, n) {
      const u = this.shift();
      return u ? w.toNum(u, f, n) : null;
    }
    removeNum(f, n, u) {
      const a = this.remove(f);
      return a ? w.toNum(a, n, u) : null;
    }
    setNum(f, n) {
      return this.set(f, w.fromNum(n));
    }
    pushNum(f) {
      return this.push(w.fromNum(f));
    }
    unshiftNum(f) {
      return this.unshift(w.fromNum(f));
    }
    insertNum(f, n) {
      return this.insert(f, w.fromNum(n));
    }
    /*
     * Int
     */
    getInt(f, n, u) {
      const a = this.get(f);
      return a ? w.toInt(a, n, u) : -1;
    }
    popInt(f, n) {
      const u = this.pop();
      return u ? w.toInt(u, f, n) : -1;
    }
    shiftInt(f, n) {
      const u = this.shift();
      return u ? w.toInt(u, f, n) : -1;
    }
    removeInt(f, n, u) {
      const a = this.remove(f);
      return a ? w.toInt(a, n, u) : -1;
    }
    setInt(f, n) {
      return this.set(f, w.fromInt(n));
    }
    pushInt(f) {
      return this.push(w.fromInt(f));
    }
    unshiftInt(f) {
      return this.unshift(w.fromInt(f));
    }
    insertInt(f, n) {
      return this.insert(f, w.fromInt(n));
    }
    /*
     * Bool
     */
    getBool(f) {
      const n = this.get(f);
      return n ? w.toBool(n) : !1;
    }
    popBool() {
      const f = this.pop();
      return f ? w.toBool(f) : !1;
    }
    shiftBool() {
      const f = this.shift();
      return f ? w.toBool(f) : !1;
    }
    removeBool(f) {
      const n = this.remove(f);
      return n ? w.toBool(n) : !1;
    }
    setBool(f, n) {
      return this.set(f, w.fromBool(n));
    }
    pushBool(f) {
      return this.push(w.fromBool(f));
    }
    unshiftBool(f) {
      return this.unshift(w.fromBool(f));
    }
    insertBool(f, n) {
      return this.insert(f, w.fromBool(n));
    }
    /**
     * Test an object to see if it is a Stack.
     * @param {Object} obj
     * @returns {Boolean}
     */
    static isStack(f) {
      return f instanceof w;
    }
    /*
     * Encoding
     */
    static toString(f, n) {
      return e(k.isBuffer(f)), f.toString(n || "utf8");
    }
    static fromString(f, n) {
      return e(typeof f == "string"), k.from(f, n || "utf8");
    }
    static toNum(f, n, u) {
      return d.decode(f, n, u);
    }
    static fromNum(f) {
      return e(d.isScriptNum(f)), f.encode();
    }
    static toInt(f, n, u) {
      return w.toNum(f, n, u).getInt();
    }
    static fromInt(f) {
      if (e(typeof f == "number"), f >= -1 && f <= 16)
        return c.small[f + 1];
      const n = d.fromNumber(f);
      return w.fromNum(n);
    }
    static toBool(f) {
      e(k.isBuffer(f));
      for (let n = 0; n < f.length; n++)
        if (f[n] !== 0)
          return !(n === f.length - 1 && f[n] === 128);
      return !1;
    }
    static fromBool(f) {
      return e(typeof f == "boolean"), w.fromInt(f ? 1 : 0);
    }
  }
  return O0 = w, O0;
}
var _0, ad;
function rb() {
  if (ad) return _0;
  ad = 1;
  class e {
    constructor(d) {
      this.sigchecks = d || 0, this.init();
    }
    init() {
      return this.sigchecks;
    }
  }
  return _0 = e, _0;
}
/*!
 * script.js - script interpreter for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var R0, fd;
function ii() {
  if (fd) return R0;
  fd = 1;
  const e = nt, c = kt, d = _h(), w = tb(), g = cr(), f = hn(), n = Or(), u = Fr(), a = Xt(), s = ln(), i = Yh(), p = Ys(), m = js(), E = Di(), v = Yn(), b = Ci(), h = rb(), o = v.opcodes, S = v.types, H = v.countBits, { encoding: j } = c, J = k.alloc(0), N = new h();
  class z {
    /**
     * Create a script.
     * @constructor
     * @param {Buffer|Array|Object} code
     */
    constructor(y) {
      this.raw = J, this.code = [], y && this.fromOptions(y);
    }
    /**
     * Get length.
     * @returns {Number}
     */
    get length() {
      return this.code.length;
    }
    /**
     * Set length.
     * @param {Number} value
     */
    set length(y) {
      this.code.length = y;
    }
    /**
     * Inject properties from options object.
     * @private
     * @param {Object} options
     */
    fromOptions(y) {
      if (e(y, "Script data is required."), k.isBuffer(y))
        return this.fromRaw(y);
      if (Array.isArray(y))
        return this.fromArray(y);
      if (y.raw) {
        if (!y.code)
          return this.fromRaw(y.raw);
        e(k.isBuffer(y.raw), "Raw must be a Buffer."), this.raw = y.raw;
      }
      if (y.code) {
        if (!y.raw)
          return this.fromArray(y.code);
        e(Array.isArray(y.code), "Code must be an array."), this.code = y.code;
      }
      return this;
    }
    /**
     * Insantiate script from options object.
     * @param {Object} options
     * @returns {Script}
     */
    static fromOptions(y) {
      return new this().fromOptions(y);
    }
    /**
     * Instantiate a value-only iterator.
     * @returns {ScriptIterator}
     */
    values() {
      return this.code.values();
    }
    /**
     * Instantiate a key and value iterator.
     * @returns {ScriptIterator}
     */
    entries() {
      return this.code.entries();
    }
    /**
     * Instantiate a value-only iterator.
     * @returns {ScriptIterator}
     */
    [Symbol.iterator]() {
      return this.code[Symbol.iterator]();
    }
    /**
     * Convert the script to an array of
     * Buffers (pushdatas) and Numbers
     * (opcodes).
     * @returns {Array}
     */
    toArray() {
      return this.code.slice();
    }
    /**
     * Inject properties from an array of
     * of buffers and numbers.
     * @private
     * @param {Array} code
     * @returns {Script}
     */
    fromArray(y) {
      e(Array.isArray(y)), this.clear();
      for (const Y of y)
        this.push(Y);
      return this.compile();
    }
    /**
     * Instantiate script from an array
     * of buffers and numbers.
     * @param {Array} code
     * @returns {Script}
     */
    static fromArray(y) {
      return new this().fromArray(y);
    }
    /**
     * Convert script to stack items.
     * @returns {Buffer[]}
     */
    toItems() {
      const y = [];
      for (const Y of this.code) {
        const he = Y.toPush();
        if (!he)
          throw new Error("Non-push opcode in script.");
        y.push(he);
      }
      return y;
    }
    /**
     * Inject data from stack items.
     * @private
     * @param {Buffer[]} items
     * @returns {Script}
     */
    fromItems(y) {
      e(Array.isArray(y)), this.clear();
      for (const Y of y)
        this.pushData(Y);
      return this.compile();
    }
    /**
     * Instantiate script from stack items.
     * @param {Buffer[]} items
     * @returns {Script}
     */
    static fromItems(y) {
      return new this().fromItems(y);
    }
    /**
     * Convert script to stack.
     * @returns {Stack}
     */
    toStack() {
      return new p(this.toItems());
    }
    /**
     * Inject data from stack.
     * @private
     * @param {Stack} stack
     * @returns {Script}
     */
    fromStack(y) {
      return this.fromItems(y.items);
    }
    /**
     * Instantiate script from stack.
     * @param {Stack} stack
     * @returns {Script}
     */
    static fromStack(y) {
      return new this().fromStack(y);
    }
    /**
     * Clone the script.
     * @returns {Script} Cloned script.
     */
    clone() {
      return new this.constructor().inject(this);
    }
    /**
     * Inject properties from script.
     * Used for cloning.
     * @private
     * @param {Script} script
     * @returns {Script}
     */
    inject(y) {
      return this.raw = y.raw, this.code = y.code.slice(), this;
    }
    /**
     * Test equality against script.
     * @param {Script} script
     * @returns {Boolean}
     */
    equals(y) {
      return e(z.isScript(y)), this.raw.equals(y.raw);
    }
    /**
     * Compare against another script.
     * @param {Script} script
     * @returns {Number}
     */
    compare(y) {
      return e(z.isScript(y)), this.raw.compare(y.raw);
    }
    /**
     * Clear the script.
     * @returns {Script}
     */
    clear() {
      return this.raw = J, this.code.length = 0, this;
    }
    /**
     * Inspect the script.
     * @returns {String} Human-readable script code.
     */
    inspect() {
      return `<Script: ${this.toString()}>`;
    }
    /**
     * Convert the script to a bitcoind test string.
     * @returns {String} Human-readable script code.
     */
    toString() {
      const y = [];
      for (const Y of this.code)
        y.push(Y.toFormat());
      return y.join(" ");
    }
    /**
     * Format the script as bitcoind asm.
     * @param {Boolean?} decode - Attempt to decode hash types.
     * @returns {String} Human-readable script.
     */
    toASM(y) {
      this.isNulldata() && (y = !1);
      const Y = [];
      for (const he of this.code)
        Y.push(he.toASM(y));
      return Y.join(" ");
    }
    /**
     * Re-encode the script internally. Useful if you
     * changed something manually in the `code` array.
     * @returns {Script}
     */
    compile() {
      if (this.code.length === 0)
        return this.clear();
      let y = 0;
      for (const he of this.code)
        y += he.getSize();
      const Y = c.write(y);
      for (const he of this.code)
        he.toWriter(Y);
      return this.raw = Y.render(), this;
    }
    /**
     * Write the script to a buffer writer.
     * @param {BufferWriter} bw
     */
    toWriter(y) {
      return y.writeVarBytes(this.raw), y;
    }
    /**
     * Encode the script to a Buffer. See {@link Script#encode}.
     * @param {String} enc - Encoding, either `'hex'` or `null`.
     * @returns {Buffer|String} Serialized script.
     */
    toRaw() {
      return this.raw;
    }
    /**
     * Convert script to a hex string.
     * @returns {String}
     */
    toJSON() {
      return this.toRaw().toString("hex");
    }
    /**
     * Inject properties from json object.
     * @private
     * @param {String} json
     */
    fromJSON(y) {
      return e(typeof y == "string", "Code must be a string."), this.fromRaw(k.from(y, "hex"));
    }
    /**
     * Instantiate script from a hex string.
     * @params {String} json
     * @returns {Script}
     */
    static fromJSON(y) {
      return new this().fromJSON(y);
    }
    /**
     * Get the script's "subscript" starting at a separator.
     * @param {Number} index - The last separator to sign/verify beyond.
     * @returns {Script} Subscript.
     */
    getSubscript(y) {
      if (y === 0)
        return this.clone();
      const Y = new z();
      for (let he = y; he < this.code.length; he++) {
        const be = this.code[he];
        if (be.value === -1)
          break;
        Y.code.push(be);
      }
      return Y.compile();
    }
    /**
     * Get the script's "subscript" starting at a separator.
     * Remove all OP_CODESEPARATORs if present. This bizarre
     * behavior is necessary for signing and verification when
     * code separators are present.
     * @returns {Script} Subscript.
     */
    removeSeparators() {
      let y = !1;
      for (const he of this.code) {
        if (he.value === -1)
          break;
        if (he.value === o.OP_CODESEPARATOR) {
          y = !0;
          break;
        }
      }
      if (!y)
        return this;
      const Y = new z();
      for (const he of this.code) {
        if (he.value === -1)
          break;
        he.value !== o.OP_CODESEPARATOR && Y.code.push(he);
      }
      return Y.compile();
    }
    /**
     * Get the value of the checkBits while calculated as little endian.
     * @param {Buffer} abkam - Stack depth of the dummy element.
     * @param {Number?} nKeysCount - Stack depth of the top pubkeys.
     * @returns {Number}
     */
    bitcalculator(y, Y) {
      let he = 0;
      const be = (Y + 7) / 8;
      for (let xe = 0; xe < be; xe++)
        he |= y[xe] << 8 * xe;
      return he;
    }
    /**
     * Execute and interpret the script.
     * @param {Stack} stack - Script execution stack.
     * @param {Number?} flags - Script standard flags.
     * @param {TX?} tx - Transaction being verified.
     * @param {Number?} index - Index of input being verified.
     * @param {Amount?} value - Previous output value.
     * @param {Number?} sigchecks
     * @throws {ScriptError} Will be thrown on VERIFY failures.
     */
    execute(y, Y, he, be, xe, Ie) {
      if (Y == null && (Y = z.flags.STANDARD_VERIFY_FLAGS), this.getSize() > a.MAX_SCRIPT_SIZE)
        throw new m("SCRIPT_SIZE");
      const ve = [], C = [];
      let I = 0, se = 0, t = 0, l, B = !1;
      Y & z.flags.VERIFY_MINIMALDATA && (B = !0);
      for (let U = 0; U < this.code.length; U++) {
        const G = this.code[U];
        if (G.value === -1)
          throw new m("BAD_OPCODE", G, U);
        if (G.data && G.data.length > a.MAX_SCRIPT_PUSH)
          throw new m("PUSH_SIZE", G, U);
        if (G.value > o.OP_16 && ++se > a.MAX_SCRIPT_OPS)
          throw new m("OP_COUNT", G, U);
        if (G.isDisabled(Y))
          throw new m("DISABLED_OPCODE", G, U);
        if (t && !G.isBranch()) {
          if (y.length + C.length > a.MAX_SCRIPT_STACK)
            throw new m("STACK_SIZE", G, U);
          continue;
        }
        if (G.data && 0 <= G.value <= o.OP_PUSHDATA4) {
          if (B && !G.isMinimal())
            throw new m("MINIMALDATA", G, U);
          if (y.push(G.data), y.length + C.length > a.MAX_SCRIPT_STACK)
            throw new m("STACK_SIZE", G, U);
          continue;
        }
        switch (G.value) {
          case o.OP_0: {
            y.pushInt(0);
            break;
          }
          case o.OP_1NEGATE: {
            y.pushInt(-1);
            break;
          }
          case o.OP_1:
          case o.OP_2:
          case o.OP_3:
          case o.OP_4:
          case o.OP_5:
          case o.OP_6:
          case o.OP_7:
          case o.OP_8:
          case o.OP_9:
          case o.OP_10:
          case o.OP_11:
          case o.OP_12:
          case o.OP_13:
          case o.OP_14:
          case o.OP_15:
          case o.OP_16: {
            y.pushInt(G.value - 80);
            break;
          }
          case o.OP_NOP:
            break;
          case o.OP_CHECKLOCKTIMEVERIFY: {
            if (!(Y & z.flags.VERIFY_CHECKLOCKTIMEVERIFY)) {
              if (Y & z.flags.VERIFY_DISCOURAGE_UPGRADABLE_NOPS)
                throw new m("DISCOURAGE_UPGRADABLE_NOPS", G, U);
              break;
            }
            if (!he)
              throw new m("UNKNOWN_ERROR", "No TX passed in.");
            if (y.length === 0)
              throw new m("INVALID_STACK_OPERATION", G, U);
            const T = y.getNum(-1, B, 5);
            if (T.isNeg())
              throw new m("NEGATIVE_LOCKTIME", G, U);
            const M = T.toDouble();
            if (!he.verifyLocktime(be, M))
              throw new m("UNSATISFIED_LOCKTIME", G, U);
            break;
          }
          case o.OP_CHECKSEQUENCEVERIFY: {
            if (!(Y & z.flags.VERIFY_CHECKSEQUENCEVERIFY)) {
              if (Y & z.flags.VERIFY_DISCOURAGE_UPGRADABLE_NOPS)
                throw new m("DISCOURAGE_UPGRADABLE_NOPS", G, U);
              break;
            }
            if (!he)
              throw new m("UNKNOWN_ERROR", "No TX passed in.");
            if (y.length === 0)
              throw new m("INVALID_STACK_OPERATION", G, U);
            const T = y.getNum(-1, B, 5);
            if (T.isNeg())
              throw new m("NEGATIVE_LOCKTIME", G, U);
            const M = T.toDouble();
            if (!he.verifySequence(be, M))
              throw new m("UNSATISFIED_LOCKTIME", G, U);
            break;
          }
          case o.OP_NOP1:
          case o.OP_NOP4:
          case o.OP_NOP5:
          case o.OP_NOP6:
          case o.OP_NOP7:
          case o.OP_NOP8:
          case o.OP_NOP9:
          case o.OP_NOP10: {
            if (Y & z.flags.VERIFY_DISCOURAGE_UPGRADABLE_NOPS)
              throw new m("DISCOURAGE_UPGRADABLE_NOPS", G, U);
            break;
          }
          case o.OP_IF:
          case o.OP_NOTIF: {
            let T = !1;
            if (!t) {
              if (y.length < 1)
                throw new m("UNBALANCED_CONDITIONAL", G, U);
              if (Y & z.flags.VERIFY_MINIMALIF) {
                const M = y.get(-1);
                if (M.length > 1)
                  throw new m("MINIMALIF");
                if (M.length === 1 && M[0] !== 1)
                  throw new m("MINIMALIF");
              }
              T = y.getBool(-1), G.value === o.OP_NOTIF && (T = !T), y.pop();
            }
            ve.push(T), T || (t += 1);
            break;
          }
          case o.OP_ELSE: {
            if (ve.length === 0)
              throw new m("UNBALANCED_CONDITIONAL", G, U);
            ve[ve.length - 1] = !ve[ve.length - 1], ve[ve.length - 1] ? t -= 1 : t += 1;
            break;
          }
          case o.OP_ENDIF: {
            if (ve.length === 0)
              throw new m("UNBALANCED_CONDITIONAL", G, U);
            ve.pop() || (t -= 1);
            break;
          }
          case o.OP_VERIFY: {
            if (y.length === 0)
              throw new m("INVALID_STACK_OPERATION", G, U);
            if (!y.getBool(-1))
              throw new m("VERIFY", G, U);
            y.pop();
            break;
          }
          case o.OP_RETURN:
            throw new m("OP_RETURN", G, U);
          case o.OP_TOALTSTACK: {
            if (y.length === 0)
              throw new m("INVALID_STACK_OPERATION", G, U);
            C.push(y.pop());
            break;
          }
          case o.OP_FROMALTSTACK: {
            if (C.length === 0)
              throw new m("INVALID_ALTSTACK_OPERATION", G, U);
            y.push(C.pop());
            break;
          }
          case o.OP_2DROP: {
            if (y.length < 2)
              throw new m("INVALID_STACK_OPERATION", G, U);
            y.pop(), y.pop();
            break;
          }
          case o.OP_2DUP: {
            if (y.length < 2)
              throw new m("INVALID_STACK_OPERATION", G, U);
            const T = y.get(-2), M = y.get(-1);
            y.push(T), y.push(M);
            break;
          }
          case o.OP_3DUP: {
            if (y.length < 3)
              throw new m("INVALID_STACK_OPERATION", G, U);
            const T = y.get(-3), M = y.get(-2), $ = y.get(-1);
            y.push(T), y.push(M), y.push($);
            break;
          }
          case o.OP_2OVER: {
            if (y.length < 4)
              throw new m("INVALID_STACK_OPERATION", G, U);
            const T = y.get(-4), M = y.get(-3);
            y.push(T), y.push(M);
            break;
          }
          case o.OP_2ROT: {
            if (y.length < 6)
              throw new m("INVALID_STACK_OPERATION", G, U);
            const T = y.get(-6), M = y.get(-5);
            y.erase(-6, -4), y.push(T), y.push(M);
            break;
          }
          case o.OP_2SWAP: {
            if (y.length < 4)
              throw new m("INVALID_STACK_OPERATION", G, U);
            y.swap(-4, -2), y.swap(-3, -1);
            break;
          }
          case o.OP_IFDUP: {
            if (y.length === 0)
              throw new m("INVALID_STACK_OPERATION", G, U);
            if (y.getBool(-1)) {
              const T = y.get(-1);
              y.push(T);
            }
            break;
          }
          case o.OP_DEPTH: {
            y.pushInt(y.length);
            break;
          }
          case o.OP_DROP: {
            if (y.length === 0)
              throw new m("INVALID_STACK_OPERATION", G, U);
            y.pop();
            break;
          }
          case o.OP_DUP: {
            if (y.length === 0)
              throw new m("INVALID_STACK_OPERATION", G, U);
            y.push(y.get(-1));
            break;
          }
          case o.OP_NIP: {
            if (y.length < 2)
              throw new m("INVALID_STACK_OPERATION", G, U);
            y.remove(-2);
            break;
          }
          case o.OP_OVER: {
            if (y.length < 2)
              throw new m("INVALID_STACK_OPERATION", G, U);
            y.push(y.get(-2));
            break;
          }
          case o.OP_PICK:
          case o.OP_ROLL: {
            if (y.length < 2)
              throw new m("INVALID_STACK_OPERATION", G, U);
            const T = y.getInt(-1, B, 4);
            if (y.pop(), T < 0 || T >= y.length)
              throw new m("INVALID_STACK_OPERATION", G, U);
            const M = y.get(-T - 1);
            G.value === o.OP_ROLL && y.remove(-T - 1), y.push(M);
            break;
          }
          case o.OP_ROT: {
            if (y.length < 3)
              throw new m("INVALID_STACK_OPERATION", G, U);
            y.swap(-3, -2), y.swap(-2, -1);
            break;
          }
          case o.OP_SWAP: {
            if (y.length < 2)
              throw new m("INVALID_STACK_OPERATION", G, U);
            y.swap(-2, -1);
            break;
          }
          case o.OP_TUCK: {
            if (y.length < 2)
              throw new m("INVALID_STACK_OPERATION", G, U);
            y.insert(-2, y.get(-1));
            break;
          }
          case o.OP_SIZE: {
            if (y.length < 1)
              throw new m("INVALID_STACK_OPERATION", G, U);
            y.pushInt(y.get(-1).length);
            break;
          }
          case o.OP_EQUAL:
          case o.OP_EQUALVERIFY: {
            if (y.length < 2)
              throw new m("INVALID_STACK_OPERATION", G, U);
            const T = y.get(-2), M = y.get(-1), $ = T.equals(M);
            if (y.pop(), y.pop(), y.pushBool($), G.value === o.OP_EQUALVERIFY) {
              if (!$)
                throw new m("EQUALVERIFY", G, U);
              y.pop();
            }
            break;
          }
          case o.OP_1ADD:
          case o.OP_1SUB:
          case o.OP_NEGATE:
          case o.OP_ABS:
          case o.OP_NOT:
          case o.OP_0NOTEQUAL: {
            if (y.length < 1)
              throw new m("INVALID_STACK_OPERATION", G, U);
            let T = y.getNum(-1, B, 4), M;
            switch (G.value) {
              case o.OP_1ADD:
                T.iaddn(1);
                break;
              case o.OP_1SUB:
                T.isubn(1);
                break;
              case o.OP_NEGATE:
                T.ineg();
                break;
              case o.OP_ABS:
                T.iabs();
                break;
              case o.OP_NOT:
                M = T.isZero(), T = E.fromBool(M);
                break;
              case o.OP_0NOTEQUAL:
                M = !T.isZero(), T = E.fromBool(M);
                break;
              default:
                e(!1, "Fatal script error.");
                break;
            }
            y.pop(), y.pushNum(T);
            break;
          }
          case o.OP_ADD:
          case o.OP_SUB:
          case o.OP_DIV:
          case o.OP_MOD:
          case o.OP_BOOLAND:
          case o.OP_BOOLOR:
          case o.OP_NUMEQUAL:
          case o.OP_NUMEQUALVERIFY:
          case o.OP_NUMNOTEQUAL:
          case o.OP_LESSTHAN:
          case o.OP_GREATERTHAN:
          case o.OP_LESSTHANOREQUAL:
          case o.OP_GREATERTHANOREQUAL:
          case o.OP_MIN:
          case o.OP_MAX: {
            if (y.length < 2)
              throw new m("INVALID_STACK_OPERATION", G, U);
            const T = y.getNum(-2, B, 4), M = y.getNum(-1, B, 4);
            let $, r;
            switch (G.value) {
              case o.OP_ADD:
                $ = T.iadd(M);
                break;
              case o.OP_SUB:
                $ = T.isub(M);
                break;
              case o.OP_DIV:
                if (M.isZero())
                  throw new m("DIV_BY_ZERO", G, U);
                $ = T.div(M);
                break;
              case o.OP_MOD:
                if (M.isZero())
                  throw new m("MOD_BY_ZERO", G, U);
                $ = T.mod(M);
                break;
              case o.OP_BOOLAND:
                r = T.toBool() && M.toBool(), $ = E.fromBool(r);
                break;
              case o.OP_BOOLOR:
                r = T.toBool() || M.toBool(), $ = E.fromBool(r);
                break;
              case o.OP_NUMEQUAL:
                r = T.eq(M), $ = E.fromBool(r);
                break;
              case o.OP_NUMEQUALVERIFY:
                r = T.eq(M), $ = E.fromBool(r);
                break;
              case o.OP_NUMNOTEQUAL:
                r = !T.eq(M), $ = E.fromBool(r);
                break;
              case o.OP_LESSTHAN:
                r = T.lt(M), $ = E.fromBool(r);
                break;
              case o.OP_GREATERTHAN:
                r = T.gt(M), $ = E.fromBool(r);
                break;
              case o.OP_LESSTHANOREQUAL:
                r = T.lte(M), $ = E.fromBool(r);
                break;
              case o.OP_GREATERTHANOREQUAL:
                r = T.gte(M), $ = E.fromBool(r);
                break;
              case o.OP_MIN:
                $ = E.min(T, M);
                break;
              case o.OP_MAX:
                $ = E.max(T, M);
                break;
              default:
                e(!1, "Fatal script error.");
                break;
            }
            if (y.pop(), y.pop(), y.pushNum($), G.value === o.OP_NUMEQUALVERIFY) {
              if (!y.getBool(-1))
                throw new m("NUMEQUALVERIFY", G, U);
              y.pop();
            }
            break;
          }
          case o.OP_WITHIN: {
            if (y.length < 3)
              throw new m("INVALID_STACK_OPERATION", G, U);
            const T = y.getNum(-3, B, 4), M = y.getNum(-2, B, 4), $ = y.getNum(-1, B, 4), r = M.lte(T) && T.lt($);
            y.pop(), y.pop(), y.pop(), y.pushBool(r);
            break;
          }
          case o.OP_RIPEMD160: {
            if (y.length === 0)
              throw new m("INVALID_STACK_OPERATION", G, U);
            y.push(d.digest(y.pop()));
            break;
          }
          case o.OP_SHA1: {
            if (y.length === 0)
              throw new m("INVALID_STACK_OPERATION", G, U);
            y.push(w.digest(y.pop()));
            break;
          }
          case o.OP_SHA256: {
            if (y.length === 0)
              throw new m("INVALID_STACK_OPERATION", G, U);
            y.push(g.digest(y.pop()));
            break;
          }
          case o.OP_HASH160: {
            if (y.length === 0)
              throw new m("INVALID_STACK_OPERATION", G, U);
            y.push(f.digest(y.pop()));
            break;
          }
          case o.OP_HASH256: {
            if (y.length === 0)
              throw new m("INVALID_STACK_OPERATION", G, U);
            y.push(n.digest(y.pop()));
            break;
          }
          case o.OP_CODESEPARATOR: {
            I = U + 1;
            break;
          }
          case o.OP_CHECKSIG:
          case o.OP_CHECKSIGVERIFY: {
            if (!he)
              throw new m("UNKNOWN_ERROR", "No TX passed in.");
            if (y.length < 2)
              throw new m("INVALID_STACK_OPERATION", G, U);
            const T = y.get(-2), M = y.get(-1), $ = this.getSubscript(I);
            (!(Y & z.flags.VERIFY_SIGHASH_FORKID) || !(T[T.length - 1] & z.hashType.SIGHASH_FORKID)) && $.findAndDelete(T), R(T, Y), q(M, Y);
            let r = !1;
            if (T.length > 0) {
              const x = T[T.length - 1], O = he.signatureHash(
                be,
                $,
                xe,
                x,
                Y
              );
              r = Q(O, T.slice(0, -1), M, Y), N.sigchecks += 1, N.sigchecks;
            }
            if (!r && Y & z.flags.VERIFY_NULLFAIL && T.length !== 0)
              throw new m("NULLFAIL", G, U);
            if (y.pop(), y.pop(), y.pushBool(r), G.value === o.OP_CHECKSIGVERIFY) {
              if (!r)
                throw new m("CHECKSIGVERIFY", G, U);
              y.pop();
            }
            break;
          }
          case o.OP_CHECKDATASIG:
          case o.OP_CHECKDATASIGVERIFY: {
            if (y.length < 3)
              throw new m("INVALID_STACK_OPERATION", G, U);
            const T = y.get(-3), M = y.get(-2), $ = y.get(-1);
            ue(T, Y), q($, Y);
            let r = !1;
            if (T.length > 0) {
              const x = g.digest(M);
              r = Q(x, T, $, Y), N.sigchecks += 1, N.sigchecks;
            }
            if (!r && Y & z.flags.VERIFY_NULLFAIL && T.length !== 0)
              throw new m("NULLFAIL", G, U);
            if (y.pop(), y.pop(), y.pop(), y.pushBool(r), G.value === o.OP_CHECKDATASIGVERIFY) {
              if (!r)
                throw new m("CHECKDATASIGVERIFY", G, U);
              y.pop();
            }
            break;
          }
          case o.OP_CHECKMULTISIG:
          case o.OP_CHECKMULTISIGVERIFY: {
            if (!he)
              throw new m("UNKNOWN_ERROR", "No TX passed in.");
            let T = 1, M = 0, $, r;
            if (y.length < T)
              throw new m("INVALID_STACK_OPERATION", G, U);
            let x = y.getInt(-T, B, 4), O = x + 2, L, X;
            if (x < 0 || x > a.MAX_MULTISIG_PUBKEYS)
              throw new m("PUBKEY_COUNT", G, U);
            if (se += x, se > a.MAX_SCRIPT_OPS)
              throw new m("OP_COUNT", G, U);
            if (T += 1, $ = T, M = $ + x, L = T, T += x, y.length < M)
              throw new m("INVALID_STACK_OPERATION", G, U);
            let P = y.getInt(-M, B, 4);
            if (P < 0 || P > x)
              throw new m("SIG_COUNT", G, U);
            r = M + 1;
            const K = r + P;
            if (y.length < K)
              throw new m("INVALID_STACK_OPERATION", G, U);
            T += 1, X = T, T += P;
            const re = this.getSubscript(I);
            let ce = !0;
            if (Y & z.flags.VERIFY_SCHNORR_MULTISIG && y.get(-K).length !== 0) {
              if (e(a.MAX_MULTISIG_PUBKEYS < 32), x > 32)
                throw new m("INVALID_BITFIELD_SIZE", G, U);
              const le = Math.floor((x + 7) / 8), me = y.get(-K);
              if (me.length !== le)
                throw new m("BITFIELD_SIZE", G, U);
              l = this.bitcalculator(me, x);
              const ne = (1 << x) - 1, W = H(l);
              if ((l & ne) !== l)
                throw new m("BIT_RANGE", G, U);
              if (W !== P)
                throw new m("INVALID_BIT_COUNT", G, U);
              const te = $ + x - 1, pe = r + P - 1;
              let Ee = 0;
              for (let Ae = 0; Ae < P; Ae++, Ee++) {
                if (l >> Ee === 0)
                  throw new m("INVALID_BIT_RANGE", G, U);
                for (; (l >> Ee & 1) === 0; )
                  Ee++;
                if (Ee >= x)
                  throw new m("PUBKEY_COUNT", G, U);
                const Oe = y.get(-pe + Ae), Be = y.get(-te + Ee);
                if (Oe) {
                  if (V(Oe, Y), q(Be, Y), Oe.length > 0) {
                    const ke = Oe[Oe.length - 1], Ne = he.signatureHash(
                      be,
                      re,
                      xe,
                      ke,
                      Y
                    );
                    ce = Q(Ne, Oe.slice(0, -1), Be, Y), N.sigchecks += 1, N.sigchecks;
                  }
                  for (; T > 1; ) {
                    if (!ce && Y & z.flags.VERIFY_NULLFAIL && O === 0 && y.get(-1).length !== 0)
                      throw new m("NULLFAIL", G, U);
                    O > 0 && (O -= 1), y.pop(), T -= 1;
                  }
                }
              }
              if (l >> Ee !== 0)
                throw new m("INVALID_BIT_COUNT", G, U);
              y.pop(), y.pushBool(ce);
            } else {
              for (let le = 0; le < P; le++) {
                const me = y.get(-r - le);
                (!(Y & z.flags.VERIFY_SIGHASH_FORKID) || !(me[me.length - 1] & z.hashType.SIGHASH_FORKID)) && re.findAndDelete(me, Y);
              }
              for (; ce && P > 0; ) {
                const le = y.get(-X), me = y.get(-L);
                if (fe(le, Y), q(me, Y), le.length > 0) {
                  const ne = le[le.length - 1], W = he.signatureHash(
                    be,
                    re,
                    xe,
                    ne,
                    Y
                  );
                  Z(W, le, me) && (X += 1, P -= 1);
                }
                L += 1, x -= 1, P > x && (ce = !1);
              }
              for (; T > 1; ) {
                if (!ce && Y & z.flags.VERIFY_NULLFAIL && O === 0 && y.get(-1).length !== 0)
                  throw new m("NULLFAIL", G, U);
                O > 0 && (O -= 1), y.pop(), T -= 1;
              }
              if (y.length < 1)
                throw new m("INVALID_STACK_OPERATION", G, U);
              if (y.pop(), y.pushBool(ce), G.value === o.OP_CHECKMULTISIGVERIFY) {
                if (!ce)
                  throw new m("CHECKMULTISIGVERIFY", G, U);
                y.pop();
              }
            }
            break;
          }
          //
          // Byte string operations
          //
          case o.OP_CAT: {
            if (y.length < 2)
              throw new m("INVALID_STACK_OPERATION", G, U);
            const T = y.get(-2), M = y.get(-1);
            if (T.length + M.length > a.MAX_SCRIPT_PUSH)
              throw new m("PUSH_SIZE", G, U);
            y.pop(), y.pop(), y.push(k.concat([T, M]));
            break;
          }
          case o.OP_SPLIT: {
            if (y.length < 2)
              throw new m("INVALID_STACK_OPERATION", G, U);
            const T = y.get(-2), M = y.getInt(-1, B, 4);
            if (M < 0 || M > T.length)
              throw new m("INVALID_SPLIT_RANGE", G, U);
            const $ = T.slice(0, M), r = T.slice(M);
            y.set(-2, $), y.set(-1, r);
            break;
          }
          case o.OP_REVERSEBYTES: {
            if (y.length < 1)
              throw new m("INVALID_STACK_OPERATION", G, U);
            y.get(-1).reverse();
            break;
          }
          //
          // Bitwise logic
          //
          case o.OP_AND:
          case o.OP_OR:
          case o.OP_XOR: {
            if (y.length < 2)
              throw new m("INVALID_STACK_OPERATION", G, U);
            const T = y.get(-2), M = y.get(-1);
            if (T.length !== M.length)
              throw new m("INVALID_OPERAND_SIZE", G, U);
            const $ = k.alloc(T.length);
            switch (G.value) {
              case o.OP_AND:
                for (let r = 0; r < T.length; r++)
                  $[r] = T[r] & M[r];
                break;
              case o.OP_OR:
                for (let r = 0; r < T.length; r++)
                  $[r] = T[r] | M[r];
                break;
              case o.OP_XOR:
                for (let r = 0; r < T.length; r++)
                  $[r] = T[r] ^ M[r];
                break;
            }
            y.pop(), y.pop(), y.push($);
            break;
          }
          //
          // Conversion operations
          //
          case o.OP_NUM2BIN: {
            if (y.length < 2)
              throw new m("INVALID_STACK_OPERATION", G, U);
            const T = y.getInt(-1, B, 4);
            if (T < 0 || T > a.MAX_SCRIPT_PUSH)
              throw new m("PUSH_SIZE", G, U);
            y.pop();
            const M = y.get(-1), $ = E.toMinimal(k.from(M));
            if ($.length > T)
              throw new m("IMPOSSIBLE_ENCODING", G, U);
            if ($.length === T) {
              y.pop(), y.push($);
              break;
            }
            const r = k.alloc(T);
            $.copy(r);
            let x = 0;
            $.length > 0 && (x = $[$.length - 1] & 128, r[$.length - 1] &= 127), r[T - 1] = x, y.pop(), y.push(r);
            break;
          }
          case o.OP_BIN2NUM: {
            if (y.length < 1)
              throw new m("INVALID_STACK_OPERATION", G, U);
            const T = y.get(-1), M = E.toMinimal(k.from(T));
            if (y.pop(), y.push(M), !E.isMinimal(M) || M.length > 4)
              throw new m("INVALID_NUMBER_RANGE", G, U);
            break;
          }
          default:
            throw new m("BAD_OPCODE", G, U);
        }
      }
      if (y.length + C.length > a.MAX_SCRIPT_STACK)
        throw new m("STACK_SIZE");
      if (ve.length !== 0)
        throw new m("UNBALANCED_CONDITIONAL");
    }
    /**
     * Remove all matched data elements from
     * a script's code (used to remove signatures
     * before verification). Note that this
     * compares and removes data on the _byte level_.
     * It also reserializes the data to a single
     * script with minimaldata encoding beforehand.
     * A signature will _not_ be removed if it is
     * not minimaldata.
     * @see https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2014-November/006878.html
     * @see https://test.webbtc.com/tx/19aa42fee0fa57c45d3b16488198b27caaacc4ff5794510d0c17f173f05587ff
     * @param {Buffer} data - Data element to match against.
     * @returns {Number} Total.
     */
    findAndDelete(y) {
      const Y = i.fromPush(y);
      if (this.raw.length < Y.getSize())
        return 0;
      let he = !1;
      for (const Ie of this.code) {
        if (Ie.value === -1)
          break;
        if (Ie.equals(Y)) {
          he = !0;
          break;
        }
      }
      if (!he)
        return 0;
      const be = [];
      let xe = 0;
      for (const Ie of this.code) {
        if (Ie.value === -1)
          break;
        if (Ie.equals(Y)) {
          xe += 1;
          continue;
        }
        be.push(Ie);
      }
      return this.code = be, this.compile(), xe;
    }
    /**
     * Find a data element in a script.
     * @param {Buffer} data - Data element to match against.
     * @returns {Number} Index (`-1` if not present).
     */
    indexOf(y) {
      for (let Y = 0; Y < this.code.length; Y++) {
        const he = this.code[Y];
        if (he.value === -1)
          break;
        if (he.data && he.data.equals(y))
          return Y;
      }
      return -1;
    }
    /**
     * Test a script to see if it is likely
     * to be script code (no weird opcodes).
     * @param {Number?} flags - Script standard flags.
     * @returns {Boolean}
     */
    isCode(y) {
      y == null && (y = z.flags.STANDARD_VERIFY_FLAGS);
      for (const Y of this.code) {
        if (Y.value === -1 || Y.isDisabled(y))
          return !1;
        switch (Y.value) {
          case o.OP_RESERVED:
          case o.OP_NOP:
          case o.OP_VER:
          case o.OP_VERIF:
          case o.OP_VERNOTIF:
          case o.OP_RESERVED1:
          case o.OP_RESERVED2:
          case o.OP_NOP1:
            return !1;
        }
        if (Y.value > o.OP_CHECKSEQUENCEVERIFY)
          return !1;
      }
      return !0;
    }
    /**
     * Inject properties from a pay-to-pubkey script.
     * @private
     * @param {Buffer} key
     */
    fromPubkey(y) {
      return e(k.isBuffer(y) && (y.length === 33 || y.length === 65)), this.raw = k.allocUnsafe(1 + y.length + 1), this.raw[0] = y.length, y.copy(this.raw, 1), this.raw[1 + y.length] = o.OP_CHECKSIG, y = this.raw.slice(1, 1 + y.length), this.code.length = 0, this.code.push(i.fromPush(y)), this.code.push(i.fromOp(o.OP_CHECKSIG)), this;
    }
    /**
     * Create a pay-to-pubkey script.
     * @param {Buffer} key
     * @returns {Script}
     */
    static fromPubkey(y) {
      return new this().fromPubkey(y);
    }
    /**
     * Inject properties from a pay-to-pubkeyhash script.
     * @private
     * @param {Buffer} hash
     */
    fromPubkeyhash(y) {
      return e(k.isBuffer(y) && y.length === 20), this.raw = k.allocUnsafe(25), this.raw[0] = o.OP_DUP, this.raw[1] = o.OP_HASH160, this.raw[2] = 20, y.copy(this.raw, 3), this.raw[23] = o.OP_EQUALVERIFY, this.raw[24] = o.OP_CHECKSIG, y = this.raw.slice(3, 23), this.code.length = 0, this.code.push(i.fromOp(o.OP_DUP)), this.code.push(i.fromOp(o.OP_HASH160)), this.code.push(i.fromPush(y)), this.code.push(i.fromOp(o.OP_EQUALVERIFY)), this.code.push(i.fromOp(o.OP_CHECKSIG)), this;
    }
    /**
     * Create a pay-to-pubkeyhash script.
     * @param {Buffer} hash
     * @returns {Script}
     */
    static fromPubkeyhash(y) {
      return new this().fromPubkeyhash(y);
    }
    /**
     * Inject properties from pay-to-multisig script.
     * @private
     * @param {Number} m
     * @param {Number} n
     * @param {Buffer[]} keys
     */
    fromMultisig(y, Y, he) {
      e((y & 255) === y && (Y & 255) === Y), e(Array.isArray(he)), e(he.length === Y, "`n` keys are required for multisig."), e(y >= 1 && y <= Y), e(Y >= 1 && Y <= 15), this.clear(), this.pushSmall(y);
      for (const be of A(he))
        this.pushData(be);
      return this.pushSmall(Y), this.pushOp(o.OP_CHECKMULTISIG), this.compile();
    }
    /**
     * Create a pay-to-multisig script.
     * @param {Number} m
     * @param {Number} n
     * @param {Buffer[]} keys
     * @returns {Script}
     */
    static fromMultisig(y, Y, he) {
      return new this().fromMultisig(y, Y, he);
    }
    /**
     * Inject properties from a pay-to-scripthash script.
     * @private
     * @param {Buffer} hash
     */
    fromScripthash(y) {
      return e(k.isBuffer(y) && y.length === 20), this.raw = k.allocUnsafe(23), this.raw[0] = o.OP_HASH160, this.raw[1] = 20, y.copy(this.raw, 2), this.raw[22] = o.OP_EQUAL, y = this.raw.slice(2, 22), this.code.length = 0, this.code.push(i.fromOp(o.OP_HASH160)), this.code.push(i.fromPush(y)), this.code.push(i.fromOp(o.OP_EQUAL)), this;
    }
    /**
     * Create a pay-to-scripthash script.
     * @param {Buffer} hash
     * @returns {Script}
     */
    static fromScripthash(y) {
      return new this().fromScripthash(y);
    }
    /**
     * Inject properties from a nulldata/opreturn script.
     * @private
     * @param {Buffer} flags
     */
    fromNulldata(y) {
      return e(k.isBuffer(y)), e(y.length <= s.MAX_OP_RETURN, "Nulldata too large."), this.clear(), this.pushOp(o.OP_RETURN), this.pushData(y), this.compile();
    }
    /**
     * Create a nulldata/opreturn script.
     * @param {Buffer} flags
     * @returns {Script}
     */
    static fromNulldata(y) {
      return new this().fromNulldata(y);
    }
    /**
     * Inject properties from an address.
     * @private
     * @param {Address|AddressString} address
     */
    fromAddress(y) {
      if (typeof y == "string" && (y = b.fromString(y)), e(y instanceof b, "Not an address."), y.isPubkeyhash())
        return this.fromPubkeyhash(y.hash);
      if (y.isScripthash())
        return this.fromScripthash(y.hash);
      throw new Error("Unknown address type.");
    }
    /**
     * Create an output script from an address.
     * @param {Address|AddressString} address
     * @returns {Script}
     */
    static fromAddress(y) {
      return new this().fromAddress(y);
    }
    /**
     * Grab and deserialize the redeem script.
     * @returns {Script|null} Redeem script.
     */
    getRedeem() {
      let y = null;
      for (const Y of this.code) {
        if (Y.value === -1 || Y.value > o.OP_16)
          return null;
        y = Y.data;
      }
      return y ? z.fromRaw(y) : null;
    }
    /**
     * Get the standard script type.
     * @returns {ScriptType}
     */
    getType() {
      return this.isPubkey() ? S.PUBKEY : this.isPubkeyhash() ? S.PUBKEYHASH : this.isScripthash() ? S.SCRIPTHASH : this.isMultisig() ? S.MULTISIG : this.isNulldata() ? S.NULLDATA : S.NONSTANDARD;
    }
    /**
     * Test whether a script is of an unknown/non-standard type.
     * @returns {Boolean}
     */
    isUnknown() {
      return this.getType() === S.NONSTANDARD;
    }
    /**
     * Test whether the script is standard by policy standards.
     * @returns {Boolean}
     */
    isStandard() {
      const [y, Y] = this.getMultisig();
      return y !== -1 ? !(Y < 1 || Y > 3 || y < 1 || y > Y) : this.isNulldata() ? this.raw.length <= s.MAX_OP_RETURN_BYTES : this.getType() !== S.NONSTANDARD;
    }
    /**
     * Calculate the size of the script
     * excluding the varint size bytes.
     * @returns {Number}
     */
    getSize() {
      return this.raw.length;
    }
    /**
     * Calculate the size of the script
     * including the varint size bytes.
     * @returns {Number}
     */
    getVarSize() {
      return j.sizeVarBytes(this.raw);
    }
    /**
     * "Guess" the address of the input script.
     * This method is not 100% reliable.
     * @returns {Address|null}
     */
    getInputAddress() {
      return b.fromInputScript(this);
    }
    /**
     * Get the address of the script if present. Note that
     * pubkey and multisig scripts will be treated as though
     * they are pubkeyhash and scripthashes respectively.
     * @returns {Address|null}
     */
    getAddress() {
      return b.fromScript(this);
    }
    /**
     * Get the hash160 of the raw script.
     * @param {String?} enc
     * @returns {Hash}
     */
    hash160(y) {
      let Y = f.digest(this.toRaw());
      return y === "hex" && (Y = Y.toString("hex")), Y;
    }
    /**
     * Get the sha256 of the raw script.
     * @param {String?} enc
     * @returns {Hash}
     */
    sha256(y) {
      let Y = g.digest(this.toRaw());
      return y === "hex" && (Y = Y.toString("hex")), Y;
    }
    /**
     * Test whether the output script is pay-to-pubkey.
     * @param {Boolean} [minimal=false] - Minimaldata only.
     * @returns {Boolean}
     */
    isPubkey(y) {
      if (y)
        return this.raw.length >= 35 && (this.raw[0] === 33 || this.raw[0] === 65) && this.raw[0] + 2 === this.raw.length && this.raw[this.raw.length - 1] === o.OP_CHECKSIG;
      if (this.code.length !== 2)
        return !1;
      const Y = this.getLength(0);
      return (Y === 33 || Y === 65) && this.getOp(1) === o.OP_CHECKSIG;
    }
    /**
     * Get P2PK key if present.
     * @param {Boolean} [minimal=false] - Minimaldata only.
     * @returns {Buffer|null}
     */
    getPubkey(y) {
      return this.isPubkey(y) ? y ? this.raw.slice(1, 1 + this.raw[0]) : this.getData(0) : null;
    }
    /**
     * Test whether the output script is pay-to-pubkeyhash.
     * @param {Boolean} [minimal=false] - Minimaldata only.
     * @returns {Boolean}
     */
    isPubkeyhash(y) {
      return y || this.raw.length === 25 ? this.raw.length === 25 && this.raw[0] === o.OP_DUP && this.raw[1] === o.OP_HASH160 && this.raw[2] === 20 && this.raw[23] === o.OP_EQUALVERIFY && this.raw[24] === o.OP_CHECKSIG : this.code.length !== 5 ? !1 : this.getOp(0) === o.OP_DUP && this.getOp(1) === o.OP_HASH160 && this.getLength(2) === 20 && this.getOp(3) === o.OP_EQUALVERIFY && this.getOp(4) === o.OP_CHECKSIG;
    }
    /**
     * Get P2PKH hash if present.
     * @param {Boolean} [minimal=false] - Minimaldata only.
     * @returns {Buffer|null}
     */
    getPubkeyhash(y) {
      return this.isPubkeyhash(y) ? y ? this.raw.slice(3, 23) : this.getData(2) : null;
    }
    /**
       * Test whether the output script is pay-to-multisig.
       * @param {Boolean} [minimal=true] - Minimaldata only.
       * @returns {Boolean}
       */
    isMultisig(y) {
      if (this.code.length < 4 || this.code.length > 19 || this.getOp(-1) !== o.OP_CHECKMULTISIG)
        return !1;
      const Y = this.getSmall(0);
      if (Y < 1)
        return !1;
      const he = this.getSmall(-2);
      if (he < 1 || Y > he || this.code.length !== he + 3)
        return !1;
      for (let be = 1; be < he + 1; be++) {
        const xe = this.code[be], Ie = xe.toLength();
        if (Ie !== 33 && Ie !== 65 || y && !xe.isMinimal())
          return !1;
      }
      return !0;
    }
    /**
     * Get multisig m and n values if present.
     * @param {Boolean} [minimal=false] - Minimaldata only.
     * @returns {Array} [m, n]
     */
    getMultisig(y) {
      return this.isMultisig(y) ? [this.getSmall(0), this.getSmall(-2)] : [-1, -1];
    }
    /**
     * Test whether the output script is pay-to-scripthash. Note that
     * bitcoin itself requires scripthashes to be in strict minimaldata
     * encoding. Using `OP_HASH160 OP_PUSHDATA1 [hash] OP_EQUAL` will
     * _not_ be recognized as a scripthash.
     * @returns {Boolean}
     */
    isScripthash() {
      return this.raw.length === 23 && this.raw[0] === o.OP_HASH160 && this.raw[1] === 20 && this.raw[22] === o.OP_EQUAL;
    }
    /**
     * Get P2SH hash if present.
     * @returns {Buffer|null}
     */
    getScripthash() {
      return this.isScripthash() ? this.getData(1) : null;
    }
    /**
     * Test whether the output script is nulldata/opreturn.
     * @param {Boolean} [minimal=false] - Minimaldata only.
     * @returns {Boolean}
     */
    isNulldata(y) {
      if (this.code.length === 0 || this.getOp(0) !== o.OP_RETURN)
        return !1;
      if (this.code.length === 1)
        return !0;
      if (y && this.raw.length > s.MAX_OP_RETURN_BYTES)
        return !1;
      for (let Y = 1; Y < this.code.length; Y++) {
        const he = this.code[Y];
        if (he.value === -1 || he.value > o.OP_16 || y && !he.isMinimal())
          return !1;
      }
      return !0;
    }
    /**
     * Get OP_RETURN data if present.
     * @param {Boolean} [minimal=false] - Minimaldata only.
     * @returns {Buffer|null}
     */
    getNulldata(y) {
      if (!this.isNulldata(y))
        return null;
      for (let Y = 1; Y < this.code.length; Y++) {
        const be = this.code[Y].toPush();
        if (be)
          return be;
      }
      return J;
    }
    /**
     * Test whether the output script is a witness program.
     * Note that this will return true even for malformed
     * witness v0 programs.
     * @returns {Boolean}
     */
    isProgram() {
      return !(this.raw.length < 4 || this.raw.length > 42 || this.raw[0] !== o.OP_0 && (this.raw[0] < o.OP_1 || this.raw[0] > o.OP_16) || this.raw[1] + 2 !== this.raw.length);
    }
    /**
     * Test whether the output script is unspendable.
     * @returns {Boolean}
     */
    isUnspendable() {
      return this.raw.length > a.MAX_SCRIPT_SIZE ? !0 : this.raw.length > 0 && this.raw[0] === o.OP_RETURN;
    }
    /**
     * "Guess" the type of the input script.
     * This method is not 100% reliable.
     * @returns {ScriptType}
     */
    getInputType() {
      return this.isPubkeyInput() ? S.PUBKEY : this.isPubkeyhashInput() ? S.PUBKEYHASH : this.isScripthashInput() ? S.SCRIPTHASH : this.isMultisigInput() ? S.MULTISIG : S.NONSTANDARD;
    }
    /**
     * "Guess" whether the input script is an unknown/non-standard type.
     * This method is not 100% reliable.
     * @returns {Boolean}
     */
    isUnknownInput() {
      return this.getInputType() === S.NONSTANDARD;
    }
    /**
     * "Guess" whether the input script is pay-to-pubkey.
     * This method is not 100% reliable.
     * @returns {Boolean}
     */
    isPubkeyInput() {
      if (this.code.length !== 1)
        return !1;
      const y = this.getLength(0);
      return y >= 9 && y <= 73;
    }
    /**
     * Get P2PK signature if present.
     * @returns {Buffer|null}
     */
    getPubkeyInput() {
      return this.isPubkeyInput() ? this.getData(0) : null;
    }
    /**
     * "Guess" whether the input script is pay-to-pubkeyhash.
     * This method is not 100% reliable.
     * @returns {Boolean}
     */
    isPubkeyhashInput() {
      if (this.code.length !== 2)
        return !1;
      const y = this.getLength(0), Y = this.getLength(1);
      return y >= 9 && y <= 73 && (Y === 33 || Y === 65);
    }
    /**
     * Get P2PKH signature and key if present.
     * @returns {Array} [sig, key]
     */
    getPubkeyhashInput() {
      return this.isPubkeyhashInput() ? [this.getData(0), this.getData(1)] : [null, null];
    }
    /**
     * "Guess" whether the input script is pay-to-multisig.
     * This method is not 100% reliable.
     * @returns {Boolean}
     */
    isMultisigInput() {
      if (this.code.length < 2 || this.getOp(0) !== o.OP_0 || this.getOp(1) > o.OP_PUSHDATA4 || this.isScripthashInput())
        return !1;
      for (let y = 1; y < this.code.length; y++) {
        const Y = this.getLength(y);
        if (Y < 9 || Y > 73)
          return !1;
      }
      return !0;
    }
    /**
     * Get multisig signatures if present.
     * @returns {Buffer[]|null}
     */
    getMultisigInput() {
      if (!this.isMultisigInput())
        return null;
      const y = [];
      for (let Y = 1; Y < this.code.length; Y++)
        y.push(this.getData(Y));
      return y;
    }
    /**
     * "Guess" whether the input script is pay-to-scripthash.
     * This method is not 100% reliable.
     * @returns {Boolean}
     */
    isScripthashInput() {
      if (this.code.length < 1)
        return !1;
      const y = this.getData(-1);
      if (!y || y.length === 0 || v.isDERSignatureEncoding(y.slice(0, -1)) || v.isKeyEncoding(y))
        return !1;
      const Y = z.fromRaw(y);
      return !(!Y.isCode() || Y.isUnspendable() || !this.isPushOnly());
    }
    /**
     * Get P2SH redeem script if present.
     * @returns {Buffer|null}
     */
    getScripthashInput() {
      return this.isScripthashInput() ? this.getData(-1) : null;
    }
    /**
     * Get coinbase height.
     * @returns {Number} `-1` if not present.
     */
    getCoinbaseHeight() {
      return z.getCoinbaseHeight(this.raw);
    }
    /**
     * Get coinbase height.
     * @param {Buffer} raw - Raw script.
     * @returns {Number} `-1` if not present.
     */
    static getCoinbaseHeight(y) {
      if (y.length === 0)
        return -1;
      if (y[0] >= o.OP_1 && y[0] <= o.OP_16)
        return y[0] - 80;
      if (y[0] > 6)
        return -1;
      const Y = i.fromRaw(y), he = Y.toNum();
      return he ? he.isNeg() || !Y.equals(i.fromNum(he)) ? -1 : he.toDouble() : 1;
    }
    /**
     * Test the script against a bloom filter.
     * @param {Bloom} filter
     * @returns {Boolean}
     */
    test(y) {
      for (const Y of this.code) {
        if (Y.value === -1)
          break;
        if (!(!Y.data || Y.data.length === 0) && y.test(Y.data))
          return !0;
      }
      return !1;
    }
    /**
     * Test the script to see if it contains only push ops.
     * Push ops are: OP_1NEGATE, OP_0-OP_16 and all PUSHDATAs.
     * @returns {Boolean}
     */
    isPushOnly() {
      for (const y of this.code)
        if (y.value === -1 || y.value > o.OP_16)
          return !1;
      return !0;
    }
    /**
     * Count the sigops in the script.
     * @param {Boolean} accurate - Whether to enable accurate counting. This will
     * take into account the `n` value for OP_CHECKMULTISIG(VERIFY).
     * @returns {Number} sigop count
     */
    getSigops(y, Y) {
      if (Y & z.flags.VERIFY_ZERO_SIGOPS)
        return 0;
      let he = 0, be = -1;
      for (const xe of this.code) {
        if (xe.value === -1)
          break;
        switch (xe.value) {
          case o.OP_CHECKSIG:
          case o.OP_CHECKSIGVERIFY:
            he += 1;
            break;
          case o.OP_CHECKSDATAIG:
          case o.OP_CHECKDATASIGVERIFY:
            Y & z.flags.VERIFY_CHECKDATASIG && (he += 1);
            break;
          case o.OP_CHECKMULTISIG:
          case o.OP_CHECKMULTISIGVERIFY:
            y && be >= o.OP_1 && be <= o.OP_16 ? he += be - 80 : he += a.MAX_MULTISIG_PUBKEYS;
            break;
        }
        be = xe.value;
      }
      return he;
    }
    /**
     * Count the sigops in the script, taking into account redeem scripts.
     * @param {Script} input - Input script, needed for access to redeem script.
     * @param {VerifyFlags} flags
     * @returns {Number} sigop count
     */
    getScripthashSigops(y, Y) {
      if (!this.isScripthash())
        return this.getSigops(!0, Y);
      const he = y.getRedeem();
      return he ? he.getSigops(!0, Y) : 0;
    }
    /*
     * Mutation
     */
    get(y) {
      return y < 0 && (y += this.code.length), y < 0 || y >= this.code.length ? null : this.code[y];
    }
    pop() {
      return this.code.pop() || null;
    }
    shift() {
      return this.code.shift() || null;
    }
    remove(y) {
      if (y < 0 && (y += this.code.length), y < 0 || y >= this.code.length)
        return null;
      const Y = this.code.splice(y, 1);
      return Y.length === 0 ? null : Y[0];
    }
    set(y, Y) {
      return y < 0 && (y += this.code.length), e(i.isOpcode(Y)), e(y >= 0 && y <= this.code.length), this.code[y] = Y, this;
    }
    push(y) {
      return e(i.isOpcode(y)), this.code.push(y), this;
    }
    unshift(y) {
      return e(i.isOpcode(y)), this.code.unshift(y), this;
    }
    insert(y, Y) {
      return y < 0 && (y += this.code.length), e(i.isOpcode(Y)), e(y >= 0 && y <= this.code.length), this.code.splice(y, 0, Y), this;
    }
    /*
     * Op
     */
    getOp(y) {
      const Y = this.get(y);
      return Y ? Y.value : -1;
    }
    popOp() {
      const y = this.pop();
      return y ? y.value : -1;
    }
    shiftOp() {
      const y = this.shift();
      return y ? y.value : -1;
    }
    removeOp(y) {
      const Y = this.remove(y);
      return Y ? Y.value : -1;
    }
    setOp(y, Y) {
      return this.set(y, i.fromOp(Y));
    }
    pushOp(y) {
      return this.push(i.fromOp(y));
    }
    unshiftOp(y) {
      return this.unshift(i.fromOp(y));
    }
    insertOp(y, Y) {
      return this.insert(y, i.fromOp(Y));
    }
    /*
     * Data
     */
    getData(y) {
      const Y = this.get(y);
      return Y ? Y.data : null;
    }
    popData() {
      const y = this.pop();
      return y ? y.data : null;
    }
    shiftData() {
      const y = this.shift();
      return y ? y.data : null;
    }
    removeData(y) {
      const Y = this.remove(y);
      return Y ? Y.data : null;
    }
    setData(y, Y) {
      return this.set(y, i.fromData(Y));
    }
    pushData(y) {
      return this.push(i.fromData(y));
    }
    unshiftData(y) {
      return this.unshift(i.fromData(y));
    }
    insertData(y, Y) {
      return this.insert(y, i.fromData(Y));
    }
    /*
     * Length
     */
    getLength(y) {
      const Y = this.get(y);
      return Y ? Y.toLength() : -1;
    }
    /*
     * Push
     */
    getPush(y) {
      const Y = this.get(y);
      return Y ? Y.toPush() : null;
    }
    popPush() {
      const y = this.pop();
      return y ? y.toPush() : null;
    }
    shiftPush() {
      const y = this.shift();
      return y ? y.toPush() : null;
    }
    removePush(y) {
      const Y = this.remove(y);
      return Y ? Y.toPush() : null;
    }
    setPush(y, Y) {
      return this.set(y, i.fromPush(Y));
    }
    pushPush(y) {
      return this.push(i.fromPush(y));
    }
    unshiftPush(y) {
      return this.unshift(i.fromPush(y));
    }
    insertPush(y, Y) {
      return this.insert(y, i.fromPush(Y));
    }
    /*
     * String
     */
    getString(y, Y) {
      const he = this.get(y);
      return he ? he.toString(Y) : null;
    }
    popString(y) {
      const Y = this.pop();
      return Y ? Y.toString(y) : null;
    }
    shiftString(y) {
      const Y = this.shift();
      return Y ? Y.toString(y) : null;
    }
    removeString(y, Y) {
      const he = this.remove(y);
      return he ? he.toString(Y) : null;
    }
    setString(y, Y, he) {
      return this.set(y, i.fromString(Y, he));
    }
    pushString(y, Y) {
      return this.push(i.fromString(y, Y));
    }
    unshiftString(y, Y) {
      return this.unshift(i.fromString(y, Y));
    }
    insertString(y, Y, he) {
      return this.insert(y, i.fromString(Y, he));
    }
    /*
     * Small
     */
    getSmall(y) {
      const Y = this.get(y);
      return Y ? Y.toSmall() : -1;
    }
    popSmall() {
      const y = this.pop();
      return y ? y.toSmall() : -1;
    }
    shiftSmall() {
      const y = this.shift();
      return y ? y.toSmall() : -1;
    }
    removeSmall(y) {
      const Y = this.remove(y);
      return Y ? Y.toSmall() : -1;
    }
    setSmall(y, Y) {
      return this.set(y, i.fromSmall(Y));
    }
    pushSmall(y) {
      return this.push(i.fromSmall(y));
    }
    unshiftSmall(y) {
      return this.unshift(i.fromSmall(y));
    }
    insertSmall(y, Y) {
      return this.insert(y, i.fromSmall(Y));
    }
    /*
     * Num
     */
    getNum(y, Y, he) {
      const be = this.get(y);
      return be ? be.toNum(Y, he) : null;
    }
    popNum(y, Y) {
      const he = this.pop();
      return he ? he.toNum(y, Y) : null;
    }
    shiftNum(y, Y) {
      const he = this.shift();
      return he ? he.toNum(y, Y) : null;
    }
    removeNum(y, Y, he) {
      const be = this.remove(y);
      return be ? be.toNum(Y, he) : null;
    }
    setNum(y, Y) {
      return this.set(y, i.fromNum(Y));
    }
    pushNum(y) {
      return this.push(i.fromNum(y));
    }
    unshiftNum(y) {
      return this.unshift(i.fromNum(y));
    }
    insertNum(y, Y) {
      return this.insert(y, i.fromNum(Y));
    }
    /*
     * Int
     */
    getInt(y, Y, he) {
      const be = this.get(y);
      return be ? be.toInt(Y, he) : -1;
    }
    popInt(y, Y) {
      const he = this.pop();
      return he ? he.toInt(y, Y) : -1;
    }
    shiftInt(y, Y) {
      const he = this.shift();
      return he ? he.toInt(y, Y) : -1;
    }
    removeInt(y, Y, he) {
      const be = this.remove(y);
      return be ? be.toInt(Y, he) : -1;
    }
    setInt(y, Y) {
      return this.set(y, i.fromInt(Y));
    }
    pushInt(y) {
      return this.push(i.fromInt(y));
    }
    unshiftInt(y) {
      return this.unshift(i.fromInt(y));
    }
    insertInt(y, Y) {
      return this.insert(y, i.fromInt(Y));
    }
    /*
     * Bool
     */
    getBool(y) {
      const Y = this.get(y);
      return Y ? Y.toBool() : !1;
    }
    popBool() {
      const y = this.pop();
      return y ? y.toBool() : !1;
    }
    shiftBool() {
      const y = this.shift();
      return y ? y.toBool() : !1;
    }
    removeBool(y) {
      const Y = this.remove(y);
      return Y ? Y.toBool() : !1;
    }
    setBool(y, Y) {
      return this.set(y, i.fromBool(Y));
    }
    pushBool(y) {
      return this.push(i.fromBool(y));
    }
    unshiftBool(y) {
      return this.unshift(i.fromBool(y));
    }
    insertBool(y, Y) {
      return this.insert(y, i.fromBool(Y));
    }
    /*
     * Symbol
     */
    getSym(y) {
      const Y = this.get(y);
      return Y ? Y.toSymbol() : null;
    }
    popSym() {
      const y = this.pop();
      return y ? y.toSymbol() : null;
    }
    shiftSym() {
      const y = this.shift();
      return y ? y.toSymbol() : null;
    }
    removeSym(y) {
      const Y = this.remove(y);
      return Y ? Y.toSymbol() : null;
    }
    setSym(y, Y) {
      return this.set(y, i.fromSymbol(Y));
    }
    pushSym(y) {
      return this.push(i.fromSymbol(y));
    }
    unshiftSym(y) {
      return this.unshift(i.fromSymbol(y));
    }
    insertSym(y, Y) {
      return this.insert(y, i.fromSymbol(Y));
    }
    /**
     * Inject properties from bitcoind test string.
     * @private
     * @param {String} items - Script string.
     * @throws Parse error.
     */
    fromString(y) {
      if (e(typeof y == "string"), y = y.trim(), y.length === 0)
        return this;
      const Y = y.split(/\s+/), he = c.write();
      for (const be of Y) {
        let xe = be;
        xe.charCodeAt(0) & 32 && (xe = xe.toUpperCase()), /^OP_/.test(xe) || (xe = `OP_${xe}`);
        const Ie = o[xe];
        if (Ie == null) {
          if (be[0] === "'") {
            e(be[be.length - 1] === "'", "Invalid string.");
            const I = be.slice(1, -1), se = i.fromString(I);
            he.writeBytes(se.toRaw());
            continue;
          }
          if (/^-?\d+$/.test(be)) {
            const I = E.fromString(be, 10), se = i.fromNum(I);
            he.writeBytes(se.toRaw());
            continue;
          }
          e(be.indexOf("0x") === 0, "Unknown opcode.");
          const ve = be.substring(2), C = k.from(ve, "hex");
          e(C.length === ve.length / 2, "Invalid hex string."), he.writeBytes(C);
          continue;
        }
        he.writeU8(Ie);
      }
      return this.fromRaw(he.render());
    }
    /**
     * Parse a bitcoind test script
     * string into a script object.
     * @param {String} items - Script string.
     * @returns {Script}
     * @throws Parse error.
     */
    static fromString(y) {
      return new this().fromString(y);
    }
    /**
     * Verify an input and output script, and a witness if present.
     * @param {Script} input
     * @param {Null} witness
     * @param {Script} output
     * @param {TX} tx
     * @param {Number} index
     * @param {Amount} value
     * @param {VerifyFlags} flags
     * @param {Number?} sigchecks
     * @throws {ScriptError}
     */
    static verify(y, Y, he, be, xe, Ie, ve, C) {
      if (ve == null && (ve = z.flags.STANDARD_VERIFY_FLAGS), ve & z.flags.VERIFY_SIGPUSHONLY && !y.isPushOnly())
        throw new m("SIG_PUSHONLY");
      ve & z.flags.VERIFY_SIGHASH_FORKID && (ve |= z.flags.VERIFY_STRICTENC);
      let I = new p();
      y.execute(I, ve, be, xe, Ie, N.sigchecks);
      let se;
      if (ve & z.flags.VERIFY_P2SH && (se = I.clone()), he.execute(I, ve, be, xe, Ie, N.sigchecks), I.length === 0 || !I.getBool(-1))
        throw new m("EVAL_FALSE");
      if (ve & z.flags.VERIFY_P2SH && he.isScripthash()) {
        if (!y.isPushOnly())
          throw new m("SIG_PUSHONLY");
        if (I = se, I.length === 0)
          throw new m("EVAL_FALSE");
        const t = I.pop(), l = z.fromRaw(t);
        if ((ve & z.flags.VERIFY_DISALLOW_SEGWIT_RECOVERY) === 0 && I.length === 0 && l.isProgram()) {
          ve & z.flags.REPORT_SIGCHECKS || (N.sigchecks = 0);
          return;
        }
        if (l.execute(I, ve, be, xe, Ie, 0, N.sigchecks), I.length === 0 || !I.getBool(-1))
          throw new m("EVAL_FALSE");
      }
      if (ve & z.flags.VERIFY_CLEANSTACK && (e((ve & z.flags.VERIFY_P2SH) !== 0), I.length !== 1))
        throw new m("CLEANSTACK");
      if (ve & z.flags.VERIFY_INPUT_SIGCHECKS && y.getSize() < N.sigchecks * 43 - 60)
        throw new m("INPUT_SIGCHECKS");
      ve & z.flags.REPORT_SIGCHECKS || (N.sigchecks = 0);
    }
    /**
     * Inject properties from buffer reader.
     * @private
     * @param {BufferReader} br
     */
    fromReader(y) {
      return this.fromRaw(y.readVarBytes());
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer}
     */
    fromRaw(y) {
      const Y = c.read(y);
      for (this.raw = y; Y.left(); )
        this.code.push(i.fromReader(Y));
      return this;
    }
    /**
     * Create a script from buffer reader.
     * @param {BufferReader} br
     * @param {String?} enc - Either `"hex"` or `null`.
     * @returns {Script}
     */
    static fromReader(y) {
      return new this().fromReader(y);
    }
    /**
     * Create a script from a serialized buffer.
     * @param {Buffer|String} data - Serialized script.
     * @param {String?} enc - Either `"hex"` or `null`.
     * @returns {Script}
     */
    static fromRaw(y, Y) {
      return typeof y == "string" && (y = k.from(y, Y)), new this().fromRaw(y);
    }
    /**
     * Test whether an object a Script.
     * @param {Object} obj
     * @returns {Boolean}
     */
    static isScript(y) {
      return y instanceof z;
    }
  }
  z.opcodes = v.opcodes, z.opcodesByVal = v.opcodesByVal, z.flags = v.flags, z.hashType = v.hashType, z.hashTypeByVal = v.hashTypeByVal, z.types = v.types, z.typesByVal = v.typesByVal;
  function A(oe) {
    return oe.slice().sort((y, Y) => y.compare(Y));
  }
  function q(oe, y) {
    if (e(k.isBuffer(oe)), e(typeof y == "number"), y & z.flags.VERIFY_STRICTENC && !v.isKeyEncoding(oe))
      throw new m("PUBKEYTYPE");
    if (y & z.flags.VERIFY_COMPRESSED_PUBKEYTYPE && !v.isCompressedEncoding(oe))
      throw new m("NONCOMPRESSED_PUBKEY");
    return !0;
  }
  function _(oe, y) {
    if (e(k.isBuffer(oe)), e(typeof y == "number"), v.isSchnorr(oe))
      throw new m("SIG_BADLENGTH");
    if ((y & z.flags.VERIFY_DERSIG || y & z.flags.VERIFY_LOW_S || y & z.flags.VERIFY_STRICTENC) && !v.isDERSignatureEncoding(oe))
      throw new m("SIG_DER");
    if (y & z.flags.VERIFY_LOW_S && !v.isLowDER(oe))
      throw new m("SIG_HIGH_S");
    return !0;
  }
  function F(oe, y) {
    if (e(k.isBuffer(oe)), e(typeof y == "number"), y & z.flags.VERIFY_STRICTENC) {
      if (!v.isHashType(oe))
        throw new m("SIG_HASHTYPE");
      const Y = oe[oe.length - 1] & z.hashType.SIGHASH_FORKID, he = y & z.flags.VERIFY_SIGHASH_FORKID;
      if (!he && Y)
        throw new m("ILLEGAL_FORKID");
      if (he && !Y)
        throw new m("MUST_USE_FORKID");
    }
    return !0;
  }
  function R(oe, y) {
    return e(k.isBuffer(oe)), e(typeof y == "number"), oe.length === 0 ? !0 : (ae(oe.slice(0, -1), y), F(oe, y));
  }
  function V(oe, y) {
    return e(k.isBuffer(oe)), e(typeof y == "number"), oe.length === 0 ? !0 : D(oe.slice(0, -1), y) ? F(oe, y) : _(oe.slice(0, -1), y);
  }
  function fe(oe, y) {
    return e(k.isBuffer(oe)), e(typeof y == "number"), oe.length === 0 ? !0 : (_(oe.slice(0, -1), y), F(oe, y));
  }
  function ue(oe, y) {
    return e(k.isBuffer(oe)), e(typeof y == "number"), oe.length === 0 ? !0 : ae(oe.slice(0, oe.length), y);
  }
  function ae(oe, y) {
    return e(k.isBuffer(oe)), e(typeof y == "number"), v.isSchnorr(oe) ? !0 : _(oe, y);
  }
  function D(oe, y) {
    if (e(k.isBuffer(oe)), e(typeof y == "number"), v.isSchnorr(oe))
      return !0;
    throw new m("SIG_NONSCHNORR");
  }
  function Q(oe, y, Y, he) {
    e(k.isBuffer(oe)), e(k.isBuffer(y)), e(k.isBuffer(Y)), e(typeof he == "number");
    let be = !1;
    return y.length === 64 ? be = u.schnorrVerify(oe, y, Y, he) : be = u.verifyDER(oe, y, Y, he), be;
  }
  function Z(oe, y, Y) {
    return u.verifyDER(oe, y.slice(0, -1), Y);
  }
  return R0 = z, R0;
}
/*!
 * slp.js - simple ledger protocol script for bcash
 * Copyright (c) 2021, Vin Armani (MIT License).
 * https://github.com/badger-cash/bcash
 */
var P0, cd;
function Xs() {
  if (cd) return P0;
  cd = 1;
  const e = nt, c = kt, { U64: d } = f8;
  Xt();
  const w = ii();
  Di();
  const g = {
    GENESIS: 0,
    MINT: 1,
    SEND: 2,
    BATON: 3,
    BURN: 4
  };
  class f {
    /**
     * Create a record of SLP data for a given coin.
     * @param {Buffer?} hash the output hash of the coin
     * @param {Number?} vout the output index of the coin
     * @param {Buffer?} tokenId 32 byte txid
     * @param {Buffer?} tokenIndex 4 byte unsigned integer (index of tx hash in db)
     * @param {Buffer} value big endian value of token base units
     * @param {String} type GENESIS | MINT | SEND | BURN | BATON
     * @param {Number?} version token type
     * @constructor
     */
    constructor(s = {}) {
      this.hash = s.hash, this.vout = s.vout, this.tokenId = s.tokenId, this.tokenIndex = s.tokenIndex, this.value = s.value, this.type = s.type, this.version = s.version;
    }
    /**
     * Get the value as 64 bit big-endian buffer
     * @private
     * @returns {Buffer}
     */
    getValueUInt64BE() {
      e(this.value.length <= 8, "value buffer must be 8 bytes or less");
      const s = k.alloc(8 - this.value.length);
      return k.concat([s, this.value]);
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     */
    fromDbData(s) {
      const i = c.read(s);
      this.tokenIndex = i.readBytes(4);
      const p = i.readVarBytes(), m = k.alloc(8 - p.length);
      this.value = k.concat([m, p]), this.type = Object.keys(g)[i.readU8()];
      try {
        this.version = i.readU8();
      } catch (E) {
        if (E.code === "ERR_ENCODING")
          this.version = 1;
        else throw E;
      }
      return e(this.version >= 1 && this.version <= 2), e(Object.keys(g).includes(this.type)), this;
    }
    /**
     * Instantiate SLP record from serialized data.
     * @param {Buffer} data
     * @returns {SlpCoinRecord}
     */
    static fromDbData(s) {
      return new this().fromDbData(s);
    }
    /**
     * Serialize the SLP record.
     * @returns {Buffer}
     */
    toDbData() {
      e(this.tokenIndex, "Missing tokenIndex"), e(this.tokenIndex.length == 4, "tokenId must be a sha256 hash"), e(this.value.byteLength, "Token amount must be a buffer"), e(Object.keys(g).includes(this.type), "Type must be GENESIS | MINT | SEND | BATON | BURN");
      for (let i = 0; i < this.value.length; i++)
        if (this.value[i] != 0) {
          this.value = this.value.slice(i);
          break;
        }
      const s = c.write();
      return s.writeBytes(this.tokenIndex), s.writeVarBytes(this.value), s.writeU8(g[this.type]), s.writeU8(this.version || 1), s.render();
    }
    /**
     * Convert object to JSON.
     * @returns {Object}
     */
    getJSON() {
      return e(this.tokenId, "tokenId must be defined"), {
        hash: this.hash ? k.from(this.hash).reverse().toString("hex") : void 0,
        vout: this.vout,
        tokenId: this.tokenId.toString("hex"),
        value: d.fromBE(this.value).toString(10),
        type: this.type,
        version: this.version || 1
      };
    }
    /**
     * Convert from JSON to Object.
     * @param {Object} json
     * @returns {SlpCoinRecord}
     */
    fromJSON(s) {
      return this.hash = k.from(s.hash, "hex").reverse(), this.vout = s.vout, this.tokenId = k.from(s.tokenId, "hex"), this.value = d.fromString(s.value).toBE(k), this.type = s.type, this.version = s.version || 1, this;
    }
    /**
     * Convert from JSON to Object.
     * @param {Object} json
     * @returns {TokenRecord}
     */
    static fromJSON(s) {
      return new this().fromJSON(s);
    }
  }
  class n {
    /**
     * Create a token record.
     * @constructor
     * @param {Buffer?} tokenId
     * @param {Buffer?} tokenIndex
     * @param {String?} ticker
     * @param {String?} name
     * @param {String?} uri
     * @param {String?} hash
     * @param {Number} decimals
     * @param {Number?} version
     * @param {Buffer?} vaultScriptHash
     */
    constructor(s = {}) {
      this.tokenId = s.tokenId, this.tokenIndex = s.tokenIndex, this.ticker = s.ticker || "", this.name = s.name || "", this.uri = s.uri || "", this.hash = s.hash || "", this.decimals = s.decimals, this.version = s.version, this.version === 2 && (this.vaultScriptHash = s.vaultScriptHash);
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     */
    fromDbData(s) {
      const i = c.read(s);
      this.tokenId = i.readHash(), this.ticker = i.readVarString("utf8"), this.name = i.readVarString("utf8"), this.uri = i.readVarString("utf8"), this.hash = i.readVarString("hex"), this.decimals = i.readU8();
      try {
        this.version = i.readU8();
      } catch (p) {
        if (p.code === "ERR_ENCODING")
          this.version = 1;
        else throw p;
      }
      return this.version === 2 && (this.vaultScriptHash = i.readBytes(20)), e(this.version >= 1 && this.version <= 2), this;
    }
    /**
     * Instantiate token record from serialized data.
     * @param {Buffer} data
     * @returns {TokenRecord}
     */
    static fromDbData(s) {
      return new this().fromDbData(s);
    }
    /**
     * Serialize the token record.
     * @returns {Buffer}
     */
    toDbData() {
      const s = c.write(), i = c.encoding;
      return s.writeHash(this.tokenId), s.writeVarString(this.ticker, "utf8"), this.ticker.length === 0 && (s.offset += i.sizeVarint(0)), s.writeVarString(this.name, "utf8"), this.name.length === 0 && (s.offset += i.sizeVarint(0)), s.writeVarString(this.uri, "utf8"), this.uri.length === 0 && (s.offset += i.sizeVarint(0)), s.writeVarString(this.hash, "hex"), this.hash.length === 0 && (s.offset += i.sizeVarint(0)), s.writeU8(this.decimals), s.writeU8(this.version || 1), this.version === 2 && s.writeBytes(this.vaultScriptHash), s.render();
    }
    /**
     * Convert object to JSON.
     * @returns {Object}
     */
    getJSON() {
      e(this.tokenId, "tokenId must be defined");
      const s = {
        tokenId: this.tokenId.toString("hex"),
        ticker: this.ticker,
        name: this.name,
        uri: this.uri,
        hash: this.hash,
        decimals: this.decimals,
        version: this.version || 1
      };
      return s.version === 2 && this.vaultScriptHash && (s.vaultScriptHash = this.vaultScriptHash.toString("hex")), s;
    }
    /**
     * Convert from JSON to Object.
     * @param {Object} json
     * @returns {SlpCoinRecord}
     */
    fromJSON(s) {
      return this.tokenId = k.from(s.tokenId, "hex"), this.ticker = s.ticker, this.name = s.name, this.uri = s.uri, this.hash = s.hash, this.decimals = s.decimals, this.version = s.version, s.version === 2 && s.vaultScriptHash && (this.vaultScriptHash = k.from(s.vaultScriptHash, "hex")), this;
    }
    /**
     * Convert from JSON to Object.
     * @param {Object} json
     * @returns {TokenRecord}
     */
    static fromJSON(s) {
      return new this().fromJSON(s);
    }
  }
  class u extends w {
    /**
     * Create an SLP script.
     * @constructor
     * @param {Buffer|Array|Object} code
     */
    constructor(s) {
      super(s), this.valid = null;
    }
    /**
     * Is SLP script is of valid construction?
     * Use this as opposed to calling property this.isValid
     * @private
     * @returns {Boolean}
     */
    isValidSlp() {
      return this.valid === null && (this.valid = this.verifySlp()), this.valid;
    }
    /**
     * Test whether SLP script is of valid construction
     * (Does not test if transaction is valid SLP transaction)
     * @private
     * @param {Script?} script
     * @returns {Boolean}
     */
    verifySlp(s) {
      if (s == null && (s = this), s.getSym(0) != "OP_RETURN" || s.getString(1, "hex") != "534c5000")
        return !1;
      const i = s.getString(2, "hex");
      if (i != "01" && i != "02")
        return !1;
      switch (s.getType()) {
        case "GENESIS": {
          if (s.code.length != 11 || !s.getData(7) || s.getData(7).length != 0 && s.getData(7).length != 32 || !s.getData(8) || s.getData(8).length != 1 || s.getInt(8) > 9)
            return !1;
          if (i == "01") {
            if (!s.getData(9) || s.getData(9).length > 1 || s.getData(9).length == 1 && s.getInt(9) < 2)
              return !1;
          } else if (i == "02" && (!s.getData(9) || s.getData(9).length != 20))
            return !1;
          if (s.getData(10).length != 8)
            return !1;
          break;
        }
        case "MINT": {
          if (i == "01" && s.code.length != 7 || i == "02" && s.code.length < 6 || s.getData(4).length != 32)
            return !1;
          if (i == "01") {
            if (!s.getData(5) || s.getData(5).length > 1 || s.getData(5).length == 1 && s.getInt(5) < 2 || s.getData(6).length != 8)
              return !1;
          } else if (i == "02") {
            const m = s.code.slice(5);
            for (let E = 0; E < m.length; E++)
              if (m[E].data.length != 8)
                return !1;
          }
          break;
        }
        case "SEND": {
          if (s.code.length < 6 || s.getData(4).length != 32)
            return !1;
          const m = s.code.slice(5);
          for (let E = 0; E < m.length; E++)
            if (m[E].data.length != 8)
              return !1;
          break;
        }
        case "BURN": {
          if (s.code.length != 6 || s.getData(4).length != 32 || s.getData(5).length != 8)
            return !1;
          break;
        }
        default:
          return !1;
      }
      return !0;
    }
    /**
     * Test whether script is of valid construction
     * (Does not test if transaction is valid SLP transaction)
     * @param {Script?} script
     * @returns {Boolean}
     */
    static verifySlp(s) {
      return new this().verifySlp(s);
    }
    /**
     * Inject properties from a script
     * @private
     * @param {Script} code
     * @returns {SLP}
     */
    fromScript(s) {
      return this.inject(s), this;
    }
    /**
     * Inject properties from a script
     * @param {Script} code
     * @returns {SLP}
     */
    static fromScript(s) {
      return new this().fromScript(s);
    }
    /**
     * Get token ID for this script
     * @private
     * @returns {Hash}
     */
    getTokenId() {
      e(this.verifySlp(), "This is not a valid SLP script");
      const s = this.getType();
      return e(s != "GENESIS", "Cannot derive the tokenID from GENESIS script"), this.getData(4);
    }
    /**
     * Get records for a this script
     * @private
     * @param {Buffer?} txId The txid of the transaction containing this script
     * @returns {(SlpCoinRecord | TokenRecord)[]}
     */
    getRecords(s) {
      e(this.isValidSlp(), "Must be a valid SLP Script");
      const i = this.getType();
      switch (e(Object.keys(g).includes(i) && i != "BATON", "Type must be GENESIS | MINT | SEND | BURN"), e(s.byteLength, "tokenId must be a buffer"), e(s.length == 32, "tokenId must be a sha256 hash"), i) {
        case "GENESIS":
          return this.getGenesisRecords(s);
        case "MINT":
          return this.getMintRecords(s);
        case "SEND":
          return this.getSendRecords(s);
        case "BURN":
          return this.getBurnRecords(s);
        default:
          return null;
      }
    }
    /**
     * Get records for a GENESIS script
     * @private
     * @param {Buffer} tokenId The tokenId of the transaction containing this script
     * @returns {(SlpCoinRecord | TokenRecord)[]}
     */
    getGenesisRecords(s) {
      e(s.byteLength, "tokenId must be a buffer"), e(s.byteLength == 32, "tokenId must be a sha256 hash");
      const i = this.getType();
      e(i == "GENESIS", "This is not a GENESIS transaction");
      const p = this.getInt(2), m = [];
      if (m.push(this.constructor.TokenRecord({
        tokenId: s,
        version: p,
        ticker: this.getString(4, "utf-8"),
        name: this.getString(5, "utf-8"),
        uri: this.getString(6, "utf-8"),
        hash: this.getString(7, "hex"),
        decimals: this.getInt(8),
        vaultScriptHash: p === 2 ? this.getData(9) : void 0
      })), m.push(this.constructor.SlpCoinRecord({
        hash: k.from(s).reverse(),
        vout: 1,
        tokenId: s,
        value: this.getData(10),
        type: i,
        version: this.getInt(2)
      })), p === 1 && this.getInt(9) >= 2) {
        const E = k.alloc(1);
        E.writeInt8(1), m.push(this.constructor.SlpCoinRecord({
          hash: k.from(s).reverse(),
          vout: this.getInt(9),
          tokenId: s,
          value: E,
          type: "BATON",
          version: this.getInt(2)
        }));
      }
      return m;
    }
    /**
     * Get records for a MINT script
     * @private
     * @param {Buffer} txId The txHash of the transaction containing this script
     * @returns {SlpCoinRecord[]}
     */
    getMintRecords(s) {
      e(s.byteLength, "txId must be a buffer"), e(s.byteLength == 32, "txId must be a sha256 hash");
      const i = this.getType();
      e(i == "MINT", "This is not a MINT transaction");
      const p = this.getInt(2), m = [];
      if (p === 1) {
        if (m.push(this.constructor.SlpCoinRecord({
          hash: k.from(s).reverse(),
          vout: 1,
          tokenId: this.getData(4),
          value: this.getData(6),
          type: i,
          version: p
        })), this.getInt(5) >= 2) {
          const E = d.fromInt(1).toBE(k);
          m.push(this.constructor.SlpCoinRecord({
            hash: k.from(s).reverse(),
            vout: this.getInt(5),
            tokenId: this.getData(4),
            value: E,
            type: "BATON",
            version: p
          }));
        }
      } else if (p === 2) {
        const E = this.code.slice(5);
        for (let v = 0; v < E.length; v++) {
          const b = E[v].toData(), h = v + 1;
          m.push(this.constructor.SlpCoinRecord({
            hash: k.from(s).reverse(),
            vout: h,
            tokenId: this.getData(4),
            value: b,
            type: i,
            version: this.getInt(2)
          }));
        }
      }
      return m;
    }
    /**
     * Get records for a SEND script
     * @private
     * @param {Buffer} txId The txHash of the transaction containing this script
     * @param {Boolean} nonStandardOuts OP_RETURN is located at an index other than 0
     * @returns {SlpCoinRecord[]}
     */
    getSendRecords(s, i = !1) {
      e(s.byteLength, "txId must be a buffer"), e(s.byteLength == 32, "txId must be a sha256 hash");
      const p = this.getType();
      e(p == "SEND", "This is not a SEND transaction");
      const m = [], E = this.code.slice(5);
      for (let v = 0; v < E.length; v++) {
        const b = E[v].toData(), h = i ? v : v + 1;
        m.push(this.constructor.SlpCoinRecord({
          hash: k.from(s).reverse(),
          vout: h,
          tokenId: this.getData(4),
          value: b,
          type: p,
          version: this.getInt(2)
        }));
      }
      return m;
    }
    getBurnRecords(s, i = !1) {
      e(s.byteLength, "txId must be a buffer"), e(s.byteLength == 32, "txId must be a sha256 hash");
      const p = this.getType();
      e(p == "BURN", "This is not a BURN transaction");
      const m = [], E = this.code[5].toData();
      return m.push(this.constructor.SlpCoinRecord({
        hash: k.from(s).reverse(),
        vout: 0,
        tokenId: this.getData(4),
        value: E,
        type: p,
        version: this.getInt(2)
      })), m;
    }
    /**
     * Re-encode the script internally. Useful if you
     * changed something manually in the `code` array.
     * @returns {Script}
     */
    compile() {
      super.compile(), this.valid = null, this.isValidSlp();
    }
    /**
     * Inspect the script.
     * @returns {String} Human-readable script code.
     */
    inspect() {
      return `<SLP: ${this.toString()}>`;
    }
    getType() {
      return this.getString(3);
    }
    /**
     * Create a new TokenRecord
     * @param {Buffer?} tokenId
     * @param {Buffer?} tokenIndex
     * @param {String?} ticker
     * @param {String?} name
     * @param {String?} uri
     * @param {String?} hash
     * @param {Number} decimals
     * @param {Number?} version
     * @returns {TokenRecord}
     */
    static TokenRecord(s = {}) {
      return new n(s);
    }
    /**
     * Create a new SlpCoinRecord
     * @param {Buffer?} hash the output hash of the coin
     * @param {Number?} vout the output index of the coin
     * @param {Buffer?} tokenId 32 byte txid
     * @param {Buffer?} tokenIndex 4 byte unsigned integer (index of tx hash in db)
     * @param {Number} value
     * @param {String} type GENESIS | MINT | SEND | BATON
     * @param {Number?} version
     * @returns {SlpCoinRecord}
     */
    static SlpCoinRecord(s = {}) {
      return new f(s);
    }
  }
  return P0 = u, P0;
}
/*!
 * output.js - output object for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var k0, ud;
function Ui() {
  if (ud) return k0;
  ud = 1;
  const e = nt, c = kt, d = Ni(), w = _r(), g = Ci(), f = ii(), n = Xs(), u = ln(), { inspectSymbol: a } = fr();
  class s {
    /**
     * Create an output.
     * @constructor
     * @param {Object?} options
     */
    constructor(p) {
      this.value = 0, this.script = new f(), p && this.fromOptions(p);
    }
    /**
     * Inject properties from options object.
     * @private
     * @param {Object} options
     */
    fromOptions(p) {
      return e(p, "Output data is required."), p.value && (e(
        Number.isSafeInteger(p.value) && p.value >= 0,
        "Value must be a uint64."
      ), this.value = p.value), p.script && this.script.fromOptions(p.script), p.address && this.script.fromAddress(p.address), p.slp && p.slp.constructor === n.SlpCoinRecord().constructor && (this.slp = p.slp), this;
    }
    /**
     * Instantiate output from options object.
     * @param {Object} options
     * @returns {Output}
     */
    static fromOptions(p) {
      return new this().fromOptions(p);
    }
    /**
     * Inject properties from script/value pair.
     * @private
     * @param {Script|Address} script
     * @param {Amount} value
     * @returns {Output}
     */
    fromScript(p, m) {
      return typeof p == "string" && (p = g.fromString(p)), p instanceof g && (p = f.fromAddress(p)), e(p instanceof f, "Script must be a Script."), e(
        Number.isSafeInteger(m) && m >= 0,
        "Value must be a uint64."
      ), this.script = p, this.value = m, this;
    }
    /**
     * Instantiate output from script/value pair.
     * @param {Script|Address} script
     * @param {Amount} value
     * @returns {Output}
     */
    static fromScript(p, m) {
      return new this().fromScript(p, m);
    }
    /**
     * Clone the output.
     * @returns {Output}
     */
    clone() {
      const p = new this.constructor();
      return p.value = this.value, p.script.inject(this.script), p;
    }
    /**
     * Test equality against another output.
     * @param {Output} output
     * @returns {Boolean}
     */
    equals(p) {
      return e(s.isOutput(p)), this.value === p.value && this.script.equals(p.script);
    }
    /**
     * Compare against another output (BIP69).
     * @param {Output} output
     * @returns {Number}
     */
    compare(p) {
      e(s.isOutput(p));
      const m = this.value - p.value;
      return m !== 0 ? m : this.script.compare(p.script);
    }
    /**
     * Get the script type as a string.
     * @returns {ScriptType} type
     */
    getType() {
      return f.typesByVal[this.script.getType()].toLowerCase();
    }
    /**
     * Get the address.
     * @returns {Address} address
     */
    getAddress() {
      return this.script.getAddress();
    }
    /**
     * Get the address hash.
     * @param {String?} enc
     * @returns {Hash} hash
     */
    getHash(p) {
      const m = this.getAddress();
      return m ? m.getHash(p) : null;
    }
    /**
     * Convert the input to a more user-friendly object.
     * @returns {Object}
     */
    [a]() {
      const p = {
        type: this.getType(),
        value: d.btc(this.value),
        script: this.script,
        address: this.getAddress()
      };
      return this.slp ? {
        ...p,
        slp: this.slp
      } : p;
    }
    /**
     * Convert the output to an object suitable
     * for JSON serialization.
     * @returns {Object}
     */
    toJSON() {
      return this.getJSON();
    }
    /**
     * Convert the output to an object suitable
     * for JSON serialization.
     * @param {Network} network
     * @returns {Object}
     */
    getJSON(p) {
      let m = this.getAddress();
      p = w.get(p), m && (m = m.toString(p));
      const E = {
        value: this.value,
        script: this.script.toJSON(),
        address: m
      };
      return this.slp ? {
        ...E,
        slp: this.slp.getJSON()
      } : E;
    }
    /**
     * Calculate the dust threshold for this
     * output, based on serialize size and rate.
     * @param {Rate?} rate
     * @returns {Amount}
     */
    getDustThreshold(p) {
      if (this.script.isUnspendable())
        return 0;
      let m = this.getSize();
      return m += 148, 3 * u.getMinFee(m, p);
    }
    /**
     * Calculate size of serialized output.
     * @returns {Number}
     */
    getSize() {
      return 8 + this.script.getVarSize();
    }
    /**
     * Test whether the output should be considered dust.
     * @param {Rate?} rate
     * @returns {Boolean}
     */
    isDust(p) {
      return this.value < this.getDustThreshold(p);
    }
    /**
     * Inject properties from a JSON object.
     * @private
     * @param {Object} json
     */
    fromJSON(p) {
      return e(p, "Output data is required."), e(
        Number.isSafeInteger(p.value) && p.value >= 0,
        "Value must be a uint64."
      ), this.value = p.value, this.script.fromJSON(p.script), p.slp && (this.slp = n.SlpCoinRecord().fromJSON(p.slp)), this;
    }
    /**
     * Instantiate an Output from a jsonified output object.
     * @param {Object} json - The jsonified output object.
     * @returns {Output}
     */
    static fromJSON(p) {
      return new this().fromJSON(p);
    }
    /**
     * Write the output to a buffer writer.
     * @param {BufferWriter} bw
     */
    toWriter(p) {
      return p.writeI64(this.value), p.writeVarBytes(this.script.toRaw()), p;
    }
    /**
     * Serialize the output.
     * @param {String?} enc - Encoding, can be `'hex'` or null.
     * @returns {Buffer|String}
     */
    toRaw() {
      const p = this.getSize();
      return this.toWriter(c.write(p)).render();
    }
    /**
     * Inject properties from buffer reader.
     * @private
     * @param {BufferReader} br
     */
    fromReader(p) {
      return this.value = p.readI64(), this.script.fromRaw(p.readVarBytes()), this;
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     */
    fromRaw(p) {
      return this.fromReader(c.read(p));
    }
    /**
     * Instantiate an output from a buffer reader.
     * @param {BufferReader} br
     * @returns {Output}
     */
    static fromReader(p) {
      return new this().fromReader(p);
    }
    /**
     * Instantiate an output from a serialized Buffer.
     * @param {Buffer} data
     * @param {String?} enc - Encoding, can be `'hex'` or null.
     * @returns {Output}
     */
    static fromRaw(p, m) {
      return typeof p == "string" && (p = k.from(p, m)), new this().fromRaw(p);
    }
    /**
     * Test an object to see if it is an Output.
     * @param {Object} obj
     * @returns {Boolean}
     */
    static isOutput(p) {
      return p instanceof s;
    }
  }
  return k0 = s, k0;
}
/*!
 * outpoint.js - outpoint object for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var B0, hd;
function dn() {
  if (hd) return B0;
  hd = 1;
  const e = nt, c = kt, d = ur(), w = Xt(), { inspectSymbol: g } = fr();
  class f {
    /**
     * Create an outpoint.
     * @constructor
     * @param {Hash?} hash
     * @param {Number?} index
     */
    constructor(a, s) {
      this.hash = w.ZERO_HASH, this.index = 4294967295, a != null && (e(k.isBuffer(a)), e(s >>> 0 === s, "Index must be a uint32."), this.hash = a, this.index = s);
    }
    /**
     * Inject properties from options object.
     * @private
     * @param {Object} options
     */
    fromOptions(a) {
      return e(a, "Outpoint data is required."), e(k.isBuffer(a.hash)), e(a.index >>> 0 === a.index, "Index must be a uint32."), this.hash = a.hash, this.index = a.index, this;
    }
    /**
     * Instantate outpoint from options object.
     * @param {Object} options
     * @returns {Outpoint}
     */
    static fromOptions(a) {
      return new this().fromOptions(a);
    }
    /**
     * Clone the outpoint.
     * @returns {Outpoint}
     */
    clone() {
      const a = new this.constructor();
      return a.hash = this.hash, a.index = this.index, a;
    }
    /**
     * Test equality against another outpoint.
     * @param {Outpoint} prevout
     * @returns {Boolean}
     */
    equals(a) {
      return e(f.isOutpoint(a)), this.hash.equals(a.hash) && this.index === a.index;
    }
    /**
     * Compare against another outpoint (BIP69).
     * @param {Outpoint} prevout
     * @returns {Number}
     */
    compare(a) {
      e(f.isOutpoint(a));
      const s = n(this.txid(), a.txid());
      return s !== 0 ? s : this.index - a.index;
    }
    /**
     * Test whether the outpoint is null (hash of zeroes
     * with max-u32 index). Used to detect coinbases.
     * @returns {Boolean}
     */
    isNull() {
      return this.index === 4294967295 && this.hash.equals(w.ZERO_HASH);
    }
    /**
     * Get little-endian hash.
     * @returns {Hash}
     */
    rhash() {
      return d.revHex(this.hash);
    }
    /**
     * Get little-endian hash.
     * @returns {Hash}
     */
    txid() {
      return this.rhash();
    }
    /**
     * Serialize outpoint to a key
     * suitable for a hash table.
     * @returns {String}
     */
    toKey() {
      return this.toRaw();
    }
    /**
     * Inject properties from hash table key.
     * @private
     * @param {String} key
     * @returns {Outpoint}
     */
    fromKey(a) {
      return this.hash = a.slice(0, 32), this.index = c.readU32(a, 32), this;
    }
    /**
     * Instantiate outpoint from hash table key.
     * @param {String} key
     * @returns {Outpoint}
     */
    static fromKey(a) {
      return new this().fromKey(a);
    }
    /**
     * Write outpoint to a buffer writer.
     * @param {BufferWriter} bw
     */
    toWriter(a) {
      return a.writeHash(this.hash), a.writeU32(this.index), a;
    }
    /**
     * Calculate size of outpoint.
     * @returns {Number}
     */
    getSize() {
      return 36;
    }
    /**
     * Serialize outpoint.
     * @returns {Buffer}
     */
    toRaw() {
      return this.toWriter(c.write(36)).render();
    }
    /**
     * Inject properties from buffer reader.
     * @private
     * @param {BufferReader} br
     */
    fromReader(a) {
      return this.hash = a.readHash(), this.index = a.readU32(), this;
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     */
    fromRaw(a) {
      return this.fromReader(c.read(a));
    }
    /**
     * Instantiate outpoint from a buffer reader.
     * @param {BufferReader} br
     * @returns {Outpoint}
     */
    static fromReader(a) {
      return new this().fromReader(a);
    }
    /**
     * Instantiate outpoint from serialized data.
     * @param {Buffer} data
     * @returns {Outpoint}
     */
    static fromRaw(a) {
      return new this().fromRaw(a);
    }
    /**
     * Inject properties from json object.
     * @private
     * @params {Object} json
     */
    fromJSON(a) {
      return e(a, "Outpoint data is required."), e(typeof a.hash == "string", "Hash must be a string."), e(a.index >>> 0 === a.index, "Index must be a uint32."), this.hash = d.fromRev(a.hash), this.index = a.index, this;
    }
    /**
     * Convert the outpoint to an object suitable
     * for JSON serialization. Note that the hash
     * will be reversed to abide by bitcoind's legacy
     * of little-endian uint256s.
     * @returns {Object}
     */
    toJSON() {
      return {
        hash: d.revHex(this.hash),
        index: this.index
      };
    }
    /**
     * Instantiate outpoint from json object.
     * @param {Object} json
     * @returns {Outpoint}
     */
    static fromJSON(a) {
      return new this().fromJSON(a);
    }
    /**
     * Inject properties from tx.
     * @private
     * @param {TX} tx
     * @param {Number} index
     */
    fromTX(a, s) {
      return e(a), e(typeof s == "number"), e(s >= 0), this.hash = a.hash(), this.index = s, this;
    }
    /**
     * Instantiate outpoint from tx.
     * @param {TX} tx
     * @param {Number} index
     * @returns {Outpoint}
     */
    static fromTX(a, s) {
      return new this().fromTX(a, s);
    }
    /**
     * Serialize outpoint to a key
     * suitable for a hash table.
     * @param {Hash} hash
     * @param {Number} index
     * @returns {String}
     */
    static toKey(a, s) {
      return new f(a, s).toKey();
    }
    /**
     * Convert the outpoint to a user-friendly string.
     * @returns {String}
     */
    [g]() {
      return `<Outpoint: ${this.rhash()}/${this.index}>`;
    }
    /**
     * Test an object to see if it is an outpoint.
     * @param {Object} obj
     * @returns {Boolean}
     */
    static isOutpoint(a) {
      return a instanceof f;
    }
  }
  function n(u, a) {
    const s = Math.min(u.length, a.length);
    for (let i = 0; i < s; i++) {
      if (u[i] < a[i])
        return -1;
      if (u[i] > a[i])
        return 1;
    }
    return u.length < a.length ? -1 : u.length > a.length ? 1 : 0;
  }
  return B0 = f, B0;
}
/*!
 * coin.js - coin object for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var M0, ld;
function Js() {
  if (ld) return M0;
  ld = 1;
  const e = nt, c = kt, d = ur(), w = Ni(), g = Ui(), f = _r(), n = Xt(), u = dn(), a = Xs(), { inspectSymbol: s } = fr();
  class i extends g {
    /**
     * Create a coin.
     * @constructor
     * @param {Object} options
     */
    constructor(m) {
      super(), this.version = 1, this.height = -1, this.coinbase = !1, this.hash = n.ZERO_HASH, this.index = 0, m && this.fromOptions(m);
    }
    /**
     * Inject options into coin.
     * @private
     * @param {Object} options
     */
    fromOptions(m) {
      return e(m, "Coin data is required."), m.version != null && (e(
        m.version >>> 0 === m.version,
        "Version must be a uint32."
      ), this.version = m.version), m.height != null && (m.height !== -1 ? (e(
        m.height >>> 0 === m.height,
        "Height must be a uint32."
      ), this.height = m.height) : this.height = -1), m.value != null && (e(
        Number.isSafeInteger(m.value) && m.value >= 0,
        "Value must be a uint64."
      ), this.value = m.value), m.script && this.script.fromOptions(m.script), m.coinbase != null && (e(
        typeof m.coinbase == "boolean",
        "Coinbase must be a boolean."
      ), this.coinbase = m.coinbase), m.hash != null && (e(k.isBuffer(m.hash)), this.hash = m.hash), m.index != null && (e(
        m.index >>> 0 === m.index,
        "Index must be a uint32."
      ), this.index = m.index), this;
    }
    /**
     * Instantiate Coin from options object.
     * @private
     * @param {Object} options
     */
    static fromOptions(m) {
      return new this().fromOptions(m);
    }
    /**
     * Clone the coin.
     * @private
     * @returns {Coin}
     */
    clone() {
      e(!1, "Coins are not cloneable.");
    }
    /**
     * Calculate number of confirmations since coin was created.
     * @param {Number?} height - Current chain height. Network
     * height is used if not passed in.
     * @return {Number}
     */
    getDepth(m) {
      return e(typeof m == "number", "Must pass a height."), this.height === -1 || m === -1 || m < this.height ? 0 : m - this.height + 1;
    }
    /**
     * Serialize coin to a key
     * suitable for a hash table.
     * @returns {String}
     */
    toKey() {
      return u.toKey(this.hash, this.index);
    }
    /**
     * Inject properties from hash table key.
     * @private
     * @param {String} key
     * @returns {Coin}
     */
    fromKey(m) {
      const { hash: E, index: v } = u.fromKey(m);
      return this.hash = E, this.index = v, this;
    }
    /**
     * Instantiate coin from hash table key.
     * @param {String} key
     * @returns {Coin}
     */
    static fromKey(m) {
      return new this().fromKey(m);
    }
    /**
     * Get little-endian hash.
     * @returns {Hash}
     */
    rhash() {
      return d.revHex(this.hash);
    }
    /**
     * Get little-endian hash.
     * @returns {Hash}
     */
    txid() {
      return this.rhash();
    }
    /**
     * Convert the coin to a more user-friendly object.
     * @returns {Object}
     */
    [s]() {
      const m = {
        type: this.getType(),
        version: this.version,
        height: this.height,
        value: w.btc(this.value),
        script: this.script,
        coinbase: this.coinbase,
        hash: this.hash ? d.revHex(this.hash) : null,
        index: this.index,
        address: this.getAddress()
      };
      return this.slp ? {
        ...m,
        slp: this.slp
      } : m;
    }
    /**
     * Convert the coin to an object suitable
     * for JSON serialization.
     * @returns {Object}
     */
    toJSON() {
      return this.getJSON();
    }
    /**
     * Convert the coin to an object suitable
     * for JSON serialization. Note that the hash
     * will be reversed to abide by bitcoind's legacy
     * of little-endian uint256s.
     * @param {Network} network
     * @param {Boolean} minimal
     * @returns {Object}
     */
    getJSON(m, E) {
      let v = this.getAddress();
      m = f.get(m), v && (v = v.toString(m));
      const b = {
        version: this.version,
        height: this.height,
        value: this.value,
        script: this.script.toJSON(),
        address: v,
        coinbase: this.coinbase,
        hash: E ? void 0 : this.rhash(),
        index: E ? void 0 : this.index
      };
      return this.slp ? {
        ...b,
        slp: this.slp.getJSON()
      } : b;
    }
    /**
     * Inject JSON properties into coin.
     * @private
     * @param {Object} json
     */
    fromJSON(m) {
      return e(m, "Coin data required."), e(m.version >>> 0 === m.version, "Version must be a uint32."), e(
        m.height === -1 || m.height >>> 0 === m.height,
        "Height must be a uint32."
      ), e(
        Number.isSafeInteger(m.value) && m.value >= 0,
        "Value must be a uint64."
      ), e(typeof m.coinbase == "boolean", "Coinbase must be a boolean."), this.version = m.version, this.height = m.height, this.value = m.value, this.script.fromJSON(m.script), this.coinbase = m.coinbase, m.hash != null && (e(typeof m.hash == "string", "Hash must be a string."), e(m.hash.length === 64, "Hash must be a string."), e(m.index >>> 0 === m.index, "Index must be a uint32."), this.hash = d.fromRev(m.hash), this.index = m.index), m.slp && (m.slp.hash = m.hash, this.slp = a.SlpCoinRecord().fromJSON(m.slp)), this;
    }
    /**
     * Instantiate an Coin from a jsonified coin object.
     * @param {Object} json - The jsonified coin object.
     * @returns {Coin}
     */
    static fromJSON(m) {
      return new this().fromJSON(m);
    }
    /**
     * Calculate size of coin.
     * @returns {Number}
     */
    getSize() {
      return 17 + this.script.getVarSize();
    }
    /**
     * Write the coin to a buffer writer.
     * @param {BufferWriter} bw
     */
    toWriter(m) {
      let E = this.height;
      return E === -1 && (E = 2147483647), m.writeU32(this.version), m.writeU32(E), m.writeI64(this.value), m.writeVarBytes(this.script.toRaw()), m.writeU8(this.coinbase ? 1 : 0), m;
    }
    /**
     * Serialize the coin.
     * @returns {Buffer|String}
     */
    toRaw() {
      const m = this.getSize();
      return this.toWriter(c.write(m)).render();
    }
    /**
     * Inject properties from serialized buffer writer.
     * @private
     * @param {BufferReader} br
     */
    fromReader(m) {
      return this.version = m.readU32(), this.height = m.readU32(), this.value = m.readI64(), this.script.fromRaw(m.readVarBytes()), this.coinbase = m.readU8() === 1, this.height === 2147483647 && (this.height = -1), this;
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     */
    fromRaw(m) {
      return this.fromReader(c.read(m));
    }
    /**
     * Instantiate a coin from a buffer reader.
     * @param {BufferReader} br
     * @returns {Coin}
     */
    static fromReader(m) {
      return new this().fromReader(m);
    }
    /**
     * Instantiate a coin from a serialized Buffer.
     * @param {Buffer} data
     * @param {String?} enc - Encoding, can be `'hex'` or null.
     * @returns {Coin}
     */
    static fromRaw(m, E) {
      return typeof m == "string" && (m = k.from(m, E)), new this().fromRaw(m);
    }
    /**
     * Inject properties from TX.
     * @param {TX} tx
     * @param {Number} index
     */
    fromTX(m, E, v) {
      return e(typeof E == "number"), e(typeof v == "number"), e(E >= 0 && E < m.outputs.length), this.version = m.version, this.height = v, this.value = m.outputs[E].value, this.script = m.outputs[E].script, this.coinbase = m.isCoinbase(), this.hash = m.hash(), this.index = E, this;
    }
    /**
     * Instantiate a coin from a TX
     * @param {TX} tx
     * @param {Number} index - Output index.
     * @returns {Coin}
     */
    static fromTX(m, E, v) {
      return new this().fromTX(m, E, v);
    }
    /**
     * Test an object to see if it is a Coin.
     * @param {Object} obj
     * @returns {Boolean}
     */
    static isCoin(m) {
      return m instanceof i;
    }
  }
  return M0 = i, M0;
}
var _n = {};
/*!
 * compress.js - coin compressor for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var dd;
function ib() {
  if (dd) return _n;
  dd = 1;
  const e = nt, { encoding: c } = kt, d = Fr(), w = Xt(), g = 6, f = k.alloc(0);
  function n(b, h) {
    const o = b.getPubkeyhash(!0);
    if (o)
      return h.writeU8(0), h.writeBytes(o), h;
    const S = b.getScripthash();
    if (S)
      return h.writeU8(1), h.writeBytes(S), h;
    const H = b.getPubkey(!0);
    if (H && m(H)) {
      const j = E(H);
      return h.writeBytes(j), h;
    }
    return h.writeVarint(b.raw.length + g), h.writeBytes(b.raw), h;
  }
  function u(b, h) {
    switch (h.readU8()) {
      case 0: {
        const o = h.readBytes(20, !0);
        b.fromPubkeyhash(o);
        break;
      }
      case 1: {
        const o = h.readBytes(20, !0);
        b.fromScripthash(o);
        break;
      }
      case 2:
      case 3:
      case 4:
      case 5: {
        h.offset -= 1;
        const o = h.readBytes(33, !0), S = v(o);
        b.fromPubkey(S);
        break;
      }
      default: {
        h.offset -= 1;
        const o = h.readVarint() - g;
        if (o > w.MAX_SCRIPT_SIZE)
          b.fromNulldata(f), h.seek(o);
        else {
          const S = h.readBytes(o);
          b.fromRaw(S);
        }
        break;
      }
    }
    return b;
  }
  function a(b) {
    if (b.isPubkeyhash(!0) || b.isScripthash())
      return 21;
    const h = b.getPubkey(!0);
    if (h && m(h))
      return 33;
    let o = 0;
    return o += c.sizeVarint(b.raw.length + g), o += b.raw.length, o;
  }
  function s(b, h) {
    return h.writeVarint(b.value), n(b.script, h), h;
  }
  function i(b, h) {
    return b.value = h.readVarint(), u(b.script, h), b;
  }
  function p(b) {
    let h = 0;
    return h += c.sizeVarint(b.value), h += a(b.script), h;
  }
  function m(b) {
    if (b.length === 0)
      return !1;
    switch (b[0]) {
      case 2:
      case 3:
        return b.length === 33;
      case 4:
        return b.length !== 65 ? !1 : d.publicKeyVerify(b);
      default:
        return !1;
    }
  }
  function E(b) {
    let h;
    switch (b[0]) {
      case 2:
      case 3:
        h = b;
        break;
      case 4:
        h = d.publicKeyConvert(b, !0), h[0] = 4 | b[64] & 1;
        break;
      default:
        throw new Error("Bad point format.");
    }
    return e(h.length === 33), h;
  }
  function v(b) {
    const h = b[0];
    switch (e(b.length === 33), h) {
      case 2:
      case 3:
        return b;
      case 4:
        b[0] = 2;
        break;
      case 5:
        b[0] = 3;
        break;
      default:
        throw new Error("Bad point format.");
    }
    const o = d.publicKeyConvert(b, !1);
    return b[0] = h, o;
  }
  return _n.pack = s, _n.unpack = i, _n.size = p, _n;
}
/*!
 * coinentry.js - coin entry object for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var N0, bd;
function Gs() {
  if (bd) return N0;
  bd = 1;
  const e = nt, c = kt, d = Js(), w = Ui(), g = ib(), { encoding: f } = c, n = 1, u = (1 << 32 - n >>> 0) - 1;
  class a {
    /**
     * Create a coin entry.
     * @constructor
     */
    constructor() {
      this.version = 1, this.height = -1, this.coinbase = !1, this.output = new w(), this.spent = !1, this.raw = null;
    }
    /**
     * Convert coin entry to an output.
     * @returns {Output}
     */
    toOutput() {
      return this.output;
    }
    /**
     * Convert coin entry to a coin.
     * @param {Outpoint} prevout
     * @returns {Coin}
     */
    toCoin(i) {
      const p = new d();
      return p.version = this.version, p.height = this.height, p.coinbase = this.coinbase, p.script = this.output.script, p.value = this.output.value, p.hash = i.hash, p.index = i.index, p;
    }
    /**
     * Inject properties from TX.
     * @param {TX} tx
     * @param {Number} index
     */
    fromOutput(i) {
      return this.output = i, this;
    }
    /**
     * Instantiate a coin from a TX
     * @param {TX} tx
     * @param {Number} index - Output index.
     * @returns {CoinEntry}
     */
    static fromOutput(i) {
      return new this().fromOutput(i);
    }
    /**
     * Inject properties from TX.
     * @param {TX} tx
     * @param {Number} index
     */
    fromCoin(i) {
      return this.version = i.version, this.height = i.height, this.coinbase = i.coinbase, this.output.script = i.script, this.output.value = i.value, this;
    }
    /**
     * Instantiate a coin from a TX
     * @param {TX} tx
     * @param {Number} index - Output index.
     * @returns {CoinEntry}
     */
    static fromCoin(i) {
      return new this().fromCoin(i);
    }
    /**
     * Inject properties from TX.
     * @param {TX} tx
     * @param {Number} index
     */
    fromTX(i, p, m) {
      return e(typeof p == "number"), e(typeof m == "number"), e(p >= 0 && p < i.outputs.length), this.version = i.version, this.height = m, this.coinbase = i.isCoinbase(), this.output = i.outputs[p], this;
    }
    /**
     * Instantiate a coin from a TX
     * @param {TX} tx
     * @param {Number} index - Output index.
     * @returns {CoinEntry}
     */
    static fromTX(i, p, m) {
      return new this().fromTX(i, p, m);
    }
    /**
     * Calculate size of coin.
     * @returns {Number}
     */
    getSize() {
      if (this.raw)
        return this.raw.length;
      let i = 0;
      return i += f.sizeVarint(this.version), i += 4, i += g.size(this.output), i;
    }
    /**
     * Write the coin to a buffer writer.
     * @param {BufferWriter} bw
     */
    toWriter(i) {
      if (this.raw)
        return i.writeBytes(this.raw), i;
      let p = this.height, m = 0;
      return this.coinbase && (m |= 1), p === -1 && (p = u), m |= p << n, i.writeVarint(this.version), i.writeU32(m), g.pack(this.output, i), i;
    }
    /**
     * Serialize the coin.
     * @returns {Buffer}
     */
    toRaw() {
      if (this.raw)
        return this.raw;
      const i = this.getSize(), p = c.write(i);
      return this.toWriter(p), this.raw = p.render(), this.raw;
    }
    /**
     * Inject properties from serialized buffer writer.
     * @private
     * @param {BufferReader} br
     */
    fromReader(i) {
      const p = i.readVarint(), m = i.readU32();
      let E = m >>> n;
      return E === u && (E = -1), this.version = p, this.coinbase = (m & 1) !== 0, this.height = E, g.unpack(this.output, i), this;
    }
    /**
     * Instantiate a coin from a serialized Buffer.
     * @param {Buffer} data
     * @returns {CoinEntry}
     */
    static fromReader(i) {
      return new this().fromReader(i);
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     */
    fromRaw(i) {
      return this.fromReader(c.read(i)), this.raw = i, this;
    }
    /**
     * Instantiate a coin from a serialized Buffer.
     * @param {Buffer} data
     * @returns {CoinEntry}
     */
    static fromRaw(i) {
      return new this().fromRaw(i);
    }
  }
  return N0 = a, N0;
}
/*!
 * coins.js - coins object for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var q0, pd;
function Xh() {
  if (pd) return q0;
  pd = 1;
  const e = nt, c = Gs();
  class d {
    /**
     * Create coins.
     * @constructor
     */
    constructor() {
      this.outputs = /* @__PURE__ */ new Map();
    }
    /**
     * Add a single entry to the collection.
     * @param {Number} index
     * @param {CoinEntry} coin
     * @returns {CoinEntry}
     */
    add(g, f) {
      return e(g >>> 0 === g), e(f), this.outputs.set(g, f), f;
    }
    /**
     * Add a single output to the collection.
     * @param {Number} index
     * @param {Output} output
     * @returns {CoinEntry}
     */
    addOutput(g, f) {
      return this.add(g, c.fromOutput(f));
    }
    /**
     * Add an output to the collection by output index.
     * @param {TX} tx
     * @param {Number} index
     * @param {Number} height
     * @returns {CoinEntry}
     */
    addIndex(g, f, n) {
      return this.add(f, c.fromTX(g, f, n));
    }
    /**
     * Add a single coin to the collection.
     * @param {Coin} coin
     * @returns {CoinEntry}
     */
    addCoin(g) {
      return this.add(g.index, c.fromCoin(g));
    }
    /**
     * Test whether the collection has a coin.
     * @param {Number} index
     * @returns {Boolean}
     */
    has(g) {
      return this.outputs.has(g);
    }
    /**
     * Test whether the collection has an unspent coin.
     * @param {Number} index
     * @returns {Boolean}
     */
    isUnspent(g) {
      const f = this.outputs.get(g);
      return !(!f || f.spent);
    }
    /**
     * Get a coin entry.
     * @param {Number} index
     * @returns {CoinEntry|null}
     */
    get(g) {
      return this.outputs.get(g) || null;
    }
    /**
     * Get an output.
     * @param {Number} index
     * @returns {Output|null}
     */
    getOutput(g) {
      const f = this.outputs.get(g);
      return f ? f.output : null;
    }
    /**
     * Get a coin.
     * @param {Outpoint} prevout
     * @returns {Coin|null}
     */
    getCoin(g) {
      const f = this.outputs.get(g.index);
      return f ? f.toCoin(g) : null;
    }
    /**
     * Spend a coin entry and return it.
     * @param {Number} index
     * @returns {CoinEntry|null}
     */
    spend(g) {
      const f = this.get(g);
      return !f || f.spent ? null : (f.spent = !0, f);
    }
    /**
     * Remove a coin entry and return it.
     * @param {Number} index
     * @returns {CoinEntry|null}
     */
    remove(g) {
      const f = this.get(g);
      return f ? (this.outputs.delete(g), f) : null;
    }
    /**
     * Test whether the coins are fully spent.
     * @returns {Boolean}
     */
    isEmpty() {
      return this.outputs.size === 0;
    }
    /**
     * Inject properties from tx.
     * @private
     * @param {TX} tx
     * @param {Number} height
     * @returns {Coins}
     */
    fromTX(g, f) {
      e(typeof f == "number");
      for (let n = 0; n < g.outputs.length; n++) {
        if (g.outputs[n].script.isUnspendable())
          continue;
        const a = c.fromTX(g, n, f);
        this.outputs.set(n, a);
      }
      return this;
    }
    /**
     * Instantiate a coins object from a transaction.
     * @param {TX} tx
     * @param {Number} height
     * @returns {Coins}
     */
    static fromTX(g, f) {
      return new this().fromTX(g, f);
    }
  }
  return q0 = d, q0;
}
/*!
 * undocoins.js - undocoins object for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var z0, md;
function nb() {
  if (md) return z0;
  md = 1;
  const e = nt, c = kt, d = Gs();
  class w {
    /**
     * Create undo coins.
     * @constructor
     */
    constructor() {
      this.items = [];
    }
    /**
     * Push coin entry onto undo coin array.
     * @param {CoinEntry}
     * @returns {Number}
     */
    push(f) {
      return this.items.push(f);
    }
    /**
     * Calculate undo coins size.
     * @returns {Number}
     */
    getSize() {
      let f = 0;
      f += 4;
      for (const n of this.items)
        f += n.getSize();
      return f;
    }
    /**
     * Serialize all undo coins.
     * @returns {Buffer}
     */
    toRaw() {
      const f = this.getSize(), n = c.write(f);
      n.writeU32(this.items.length);
      for (const u of this.items)
        u.toWriter(n);
      return n.render();
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     * @returns {UndoCoins}
     */
    fromRaw(f) {
      const n = c.read(f), u = n.readU32();
      for (let a = 0; a < u; a++)
        this.items.push(d.fromReader(n));
      return this;
    }
    /**
     * Instantiate undo coins from serialized data.
     * @param {Buffer} data
     * @returns {UndoCoins}
     */
    static fromRaw(f) {
      return new this().fromRaw(f);
    }
    /**
     * Test whether the undo coins have any members.
     * @returns {Boolean}
     */
    isEmpty() {
      return this.items.length === 0;
    }
    /**
     * Render the undo coins.
     * @returns {Buffer}
     */
    commit() {
      const f = this.toRaw();
      return this.items.length = 0, f;
    }
    /**
     * Re-apply undo coins to a view, effectively unspending them.
     * @param {CoinView} view
     * @param {Outpoint} prevout
     */
    apply(f, n) {
      const u = this.items.pop();
      e(u), f.addEntry(n, u);
    }
  }
  return z0 = w, z0;
}
/*!
 * coinview.js - coin viewpoint object for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var T0, gd;
function Jh() {
  if (gd) return T0;
  gd = 1;
  const { BufferMap: e } = un, c = Xh(), d = nb(), w = Gs();
  class g {
    /**
     * Create a coin view.
     * @constructor
     */
    constructor() {
      this.map = new e(), this.undo = new d();
    }
    /**
     * Get coins.
     * @param {Hash} hash
     * @returns {Coins} coins
     */
    get(n) {
      return this.map.get(n);
    }
    /**
     * Test whether the view has an entry.
     * @param {Hash} hash
     * @returns {Boolean}
     */
    has(n) {
      return this.map.has(n);
    }
    /**
     * Add coins to the collection.
     * @param {Hash} hash
     * @param {Coins} coins
     * @returns {Coins}
     */
    add(n, u) {
      return this.map.set(n, u), u;
    }
    /**
     * Ensure existence of coins object in the collection.
     * @param {Hash} hash
     * @returns {Coins}
     */
    ensure(n) {
      const u = this.map.get(n);
      return u || this.add(n, new c());
    }
    /**
     * Remove coins from the collection.
     * @param {Coins} coins
     * @returns {Coins|null}
     */
    remove(n) {
      const u = this.map.get(n);
      return u ? (this.map.delete(n), u) : null;
    }
    /**
     * Add a tx to the collection.
     * @param {TX} tx
     * @param {Number} height
     * @returns {Coins}
     */
    addTX(n, u) {
      const a = n.hash(), s = c.fromTX(n, u);
      return this.add(a, s);
    }
    /**
     * Remove a tx from the collection.
     * @param {TX} tx
     * @param {Number} height
     * @returns {Coins}
     */
    removeTX(n, u) {
      const a = n.hash(), s = c.fromTX(n, u);
      for (const i of s.outputs.values())
        i.spent = !0;
      return this.add(a, s);
    }
    /**
     * Add an entry to the collection.
     * @param {Outpoint} prevout
     * @param {CoinEntry} coin
     * @returns {CoinEntry|null}
     */
    addEntry(n, u) {
      const { hash: a, index: s } = n;
      return this.ensure(a).add(s, u);
    }
    /**
     * Add a coin to the collection.
     * @param {Coin} coin
     * @returns {CoinEntry|null}
     */
    addCoin(n) {
      return this.ensure(n.hash).addCoin(n);
    }
    /**
     * Add an output to the collection.
     * @param {Outpoint} prevout
     * @param {Output} output
     * @returns {CoinEntry|null}
     */
    addOutput(n, u) {
      const { hash: a, index: s } = n;
      return this.ensure(a).addOutput(s, u);
    }
    /**
     * Add an output to the collection by output index.
     * @param {TX} tx
     * @param {Number} index
     * @param {Number} height
     * @returns {CoinEntry|null}
     */
    addIndex(n, u, a) {
      const s = n.hash();
      return this.ensure(s).addIndex(n, u, a);
    }
    /**
     * Spend an output.
     * @param {Outpoint} prevout
     * @returns {CoinEntry|null}
     */
    spendEntry(n) {
      const { hash: u, index: a } = n, s = this.get(u);
      if (!s)
        return null;
      const i = s.spend(a);
      return i ? (this.undo.push(i), i) : null;
    }
    /**
     * Remove an output.
     * @param {Outpoint} prevout
     * @returns {CoinEntry|null}
     */
    removeEntry(n) {
      const { hash: u, index: a } = n, s = this.get(u);
      return s ? s.remove(a) : null;
    }
    /**
     * Test whether the view has an entry by prevout.
     * @param {Outpoint} prevout
     * @returns {Boolean}
     */
    hasEntry(n) {
      const { hash: u, index: a } = n, s = this.get(u);
      return s ? s.has(a) : !1;
    }
    /**
     * Get a single entry by prevout.
     * @param {Outpoint} prevout
     * @returns {CoinEntry|null}
     */
    getEntry(n) {
      const { hash: u, index: a } = n, s = this.get(u);
      return s ? s.get(a) : null;
    }
    /**
     * Test whether an entry has been spent by prevout.
     * @param {Outpoint} prevout
     * @returns {Boolean}
     */
    isUnspent(n) {
      const { hash: u, index: a } = n, s = this.get(u);
      return s ? s.isUnspent(a) : !1;
    }
    /**
     * Get a single coin by prevout.
     * @param {Outpoint} prevout
     * @returns {Coin|null}
     */
    getCoin(n) {
      const u = this.get(n.hash);
      return u ? u.getCoin(n) : null;
    }
    /**
     * Get a single output by prevout.
     * @param {Outpoint} prevout
     * @returns {Output|null}
     */
    getOutput(n) {
      const { hash: u, index: a } = n, s = this.get(u);
      return s ? s.getOutput(a) : null;
    }
    /**
     * Get coins height by prevout.
     * @param {Outpoint} prevout
     * @returns {Number}
     */
    getHeight(n) {
      const u = this.getEntry(n);
      return u ? u.height : -1;
    }
    /**
     * Get coins coinbase flag by prevout.
     * @param {Outpoint} prevout
     * @returns {Boolean}
     */
    isCoinbase(n) {
      const u = this.getEntry(n);
      return u ? u.coinbase : !1;
    }
    /**
     * Test whether the view has an entry by input.
     * @param {Input} input
     * @returns {Boolean}
     */
    hasEntryFor(n) {
      return this.hasEntry(n.prevout);
    }
    /**
     * Get a single entry by input.
     * @param {Input} input
     * @returns {CoinEntry|null}
     */
    getEntryFor(n) {
      return this.getEntry(n.prevout);
    }
    /**
     * Test whether an entry has been spent by input.
     * @param {Input} input
     * @returns {Boolean}
     */
    isUnspentFor(n) {
      return this.isUnspent(n.prevout);
    }
    /**
     * Get a single coin by input.
     * @param {Input} input
     * @returns {Coin|null}
     */
    getCoinFor(n) {
      return this.getCoin(n.prevout);
    }
    /**
     * Get a single output by input.
     * @param {Input} input
     * @returns {Output|null}
     */
    getOutputFor(n) {
      return this.getOutput(n.prevout);
    }
    /**
     * Get coins height by input.
     * @param {Input} input
     * @returns {Number}
     */
    getHeightFor(n) {
      return this.getHeight(n.prevout);
    }
    /**
     * Get coins coinbase flag by input.
     * @param {Input} input
     * @returns {Boolean}
     */
    isCoinbaseFor(n) {
      return this.isCoinbase(n.prevout);
    }
    /**
     * Retrieve coins from database.
     * @method
     * @param {ChainDB} db
     * @param {Outpoint} prevout
     * @returns {Promise} - Returns {@link CoinEntry}.
     */
    async readCoin(n, u) {
      const a = this.getEntry(u);
      if (a)
        return a;
      const s = await n.readCoin(u);
      return s ? this.addEntry(u, s) : null;
    }
    /**
     * Read all input coins into unspent map.
     * @method
     * @param {ChainDB} db
     * @param {TX} tx
     * @returns {Promise} - Returns {Boolean}.
     */
    async readInputs(n, u) {
      let a = !0;
      for (const { prevout: s } of u.inputs)
        await this.readCoin(n, s) || (a = !1);
      return a;
    }
    /**
     * Spend coins for transaction.
     * @method
     * @param {ChainDB} db
     * @param {TX} tx
     * @returns {Promise} - Returns {Boolean}.
     */
    async spendInputs(n, u) {
      let a = 0;
      for (; a < u.inputs.length; ) {
        const s = Math.min(a + 4, u.inputs.length), i = [];
        for (; a < s; a++) {
          const { prevout: m } = u.inputs[a];
          i.push(this.readCoin(n, m));
        }
        const p = await Promise.all(i);
        for (const m of p) {
          if (!m || m.spent)
            return !1;
          m.spent = !0, this.undo.push(m);
        }
      }
      return !0;
    }
    /**
     * Calculate serialization size.
     * @returns {Number}
     */
    getSize(n) {
      let u = 0;
      u += n.inputs.length;
      for (const { prevout: a } of n.inputs) {
        const s = this.getEntry(a);
        s && (u += s.getSize());
      }
      return u;
    }
    /**
     * Write coin data to buffer writer
     * as it pertains to a transaction.
     * @param {BufferWriter} bw
     * @param {TX} tx
     */
    toWriter(n, u) {
      for (const { prevout: a } of u.inputs) {
        const s = this.getEntry(a);
        if (!s) {
          n.writeU8(0);
          continue;
        }
        n.writeU8(1), s.toWriter(n);
      }
      return n;
    }
    /**
     * Read serialized view data from a buffer
     * reader as it pertains to a transaction.
     * @private
     * @param {BufferReader} br
     * @param {TX} tx
     */
    fromReader(n, u) {
      for (const { prevout: a } of u.inputs) {
        if (n.readU8() === 0)
          continue;
        const s = w.fromReader(n);
        this.addEntry(a, s);
      }
      return this;
    }
    /**
     * Read serialized view data from a buffer
     * reader as it pertains to a transaction.
     * @param {BufferReader} br
     * @param {TX} tx
     * @returns {CoinView}
     */
    static fromReader(n, u) {
      return new this().fromReader(n, u);
    }
  }
  return T0 = g, T0;
}
/*!
 * coins/index.js - utxo management for bcoin
 * Copyright (c) 2016-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var xd;
function Qm() {
  return xd || (xd = 1, $i.Coins = Xh(), $i.CoinView = Jh(), $i.compress = ib(), $i.UndoCoins = nb()), $i;
}
var C0 = {}, D0 = {};
/*!
 * common.js - common functions for hd
 * Copyright (c) 2015-2016, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var wd;
function Ws() {
  return wd || (wd = 1, function(e) {
    const c = nt, d = ap, w = e;
    w.HARDENED = 2147483648, w.MIN_ENTROPY = 128, w.MAX_ENTROPY = 512, w.cache = new d(500), w.parsePath = function(f, n) {
      c(typeof f == "string"), c(typeof n == "boolean"), c(f.length >= 1), c(f.length <= 3062);
      const u = f.split("/"), a = u[0];
      if (a !== "m" && a !== "M" && a !== "m'" && a !== "M'")
        throw new Error("Invalid path root.");
      const s = [];
      for (let i = 1; i < u.length; i++) {
        let p = u[i];
        const m = p[p.length - 1] === "'";
        if (m && (p = p.slice(0, -1)), p.length > 10)
          throw new Error("Path index too large.");
        if (!/^\d+$/.test(p))
          throw new Error("Path index is non-numeric.");
        let E = parseInt(p, 10);
        if (E >>> 0 !== E)
          throw new Error("Path index out of range.");
        if (m && (E |= w.HARDENED, E >>>= 0), !n && E & w.HARDENED)
          throw new Error("Path index cannot be hardened.");
        s.push(E);
      }
      return s;
    }, w.isMaster = function(f) {
      return f.depth === 0 && f.childIndex === 0 && f.parentFingerPrint === 0;
    }, w.isAccount = function(f, n) {
      if (n != null) {
        const u = (w.HARDENED | n) >>> 0;
        if (f.childIndex !== u)
          return !1;
      }
      return f.depth === 3 && (f.childIndex & w.HARDENED) !== 0;
    }, w.ZERO_KEY = k.alloc(33, 0);
  }(D0)), D0;
}
/*!
 * cleanse.js - memzero for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var U0, yd;
function Zs() {
  if (yd) return U0;
  yd = 1;
  const e = Bt(), c = Ti();
  function d(w) {
    e(k.isBuffer(w)), c.randomFill(w, 0, w.length);
  }
  return d.native = 0, U0 = d, U0;
}
var Rn = {};
/*!
 * pbkdf2.js - pbkdf2 for bcrypto
 * Copyright (c) 2014-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/PBKDF2
 *   https://tools.ietf.org/html/rfc2898
 *   https://tools.ietf.org/html/rfc2898#section-5.2
 *   https://tools.ietf.org/html/rfc6070
 *   https://www.emc.com/collateral/white-papers/h11302-pkcs5v2-1-password-based-cryptography-standard-wp.pdf
 *   http://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-132.pdf
 */
var vd;
function Gh() {
  if (vd) return Rn;
  vd = 1;
  const e = Bt(), d = (sn.crypto || sn.msCrypto || {}).subtle || {};
  function w(n, u, a, s, i) {
    typeof u == "string" && (u = k.from(u, "utf8")), typeof a == "string" && (a = k.from(a, "utf8")), a == null && (a = k.alloc(0)), e(n && typeof n.id == "string"), e(k.isBuffer(u)), e(k.isBuffer(a)), e(s >>> 0 === s), e(i >>> 0 === i);
    const p = n.size, m = Math.ceil(i / p), E = k.alloc(m * p), v = k.alloc(a.length + 4);
    a.copy(v, 0), u.length > n.blockSize && (u = n.digest(u), e(u.length <= n.blockSize));
    for (let b = 0; b < m; b++) {
      const h = b + 1;
      v[a.length + 0] = h >>> 24, v[a.length + 1] = h >>> 16, v[a.length + 2] = h >>> 8, v[a.length + 3] = h;
      const o = n.mac(v, u);
      let S = o;
      for (let H = 1; H < s; H++) {
        S = n.mac(S, u);
        for (let j = 0; j < p; j++)
          o[j] ^= S[j];
      }
      o.copy(E, b * p);
    }
    return E.slice(0, i);
  }
  async function g(n, u, a, s, i) {
    typeof u == "string" && (u = k.from(u, "utf8")), typeof a == "string" && (a = k.from(a, "utf8")), a == null && (a = k.alloc(0)), e(n && typeof n.id == "string"), e(k.isBuffer(u)), e(k.isBuffer(a)), e(s >>> 0 === s), e(i >>> 0 === i);
    const p = f(n);
    if (!d.importKey || !d.deriveBits || !p)
      return w(n, u, a, s, i);
    const m = { name: "PBKDF2" }, E = ["deriveBits"], v = {
      name: "PBKDF2",
      salt: a,
      iterations: s,
      hash: p
    }, b = await d.importKey("raw", u, m, !1, E), h = await d.deriveBits(v, b, i * 8);
    return k.from(h);
  }
  function f(n) {
    switch (n.id) {
      case "SHA1":
        return "SHA-1";
      case "SHA256":
        return "SHA-256";
      case "SHA384":
        return "SHA-384";
      case "SHA512":
        return "SHA-512";
      default:
        return null;
    }
  }
  return Rn.native = 0, Rn.derive = w, Rn.deriveAsync = g, Rn;
}
/*!
 * sha512.js - SHA512 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/hash.js:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/hash.js
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/SHA-2
 *   https://tools.ietf.org/html/rfc4634
 *   https://github.com/indutny/hash.js/blob/master/lib/hash/sha/512.js
 */
var F0, Sd;
function Fi() {
  if (Sd) return F0;
  Sd = 1;
  const e = Bt(), c = ri(), d = -1, w = k.alloc(16, 0), g = k.alloc(128, 0);
  g[0] = 128;
  const f = new Uint32Array([
    1116352408,
    3609767458,
    1899447441,
    602891725,
    3049323471,
    3964484399,
    3921009573,
    2173295548,
    961987163,
    4081628472,
    1508970993,
    3053834265,
    2453635748,
    2937671579,
    2870763221,
    3664609560,
    3624381080,
    2734883394,
    310598401,
    1164996542,
    607225278,
    1323610764,
    1426881987,
    3590304994,
    1925078388,
    4068182383,
    2162078206,
    991336113,
    2614888103,
    633803317,
    3248222580,
    3479774868,
    3835390401,
    2666613458,
    4022224774,
    944711139,
    264347078,
    2341262773,
    604807628,
    2007800933,
    770255983,
    1495990901,
    1249150122,
    1856431235,
    1555081692,
    3175218132,
    1996064986,
    2198950837,
    2554220882,
    3999719339,
    2821834349,
    766784016,
    2952996808,
    2566594879,
    3210313671,
    3203337956,
    3336571891,
    1034457026,
    3584528711,
    2466948901,
    113926993,
    3758326383,
    338241895,
    168717936,
    666307205,
    1188179964,
    773529912,
    1546045734,
    1294757372,
    1522805485,
    1396182291,
    2643833823,
    1695183700,
    2343527390,
    1986661051,
    1014477480,
    2177026350,
    1206759142,
    2456956037,
    344077627,
    2730485921,
    1290863460,
    2820302411,
    3158454273,
    3259730800,
    3505952657,
    3345764771,
    106217008,
    3516065817,
    3606008344,
    3600352804,
    1432725776,
    4094571909,
    1467031594,
    275423344,
    851169720,
    430227734,
    3100823752,
    506948616,
    1363258195,
    659060556,
    3750685593,
    883997877,
    3785050280,
    958139571,
    3318307427,
    1322822218,
    3812723403,
    1537002063,
    2003034995,
    1747873779,
    3602036899,
    1955562222,
    1575990012,
    2024104815,
    1125592928,
    2227730452,
    2716904306,
    2361852424,
    442776044,
    2428436474,
    593698344,
    2756734187,
    3733110249,
    3204031479,
    2999351573,
    3329325298,
    3815920427,
    3391569614,
    3928383900,
    3515267271,
    566280711,
    3940187606,
    3454069534,
    4118630271,
    4000239992,
    116418474,
    1914138554,
    174292421,
    2731055270,
    289380356,
    3203993006,
    460393269,
    320620315,
    685471733,
    587496836,
    852142971,
    1086792851,
    1017036298,
    365543100,
    1126000580,
    2618297676,
    1288033470,
    3409855158,
    1501505948,
    4234509866,
    1607167915,
    987167468,
    1816402316,
    1246189591
  ]);
  class n {
    constructor() {
      this.state = new Uint32Array(16), this.msg = new Uint32Array(160), this.block = k.alloc(128), this.size = d;
    }
    init() {
      return this.state[0] = 1779033703, this.state[1] = 4089235720, this.state[2] = 3144134277, this.state[3] = 2227873595, this.state[4] = 1013904242, this.state[5] = 4271175723, this.state[6] = 2773480762, this.state[7] = 1595750129, this.state[8] = 1359893119, this.state[9] = 2917565137, this.state[10] = 2600822924, this.state[11] = 725511199, this.state[12] = 528734635, this.state[13] = 4215389547, this.state[14] = 1541459225, this.state[15] = 327033209, this.size = 0, this;
    }
    update(D) {
      return e(k.isBuffer(D)), this._update(D, D.length), this;
    }
    final() {
      return this._final(k.alloc(64));
    }
    _update(D, Q) {
      e(this.size !== d, "Context is not initialized.");
      let Z = this.size & 127, oe = 0;
      if (this.size += Q, Z > 0) {
        let y = 128 - Z;
        if (y > Q && (y = Q), D.copy(this.block, Z, oe, oe + y), Z += y, Q -= y, oe += y, Z < 128)
          return;
        this._transform(this.block, 0);
      }
      for (; Q >= 128; )
        this._transform(D, oe), oe += 128, Q -= 128;
      Q > 0 && D.copy(this.block, 0, oe, oe + Q);
    }
    /**
     * Finalize SHA512 context.
     * @private
     * @param {Buffer} out
     * @returns {Buffer}
     */
    _final(D) {
      e(this.size !== d, "Context is not initialized.");
      const Q = this.size & 127, Z = this.size * 8;
      ue(w, Z * (1 / 4294967296) >>> 0, 8), ue(w, Z >>> 0, 12), this._update(g, 1 + (239 - Q & 127)), this._update(w, 16);
      for (let oe = 0; oe < 16; oe++)
        ue(D, this.state[oe], oe * 4), this.state[oe] = 0;
      for (let oe = 0; oe < 160; oe++)
        this.msg[oe] = 0;
      for (let oe = 0; oe < 128; oe++)
        this.block[oe] = 0;
      return this.size = d, D;
    }
    _prepare(D, Q) {
      const Z = this.msg;
      let oe = 0;
      for (; oe < 32; oe++)
        Z[oe] = fe(D, Q + oe * 4);
      for (; oe < 160; oe += 2) {
        const y = R(Z[oe - 4], Z[oe - 3]), Y = V(Z[oe - 4], Z[oe - 3]), he = Z[oe - 14], be = Z[oe - 13], xe = _(Z[oe - 30], Z[oe - 29]), Ie = F(Z[oe - 30], Z[oe - 29]), ve = Z[oe - 32], C = Z[oe - 31];
        Z[oe + 0] = i(
          y,
          Y,
          he,
          be,
          xe,
          Ie,
          ve,
          C
        ), Z[oe + 1] = p(
          y,
          Y,
          he,
          be,
          xe,
          Ie,
          ve,
          C
        );
      }
    }
    _transform(D, Q) {
      const Z = this.msg;
      this._prepare(D, Q);
      let oe = this.state[0], y = this.state[1], Y = this.state[2], he = this.state[3], be = this.state[4], xe = this.state[5], Ie = this.state[6], ve = this.state[7], C = this.state[8], I = this.state[9], se = this.state[10], t = this.state[11], l = this.state[12], B = this.state[13], U = this.state[14], G = this.state[15];
      for (let T = 0; T < Z.length; T += 2) {
        let M = U, $ = G, r = A(C, I), x = q(C, I);
        const O = S(C, I, se, t, l), L = H(C, I, se, t, l, B), X = f[T + 0], P = f[T + 1], K = Z[T + 0], re = Z[T + 1], ce = m(
          M,
          $,
          r,
          x,
          O,
          L,
          X,
          P,
          K,
          re
        ), le = E(
          M,
          $,
          r,
          x,
          O,
          L,
          X,
          P,
          K,
          re
        );
        M = N(oe, y), $ = z(oe, y), r = j(oe, y, Y, he, be), x = J(oe, y, Y, he, be, xe);
        const me = a(M, $, r, x), ne = s(M, $, r, x);
        U = l, G = B, l = se, B = t, se = C, t = I, C = a(Ie, ve, ce, le), I = s(ve, ve, ce, le), Ie = be, ve = xe, be = Y, xe = he, Y = oe, he = y, oe = a(ce, le, me, ne), y = s(ce, le, me, ne);
      }
      u(this.state, 0, oe, y), u(this.state, 2, Y, he), u(this.state, 4, be, xe), u(this.state, 6, Ie, ve), u(this.state, 8, C, I), u(this.state, 10, se, t), u(this.state, 12, l, B), u(this.state, 14, U, G);
    }
    static hash() {
      return new n();
    }
    static hmac() {
      return new c(n, 128);
    }
    static digest(D) {
      return n.ctx.init().update(D).final();
    }
    static root(D, Q) {
      return e(k.isBuffer(D) && D.length === 64), e(k.isBuffer(Q) && Q.length === 64), n.ctx.init().update(D).update(Q).final();
    }
    static multi(D, Q, Z) {
      const { ctx: oe } = n;
      return oe.init(), oe.update(D), oe.update(Q), Z && oe.update(Z), oe.final();
    }
    static mac(D, Q) {
      return n.hmac().init(Q).update(D).final();
    }
  }
  n.native = 0, n.id = "SHA512", n.size = 64, n.bits = 512, n.blockSize = 128, n.zero = k.alloc(64, 0), n.ctx = new n();
  function u(ae, D, Q, Z) {
    const oe = ae[D + 0], y = ae[D + 1], Y = Z + y >>> 0, he = (Y < Z) + Q + oe;
    ae[D + 0] = he >>> 0, ae[D + 1] = Y;
  }
  function a(ae, D, Q, Z) {
    return (D + Z >>> 0 < D) + ae + Q >>> 0;
  }
  function s(ae, D, Q, Z) {
    return D + Z >>> 0;
  }
  function i(ae, D, Q, Z, oe, y, Y, he) {
    let be = 0, xe = D;
    return xe = xe + Z >>> 0, be += xe < D, xe = xe + y >>> 0, be += xe < y, xe = xe + he >>> 0, be += xe < he, ae + Q + oe + Y + be >>> 0;
  }
  function p(ae, D, Q, Z, oe, y, Y, he) {
    return D + Z + y + he >>> 0;
  }
  function m(ae, D, Q, Z, oe, y, Y, he, be, xe) {
    let Ie = 0, ve = D;
    return ve = ve + Z >>> 0, Ie += ve < D, ve = ve + y >>> 0, Ie += ve < y, ve = ve + he >>> 0, Ie += ve < he, ve = ve + xe >>> 0, Ie += ve < xe, ae + Q + oe + Y + be + Ie >>> 0;
  }
  function E(ae, D, Q, Z, oe, y, Y, he, be, xe) {
    return D + Z + y + he + xe >>> 0;
  }
  function v(ae, D, Q) {
    return (D << 32 - Q | ae >>> Q) >>> 0;
  }
  function b(ae, D, Q) {
    return (ae << 32 - Q | D >>> Q) >>> 0;
  }
  function h(ae, D, Q) {
    return ae >>> Q;
  }
  function o(ae, D, Q) {
    return (ae << 32 - Q | D >>> Q) >>> 0;
  }
  function S(ae, D, Q, Z, oe, y) {
    return (ae & Q ^ ~ae & oe) >>> 0;
  }
  function H(ae, D, Q, Z, oe, y) {
    return (D & Z ^ ~D & y) >>> 0;
  }
  function j(ae, D, Q, Z, oe, y) {
    return (ae & Q ^ ae & oe ^ Q & oe) >>> 0;
  }
  function J(ae, D, Q, Z, oe, y) {
    return (D & Z ^ D & y ^ Z & y) >>> 0;
  }
  function N(ae, D) {
    const Q = v(ae, D, 28), Z = v(D, ae, 2), oe = v(D, ae, 7);
    return (Q ^ Z ^ oe) >>> 0;
  }
  function z(ae, D) {
    const Q = b(ae, D, 28), Z = b(D, ae, 2), oe = b(D, ae, 7);
    return (Q ^ Z ^ oe) >>> 0;
  }
  function A(ae, D) {
    const Q = v(ae, D, 14), Z = v(ae, D, 18), oe = v(D, ae, 9);
    return (Q ^ Z ^ oe) >>> 0;
  }
  function q(ae, D) {
    const Q = b(ae, D, 14), Z = b(ae, D, 18), oe = b(D, ae, 9);
    return (Q ^ Z ^ oe) >>> 0;
  }
  function _(ae, D) {
    const Q = v(ae, D, 1), Z = v(ae, D, 8), oe = h(ae, D, 7);
    return (Q ^ Z ^ oe) >>> 0;
  }
  function F(ae, D) {
    const Q = b(ae, D, 1), Z = b(ae, D, 8), oe = o(ae, D, 7);
    return (Q ^ Z ^ oe) >>> 0;
  }
  function R(ae, D) {
    const Q = v(ae, D, 19), Z = v(D, ae, 29), oe = h(ae, D, 6);
    return (Q ^ Z ^ oe) >>> 0;
  }
  function V(ae, D) {
    const Q = b(ae, D, 19), Z = b(D, ae, 29), oe = o(ae, D, 6);
    return (Q ^ Z ^ oe) >>> 0;
  }
  function fe(ae, D) {
    return ae[D++] * 16777216 + ae[D++] * 65536 + ae[D++] * 256 + ae[D];
  }
  function ue(ae, D, Q) {
    return ae[Q++] = D >>> 24, ae[Q++] = D >>> 16, ae[Q++] = D >>> 8, ae[Q++] = D, Q;
  }
  return F0 = n, F0;
}
var H0 = {}, L0, Ed;
function e9() {
  return Ed || (Ed = 1, L0 = [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ]), L0;
}
var K0, Id;
function t9() {
  return Id || (Id = 1, K0 = [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ]), K0;
}
var V0, Ad;
function r9() {
  return Ad || (Ad = 1, V0 = [
    "abandon",
    "ability",
    "able",
    "about",
    "above",
    "absent",
    "absorb",
    "abstract",
    "absurd",
    "abuse",
    "access",
    "accident",
    "account",
    "accuse",
    "achieve",
    "acid",
    "acoustic",
    "acquire",
    "across",
    "act",
    "action",
    "actor",
    "actress",
    "actual",
    "adapt",
    "add",
    "addict",
    "address",
    "adjust",
    "admit",
    "adult",
    "advance",
    "advice",
    "aerobic",
    "affair",
    "afford",
    "afraid",
    "again",
    "age",
    "agent",
    "agree",
    "ahead",
    "aim",
    "air",
    "airport",
    "aisle",
    "alarm",
    "album",
    "alcohol",
    "alert",
    "alien",
    "all",
    "alley",
    "allow",
    "almost",
    "alone",
    "alpha",
    "already",
    "also",
    "alter",
    "always",
    "amateur",
    "amazing",
    "among",
    "amount",
    "amused",
    "analyst",
    "anchor",
    "ancient",
    "anger",
    "angle",
    "angry",
    "animal",
    "ankle",
    "announce",
    "annual",
    "another",
    "answer",
    "antenna",
    "antique",
    "anxiety",
    "any",
    "apart",
    "apology",
    "appear",
    "apple",
    "approve",
    "april",
    "arch",
    "arctic",
    "area",
    "arena",
    "argue",
    "arm",
    "armed",
    "armor",
    "army",
    "around",
    "arrange",
    "arrest",
    "arrive",
    "arrow",
    "art",
    "artefact",
    "artist",
    "artwork",
    "ask",
    "aspect",
    "assault",
    "asset",
    "assist",
    "assume",
    "asthma",
    "athlete",
    "atom",
    "attack",
    "attend",
    "attitude",
    "attract",
    "auction",
    "audit",
    "august",
    "aunt",
    "author",
    "auto",
    "autumn",
    "average",
    "avocado",
    "avoid",
    "awake",
    "aware",
    "away",
    "awesome",
    "awful",
    "awkward",
    "axis",
    "baby",
    "bachelor",
    "bacon",
    "badge",
    "bag",
    "balance",
    "balcony",
    "ball",
    "bamboo",
    "banana",
    "banner",
    "bar",
    "barely",
    "bargain",
    "barrel",
    "base",
    "basic",
    "basket",
    "battle",
    "beach",
    "bean",
    "beauty",
    "because",
    "become",
    "beef",
    "before",
    "begin",
    "behave",
    "behind",
    "believe",
    "below",
    "belt",
    "bench",
    "benefit",
    "best",
    "betray",
    "better",
    "between",
    "beyond",
    "bicycle",
    "bid",
    "bike",
    "bind",
    "biology",
    "bird",
    "birth",
    "bitter",
    "black",
    "blade",
    "blame",
    "blanket",
    "blast",
    "bleak",
    "bless",
    "blind",
    "blood",
    "blossom",
    "blouse",
    "blue",
    "blur",
    "blush",
    "board",
    "boat",
    "body",
    "boil",
    "bomb",
    "bone",
    "bonus",
    "book",
    "boost",
    "border",
    "boring",
    "borrow",
    "boss",
    "bottom",
    "bounce",
    "box",
    "boy",
    "bracket",
    "brain",
    "brand",
    "brass",
    "brave",
    "bread",
    "breeze",
    "brick",
    "bridge",
    "brief",
    "bright",
    "bring",
    "brisk",
    "broccoli",
    "broken",
    "bronze",
    "broom",
    "brother",
    "brown",
    "brush",
    "bubble",
    "buddy",
    "budget",
    "buffalo",
    "build",
    "bulb",
    "bulk",
    "bullet",
    "bundle",
    "bunker",
    "burden",
    "burger",
    "burst",
    "bus",
    "business",
    "busy",
    "butter",
    "buyer",
    "buzz",
    "cabbage",
    "cabin",
    "cable",
    "cactus",
    "cage",
    "cake",
    "call",
    "calm",
    "camera",
    "camp",
    "can",
    "canal",
    "cancel",
    "candy",
    "cannon",
    "canoe",
    "canvas",
    "canyon",
    "capable",
    "capital",
    "captain",
    "car",
    "carbon",
    "card",
    "cargo",
    "carpet",
    "carry",
    "cart",
    "case",
    "cash",
    "casino",
    "castle",
    "casual",
    "cat",
    "catalog",
    "catch",
    "category",
    "cattle",
    "caught",
    "cause",
    "caution",
    "cave",
    "ceiling",
    "celery",
    "cement",
    "census",
    "century",
    "cereal",
    "certain",
    "chair",
    "chalk",
    "champion",
    "change",
    "chaos",
    "chapter",
    "charge",
    "chase",
    "chat",
    "cheap",
    "check",
    "cheese",
    "chef",
    "cherry",
    "chest",
    "chicken",
    "chief",
    "child",
    "chimney",
    "choice",
    "choose",
    "chronic",
    "chuckle",
    "chunk",
    "churn",
    "cigar",
    "cinnamon",
    "circle",
    "citizen",
    "city",
    "civil",
    "claim",
    "clap",
    "clarify",
    "claw",
    "clay",
    "clean",
    "clerk",
    "clever",
    "click",
    "client",
    "cliff",
    "climb",
    "clinic",
    "clip",
    "clock",
    "clog",
    "close",
    "cloth",
    "cloud",
    "clown",
    "club",
    "clump",
    "cluster",
    "clutch",
    "coach",
    "coast",
    "coconut",
    "code",
    "coffee",
    "coil",
    "coin",
    "collect",
    "color",
    "column",
    "combine",
    "come",
    "comfort",
    "comic",
    "common",
    "company",
    "concert",
    "conduct",
    "confirm",
    "congress",
    "connect",
    "consider",
    "control",
    "convince",
    "cook",
    "cool",
    "copper",
    "copy",
    "coral",
    "core",
    "corn",
    "correct",
    "cost",
    "cotton",
    "couch",
    "country",
    "couple",
    "course",
    "cousin",
    "cover",
    "coyote",
    "crack",
    "cradle",
    "craft",
    "cram",
    "crane",
    "crash",
    "crater",
    "crawl",
    "crazy",
    "cream",
    "credit",
    "creek",
    "crew",
    "cricket",
    "crime",
    "crisp",
    "critic",
    "crop",
    "cross",
    "crouch",
    "crowd",
    "crucial",
    "cruel",
    "cruise",
    "crumble",
    "crunch",
    "crush",
    "cry",
    "crystal",
    "cube",
    "culture",
    "cup",
    "cupboard",
    "curious",
    "current",
    "curtain",
    "curve",
    "cushion",
    "custom",
    "cute",
    "cycle",
    "dad",
    "damage",
    "damp",
    "dance",
    "danger",
    "daring",
    "dash",
    "daughter",
    "dawn",
    "day",
    "deal",
    "debate",
    "debris",
    "decade",
    "december",
    "decide",
    "decline",
    "decorate",
    "decrease",
    "deer",
    "defense",
    "define",
    "defy",
    "degree",
    "delay",
    "deliver",
    "demand",
    "demise",
    "denial",
    "dentist",
    "deny",
    "depart",
    "depend",
    "deposit",
    "depth",
    "deputy",
    "derive",
    "describe",
    "desert",
    "design",
    "desk",
    "despair",
    "destroy",
    "detail",
    "detect",
    "develop",
    "device",
    "devote",
    "diagram",
    "dial",
    "diamond",
    "diary",
    "dice",
    "diesel",
    "diet",
    "differ",
    "digital",
    "dignity",
    "dilemma",
    "dinner",
    "dinosaur",
    "direct",
    "dirt",
    "disagree",
    "discover",
    "disease",
    "dish",
    "dismiss",
    "disorder",
    "display",
    "distance",
    "divert",
    "divide",
    "divorce",
    "dizzy",
    "doctor",
    "document",
    "dog",
    "doll",
    "dolphin",
    "domain",
    "donate",
    "donkey",
    "donor",
    "door",
    "dose",
    "double",
    "dove",
    "draft",
    "dragon",
    "drama",
    "drastic",
    "draw",
    "dream",
    "dress",
    "drift",
    "drill",
    "drink",
    "drip",
    "drive",
    "drop",
    "drum",
    "dry",
    "duck",
    "dumb",
    "dune",
    "during",
    "dust",
    "dutch",
    "duty",
    "dwarf",
    "dynamic",
    "eager",
    "eagle",
    "early",
    "earn",
    "earth",
    "easily",
    "east",
    "easy",
    "echo",
    "ecology",
    "economy",
    "edge",
    "edit",
    "educate",
    "effort",
    "egg",
    "eight",
    "either",
    "elbow",
    "elder",
    "electric",
    "elegant",
    "element",
    "elephant",
    "elevator",
    "elite",
    "else",
    "embark",
    "embody",
    "embrace",
    "emerge",
    "emotion",
    "employ",
    "empower",
    "empty",
    "enable",
    "enact",
    "end",
    "endless",
    "endorse",
    "enemy",
    "energy",
    "enforce",
    "engage",
    "engine",
    "enhance",
    "enjoy",
    "enlist",
    "enough",
    "enrich",
    "enroll",
    "ensure",
    "enter",
    "entire",
    "entry",
    "envelope",
    "episode",
    "equal",
    "equip",
    "era",
    "erase",
    "erode",
    "erosion",
    "error",
    "erupt",
    "escape",
    "essay",
    "essence",
    "estate",
    "eternal",
    "ethics",
    "evidence",
    "evil",
    "evoke",
    "evolve",
    "exact",
    "example",
    "excess",
    "exchange",
    "excite",
    "exclude",
    "excuse",
    "execute",
    "exercise",
    "exhaust",
    "exhibit",
    "exile",
    "exist",
    "exit",
    "exotic",
    "expand",
    "expect",
    "expire",
    "explain",
    "expose",
    "express",
    "extend",
    "extra",
    "eye",
    "eyebrow",
    "fabric",
    "face",
    "faculty",
    "fade",
    "faint",
    "faith",
    "fall",
    "false",
    "fame",
    "family",
    "famous",
    "fan",
    "fancy",
    "fantasy",
    "farm",
    "fashion",
    "fat",
    "fatal",
    "father",
    "fatigue",
    "fault",
    "favorite",
    "feature",
    "february",
    "federal",
    "fee",
    "feed",
    "feel",
    "female",
    "fence",
    "festival",
    "fetch",
    "fever",
    "few",
    "fiber",
    "fiction",
    "field",
    "figure",
    "file",
    "film",
    "filter",
    "final",
    "find",
    "fine",
    "finger",
    "finish",
    "fire",
    "firm",
    "first",
    "fiscal",
    "fish",
    "fit",
    "fitness",
    "fix",
    "flag",
    "flame",
    "flash",
    "flat",
    "flavor",
    "flee",
    "flight",
    "flip",
    "float",
    "flock",
    "floor",
    "flower",
    "fluid",
    "flush",
    "fly",
    "foam",
    "focus",
    "fog",
    "foil",
    "fold",
    "follow",
    "food",
    "foot",
    "force",
    "forest",
    "forget",
    "fork",
    "fortune",
    "forum",
    "forward",
    "fossil",
    "foster",
    "found",
    "fox",
    "fragile",
    "frame",
    "frequent",
    "fresh",
    "friend",
    "fringe",
    "frog",
    "front",
    "frost",
    "frown",
    "frozen",
    "fruit",
    "fuel",
    "fun",
    "funny",
    "furnace",
    "fury",
    "future",
    "gadget",
    "gain",
    "galaxy",
    "gallery",
    "game",
    "gap",
    "garage",
    "garbage",
    "garden",
    "garlic",
    "garment",
    "gas",
    "gasp",
    "gate",
    "gather",
    "gauge",
    "gaze",
    "general",
    "genius",
    "genre",
    "gentle",
    "genuine",
    "gesture",
    "ghost",
    "giant",
    "gift",
    "giggle",
    "ginger",
    "giraffe",
    "girl",
    "give",
    "glad",
    "glance",
    "glare",
    "glass",
    "glide",
    "glimpse",
    "globe",
    "gloom",
    "glory",
    "glove",
    "glow",
    "glue",
    "goat",
    "goddess",
    "gold",
    "good",
    "goose",
    "gorilla",
    "gospel",
    "gossip",
    "govern",
    "gown",
    "grab",
    "grace",
    "grain",
    "grant",
    "grape",
    "grass",
    "gravity",
    "great",
    "green",
    "grid",
    "grief",
    "grit",
    "grocery",
    "group",
    "grow",
    "grunt",
    "guard",
    "guess",
    "guide",
    "guilt",
    "guitar",
    "gun",
    "gym",
    "habit",
    "hair",
    "half",
    "hammer",
    "hamster",
    "hand",
    "happy",
    "harbor",
    "hard",
    "harsh",
    "harvest",
    "hat",
    "have",
    "hawk",
    "hazard",
    "head",
    "health",
    "heart",
    "heavy",
    "hedgehog",
    "height",
    "hello",
    "helmet",
    "help",
    "hen",
    "hero",
    "hidden",
    "high",
    "hill",
    "hint",
    "hip",
    "hire",
    "history",
    "hobby",
    "hockey",
    "hold",
    "hole",
    "holiday",
    "hollow",
    "home",
    "honey",
    "hood",
    "hope",
    "horn",
    "horror",
    "horse",
    "hospital",
    "host",
    "hotel",
    "hour",
    "hover",
    "hub",
    "huge",
    "human",
    "humble",
    "humor",
    "hundred",
    "hungry",
    "hunt",
    "hurdle",
    "hurry",
    "hurt",
    "husband",
    "hybrid",
    "ice",
    "icon",
    "idea",
    "identify",
    "idle",
    "ignore",
    "ill",
    "illegal",
    "illness",
    "image",
    "imitate",
    "immense",
    "immune",
    "impact",
    "impose",
    "improve",
    "impulse",
    "inch",
    "include",
    "income",
    "increase",
    "index",
    "indicate",
    "indoor",
    "industry",
    "infant",
    "inflict",
    "inform",
    "inhale",
    "inherit",
    "initial",
    "inject",
    "injury",
    "inmate",
    "inner",
    "innocent",
    "input",
    "inquiry",
    "insane",
    "insect",
    "inside",
    "inspire",
    "install",
    "intact",
    "interest",
    "into",
    "invest",
    "invite",
    "involve",
    "iron",
    "island",
    "isolate",
    "issue",
    "item",
    "ivory",
    "jacket",
    "jaguar",
    "jar",
    "jazz",
    "jealous",
    "jeans",
    "jelly",
    "jewel",
    "job",
    "join",
    "joke",
    "journey",
    "joy",
    "judge",
    "juice",
    "jump",
    "jungle",
    "junior",
    "junk",
    "just",
    "kangaroo",
    "keen",
    "keep",
    "ketchup",
    "key",
    "kick",
    "kid",
    "kidney",
    "kind",
    "kingdom",
    "kiss",
    "kit",
    "kitchen",
    "kite",
    "kitten",
    "kiwi",
    "knee",
    "knife",
    "knock",
    "know",
    "lab",
    "label",
    "labor",
    "ladder",
    "lady",
    "lake",
    "lamp",
    "language",
    "laptop",
    "large",
    "later",
    "latin",
    "laugh",
    "laundry",
    "lava",
    "law",
    "lawn",
    "lawsuit",
    "layer",
    "lazy",
    "leader",
    "leaf",
    "learn",
    "leave",
    "lecture",
    "left",
    "leg",
    "legal",
    "legend",
    "leisure",
    "lemon",
    "lend",
    "length",
    "lens",
    "leopard",
    "lesson",
    "letter",
    "level",
    "liar",
    "liberty",
    "library",
    "license",
    "life",
    "lift",
    "light",
    "like",
    "limb",
    "limit",
    "link",
    "lion",
    "liquid",
    "list",
    "little",
    "live",
    "lizard",
    "load",
    "loan",
    "lobster",
    "local",
    "lock",
    "logic",
    "lonely",
    "long",
    "loop",
    "lottery",
    "loud",
    "lounge",
    "love",
    "loyal",
    "lucky",
    "luggage",
    "lumber",
    "lunar",
    "lunch",
    "luxury",
    "lyrics",
    "machine",
    "mad",
    "magic",
    "magnet",
    "maid",
    "mail",
    "main",
    "major",
    "make",
    "mammal",
    "man",
    "manage",
    "mandate",
    "mango",
    "mansion",
    "manual",
    "maple",
    "marble",
    "march",
    "margin",
    "marine",
    "market",
    "marriage",
    "mask",
    "mass",
    "master",
    "match",
    "material",
    "math",
    "matrix",
    "matter",
    "maximum",
    "maze",
    "meadow",
    "mean",
    "measure",
    "meat",
    "mechanic",
    "medal",
    "media",
    "melody",
    "melt",
    "member",
    "memory",
    "mention",
    "menu",
    "mercy",
    "merge",
    "merit",
    "merry",
    "mesh",
    "message",
    "metal",
    "method",
    "middle",
    "midnight",
    "milk",
    "million",
    "mimic",
    "mind",
    "minimum",
    "minor",
    "minute",
    "miracle",
    "mirror",
    "misery",
    "miss",
    "mistake",
    "mix",
    "mixed",
    "mixture",
    "mobile",
    "model",
    "modify",
    "mom",
    "moment",
    "monitor",
    "monkey",
    "monster",
    "month",
    "moon",
    "moral",
    "more",
    "morning",
    "mosquito",
    "mother",
    "motion",
    "motor",
    "mountain",
    "mouse",
    "move",
    "movie",
    "much",
    "muffin",
    "mule",
    "multiply",
    "muscle",
    "museum",
    "mushroom",
    "music",
    "must",
    "mutual",
    "myself",
    "mystery",
    "myth",
    "naive",
    "name",
    "napkin",
    "narrow",
    "nasty",
    "nation",
    "nature",
    "near",
    "neck",
    "need",
    "negative",
    "neglect",
    "neither",
    "nephew",
    "nerve",
    "nest",
    "net",
    "network",
    "neutral",
    "never",
    "news",
    "next",
    "nice",
    "night",
    "noble",
    "noise",
    "nominee",
    "noodle",
    "normal",
    "north",
    "nose",
    "notable",
    "note",
    "nothing",
    "notice",
    "novel",
    "now",
    "nuclear",
    "number",
    "nurse",
    "nut",
    "oak",
    "obey",
    "object",
    "oblige",
    "obscure",
    "observe",
    "obtain",
    "obvious",
    "occur",
    "ocean",
    "october",
    "odor",
    "off",
    "offer",
    "office",
    "often",
    "oil",
    "okay",
    "old",
    "olive",
    "olympic",
    "omit",
    "once",
    "one",
    "onion",
    "online",
    "only",
    "open",
    "opera",
    "opinion",
    "oppose",
    "option",
    "orange",
    "orbit",
    "orchard",
    "order",
    "ordinary",
    "organ",
    "orient",
    "original",
    "orphan",
    "ostrich",
    "other",
    "outdoor",
    "outer",
    "output",
    "outside",
    "oval",
    "oven",
    "over",
    "own",
    "owner",
    "oxygen",
    "oyster",
    "ozone",
    "pact",
    "paddle",
    "page",
    "pair",
    "palace",
    "palm",
    "panda",
    "panel",
    "panic",
    "panther",
    "paper",
    "parade",
    "parent",
    "park",
    "parrot",
    "party",
    "pass",
    "patch",
    "path",
    "patient",
    "patrol",
    "pattern",
    "pause",
    "pave",
    "payment",
    "peace",
    "peanut",
    "pear",
    "peasant",
    "pelican",
    "pen",
    "penalty",
    "pencil",
    "people",
    "pepper",
    "perfect",
    "permit",
    "person",
    "pet",
    "phone",
    "photo",
    "phrase",
    "physical",
    "piano",
    "picnic",
    "picture",
    "piece",
    "pig",
    "pigeon",
    "pill",
    "pilot",
    "pink",
    "pioneer",
    "pipe",
    "pistol",
    "pitch",
    "pizza",
    "place",
    "planet",
    "plastic",
    "plate",
    "play",
    "please",
    "pledge",
    "pluck",
    "plug",
    "plunge",
    "poem",
    "poet",
    "point",
    "polar",
    "pole",
    "police",
    "pond",
    "pony",
    "pool",
    "popular",
    "portion",
    "position",
    "possible",
    "post",
    "potato",
    "pottery",
    "poverty",
    "powder",
    "power",
    "practice",
    "praise",
    "predict",
    "prefer",
    "prepare",
    "present",
    "pretty",
    "prevent",
    "price",
    "pride",
    "primary",
    "print",
    "priority",
    "prison",
    "private",
    "prize",
    "problem",
    "process",
    "produce",
    "profit",
    "program",
    "project",
    "promote",
    "proof",
    "property",
    "prosper",
    "protect",
    "proud",
    "provide",
    "public",
    "pudding",
    "pull",
    "pulp",
    "pulse",
    "pumpkin",
    "punch",
    "pupil",
    "puppy",
    "purchase",
    "purity",
    "purpose",
    "purse",
    "push",
    "put",
    "puzzle",
    "pyramid",
    "quality",
    "quantum",
    "quarter",
    "question",
    "quick",
    "quit",
    "quiz",
    "quote",
    "rabbit",
    "raccoon",
    "race",
    "rack",
    "radar",
    "radio",
    "rail",
    "rain",
    "raise",
    "rally",
    "ramp",
    "ranch",
    "random",
    "range",
    "rapid",
    "rare",
    "rate",
    "rather",
    "raven",
    "raw",
    "razor",
    "ready",
    "real",
    "reason",
    "rebel",
    "rebuild",
    "recall",
    "receive",
    "recipe",
    "record",
    "recycle",
    "reduce",
    "reflect",
    "reform",
    "refuse",
    "region",
    "regret",
    "regular",
    "reject",
    "relax",
    "release",
    "relief",
    "rely",
    "remain",
    "remember",
    "remind",
    "remove",
    "render",
    "renew",
    "rent",
    "reopen",
    "repair",
    "repeat",
    "replace",
    "report",
    "require",
    "rescue",
    "resemble",
    "resist",
    "resource",
    "response",
    "result",
    "retire",
    "retreat",
    "return",
    "reunion",
    "reveal",
    "review",
    "reward",
    "rhythm",
    "rib",
    "ribbon",
    "rice",
    "rich",
    "ride",
    "ridge",
    "rifle",
    "right",
    "rigid",
    "ring",
    "riot",
    "ripple",
    "risk",
    "ritual",
    "rival",
    "river",
    "road",
    "roast",
    "robot",
    "robust",
    "rocket",
    "romance",
    "roof",
    "rookie",
    "room",
    "rose",
    "rotate",
    "rough",
    "round",
    "route",
    "royal",
    "rubber",
    "rude",
    "rug",
    "rule",
    "run",
    "runway",
    "rural",
    "sad",
    "saddle",
    "sadness",
    "safe",
    "sail",
    "salad",
    "salmon",
    "salon",
    "salt",
    "salute",
    "same",
    "sample",
    "sand",
    "satisfy",
    "satoshi",
    "sauce",
    "sausage",
    "save",
    "say",
    "scale",
    "scan",
    "scare",
    "scatter",
    "scene",
    "scheme",
    "school",
    "science",
    "scissors",
    "scorpion",
    "scout",
    "scrap",
    "screen",
    "script",
    "scrub",
    "sea",
    "search",
    "season",
    "seat",
    "second",
    "secret",
    "section",
    "security",
    "seed",
    "seek",
    "segment",
    "select",
    "sell",
    "seminar",
    "senior",
    "sense",
    "sentence",
    "series",
    "service",
    "session",
    "settle",
    "setup",
    "seven",
    "shadow",
    "shaft",
    "shallow",
    "share",
    "shed",
    "shell",
    "sheriff",
    "shield",
    "shift",
    "shine",
    "ship",
    "shiver",
    "shock",
    "shoe",
    "shoot",
    "shop",
    "short",
    "shoulder",
    "shove",
    "shrimp",
    "shrug",
    "shuffle",
    "shy",
    "sibling",
    "sick",
    "side",
    "siege",
    "sight",
    "sign",
    "silent",
    "silk",
    "silly",
    "silver",
    "similar",
    "simple",
    "since",
    "sing",
    "siren",
    "sister",
    "situate",
    "six",
    "size",
    "skate",
    "sketch",
    "ski",
    "skill",
    "skin",
    "skirt",
    "skull",
    "slab",
    "slam",
    "sleep",
    "slender",
    "slice",
    "slide",
    "slight",
    "slim",
    "slogan",
    "slot",
    "slow",
    "slush",
    "small",
    "smart",
    "smile",
    "smoke",
    "smooth",
    "snack",
    "snake",
    "snap",
    "sniff",
    "snow",
    "soap",
    "soccer",
    "social",
    "sock",
    "soda",
    "soft",
    "solar",
    "soldier",
    "solid",
    "solution",
    "solve",
    "someone",
    "song",
    "soon",
    "sorry",
    "sort",
    "soul",
    "sound",
    "soup",
    "source",
    "south",
    "space",
    "spare",
    "spatial",
    "spawn",
    "speak",
    "special",
    "speed",
    "spell",
    "spend",
    "sphere",
    "spice",
    "spider",
    "spike",
    "spin",
    "spirit",
    "split",
    "spoil",
    "sponsor",
    "spoon",
    "sport",
    "spot",
    "spray",
    "spread",
    "spring",
    "spy",
    "square",
    "squeeze",
    "squirrel",
    "stable",
    "stadium",
    "staff",
    "stage",
    "stairs",
    "stamp",
    "stand",
    "start",
    "state",
    "stay",
    "steak",
    "steel",
    "stem",
    "step",
    "stereo",
    "stick",
    "still",
    "sting",
    "stock",
    "stomach",
    "stone",
    "stool",
    "story",
    "stove",
    "strategy",
    "street",
    "strike",
    "strong",
    "struggle",
    "student",
    "stuff",
    "stumble",
    "style",
    "subject",
    "submit",
    "subway",
    "success",
    "such",
    "sudden",
    "suffer",
    "sugar",
    "suggest",
    "suit",
    "summer",
    "sun",
    "sunny",
    "sunset",
    "super",
    "supply",
    "supreme",
    "sure",
    "surface",
    "surge",
    "surprise",
    "surround",
    "survey",
    "suspect",
    "sustain",
    "swallow",
    "swamp",
    "swap",
    "swarm",
    "swear",
    "sweet",
    "swift",
    "swim",
    "swing",
    "switch",
    "sword",
    "symbol",
    "symptom",
    "syrup",
    "system",
    "table",
    "tackle",
    "tag",
    "tail",
    "talent",
    "talk",
    "tank",
    "tape",
    "target",
    "task",
    "taste",
    "tattoo",
    "taxi",
    "teach",
    "team",
    "tell",
    "ten",
    "tenant",
    "tennis",
    "tent",
    "term",
    "test",
    "text",
    "thank",
    "that",
    "theme",
    "then",
    "theory",
    "there",
    "they",
    "thing",
    "this",
    "thought",
    "three",
    "thrive",
    "throw",
    "thumb",
    "thunder",
    "ticket",
    "tide",
    "tiger",
    "tilt",
    "timber",
    "time",
    "tiny",
    "tip",
    "tired",
    "tissue",
    "title",
    "toast",
    "tobacco",
    "today",
    "toddler",
    "toe",
    "together",
    "toilet",
    "token",
    "tomato",
    "tomorrow",
    "tone",
    "tongue",
    "tonight",
    "tool",
    "tooth",
    "top",
    "topic",
    "topple",
    "torch",
    "tornado",
    "tortoise",
    "toss",
    "total",
    "tourist",
    "toward",
    "tower",
    "town",
    "toy",
    "track",
    "trade",
    "traffic",
    "tragic",
    "train",
    "transfer",
    "trap",
    "trash",
    "travel",
    "tray",
    "treat",
    "tree",
    "trend",
    "trial",
    "tribe",
    "trick",
    "trigger",
    "trim",
    "trip",
    "trophy",
    "trouble",
    "truck",
    "true",
    "truly",
    "trumpet",
    "trust",
    "truth",
    "try",
    "tube",
    "tuition",
    "tumble",
    "tuna",
    "tunnel",
    "turkey",
    "turn",
    "turtle",
    "twelve",
    "twenty",
    "twice",
    "twin",
    "twist",
    "two",
    "type",
    "typical",
    "ugly",
    "umbrella",
    "unable",
    "unaware",
    "uncle",
    "uncover",
    "under",
    "undo",
    "unfair",
    "unfold",
    "unhappy",
    "uniform",
    "unique",
    "unit",
    "universe",
    "unknown",
    "unlock",
    "until",
    "unusual",
    "unveil",
    "update",
    "upgrade",
    "uphold",
    "upon",
    "upper",
    "upset",
    "urban",
    "urge",
    "usage",
    "use",
    "used",
    "useful",
    "useless",
    "usual",
    "utility",
    "vacant",
    "vacuum",
    "vague",
    "valid",
    "valley",
    "valve",
    "van",
    "vanish",
    "vapor",
    "various",
    "vast",
    "vault",
    "vehicle",
    "velvet",
    "vendor",
    "venture",
    "venue",
    "verb",
    "verify",
    "version",
    "very",
    "vessel",
    "veteran",
    "viable",
    "vibrant",
    "vicious",
    "victory",
    "video",
    "view",
    "village",
    "vintage",
    "violin",
    "virtual",
    "virus",
    "visa",
    "visit",
    "visual",
    "vital",
    "vivid",
    "vocal",
    "voice",
    "void",
    "volcano",
    "volume",
    "vote",
    "voyage",
    "wage",
    "wagon",
    "wait",
    "walk",
    "wall",
    "walnut",
    "want",
    "warfare",
    "warm",
    "warrior",
    "wash",
    "wasp",
    "waste",
    "water",
    "wave",
    "way",
    "wealth",
    "weapon",
    "wear",
    "weasel",
    "weather",
    "web",
    "wedding",
    "weekend",
    "weird",
    "welcome",
    "west",
    "wet",
    "whale",
    "what",
    "wheat",
    "wheel",
    "when",
    "where",
    "whip",
    "whisper",
    "wide",
    "width",
    "wife",
    "wild",
    "will",
    "win",
    "window",
    "wine",
    "wing",
    "wink",
    "winner",
    "winter",
    "wire",
    "wisdom",
    "wise",
    "wish",
    "witness",
    "wolf",
    "woman",
    "wonder",
    "wood",
    "wool",
    "word",
    "work",
    "world",
    "worry",
    "worth",
    "wrap",
    "wreck",
    "wrestle",
    "wrist",
    "write",
    "wrong",
    "yard",
    "year",
    "yellow",
    "you",
    "young",
    "youth",
    "zebra",
    "zero",
    "zone",
    "zoo"
  ]), V0;
}
var $0, Od;
function i9() {
  return Od || (Od = 1, $0 = [
    "abaisser",
    "abandon",
    "abdiquer",
    "abeille",
    "abolir",
    "aborder",
    "aboutir",
    "aboyer",
    "abrasif",
    "abreuver",
    "abriter",
    "abroger",
    "abrupt",
    "absence",
    "absolu",
    "absurde",
    "abusif",
    "abyssal",
    "academie",
    "acajou",
    "acarien",
    "accabler",
    "accepter",
    "acclamer",
    "accolade",
    "accroche",
    "accuser",
    "acerbe",
    "achat",
    "acheter",
    "aciduler",
    "acier",
    "acompte",
    "acquerir",
    "acronyme",
    "acteur",
    "actif",
    "actuel",
    "adepte",
    "adequat",
    "adhesif",
    "adjectif",
    "adjuger",
    "admettre",
    "admirer",
    "adopter",
    "adorer",
    "adoucir",
    "adresse",
    "adroit",
    "adulte",
    "adverbe",
    "aerer",
    "aeronef",
    "affaire",
    "affecter",
    "affiche",
    "affreux",
    "affubler",
    "agacer",
    "agencer",
    "agile",
    "agiter",
    "agrafer",
    "agreable",
    "agrume",
    "aider",
    "aiguille",
    "ailier",
    "aimable",
    "aisance",
    "ajouter",
    "ajuster",
    "alarmer",
    "alchimie",
    "alerte",
    "algebre",
    "algue",
    "aliener",
    "aliment",
    "alleger",
    "alliage",
    "allouer",
    "allumer",
    "alourdir",
    "alpaga",
    "altesse",
    "alveole",
    "amateur",
    "ambigu",
    "ambre",
    "amenager",
    "amertume",
    "amidon",
    "amiral",
    "amorcer",
    "amour",
    "amovible",
    "amphibie",
    "ampleur",
    "amusant",
    "analyse",
    "anaphore",
    "anarchie",
    "anatomie",
    "ancien",
    "aneantir",
    "angle",
    "angoisse",
    "anguleux",
    "animal",
    "annexer",
    "annonce",
    "annuel",
    "anodin",
    "anomalie",
    "anonyme",
    "anormal",
    "antenne",
    "antidote",
    "anxieux",
    "apaiser",
    "aperitif",
    "aplanir",
    "apologie",
    "appareil",
    "appeler",
    "apporter",
    "appuyer",
    "aquarium",
    "aqueduc",
    "arbitre",
    "arbuste",
    "ardeur",
    "ardoise",
    "argent",
    "arlequin",
    "armature",
    "armement",
    "armoire",
    "armure",
    "arpenter",
    "arracher",
    "arriver",
    "arroser",
    "arsenic",
    "arteriel",
    "article",
    "aspect",
    "asphalte",
    "aspirer",
    "assaut",
    "asservir",
    "assiette",
    "associer",
    "assurer",
    "asticot",
    "astre",
    "astuce",
    "atelier",
    "atome",
    "atrium",
    "atroce",
    "attaque",
    "attentif",
    "attirer",
    "attraper",
    "aubaine",
    "auberge",
    "audace",
    "audible",
    "augurer",
    "aurore",
    "automne",
    "autruche",
    "avaler",
    "avancer",
    "avarice",
    "avenir",
    "averse",
    "aveugle",
    "aviateur",
    "avide",
    "avion",
    "aviser",
    "avoine",
    "avouer",
    "avril",
    "axial",
    "axiome",
    "badge",
    "bafouer",
    "bagage",
    "baguette",
    "baignade",
    "balancer",
    "balcon",
    "baleine",
    "balisage",
    "bambin",
    "bancaire",
    "bandage",
    "banlieue",
    "banniere",
    "banquier",
    "barbier",
    "baril",
    "baron",
    "barque",
    "barrage",
    "bassin",
    "bastion",
    "bataille",
    "bateau",
    "batterie",
    "baudrier",
    "bavarder",
    "belette",
    "belier",
    "belote",
    "benefice",
    "berceau",
    "berger",
    "berline",
    "bermuda",
    "besace",
    "besogne",
    "betail",
    "beurre",
    "biberon",
    "bicycle",
    "bidule",
    "bijou",
    "bilan",
    "bilingue",
    "billard",
    "binaire",
    "biologie",
    "biopsie",
    "biotype",
    "biscuit",
    "bison",
    "bistouri",
    "bitume",
    "bizarre",
    "blafard",
    "blague",
    "blanchir",
    "blessant",
    "blinder",
    "blond",
    "bloquer",
    "blouson",
    "bobard",
    "bobine",
    "boire",
    "boiser",
    "bolide",
    "bonbon",
    "bondir",
    "bonheur",
    "bonifier",
    "bonus",
    "bordure",
    "borne",
    "botte",
    "boucle",
    "boueux",
    "bougie",
    "boulon",
    "bouquin",
    "bourse",
    "boussole",
    "boutique",
    "boxeur",
    "branche",
    "brasier",
    "brave",
    "brebis",
    "breche",
    "breuvage",
    "bricoler",
    "brigade",
    "brillant",
    "brioche",
    "brique",
    "brochure",
    "broder",
    "bronzer",
    "brousse",
    "broyeur",
    "brume",
    "brusque",
    "brutal",
    "bruyant",
    "buffle",
    "buisson",
    "bulletin",
    "bureau",
    "burin",
    "bustier",
    "butiner",
    "butoir",
    "buvable",
    "buvette",
    "cabanon",
    "cabine",
    "cachette",
    "cadeau",
    "cadre",
    "cafeine",
    "caillou",
    "caisson",
    "calculer",
    "calepin",
    "calibre",
    "calmer",
    "calomnie",
    "calvaire",
    "camarade",
    "camera",
    "camion",
    "campagne",
    "canal",
    "caneton",
    "canon",
    "cantine",
    "canular",
    "capable",
    "caporal",
    "caprice",
    "capsule",
    "capter",
    "capuche",
    "carabine",
    "carbone",
    "caresser",
    "caribou",
    "carnage",
    "carotte",
    "carreau",
    "carton",
    "cascade",
    "casier",
    "casque",
    "cassure",
    "causer",
    "caution",
    "cavalier",
    "caverne",
    "caviar",
    "cedille",
    "ceinture",
    "celeste",
    "cellule",
    "cendrier",
    "censurer",
    "central",
    "cercle",
    "cerebral",
    "cerise",
    "cerner",
    "cerveau",
    "cesser",
    "chagrin",
    "chaise",
    "chaleur",
    "chambre",
    "chance",
    "chapitre",
    "charbon",
    "chasseur",
    "chaton",
    "chausson",
    "chavirer",
    "chemise",
    "chenille",
    "chequier",
    "chercher",
    "cheval",
    "chien",
    "chiffre",
    "chignon",
    "chimere",
    "chiot",
    "chlorure",
    "chocolat",
    "choisir",
    "chose",
    "chouette",
    "chrome",
    "chute",
    "cigare",
    "cigogne",
    "cimenter",
    "cinema",
    "cintrer",
    "circuler",
    "cirer",
    "cirque",
    "citerne",
    "citoyen",
    "citron",
    "civil",
    "clairon",
    "clameur",
    "claquer",
    "classe",
    "clavier",
    "client",
    "cligner",
    "climat",
    "clivage",
    "cloche",
    "clonage",
    "cloporte",
    "cobalt",
    "cobra",
    "cocasse",
    "cocotier",
    "coder",
    "codifier",
    "coffre",
    "cogner",
    "cohesion",
    "coiffer",
    "coincer",
    "colere",
    "colibri",
    "colline",
    "colmater",
    "colonel",
    "combat",
    "comedie",
    "commande",
    "compact",
    "concert",
    "conduire",
    "confier",
    "congeler",
    "connoter",
    "consonne",
    "contact",
    "convexe",
    "copain",
    "copie",
    "corail",
    "corbeau",
    "cordage",
    "corniche",
    "corpus",
    "correct",
    "cortege",
    "cosmique",
    "costume",
    "coton",
    "coude",
    "coupure",
    "courage",
    "couteau",
    "couvrir",
    "coyote",
    "crabe",
    "crainte",
    "cravate",
    "crayon",
    "creature",
    "crediter",
    "cremeux",
    "creuser",
    "crevette",
    "cribler",
    "crier",
    "cristal",
    "critere",
    "croire",
    "croquer",
    "crotale",
    "crucial",
    "cruel",
    "crypter",
    "cubique",
    "cueillir",
    "cuillere",
    "cuisine",
    "cuivre",
    "culminer",
    "cultiver",
    "cumuler",
    "cupide",
    "curatif",
    "curseur",
    "cyanure",
    "cycle",
    "cylindre",
    "cynique",
    "daigner",
    "damier",
    "danger",
    "danseur",
    "dauphin",
    "debattre",
    "debiter",
    "deborder",
    "debrider",
    "debutant",
    "decaler",
    "decembre",
    "dechirer",
    "decider",
    "declarer",
    "decorer",
    "decrire",
    "decupler",
    "dedale",
    "deductif",
    "deesse",
    "defensif",
    "defiler",
    "defrayer",
    "degager",
    "degivrer",
    "deglutir",
    "degrafer",
    "dejeuner",
    "delice",
    "deloger",
    "demander",
    "demeurer",
    "demolir",
    "denicher",
    "denouer",
    "dentelle",
    "denuder",
    "depart",
    "depenser",
    "dephaser",
    "deplacer",
    "deposer",
    "deranger",
    "derober",
    "desastre",
    "descente",
    "desert",
    "designer",
    "desobeir",
    "dessiner",
    "destrier",
    "detacher",
    "detester",
    "detourer",
    "detresse",
    "devancer",
    "devenir",
    "deviner",
    "devoir",
    "diable",
    "dialogue",
    "diamant",
    "dicter",
    "differer",
    "digerer",
    "digital",
    "digne",
    "diluer",
    "dimanche",
    "diminuer",
    "dioxyde",
    "directif",
    "diriger",
    "discuter",
    "disposer",
    "dissiper",
    "distance",
    "divertir",
    "diviser",
    "docile",
    "docteur",
    "dogme",
    "doigt",
    "domaine",
    "domicile",
    "dompter",
    "donateur",
    "donjon",
    "donner",
    "dopamine",
    "dortoir",
    "dorure",
    "dosage",
    "doseur",
    "dossier",
    "dotation",
    "douanier",
    "double",
    "douceur",
    "douter",
    "doyen",
    "dragon",
    "draper",
    "dresser",
    "dribbler",
    "droiture",
    "duperie",
    "duplexe",
    "durable",
    "durcir",
    "dynastie",
    "eblouir",
    "ecarter",
    "echarpe",
    "echelle",
    "eclairer",
    "eclipse",
    "eclore",
    "ecluse",
    "ecole",
    "economie",
    "ecorce",
    "ecouter",
    "ecraser",
    "ecremer",
    "ecrivain",
    "ecrou",
    "ecume",
    "ecureuil",
    "edifier",
    "eduquer",
    "effacer",
    "effectif",
    "effigie",
    "effort",
    "effrayer",
    "effusion",
    "egaliser",
    "egarer",
    "ejecter",
    "elaborer",
    "elargir",
    "electron",
    "elegant",
    "elephant",
    "eleve",
    "eligible",
    "elitisme",
    "eloge",
    "elucider",
    "eluder",
    "emballer",
    "embellir",
    "embryon",
    "emeraude",
    "emission",
    "emmener",
    "emotion",
    "emouvoir",
    "empereur",
    "employer",
    "emporter",
    "emprise",
    "emulsion",
    "encadrer",
    "enchere",
    "enclave",
    "encoche",
    "endiguer",
    "endosser",
    "endroit",
    "enduire",
    "energie",
    "enfance",
    "enfermer",
    "enfouir",
    "engager",
    "engin",
    "englober",
    "enigme",
    "enjamber",
    "enjeu",
    "enlever",
    "ennemi",
    "ennuyeux",
    "enrichir",
    "enrobage",
    "enseigne",
    "entasser",
    "entendre",
    "entier",
    "entourer",
    "entraver",
    "enumerer",
    "envahir",
    "enviable",
    "envoyer",
    "enzyme",
    "eolien",
    "epaissir",
    "epargne",
    "epatant",
    "epaule",
    "epicerie",
    "epidemie",
    "epier",
    "epilogue",
    "epine",
    "episode",
    "epitaphe",
    "epoque",
    "epreuve",
    "eprouver",
    "epuisant",
    "equerre",
    "equipe",
    "eriger",
    "erosion",
    "erreur",
    "eruption",
    "escalier",
    "espadon",
    "espece",
    "espiegle",
    "espoir",
    "esprit",
    "esquiver",
    "essayer",
    "essence",
    "essieu",
    "essorer",
    "estime",
    "estomac",
    "estrade",
    "etagere",
    "etaler",
    "etanche",
    "etatique",
    "eteindre",
    "etendoir",
    "eternel",
    "ethanol",
    "ethique",
    "ethnie",
    "etirer",
    "etoffer",
    "etoile",
    "etonnant",
    "etourdir",
    "etrange",
    "etroit",
    "etude",
    "euphorie",
    "evaluer",
    "evasion",
    "eventail",
    "evidence",
    "eviter",
    "evolutif",
    "evoquer",
    "exact",
    "exagerer",
    "exaucer",
    "exceller",
    "excitant",
    "exclusif",
    "excuse",
    "executer",
    "exemple",
    "exercer",
    "exhaler",
    "exhorter",
    "exigence",
    "exiler",
    "exister",
    "exotique",
    "expedier",
    "explorer",
    "exposer",
    "exprimer",
    "exquis",
    "extensif",
    "extraire",
    "exulter",
    "fable",
    "fabuleux",
    "facette",
    "facile",
    "facture",
    "faiblir",
    "falaise",
    "fameux",
    "famille",
    "farceur",
    "farfelu",
    "farine",
    "farouche",
    "fasciner",
    "fatal",
    "fatigue",
    "faucon",
    "fautif",
    "faveur",
    "favori",
    "febrile",
    "feconder",
    "federer",
    "felin",
    "femme",
    "femur",
    "fendoir",
    "feodal",
    "fermer",
    "feroce",
    "ferveur",
    "festival",
    "feuille",
    "feutre",
    "fevrier",
    "fiasco",
    "ficeler",
    "fictif",
    "fidele",
    "figure",
    "filature",
    "filetage",
    "filiere",
    "filleul",
    "filmer",
    "filou",
    "filtrer",
    "financer",
    "finir",
    "fiole",
    "firme",
    "fissure",
    "fixer",
    "flairer",
    "flamme",
    "flasque",
    "flatteur",
    "fleau",
    "fleche",
    "fleur",
    "flexion",
    "flocon",
    "flore",
    "fluctuer",
    "fluide",
    "fluvial",
    "folie",
    "fonderie",
    "fongible",
    "fontaine",
    "forcer",
    "forgeron",
    "formuler",
    "fortune",
    "fossile",
    "foudre",
    "fougere",
    "fouiller",
    "foulure",
    "fourmi",
    "fragile",
    "fraise",
    "franchir",
    "frapper",
    "frayeur",
    "fregate",
    "freiner",
    "frelon",
    "fremir",
    "frenesie",
    "frere",
    "friable",
    "friction",
    "frisson",
    "frivole",
    "froid",
    "fromage",
    "frontal",
    "frotter",
    "fruit",
    "fugitif",
    "fuite",
    "fureur",
    "furieux",
    "furtif",
    "fusion",
    "futur",
    "gagner",
    "galaxie",
    "galerie",
    "gambader",
    "garantir",
    "gardien",
    "garnir",
    "garrigue",
    "gazelle",
    "gazon",
    "geant",
    "gelatine",
    "gelule",
    "gendarme",
    "general",
    "genie",
    "genou",
    "gentil",
    "geologie",
    "geometre",
    "geranium",
    "germe",
    "gestuel",
    "geyser",
    "gibier",
    "gicler",
    "girafe",
    "givre",
    "glace",
    "glaive",
    "glisser",
    "globe",
    "gloire",
    "glorieux",
    "golfeur",
    "gomme",
    "gonfler",
    "gorge",
    "gorille",
    "goudron",
    "gouffre",
    "goulot",
    "goupille",
    "gourmand",
    "goutte",
    "graduel",
    "graffiti",
    "graine",
    "grand",
    "grappin",
    "gratuit",
    "gravir",
    "grenat",
    "griffure",
    "griller",
    "grimper",
    "grogner",
    "gronder",
    "grotte",
    "groupe",
    "gruger",
    "grutier",
    "gruyere",
    "guepard",
    "guerrier",
    "guide",
    "guimauve",
    "guitare",
    "gustatif",
    "gymnaste",
    "gyrostat",
    "habitude",
    "hachoir",
    "halte",
    "hameau",
    "hangar",
    "hanneton",
    "haricot",
    "harmonie",
    "harpon",
    "hasard",
    "helium",
    "hematome",
    "herbe",
    "herisson",
    "hermine",
    "heron",
    "hesiter",
    "heureux",
    "hiberner",
    "hibou",
    "hilarant",
    "histoire",
    "hiver",
    "homard",
    "hommage",
    "homogene",
    "honneur",
    "honorer",
    "honteux",
    "horde",
    "horizon",
    "horloge",
    "hormone",
    "horrible",
    "houleux",
    "housse",
    "hublot",
    "huileux",
    "humain",
    "humble",
    "humide",
    "humour",
    "hurler",
    "hydromel",
    "hygiene",
    "hymne",
    "hypnose",
    "idylle",
    "ignorer",
    "iguane",
    "illicite",
    "illusion",
    "image",
    "imbiber",
    "imiter",
    "immense",
    "immobile",
    "immuable",
    "impact",
    "imperial",
    "implorer",
    "imposer",
    "imprimer",
    "imputer",
    "incarner",
    "incendie",
    "incident",
    "incliner",
    "incolore",
    "indexer",
    "indice",
    "inductif",
    "inedit",
    "ineptie",
    "inexact",
    "infini",
    "infliger",
    "informer",
    "infusion",
    "ingerer",
    "inhaler",
    "inhiber",
    "injecter",
    "injure",
    "innocent",
    "inoculer",
    "inonder",
    "inscrire",
    "insecte",
    "insigne",
    "insolite",
    "inspirer",
    "instinct",
    "insulter",
    "intact",
    "intense",
    "intime",
    "intrigue",
    "intuitif",
    "inutile",
    "invasion",
    "inventer",
    "inviter",
    "invoquer",
    "ironique",
    "irradier",
    "irreel",
    "irriter",
    "isoler",
    "ivoire",
    "ivresse",
    "jaguar",
    "jaillir",
    "jambe",
    "janvier",
    "jardin",
    "jauger",
    "jaune",
    "javelot",
    "jetable",
    "jeton",
    "jeudi",
    "jeunesse",
    "joindre",
    "joncher",
    "jongler",
    "joueur",
    "jouissif",
    "journal",
    "jovial",
    "joyau",
    "joyeux",
    "jubiler",
    "jugement",
    "junior",
    "jupon",
    "juriste",
    "justice",
    "juteux",
    "juvenile",
    "kayak",
    "kimono",
    "kiosque",
    "label",
    "labial",
    "labourer",
    "lacerer",
    "lactose",
    "lagune",
    "laine",
    "laisser",
    "laitier",
    "lambeau",
    "lamelle",
    "lampe",
    "lanceur",
    "langage",
    "lanterne",
    "lapin",
    "largeur",
    "larme",
    "laurier",
    "lavabo",
    "lavoir",
    "lecture",
    "legal",
    "leger",
    "legume",
    "lessive",
    "lettre",
    "levier",
    "lexique",
    "lezard",
    "liasse",
    "liberer",
    "libre",
    "licence",
    "licorne",
    "liege",
    "lievre",
    "ligature",
    "ligoter",
    "ligue",
    "limer",
    "limite",
    "limonade",
    "limpide",
    "lineaire",
    "lingot",
    "lionceau",
    "liquide",
    "lisiere",
    "lister",
    "lithium",
    "litige",
    "littoral",
    "livreur",
    "logique",
    "lointain",
    "loisir",
    "lombric",
    "loterie",
    "louer",
    "lourd",
    "loutre",
    "louve",
    "loyal",
    "lubie",
    "lucide",
    "lucratif",
    "lueur",
    "lugubre",
    "luisant",
    "lumiere",
    "lunaire",
    "lundi",
    "luron",
    "lutter",
    "luxueux",
    "machine",
    "magasin",
    "magenta",
    "magique",
    "maigre",
    "maillon",
    "maintien",
    "mairie",
    "maison",
    "majorer",
    "malaxer",
    "malefice",
    "malheur",
    "malice",
    "mallette",
    "mammouth",
    "mandater",
    "maniable",
    "manquant",
    "manteau",
    "manuel",
    "marathon",
    "marbre",
    "marchand",
    "mardi",
    "maritime",
    "marqueur",
    "marron",
    "marteler",
    "mascotte",
    "massif",
    "materiel",
    "matiere",
    "matraque",
    "maudire",
    "maussade",
    "mauve",
    "maximal",
    "mechant",
    "meconnu",
    "medaille",
    "medecin",
    "mediter",
    "meduse",
    "meilleur",
    "melange",
    "melodie",
    "membre",
    "memoire",
    "menacer",
    "mener",
    "menhir",
    "mensonge",
    "mentor",
    "mercredi",
    "merite",
    "merle",
    "messager",
    "mesure",
    "metal",
    "meteore",
    "methode",
    "metier",
    "meuble",
    "miauler",
    "microbe",
    "miette",
    "mignon",
    "migrer",
    "milieu",
    "million",
    "mimique",
    "mince",
    "mineral",
    "minimal",
    "minorer",
    "minute",
    "miracle",
    "miroiter",
    "missile",
    "mixte",
    "mobile",
    "moderne",
    "moelleux",
    "mondial",
    "moniteur",
    "monnaie",
    "monotone",
    "monstre",
    "montagne",
    "monument",
    "moqueur",
    "morceau",
    "morsure",
    "mortier",
    "moteur",
    "motif",
    "mouche",
    "moufle",
    "moulin",
    "mousson",
    "mouton",
    "mouvant",
    "multiple",
    "munition",
    "muraille",
    "murene",
    "murmure",
    "muscle",
    "museum",
    "musicien",
    "mutation",
    "muter",
    "mutuel",
    "myriade",
    "myrtille",
    "mystere",
    "mythique",
    "nageur",
    "nappe",
    "narquois",
    "narrer",
    "natation",
    "nation",
    "nature",
    "naufrage",
    "nautique",
    "navire",
    "nebuleux",
    "nectar",
    "nefaste",
    "negation",
    "negliger",
    "negocier",
    "neige",
    "nerveux",
    "nettoyer",
    "neurone",
    "neutron",
    "neveu",
    "niche",
    "nickel",
    "nitrate",
    "niveau",
    "noble",
    "nocif",
    "nocturne",
    "noirceur",
    "noisette",
    "nomade",
    "nombreux",
    "nommer",
    "normatif",
    "notable",
    "notifier",
    "notoire",
    "nourrir",
    "nouveau",
    "novateur",
    "novembre",
    "novice",
    "nuage",
    "nuancer",
    "nuire",
    "nuisible",
    "numero",
    "nuptial",
    "nuque",
    "nutritif",
    "obeir",
    "objectif",
    "obliger",
    "obscur",
    "observer",
    "obstacle",
    "obtenir",
    "obturer",
    "occasion",
    "occuper",
    "ocean",
    "octobre",
    "octroyer",
    "octupler",
    "oculaire",
    "odeur",
    "odorant",
    "offenser",
    "officier",
    "offrir",
    "ogive",
    "oiseau",
    "oisillon",
    "olfactif",
    "olivier",
    "ombrage",
    "omettre",
    "onctueux",
    "onduler",
    "onereux",
    "onirique",
    "opale",
    "opaque",
    "operer",
    "opinion",
    "opportun",
    "opprimer",
    "opter",
    "optique",
    "orageux",
    "orange",
    "orbite",
    "ordonner",
    "oreille",
    "organe",
    "orgueil",
    "orifice",
    "ornement",
    "orque",
    "ortie",
    "osciller",
    "osmose",
    "ossature",
    "otarie",
    "ouragan",
    "ourson",
    "outil",
    "outrager",
    "ouvrage",
    "ovation",
    "oxyde",
    "oxygene",
    "ozone",
    "paisible",
    "palace",
    "palmares",
    "palourde",
    "palper",
    "panache",
    "panda",
    "pangolin",
    "paniquer",
    "panneau",
    "panorama",
    "pantalon",
    "papaye",
    "papier",
    "papoter",
    "papyrus",
    "paradoxe",
    "parcelle",
    "paresse",
    "parfumer",
    "parler",
    "parole",
    "parrain",
    "parsemer",
    "partager",
    "parure",
    "parvenir",
    "passion",
    "pasteque",
    "paternel",
    "patience",
    "patron",
    "pavillon",
    "pavoiser",
    "payer",
    "paysage",
    "peigne",
    "peintre",
    "pelage",
    "pelican",
    "pelle",
    "pelouse",
    "peluche",
    "pendule",
    "penetrer",
    "penible",
    "pensif",
    "penurie",
    "pepite",
    "peplum",
    "perdrix",
    "perforer",
    "periode",
    "permuter",
    "perplexe",
    "persil",
    "perte",
    "peser",
    "petale",
    "petit",
    "petrir",
    "peuple",
    "pharaon",
    "phobie",
    "phoque",
    "photon",
    "phrase",
    "physique",
    "piano",
    "pictural",
    "piece",
    "pierre",
    "pieuvre",
    "pilote",
    "pinceau",
    "pipette",
    "piquer",
    "pirogue",
    "piscine",
    "piston",
    "pivoter",
    "pixel",
    "pizza",
    "placard",
    "plafond",
    "plaisir",
    "planer",
    "plaque",
    "plastron",
    "plateau",
    "pleurer",
    "plexus",
    "pliage",
    "plomb",
    "plonger",
    "pluie",
    "plumage",
    "pochette",
    "poesie",
    "poete",
    "pointe",
    "poirier",
    "poisson",
    "poivre",
    "polaire",
    "policier",
    "pollen",
    "polygone",
    "pommade",
    "pompier",
    "ponctuel",
    "ponderer",
    "poney",
    "portique",
    "position",
    "posseder",
    "posture",
    "potager",
    "poteau",
    "potion",
    "pouce",
    "poulain",
    "poumon",
    "pourpre",
    "poussin",
    "pouvoir",
    "prairie",
    "pratique",
    "precieux",
    "predire",
    "prefixe",
    "prelude",
    "prenom",
    "presence",
    "pretexte",
    "prevoir",
    "primitif",
    "prince",
    "prison",
    "priver",
    "probleme",
    "proceder",
    "prodige",
    "profond",
    "progres",
    "proie",
    "projeter",
    "prologue",
    "promener",
    "propre",
    "prospere",
    "proteger",
    "prouesse",
    "proverbe",
    "prudence",
    "pruneau",
    "psychose",
    "public",
    "puceron",
    "puiser",
    "pulpe",
    "pulsar",
    "punaise",
    "punitif",
    "pupitre",
    "purifier",
    "puzzle",
    "pyramide",
    "quasar",
    "querelle",
    "question",
    "quietude",
    "quitter",
    "quotient",
    "racine",
    "raconter",
    "radieux",
    "ragondin",
    "raideur",
    "raisin",
    "ralentir",
    "rallonge",
    "ramasser",
    "rapide",
    "rasage",
    "ratisser",
    "ravager",
    "ravin",
    "rayonner",
    "reactif",
    "reagir",
    "realiser",
    "reanimer",
    "recevoir",
    "reciter",
    "reclamer",
    "recolter",
    "recruter",
    "reculer",
    "recycler",
    "rediger",
    "redouter",
    "refaire",
    "reflexe",
    "reformer",
    "refrain",
    "refuge",
    "regalien",
    "region",
    "reglage",
    "regulier",
    "reiterer",
    "rejeter",
    "rejouer",
    "relatif",
    "relever",
    "relief",
    "remarque",
    "remede",
    "remise",
    "remonter",
    "remplir",
    "remuer",
    "renard",
    "renfort",
    "renifler",
    "renoncer",
    "rentrer",
    "renvoi",
    "replier",
    "reporter",
    "reprise",
    "reptile",
    "requin",
    "reserve",
    "resineux",
    "resoudre",
    "respect",
    "rester",
    "resultat",
    "retablir",
    "retenir",
    "reticule",
    "retomber",
    "retracer",
    "reunion",
    "reussir",
    "revanche",
    "revivre",
    "revolte",
    "revulsif",
    "richesse",
    "rideau",
    "rieur",
    "rigide",
    "rigoler",
    "rincer",
    "riposter",
    "risible",
    "risque",
    "rituel",
    "rival",
    "riviere",
    "rocheux",
    "romance",
    "rompre",
    "ronce",
    "rondin",
    "roseau",
    "rosier",
    "rotatif",
    "rotor",
    "rotule",
    "rouge",
    "rouille",
    "rouleau",
    "routine",
    "royaume",
    "ruban",
    "rubis",
    "ruche",
    "ruelle",
    "rugueux",
    "ruiner",
    "ruisseau",
    "ruser",
    "rustique",
    "rythme",
    "sabler",
    "saboter",
    "sabre",
    "sacoche",
    "safari",
    "sagesse",
    "saisir",
    "salade",
    "salive",
    "salon",
    "saluer",
    "samedi",
    "sanction",
    "sanglier",
    "sarcasme",
    "sardine",
    "saturer",
    "saugrenu",
    "saumon",
    "sauter",
    "sauvage",
    "savant",
    "savonner",
    "scalpel",
    "scandale",
    "scelerat",
    "scenario",
    "sceptre",
    "schema",
    "science",
    "scinder",
    "score",
    "scrutin",
    "sculpter",
    "seance",
    "secable",
    "secher",
    "secouer",
    "secreter",
    "sedatif",
    "seduire",
    "seigneur",
    "sejour",
    "selectif",
    "semaine",
    "sembler",
    "semence",
    "seminal",
    "senateur",
    "sensible",
    "sentence",
    "separer",
    "sequence",
    "serein",
    "sergent",
    "serieux",
    "serrure",
    "serum",
    "service",
    "sesame",
    "sevir",
    "sevrage",
    "sextuple",
    "sideral",
    "siecle",
    "sieger",
    "siffler",
    "sigle",
    "signal",
    "silence",
    "silicium",
    "simple",
    "sincere",
    "sinistre",
    "siphon",
    "sirop",
    "sismique",
    "situer",
    "skier",
    "social",
    "socle",
    "sodium",
    "soigneux",
    "soldat",
    "soleil",
    "solitude",
    "soluble",
    "sombre",
    "sommeil",
    "somnoler",
    "sonde",
    "songeur",
    "sonnette",
    "sonore",
    "sorcier",
    "sortir",
    "sosie",
    "sottise",
    "soucieux",
    "soudure",
    "souffle",
    "soulever",
    "soupape",
    "source",
    "soutirer",
    "souvenir",
    "spacieux",
    "spatial",
    "special",
    "sphere",
    "spiral",
    "stable",
    "station",
    "sternum",
    "stimulus",
    "stipuler",
    "strict",
    "studieux",
    "stupeur",
    "styliste",
    "sublime",
    "substrat",
    "subtil",
    "subvenir",
    "succes",
    "sucre",
    "suffixe",
    "suggerer",
    "suiveur",
    "sulfate",
    "superbe",
    "supplier",
    "surface",
    "suricate",
    "surmener",
    "surprise",
    "sursaut",
    "survie",
    "suspect",
    "syllabe",
    "symbole",
    "symetrie",
    "synapse",
    "syntaxe",
    "systeme",
    "tabac",
    "tablier",
    "tactile",
    "tailler",
    "talent",
    "talisman",
    "talonner",
    "tambour",
    "tamiser",
    "tangible",
    "tapis",
    "taquiner",
    "tarder",
    "tarif",
    "tartine",
    "tasse",
    "tatami",
    "tatouage",
    "taupe",
    "taureau",
    "taxer",
    "temoin",
    "temporel",
    "tenaille",
    "tendre",
    "teneur",
    "tenir",
    "tension",
    "terminer",
    "terne",
    "terrible",
    "tetine",
    "texte",
    "theme",
    "theorie",
    "therapie",
    "thorax",
    "tibia",
    "tiede",
    "timide",
    "tirelire",
    "tiroir",
    "tissu",
    "titane",
    "titre",
    "tituber",
    "toboggan",
    "tolerant",
    "tomate",
    "tonique",
    "tonneau",
    "toponyme",
    "torche",
    "tordre",
    "tornade",
    "torpille",
    "torrent",
    "torse",
    "tortue",
    "totem",
    "toucher",
    "tournage",
    "tousser",
    "toxine",
    "traction",
    "trafic",
    "tragique",
    "trahir",
    "train",
    "trancher",
    "travail",
    "trefle",
    "tremper",
    "tresor",
    "treuil",
    "triage",
    "tribunal",
    "tricoter",
    "trilogie",
    "triomphe",
    "tripler",
    "triturer",
    "trivial",
    "trombone",
    "tronc",
    "tropical",
    "troupeau",
    "tuile",
    "tulipe",
    "tumulte",
    "tunnel",
    "turbine",
    "tuteur",
    "tutoyer",
    "tuyau",
    "tympan",
    "typhon",
    "typique",
    "tyran",
    "ubuesque",
    "ultime",
    "ultrason",
    "unanime",
    "unifier",
    "union",
    "unique",
    "unitaire",
    "univers",
    "uranium",
    "urbain",
    "urticant",
    "usage",
    "usine",
    "usuel",
    "usure",
    "utile",
    "utopie",
    "vacarme",
    "vaccin",
    "vagabond",
    "vague",
    "vaillant",
    "vaincre",
    "vaisseau",
    "valable",
    "valise",
    "vallon",
    "valve",
    "vampire",
    "vanille",
    "vapeur",
    "varier",
    "vaseux",
    "vassal",
    "vaste",
    "vecteur",
    "vedette",
    "vegetal",
    "vehicule",
    "veinard",
    "veloce",
    "vendredi",
    "venerer",
    "venger",
    "venimeux",
    "ventouse",
    "verdure",
    "verin",
    "vernir",
    "verrou",
    "verser",
    "vertu",
    "veston",
    "veteran",
    "vetuste",
    "vexant",
    "vexer",
    "viaduc",
    "viande",
    "victoire",
    "vidange",
    "video",
    "vignette",
    "vigueur",
    "vilain",
    "village",
    "vinaigre",
    "violon",
    "vipere",
    "virement",
    "virtuose",
    "virus",
    "visage",
    "viseur",
    "vision",
    "visqueux",
    "visuel",
    "vital",
    "vitesse",
    "viticole",
    "vitrine",
    "vivace",
    "vivipare",
    "vocation",
    "voguer",
    "voile",
    "voisin",
    "voiture",
    "volaille",
    "volcan",
    "voltiger",
    "volume",
    "vorace",
    "vortex",
    "voter",
    "vouloir",
    "voyage",
    "voyelle",
    "wagon",
    "xenon",
    "yacht",
    "zebre",
    "zenith",
    "zeste",
    "zoologie"
  ]), $0;
}
var j0, _d;
function n9() {
  return _d || (_d = 1, j0 = [
    "abaco",
    "abbaglio",
    "abbinato",
    "abete",
    "abisso",
    "abolire",
    "abrasivo",
    "abrogato",
    "accadere",
    "accenno",
    "accusato",
    "acetone",
    "achille",
    "acido",
    "acqua",
    "acre",
    "acrilico",
    "acrobata",
    "acuto",
    "adagio",
    "addebito",
    "addome",
    "adeguato",
    "aderire",
    "adipe",
    "adottare",
    "adulare",
    "affabile",
    "affetto",
    "affisso",
    "affranto",
    "aforisma",
    "afoso",
    "africano",
    "agave",
    "agente",
    "agevole",
    "aggancio",
    "agire",
    "agitare",
    "agonismo",
    "agricolo",
    "agrumeto",
    "aguzzo",
    "alabarda",
    "alato",
    "albatro",
    "alberato",
    "albo",
    "albume",
    "alce",
    "alcolico",
    "alettone",
    "alfa",
    "algebra",
    "aliante",
    "alibi",
    "alimento",
    "allagato",
    "allegro",
    "allievo",
    "allodola",
    "allusivo",
    "almeno",
    "alogeno",
    "alpaca",
    "alpestre",
    "altalena",
    "alterno",
    "alticcio",
    "altrove",
    "alunno",
    "alveolo",
    "alzare",
    "amalgama",
    "amanita",
    "amarena",
    "ambito",
    "ambrato",
    "ameba",
    "america",
    "ametista",
    "amico",
    "ammasso",
    "ammenda",
    "ammirare",
    "ammonito",
    "amore",
    "ampio",
    "ampliare",
    "amuleto",
    "anacardo",
    "anagrafe",
    "analista",
    "anarchia",
    "anatra",
    "anca",
    "ancella",
    "ancora",
    "andare",
    "andrea",
    "anello",
    "angelo",
    "angolare",
    "angusto",
    "anima",
    "annegare",
    "annidato",
    "anno",
    "annuncio",
    "anonimo",
    "anticipo",
    "anzi",
    "apatico",
    "apertura",
    "apode",
    "apparire",
    "appetito",
    "appoggio",
    "approdo",
    "appunto",
    "aprile",
    "arabica",
    "arachide",
    "aragosta",
    "araldica",
    "arancio",
    "aratura",
    "arazzo",
    "arbitro",
    "archivio",
    "ardito",
    "arenile",
    "argento",
    "argine",
    "arguto",
    "aria",
    "armonia",
    "arnese",
    "arredato",
    "arringa",
    "arrosto",
    "arsenico",
    "arso",
    "artefice",
    "arzillo",
    "asciutto",
    "ascolto",
    "asepsi",
    "asettico",
    "asfalto",
    "asino",
    "asola",
    "aspirato",
    "aspro",
    "assaggio",
    "asse",
    "assoluto",
    "assurdo",
    "asta",
    "astenuto",
    "astice",
    "astratto",
    "atavico",
    "ateismo",
    "atomico",
    "atono",
    "attesa",
    "attivare",
    "attorno",
    "attrito",
    "attuale",
    "ausilio",
    "austria",
    "autista",
    "autonomo",
    "autunno",
    "avanzato",
    "avere",
    "avvenire",
    "avviso",
    "avvolgere",
    "azione",
    "azoto",
    "azzimo",
    "azzurro",
    "babele",
    "baccano",
    "bacino",
    "baco",
    "badessa",
    "badilata",
    "bagnato",
    "baita",
    "balcone",
    "baldo",
    "balena",
    "ballata",
    "balzano",
    "bambino",
    "bandire",
    "baraonda",
    "barbaro",
    "barca",
    "baritono",
    "barlume",
    "barocco",
    "basilico",
    "basso",
    "batosta",
    "battuto",
    "baule",
    "bava",
    "bavosa",
    "becco",
    "beffa",
    "belgio",
    "belva",
    "benda",
    "benevole",
    "benigno",
    "benzina",
    "bere",
    "berlina",
    "beta",
    "bibita",
    "bici",
    "bidone",
    "bifido",
    "biga",
    "bilancia",
    "bimbo",
    "binocolo",
    "biologo",
    "bipede",
    "bipolare",
    "birbante",
    "birra",
    "biscotto",
    "bisesto",
    "bisnonno",
    "bisonte",
    "bisturi",
    "bizzarro",
    "blando",
    "blatta",
    "bollito",
    "bonifico",
    "bordo",
    "bosco",
    "botanico",
    "bottino",
    "bozzolo",
    "braccio",
    "bradipo",
    "brama",
    "branca",
    "bravura",
    "bretella",
    "brevetto",
    "brezza",
    "briglia",
    "brillante",
    "brindare",
    "broccolo",
    "brodo",
    "bronzina",
    "brullo",
    "bruno",
    "bubbone",
    "buca",
    "budino",
    "buffone",
    "buio",
    "bulbo",
    "buono",
    "burlone",
    "burrasca",
    "bussola",
    "busta",
    "cadetto",
    "caduco",
    "calamaro",
    "calcolo",
    "calesse",
    "calibro",
    "calmo",
    "caloria",
    "cambusa",
    "camerata",
    "camicia",
    "cammino",
    "camola",
    "campale",
    "canapa",
    "candela",
    "cane",
    "canino",
    "canotto",
    "cantina",
    "capace",
    "capello",
    "capitolo",
    "capogiro",
    "cappero",
    "capra",
    "capsula",
    "carapace",
    "carcassa",
    "cardo",
    "carisma",
    "carovana",
    "carretto",
    "cartolina",
    "casaccio",
    "cascata",
    "caserma",
    "caso",
    "cassone",
    "castello",
    "casuale",
    "catasta",
    "catena",
    "catrame",
    "cauto",
    "cavillo",
    "cedibile",
    "cedrata",
    "cefalo",
    "celebre",
    "cellulare",
    "cena",
    "cenone",
    "centesimo",
    "ceramica",
    "cercare",
    "certo",
    "cerume",
    "cervello",
    "cesoia",
    "cespo",
    "ceto",
    "chela",
    "chiaro",
    "chicca",
    "chiedere",
    "chimera",
    "china",
    "chirurgo",
    "chitarra",
    "ciao",
    "ciclismo",
    "cifrare",
    "cigno",
    "cilindro",
    "ciottolo",
    "circa",
    "cirrosi",
    "citrico",
    "cittadino",
    "ciuffo",
    "civetta",
    "civile",
    "classico",
    "clinica",
    "cloro",
    "cocco",
    "codardo",
    "codice",
    "coerente",
    "cognome",
    "collare",
    "colmato",
    "colore",
    "colposo",
    "coltivato",
    "colza",
    "coma",
    "cometa",
    "commando",
    "comodo",
    "computer",
    "comune",
    "conciso",
    "condurre",
    "conferma",
    "congelare",
    "coniuge",
    "connesso",
    "conoscere",
    "consumo",
    "continuo",
    "convegno",
    "coperto",
    "copione",
    "coppia",
    "copricapo",
    "corazza",
    "cordata",
    "coricato",
    "cornice",
    "corolla",
    "corpo",
    "corredo",
    "corsia",
    "cortese",
    "cosmico",
    "costante",
    "cottura",
    "covato",
    "cratere",
    "cravatta",
    "creato",
    "credere",
    "cremoso",
    "crescita",
    "creta",
    "criceto",
    "crinale",
    "crisi",
    "critico",
    "croce",
    "cronaca",
    "crostata",
    "cruciale",
    "crusca",
    "cucire",
    "cuculo",
    "cugino",
    "cullato",
    "cupola",
    "curatore",
    "cursore",
    "curvo",
    "cuscino",
    "custode",
    "dado",
    "daino",
    "dalmata",
    "damerino",
    "daniela",
    "dannoso",
    "danzare",
    "datato",
    "davanti",
    "davvero",
    "debutto",
    "decennio",
    "deciso",
    "declino",
    "decollo",
    "decreto",
    "dedicato",
    "definito",
    "deforme",
    "degno",
    "delegare",
    "delfino",
    "delirio",
    "delta",
    "demenza",
    "denotato",
    "dentro",
    "deposito",
    "derapata",
    "derivare",
    "deroga",
    "descritto",
    "deserto",
    "desiderio",
    "desumere",
    "detersivo",
    "devoto",
    "diametro",
    "dicembre",
    "diedro",
    "difeso",
    "diffuso",
    "digerire",
    "digitale",
    "diluvio",
    "dinamico",
    "dinnanzi",
    "dipinto",
    "diploma",
    "dipolo",
    "diradare",
    "dire",
    "dirotto",
    "dirupo",
    "disagio",
    "discreto",
    "disfare",
    "disgelo",
    "disposto",
    "distanza",
    "disumano",
    "dito",
    "divano",
    "divelto",
    "dividere",
    "divorato",
    "doblone",
    "docente",
    "doganale",
    "dogma",
    "dolce",
    "domato",
    "domenica",
    "dominare",
    "dondolo",
    "dono",
    "dormire",
    "dote",
    "dottore",
    "dovuto",
    "dozzina",
    "drago",
    "druido",
    "dubbio",
    "dubitare",
    "ducale",
    "duna",
    "duomo",
    "duplice",
    "duraturo",
    "ebano",
    "eccesso",
    "ecco",
    "eclissi",
    "economia",
    "edera",
    "edicola",
    "edile",
    "editoria",
    "educare",
    "egemonia",
    "egli",
    "egoismo",
    "egregio",
    "elaborato",
    "elargire",
    "elegante",
    "elencato",
    "eletto",
    "elevare",
    "elfico",
    "elica",
    "elmo",
    "elsa",
    "eluso",
    "emanato",
    "emblema",
    "emesso",
    "emiro",
    "emotivo",
    "emozione",
    "empirico",
    "emulo",
    "endemico",
    "enduro",
    "energia",
    "enfasi",
    "enoteca",
    "entrare",
    "enzima",
    "epatite",
    "epilogo",
    "episodio",
    "epocale",
    "eppure",
    "equatore",
    "erario",
    "erba",
    "erboso",
    "erede",
    "eremita",
    "erigere",
    "ermetico",
    "eroe",
    "erosivo",
    "errante",
    "esagono",
    "esame",
    "esanime",
    "esaudire",
    "esca",
    "esempio",
    "esercito",
    "esibito",
    "esigente",
    "esistere",
    "esito",
    "esofago",
    "esortato",
    "esoso",
    "espanso",
    "espresso",
    "essenza",
    "esso",
    "esteso",
    "estimare",
    "estonia",
    "estroso",
    "esultare",
    "etilico",
    "etnico",
    "etrusco",
    "etto",
    "euclideo",
    "europa",
    "evaso",
    "evidenza",
    "evitato",
    "evoluto",
    "evviva",
    "fabbrica",
    "faccenda",
    "fachiro",
    "falco",
    "famiglia",
    "fanale",
    "fanfara",
    "fango",
    "fantasma",
    "fare",
    "farfalla",
    "farinoso",
    "farmaco",
    "fascia",
    "fastoso",
    "fasullo",
    "faticare",
    "fato",
    "favoloso",
    "febbre",
    "fecola",
    "fede",
    "fegato",
    "felpa",
    "feltro",
    "femmina",
    "fendere",
    "fenomeno",
    "fermento",
    "ferro",
    "fertile",
    "fessura",
    "festivo",
    "fetta",
    "feudo",
    "fiaba",
    "fiducia",
    "fifa",
    "figurato",
    "filo",
    "finanza",
    "finestra",
    "finire",
    "fiore",
    "fiscale",
    "fisico",
    "fiume",
    "flacone",
    "flamenco",
    "flebo",
    "flemma",
    "florido",
    "fluente",
    "fluoro",
    "fobico",
    "focaccia",
    "focoso",
    "foderato",
    "foglio",
    "folata",
    "folclore",
    "folgore",
    "fondente",
    "fonetico",
    "fonia",
    "fontana",
    "forbito",
    "forchetta",
    "foresta",
    "formica",
    "fornaio",
    "foro",
    "fortezza",
    "forzare",
    "fosfato",
    "fosso",
    "fracasso",
    "frana",
    "frassino",
    "fratello",
    "freccetta",
    "frenata",
    "fresco",
    "frigo",
    "frollino",
    "fronde",
    "frugale",
    "frutta",
    "fucilata",
    "fucsia",
    "fuggente",
    "fulmine",
    "fulvo",
    "fumante",
    "fumetto",
    "fumoso",
    "fune",
    "funzione",
    "fuoco",
    "furbo",
    "furgone",
    "furore",
    "fuso",
    "futile",
    "gabbiano",
    "gaffe",
    "galateo",
    "gallina",
    "galoppo",
    "gambero",
    "gamma",
    "garanzia",
    "garbo",
    "garofano",
    "garzone",
    "gasdotto",
    "gasolio",
    "gastrico",
    "gatto",
    "gaudio",
    "gazebo",
    "gazzella",
    "geco",
    "gelatina",
    "gelso",
    "gemello",
    "gemmato",
    "gene",
    "genitore",
    "gennaio",
    "genotipo",
    "gergo",
    "ghepardo",
    "ghiaccio",
    "ghisa",
    "giallo",
    "gilda",
    "ginepro",
    "giocare",
    "gioiello",
    "giorno",
    "giove",
    "girato",
    "girone",
    "gittata",
    "giudizio",
    "giurato",
    "giusto",
    "globulo",
    "glutine",
    "gnomo",
    "gobba",
    "golf",
    "gomito",
    "gommone",
    "gonfio",
    "gonna",
    "governo",
    "gracile",
    "grado",
    "grafico",
    "grammo",
    "grande",
    "grattare",
    "gravoso",
    "grazia",
    "greca",
    "gregge",
    "grifone",
    "grigio",
    "grinza",
    "grotta",
    "gruppo",
    "guadagno",
    "guaio",
    "guanto",
    "guardare",
    "gufo",
    "guidare",
    "ibernato",
    "icona",
    "identico",
    "idillio",
    "idolo",
    "idra",
    "idrico",
    "idrogeno",
    "igiene",
    "ignaro",
    "ignorato",
    "ilare",
    "illeso",
    "illogico",
    "illudere",
    "imballo",
    "imbevuto",
    "imbocco",
    "imbuto",
    "immane",
    "immerso",
    "immolato",
    "impacco",
    "impeto",
    "impiego",
    "importo",
    "impronta",
    "inalare",
    "inarcare",
    "inattivo",
    "incanto",
    "incendio",
    "inchino",
    "incisivo",
    "incluso",
    "incontro",
    "incrocio",
    "incubo",
    "indagine",
    "india",
    "indole",
    "inedito",
    "infatti",
    "infilare",
    "inflitto",
    "ingaggio",
    "ingegno",
    "inglese",
    "ingordo",
    "ingrosso",
    "innesco",
    "inodore",
    "inoltrare",
    "inondato",
    "insano",
    "insetto",
    "insieme",
    "insonnia",
    "insulina",
    "intasato",
    "intero",
    "intonaco",
    "intuito",
    "inumidire",
    "invalido",
    "invece",
    "invito",
    "iperbole",
    "ipnotico",
    "ipotesi",
    "ippica",
    "iride",
    "irlanda",
    "ironico",
    "irrigato",
    "irrorare",
    "isolato",
    "isotopo",
    "isterico",
    "istituto",
    "istrice",
    "italia",
    "iterare",
    "labbro",
    "labirinto",
    "lacca",
    "lacerato",
    "lacrima",
    "lacuna",
    "laddove",
    "lago",
    "lampo",
    "lancetta",
    "lanterna",
    "lardoso",
    "larga",
    "laringe",
    "lastra",
    "latenza",
    "latino",
    "lattuga",
    "lavagna",
    "lavoro",
    "legale",
    "leggero",
    "lembo",
    "lentezza",
    "lenza",
    "leone",
    "lepre",
    "lesivo",
    "lessato",
    "lesto",
    "letterale",
    "leva",
    "levigato",
    "libero",
    "lido",
    "lievito",
    "lilla",
    "limatura",
    "limitare",
    "limpido",
    "lineare",
    "lingua",
    "liquido",
    "lira",
    "lirica",
    "lisca",
    "lite",
    "litigio",
    "livrea",
    "locanda",
    "lode",
    "logica",
    "lombare",
    "londra",
    "longevo",
    "loquace",
    "lorenzo",
    "loto",
    "lotteria",
    "luce",
    "lucidato",
    "lumaca",
    "luminoso",
    "lungo",
    "lupo",
    "luppolo",
    "lusinga",
    "lusso",
    "lutto",
    "macabro",
    "macchina",
    "macero",
    "macinato",
    "madama",
    "magico",
    "maglia",
    "magnete",
    "magro",
    "maiolica",
    "malafede",
    "malgrado",
    "malinteso",
    "malsano",
    "malto",
    "malumore",
    "mana",
    "mancia",
    "mandorla",
    "mangiare",
    "manifesto",
    "mannaro",
    "manovra",
    "mansarda",
    "mantide",
    "manubrio",
    "mappa",
    "maratona",
    "marcire",
    "maretta",
    "marmo",
    "marsupio",
    "maschera",
    "massaia",
    "mastino",
    "materasso",
    "matricola",
    "mattone",
    "maturo",
    "mazurca",
    "meandro",
    "meccanico",
    "mecenate",
    "medesimo",
    "meditare",
    "mega",
    "melassa",
    "melis",
    "melodia",
    "meninge",
    "meno",
    "mensola",
    "mercurio",
    "merenda",
    "merlo",
    "meschino",
    "mese",
    "messere",
    "mestolo",
    "metallo",
    "metodo",
    "mettere",
    "miagolare",
    "mica",
    "micelio",
    "michele",
    "microbo",
    "midollo",
    "miele",
    "migliore",
    "milano",
    "milite",
    "mimosa",
    "minerale",
    "mini",
    "minore",
    "mirino",
    "mirtillo",
    "miscela",
    "missiva",
    "misto",
    "misurare",
    "mitezza",
    "mitigare",
    "mitra",
    "mittente",
    "mnemonico",
    "modello",
    "modifica",
    "modulo",
    "mogano",
    "mogio",
    "mole",
    "molosso",
    "monastero",
    "monco",
    "mondina",
    "monetario",
    "monile",
    "monotono",
    "monsone",
    "montato",
    "monviso",
    "mora",
    "mordere",
    "morsicato",
    "mostro",
    "motivato",
    "motosega",
    "motto",
    "movenza",
    "movimento",
    "mozzo",
    "mucca",
    "mucosa",
    "muffa",
    "mughetto",
    "mugnaio",
    "mulatto",
    "mulinello",
    "multiplo",
    "mummia",
    "munto",
    "muovere",
    "murale",
    "musa",
    "muscolo",
    "musica",
    "mutevole",
    "muto",
    "nababbo",
    "nafta",
    "nanometro",
    "narciso",
    "narice",
    "narrato",
    "nascere",
    "nastrare",
    "naturale",
    "nautica",
    "naviglio",
    "nebulosa",
    "necrosi",
    "negativo",
    "negozio",
    "nemmeno",
    "neofita",
    "neretto",
    "nervo",
    "nessuno",
    "nettuno",
    "neutrale",
    "neve",
    "nevrotico",
    "nicchia",
    "ninfa",
    "nitido",
    "nobile",
    "nocivo",
    "nodo",
    "nome",
    "nomina",
    "nordico",
    "normale",
    "norvegese",
    "nostrano",
    "notare",
    "notizia",
    "notturno",
    "novella",
    "nucleo",
    "nulla",
    "numero",
    "nuovo",
    "nutrire",
    "nuvola",
    "nuziale",
    "oasi",
    "obbedire",
    "obbligo",
    "obelisco",
    "oblio",
    "obolo",
    "obsoleto",
    "occasione",
    "occhio",
    "occidente",
    "occorrere",
    "occultare",
    "ocra",
    "oculato",
    "odierno",
    "odorare",
    "offerta",
    "offrire",
    "offuscato",
    "oggetto",
    "oggi",
    "ognuno",
    "olandese",
    "olfatto",
    "oliato",
    "oliva",
    "ologramma",
    "oltre",
    "omaggio",
    "ombelico",
    "ombra",
    "omega",
    "omissione",
    "ondoso",
    "onere",
    "onice",
    "onnivoro",
    "onorevole",
    "onta",
    "operato",
    "opinione",
    "opposto",
    "oracolo",
    "orafo",
    "ordine",
    "orecchino",
    "orefice",
    "orfano",
    "organico",
    "origine",
    "orizzonte",
    "orma",
    "ormeggio",
    "ornativo",
    "orologio",
    "orrendo",
    "orribile",
    "ortensia",
    "ortica",
    "orzata",
    "orzo",
    "osare",
    "oscurare",
    "osmosi",
    "ospedale",
    "ospite",
    "ossa",
    "ossidare",
    "ostacolo",
    "oste",
    "otite",
    "otre",
    "ottagono",
    "ottimo",
    "ottobre",
    "ovale",
    "ovest",
    "ovino",
    "oviparo",
    "ovocito",
    "ovunque",
    "ovviare",
    "ozio",
    "pacchetto",
    "pace",
    "pacifico",
    "padella",
    "padrone",
    "paese",
    "paga",
    "pagina",
    "palazzina",
    "palesare",
    "pallido",
    "palo",
    "palude",
    "pandoro",
    "pannello",
    "paolo",
    "paonazzo",
    "paprica",
    "parabola",
    "parcella",
    "parere",
    "pargolo",
    "pari",
    "parlato",
    "parola",
    "partire",
    "parvenza",
    "parziale",
    "passivo",
    "pasticca",
    "patacca",
    "patologia",
    "pattume",
    "pavone",
    "peccato",
    "pedalare",
    "pedonale",
    "peggio",
    "peloso",
    "penare",
    "pendice",
    "penisola",
    "pennuto",
    "penombra",
    "pensare",
    "pentola",
    "pepe",
    "pepita",
    "perbene",
    "percorso",
    "perdonato",
    "perforare",
    "pergamena",
    "periodo",
    "permesso",
    "perno",
    "perplesso",
    "persuaso",
    "pertugio",
    "pervaso",
    "pesatore",
    "pesista",
    "peso",
    "pestifero",
    "petalo",
    "pettine",
    "petulante",
    "pezzo",
    "piacere",
    "pianta",
    "piattino",
    "piccino",
    "picozza",
    "piega",
    "pietra",
    "piffero",
    "pigiama",
    "pigolio",
    "pigro",
    "pila",
    "pilifero",
    "pillola",
    "pilota",
    "pimpante",
    "pineta",
    "pinna",
    "pinolo",
    "pioggia",
    "piombo",
    "piramide",
    "piretico",
    "pirite",
    "pirolisi",
    "pitone",
    "pizzico",
    "placebo",
    "planare",
    "plasma",
    "platano",
    "plenario",
    "pochezza",
    "poderoso",
    "podismo",
    "poesia",
    "poggiare",
    "polenta",
    "poligono",
    "pollice",
    "polmonite",
    "polpetta",
    "polso",
    "poltrona",
    "polvere",
    "pomice",
    "pomodoro",
    "ponte",
    "popoloso",
    "porfido",
    "poroso",
    "porpora",
    "porre",
    "portata",
    "posa",
    "positivo",
    "possesso",
    "postulato",
    "potassio",
    "potere",
    "pranzo",
    "prassi",
    "pratica",
    "precluso",
    "predica",
    "prefisso",
    "pregiato",
    "prelievo",
    "premere",
    "prenotare",
    "preparato",
    "presenza",
    "pretesto",
    "prevalso",
    "prima",
    "principe",
    "privato",
    "problema",
    "procura",
    "produrre",
    "profumo",
    "progetto",
    "prolunga",
    "promessa",
    "pronome",
    "proposta",
    "proroga",
    "proteso",
    "prova",
    "prudente",
    "prugna",
    "prurito",
    "psiche",
    "pubblico",
    "pudica",
    "pugilato",
    "pugno",
    "pulce",
    "pulito",
    "pulsante",
    "puntare",
    "pupazzo",
    "pupilla",
    "puro",
    "quadro",
    "qualcosa",
    "quasi",
    "querela",
    "quota",
    "raccolto",
    "raddoppio",
    "radicale",
    "radunato",
    "raffica",
    "ragazzo",
    "ragione",
    "ragno",
    "ramarro",
    "ramingo",
    "ramo",
    "randagio",
    "rantolare",
    "rapato",
    "rapina",
    "rappreso",
    "rasatura",
    "raschiato",
    "rasente",
    "rassegna",
    "rastrello",
    "rata",
    "ravveduto",
    "reale",
    "recepire",
    "recinto",
    "recluta",
    "recondito",
    "recupero",
    "reddito",
    "redimere",
    "regalato",
    "registro",
    "regola",
    "regresso",
    "relazione",
    "remare",
    "remoto",
    "renna",
    "replica",
    "reprimere",
    "reputare",
    "resa",
    "residente",
    "responso",
    "restauro",
    "rete",
    "retina",
    "retorica",
    "rettifica",
    "revocato",
    "riassunto",
    "ribadire",
    "ribelle",
    "ribrezzo",
    "ricarica",
    "ricco",
    "ricevere",
    "riciclato",
    "ricordo",
    "ricreduto",
    "ridicolo",
    "ridurre",
    "rifasare",
    "riflesso",
    "riforma",
    "rifugio",
    "rigare",
    "rigettato",
    "righello",
    "rilassato",
    "rilevato",
    "rimanere",
    "rimbalzo",
    "rimedio",
    "rimorchio",
    "rinascita",
    "rincaro",
    "rinforzo",
    "rinnovo",
    "rinomato",
    "rinsavito",
    "rintocco",
    "rinuncia",
    "rinvenire",
    "riparato",
    "ripetuto",
    "ripieno",
    "riportare",
    "ripresa",
    "ripulire",
    "risata",
    "rischio",
    "riserva",
    "risibile",
    "riso",
    "rispetto",
    "ristoro",
    "risultato",
    "risvolto",
    "ritardo",
    "ritegno",
    "ritmico",
    "ritrovo",
    "riunione",
    "riva",
    "riverso",
    "rivincita",
    "rivolto",
    "rizoma",
    "roba",
    "robotico",
    "robusto",
    "roccia",
    "roco",
    "rodaggio",
    "rodere",
    "roditore",
    "rogito",
    "rollio",
    "romantico",
    "rompere",
    "ronzio",
    "rosolare",
    "rospo",
    "rotante",
    "rotondo",
    "rotula",
    "rovescio",
    "rubizzo",
    "rubrica",
    "ruga",
    "rullino",
    "rumine",
    "rumoroso",
    "ruolo",
    "rupe",
    "russare",
    "rustico",
    "sabato",
    "sabbiare",
    "sabotato",
    "sagoma",
    "salasso",
    "saldatura",
    "salgemma",
    "salivare",
    "salmone",
    "salone",
    "saltare",
    "saluto",
    "salvo",
    "sapere",
    "sapido",
    "saporito",
    "saraceno",
    "sarcasmo",
    "sarto",
    "sassoso",
    "satellite",
    "satira",
    "satollo",
    "saturno",
    "savana",
    "savio",
    "saziato",
    "sbadiglio",
    "sbalzo",
    "sbancato",
    "sbarra",
    "sbattere",
    "sbavare",
    "sbendare",
    "sbirciare",
    "sbloccato",
    "sbocciato",
    "sbrinare",
    "sbruffone",
    "sbuffare",
    "scabroso",
    "scadenza",
    "scala",
    "scambiare",
    "scandalo",
    "scapola",
    "scarso",
    "scatenare",
    "scavato",
    "scelto",
    "scenico",
    "scettro",
    "scheda",
    "schiena",
    "sciarpa",
    "scienza",
    "scindere",
    "scippo",
    "sciroppo",
    "scivolo",
    "sclerare",
    "scodella",
    "scolpito",
    "scomparto",
    "sconforto",
    "scoprire",
    "scorta",
    "scossone",
    "scozzese",
    "scriba",
    "scrollare",
    "scrutinio",
    "scuderia",
    "scultore",
    "scuola",
    "scuro",
    "scusare",
    "sdebitare",
    "sdoganare",
    "seccatura",
    "secondo",
    "sedano",
    "seggiola",
    "segnalato",
    "segregato",
    "seguito",
    "selciato",
    "selettivo",
    "sella",
    "selvaggio",
    "semaforo",
    "sembrare",
    "seme",
    "seminato",
    "sempre",
    "senso",
    "sentire",
    "sepolto",
    "sequenza",
    "serata",
    "serbato",
    "sereno",
    "serio",
    "serpente",
    "serraglio",
    "servire",
    "sestina",
    "setola",
    "settimana",
    "sfacelo",
    "sfaldare",
    "sfamato",
    "sfarzoso",
    "sfaticato",
    "sfera",
    "sfida",
    "sfilato",
    "sfinge",
    "sfocato",
    "sfoderare",
    "sfogo",
    "sfoltire",
    "sforzato",
    "sfratto",
    "sfruttato",
    "sfuggito",
    "sfumare",
    "sfuso",
    "sgabello",
    "sgarbato",
    "sgonfiare",
    "sgorbio",
    "sgrassato",
    "sguardo",
    "sibilo",
    "siccome",
    "sierra",
    "sigla",
    "signore",
    "silenzio",
    "sillaba",
    "simbolo",
    "simpatico",
    "simulato",
    "sinfonia",
    "singolo",
    "sinistro",
    "sino",
    "sintesi",
    "sinusoide",
    "sipario",
    "sisma",
    "sistole",
    "situato",
    "slitta",
    "slogatura",
    "sloveno",
    "smarrito",
    "smemorato",
    "smentito",
    "smeraldo",
    "smilzo",
    "smontare",
    "smottato",
    "smussato",
    "snellire",
    "snervato",
    "snodo",
    "sobbalzo",
    "sobrio",
    "soccorso",
    "sociale",
    "sodale",
    "soffitto",
    "sogno",
    "soldato",
    "solenne",
    "solido",
    "sollazzo",
    "solo",
    "solubile",
    "solvente",
    "somatico",
    "somma",
    "sonda",
    "sonetto",
    "sonnifero",
    "sopire",
    "soppeso",
    "sopra",
    "sorgere",
    "sorpasso",
    "sorriso",
    "sorso",
    "sorteggio",
    "sorvolato",
    "sospiro",
    "sosta",
    "sottile",
    "spada",
    "spalla",
    "spargere",
    "spatola",
    "spavento",
    "spazzola",
    "specie",
    "spedire",
    "spegnere",
    "spelatura",
    "speranza",
    "spessore",
    "spettrale",
    "spezzato",
    "spia",
    "spigoloso",
    "spillato",
    "spinoso",
    "spirale",
    "splendido",
    "sportivo",
    "sposo",
    "spranga",
    "sprecare",
    "spronato",
    "spruzzo",
    "spuntino",
    "squillo",
    "sradicare",
    "srotolato",
    "stabile",
    "stacco",
    "staffa",
    "stagnare",
    "stampato",
    "stantio",
    "starnuto",
    "stasera",
    "statuto",
    "stelo",
    "steppa",
    "sterzo",
    "stiletto",
    "stima",
    "stirpe",
    "stivale",
    "stizzoso",
    "stonato",
    "storico",
    "strappo",
    "stregato",
    "stridulo",
    "strozzare",
    "strutto",
    "stuccare",
    "stufo",
    "stupendo",
    "subentro",
    "succoso",
    "sudore",
    "suggerito",
    "sugo",
    "sultano",
    "suonare",
    "superbo",
    "supporto",
    "surgelato",
    "surrogato",
    "sussurro",
    "sutura",
    "svagare",
    "svedese",
    "sveglio",
    "svelare",
    "svenuto",
    "svezia",
    "sviluppo",
    "svista",
    "svizzera",
    "svolta",
    "svuotare",
    "tabacco",
    "tabulato",
    "tacciare",
    "taciturno",
    "tale",
    "talismano",
    "tampone",
    "tannino",
    "tara",
    "tardivo",
    "targato",
    "tariffa",
    "tarpare",
    "tartaruga",
    "tasto",
    "tattico",
    "taverna",
    "tavolata",
    "tazza",
    "teca",
    "tecnico",
    "telefono",
    "temerario",
    "tempo",
    "temuto",
    "tendone",
    "tenero",
    "tensione",
    "tentacolo",
    "teorema",
    "terme",
    "terrazzo",
    "terzetto",
    "tesi",
    "tesserato",
    "testato",
    "tetro",
    "tettoia",
    "tifare",
    "tigella",
    "timbro",
    "tinto",
    "tipico",
    "tipografo",
    "tiraggio",
    "tiro",
    "titanio",
    "titolo",
    "titubante",
    "tizio",
    "tizzone",
    "toccare",
    "tollerare",
    "tolto",
    "tombola",
    "tomo",
    "tonfo",
    "tonsilla",
    "topazio",
    "topologia",
    "toppa",
    "torba",
    "tornare",
    "torrone",
    "tortora",
    "toscano",
    "tossire",
    "tostatura",
    "totano",
    "trabocco",
    "trachea",
    "trafila",
    "tragedia",
    "tralcio",
    "tramonto",
    "transito",
    "trapano",
    "trarre",
    "trasloco",
    "trattato",
    "trave",
    "treccia",
    "tremolio",
    "trespolo",
    "tributo",
    "tricheco",
    "trifoglio",
    "trillo",
    "trincea",
    "trio",
    "tristezza",
    "triturato",
    "trivella",
    "tromba",
    "trono",
    "troppo",
    "trottola",
    "trovare",
    "truccato",
    "tubatura",
    "tuffato",
    "tulipano",
    "tumulto",
    "tunisia",
    "turbare",
    "turchino",
    "tuta",
    "tutela",
    "ubicato",
    "uccello",
    "uccisore",
    "udire",
    "uditivo",
    "uffa",
    "ufficio",
    "uguale",
    "ulisse",
    "ultimato",
    "umano",
    "umile",
    "umorismo",
    "uncinetto",
    "ungere",
    "ungherese",
    "unicorno",
    "unificato",
    "unisono",
    "unitario",
    "unte",
    "uovo",
    "upupa",
    "uragano",
    "urgenza",
    "urlo",
    "usanza",
    "usato",
    "uscito",
    "usignolo",
    "usuraio",
    "utensile",
    "utilizzo",
    "utopia",
    "vacante",
    "vaccinato",
    "vagabondo",
    "vagliato",
    "valanga",
    "valgo",
    "valico",
    "valletta",
    "valoroso",
    "valutare",
    "valvola",
    "vampata",
    "vangare",
    "vanitoso",
    "vano",
    "vantaggio",
    "vanvera",
    "vapore",
    "varano",
    "varcato",
    "variante",
    "vasca",
    "vedetta",
    "vedova",
    "veduto",
    "vegetale",
    "veicolo",
    "velcro",
    "velina",
    "velluto",
    "veloce",
    "venato",
    "vendemmia",
    "vento",
    "verace",
    "verbale",
    "vergogna",
    "verifica",
    "vero",
    "verruca",
    "verticale",
    "vescica",
    "vessillo",
    "vestale",
    "veterano",
    "vetrina",
    "vetusto",
    "viandante",
    "vibrante",
    "vicenda",
    "vichingo",
    "vicinanza",
    "vidimare",
    "vigilia",
    "vigneto",
    "vigore",
    "vile",
    "villano",
    "vimini",
    "vincitore",
    "viola",
    "vipera",
    "virgola",
    "virologo",
    "virulento",
    "viscoso",
    "visione",
    "vispo",
    "vissuto",
    "visura",
    "vita",
    "vitello",
    "vittima",
    "vivanda",
    "vivido",
    "viziare",
    "voce",
    "voga",
    "volatile",
    "volere",
    "volpe",
    "voragine",
    "vulcano",
    "zampogna",
    "zanna",
    "zappato",
    "zattera",
    "zavorra",
    "zefiro",
    "zelante",
    "zelo",
    "zenzero",
    "zerbino",
    "zibetto",
    "zinco",
    "zircone",
    "zitto",
    "zolla",
    "zotico",
    "zucchero",
    "zufolo",
    "zulu",
    "zuppa"
  ]), j0;
}
var Y0, Rd;
function s9() {
  return Rd || (Rd = 1, Y0 = [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ]), Y0;
}
var X0, Pd;
function o9() {
  return Pd || (Pd = 1, X0 = [
    "abaco",
    "abdomen",
    "abeja",
    "abierto",
    "abogado",
    "abono",
    "aborto",
    "abrazo",
    "abrir",
    "abuelo",
    "abuso",
    "acabar",
    "academia",
    "acceso",
    "accion",
    "aceite",
    "acelga",
    "acento",
    "aceptar",
    "acido",
    "aclarar",
    "acne",
    "acoger",
    "acoso",
    "activo",
    "acto",
    "actriz",
    "actuar",
    "acudir",
    "acuerdo",
    "acusar",
    "adicto",
    "admitir",
    "adoptar",
    "adorno",
    "aduana",
    "adulto",
    "aereo",
    "afectar",
    "aficion",
    "afinar",
    "afirmar",
    "agil",
    "agitar",
    "agonia",
    "agosto",
    "agotar",
    "agregar",
    "agrio",
    "agua",
    "agudo",
    "aguila",
    "aguja",
    "ahogo",
    "ahorro",
    "aire",
    "aislar",
    "ajedrez",
    "ajeno",
    "ajuste",
    "alacran",
    "alambre",
    "alarma",
    "alba",
    "album",
    "alcalde",
    "aldea",
    "alegre",
    "alejar",
    "alerta",
    "aleta",
    "alfiler",
    "alga",
    "algodon",
    "aliado",
    "aliento",
    "alivio",
    "alma",
    "almeja",
    "almibar",
    "altar",
    "alteza",
    "altivo",
    "alto",
    "altura",
    "alumno",
    "alzar",
    "amable",
    "amante",
    "amapola",
    "amargo",
    "amasar",
    "ambar",
    "ambito",
    "ameno",
    "amigo",
    "amistad",
    "amor",
    "amparo",
    "amplio",
    "ancho",
    "anciano",
    "ancla",
    "andar",
    "anden",
    "anemia",
    "angulo",
    "anillo",
    "animo",
    "anis",
    "anotar",
    "antena",
    "antiguo",
    "antojo",
    "anual",
    "anular",
    "anuncio",
    "anadir",
    "anejo",
    "ano",
    "apagar",
    "aparato",
    "apetito",
    "apio",
    "aplicar",
    "apodo",
    "aporte",
    "apoyo",
    "aprender",
    "aprobar",
    "apuesta",
    "apuro",
    "arado",
    "arana",
    "arar",
    "arbitro",
    "arbol",
    "arbusto",
    "archivo",
    "arco",
    "arder",
    "ardilla",
    "arduo",
    "area",
    "arido",
    "aries",
    "armonia",
    "arnes",
    "aroma",
    "arpa",
    "arpon",
    "arreglo",
    "arroz",
    "arruga",
    "arte",
    "artista",
    "asa",
    "asado",
    "asalto",
    "ascenso",
    "asegurar",
    "aseo",
    "asesor",
    "asiento",
    "asilo",
    "asistir",
    "asno",
    "asombro",
    "aspero",
    "astilla",
    "astro",
    "astuto",
    "asumir",
    "asunto",
    "atajo",
    "ataque",
    "atar",
    "atento",
    "ateo",
    "atico",
    "atleta",
    "atomo",
    "atraer",
    "atroz",
    "atun",
    "audaz",
    "audio",
    "auge",
    "aula",
    "aumento",
    "ausente",
    "autor",
    "aval",
    "avance",
    "avaro",
    "ave",
    "avellana",
    "avena",
    "avestruz",
    "avion",
    "aviso",
    "ayer",
    "ayuda",
    "ayuno",
    "azafran",
    "azar",
    "azote",
    "azucar",
    "azufre",
    "azul",
    "baba",
    "babor",
    "bache",
    "bahia",
    "baile",
    "bajar",
    "balanza",
    "balcon",
    "balde",
    "bambu",
    "banco",
    "banda",
    "bano",
    "barba",
    "barco",
    "barniz",
    "barro",
    "bascula",
    "baston",
    "basura",
    "batalla",
    "bateria",
    "batir",
    "batuta",
    "baul",
    "bazar",
    "bebe",
    "bebida",
    "bello",
    "besar",
    "beso",
    "bestia",
    "bicho",
    "bien",
    "bingo",
    "blanco",
    "bloque",
    "blusa",
    "boa",
    "bobina",
    "bobo",
    "boca",
    "bocina",
    "boda",
    "bodega",
    "boina",
    "bola",
    "bolero",
    "bolsa",
    "bomba",
    "bondad",
    "bonito",
    "bono",
    "bonsai",
    "borde",
    "borrar",
    "bosque",
    "bote",
    "botin",
    "boveda",
    "bozal",
    "bravo",
    "brazo",
    "brecha",
    "breve",
    "brillo",
    "brinco",
    "brisa",
    "broca",
    "broma",
    "bronce",
    "brote",
    "bruja",
    "brusco",
    "bruto",
    "buceo",
    "bucle",
    "bueno",
    "buey",
    "bufanda",
    "bufon",
    "buho",
    "buitre",
    "bulto",
    "burbuja",
    "burla",
    "burro",
    "buscar",
    "butaca",
    "buzon",
    "caballo",
    "cabeza",
    "cabina",
    "cabra",
    "cacao",
    "cadaver",
    "cadena",
    "caer",
    "cafe",
    "caida",
    "caiman",
    "caja",
    "cajon",
    "cal",
    "calamar",
    "calcio",
    "caldo",
    "calidad",
    "calle",
    "calma",
    "calor",
    "calvo",
    "cama",
    "cambio",
    "camello",
    "camino",
    "campo",
    "cancer",
    "candil",
    "canela",
    "canguro",
    "canica",
    "canto",
    "cana",
    "canon",
    "caoba",
    "caos",
    "capaz",
    "capitan",
    "capote",
    "captar",
    "capucha",
    "cara",
    "carbon",
    "carcel",
    "careta",
    "carga",
    "carino",
    "carne",
    "carpeta",
    "carro",
    "carta",
    "casa",
    "casco",
    "casero",
    "caspa",
    "castor",
    "catorce",
    "catre",
    "caudal",
    "causa",
    "cazo",
    "cebolla",
    "ceder",
    "cedro",
    "celda",
    "celebre",
    "celoso",
    "celula",
    "cemento",
    "ceniza",
    "centro",
    "cerca",
    "cerdo",
    "cereza",
    "cero",
    "cerrar",
    "certeza",
    "cesped",
    "cetro",
    "chacal",
    "chaleco",
    "champu",
    "chancla",
    "chapa",
    "charla",
    "chico",
    "chiste",
    "chivo",
    "choque",
    "choza",
    "chuleta",
    "chupar",
    "ciclon",
    "ciego",
    "cielo",
    "cien",
    "cierto",
    "cifra",
    "cigarro",
    "cima",
    "cinco",
    "cine",
    "cinta",
    "cipres",
    "circo",
    "ciruela",
    "cisne",
    "cita",
    "ciudad",
    "clamor",
    "clan",
    "claro",
    "clase",
    "clave",
    "cliente",
    "clima",
    "clinica",
    "cobre",
    "coccion",
    "cochino",
    "cocina",
    "coco",
    "codigo",
    "codo",
    "cofre",
    "coger",
    "cohete",
    "cojin",
    "cojo",
    "cola",
    "colcha",
    "colegio",
    "colgar",
    "colina",
    "collar",
    "colmo",
    "columna",
    "combate",
    "comer",
    "comida",
    "comodo",
    "compra",
    "conde",
    "conejo",
    "conga",
    "conocer",
    "consejo",
    "contar",
    "copa",
    "copia",
    "corazon",
    "corbata",
    "corcho",
    "cordon",
    "corona",
    "correr",
    "coser",
    "cosmos",
    "costa",
    "craneo",
    "crater",
    "crear",
    "crecer",
    "creido",
    "crema",
    "cria",
    "crimen",
    "cripta",
    "crisis",
    "cromo",
    "cronica",
    "croqueta",
    "crudo",
    "cruz",
    "cuadro",
    "cuarto",
    "cuatro",
    "cubo",
    "cubrir",
    "cuchara",
    "cuello",
    "cuento",
    "cuerda",
    "cuesta",
    "cueva",
    "cuidar",
    "culebra",
    "culpa",
    "culto",
    "cumbre",
    "cumplir",
    "cuna",
    "cuneta",
    "cuota",
    "cupon",
    "cupula",
    "curar",
    "curioso",
    "curso",
    "curva",
    "cutis",
    "dama",
    "danza",
    "dar",
    "dardo",
    "datil",
    "deber",
    "debil",
    "decada",
    "decir",
    "dedo",
    "defensa",
    "definir",
    "dejar",
    "delfin",
    "delgado",
    "delito",
    "demora",
    "denso",
    "dental",
    "deporte",
    "derecho",
    "derrota",
    "desayuno",
    "deseo",
    "desfile",
    "desnudo",
    "destino",
    "desvio",
    "detalle",
    "detener",
    "deuda",
    "dia",
    "diablo",
    "diadema",
    "diamante",
    "diana",
    "diario",
    "dibujo",
    "dictar",
    "diente",
    "dieta",
    "diez",
    "dificil",
    "digno",
    "dilema",
    "diluir",
    "dinero",
    "directo",
    "dirigir",
    "disco",
    "diseno",
    "disfraz",
    "diva",
    "divino",
    "doble",
    "doce",
    "dolor",
    "domingo",
    "don",
    "donar",
    "dorado",
    "dormir",
    "dorso",
    "dos",
    "dosis",
    "dragon",
    "droga",
    "ducha",
    "duda",
    "duelo",
    "dueno",
    "dulce",
    "duo",
    "duque",
    "durar",
    "dureza",
    "duro",
    "ebano",
    "ebrio",
    "echar",
    "eco",
    "ecuador",
    "edad",
    "edicion",
    "edificio",
    "editor",
    "educar",
    "efecto",
    "eficaz",
    "eje",
    "ejemplo",
    "elefante",
    "elegir",
    "elemento",
    "elevar",
    "elipse",
    "elite",
    "elixir",
    "elogio",
    "eludir",
    "embudo",
    "emitir",
    "emocion",
    "empate",
    "empeno",
    "empleo",
    "empresa",
    "enano",
    "encargo",
    "enchufe",
    "encia",
    "enemigo",
    "enero",
    "enfado",
    "enfermo",
    "engano",
    "enigma",
    "enlace",
    "enorme",
    "enredo",
    "ensayo",
    "ensenar",
    "entero",
    "entrar",
    "envase",
    "envio",
    "epoca",
    "equipo",
    "erizo",
    "escala",
    "escena",
    "escolar",
    "escribir",
    "escudo",
    "esencia",
    "esfera",
    "esfuerzo",
    "espada",
    "espejo",
    "espia",
    "esposa",
    "espuma",
    "esqui",
    "estar",
    "este",
    "estilo",
    "estufa",
    "etapa",
    "eterno",
    "etica",
    "etnia",
    "evadir",
    "evaluar",
    "evento",
    "evitar",
    "exacto",
    "examen",
    "exceso",
    "excusa",
    "exento",
    "exigir",
    "exilio",
    "existir",
    "exito",
    "experto",
    "explicar",
    "exponer",
    "extremo",
    "fabrica",
    "fabula",
    "fachada",
    "facil",
    "factor",
    "faena",
    "faja",
    "falda",
    "fallo",
    "falso",
    "faltar",
    "fama",
    "familia",
    "famoso",
    "faraon",
    "farmacia",
    "farol",
    "farsa",
    "fase",
    "fatiga",
    "fauna",
    "favor",
    "fax",
    "febrero",
    "fecha",
    "feliz",
    "feo",
    "feria",
    "feroz",
    "fertil",
    "fervor",
    "festin",
    "fiable",
    "fianza",
    "fiar",
    "fibra",
    "ficcion",
    "ficha",
    "fideo",
    "fiebre",
    "fiel",
    "fiera",
    "fiesta",
    "figura",
    "fijar",
    "fijo",
    "fila",
    "filete",
    "filial",
    "filtro",
    "fin",
    "finca",
    "fingir",
    "finito",
    "firma",
    "flaco",
    "flauta",
    "flecha",
    "flor",
    "flota",
    "fluir",
    "flujo",
    "fluor",
    "fobia",
    "foca",
    "fogata",
    "fogon",
    "folio",
    "folleto",
    "fondo",
    "forma",
    "forro",
    "fortuna",
    "forzar",
    "fosa",
    "foto",
    "fracaso",
    "fragil",
    "franja",
    "frase",
    "fraude",
    "freir",
    "freno",
    "fresa",
    "frio",
    "frito",
    "fruta",
    "fuego",
    "fuente",
    "fuerza",
    "fuga",
    "fumar",
    "funcion",
    "funda",
    "furgon",
    "furia",
    "fusil",
    "futbol",
    "futuro",
    "gacela",
    "gafas",
    "gaita",
    "gajo",
    "gala",
    "galeria",
    "gallo",
    "gamba",
    "ganar",
    "gancho",
    "ganga",
    "ganso",
    "garaje",
    "garza",
    "gasolina",
    "gastar",
    "gato",
    "gavilan",
    "gemelo",
    "gemir",
    "gen",
    "genero",
    "genio",
    "gente",
    "geranio",
    "gerente",
    "germen",
    "gesto",
    "gigante",
    "gimnasio",
    "girar",
    "giro",
    "glaciar",
    "globo",
    "gloria",
    "gol",
    "golfo",
    "goloso",
    "golpe",
    "goma",
    "gordo",
    "gorila",
    "gorra",
    "gota",
    "goteo",
    "gozar",
    "grada",
    "grafico",
    "grano",
    "grasa",
    "gratis",
    "grave",
    "grieta",
    "grillo",
    "gripe",
    "gris",
    "grito",
    "grosor",
    "grua",
    "grueso",
    "grumo",
    "grupo",
    "guante",
    "guapo",
    "guardia",
    "guerra",
    "guia",
    "guino",
    "guion",
    "guiso",
    "guitarra",
    "gusano",
    "gustar",
    "haber",
    "habil",
    "hablar",
    "hacer",
    "hacha",
    "hada",
    "hallar",
    "hamaca",
    "harina",
    "haz",
    "hazana",
    "hebilla",
    "hebra",
    "hecho",
    "helado",
    "helio",
    "hembra",
    "herir",
    "hermano",
    "heroe",
    "hervir",
    "hielo",
    "hierro",
    "higado",
    "higiene",
    "hijo",
    "himno",
    "historia",
    "hocico",
    "hogar",
    "hoguera",
    "hoja",
    "hombre",
    "hongo",
    "honor",
    "honra",
    "hora",
    "hormiga",
    "horno",
    "hostil",
    "hoyo",
    "hueco",
    "huelga",
    "huerta",
    "hueso",
    "huevo",
    "huida",
    "huir",
    "humano",
    "humedo",
    "humilde",
    "humo",
    "hundir",
    "huracan",
    "hurto",
    "icono",
    "ideal",
    "idioma",
    "idolo",
    "iglesia",
    "iglu",
    "igual",
    "ilegal",
    "ilusion",
    "imagen",
    "iman",
    "imitar",
    "impar",
    "imperio",
    "imponer",
    "impulso",
    "incapaz",
    "indice",
    "inerte",
    "infiel",
    "informe",
    "ingenio",
    "inicio",
    "inmenso",
    "inmune",
    "innato",
    "insecto",
    "instante",
    "interes",
    "intimo",
    "intuir",
    "inutil",
    "invierno",
    "ira",
    "iris",
    "ironia",
    "isla",
    "islote",
    "jabali",
    "jabon",
    "jamon",
    "jarabe",
    "jardin",
    "jarra",
    "jaula",
    "jazmin",
    "jefe",
    "jeringa",
    "jinete",
    "jornada",
    "joroba",
    "joven",
    "joya",
    "juerga",
    "jueves",
    "juez",
    "jugador",
    "jugo",
    "juguete",
    "juicio",
    "junco",
    "jungla",
    "junio",
    "juntar",
    "jupiter",
    "jurar",
    "justo",
    "juvenil",
    "juzgar",
    "kilo",
    "koala",
    "labio",
    "lacio",
    "lacra",
    "lado",
    "ladron",
    "lagarto",
    "lagrima",
    "laguna",
    "laico",
    "lamer",
    "lamina",
    "lampara",
    "lana",
    "lancha",
    "langosta",
    "lanza",
    "lapiz",
    "largo",
    "larva",
    "lastima",
    "lata",
    "latex",
    "latir",
    "laurel",
    "lavar",
    "lazo",
    "leal",
    "leccion",
    "leche",
    "lector",
    "leer",
    "legion",
    "legumbre",
    "lejano",
    "lengua",
    "lento",
    "lena",
    "leon",
    "leopardo",
    "lesion",
    "letal",
    "letra",
    "leve",
    "leyenda",
    "libertad",
    "libro",
    "licor",
    "lider",
    "lidiar",
    "lienzo",
    "liga",
    "ligero",
    "lima",
    "limite",
    "limon",
    "limpio",
    "lince",
    "lindo",
    "linea",
    "lingote",
    "lino",
    "linterna",
    "liquido",
    "liso",
    "lista",
    "litera",
    "litio",
    "litro",
    "llaga",
    "llama",
    "llanto",
    "llave",
    "llegar",
    "llenar",
    "llevar",
    "llorar",
    "llover",
    "lluvia",
    "lobo",
    "locion",
    "loco",
    "locura",
    "logica",
    "logro",
    "lombriz",
    "lomo",
    "lonja",
    "lote",
    "lucha",
    "lucir",
    "lugar",
    "lujo",
    "luna",
    "lunes",
    "lupa",
    "lustro",
    "luto",
    "luz",
    "maceta",
    "macho",
    "madera",
    "madre",
    "maduro",
    "maestro",
    "mafia",
    "magia",
    "mago",
    "maiz",
    "maldad",
    "maleta",
    "malla",
    "malo",
    "mama",
    "mambo",
    "mamut",
    "manco",
    "mando",
    "manejar",
    "manga",
    "maniqui",
    "manjar",
    "mano",
    "manso",
    "manta",
    "manana",
    "mapa",
    "maquina",
    "mar",
    "marco",
    "marea",
    "marfil",
    "margen",
    "marido",
    "marmol",
    "marron",
    "martes",
    "marzo",
    "masa",
    "mascara",
    "masivo",
    "matar",
    "materia",
    "matiz",
    "matriz",
    "maximo",
    "mayor",
    "mazorca",
    "mecha",
    "medalla",
    "medio",
    "medula",
    "mejilla",
    "mejor",
    "melena",
    "melon",
    "memoria",
    "menor",
    "mensaje",
    "mente",
    "menu",
    "mercado",
    "merengue",
    "merito",
    "mes",
    "meson",
    "meta",
    "meter",
    "metodo",
    "metro",
    "mezcla",
    "miedo",
    "miel",
    "miembro",
    "miga",
    "mil",
    "milagro",
    "militar",
    "millon",
    "mimo",
    "mina",
    "minero",
    "minimo",
    "minuto",
    "miope",
    "mirar",
    "misa",
    "miseria",
    "misil",
    "mismo",
    "mitad",
    "mito",
    "mochila",
    "mocion",
    "moda",
    "modelo",
    "moho",
    "mojar",
    "molde",
    "moler",
    "molino",
    "momento",
    "momia",
    "monarca",
    "moneda",
    "monja",
    "monto",
    "mono",
    "morada",
    "morder",
    "moreno",
    "morir",
    "morro",
    "morsa",
    "mortal",
    "mosca",
    "mostrar",
    "motivo",
    "mover",
    "movil",
    "mozo",
    "mucho",
    "mudar",
    "mueble",
    "muela",
    "muerte",
    "muestra",
    "mugre",
    "mujer",
    "mula",
    "muleta",
    "multa",
    "mundo",
    "muneca",
    "mural",
    "muro",
    "musculo",
    "museo",
    "musgo",
    "musica",
    "muslo",
    "nacar",
    "nacion",
    "nadar",
    "naipe",
    "naranja",
    "nariz",
    "narrar",
    "nasal",
    "natal",
    "nativo",
    "natural",
    "nausea",
    "naval",
    "nave",
    "navidad",
    "necio",
    "nectar",
    "negar",
    "negocio",
    "negro",
    "neon",
    "nervio",
    "neto",
    "neutro",
    "nevar",
    "nevera",
    "nicho",
    "nido",
    "niebla",
    "nieto",
    "ninez",
    "nino",
    "nitido",
    "nivel",
    "nobleza",
    "noche",
    "nomina",
    "noria",
    "norma",
    "norte",
    "nota",
    "noticia",
    "novato",
    "novela",
    "novio",
    "nube",
    "nuca",
    "nucleo",
    "nudillo",
    "nudo",
    "nuera",
    "nueve",
    "nuez",
    "nulo",
    "numero",
    "nutria",
    "oasis",
    "obeso",
    "obispo",
    "objeto",
    "obra",
    "obrero",
    "observar",
    "obtener",
    "obvio",
    "oca",
    "ocaso",
    "oceano",
    "ochenta",
    "ocho",
    "ocio",
    "ocre",
    "octavo",
    "octubre",
    "oculto",
    "ocupar",
    "ocurrir",
    "odiar",
    "odio",
    "odisea",
    "oeste",
    "ofensa",
    "oferta",
    "oficio",
    "ofrecer",
    "ogro",
    "oido",
    "oir",
    "ojo",
    "ola",
    "oleada",
    "olfato",
    "olivo",
    "olla",
    "olmo",
    "olor",
    "olvido",
    "ombligo",
    "onda",
    "onza",
    "opaco",
    "opcion",
    "opera",
    "opinar",
    "oponer",
    "optar",
    "optica",
    "opuesto",
    "oracion",
    "orador",
    "oral",
    "orbita",
    "orca",
    "orden",
    "oreja",
    "organo",
    "orgia",
    "orgullo",
    "oriente",
    "origen",
    "orilla",
    "oro",
    "orquesta",
    "oruga",
    "osadia",
    "oscuro",
    "osezno",
    "oso",
    "ostra",
    "otono",
    "otro",
    "oveja",
    "ovulo",
    "oxido",
    "oxigeno",
    "oyente",
    "ozono",
    "pacto",
    "padre",
    "paella",
    "pagina",
    "pago",
    "pais",
    "pajaro",
    "palabra",
    "palco",
    "paleta",
    "palido",
    "palma",
    "paloma",
    "palpar",
    "pan",
    "panal",
    "panico",
    "pantera",
    "panuelo",
    "papa",
    "papel",
    "papilla",
    "paquete",
    "parar",
    "parcela",
    "pared",
    "parir",
    "paro",
    "parpado",
    "parque",
    "parrafo",
    "parte",
    "pasar",
    "paseo",
    "pasion",
    "paso",
    "pasta",
    "pata",
    "patio",
    "patria",
    "pausa",
    "pauta",
    "pavo",
    "payaso",
    "peaton",
    "pecado",
    "pecera",
    "pecho",
    "pedal",
    "pedir",
    "pegar",
    "peine",
    "pelar",
    "peldano",
    "pelea",
    "peligro",
    "pellejo",
    "pelo",
    "peluca",
    "pena",
    "pensar",
    "penon",
    "peon",
    "peor",
    "pepino",
    "pequeno",
    "pera",
    "percha",
    "perder",
    "pereza",
    "perfil",
    "perico",
    "perla",
    "permiso",
    "perro",
    "persona",
    "pesa",
    "pesca",
    "pesimo",
    "pestana",
    "petalo",
    "petroleo",
    "pez",
    "pezuna",
    "picar",
    "pichon",
    "pie",
    "piedra",
    "pierna",
    "pieza",
    "pijama",
    "pilar",
    "piloto",
    "pimienta",
    "pino",
    "pintor",
    "pinza",
    "pina",
    "piojo",
    "pipa",
    "pirata",
    "pisar",
    "piscina",
    "piso",
    "pista",
    "piton",
    "pizca",
    "placa",
    "plan",
    "plata",
    "playa",
    "plaza",
    "pleito",
    "pleno",
    "plomo",
    "pluma",
    "plural",
    "pobre",
    "poco",
    "poder",
    "podio",
    "poema",
    "poesia",
    "poeta",
    "polen",
    "policia",
    "pollo",
    "polvo",
    "pomada",
    "pomelo",
    "pomo",
    "pompa",
    "poner",
    "porcion",
    "portal",
    "posada",
    "poseer",
    "posible",
    "poste",
    "potencia",
    "potro",
    "pozo",
    "prado",
    "precoz",
    "pregunta",
    "premio",
    "prensa",
    "preso",
    "previo",
    "primo",
    "principe",
    "prision",
    "privar",
    "proa",
    "probar",
    "proceso",
    "producto",
    "proeza",
    "profesor",
    "programa",
    "prole",
    "promesa",
    "pronto",
    "propio",
    "proximo",
    "prueba",
    "publico",
    "puchero",
    "pudor",
    "pueblo",
    "puerta",
    "puesto",
    "pulga",
    "pulir",
    "pulmon",
    "pulpo",
    "pulso",
    "puma",
    "punto",
    "punal",
    "puno",
    "pupa",
    "pupila",
    "pure",
    "quedar",
    "queja",
    "quemar",
    "querer",
    "queso",
    "quieto",
    "quimica",
    "quince",
    "quitar",
    "rabano",
    "rabia",
    "rabo",
    "racion",
    "radical",
    "raiz",
    "rama",
    "rampa",
    "rancho",
    "rango",
    "rapaz",
    "rapido",
    "rapto",
    "rasgo",
    "raspa",
    "rato",
    "rayo",
    "raza",
    "razon",
    "reaccion",
    "realidad",
    "rebano",
    "rebote",
    "recaer",
    "receta",
    "rechazo",
    "recoger",
    "recreo",
    "recto",
    "recurso",
    "red",
    "redondo",
    "reducir",
    "reflejo",
    "reforma",
    "refran",
    "refugio",
    "regalo",
    "regir",
    "regla",
    "regreso",
    "rehen",
    "reino",
    "reir",
    "reja",
    "relato",
    "relevo",
    "relieve",
    "relleno",
    "reloj",
    "remar",
    "remedio",
    "remo",
    "rencor",
    "rendir",
    "renta",
    "reparto",
    "repetir",
    "reposo",
    "reptil",
    "res",
    "rescate",
    "resina",
    "respeto",
    "resto",
    "resumen",
    "retiro",
    "retorno",
    "retrato",
    "reunir",
    "reves",
    "revista",
    "rey",
    "rezar",
    "rico",
    "riego",
    "rienda",
    "riesgo",
    "rifa",
    "rigido",
    "rigor",
    "rincon",
    "rinon",
    "rio",
    "riqueza",
    "risa",
    "ritmo",
    "rito",
    "rizo",
    "roble",
    "roce",
    "rociar",
    "rodar",
    "rodeo",
    "rodilla",
    "roer",
    "rojizo",
    "rojo",
    "romero",
    "romper",
    "ron",
    "ronco",
    "ronda",
    "ropa",
    "ropero",
    "rosa",
    "rosca",
    "rostro",
    "rotar",
    "rubi",
    "rubor",
    "rudo",
    "rueda",
    "rugir",
    "ruido",
    "ruina",
    "ruleta",
    "rulo",
    "rumbo",
    "rumor",
    "ruptura",
    "ruta",
    "rutina",
    "sabado",
    "saber",
    "sabio",
    "sable",
    "sacar",
    "sagaz",
    "sagrado",
    "sala",
    "saldo",
    "salero",
    "salir",
    "salmon",
    "salon",
    "salsa",
    "salto",
    "salud",
    "salvar",
    "samba",
    "sancion",
    "sandia",
    "sanear",
    "sangre",
    "sanidad",
    "sano",
    "santo",
    "sapo",
    "saque",
    "sardina",
    "sarten",
    "sastre",
    "satan",
    "sauna",
    "saxofon",
    "seccion",
    "seco",
    "secreto",
    "secta",
    "sed",
    "seguir",
    "seis",
    "sello",
    "selva",
    "semana",
    "semilla",
    "senda",
    "sensor",
    "senal",
    "senor",
    "separar",
    "sepia",
    "sequia",
    "ser",
    "serie",
    "sermon",
    "servir",
    "sesenta",
    "sesion",
    "seta",
    "setenta",
    "severo",
    "sexo",
    "sexto",
    "sidra",
    "siesta",
    "siete",
    "siglo",
    "signo",
    "silaba",
    "silbar",
    "silencio",
    "silla",
    "simbolo",
    "simio",
    "sirena",
    "sistema",
    "sitio",
    "situar",
    "sobre",
    "socio",
    "sodio",
    "sol",
    "solapa",
    "soldado",
    "soledad",
    "solido",
    "soltar",
    "solucion",
    "sombra",
    "sondeo",
    "sonido",
    "sonoro",
    "sonrisa",
    "sopa",
    "soplar",
    "soporte",
    "sordo",
    "sorpresa",
    "sorteo",
    "sosten",
    "sotano",
    "suave",
    "subir",
    "suceso",
    "sudor",
    "suegra",
    "suelo",
    "sueno",
    "suerte",
    "sufrir",
    "sujeto",
    "sultan",
    "sumar",
    "superar",
    "suplir",
    "suponer",
    "supremo",
    "sur",
    "surco",
    "sureno",
    "surgir",
    "susto",
    "sutil",
    "tabaco",
    "tabique",
    "tabla",
    "tabu",
    "taco",
    "tacto",
    "tajo",
    "talar",
    "talco",
    "talento",
    "talla",
    "talon",
    "tamano",
    "tambor",
    "tango",
    "tanque",
    "tapa",
    "tapete",
    "tapia",
    "tapon",
    "taquilla",
    "tarde",
    "tarea",
    "tarifa",
    "tarjeta",
    "tarot",
    "tarro",
    "tarta",
    "tatuaje",
    "tauro",
    "taza",
    "tazon",
    "teatro",
    "techo",
    "tecla",
    "tecnica",
    "tejado",
    "tejer",
    "tejido",
    "tela",
    "telefono",
    "tema",
    "temor",
    "templo",
    "tenaz",
    "tender",
    "tener",
    "tenis",
    "tenso",
    "teoria",
    "terapia",
    "terco",
    "termino",
    "ternura",
    "terror",
    "tesis",
    "tesoro",
    "testigo",
    "tetera",
    "texto",
    "tez",
    "tibio",
    "tiburon",
    "tiempo",
    "tienda",
    "tierra",
    "tieso",
    "tigre",
    "tijera",
    "tilde",
    "timbre",
    "timido",
    "timo",
    "tinta",
    "tio",
    "tipico",
    "tipo",
    "tira",
    "tiron",
    "titan",
    "titere",
    "titulo",
    "tiza",
    "toalla",
    "tobillo",
    "tocar",
    "tocino",
    "todo",
    "toga",
    "toldo",
    "tomar",
    "tono",
    "tonto",
    "topar",
    "tope",
    "toque",
    "torax",
    "torero",
    "tormenta",
    "torneo",
    "toro",
    "torpedo",
    "torre",
    "torso",
    "tortuga",
    "tos",
    "tosco",
    "toser",
    "toxico",
    "trabajo",
    "tractor",
    "traer",
    "trafico",
    "trago",
    "traje",
    "tramo",
    "trance",
    "trato",
    "trauma",
    "trazar",
    "trebol",
    "tregua",
    "treinta",
    "tren",
    "trepar",
    "tres",
    "tribu",
    "trigo",
    "tripa",
    "triste",
    "triunfo",
    "trofeo",
    "trompa",
    "tronco",
    "tropa",
    "trote",
    "trozo",
    "truco",
    "trueno",
    "trufa",
    "tuberia",
    "tubo",
    "tuerto",
    "tumba",
    "tumor",
    "tunel",
    "tunica",
    "turbina",
    "turismo",
    "turno",
    "tutor",
    "ubicar",
    "ulcera",
    "umbral",
    "unidad",
    "unir",
    "universo",
    "uno",
    "untar",
    "una",
    "urbano",
    "urbe",
    "urgente",
    "urna",
    "usar",
    "usuario",
    "util",
    "utopia",
    "uva",
    "vaca",
    "vacio",
    "vacuna",
    "vagar",
    "vago",
    "vaina",
    "vajilla",
    "vale",
    "valido",
    "valle",
    "valor",
    "valvula",
    "vampiro",
    "vara",
    "variar",
    "varon",
    "vaso",
    "vecino",
    "vector",
    "vehiculo",
    "veinte",
    "vejez",
    "vela",
    "velero",
    "veloz",
    "vena",
    "vencer",
    "venda",
    "veneno",
    "vengar",
    "venir",
    "venta",
    "venus",
    "ver",
    "verano",
    "verbo",
    "verde",
    "vereda",
    "verja",
    "verso",
    "verter",
    "via",
    "viaje",
    "vibrar",
    "vicio",
    "victima",
    "vida",
    "video",
    "vidrio",
    "viejo",
    "viernes",
    "vigor",
    "vil",
    "villa",
    "vinagre",
    "vino",
    "vinedo",
    "violin",
    "viral",
    "virgo",
    "virtud",
    "visor",
    "vispera",
    "vista",
    "vitamina",
    "viudo",
    "vivaz",
    "vivero",
    "vivir",
    "vivo",
    "volcan",
    "volumen",
    "volver",
    "voraz",
    "votar",
    "voto",
    "voz",
    "vuelo",
    "vulgar",
    "yacer",
    "yate",
    "yegua",
    "yema",
    "yerno",
    "yeso",
    "yodo",
    "yoga",
    "yogur",
    "zafiro",
    "zanja",
    "zapato",
    "zarza",
    "zona",
    "zorro",
    "zumo",
    "zurdo"
  ]), X0;
}
/*!
 * wordlist.js - wordlists for bcoin
 * Copyright (c) 2015-2016, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var kd;
function sb() {
  return kd || (kd = 1, H0.get = function(c) {
    switch (c) {
      case "simplified chinese":
        return e9();
      case "traditional chinese":
        return t9();
      case "english":
        return r9();
      case "french":
        return i9();
      case "italian":
        return n9();
      case "japanese":
        return s9();
      case "spanish":
        return o9();
      default:
        throw new Error(`Unknown language: ${c}.`);
    }
  }), H0;
}
/*!
 * nfkd.js - unicode normalization for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var J0, Bd;
function a9() {
  if (Bd) return J0;
  Bd = 1;
  function e(c) {
    return c.normalize("NFKD");
  }
  return J0 = e, J0;
}
/*!
 * mnemonic.js - hd mnemonics for bcoin
 * Copyright (c) 2015-2016, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var G0, Md;
function Wh() {
  if (Md) return G0;
  Md = 1;
  const e = nt, c = kt, d = cr(), w = Zs(), g = Ti(), f = Gh(), n = Fi(), u = sb(), a = Ws(), s = a9(), { inspectSymbol: i } = fr(), p = /* @__PURE__ */ Object.create(null);
  class m {
    /**
     * Create a mnemonic.
     * @constructor
     * @param {Object} options
     * @param {Number?} options.bit - Bits of entropy (Must
     * be a multiple of 8) (default=128).
     * @param {Buffer?} options.entropy - Entropy bytes. Will
     * be generated with `options.bits` bits of entropy
     * if not present.
     * @param {String?} options.phrase - Mnemonic phrase (will
     * be generated if not present).
     * @param {String?} options.language - Language.
     */
    constructor(b) {
      this.bits = a.MIN_ENTROPY, this.language = "english", this.entropy = null, this.phrase = null, b && this.fromOptions(b);
    }
    /**
     * Inject properties from options object.
     * @private
     * @param {Object} options
     */
    fromOptions(b) {
      return typeof b == "string" && (b = { phrase: b }), b.bits != null && (e((b.bits & 65535) === b.bits), e(b.bits >= a.MIN_ENTROPY), e(b.bits <= a.MAX_ENTROPY), e(b.bits % 32 === 0), this.bits = b.bits), b.language && (e(typeof b.language == "string"), e(m.languages.indexOf(b.language) !== -1), this.language = b.language), b.phrase ? (this.fromPhrase(b.phrase), this) : b.entropy ? (this.fromEntropy(b.entropy), this) : this;
    }
    /**
     * Instantiate mnemonic from options.
     * @param {Object} options
     * @returns {Mnemonic}
     */
    static fromOptions(b) {
      return new this().fromOptions(b);
    }
    /**
     * Destroy the mnemonic (zeroes entropy).
     */
    destroy() {
      this.bits = a.MIN_ENTROPY, this.language = "english", this.entropy && (w(this.entropy), this.entropy = null), this.phrase = null;
    }
    /**
     * Generate the seed.
     * @param {String?} passphrase
     * @returns {Buffer} pbkdf2 seed.
     */
    toSeed(b) {
      b || (b = "");
      const h = s(this.getPhrase()), o = s(`mnemonic${b}`);
      return f.derive(
        n,
        k.from(h, "utf8"),
        k.from(o, "utf8"),
        2048,
        64
      );
    }
    /**
     * Get or generate entropy.
     * @returns {Buffer}
     */
    getEntropy() {
      return this.entropy || (this.entropy = g.randomBytes(this.bits / 8)), e(this.bits / 8 === this.entropy.length), this.entropy;
    }
    /**
     * Generate a mnemonic phrase from chosen language.
     * @returns {String}
     */
    getPhrase() {
      if (this.phrase)
        return this.phrase;
      const b = this.bits + this.bits / 32, h = this.getEntropy(), o = d.digest(h), S = Math.ceil(b / 8), H = k.allocUnsafe(S);
      h.copy(H, 0), o.copy(H, h.length);
      const j = m.getWordlist(this.language);
      let J = [];
      for (let N = 0; N < b / 11; N++) {
        let z = 0;
        for (let A = 0; A < 11; A++) {
          const q = N * 11 + A, _ = q % 8, F = (q - _) / 8;
          z <<= 1, z |= H[F] >>> 7 - _ & 1;
        }
        J.push(j.words[z]);
      }
      return this.language === "japanese" ? J = J.join("") : J = J.join(" "), this.phrase = J, J;
    }
    /**
     * Inject properties from phrase.
     * @private
     * @param {String} phrase
     */
    fromPhrase(b) {
      e(typeof b == "string"), e(b.length <= 1e3);
      const h = b.trim().split(/[\s\u3000]+/), o = h.length * 11, S = o % 32;
      e(S !== 0, "Invalid checksum.");
      const H = o - S;
      e(H >= a.MIN_ENTROPY), e(H <= a.MAX_ENTROPY), e(H % 32 === 0);
      const j = Math.ceil(o / 8), J = k.allocUnsafe(j);
      J.fill(0);
      const N = m.getLanguage(h[0]), z = m.getWordlist(N);
      for (let R = 0; R < h.length; R++) {
        const V = h[R], fe = z.map[V];
        if (fe == null)
          throw new Error("Could not find word.");
        for (let ue = 0; ue < 11; ue++) {
          const ae = R * 11 + ue, D = ae % 8, Q = (ae - D) / 8, Z = fe >>> 10 - ue & 1;
          J[Q] |= Z << 7 - D;
        }
      }
      const A = Math.ceil(S / 8), q = J.slice(0, J.length - A), _ = J.slice(J.length - A), F = d.digest(q);
      for (let R = 0; R < S; R++) {
        const V = R % 8, fe = (R - V) / 8, ue = _[fe] >>> 7 - V & 1, ae = F[fe] >>> 7 - V & 1;
        if (ue !== ae)
          throw new Error("Invalid checksum.");
      }
      return e(H / 8 === q.length), this.bits = H, this.language = N, this.entropy = q, this.phrase = b, this;
    }
    /**
     * Instantiate mnemonic from a phrase (validates checksum).
     * @param {String} phrase
     * @returns {Mnemonic}
     * @throws on bad checksum
     */
    static fromPhrase(b) {
      return new this().fromPhrase(b);
    }
    /**
     * Inject properties from entropy.
     * @private
     * @param {Buffer} entropy
     * @param {String?} lang
     */
    fromEntropy(b, h) {
      return e(k.isBuffer(b)), e(b.length * 8 >= a.MIN_ENTROPY), e(b.length * 8 <= a.MAX_ENTROPY), e(b.length * 8 % 32 === 0), e(!h || m.languages.indexOf(h) !== -1), this.entropy = b, this.bits = b.length * 8, h && (this.language = h), this;
    }
    /**
     * Instantiate mnemonic from entropy.
     * @param {Buffer} entropy
     * @param {String?} lang
     * @returns {Mnemonic}
     */
    static fromEntropy(b, h) {
      return new this().fromEntropy(b, h);
    }
    /**
     * Determine a single word's language.
     * @param {String} word
     * @returns {String} Language.
     * @throws on not found.
     */
    static getLanguage(b) {
      for (const h of m.languages)
        if (m.getWordlist(h).map[b] != null)
          return h;
      throw new Error("Could not determine language.");
    }
    /**
     * Retrieve the wordlist for a language.
     * @param {String} lang
     * @returns {Object}
     */
    static getWordlist(b) {
      const h = p[b];
      if (h)
        return h;
      const o = u.get(b), S = new E(o);
      return p[b] = S, S;
    }
    /**
     * Convert mnemonic to a json-friendly object.
     * @returns {Object}
     */
    toJSON() {
      return {
        bits: this.bits,
        language: this.language,
        entropy: this.getEntropy().toString("hex"),
        phrase: this.getPhrase()
      };
    }
    /**
     * Inject properties from json object.
     * @private
     * @param {Object} json
     */
    fromJSON(b) {
      return e(b), e((b.bits & 65535) === b.bits), e(typeof b.language == "string"), e(typeof b.entropy == "string"), e(typeof b.phrase == "string"), e(b.bits >= a.MIN_ENTROPY), e(b.bits <= a.MAX_ENTROPY), e(b.bits % 32 === 0), e(b.bits / 8 === b.entropy.length / 2), this.bits = b.bits, this.language = b.language, this.entropy = k.from(b.entropy, "hex"), this.phrase = b.phrase, this;
    }
    /**
     * Instantiate mnemonic from json object.
     * @param {Object} json
     * @returns {Mnemonic}
     */
    static fromJSON(b) {
      return new this().fromJSON(b);
    }
    /**
     * Calculate serialization size.
     * @returns {Number}
     */
    getSize() {
      let b = 0;
      return b += 3, b += this.getEntropy().length, b;
    }
    /**
     * Write the mnemonic to a buffer writer.
     * @params {BufferWriter} bw
     */
    toWriter(b) {
      const h = m.languages.indexOf(this.language);
      return e(h !== -1), b.writeU16(this.bits), b.writeU8(h), b.writeBytes(this.getEntropy()), b;
    }
    /**
     * Serialize mnemonic.
     * @returns {Buffer}
     */
    toRaw(b) {
      const h = this.getSize();
      return this.toWriter(c.write(h)).render();
    }
    /**
     * Inject properties from buffer reader.
     * @private
     * @param {BufferReader} br
     */
    fromReader(b) {
      const h = b.readU16();
      e(h >= a.MIN_ENTROPY), e(h <= a.MAX_ENTROPY), e(h % 32 === 0);
      const o = m.languages[b.readU8()];
      return e(o), this.bits = h, this.language = o, this.entropy = b.readBytes(h / 8), this;
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     */
    fromRaw(b) {
      return this.fromReader(c.read(b));
    }
    /**
     * Instantiate mnemonic from buffer reader.
     * @param {BufferReader} br
     * @returns {Mnemonic}
     */
    static fromReader(b) {
      return new this().fromReader(b);
    }
    /**
     * Instantiate mnemonic from serialized data.
     * @param {Buffer} data
     * @returns {Mnemonic}
     */
    static fromRaw(b) {
      return new this().fromRaw(b);
    }
    /**
     * Convert the mnemonic to a string.
     * @returns {String}
     */
    toString() {
      return this.getPhrase();
    }
    /**
     * Inspect the mnemonic.
     * @returns {String}
     */
    [i]() {
      return `<Mnemonic: ${this.getPhrase()}>`;
    }
    /**
     * Test whether an object is a Mnemonic.
     * @param {Object} obj
     * @returns {Boolean}
     */
    static isMnemonic(b) {
      return b instanceof m;
    }
  }
  m.languages = [
    "simplified chinese",
    "traditional chinese",
    "english",
    "french",
    "italian",
    "japanese",
    "spanish"
  ];
  class E {
    /**
     * Create word list.
     * @constructor
     * @ignore
     * @param {Array} words
     */
    constructor(b) {
      this.words = b, this.map = /* @__PURE__ */ Object.create(null);
      for (let h = 0; h < b.length; h++) {
        const o = b[h];
        this.map[o] = h;
      }
    }
  }
  return G0 = m, G0;
}
/*!
 * public.js - hd public keys for bcoin
 * Copyright (c) 2015-2016, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var W0, Nd;
function Zh() {
  if (Nd) return W0;
  Nd = 1;
  const e = nt, c = kt, { base58: d } = Ds, w = Fi(), g = hn(), f = Or(), n = Zs(), u = Fr(), a = _r(), s = Xt(), i = Ws();
  class p {
    /**
     * Create an HD public key.
     * @constructor
     * @param {Object|Base58String} options
     * @param {Base58String?} options.xkey - Serialized base58 key.
     * @param {Number?} options.depth
     * @param {Number?} options.parentFingerPrint
     * @param {Number?} options.childIndex
     * @param {Buffer?} options.chainCode
     * @param {Buffer?} options.publicKey
     */
    constructor(E) {
      this.depth = 0, this.parentFingerPrint = 0, this.childIndex = 0, this.chainCode = s.ZERO_HASH, this.publicKey = i.ZERO_KEY, this.fingerPrint = -1, E && this.fromOptions(E);
    }
    /**
     * Inject properties from options object.
     * @private
     * @param {Object} options
     */
    fromOptions(E) {
      return e(E, "No options for HDPublicKey"), e((E.depth & 255) === E.depth), e(E.parentFingerPrint >>> 0 === E.parentFingerPrint), e(E.childIndex >>> 0 === E.childIndex), e(k.isBuffer(E.chainCode)), e(k.isBuffer(E.publicKey)), this.depth = E.depth, this.parentFingerPrint = E.parentFingerPrint, this.childIndex = E.childIndex, this.chainCode = E.chainCode, this.publicKey = E.publicKey, this;
    }
    /**
     * Instantiate HD public key from options object.
     * @param {Object} options
     * @returns {HDPublicKey}
     */
    static fromOptions(E) {
      return new this().fromOptions(E);
    }
    /**
     * Get HD public key (self).
     * @returns {HDPublicKey}
     */
    toPublic() {
      return this;
    }
    /**
     * Get cached base58 xprivkey (always null here).
     * @returns {null}
     */
    xprivkey(E) {
      return null;
    }
    /**
     * Get cached base58 xpubkey.
     * @returns {Base58String}
     */
    xpubkey(E) {
      return this.toBase58(E);
    }
    /**
     * Destroy the key (zeroes chain code and pubkey).
     */
    destroy() {
      this.depth = 0, this.childIndex = 0, this.parentFingerPrint = 0, n(this.chainCode), n(this.publicKey), this.fingerPrint = -1;
    }
    /**
     * Derive a child key.
     * @param {Number} index - Derivation index.
     * @param {Boolean?} hardened - Whether the derivation
     * should be hardened (throws if true).
     * @returns {HDPrivateKey}
     * @throws on `hardened`
     */
    derive(E, v) {
      if (e(typeof E == "number"), E >>> 0 !== E)
        throw new Error("Index out of range.");
      if (E & i.HARDENED || v)
        throw new Error("Cannot derive hardened.");
      if (this.depth >= 255)
        throw new Error("Depth too high.");
      const b = this.getID(E), h = i.cache.get(b);
      if (h)
        return h;
      const o = c.pool(37);
      o.writeBytes(this.publicKey), o.writeU32BE(E);
      const S = o.render(), H = w.mac(S, this.chainCode), j = H.slice(0, 32), J = H.slice(32, 64);
      let N;
      try {
        N = u.publicKeyTweakAdd(this.publicKey, j, !0);
      } catch {
        return this.derive(E + 1);
      }
      if (this.fingerPrint === -1) {
        const A = g.digest(this.publicKey);
        this.fingerPrint = A.readUInt32BE(0, !0);
      }
      const z = new this.constructor();
      return z.depth = this.depth + 1, z.parentFingerPrint = this.fingerPrint, z.childIndex = E, z.chainCode = J, z.publicKey = N, i.cache.set(b, z), z;
    }
    /**
     * Unique HD key ID.
     * @private
     * @param {Number} index
     * @returns {String}
     */
    getID(E) {
      return "b" + this.publicKey.toString("hex") + E;
    }
    /**
     * Derive a BIP44 account key (does not derive, only ensures account key).
     * @method
     * @param {Number} purpose
     * @param {Number} type
     * @param {Number} account
     * @returns {HDPublicKey}
     * @throws Error if key is not already an account key.
     */
    deriveAccount(E, v, b) {
      return e(E >>> 0 === E), e(v >>> 0 === v), e(b >>> 0 === b), e(this.isAccount(b), "Cannot derive account index."), this;
    }
    /**
     * Test whether the key is a master key.
     * @method
     * @returns {Boolean}
     */
    isMaster() {
      return i.isMaster(this);
    }
    /**
     * Test whether the key is (most likely) a BIP44 account key.
     * @method
     * @param {Number?} account
     * @returns {Boolean}
     */
    isAccount(E) {
      return i.isAccount(this, E);
    }
    /**
     * Test whether a string is a valid path.
     * @param {String} path
     * @param {Boolean?} hardened
     * @returns {Boolean}
     */
    static isValidPath(E) {
      try {
        return i.parsePath(E, !1), !0;
      } catch {
        return !1;
      }
    }
    /**
     * Derive a key from a derivation path.
     * @param {String} path
     * @returns {HDPublicKey}
     * @throws Error if `path` is not a valid path.
     * @throws Error if hardened.
     */
    derivePath(E) {
      const v = i.parsePath(E, !1);
      let b = this;
      for (const h of v)
        b = b.derive(h);
      return b;
    }
    /**
     * Compare a key against an object.
     * @param {Object} obj
     * @returns {Boolean}
     */
    equals(E) {
      return e(p.isHDPublicKey(E)), this.depth === E.depth && this.parentFingerPrint === E.parentFingerPrint && this.childIndex === E.childIndex && this.chainCode.equals(E.chainCode) && this.publicKey.equals(E.publicKey);
    }
    /**
     * Compare a key against an object.
     * @param {Object} obj
     * @returns {Boolean}
     */
    compare(E) {
      e(p.isHDPublicKey(E));
      let v = this.depth - E.depth;
      return v !== 0 || (v = this.parentFingerPrint - E.parentFingerPrint, v !== 0) || (v = this.childIndex - E.childIndex, v !== 0) || (v = this.chainCode.compare(E.chainCode), v !== 0) || (v = this.publicKey.compare(E.publicKey), v !== 0) ? v : 0;
    }
    /**
     * Convert key to a more json-friendly object.
     * @returns {Object}
     */
    toJSON(E) {
      return {
        xpubkey: this.xpubkey(E)
      };
    }
    /**
     * Inject properties from json object.
     * @private
     * @param {Object} json
     * @param {Network?} network
     */
    fromJSON(E, v) {
      return e(E.xpubkey, "Could not handle HD key JSON."), this.fromBase58(E.xpubkey, v), this;
    }
    /**
     * Instantiate an HDPublicKey from a jsonified key object.
     * @param {Object} json - The jsonified transaction object.
     * @param {Network?} network
     * @returns {HDPrivateKey}
     */
    static fromJSON(E, v) {
      return new this().fromJSON(E, v);
    }
    /**
     * Test whether an object is in the form of a base58 xpubkey.
     * @param {String} data
     * @param {(Network|NetworkType)?} network
     * @returns {Boolean}
     */
    static isBase58(E, v) {
      if (typeof E != "string" || E.length < 4)
        return !1;
      const b = E.substring(0, 4);
      try {
        return a.fromPublic58(b, v), !0;
      } catch {
        return !1;
      }
    }
    /**
     * Test whether a buffer has a valid network prefix.
     * @param {Buffer} data
     * @param {(Network|NetworkType)?} network
     * @returns {NetworkType}
     */
    static isRaw(E, v) {
      if (!k.isBuffer(E) || E.length < 4)
        return !1;
      const b = E.readUInt32BE(0, !0);
      try {
        return a.fromPublic(b, v), !0;
      } catch {
        return !1;
      }
    }
    /**
     * Inject properties from a base58 key.
     * @private
     * @param {Base58String} xkey
     * @param {Network?} network
     */
    fromBase58(E, v) {
      return e(typeof E == "string"), this.fromRaw(d.decode(E), v);
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {BufferReader} br
     * @param {(Network|NetworkType)?} network
     */
    fromReader(E, v) {
      const b = E.readU32BE();
      return a.fromPublic(b, v), this.depth = E.readU8(), this.parentFingerPrint = E.readU32BE(), this.childIndex = E.readU32BE(), this.chainCode = E.readBytes(32), this.publicKey = E.readBytes(33), E.verifyChecksum(f.digest), this;
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     * @param {(Network|NetworkType)?} network
     */
    fromRaw(E, v) {
      return this.fromReader(c.read(E), v);
    }
    /**
     * Serialize key data to base58 extended key.
     * @param {(Network|NetworkType)?} network
     * @returns {Base58String}
     */
    toBase58(E) {
      return d.encode(this.toRaw(E));
    }
    /**
     * Write the key to a buffer writer.
     * @param {BufferWriter} bw
     * @param {(Network|NetworkType)?} network
     */
    toWriter(E, v) {
      return v = a.get(v), E.writeU32BE(v.keyPrefix.xpubkey), E.writeU8(this.depth), E.writeU32BE(this.parentFingerPrint), E.writeU32BE(this.childIndex), E.writeBytes(this.chainCode), E.writeBytes(this.publicKey), E.writeChecksum(f.digest), E;
    }
    /**
     * Calculate serialization size.
     * @returns {Number}
     */
    getSize() {
      return 82;
    }
    /**
     * Serialize the key.
     * @param {(Network|NetworkType)?} network
     * @returns {Buffer}
     */
    toRaw(E) {
      return this.toWriter(c.write(82), E).render();
    }
    /**
     * Instantiate an HD public key from a base58 string.
     * @param {Base58String} xkey
     * @param {Network?} network
     * @returns {HDPublicKey}
     */
    static fromBase58(E, v) {
      return new this().fromBase58(E, v);
    }
    /**
     * Instantiate key from serialized data.
     * @param {BufferReader} br
     * @param {(Network|NetworkType)?} network
     * @returns {HDPublicKey}
     */
    static fromReader(E, v) {
      return new this().fromReader(E, v);
    }
    /**
     * Instantiate key from serialized data.
     * @param {Buffer} data
     * @param {(Network|NetworkType)?} network
     * @returns {HDPublicKey}
     */
    static fromRaw(E, v) {
      return new this().fromRaw(E, v);
    }
    /**
     * Test whether an object is a HDPublicKey.
     * @param {Object} obj
     * @returns {Boolean}
     */
    static isHDPublicKey(E) {
      return E instanceof p;
    }
  }
  return W0 = p, W0;
}
/*!
 * private.js - hd private keys for bcoin
 * Copyright (c) 2015-2016, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var Z0, qd;
function ob() {
  if (qd) return Z0;
  qd = 1;
  const e = nt, c = kt, { base58: d } = Ds, w = Fi(), g = hn(), f = Or(), n = Zs(), u = Ti(), a = Fr(), s = _r(), i = Xt(), p = Ws(), m = Wh(), E = Zh(), v = k.from("Bitcoin seed", "ascii");
  class b {
    /**
     * Create an hd private key.
     * @constructor
     * @param {Object|String} options
     * @param {Number?} options.depth
     * @param {Number?} options.parentFingerPrint
     * @param {Number?} options.childIndex
     * @param {Buffer?} options.chainCode
     * @param {Buffer?} options.privateKey
     */
    constructor(o) {
      this.depth = 0, this.parentFingerPrint = 0, this.childIndex = 0, this.chainCode = i.ZERO_HASH, this.privateKey = i.ZERO_HASH, this.publicKey = p.ZERO_KEY, this.fingerPrint = -1, this._hdPublicKey = null, o && this.fromOptions(o);
    }
    /**
     * Inject properties from options object.
     * @private
     * @param {Object} options
     */
    fromOptions(o) {
      return e(o, "No options for HD private key."), e((o.depth & 255) === o.depth), e(o.parentFingerPrint >>> 0 === o.parentFingerPrint), e(o.childIndex >>> 0 === o.childIndex), e(k.isBuffer(o.chainCode)), e(k.isBuffer(o.privateKey)), this.depth = o.depth, this.parentFingerPrint = o.parentFingerPrint, this.childIndex = o.childIndex, this.chainCode = o.chainCode, this.privateKey = o.privateKey, this.publicKey = a.publicKeyCreate(o.privateKey, !0), this;
    }
    /**
     * Instantiate HD private key from options object.
     * @param {Object} options
     * @returns {HDPrivateKey}
     */
    static fromOptions(o) {
      return new this().fromOptions(o);
    }
    /**
     * Get HD public key.
     * @returns {HDPublicKey}
     */
    toPublic() {
      let o = this._hdPublicKey;
      return o || (o = new E(), o.depth = this.depth, o.parentFingerPrint = this.parentFingerPrint, o.childIndex = this.childIndex, o.chainCode = this.chainCode, o.publicKey = this.publicKey, this._hdPublicKey = o), o;
    }
    /**
     * Get cached base58 xprivkey.
     * @returns {Base58String}
     */
    xprivkey(o) {
      return this.toBase58(o);
    }
    /**
     * Get cached base58 xpubkey.
     * @returns {Base58String}
     */
    xpubkey(o) {
      return this.toPublic().xpubkey(o);
    }
    /**
     * Destroy the key (zeroes chain code, privkey, and pubkey).
     * @param {Boolean} pub - Destroy hd public key as well.
     */
    destroy(o) {
      this.depth = 0, this.childIndex = 0, this.parentFingerPrint = 0, n(this.chainCode), n(this.privateKey), n(this.publicKey), this.fingerPrint = -1, this._hdPublicKey && (o && this._hdPublicKey.destroy(), this._hdPublicKey = null);
    }
    /**
     * Derive a child key.
     * @param {Number} index - Derivation index.
     * @param {Boolean?} hardened - Whether the derivation should be hardened.
     * @returns {HDPrivateKey}
     */
    derive(o, S) {
      if (e(typeof o == "number"), o >>> 0 !== o)
        throw new Error("Index out of range.");
      if (this.depth >= 255)
        throw new Error("Depth too high.");
      S && (o |= p.HARDENED, o >>>= 0);
      const H = this.getID(o), j = p.cache.get(H);
      if (j)
        return j;
      const J = c.pool(37);
      o & p.HARDENED ? (J.writeU8(0), J.writeBytes(this.privateKey), J.writeU32BE(o)) : (J.writeBytes(this.publicKey), J.writeU32BE(o));
      const N = J.render(), z = w.mac(N, this.chainCode), A = z.slice(0, 32), q = z.slice(32, 64);
      let _;
      try {
        _ = a.privateKeyTweakAdd(this.privateKey, A);
      } catch {
        return this.derive(o + 1);
      }
      if (this.fingerPrint === -1) {
        const R = g.digest(this.publicKey);
        this.fingerPrint = R.readUInt32BE(0, !0);
      }
      const F = new this.constructor();
      return F.depth = this.depth + 1, F.parentFingerPrint = this.fingerPrint, F.childIndex = o, F.chainCode = q, F.privateKey = _, F.publicKey = a.publicKeyCreate(_, !0), p.cache.set(H, F), F;
    }
    /**
     * Unique HD key ID.
     * @private
     * @param {Number} index
     * @returns {String}
     */
    getID(o) {
      return "v" + this.publicKey.toString("hex") + o;
    }
    /**
     * Derive a BIP44 account key.
     * @param {Number} purpose
     * @param {Number} type
     * @param {Number} account
     * @returns {HDPrivateKey}
     * @throws Error if key is not a master key.
     */
    deriveAccount(o, S, H) {
      return e(o >>> 0 === o, "Purpose must be a number."), e(S >>> 0 === S, "Account index must be a number."), e(H >>> 0 === H, "Account index must be a number."), e(this.isMaster(), "Cannot derive account index."), this.derive(o, !0).derive(S, !0).derive(H, !0);
    }
    /**
     * Test whether the key is a master key.
     * @returns {Boolean}
     */
    isMaster() {
      return p.isMaster(this);
    }
    /**
     * Test whether the key is (most likely) a BIP44 account key.
     * @param {Number?} account
     * @returns {Boolean}
     */
    isAccount(o) {
      return p.isAccount(this, o);
    }
    /**
     * Test whether an object is in the form of a base58 xprivkey.
     * @param {String} data
     * @param {Network?} network
     * @returns {Boolean}
     */
    static isBase58(o, S) {
      if (typeof o != "string" || o.length < 4)
        return !1;
      const H = o.substring(0, 4);
      try {
        return s.fromPrivate58(H, S), !0;
      } catch {
        return !1;
      }
    }
    /**
     * Test whether a buffer has a valid network prefix.
     * @param {Buffer} data
     * @param {Network?} network
     * @returns {Boolean}
     */
    static isRaw(o, S) {
      if (!k.isBuffer(o) || o.length < 4)
        return !1;
      const H = o.readUInt32BE(0, !0);
      try {
        return s.fromPrivate(H, S), !0;
      } catch {
        return !1;
      }
    }
    /**
     * Test whether a string is a valid path.
     * @param {String} path
     * @returns {Boolean}
     */
    static isValidPath(o) {
      try {
        return p.parsePath(o, !0), !0;
      } catch {
        return !1;
      }
    }
    /**
     * Derive a key from a derivation path.
     * @param {String} path
     * @returns {HDPrivateKey}
     * @throws Error if `path` is not a valid path.
     */
    derivePath(o) {
      const S = p.parsePath(o, !0);
      let H = this;
      for (const j of S)
        H = H.derive(j);
      return H;
    }
    /**
     * Compare a key against an object.
     * @param {Object} obj
     * @returns {Boolean}
     */
    equals(o) {
      return e(b.isHDPrivateKey(o)), this.depth === o.depth && this.parentFingerPrint === o.parentFingerPrint && this.childIndex === o.childIndex && this.chainCode.equals(o.chainCode) && this.privateKey.equals(o.privateKey);
    }
    /**
     * Compare a key against an object.
     * @param {Object} obj
     * @returns {Boolean}
     */
    compare(o) {
      e(b.isHDPrivateKey(o));
      let S = this.depth - o.depth;
      return S !== 0 || (S = this.parentFingerPrint - o.parentFingerPrint, S !== 0) || (S = this.childIndex - o.childIndex, S !== 0) || (S = this.chainCode.compare(o.chainCode), S !== 0) || (S = this.privateKey.compare(o.privateKey), S !== 0) ? S : 0;
    }
    /**
     * Inject properties from seed.
     * @private
     * @param {Buffer} seed
     */
    fromSeed(o) {
      if (e(k.isBuffer(o)), o.length * 8 < p.MIN_ENTROPY || o.length * 8 > p.MAX_ENTROPY)
        throw new Error("Entropy not in range.");
      const S = w.mac(o, v), H = S.slice(0, 32), j = S.slice(32, 64);
      if (!a.privateKeyVerify(H))
        throw new Error("Master private key is invalid.");
      return this.depth = 0, this.parentFingerPrint = 0, this.childIndex = 0, this.chainCode = j, this.privateKey = H, this.publicKey = a.publicKeyCreate(H, !0), this;
    }
    /**
     * Instantiate an hd private key from a 512 bit seed.
     * @param {Buffer} seed
     * @returns {HDPrivateKey}
     */
    static fromSeed(o) {
      return new this().fromSeed(o);
    }
    /**
     * Inject properties from a mnemonic.
     * @private
     * @param {Mnemonic} mnemonic
     * @param {String?} passphrase
     */
    fromMnemonic(o, S) {
      return e(o instanceof m), this.fromSeed(o.toSeed(S));
    }
    /**
     * Instantiate an hd private key from a mnemonic.
     * @param {Mnemonic} mnemonic
     * @param {String?} passphrase
     * @returns {HDPrivateKey}
     */
    static fromMnemonic(o, S) {
      return new this().fromMnemonic(o, S);
    }
    /**
     * Inject properties from a mnemonic.
     * @private
     * @param {String} mnemonic
     */
    fromPhrase(o) {
      const S = m.fromPhrase(o);
      return this.fromMnemonic(S), this;
    }
    /**
     * Instantiate an hd private key from a phrase.
     * @param {String} phrase
     * @returns {HDPrivateKey}
     */
    static fromPhrase(o) {
      return new this().fromPhrase(o);
    }
    /**
     * Inject properties from privateKey and entropy.
     * @private
     * @param {Buffer} key
     * @param {Buffer} entropy
     */
    fromKey(o, S) {
      return e(k.isBuffer(o) && o.length === 32), e(k.isBuffer(S) && S.length === 32), this.depth = 0, this.parentFingerPrint = 0, this.childIndex = 0, this.chainCode = S, this.privateKey = o, this.publicKey = a.publicKeyCreate(o, !0), this;
    }
    /**
     * Create an hd private key from a key and entropy bytes.
     * @param {Buffer} key
     * @param {Buffer} entropy
     * @returns {HDPrivateKey}
     */
    static fromKey(o, S) {
      return new this().fromKey(o, S);
    }
    /**
     * Generate an hd private key.
     * @returns {HDPrivateKey}
     */
    static generate() {
      const o = a.privateKeyGenerate(), S = u.randomBytes(32);
      return b.fromKey(o, S);
    }
    /**
     * Inject properties from base58 key.
     * @private
     * @param {Base58String} xkey
     * @param {Network?} network
     */
    fromBase58(o, S) {
      return e(typeof o == "string"), this.fromRaw(d.decode(o), S);
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {BufferReader} br
     * @param {(Network|NetworkType)?} network
     */
    fromReader(o, S) {
      const H = o.readU32BE();
      return s.fromPrivate(H, S), this.depth = o.readU8(), this.parentFingerPrint = o.readU32BE(), this.childIndex = o.readU32BE(), this.chainCode = o.readBytes(32), e(o.readU8() === 0), this.privateKey = o.readBytes(32), this.publicKey = a.publicKeyCreate(this.privateKey, !0), o.verifyChecksum(f.digest), this;
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     * @param {(Network|NetworkType)?} network
     */
    fromRaw(o, S) {
      return this.fromReader(c.read(o), S);
    }
    /**
     * Serialize key to a base58 string.
     * @param {(Network|NetworkType)?} network
     * @returns {Base58String}
     */
    toBase58(o) {
      return d.encode(this.toRaw(o));
    }
    /**
     * Calculate serialization size.
     * @returns {Number}
     */
    getSize() {
      return 82;
    }
    /**
     * Write the key to a buffer writer.
     * @param {BufferWriter} bw
     * @param {(Network|NetworkType)?} network
     */
    toWriter(o, S) {
      return S = s.get(S), o.writeU32BE(S.keyPrefix.xprivkey), o.writeU8(this.depth), o.writeU32BE(this.parentFingerPrint), o.writeU32BE(this.childIndex), o.writeBytes(this.chainCode), o.writeU8(0), o.writeBytes(this.privateKey), o.writeChecksum(f.digest), o;
    }
    /**
     * Serialize the key.
     * @param {(Network|NetworkType)?} network
     * @returns {Buffer}
     */
    toRaw(o) {
      return this.toWriter(c.write(82), o).render();
    }
    /**
     * Instantiate an HD private key from a base58 string.
     * @param {Base58String} xkey
     * @param {Network?} network
     * @returns {HDPrivateKey}
     */
    static fromBase58(o, S) {
      return new this().fromBase58(o, S);
    }
    /**
     * Instantiate key from buffer reader.
     * @param {BufferReader} br
     * @param {(Network|NetworkType)?} network
     * @returns {HDPrivateKey}
     */
    static fromReader(o, S) {
      return new this().fromReader(o, S);
    }
    /**
     * Instantiate key from serialized data.
     * @param {Buffer} data
     * @param {(Network|NetworkType)?} network
     * @returns {HDPrivateKey}
     */
    static fromRaw(o, S) {
      return new this().fromRaw(o, S);
    }
    /**
     * Convert key to a more json-friendly object.
     * @returns {Object}
     */
    toJSON(o) {
      return {
        xprivkey: this.xprivkey(o)
      };
    }
    /**
     * Inject properties from json object.
     * @private
     * @param {Object} json
     * @param {Network?} network
     */
    fromJSON(o, S) {
      return e(o.xprivkey, "Could not handle key JSON."), this.fromBase58(o.xprivkey, S), this;
    }
    /**
     * Instantiate an HDPrivateKey from a jsonified key object.
     * @param {Object} json - The jsonified key object.
     * @param {Network?} network
     * @returns {HDPrivateKey}
     */
    static fromJSON(o, S) {
      return new this().fromJSON(o, S);
    }
    /**
     * Test whether an object is an HDPrivateKey.
     * @param {Object} obj
     * @returns {Boolean}
     */
    static isHDPrivateKey(o) {
      return o instanceof b;
    }
  }
  return Z0 = b, Z0;
}
/*!
 * hd.js - hd keys for bcoin
 * Copyright (c) 2015-2016, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var zd;
function f9() {
  return zd || (zd = 1, function(e) {
    const c = nt, d = Ws(), w = Wh(), g = ob(), f = Zh(), n = sb(), u = e;
    u.fromBase58 = function(s, i) {
      return g.isBase58(s) ? g.fromBase58(s, i) : f.fromBase58(s, i);
    }, u.generate = function() {
      return g.generate();
    }, u.fromSeed = function(s) {
      return g.fromSeed(s);
    }, u.fromMnemonic = function(s) {
      return g.fromMnemonic(s);
    }, u.fromJSON = function(s, i) {
      return s.xprivkey ? g.fromJSON(s, i) : f.fromJSON(s, i);
    }, u.fromRaw = function(s, i) {
      return g.isRaw(s, i) ? g.fromRaw(s, i) : f.fromRaw(s, i);
    }, u.from = function(s, i) {
      if (c(s, "Options required."), u.isHD(s))
        return s;
      if (u.isBase58(s, i))
        return u.fromBase58(s, i);
      if (u.isRaw(s, i))
        return u.fromRaw(s, i);
      if (s && typeof s == "object")
        return u.fromMnemonic(s);
      throw new Error("Cannot create HD key from bad options.");
    }, u.isBase58 = function(s, i) {
      return g.isBase58(s, i) || f.isBase58(s, i);
    }, u.isRaw = function(s, i) {
      return g.isRaw(s, i) || f.isRaw(s, i);
    }, u.isHD = function(s) {
      return g.isHDPrivateKey(s) || f.isHDPublicKey(s);
    }, u.isPrivate = function(s) {
      return g.isHDPrivateKey(s);
    }, u.isPublic = function(s) {
      return f.isHDPublicKey(s);
    }, u.common = d, u.HD = u, u.Mnemonic = w, u.PrivateKey = g, u.PublicKey = f, u.HDPrivateKey = g, u.HDPublicKey = f, u.wordlist = n;
  }(C0)), C0;
}
/*!
 * hd/index.js - hd keys for bcoin
 * Copyright (c) 2014-2016, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var Q0, Td;
function c9() {
  return Td || (Td = 1, Q0 = f9()), Q0;
}
var jt = {};
/*!
 * invitem.js - inv item object for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var ea, Cd;
function Qs() {
  if (Cd) return ea;
  Cd = 1;
  const e = kt, c = ur();
  class d {
    /**
     * Create an inv item.
     * @constructor
     * @param {Number} type
     * @param {Hash} hash
     */
    constructor(g, f) {
      this.type = g, this.hash = f;
    }
    /**
     * Write inv item to buffer writer.
     * @param {BufferWriter} bw
     */
    getSize() {
      return 36;
    }
    /**
     * Write inv item to buffer writer.
     * @param {BufferWriter} bw
     */
    toWriter(g) {
      return g.writeU32(this.type), g.writeHash(this.hash), g;
    }
    /**
     * Serialize inv item.
     * @returns {Buffer}
     */
    toRaw() {
      return this.toWriter(e.write(36)).render();
    }
    /**
     * Inject properties from buffer reader.
     * @private
     * @param {BufferReader} br
     */
    fromReader(g) {
      return this.type = g.readU32(), this.hash = g.readHash(), this;
    }
    /**
     * Inject properties from serialized data.
     * @param {Buffer} data
     */
    fromRaw(g) {
      return this.fromReader(e.read(g));
    }
    /**
     * Instantiate inv item from buffer reader.
     * @param {BufferReader} br
     * @returns {InvItem}
     */
    static fromReader(g) {
      return new this().fromReader(g);
    }
    /**
     * Instantiate inv item from serialized data.
     * @param {Buffer} data
     * @param {String?} enc
     * @returns {InvItem}
     */
    static fromRaw(g, f) {
      return typeof g == "string" && (g = k.from(g, f)), new this().fromRaw(g);
    }
    /**
     * Test whether the inv item is a block.
     * @returns {Boolean}
     */
    isBlock() {
      switch (this.type) {
        case d.types.BLOCK:
        case d.types.FILTERED_BLOCK:
        case d.types.CMPCT_BLOCK:
          return !0;
        default:
          return !1;
      }
    }
    /**
     * Test whether the inv item is a tx.
     * @returns {Boolean}
     */
    isTX() {
      switch (this.type) {
        case d.types.TX:
          return !0;
        default:
          return !1;
      }
    }
    /**
     * Get little-endian hash.
     * @returns {Hash}
     */
    rhash() {
      return c.revHex(this.hash);
    }
  }
  return d.types = {
    TX: 1,
    BLOCK: 2,
    FILTERED_BLOCK: 3,
    CMPCT_BLOCK: 4
  }, d.typesByVal = {
    1: "TX",
    2: "BLOCK",
    3: "FILTERED_BLOCK",
    4: "CMPCT_BLOCK"
  }, ea = d, ea;
}
/*!
 * abstractblock.js - abstract block object for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var ta, Dd;
function Xn() {
  if (Dd) return ta;
  Dd = 1;
  const e = nt, c = Or(), d = kt, w = ur(), g = Qs(), f = Xt();
  class n {
    /**
     * Create an abstract block.
     * @constructor
     */
    constructor() {
      this.version = 1, this.prevBlock = f.ZERO_HASH, this.merkleRoot = f.ZERO_HASH, this.time = 0, this.bits = 0, this.nonce = 0, this.mutable = !1, this._hash = null, this._hhash = null;
    }
    /**
     * Inject properties from options object.
     * @private
     * @param {Object} options
     */
    parseOptions(a) {
      return e(a, "Block data is required."), e(a.version >>> 0 === a.version), e(k.isBuffer(a.prevBlock)), e(k.isBuffer(a.merkleRoot)), e(a.time >>> 0 === a.time), e(a.bits >>> 0 === a.bits), e(a.nonce >>> 0 === a.nonce), this.version = a.version, this.prevBlock = a.prevBlock, this.merkleRoot = a.merkleRoot, this.time = a.time, this.bits = a.bits, this.nonce = a.nonce, a.mutable != null && (e(typeof a.mutable == "boolean"), this.mutable = a.mutable), this;
    }
    /**
     * Inject properties from json object.
     * @private
     * @param {Object} json
     */
    parseJSON(a) {
      return e(a, "Block data is required."), e(a.version >>> 0 === a.version), e(typeof a.prevBlock == "string"), e(typeof a.merkleRoot == "string"), e(a.time >>> 0 === a.time), e(a.bits >>> 0 === a.bits), e(a.nonce >>> 0 === a.nonce), this.version = a.version, this.prevBlock = w.fromRev(a.prevBlock), this.merkleRoot = w.fromRev(a.merkleRoot), this.time = a.time, this.bits = a.bits, this.nonce = a.nonce, this;
    }
    /**
     * Test whether the block is a memblock.
     * @returns {Boolean}
     */
    isMemory() {
      return !1;
    }
    /**
     * Clear any cached values (abstract).
     */
    _refresh() {
      this._hash = null, this._hhash = null;
    }
    /**
     * Clear any cached values.
     */
    refresh() {
      return this._refresh();
    }
    /**
     * Hash the block headers.
     * @param {String?} enc - Can be `'hex'` or `null`.
     * @returns {Hash|Buffer} hash
     */
    hash(a) {
      let s = this._hash;
      if (s || (s = c.digest(this.toHead()), this.mutable || (this._hash = s)), a === "hex") {
        let i = this._hhash;
        i || (i = s.toString("hex"), this.mutable || (this._hhash = i)), s = i;
      }
      return s;
    }
    /**
     * Serialize the block headers.
     * @returns {Buffer}
     */
    toHead() {
      return this.writeHead(d.write(80)).render();
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     */
    fromHead(a) {
      return this.readHead(d.read(a));
    }
    /**
     * Serialize the block headers.
     * @param {BufferWriter} bw
     */
    writeHead(a) {
      return a.writeU32(this.version), a.writeHash(this.prevBlock), a.writeHash(this.merkleRoot), a.writeU32(this.time), a.writeU32(this.bits), a.writeU32(this.nonce), a;
    }
    /**
     * Parse the block headers.
     * @param {BufferReader} br
     */
    readHead(a) {
      return this.version = a.readU32(), this.prevBlock = a.readHash(), this.merkleRoot = a.readHash(), this.time = a.readU32(), this.bits = a.readU32(), this.nonce = a.readU32(), this;
    }
    /**
     * Verify the block.
     * @returns {Boolean}
     */
    verify() {
      return !(!this.verifyPOW() || !this.verifyBody());
    }
    /**
     * Verify proof-of-work.
     * @returns {Boolean}
     */
    verifyPOW() {
      return f.verifyPOW(this.hash(), this.bits);
    }
    /**
     * Verify the block.
     * @returns {Boolean}
     */
    verifyBody() {
      throw new Error("Abstract method.");
    }
    /**
     * Get little-endian block hash.
     * @returns {Hash}
     */
    rhash() {
      return w.revHex(this.hash());
    }
    /**
     * Convert the block to an inv item.
     * @returns {InvItem}
     */
    toInv() {
      return new g(g.types.BLOCK, this.hash());
    }
  }
  return ta = n, ta;
}
var ji = {};
/*!
 * merkle.js - merkle trees for bcrypto
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on bitcoin/bitcoin:
 *   Copyright (c) 2009-2019, The Bitcoin Core Developers (MIT License).
 *   Copyright (c) 2009-2019, The Bitcoin Developers (MIT License).
 *   https://github.com/bitcoin/bitcoin
 */
var Ud;
function ab() {
  if (Ud) return ji;
  Ud = 1;
  const e = Bt();
  function c(f, n) {
    e(f && typeof f.root == "function"), e(Array.isArray(n));
    const u = new Array(n.length);
    for (let p = 0; p < n.length; p++)
      u[p] = n[p];
    let a = u.length, s = !1, i = 0;
    if (a === 0)
      return u.push(f.zero), [u, s];
    for (; a > 1; ) {
      for (let p = 0; p < a; p += 2) {
        const m = Math.min(p + 1, a - 1), E = u[i + p], v = u[i + m];
        m === p + 1 && m + 1 === a && E.equals(v) && (s = !0);
        const b = f.root(E, v);
        u.push(b);
      }
      i += a, a = a + 1 >>> 1;
    }
    return [u, s];
  }
  function d(f, n) {
    e(f && typeof f.root == "function"), e(Array.isArray(n));
    const [u, a] = c(f, n);
    return [u[u.length - 1], a];
  }
  function w(f, n, u) {
    e(f && typeof f.root == "function"), e(n >>> 0 === n), e(Array.isArray(u)), e(n < u.length);
    let a = u.length;
    const [s] = c(f, u), i = [];
    let p = 0;
    for (; a > 1; ) {
      const m = Math.min(n ^ 1, a - 1);
      i.push(s[p + m]), n >>>= 1, p += a, a = a + 1 >>> 1;
    }
    return i;
  }
  function g(f, n, u, a) {
    e(f && typeof f.root == "function"), e(k.isBuffer(n)), e(Array.isArray(u)), e(a >>> 0 === a);
    let s = n;
    for (const i of u) {
      if (a & 1 && i.equals(s))
        return f.zero;
      a & 1 ? s = f.root(i, s) : s = f.root(s, i), a >>>= 1;
    }
    return s;
  }
  return ji.createTree = c, ji.createRoot = d, ji.createBranch = w, ji.deriveRoot = g, ji;
}
/*!
 * input.js - input object for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var ra, Fd;
function eo() {
  if (Fd) return ra;
  Fd = 1;
  const e = nt, c = kt, d = _r(), w = ii(), g = dn(), { inspectSymbol: f } = fr();
  class n {
    /**
     * Create transaction input.
     * @constructor
     * @param {Object} options
     */
    constructor(a) {
      this.prevout = new g(), this.script = new w(), this.sequence = 4294967295, a && this.fromOptions(a);
    }
    /**
     * Inject properties from options object.
     * @private
     * @param {Object} options
     */
    fromOptions(a) {
      return e(a, "Input data is required."), this.prevout.fromOptions(a.prevout), a.script && this.script.fromOptions(a.script), a.sequence != null && (e(
        a.sequence >>> 0 === a.sequence,
        "Sequence must be a uint32."
      ), this.sequence = a.sequence), this;
    }
    /**
     * Instantiate an Input from options object.
     * @param {Object} options
     * @returns {Input}
     */
    static fromOptions(a) {
      return new this().fromOptions(a);
    }
    /**
     * Clone the input.
     * @returns {Input}
     */
    clone() {
      const a = new this.constructor();
      return a.prevout = this.prevout, a.script.inject(this.script), a.sequence = this.sequence, a;
    }
    /**
     * Test equality against another input.
     * @param {Input} input
     * @returns {Boolean}
     */
    equals(a) {
      return e(n.isInput(a)), this.prevout.equals(a.prevout);
    }
    /**
     * Compare against another input (BIP69).
     * @param {Input} input
     * @returns {Number}
     */
    compare(a) {
      return e(n.isInput(a)), this.prevout.compare(a.prevout);
    }
    /**
     * Get the previous output script type as a string.
     * Will "guess" based on the input script and/or
     * witness if coin is not available.
     * @param {Coin?} coin
     * @returns {ScriptType} type
     */
    getType(a) {
      if (this.isCoinbase())
        return "coinbase";
      if (a)
        return a.getType();
      const s = this.script.getInputType();
      return w.typesByVal[s].toLowerCase();
    }
    /**
     * Get the redeem script.
     * @param {Coin?} coin
     * @returns {Script?} Redeem script.
     */
    getRedeem(a) {
      if (this.isCoinbase())
        return null;
      if (!a)
        return this.script.isScripthashInput() ? this.script.getRedeem() : null;
      let s = a.script, i = null;
      return s.isScripthash() && (s = this.script.getRedeem(), i = s), i;
    }
    /**
     * Get the redeem script type.
     * @param {Coin?} coin
     * @returns {String} subtype
     */
    getSubtype(a) {
      if (this.isCoinbase())
        return null;
      const s = this.getRedeem(a);
      if (!s)
        return null;
      const i = s.getType();
      return w.typesByVal[i].toLowerCase();
    }
    /**
     * Get the previous output script's address. Will "guess"
     * based on the input script and/or witness if coin
     * is not available.
     * @param {Coin?} coin
     * @returns {Address?} addr
     */
    getAddress(a) {
      return this.isCoinbase() ? null : a ? a.getAddress() : this.script.code.length > 0 ? this.script.getInputAddress() : null;
    }
    /**
     * Get the address hash.
     * @param {Coin?} coin
     * @param {String?} enc
     * @returns {Hash} hash
     */
    getHash(a, s) {
      const i = this.getAddress(a);
      return i ? i.getHash(s) : null;
    }
    /**
     * Test to see if nSequence is equal to uint32max.
     * @returns {Boolean}
     */
    isFinal() {
      return this.sequence === 4294967295;
    }
    /**
     * Test to see if nSequence is less than 0xfffffffe.
     * @returns {Boolean}
     */
    isRBF() {
      return this.sequence < 4294967294;
    }
    /**
     * Test to see if outpoint is null.
     * @returns {Boolean}
     */
    isCoinbase() {
      return this.prevout.isNull();
    }
    /**
     * Convert the input to a more user-friendly object.
     * @returns {Object}
     */
    [f]() {
      return this.format();
    }
    /**
     * Convert the input to a more user-friendly object.
     * @param {Coin?} coin
     * @returns {Object}
     */
    format(a) {
      return {
        type: this.getType(a),
        subtype: this.getSubtype(a),
        address: this.getAddress(a),
        script: this.script,
        redeem: this.getRedeem(a),
        sequence: this.sequence,
        prevout: this.prevout,
        coin: a || null
      };
    }
    /**
     * Convert the input to an object suitable
     * for JSON serialization.
     * @returns {Object}
     */
    toJSON(a, s) {
      return this.getJSON();
    }
    /**
     * Convert the input to an object suitable
     * for JSON serialization. Note that the hashes
     * will be reversed to abide by bitcoind's legacy
     * of little-endian uint256s.
     * @param {Network} network
     * @param {Coin} coin
     * @returns {Object}
     */
    getJSON(a, s) {
      a = d.get(a);
      let i;
      return s || (i = this.getAddress(), i && (i = i.toString(a))), {
        prevout: this.prevout.toJSON(),
        script: this.script.toJSON(),
        sequence: this.sequence,
        address: i,
        coin: s ? s.getJSON(a, !0) : void 0
      };
    }
    /**
     * Inject properties from a JSON object.
     * @private
     * @param {Object} json
     */
    fromJSON(a) {
      return e(a, "Input data is required."), e(
        a.sequence >>> 0 === a.sequence,
        "Sequence must be a uint32."
      ), this.prevout.fromJSON(a.prevout), this.script.fromJSON(a.script), this.sequence = a.sequence, this;
    }
    /**
     * Instantiate an Input from a jsonified input object.
     * @param {Object} json - The jsonified input object.
     * @returns {Input}
     */
    static fromJSON(a) {
      return new this().fromJSON(a);
    }
    /**
     * Calculate size of serialized input.
     * @returns {Number}
     */
    getSize() {
      return 40 + this.script.getVarSize();
    }
    /**
     * Serialize the input.
     * @param {String?} enc - Encoding, can be `'hex'` or null.
     * @returns {Buffer|String}
     */
    toRaw() {
      const a = this.getSize();
      return this.toWriter(c.write(a)).render();
    }
    /**
     * Write the input to a buffer writer.
     * @param {BufferWriter} bw
     */
    toWriter(a) {
      return this.prevout.toWriter(a), a.writeVarBytes(this.script.toRaw()), a.writeU32(this.sequence), a;
    }
    /**
     * Inject properties from buffer reader.
     * @private
     * @param {BufferReader} br
     */
    fromReader(a) {
      return this.prevout.fromReader(a), this.script.fromRaw(a.readVarBytes()), this.sequence = a.readU32(), this;
    }
    /**
     * Inject properties from serialized data.
     * @param {Buffer} data
     */
    fromRaw(a) {
      return this.fromReader(c.read(a));
    }
    /**
     * Instantiate an input from a buffer reader.
     * @param {BufferReader} br
     * @returns {Input}
     */
    static fromReader(a) {
      return new this().fromReader(a);
    }
    /**
     * Instantiate an input from a serialized Buffer.
     * @param {Buffer} data
     * @param {String?} enc - Encoding, can be `'hex'` or null.
     * @returns {Input}
     */
    static fromRaw(a, s) {
      return typeof a == "string" && (a = k.from(a, s)), new this().fromRaw(a);
    }
    /**
     * Inject properties from outpoint.
     * @private
     * @param {Outpoint} outpoint
     */
    fromOutpoint(a) {
      return e(k.isBuffer(a.hash)), e(typeof a.index == "number"), this.prevout.hash = a.hash, this.prevout.index = a.index, this;
    }
    /**
     * Instantiate input from outpoint.
     * @param {Outpoint}
     * @returns {Input}
     */
    static fromOutpoint(a) {
      return new this().fromOutpoint(a);
    }
    /**
     * Inject properties from coin.
     * @private
     * @param {Coin} coin
     */
    fromCoin(a) {
      return e(k.isBuffer(a.hash)), e(typeof a.index == "number"), this.prevout.hash = a.hash, this.prevout.index = a.index, this;
    }
    /**
     * Instantiate input from coin.
     * @param {Coin}
     * @returns {Input}
     */
    static fromCoin(a) {
      return new this().fromCoin(a);
    }
    /**
     * Inject properties from transaction.
     * @private
     * @param {TX} tx
     * @param {Number} index
     */
    fromTX(a, s) {
      return e(a), e(typeof s == "number"), e(s >= 0 && s < a.outputs.length), this.prevout.hash = a.hash(), this.prevout.index = s, this;
    }
    /**
     * Instantiate input from tx.
     * @param {TX} tx
     * @param {Number} index
     * @returns {Input}
     */
    static fromTX(a, s) {
      return new this().fromTX(a, s);
    }
    /**
     * Test an object to see if it is an Input.
     * @param {Object} obj
     * @returns {Boolean}
     */
    static isInput(a) {
      return a instanceof n;
    }
  }
  return ra = n, ra;
}
/*!
 * tx.js - transaction object for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var ia, Hd;
function Jn() {
  if (Hd) return ia;
  Hd = 1;
  const e = nt, c = kt, d = Or(), w = Fr(), { BufferSet: g } = un, f = ur(), n = Ni(), u = _r(), a = ii(), s = Xs(), i = eo(), p = Ui(), m = dn(), E = Qs(), v = Xt(), b = ln(), h = js(), { encoding: o } = c, { hashType: S } = a, H = Yn(), { inspectSymbol: j } = fr();
  class J {
    /**
     * Create a transaction.
     * @constructor
     * @param {Object?} options
     */
    constructor(A) {
      this.version = 1, this.inputs = [], this.outputs = [], this.locktime = 0, this.mutable = !1, this._hash = null, this._hhash = null, this._raw = null, this._offset = -1, this._block = !1, this._size = -1, this._sigops = -1, this._hashPrevouts = null, this._hashSequence = null, this._hashOutputs = null, A && this.fromOptions(A);
    }
    /**
     * Inject properties from options object.
     * @private
     * @param {Object} options
     */
    fromOptions(A) {
      if (e(A, "TX data is required."), A.version != null && (e(
        A.version >>> 0 === A.version,
        "Version must be a uint32."
      ), this.version = A.version), A.inputs) {
        e(Array.isArray(A.inputs), "Inputs must be an array.");
        for (const q of A.inputs)
          this.inputs.push(new i(q));
      }
      if (A.outputs) {
        e(Array.isArray(A.outputs), "Outputs must be an array.");
        for (const q of A.outputs)
          this.outputs.push(new p(q));
      }
      return A.locktime != null && (e(
        A.locktime >>> 0 === A.locktime,
        "Locktime must be a uint32."
      ), this.locktime = A.locktime), A.slpToken && A.slpToken.constructor === s.TokenRecord().constructor && (this.slpToken = A.slpToken), this;
    }
    /**
     * Instantiate TX from options object.
     * @param {Object} options
     * @returns {TX}
     */
    static fromOptions(A) {
      return new this().fromOptions(A);
    }
    /**
     * Clone the transaction.
     * @returns {TX}
     */
    clone() {
      return new this.constructor().inject(this);
    }
    /**
     * Inject properties from tx.
     * Used for cloning.
     * @private
     * @param {TX} tx
     * @returns {TX}
     */
    inject(A) {
      this.version = A.version;
      for (const q of A.inputs)
        this.inputs.push(q.clone());
      for (const q of A.outputs)
        this.outputs.push(q.clone());
      return this.locktime = A.locktime, this;
    }
    /**
     * Clear any cached values.
     */
    refresh() {
      this._hash = null, this._hhash = null, this._raw = null, this._size = -1, this._offset = -1, this._block = !1, this._sigops = -1, this._hashPrevouts = null, this._hashSequence = null, this._hashOutputs = null;
    }
    /**
     * Hash the transaction with the non-witness serialization.
     * @param {String?} enc - Can be `'hex'` or `null`.
     * @returns {Hash|Buffer} hash
     */
    hash(A) {
      let q = this._hash;
      if (q || (q = d.digest(this.toRaw()), this.mutable || (this._hash = q)), A === "hex") {
        let _ = this._hhash;
        _ || (_ = q.toString("hex"), this.mutable || (this._hhash = _)), q = _;
      }
      return q;
    }
    /**
     * Serialize the transaction. Note
     * that this is cached.
     * @returns {Buffer} Serialized transaction.
     */
    toRaw() {
      return this.frame().data;
    }
    /**
     * Write the transaction to a buffer writer.
     * @param {BufferWriter} bw
     * @param {Boolean} block
     */
    toWriter(A, q) {
      return this.mutable ? this.writeNormal(A) : (q && (this._offset = A.offset, this._block = !0), A.writeBytes(this.toRaw()), A);
    }
    /**
     * Serialize the transaction. Note
     * that this is cached.
     * @private
     * @returns {RawTX}
     */
    frame() {
      if (this.mutable)
        return e(!this._raw), this.frameNormal();
      if (this._raw) {
        e(this._size >= 0);
        const q = new N(this._size);
        return q.data = this._raw, q;
      }
      const A = this.frameNormal();
      return this._raw = A.data, this._size = A.size, A;
    }
    /**
     * Return the offset and size of the transaction. Useful
     * when the transaction is deserialized within a block.
     * @returns {Object} contains `size` and `offset`.
     */
    getPosition() {
      return this._block && this._offset > 80 || console.log(this), e(this._block && this._offset > 80, "Position not available."), {
        offset: this._offset,
        size: this._size
      };
    }
    /**
     * Calculate the real size of the transaction.
     * @returns {Number} size
     */
    getSize() {
      return this.mutable ? this.getNormalSizes().size : this.frame().size;
    }
    /**
     * Get the signature hash of the transaction for signing verifying.
     * @param {Number} index - Index of input being signed/verified.
     * @param {Script} prev - Previous output script or redeem script.
     * @param {Amount} value - Previous output value.
     * @param {SighashType} type - Sighash type.
     * @param {Number} flags - Script flags.
     * @returns {Buffer} Signature hash.
     */
    signatureHash(A, q, _, F, R) {
      if (e(A >= 0 && A < this.inputs.length), e(q instanceof a), e(typeof _ == "number"), e(typeof F == "number"), R == null && (R = a.flags.STANDARD_VERIFY_FLAGS), R & a.flags.VERIFY_REPLAY_PROTECTION) {
        const V = H.getHashTypeForkValue(F) ^ 57005;
        F = H.hashTypeWithForkValue(F, V | 16711680);
      }
      return F & a.hashType.SIGHASH_FORKID && R & a.flags.VERIFY_SIGHASH_FORKID ? this.signatureHashV1(A, q, _, F) : this.signatureHashV0(A, q, F);
    }
    /**
     * Legacy sighashing -- O(n^2).
     * @private
     * @param {Number} index
     * @param {Script} prev
     * @param {SighashType} type
     * @returns {Buffer}
     */
    signatureHashV0(A, q, _) {
      if ((_ & 31) === S.SINGLE && A >= this.outputs.length) {
        const V = k.alloc(32, 0);
        return V[0] = 1, V;
      }
      q = q.removeSeparators();
      const F = this.hashSize(A, q, _), R = c.pool(F);
      if (R.writeU32(this.version), _ & S.ANYONECANPAY) {
        const V = this.inputs[A];
        R.writeVarint(1), V.prevout.toWriter(R), R.writeVarBytes(q.toRaw()), R.writeU32(V.sequence);
      } else {
        R.writeVarint(this.inputs.length);
        for (let V = 0; V < this.inputs.length; V++) {
          const fe = this.inputs[V];
          if (fe.prevout.toWriter(R), V === A) {
            R.writeVarBytes(q.toRaw()), R.writeU32(fe.sequence);
            continue;
          }
          switch (R.writeVarint(0), _ & 31) {
            case S.NONE:
            case S.SINGLE:
              R.writeU32(0);
              break;
            default:
              R.writeU32(fe.sequence);
              break;
          }
        }
      }
      switch (_ & 31) {
        case S.NONE: {
          R.writeVarint(0);
          break;
        }
        case S.SINGLE: {
          const V = this.outputs[A];
          R.writeVarint(A + 1);
          for (let fe = 0; fe < A; fe++)
            R.writeI64(-1), R.writeVarint(0);
          V.toWriter(R);
          break;
        }
        default: {
          R.writeVarint(this.outputs.length);
          for (const V of this.outputs)
            V.toWriter(R);
          break;
        }
      }
      return R.writeU32(this.locktime), R.writeU32(_), d.digest(R.render());
    }
    /**
     * Calculate sighash size.
     * @private
     * @param {Number} index
     * @param {Script} prev
     * @param {Number} type
     * @returns {Number}
     */
    hashSize(A, q, _) {
      let F = 0;
      switch (F += 4, _ & S.ANYONECANPAY ? (F += 1, F += 36, F += q.getVarSize(), F += 4) : (F += o.sizeVarint(this.inputs.length), F += 41 * (this.inputs.length - 1), F += 36, F += q.getVarSize(), F += 4), _ & 31) {
        case S.NONE:
          F += 1;
          break;
        case S.SINGLE:
          F += o.sizeVarint(A + 1), F += 9 * A, F += this.outputs[A].getSize();
          break;
        default:
          F += o.sizeVarint(this.outputs.length);
          for (const R of this.outputs)
            F += R.getSize();
          break;
      }
      return F += 8, F;
    }
    /**
     * Witness sighashing -- O(n).
     * @private
     * @param {Number} index
     * @param {Script} prev
     * @param {Amount} value
     * @param {SighashType} type
     * @returns {Buffer}
     */
    signatureHashV1(A, q, _, F) {
      const R = this.inputs[A];
      let V = v.ZERO_HASH, fe = v.ZERO_HASH, ue = v.ZERO_HASH;
      if (!(F & S.ANYONECANPAY))
        if (this._hashPrevouts)
          V = this._hashPrevouts;
        else {
          const Q = c.pool(this.inputs.length * 36);
          for (const Z of this.inputs)
            Z.prevout.toWriter(Q);
          V = d.digest(Q.render()), this.mutable || (this._hashPrevouts = V);
        }
      if (!(F & S.ANYONECANPAY) && (F & 31) !== S.SINGLE && (F & 31) !== S.NONE)
        if (this._hashSequence)
          fe = this._hashSequence;
        else {
          const Q = c.pool(this.inputs.length * 4);
          for (const Z of this.inputs)
            Q.writeU32(Z.sequence);
          fe = d.digest(Q.render()), this.mutable || (this._hashSequence = fe);
        }
      if ((F & 31) !== S.SINGLE && (F & 31) !== S.NONE)
        if (this._hashOutputs)
          ue = this._hashOutputs;
        else {
          let Q = 0;
          for (const oe of this.outputs)
            Q += oe.getSize();
          const Z = c.pool(Q);
          for (const oe of this.outputs)
            oe.toWriter(Z);
          ue = d.digest(Z.render()), this.mutable || (this._hashOutputs = ue);
        }
      else if ((F & 31) === S.SINGLE && A < this.outputs.length) {
        const Q = this.outputs[A];
        ue = d.digest(Q.toRaw());
      }
      const ae = 156 + q.getVarSize(), D = c.pool(ae);
      return D.writeU32(this.version), D.writeBytes(V), D.writeBytes(fe), D.writeHash(R.prevout.hash), D.writeU32(R.prevout.index), D.writeVarBytes(q.toRaw()), D.writeI64(_), D.writeU32(R.sequence), D.writeBytes(ue), D.writeU32(this.locktime), D.writeU32(F), d.digest(D.render());
    }
    /**
     * Verify signature.
     * @param {Number} index
     * @param {Script} prev
     * @param {Amount} value
     * @param {Buffer} sig
     * @param {Buffer} key
     * @param {Number} flags
     * @returns {Boolean}
     */
    checksig(A, q, _, F, R, V) {
      if (F.length === 0)
        return !1;
      const fe = F[F.length - 1], ue = this.signatureHash(A, q, _, fe, V);
      let ae;
      return H.isSchnorr(F) ? ae = w.schnorrVerify(ue, F.slice(0, -1), R) : ae = w.verifyDER(ue, F.slice(0, -1), R), ae;
    }
    /**
     * Create a signature suitable for inserting into scriptSigs.
     * @param {Number} index - Index of input being signed.
     * @param {Script} prev - Previous output script or redeem script.
     * @param {Amount} value - Previous output value.
     * @param {Buffer} key
     * @param {SighashType} type
     * @param {Number} flags - Script flags.
     * @returns {Buffer} Signature in SCHNORR / DER format.
     */
    signature(A, q, _, F, R, V) {
      let fe;
      R == null && (R = S.ALL), V == null && (V = a.flags.VERIFY_SIGHASH_FORKID);
      const ue = this.signatureHash(A, q, _, R, V), ae = w.signDER(ue, F), D = w.schnorrSign(ue, F);
      H.isSchnorr(D) ? fe = D : fe = ae;
      const Q = c.write(fe.length + 1);
      return Q.writeBytes(fe), Q.writeU8(R), Q.render();
    }
    /**
     * Create a signature suitable for inserting into scriptSigs.
     * @param {Number} index - Index of input being signed.
     * @param {Script} prev - Previous output script or redeem script.
     * @param {Amount} value - Previous output value.
     * @param {Buffer} key
     * @param {SighashType} type
     * @param {Number} flags - Script flags.
     * @returns {Buffer} Signature in Schnorr format.
     */
    schnorrSignature(A, q, _, F, R, V) {
      R == null && (R = S.ALL), V == null && (V = a.flags.VERIFY_SIGHASH_FORKID);
      const fe = this.signatureHash(A, q, _, R, V), ue = w.schnorrSign(fe, F), ae = c.write(ue.length + 1);
      return ae.writeBytes(ue), ae.writeU8(R), ae.render();
    }
    /**
     * Verify all transaction inputs.
     * @param {CoinView} view
     * @param {VerifyFlags?} [flags=STANDARD_VERIFY_FLAGS]
     * @throws {ScriptError} on invalid inputs
     */
    check(A, q) {
      if (this.inputs.length === 0)
        throw new h("UNKNOWN_ERROR", "No inputs.");
      if (!this.isCoinbase())
        for (let _ = 0; _ < this.inputs.length; _++) {
          const { prevout: F } = this.inputs[_], R = A.getOutput(F);
          if (!R)
            throw new h("UNKNOWN_ERROR", "No coin available.");
          this.checkInput(_, R, q);
        }
    }
    /**
     * Verify a transaction input.
     * @param {Number} index - Index of output being
     * verified.
     * @param {Coin|Output} coin - Previous output.
     * @param {VerifyFlags} [flags=STANDARD_VERIFY_FLAGS]
     * @throws {ScriptError} on invalid input
     */
    checkInput(A, q, _) {
      const F = this.inputs[A];
      e(F, "Input does not exist."), e(q, "No coin passed."), a.verify(
        F.script,
        null,
        q.script,
        this,
        A,
        q.value,
        _
      );
    }
    /**
     * Verify the transaction inputs on the worker pool
     * (if workers are enabled).
     * @param {CoinView} view
     * @param {VerifyFlags?} [flags=STANDARD_VERIFY_FLAGS]
     * @param {WorkerPool?} pool
     * @returns {Promise}
     */
    async checkAsync(A, q, _) {
      if (this.inputs.length === 0)
        throw new h("UNKNOWN_ERROR", "No inputs.");
      if (!this.isCoinbase()) {
        if (!_) {
          this.check(A, q);
          return;
        }
        await _.check(this, A, q);
      }
    }
    /**
     * Verify a transaction input asynchronously.
     * @param {Number} index - Index of output being
     * verified.
     * @param {Coin|Output} coin - Previous output.
     * @param {VerifyFlags} [flags=STANDARD_VERIFY_FLAGS]
     * @param {WorkerPool?} pool
     * @returns {Promise}
     */
    async checkInputAsync(A, q, _, F) {
      const R = this.inputs[A];
      if (e(R, "Input does not exist."), e(q, "No coin passed."), !F) {
        this.checkInput(A, q, _);
        return;
      }
      await F.checkInput(this, A, q, _);
    }
    /**
     * Verify all transaction inputs.
     * @param {CoinView} view
     * @param {VerifyFlags?} [flags=STANDARD_VERIFY_FLAGS]
     * @returns {Boolean} Whether the inputs are valid.
     */
    verify(A, q) {
      try {
        this.check(A, q);
      } catch (_) {
        if (_.type === "ScriptError")
          return !1;
        throw _;
      }
      return !0;
    }
    /**
     * Verify a transaction input.
     * @param {Number} index - Index of output being
     * verified.
     * @param {Coin|Output} coin - Previous output.
     * @param {VerifyFlags} [flags=STANDARD_VERIFY_FLAGS]
     * @returns {Boolean} Whether the input is valid.
     */
    verifyInput(A, q, _) {
      try {
        this.checkInput(A, q, _);
      } catch (F) {
        if (F.type === "ScriptError")
          return !1;
        throw F;
      }
      return !0;
    }
    /**
     * Verify the transaction inputs on the worker pool
     * (if workers are enabled).
     * @param {CoinView} view
     * @param {VerifyFlags?} [flags=STANDARD_VERIFY_FLAGS]
     * @param {WorkerPool?} pool
     * @returns {Promise}
     */
    async verifyAsync(A, q, _) {
      try {
        await this.checkAsync(A, q, _);
      } catch (F) {
        if (F.type === "ScriptError")
          return !1;
        throw F;
      }
      return !0;
    }
    /**
     * Verify a transaction input asynchronously.
     * @param {Number} index - Index of output being
     * verified.
     * @param {Coin|Output} coin - Previous output.
     * @param {VerifyFlags} [flags=STANDARD_VERIFY_FLAGS]
     * @param {WorkerPool?} pool
     * @returns {Promise}
     */
    async verifyInputAsync(A, q, _, F) {
      try {
        await this.checkInput(A, q, _, F);
      } catch (R) {
        if (R.type === "ScriptError")
          return !1;
        throw R;
      }
      return !0;
    }
    /**
     * Test whether the transaction is a coinbase
     * by examining the inputs.
     * @returns {Boolean}
     */
    isCoinbase() {
      return this.inputs.length === 1 && this.inputs[0].prevout.isNull();
    }
    /**
     * Test whether the transaction is replaceable.
     * @returns {Boolean}
     */
    isRBF() {
      if (this.version === 2)
        return !1;
      for (const A of this.inputs)
        if (A.isRBF())
          return !0;
      return !1;
    }
    /**
     * Calculate the fee for the transaction.
     * @param {CoinView} view
     * @returns {Amount} fee (zero if not all coins are available).
     */
    getFee(A) {
      return this.hasCoins(A) ? this.getInputValue(A) - this.getOutputValue() : 0;
    }
    /**
     * Calculate the total input value.
     * @param {CoinView} view
     * @returns {Amount} value
     */
    getInputValue(A) {
      let q = 0;
      for (const { prevout: _ } of this.inputs) {
        const F = A.getOutput(_);
        if (!F)
          return 0;
        q += F.value;
      }
      return q;
    }
    /**
     * Calculate the total output value.
     * @returns {Amount} value
     */
    getOutputValue() {
      let A = 0;
      for (const q of this.outputs)
        A += q.value;
      return A;
    }
    /**
     * Get all input addresses.
     * @private
     * @param {CoinView} view
     * @returns {Array} [addrs, table]
     */
    _getInputAddresses(A) {
      const q = new g(), _ = [];
      if (this.isCoinbase())
        return [_, q];
      for (const F of this.inputs) {
        const R = A ? A.getOutputFor(F) : null, V = F.getAddress(R);
        if (!V)
          continue;
        const fe = V.getHash();
        q.has(fe) || (q.add(fe), _.push(V));
      }
      return [_, q];
    }
    /**
     * Get all output addresses.
     * @private
     * @returns {Array} [addrs, table]
     */
    _getOutputAddresses() {
      const A = new g(), q = [];
      for (const _ of this.outputs) {
        const F = _.getAddress();
        if (!F)
          continue;
        const R = F.getHash();
        A.has(R) || (A.add(R), q.push(F));
      }
      return [q, A];
    }
    /**
     * Get all addresses.
     * @private
     * @param {CoinView} view
     * @returns {Array} [addrs, table]
     */
    _getAddresses(A) {
      const [q, _] = this._getInputAddresses(A), F = this.getOutputAddresses();
      for (const R of F) {
        const V = R.getHash();
        _.has(V) || (_.add(V), q.push(R));
      }
      return [q, _];
    }
    /**
     * Get all input addresses.
     * @param {CoinView|null} view
     * @returns {Address[]} addresses
     */
    getInputAddresses(A) {
      const [q] = this._getInputAddresses(A);
      return q;
    }
    /**
     * Get all output addresses.
     * @returns {Address[]} addresses
     */
    getOutputAddresses() {
      const [A] = this._getOutputAddresses();
      return A;
    }
    /**
     * Get all addresses.
     * @param {CoinView|null} view
     * @returns {Address[]} addresses
     */
    getAddresses(A) {
      const [q] = this._getAddresses(A);
      return q;
    }
    /**
     * Get all input address hashes.
     * @param {CoinView|null} view
     * @returns {Hash[]} hashes
     */
    getInputHashes(A, q) {
      const [, _] = this._getInputAddresses(A);
      return q !== "hex" ? _.toArray() : _.toArray().map((F) => F.toString("hex"));
    }
    /**
     * Get all output address hashes.
     * @returns {Hash[]} hashes
     */
    getOutputHashes(A) {
      const [, q] = this._getOutputAddresses();
      return A !== "hex" ? q.toArray() : q.toArray().map((_) => _.toString("hex"));
    }
    /**
     * Get all address hashes.
     * @param {CoinView|null} view
     * @returns {Hash[]} hashes
     */
    getHashes(A, q) {
      const [, _] = this._getAddresses(A);
      return q !== "hex" ? _.toArray() : _.toArray().map((F) => F.toString("hex"));
    }
    /**
     * Test whether the transaction has
     * all coins available.
     * @param {CoinView} view
     * @returns {Boolean}
     */
    hasCoins(A) {
      if (this.inputs.length === 0)
        return !1;
      for (const { prevout: q } of this.inputs)
        if (!A.hasEntry(q))
          return !1;
      return !0;
    }
    /**
     * Check finality of transaction by examining
     * nLocktime and nSequence values.
     * @example
     * tx.isFinal(chain.height + 1, network.now());
     * @param {Number} height - Height at which to test. This
     * is usually the chain height, or the chain height + 1
     * when the transaction entered the mempool.
     * @param {Number} time - Time at which to test. This is
     * usually the chain tip's parent's median time, or the
     * time at which the transaction entered the mempool. If
     * MEDIAN_TIME_PAST is enabled this will be the median
     * time of the chain tip's previous entry's median time.
     * @returns {Boolean}
     */
    isFinal(A, q) {
      const _ = v.LOCKTIME_THRESHOLD;
      if (this.locktime === 0 || this.locktime < (this.locktime < _ ? A : q))
        return !0;
      for (const F of this.inputs)
        if (F.sequence !== 4294967295)
          return !1;
      return !0;
    }
    /**
     * Verify the absolute locktime of a transaction.
     * Called by OP_CHECKLOCKTIMEVERIFY.
     * @param {Number} index - Index of input being verified.
     * @param {Number} predicate - Locktime to verify against.
     * @returns {Boolean}
     */
    verifyLocktime(A, q) {
      const _ = v.LOCKTIME_THRESHOLD, F = this.inputs[A];
      return e(F, "Input does not exist."), e(q >= 0, "Locktime must be non-negative."), !(this.locktime < _ != q < _ || q > this.locktime || F.sequence === 4294967295);
    }
    /**
     * Verify the relative locktime of an input.
     * Called by OP_CHECKSEQUENCEVERIFY.
     * @param {Number} index - Index of input being verified.
     * @param {Number} predicate - Relative locktime to verify against.
     * @returns {Boolean}
     */
    verifySequence(A, q) {
      const _ = v.SEQUENCE_DISABLE_FLAG, F = v.SEQUENCE_TYPE_FLAG, R = v.SEQUENCE_MASK, V = this.inputs[A];
      return e(V, "Input does not exist."), e(q >= 0, "Locktime must be non-negative."), q & _ ? !0 : !(this.version < 2 || V.sequence & _ || (V.sequence & F) !== (q & F) || (q & R) > (V.sequence & R));
    }
    /**
     * Calculate legacy (inaccurate) sigop count.
     * @returns {Number} sigop count
     */
    getLegacySigops() {
      if (this._sigops !== -1)
        return this._sigops;
      let A = 0;
      for (const q of this.inputs)
        A += q.script.getSigops(!1);
      for (const q of this.outputs)
        A += q.script.getSigops(!1);
      return this.mutable || (this._sigops = A), A;
    }
    /**
     * Calculate accurate sigop count, taking into account redeem scripts.
     * @param {CoinView} view
     * @param {VerifyFlags} flags
     * @returns {Number} sigop count
     */
    getScripthashSigops(A, q) {
      if (this.isCoinbase())
        return 0;
      let _ = 0;
      for (const F of this.inputs) {
        const R = A.getOutputFor(F);
        R && R.script.isScripthash() && (_ += R.script.getScripthashSigops(F.script, q));
      }
      return _;
    }
    /**
     * Calculate sigops count.
     * @param {CoinView} view
     * @param {VerifyFlags?} flags
     * @returns {Number} sigop count
     */
    getSigopsCount(A, q) {
      q === null && (q = a.flags.STANDARD_VERIFY_FLAGS);
      let _ = this.getLegacySigops();
      return q & a.flags.VERIFY_P2SH && (_ += this.getScripthashSigops(A, q)), _;
    }
    /**
     * Calculate sigop count.
     * @param {CoinView} view
     * @param {VerifyFlags?} flags
     * @returns {Number} sigop count
     */
    getSigops(A, q) {
      return this.getSigopsCount(A, q);
    }
    /**
     * Non-contextual sanity checks for the transaction.
     * Will mostly verify coin and output values.
     * @see CheckTransaction()
     * @returns {Array} [result, reason, score]
     */
    isSane() {
      const [A] = this.checkSanity();
      return A;
    }
    /**
     * Non-contextual sanity checks for the transaction.
     * Will mostly verify coin and output values.
     * @see CheckTransaction()
     * @returns {Array} [valid, reason, score]
     */
    checkSanity() {
      if (this.inputs.length === 0)
        return [!1, "bad-txns-vin-empty", 100];
      if (this.outputs.length === 0)
        return [!1, "bad-txns-vout-empty", 100];
      if (this.getSize() > v.MAX_TX_SIZE)
        return [!1, "bad-txns-oversize", 100];
      let A = 0;
      for (const _ of this.outputs) {
        if (_.value < 0)
          return [!1, "bad-txns-vout-negative", 100];
        if (_.value > v.MAX_MONEY)
          return [!1, "bad-txns-vout-toolarge", 100];
        if (A += _.value, A < 0 || A > v.MAX_MONEY)
          return [!1, "bad-txns-txouttotal-toolarge", 100];
      }
      const q = new g();
      for (const _ of this.inputs) {
        const F = _.prevout.toKey();
        if (q.has(F))
          return [!1, "bad-txns-inputs-duplicate", 100];
        q.add(F);
      }
      if (this.isCoinbase()) {
        const _ = this.inputs[0].script.getSize();
        if (_ < 2 || _ > v.MAX_COINBASE_SCRIPTSIG_SIZE)
          return [!1, "bad-cb-length", 100];
      } else
        for (const _ of this.inputs)
          if (_.prevout.isNull())
            return [!1, "bad-txns-prevout-null", 10];
      return [!0, "valid", 0];
    }
    /**
     * Non-contextual checks to determine whether the
     * transaction has all standard output script
     * types and standard input script size with only
     * pushdatas in the code.
     * Will mostly verify coin and output values.
     * @see IsStandardTx()
     * @returns {Array} [valid, reason, score]
     */
    isStandard() {
      const [A] = this.checkStandard();
      return A;
    }
    /**
     * Non-contextual checks to determine whether the
     * transaction has all standard output script
     * types and standard input script size with only
     * pushdatas in the code.
     * Will mostly verify coin and output values.
     * @see IsStandardTx()
     * @returns {Array} [valid, reason, score]
     */
    checkStandard() {
      if (this.version < 1 || this.version > b.MAX_TX_VERSION)
        return [!1, "version", 0];
      if (this.getSize() >= b.MAX_TX_SIZE)
        return [!1, "tx-size", 0];
      for (const q of this.inputs) {
        if (q.script.getSize() > 1650)
          return [!1, "scriptsig-size", 0];
        if (!q.script.isPushOnly())
          return [!1, "scriptsig-not-pushonly", 0];
      }
      let A = 0;
      for (const q of this.outputs) {
        if (!q.script.isStandard())
          return [!1, "scriptpubkey", 0];
        if (q.script.isNulldata()) {
          A++;
          continue;
        }
        if (q.script.isMultisig() && !b.BARE_MULTISIG)
          return [!1, "bare-multisig", 0];
        if (q.isDust(b.MIN_RELAY))
          return [!1, "dust", 0];
      }
      return A > 1 ? [!1, "multi-op-return", 0] : [!0, "valid", 0];
    }
    /**
     * Perform contextual checks to verify coin and input
     * script standardness (including the redeem script).
     * @see AreInputsStandard()
     * @param {CoinView} view
     * @param {VerifyFlags?} flags
     * @returns {Boolean}
     */
    hasStandardInputs(A) {
      if (this.isCoinbase())
        return !0;
      for (const q of this.inputs) {
        const _ = A.getOutputFor(q);
        if (!_)
          return !1;
        if (!_.script.isPubkeyhash()) {
          if (_.script.isScripthash()) {
            const F = q.script.getRedeem();
            if (!F || F.getSigops(!0) > b.MAX_P2SH_SIGOPS)
              return !1;
            continue;
          }
          if (_.script.isUnknown())
            return !1;
        }
      }
      return !0;
    }
    /**
     * Perform contextual checks to verify input, output,
     * and fee values, as well as coinbase spend maturity
     * (coinbases can only be spent 100 blocks or more
     * after they're created). Note that this function is
     * consensus critical.
     * @param {CoinView} view
     * @param {Number} height - Height at which the
     * transaction is being spent. In the mempool this is
     * the chain height plus one at the time it entered the pool.
     * @returns {Boolean}
     */
    verifyInputs(A, q) {
      const [_] = this.checkInputs(A, q);
      return _ !== -1;
    }
    /**
     * Perform contextual checks to verify input, output,
     * and fee values, as well as coinbase spend maturity
     * (coinbases can only be spent 100 blocks or more
     * after they're created). Note that this function is
     * consensus critical.
     * @param {CoinView} view
     * @param {Number} height - Height at which the
     * transaction is being spent. In the mempool this is
     * the chain height plus one at the time it entered the pool.
     * @returns {Array} [fee, reason, score]
     */
    checkInputs(A, q) {
      e(typeof q == "number");
      let _ = 0;
      for (const { prevout: V } of this.inputs) {
        const fe = A.getEntry(V);
        if (!fe)
          return [-1, "bad-txns-inputs-missingorspent", 0];
        if (fe.coinbase && q - fe.height < v.COINBASE_MATURITY)
          return [-1, "bad-txns-premature-spend-of-coinbase", 0];
        const ue = A.getOutput(V);
        if (e(ue), ue.value < 0 || ue.value > v.MAX_MONEY)
          return [-1, "bad-txns-inputvalues-outofrange", 100];
        if (_ += ue.value, _ < 0 || _ > v.MAX_MONEY)
          return [-1, "bad-txns-inputvalues-outofrange", 100];
      }
      const F = this.getOutputValue();
      if (_ < F)
        return [-1, "bad-txns-in-belowout", 100];
      const R = _ - F;
      return R < 0 ? [-1, "bad-txns-fee-negative", 100] : R > v.MAX_MONEY ? [-1, "bad-txns-fee-outofrange", 100] : [R, "valid", 0];
    }
    /**
     * Calculate the modified size of the transaction. This
     * is used in the mempool for calculating priority.
     * @param {Number?} size - The size to modify. If not present,
     * virtual size will be used.
     * @returns {Number} Modified size.
     */
    getModifiedSize(A) {
      A == null && (A = this.getSize());
      for (const q of this.inputs) {
        const _ = 41 + Math.min(110, q.script.getSize());
        A > _ && (A -= _);
      }
      return A;
    }
    /**
     * Calculate the transaction priority.
     * @param {CoinView} view
     * @param {Number} height
     * @param {Number?} size - Size to calculate priority
     * based on. If not present, virtual size will be used.
     * @returns {Number}
     */
    getPriority(A, q, _) {
      if (e(typeof q == "number", "Must pass in height."), this.isCoinbase())
        return 0;
      _ == null && (_ = this.getSize());
      let F = 0;
      for (const { prevout: R } of this.inputs) {
        const V = A.getOutput(R);
        if (!V)
          continue;
        const fe = A.getHeight(R);
        if (fe !== -1 && fe <= q) {
          const ue = q - fe;
          F += V.value * ue;
        }
      }
      return Math.floor(F / _);
    }
    /**
     * Calculate the transaction's on-chain value.
     * @param {CoinView} view
     * @returns {Number}
     */
    getChainValue(A) {
      if (this.isCoinbase())
        return 0;
      let q = 0;
      for (const { prevout: _ } of this.inputs) {
        const F = A.getOutput(_);
        !F || A.getHeight(_) === -1 || (q += F.value);
      }
      return q;
    }
    /**
     * Determine whether the transaction is above the
     * free threshold in priority. A transaction which
     * passed this test is most likely relayable
     * without a fee.
     * @param {CoinView} view
     * @param {Number?} height - If not present, tx
     * height or network height will be used.
     * @param {Number?} size - If not present, modified
     * size will be calculated and used.
     * @returns {Boolean}
     */
    isFree(A, q, _) {
      return this.getPriority(A, q, _) > b.FREE_THRESHOLD;
    }
    /**
     * Calculate minimum fee in order for the transaction
     * to be relayable (not the constant min relay fee).
     * @param {Number?} size - If not present, max size
     * estimation will be calculated and used.
     * @param {Rate?} rate - Rate of satoshi per kB.
     * @returns {Amount} fee
     */
    getMinFee(A, q) {
      return A == null && (A = this.getSize()), b.getMinFee(A, q);
    }
    /**
     * Calculate the minimum fee in order for the transaction
     * to be relayable, but _round to the nearest kilobyte
     * when taking into account size.
     * @param {Number?} size - If not present, max size
     * estimation will be calculated and used.
     * @param {Rate?} rate - Rate of satoshi per kB.
     * @returns {Amount} fee
     */
    getRoundFee(A, q) {
      return A == null && (A = this.getSize()), b.getRoundFee(A, q);
    }
    /**
     * Calculate the transaction's rate based on size
     * and fees. Size will be calculated if not present.
     * @param {CoinView} view
     * @param {Number?} size
     * @returns {Rate}
     */
    getRate(A, q) {
      const _ = this.getFee(A);
      return _ < 0 ? 0 : (q == null && (q = this.getSize()), b.getRate(q, _));
    }
    /**
     * Get all unique outpoint hashes.
     * @returns {Hash[]} Outpoint hashes.
     */
    getPrevout() {
      if (this.isCoinbase())
        return [];
      const A = new g();
      for (const q of this.inputs)
        A.add(q.prevout.hash);
      return A.toArray();
    }
    /**
     * Test a transaction against a bloom filter using
     * the BIP37 matching algorithm. Note that this may
     * update the filter depending on what the `update`
     * value is.
     * @see "Filter matching algorithm":
     * @see https://github.com/bitcoin/bips/blob/master/bip-0037.mediawiki
     * @param {BloomFilter} filter
     * @returns {Boolean} True if the transaction matched.
     */
    isWatched(A) {
      let q = !1;
      A.test(this.hash()) && (q = !0);
      for (let _ = 0; _ < this.outputs.length; _++) {
        const F = this.outputs[_];
        if (F.script.test(A)) {
          if (A.update === 1) {
            const R = m.fromTX(this, _);
            A.add(R.toRaw());
          } else if (A.update === 2 && (F.script.isPubkey() || F.script.isMultisig())) {
            const R = m.fromTX(this, _);
            A.add(R.toRaw());
          }
          q = !0;
        }
      }
      if (q)
        return q;
      for (const _ of this.inputs) {
        const F = _.prevout;
        if (A.test(F.toRaw()) || _.script.test(A))
          return !0;
      }
      return !1;
    }
    /**
     * Get little-endian tx hash.
     * @returns {Hash}
     */
    rhash() {
      return f.revHex(this.hash());
    }
    /**
     * Get little-endian tx hash.
     * @returns {Hash}
     */
    txid() {
      return this.rhash();
    }
    /**
     * Convert the tx to an inv item.
     * @returns {InvItem}
     */
    toInv() {
      return new E(E.types.TX, this.hash());
    }
    /**
     * Inspect the transaction and return a more
     * user-friendly representation of the data.
     * @returns {Object}
     */
    [j]() {
      return this.format();
    }
    /**
     * Inspect the transaction and return a more
     * user-friendly representation of the data.
     * @param {CoinView} view
     * @param {ChainEntry} entry
     * @param {Number} index
     * @returns {Object}
     */
    format(A, q, _) {
      let F = 0, R = 0, V = -1, fe = null, ue = 0, ae = null;
      A && (R = this.getFee(A), F = this.getRate(A), Number.isSafeInteger(F) || (F = 0)), q && (V = q.height, fe = f.revHex(q.hash), ue = q.time, ae = f.date(ue)), _ == null && (_ = -1);
      const D = {
        hash: this.txid(),
        size: this.getSize(),
        value: n.btc(this.getOutputValue()),
        fee: n.btc(R),
        rate: n.btc(F),
        minFee: n.btc(this.getMinFee()),
        height: V,
        block: fe,
        time: ue,
        date: ae,
        index: _,
        version: this.version,
        inputs: this.inputs.map((Q) => {
          const Z = A ? A.getOutputFor(Q) : null;
          return Q.format(Z);
        }),
        outputs: this.outputs,
        locktime: this.locktime
      };
      return this.slpToken ? {
        ...D,
        slpToken: this.slpToken
      } : D;
    }
    /**
     * Convert the transaction to an object suitable
     * for JSON serialization.
     * @returns {Object}
     */
    toJSON() {
      return this.getJSON();
    }
    /**
     * Convert the transaction to an object suitable
     * for JSON serialization. Note that the hashes
     * will be reversed to abide by bitcoind's legacy
     * of little-endian uint256s.
     * @param {Network} network
     * @param {CoinView} view
     * @param {ChainEntry} entry
     * @param {Number} index
     * @returns {Object}
     */
    getJSON(A, q, _, F) {
      let R, V, fe, ue, ae, D;
      q && (V = this.getFee(q), R = this.getRate(q), Number.isSafeInteger(R) || (R = 0)), _ && (fe = _.height, ue = f.revHex(_.hash), ae = _.time, D = f.date(ae)), A = u.get(A);
      const Q = {
        hash: this.txid(),
        fee: V,
        rate: R,
        mtime: f.now(),
        height: fe,
        block: ue,
        time: ae,
        date: D,
        index: F,
        version: this.version,
        inputs: this.inputs.map((Z) => {
          const oe = q ? q.getCoinFor(Z) : null;
          return Z.getJSON(A, oe);
        }),
        outputs: this.outputs.map((Z) => Z.getJSON(A)),
        locktime: this.locktime,
        hex: this.toRaw().toString("hex")
      };
      return this.slpToken ? {
        ...Q,
        slpToken: this.slpToken.getJSON()
      } : Q;
    }
    /**
     * Inject properties from a json object.
     * @private
     * @param {Object} json
     */
    fromJSON(A) {
      e(A, "TX data is required."), e(A.version >>> 0 === A.version, "Version must be a uint32."), e(Array.isArray(A.inputs), "Inputs must be an array."), e(Array.isArray(A.outputs), "Outputs must be an array."), e(
        A.locktime >>> 0 === A.locktime,
        "Locktime must be a uint32."
      ), this.version = A.version;
      for (const q of A.inputs)
        this.inputs.push(i.fromJSON(q));
      for (const q of A.outputs)
        this.outputs.push(p.fromJSON(q));
      return this.locktime = A.locktime, A.slpToken && (this.slpToken = s.TokenRecord().fromJSON(A.slpToken)), this;
    }
    /**
     * Instantiate a transaction from a
     * jsonified transaction object.
     * @param {Object} json - The jsonified transaction object.
     * @returns {TX}
     */
    static fromJSON(A) {
      return new this().fromJSON(A);
    }
    /**
     * Instantiate a transaction from a serialized Buffer.
     * @param {Buffer} data
     * @param {String?} enc - Encoding, can be `'hex'` or null.
     * @returns {TX}
     */
    static fromRaw(A, q) {
      return typeof A == "string" && (A = k.from(A, q)), new this().fromRaw(A);
    }
    /**
     * Instantiate a transaction from a buffer reader.
     * @param {BufferReader} br
     * @param {Boolean} block
     * @returns {TX}
     */
    static fromReader(A, q) {
      return new this().fromReader(A, q);
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     */
    fromRaw(A) {
      return this.fromReader(c.read(A));
    }
    /**
     * Inject properties from buffer reader.
     * @private
     * @param {BufferReader} br
     * @param {Boolean} block
     */
    fromReader(A, q) {
      const _ = A.start();
      this.version = A.readU32();
      const F = A.readVarint();
      for (let V = 0; V < F; V++)
        this.inputs.push(i.fromReader(A));
      const R = A.readVarint();
      for (let V = 0; V < R; V++)
        this.outputs.push(p.fromReader(A));
      return this.locktime = A.readU32(), q && (this._offset = _, this._block = !0), this.mutable ? A.end() : (this._raw = A.endData(), this._size = this._raw.length), this;
    }
    /**
     * Serialize transaction without witness.
     * @private
     * @returns {RawTX}
     */
    frameNormal() {
      const A = this.getNormalSizes(), q = c.write(A.size);
      return this.writeNormal(q), A.data = q.render(), A;
    }
    /**
     * Serialize transaction without witness.
     * @private
     * @param {BufferWriter} bw
     * @returns {RawTX}
     */
    writeNormal(A) {
      if (this.inputs.length === 0 && this.outputs.length !== 0)
        throw new Error("Cannot serialize zero-input tx.");
      A.writeU32(this.version), A.writeVarint(this.inputs.length);
      for (const q of this.inputs)
        q.toWriter(A);
      A.writeVarint(this.outputs.length);
      for (const q of this.outputs)
        q.toWriter(A);
      return A.writeU32(this.locktime), A;
    }
    /**
     * Calculate the real size of the transaction
     * without the witness vector.
     * @returns {RawTX}
     */
    getNormalSizes() {
      let A = 0;
      A += 4, A += o.sizeVarint(this.inputs.length);
      for (const q of this.inputs)
        A += q.getSize();
      A += o.sizeVarint(this.outputs.length);
      for (const q of this.outputs)
        A += q.getSize();
      return A += 4, new N(A, 0);
    }
    /**
     * Test whether an object is a TX.
     * @param {Object} obj
     * @returns {Boolean}
     */
    static isTX(A) {
      return A instanceof J;
    }
  }
  class N {
    constructor(A) {
      this.data = null, this.size = A;
    }
  }
  return ia = J, ia;
}
/*!
 * headers.js - headers object for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var na, Ld;
function Gn() {
  if (Ld) return na;
  Ld = 1;
  const e = kt, c = ur(), d = Xn(), { inspectSymbol: w } = fr();
  class g extends d {
    /**
     * Create headers.
     * @constructor
     * @param {Object} options
     */
    constructor(n) {
      super(), n && this.parseOptions(n);
    }
    /**
     * Perform non-contextual
     * verification on the headers.
     * @returns {Boolean}
     */
    verifyBody() {
      return !0;
    }
    /**
     * Get size of the headers.
     * @returns {Number}
     */
    getSize() {
      return 81;
    }
    /**
     * Serialize the headers to a buffer writer.
     * @param {BufferWriter} bw
     */
    toWriter(n) {
      return this.writeHead(n), n.writeVarint(0), n;
    }
    /**
     * Serialize the headers.
     * @returns {Buffer|String}
     */
    toRaw() {
      const n = this.getSize();
      return this.toWriter(e.write(n)).render();
    }
    /**
     * Inject properties from buffer reader.
     * @private
     * @param {Buffer} data
     */
    fromReader(n) {
      return this.readHead(n), n.readVarint(), this;
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     */
    fromRaw(n) {
      return this.fromReader(e.read(n));
    }
    /**
     * Instantiate headers from buffer reader.
     * @param {BufferReader} br
     * @returns {Headers}
     */
    static fromReader(n) {
      return new this().fromReader(n);
    }
    /**
     * Instantiate headers from serialized data.
     * @param {Buffer} data
     * @param {String?} enc - Encoding, can be `'hex'` or null.
     * @returns {Headers}
     */
    static fromRaw(n, u) {
      return typeof n == "string" && (n = k.from(n, u)), new this().fromRaw(n);
    }
    /**
     * Instantiate headers from serialized data.
     * @param {Buffer} data
     * @param {String?} enc - Encoding, can be `'hex'` or null.
     * @returns {Headers}
     */
    static fromHead(n, u) {
      return typeof n == "string" && (n = k.from(n, u)), new this().fromHead(n);
    }
    /**
     * Instantiate headers from a chain entry.
     * @param {ChainEntry} entry
     * @returns {Headers}
     */
    static fromEntry(n) {
      const u = new this();
      return u.version = n.version, u.prevBlock = n.prevBlock, u.merkleRoot = n.merkleRoot, u.time = n.time, u.bits = n.bits, u.nonce = n.nonce, u._hash = n.hash, u._hhash = n.hash, u;
    }
    /**
     * Convert the block to a headers object.
     * @returns {Headers}
     */
    toHeaders() {
      return this;
    }
    /**
     * Convert the block to a headers object.
     * @param {Block|MerkleBlock} block
     * @returns {Headers}
     */
    static fromBlock(n) {
      const u = new this(n);
      return u._hash = n._hash, u._hhash = n._hhash, u;
    }
    /**
     * Convert the block to an object suitable
     * for JSON serialization.
     * @returns {Object}
     */
    toJSON() {
      return this.getJSON();
    }
    /**
     * Convert the block to an object suitable
     * for JSON serialization. Note that the hashes
     * will be reversed to abide by bitcoind's legacy
     * of little-endian uint256s.
     * @param {Network} network
     * @param {CoinView} view
     * @param {Number} height
     * @returns {Object}
     */
    getJSON(n, u, a) {
      return {
        hash: this.rhash(),
        height: a,
        version: this.version,
        prevBlock: c.revHex(this.prevBlock),
        merkleRoot: c.revHex(this.merkleRoot),
        time: this.time,
        bits: this.bits,
        nonce: this.nonce
      };
    }
    /**
     * Inject properties from json object.
     * @private
     * @param {Object} json
     */
    fromJSON(n) {
      return this.parseJSON(n), this;
    }
    /**
     * Instantiate a merkle block from a jsonified block object.
     * @param {Object} json - The jsonified block object.
     * @returns {Headers}
     */
    static fromJSON(n) {
      return new this().fromJSON(n);
    }
    /**
     * Inspect the headers and return a more
     * user-friendly representation of the data.
     * @returns {Object}
     */
    [w]() {
      return this.format();
    }
    /**
     * Inspect the headers and return a more
     * user-friendly representation of the data.
     * @param {CoinView} view
     * @param {Number} height
     * @returns {Object}
     */
    format(n, u) {
      return {
        hash: this.rhash(),
        height: u ?? -1,
        date: c.date(this.time),
        version: this.version.toString(16),
        prevBlock: c.revHex(this.prevBlock),
        merkleRoot: c.revHex(this.merkleRoot),
        time: this.time,
        bits: this.bits,
        nonce: this.nonce
      };
    }
    /**
     * Test an object to see if it is a Headers object.
     * @param {Object} obj
     * @returns {Boolean}
     */
    static isHeaders(n) {
      return n instanceof g;
    }
  }
  return na = g, na;
}
/*!
 * merkleblock.js - merkleblock object for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var sa, Kd;
function Qh() {
  if (Kd) return sa;
  Kd = 1;
  const e = nt, c = kt, { BufferMap: d, BufferSet: w } = un, g = ur(), f = Or(), n = Xt(), u = Xn(), a = Gn(), s = k.from([0]), { encoding: i } = c, { inspectSymbol: p } = fr();
  class m extends u {
    /**
     * Create a merkle block.
     * @constructor
     * @param {Object} options
     */
    constructor(b) {
      super(), this.txs = [], this.hashes = [], this.flags = s, this.totalTX = 0, this._tree = null, b && this.fromOptions(b);
    }
    /**
     * Inject properties from options object.
     * @private
     * @param {Object} options
     */
    fromOptions(b) {
      if (this.parseOptions(b), e(b, "MerkleBlock data is required."), e(Array.isArray(b.hashes)), e(k.isBuffer(b.flags)), e(b.totalTX >>> 0 === b.totalTX), b.hashes)
        for (const h of b.hashes)
          e(k.isBuffer(h)), this.hashes.push(h);
      return b.flags && (e(k.isBuffer(b.flags)), this.flags = b.flags), b.totalTX != null && (e(b.totalTX >>> 0 === b.totalTX), this.totalTX = b.totalTX), this;
    }
    /**
     * Instantiate merkle block from options object.
     * @param {Object} options
     * @returns {MerkleBlock}
     */
    static fromOptions(b) {
      return new this().fromOptions(b);
    }
    /**
     * Clear any cached values.
     * @param {Boolean?} all - Clear transactions.
     */
    refresh(b) {
      if (this._refresh(), this._tree = null, !!b)
        for (const h of this.txs)
          h.refresh();
    }
    /**
     * Test the block's _matched_ transaction vector against a hash.
     * @param {Hash} hash
     * @returns {Boolean}
     */
    hasTX(b) {
      return this.indexOf(b) !== -1;
    }
    /**
     * Test the block's _matched_ transaction vector against a hash.
     * @param {Hash} hash
     * @returns {Number} Index.
     */
    indexOf(b) {
      const o = this.getTree().map.get(b);
      return o ?? -1;
    }
    /**
     * Verify the partial merkletree.
     * @private
     * @returns {Boolean}
     */
    verifyBody() {
      const [b] = this.checkBody();
      return b;
    }
    /**
     * Verify the partial merkletree.
     * @private
     * @returns {Array} [valid, reason, score]
     */
    checkBody() {
      return this.getTree().root.equals(this.merkleRoot) ? [!0, "valid", 0] : [!1, "bad-txnmrklroot", 100];
    }
    /**
     * Extract the matches from partial merkle
     * tree and calculate merkle root.
     * @returns {Object}
     */
    getTree() {
      if (!this._tree)
        try {
          this._tree = this.extractTree();
        } catch {
          this._tree = new E();
        }
      return this._tree;
    }
    /**
     * Extract the matches from partial merkle
     * tree and calculate merkle root.
     * @private
     * @returns {Object}
     */
    extractTree() {
      const b = [], h = [], o = new d(), S = this.hashes, H = this.flags, j = this.totalTX;
      let J = 0, N = 0, z = !1, A = 0;
      const q = (R) => j + (1 << R) - 1 >>> R, _ = (R, V) => {
        if (J >= H.length * 8)
          return z = !0, n.ZERO_HASH;
        const fe = H[J / 8 | 0] >>> J % 8 & 1;
        if (J += 1, R === 0 || !fe) {
          if (N >= S.length)
            return z = !0, n.ZERO_HASH;
          const D = S[N];
          return N += 1, R === 0 && fe && (b.push(D), h.push(V), o.set(D, V)), D;
        }
        const ue = _(R - 1, V * 2);
        let ae;
        return V * 2 + 1 < q(R - 1) ? (ae = _(R - 1, V * 2 + 1), ae.equals(ue) && (z = !0)) : ae = ue, f.root(ue, ae);
      };
      if (j === 0)
        throw new Error("Zero transactions.");
      if (S.length > j)
        throw new Error("Too many hashes.");
      if (H.length * 8 < S.length)
        throw new Error("Flags too small.");
      for (; q(A) > 1; )
        A += 1;
      const F = _(A, 0);
      if (z)
        throw new Error("Mutated merkle tree.");
      if (((J + 7) / 8 | 0) !== H.length)
        throw new Error("Too many flag bits.");
      if (N !== S.length)
        throw new Error("Incorrect number of hashes.");
      return new E(F, b, h, o);
    }
    /**
     * Extract the coinbase height (always -1).
     * @returns {Number}
     */
    getCoinbaseHeight() {
      return -1;
    }
    /**
     * Inspect the block and return a more
     * user-friendly representation of the data.
     * @returns {Object}
     */
    [p]() {
      return this.format();
    }
    /**
     * Inspect the block and return a more
     * user-friendly representation of the data.
     * @param {CoinView} view
     * @param {Number} height
     * @returns {Object}
     */
    format(b, h) {
      return {
        hash: this.rhash(),
        height: h ?? -1,
        date: g.date(this.time),
        version: this.version.toString(16),
        prevBlock: g.revHex(this.prevBlock),
        merkleRoot: g.revHex(this.merkleRoot),
        time: this.time,
        bits: this.bits,
        nonce: this.nonce,
        totalTX: this.totalTX,
        hashes: this.hashes.map((o) => o.toString("hex")),
        flags: this.flags,
        map: this.getTree().map,
        txs: this.txs.length
      };
    }
    /**
     * Get merkleblock size.
     * @returns {Number} Size.
     */
    getSize() {
      let b = 0;
      return b += 80, b += 4, b += i.sizeVarint(this.hashes.length), b += this.hashes.length * 32, b += i.sizeVarint(this.flags.length), b += this.flags.length, b;
    }
    /**
     * Write the merkleblock to a buffer writer.
     * @param {BufferWriter} bw
     */
    toWriter(b) {
      this.writeHead(b), b.writeU32(this.totalTX), b.writeVarint(this.hashes.length);
      for (const h of this.hashes)
        b.writeHash(h);
      return b.writeVarBytes(this.flags), b;
    }
    /**
     * Serialize the merkleblock.
     * @param {String?} enc - Encoding, can be `'hex'` or null.
     * @returns {Buffer|String}
     */
    toRaw() {
      const b = this.getSize();
      return this.toWriter(c.write(b)).render();
    }
    /**
     * Inject properties from buffer reader.
     * @private
     * @param {BufferReader} br
     */
    fromReader(b) {
      this.readHead(b), this.totalTX = b.readU32();
      const h = b.readVarint();
      for (let o = 0; o < h; o++)
        this.hashes.push(b.readHash());
      return this.flags = b.readVarBytes(), this;
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     */
    fromRaw(b) {
      return this.fromReader(c.read(b));
    }
    /**
     * Instantiate a merkleblock from a buffer reader.
     * @param {BufferReader} br
     * @returns {MerkleBlock}
     */
    static fromReader(b) {
      return new this().fromReader(b);
    }
    /**
     * Instantiate a merkleblock from a serialized data.
     * @param {Buffer} data
     * @param {String?} enc - Encoding, can be `'hex'` or null.
     * @returns {MerkleBlock}
     */
    static fromRaw(b, h) {
      return typeof b == "string" && (b = k.from(b, h)), new this().fromRaw(b);
    }
    /**
     * Convert the block to an object suitable
     * for JSON serialization.
     * @returns {Object}
     */
    toJSON() {
      return this.getJSON();
    }
    /**
     * Convert the block to an object suitable
     * for JSON serialization. Note that the hashes
     * will be reversed to abide by bitcoind's legacy
     * of little-endian uint256s.
     * @param {Network} network
     * @param {CoinView} view
     * @param {Number} height
     * @returns {Object}
     */
    getJSON(b, h, o) {
      return {
        hash: this.rhash(),
        height: o,
        version: this.version,
        prevBlock: g.revHex(this.prevBlock),
        merkleRoot: g.revHex(this.merkleRoot),
        time: this.time,
        bits: this.bits,
        nonce: this.nonce,
        totalTX: this.totalTX,
        hashes: this.hashes.map((S) => g.revHex(S)),
        flags: this.flags.toString("hex")
      };
    }
    /**
     * Inject properties from json object.
     * @private
     * @param {Object} json
     */
    fromJSON(b) {
      e(b, "MerkleBlock data is required."), e(Array.isArray(b.hashes)), e(typeof b.flags == "string"), e(b.totalTX >>> 0 === b.totalTX), this.parseJSON(b);
      for (const h of b.hashes)
        this.hashes.push(g.fromRev(h));
      return this.flags = k.from(b.flags, "hex"), this.totalTX = b.totalTX, this;
    }
    /**
     * Instantiate a merkle block from a jsonified block object.
     * @param {Object} json - The jsonified block object.
     * @returns {MerkleBlock}
     */
    static fromJSON(b) {
      return new this().fromJSON(b);
    }
    /**
     * Create a merkleblock from a {@link Block} object, passing
     * it through a filter first. This will build the partial
     * merkle tree.
     * @param {Block} block
     * @param {Bloom} filter
     * @returns {MerkleBlock}
     */
    static fromBlock(b, h) {
      const o = [];
      for (const S of b.txs)
        o.push(S.isWatched(h) ? 1 : 0);
      return this.fromMatches(b, o);
    }
    /**
     * Create a merkleblock from an array of txids.
     * This will build the partial merkle tree.
     * @param {Block} block
     * @param {Hash[]} hashes
     * @returns {MerkleBlock}
     */
    static fromHashes(b, h) {
      const o = new w();
      for (const H of h)
        o.add(H);
      const S = [];
      for (const H of b.txs) {
        const j = H.hash();
        S.push(o.has(j) ? 1 : 0);
      }
      return this.fromMatches(b, S);
    }
    /**
     * Create a merkleblock from an array of matches.
     * This will build the partial merkle tree.
     * @param {Block} block
     * @param {Number[]} matches
     * @returns {MerkleBlock}
     */
    static fromMatches(b, h) {
      const o = [], S = [], H = [], j = [], J = b.txs.length;
      let N = 0;
      const z = (R) => J + (1 << R) - 1 >>> R, A = (R, V, fe) => {
        if (R === 0)
          return fe[V];
        const ue = A(R - 1, V * 2, fe);
        let ae;
        return V * 2 + 1 < z(R - 1) ? ae = A(R - 1, V * 2 + 1, fe) : ae = ue, f.root(ue, ae);
      }, q = (R, V, fe, ue) => {
        let ae = 0;
        for (let D = V << R; D < V + 1 << R && D < J; D++)
          ae |= ue[D];
        if (H.push(ae), R === 0 || !ae) {
          j.push(A(R, V, fe));
          return;
        }
        q(R - 1, V * 2, fe, ue), V * 2 + 1 < z(R - 1) && q(R - 1, V * 2 + 1, fe, ue);
      };
      for (let R = 0; R < b.txs.length; R++) {
        const V = b.txs[R];
        h[R] && o.push(V), S.push(V.hash());
      }
      for (; z(N) > 1; )
        N += 1;
      q(N, 0, S, h);
      const _ = k.allocUnsafe((H.length + 7) / 8 | 0);
      _.fill(0);
      for (let R = 0; R < H.length; R++)
        _[R / 8 | 0] |= H[R] << R % 8;
      const F = new this();
      return F._hash = b._hash, F._hhash = b._hhash, F.version = b.version, F.prevBlock = b.prevBlock, F.merkleRoot = b.merkleRoot, F.time = b.time, F.bits = b.bits, F.nonce = b.nonce, F.totalTX = J, F.hashes = j, F.flags = _, F.txs = o, F;
    }
    /**
     * Test whether an object is a MerkleBlock.
     * @param {Object} obj
     * @returns {Boolean}
     */
    static isMerkleBlock(b) {
      return b instanceof m;
    }
    /**
     * Convert the block to a headers object.
     * @returns {Headers}
     */
    toHeaders() {
      return a.fromBlock(this);
    }
  }
  class E {
    constructor(b, h, o, S) {
      this.root = b || n.ZERO_HASH, this.matches = h || [], this.indexes = o || [], this.map = S || new d();
    }
  }
  return sa = m, sa;
}
/*!
 * block.js - block object for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var oa, Vd;
function el() {
  if (Vd) return oa;
  Vd = 1;
  const e = nt, c = kt, { BufferSet: d } = un, w = Or(), g = ab(), f = Xt(), n = Xn(), u = Jn(), a = Qh(), s = Gn(), i = _r(), p = ur(), { encoding: m } = c, { inspectSymbol: E } = fr();
  class v extends n {
    /**
     * Create a block.
     * @constructor
     * @param {Object} options
     */
    constructor(o) {
      super(), this.txs = [], this._raw = null, this._size = -1, o && this.fromOptions(o);
    }
    /**
     * Inject properties from options object.
     * @private
     * @param {Object} options
     */
    fromOptions(o) {
      if (this.parseOptions(o), o.txs) {
        e(Array.isArray(o.txs));
        for (const S of o.txs)
          e(S instanceof u), this.txs.push(S);
      }
      return this;
    }
    /**
     * Instantiate block from options.
     * @param {Object} options
     * @returns {Block}
     */
    static fromOptions(o) {
      return new this().fromOptions(o);
    }
    /**
     * Clear any cached values.
     * @param {Boolean?} all - Clear transactions.
     */
    refresh(o) {
      if (this._refresh(), this._raw = null, this._size = -1, !o)
        return this;
      for (const S of this.txs)
        S.refresh();
      return this;
    }
    /**
     * Serialize the block.
     * @returns {Buffer}
     */
    toRaw() {
      return this.frame().data;
    }
    /**
     * Check if block has been serialized.
     * @returns {Buffer}
     */
    hasRaw() {
      return !!this._raw;
    }
    /**
     * Serialize the block.
     * @returns {Buffer}
     */
    toNormal() {
      return this.toRaw();
    }
    /**
     * Serialize the block.
     * @param {BufferWriter} bw
     */
    toWriter(o) {
      if (this.mutable)
        return this.writeNormal(o);
      const S = this.frame();
      return o.writeBytes(S.data), o;
    }
    /**
     * Serialize the block.
     * @param {BufferWriter} bw
     */
    toNormalWriter(o) {
      return this.toWriter(o);
    }
    /**
     * Get the raw block serialization.
     * @private
     * @returns {RawBlock}
     */
    frame() {
      if (this.mutable)
        return e(!this._raw), this.frameNormal();
      if (this._raw) {
        e(this._size >= 0);
        const S = new b(this._size);
        return S.data = this._raw, S;
      }
      const o = this.frameNormal();
      return this._raw = o.data, this._size = o.size, o;
    }
    /**
     * Calculate real block size.
     * @returns {Object} Contains `size`
     */
    getSize() {
      return this.mutable ? this.getNormalSizes().size : this.frame().size;
    }
    /**
     * Test the block's transaction vector against a hash.
     * @param {Hash} hash
     * @returns {Boolean}
     */
    hasTX(o) {
      return this.indexOf(o) !== -1;
    }
    /**
     * Find the index of a transaction in the block.
     * @param {Hash} hash
     * @returns {Number} index (-1 if not present).
     */
    indexOf(o) {
      for (let S = 0; S < this.txs.length; S++)
        if (this.txs[S].hash().equals(o))
          return S;
      return -1;
    }
    /**
     * Calculate merkle root. Returns null
     * if merkle tree has been malleated.
     * @param {String?} enc - Encoding, can be `'hex'` or null.
     * @returns {Hash|null}
     */
    createMerkleRoot(o) {
      const S = [];
      for (const J of this.txs)
        S.push(J.hash());
      const [H, j] = g.createRoot(w, S);
      return j ? null : o === "hex" ? H.toString("hex") : H;
    }
    /**
     * Retrieve the merkle root from the block header.
     * @param {String?} enc
     * @returns {Hash}
     */
    getMerkleRoot(o) {
      return o === "hex" ? this.merkleRoot.toString("hex") : this.merkleRoot;
    }
    /**
     * Do non-contextual verification on the block. Including checking the block
     * size, the coinbase and the merkle root. This is consensus-critical.
     * @returns {Boolean}
     */
    verifyBody() {
      const [o] = this.checkBody();
      return o;
    }
    /**
     * Do non-contextual verification on the block. Including checking the block
     * size, the coinbase and the merkle root. This is consensus-critical.
     * @param {Boolean?} skipSigops
     * @returns {Array} [valid, reason, score]
     */
    checkBody(o) {
      if (this.txs.length === 0 || this.txs.length > f.MAX_FORK_BLOCK_SIZE / 10 || this.getSize() > f.MAX_FORK_BLOCK_SIZE)
        return [!1, "bad-blk-length", 100];
      if (this.txs.length === 0 || !this.txs[0].isCoinbase())
        return [!1, "bad-cb-missing", 100];
      const S = this.createMerkleRoot();
      if (!S)
        return [!1, "bad-txns-duplicate", 100];
      if (!this.merkleRoot.equals(S))
        return [!1, "bad-txnmrklroot", 100];
      const H = this.getSize();
      let j = 0;
      for (let J = 0; J < this.txs.length; J++) {
        const N = this.txs[J];
        if (J > 0 && N.isCoinbase())
          return [!1, "bad-cb-multiple", 100];
        const [z, A, q] = N.checkSanity();
        if (!z)
          return [z, A, q];
        if (j += N.getLegacySigops(), !o && j > f.maxBlockSigops(H))
          return [!1, "bad-blk-sigops", 100];
      }
      return [!0, "valid", 0];
    }
    /**
     * Retrieve the coinbase height from the coinbase input script.
     * @returns {Number} height (-1 if not present).
     */
    getCoinbaseHeight() {
      if (this.version < 2 || this.txs.length === 0)
        return -1;
      const o = this.txs[0];
      return o.inputs.length === 0 ? -1 : o.inputs[0].script.getCoinbaseHeight();
    }
    /**
     * Get the "claimed" reward by the coinbase.
     * @returns {Amount} claimed
     */
    getClaimed() {
      return e(this.txs.length > 0), e(this.txs[0].isCoinbase()), this.txs[0].getOutputValue();
    }
    /**
     * Get all unique outpoint hashes in the
     * block. Coinbases are ignored.
     * @returns {Hash[]} Outpoint hashes.
     */
    getPrevout() {
      const o = new d();
      for (let S = 1; S < this.txs.length; S++) {
        const H = this.txs[S];
        for (const j of H.inputs)
          o.add(j.prevout.hash);
      }
      return o.toArray();
    }
    /**
     * Inspect the block and return a more
     * user-friendly representation of the data.
     * @returns {Object}
     */
    [E]() {
      return this.format();
    }
    /**
     * Inspect the block and return a more
     * user-friendly representation of the data.
     * @param {CoinView} view
     * @param {Number} height
     * @returns {Object}
     */
    format(o, S) {
      return {
        hash: this.rhash(),
        height: S ?? -1,
        size: this.getSize(),
        date: p.date(this.time),
        version: this.version.toString(16),
        prevBlock: p.revHex(this.prevBlock),
        merkleRoot: p.revHex(this.merkleRoot),
        time: this.time,
        bits: this.bits,
        nonce: this.nonce,
        txs: this.txs.map((H, j) => H.format(o, null, j))
      };
    }
    /**
     * Convert the block to an object suitable
     * for JSON serialization.
     * @returns {Object}
     */
    toJSON() {
      return this.getJSON();
    }
    /**
     * Convert the block to an object suitable
     * for JSON serialization. Note that the hashes
     * will be reversed to abide by bitcoind's legacy
     * of little-endian uint256s.
     * @param {Network} network
     * @param {CoinView} view
     * @param {Number} height
     * @param {Number} depth
     * @returns {Object}
     */
    getJSON(o, S, H, j) {
      return o = i.get(o), {
        hash: this.rhash(),
        height: H,
        depth: j,
        version: this.version,
        prevBlock: p.revHex(this.prevBlock),
        merkleRoot: p.revHex(this.merkleRoot),
        time: this.time,
        bits: this.bits,
        nonce: this.nonce,
        txs: this.txs.map((J, N) => J.getJSON(o, S, null, N))
      };
    }
    /**
     * Inject properties from json object.
     * @private
     * @param {Object} json
     */
    fromJSON(o) {
      e(o, "Block data is required."), e(Array.isArray(o.txs)), this.parseJSON(o);
      for (const S of o.txs)
        this.txs.push(u.fromJSON(S));
      return this;
    }
    /**
     * Instantiate a block from a jsonified block object.
     * @param {Object} json - The jsonified block object.
     * @returns {Block}
     */
    static fromJSON(o) {
      return new this().fromJSON(o);
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     */
    fromReader(o) {
      o.start(), this.readHead(o);
      const S = o.readVarint();
      for (let H = 0; H < S; H++) {
        const j = u.fromReader(o, !0);
        this.txs.push(j);
      }
      return this.mutable || (this._raw = o.endData(), this._size = this._raw.length), this;
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     */
    fromRaw(o) {
      return this.fromReader(c.read(o));
    }
    /**
     * Instantiate a block from a serialized Buffer.
     * @param {Buffer} data
     * @param {String?} enc - Encoding, can be `'hex'` or null.
     * @returns {Block}
     */
    static fromReader(o) {
      return new this().fromReader(o);
    }
    /**
     * Instantiate a block from a serialized Buffer.
     * @param {Buffer} data
     * @param {String?} enc - Encoding, can be `'hex'` or null.
     * @returns {Block}
     */
    static fromRaw(o, S) {
      return typeof o == "string" && (o = k.from(o, S)), new this().fromRaw(o);
    }
    /**
     * Convert the Block to a MerkleBlock.
     * @param {Bloom} filter - Bloom filter for transactions
     * to match. The merkle block will contain only the
     * matched transactions.
     * @returns {MerkleBlock}
     */
    toMerkle(o) {
      return a.fromBlock(this, o);
    }
    /**
     * Serialze block data.
     * @private
     * @param {BufferWriter?} writer
     * @returns {Buffer}
     */
    writeNormal(o) {
      this.writeHead(o), o.writeVarint(this.txs.length);
      for (const S of this.txs)
        S.toWriter(o);
      return o;
    }
    /**
     * Serialze block data.
     * @private
     * @param {BufferWriter?} writer
     * @returns {Buffer}
     */
    frameNormal() {
      const o = this.getNormalSizes(), S = c.write(o.size);
      return this.writeNormal(S), o.data = S.render(), o;
    }
    /**
     * Convert the block to a headers object.
     * @returns {Headers}
     */
    toHeaders() {
      return s.fromBlock(this);
    }
    /**
     * Get real block size.
     * @returns {RawBlock}
     */
    getNormalSizes() {
      let o = 0;
      o += 80, o += m.sizeVarint(this.txs.length);
      for (const S of this.txs)
        o += S.getSize();
      return new b(o, 0);
    }
    /**
     * Test whether an object is a Block.
     * @param {Object} obj
     * @returns {Boolean}
     */
    static isBlock(o) {
      return o instanceof v;
    }
  }
  class b {
    constructor(o) {
      this.data = null, this.size = o;
    }
  }
  return oa = v, oa;
}
/*!
 * keyring.js - keyring object for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var aa, $d;
function fb() {
  if ($d) return aa;
  $d = 1;
  const e = nt, { base58: c } = Ds, d = kt, w = hn(), g = Or(), f = _r(), n = ii(), u = Ci(), a = Ui(), s = Fr(), { encoding: i } = d, { inspectSymbol: p } = fr(), m = k.alloc(33, 0);
  class E {
    /**
     * Create a key ring.
     * @constructor
     * @param {Object} options
     */
    constructor(h) {
      this.nested = !1, this.publicKey = m, this.privateKey = null, this.script = null, this._keyHash = null, this._keyAddress = null, this._scriptHash160 = null, this._scriptAddress = null, h && this.fromOptions(h);
    }
    /**
     * Inject properties from options object.
     * @private
     * @param {Object} options
     */
    fromOptions(h) {
      let o = v(h);
      if (k.isBuffer(o))
        return this.fromKey(o);
      o = v(h.key), h.publicKey && (o = v(h.publicKey)), h.privateKey && (o = v(h.privateKey));
      const S = h.script, H = h.compressed;
      return S ? this.fromScript(o, S, H) : this.fromKey(o, H);
    }
    /**
     * Instantiate key ring from options.
     * @param {Object} options
     * @returns {KeyRing}
     */
    static fromOptions(h) {
      return new this().fromOptions(h);
    }
    /**
     * Clear cached key/script hashes.
     */
    refresh() {
      this._keyHash = null, this._keyAddress = null, this._scriptHash160 = null, this._scriptAddress = null;
    }
    /**
     * Inject data from private key.
     * @private
     * @param {Buffer} key
     * @param {Boolean?} compress
     */
    fromPrivate(h, o) {
      return e(k.isBuffer(h), "Private key must be a buffer."), e(s.privateKeyVerify(h), "Not a valid private key."), this.privateKey = h, this.publicKey = s.publicKeyCreate(h, o !== !1), this;
    }
    /**
     * Instantiate keyring from a private key.
     * @param {Buffer} key
     * @param {Boolean?} compress
     * @returns {KeyRing}
     */
    static fromPrivate(h, o) {
      return new this().fromPrivate(h, o);
    }
    /**
     * Inject data from public key.
     * @private
     * @param {Buffer} key
     */
    fromPublic(h) {
      return e(k.isBuffer(h), "Public key must be a buffer."), e(s.publicKeyVerify(h), "Not a valid public key."), this.publicKey = h, this;
    }
    /**
     * Generate a keyring.
     * @private
     * @param {Boolean?} compress
     * @returns {KeyRing}
     */
    generate(h) {
      const o = s.privateKeyGenerate();
      return this.fromKey(o, h);
    }
    /**
     * Generate a keyring.
     * @param {Boolean?} compress
     * @returns {KeyRing}
     */
    static generate(h) {
      return new this().generate(h);
    }
    /**
     * Instantiate keyring from a public key.
     * @param {Buffer} publicKey
     * @returns {KeyRing}
     */
    static fromPublic(h) {
      return new this().fromPublic(h);
    }
    /**
     * Inject data from public key.
     * @private
     * @param {Buffer} privateKey
     * @param {Boolean?} compress
     */
    fromKey(h, o) {
      return e(k.isBuffer(h), "Key must be a buffer."), h.length === 32 ? this.fromPrivate(h, o !== !1) : this.fromPublic(h);
    }
    /**
     * Instantiate keyring from a public key.
     * @param {Buffer} publicKey
     * @param {Boolean?} compress
     * @returns {KeyRing}
     */
    static fromKey(h, o) {
      return new this().fromKey(h, o);
    }
    /**
     * Inject data from script.
     * @private
     * @param {Buffer} key
     * @param {Script} script
     * @param {Boolean?} compress
     */
    fromScript(h, o, S) {
      return e(o instanceof n, "Non-script passed into KeyRing."), this.fromKey(h, S), this.script = o, this;
    }
    /**
     * Instantiate keyring from script.
     * @param {Buffer} key
     * @param {Script} script
     * @param {Boolean?} compress
     * @returns {KeyRing}
     */
    static fromScript(h, o, S) {
      return new this().fromScript(h, o, S);
    }
    /**
     * Get ith public key from multisig script.
     * @private
     * @param {Script} script
     * @param {Number} i
     * @returns {KeyRing}
     */
    fromMultisigScript(h, o) {
      e(h instanceof n, "Non-script passed."), e(h.isMultisig(), "Script must be multisig");
      const S = h.getSmall(-2);
      return e(o >= 1 && o <= S, "Requested `i`th key, `n` available"), this.fromKey(h.code[o].toData()), this;
    }
    /**
     * Instantiate keyring from ith key in multisig script.
     * @param {Script} script
     * @param {Number} i
     * @returns {KeyRing}
     */
    static fromMultisigScript(h, o) {
      return new this().fromMultisigScript(h, o);
    }
    /**
     * Calculate WIF serialization size.
     * @returns {Number}
     */
    getSecretSize() {
      let h = 0;
      return h += 1, h += this.privateKey.length, this.publicKey.length === 33 && (h += 1), h += 4, h;
    }
    /**
     * Convert key to a CBitcoinSecret.
     * @param {(Network|NetworkType)?} network
     * @returns {Base58String}
     */
    toSecret(h) {
      const o = this.getSecretSize(), S = d.write(o);
      return e(this.privateKey, "Cannot serialize without private key."), h = f.get(h), S.writeU8(h.keyPrefix.privkey), S.writeBytes(this.privateKey), this.publicKey.length === 33 && S.writeU8(1), S.writeChecksum(g.digest), c.encode(S.render());
    }
    /**
     * Inject properties from serialized CBitcoinSecret.
     * @private
     * @param {Base58String} secret
     * @param {(Network|NetworkType)?} network
     */
    fromSecret(h, o) {
      const S = d.read(c.decode(h), !0), H = S.readU8();
      f.fromWIF(H, o);
      const j = S.readBytes(32);
      let J = !1;
      return S.left() > 4 && (e(S.readU8() === 1, "Bad compression flag."), J = !0), S.verifyChecksum(g.digest), this.fromPrivate(j, J);
    }
    /**
     * Instantiate a keyring from a serialized CBitcoinSecret.
     * @param {Base58String} secret
     * @param {(Network|NetworkType)?} network
     * @returns {KeyRing}
     */
    static fromSecret(h, o) {
      return new this().fromSecret(h, o);
    }
    /**
     * Get private key.
     * @param {String?} enc - Can be `"hex"`, `"base58"`, or `null`.
     * @returns {Buffer} Private key.
     */
    getPrivateKey(h, o) {
      return this.privateKey ? h === "base58" ? this.toSecret(o) : h === "hex" ? this.privateKey.toString("hex") : this.privateKey : null;
    }
    /**
     * Get public key.
     * @param {String?} enc - `"hex"` or `null`.
     * @returns {Buffer}
     */
    getPublicKey(h) {
      return h === "base58" ? c.encode(this.publicKey) : h === "hex" ? this.publicKey.toString("hex") : this.publicKey;
    }
    /**
     * Get redeem script.
     * @returns {Script}
     */
    getScript() {
      return this.script;
    }
    /**
     * Get scripthash.
     * @param {String?} enc - `"hex"` or `null`.
     * @returns {Buffer}
     */
    getScriptHash(h) {
      return this.getScriptHash160(h);
    }
    /**
     * Get ripemd160 scripthash.
     * @param {String?} enc - `"hex"` or `null`.
     * @returns {Buffer}
     */
    getScriptHash160(h) {
      return this.script ? (this._scriptHash160 || (this._scriptHash160 = this.script.hash160()), h === "hex" ? this._scriptHash160.toString("hex") : this._scriptHash160) : null;
    }
    /**
     * Get scripthash address.
     * @param {String?} enc - `"base58"` or `null`.
     * @returns {Address|AddressString}
     */
    getScriptAddress(h, o) {
      if (!this.script)
        return null;
      if (!this._scriptAddress) {
        const S = this.getScriptHash160(), H = u.fromScripthash(S);
        this._scriptAddress = H;
      }
      return h === "base58" ? this._scriptAddress.toBase58(o) : h === "string" ? this._scriptAddress.toString(o) : this._scriptAddress;
    }
    /**
     * Get public key hash.
     * @param {String?} enc - `"hex"` or `null`.
     * @returns {Buffer}
     */
    getKeyHash(h) {
      return this._keyHash || (this._keyHash = w.digest(this.publicKey)), h === "hex" ? this._keyHash.toString("hex") : this._keyHash;
    }
    /**
     * Get pubkeyhash address.
     * @param {String?} enc - `"base58"` or `null`.
     * @returns {Address|AddressString}
     */
    getKeyAddress(h, o) {
      if (!this._keyAddress) {
        const S = this.getKeyHash(), H = u.fromPubkeyhash(S);
        this._keyAddress = H;
      }
      return h === "base58" ? this._keyAddress.toBase58(o) : h === "string" ? this._keyAddress.toString(o) : this._keyAddress;
    }
    /**
     * Get hash.
     * @param {String?} enc - `"hex"` or `null`.
     * @returns {Buffer}
     */
    getHash(h) {
      return this.script ? this.getScriptHash(h) : this.getKeyHash(h);
    }
    /**
     * Get base58 address.
     * @param {String?} enc - `"base58"` or `null`.
     * @returns {Address|AddressString}
     */
    getAddress(h, o) {
      return this.script ? this.getScriptAddress(h, o) : this.getKeyAddress(h, o);
    }
    /**
     * Test an address hash against hash.
     * @param {Buffer} hash
     * @returns {Boolean}
     */
    ownHash(h) {
      return h ? !!(h.equals(this.getKeyHash()) || this.script && h.equals(this.getScriptHash())) : !1;
    }
    /**
     * Check whether transaction output belongs to this address.
     * @param {TX|Output} tx - Transaction or Output.
     * @param {Number?} index - Output index.
     * @returns {Boolean}
     */
    ownOutput(h, o) {
      let S;
      return h instanceof a ? S = h : (S = h.outputs[o], e(S, "Output does not exist.")), this.ownHash(S.getHash());
    }
    /**
     * Test a hash against script hashes to
     * find the correct redeem script, if any.
     * @param {Buffer} hash
     * @returns {Script|null}
     */
    getRedeem(h) {
      return this.script && h.equals(this.getScriptHash160()) ? this.script : null;
    }
    /**
     * Sign a message.
     * @param {Buffer} msg
     * @returns {Buffer} Signature in DER format.
     */
    sign(h) {
      return e(this.privateKey, "Cannot sign without private key."), s.signDER(h, this.privateKey);
    }
    /**
     * Sign a message.
     * @param {Buffer} msg
     * @returns {Buffer} Signature in Schnorr format.
     */
    signSchnorr(h) {
      return e(this.privateKey, "Cannot sign without private key."), s.schnorrSign(h, this.privateKey);
    }
    /**
     * Verify a message.
     * @param {Buffer} msg
     * @param {Buffer} sig - Signature in DER format.
     * @returns {Boolean}
     */
    verify(h, o) {
      return s.verifyDER(h, o, this.publicKey);
    }
    /**
     * Verify a message.
     * @param {Buffer} msg
     * @param {Buffer} sig - Signature in Schnorr format.
     * @returns {Boolean}
     */
    verifySchnorr(h, o) {
      return s.schnorrVerify(h, o, this.publicKey);
    }
    /**
     * Get witness program version.
     * @returns {Number}
     */
    getVersion() {
      return -1;
    }
    /**
     * Get address type.
     * @returns {ScriptType}
     */
    getType() {
      return this.script ? u.types.SCRIPTHASH : u.types.PUBKEYHASH;
    }
    /**
     * Inspect keyring.
     * @returns {Object}
     */
    [p]() {
      return this.toJSON();
    }
    /**
     * Convert an KeyRing to a more json-friendly object.
     * @returns {Object}
     */
    toJSON(h) {
      return {
        publicKey: this.publicKey.toString("hex"),
        script: this.script ? this.script.toRaw().toString("hex") : null,
        type: u.typesByVal[this.getType()].toLowerCase(),
        address: this.getAddress("string", h)
      };
    }
    /**
     * Inject properties from json object.
     * @private
     * @param {Object} json
     */
    fromJSON(h) {
      return e(h), e(typeof h.publicKey == "string"), e(!h.script || typeof h.script == "string"), this.publicKey = k.from(h.publicKey, "hex"), h.script && (this.script = k.from(h.script, "hex")), this;
    }
    /**
     * Instantiate an KeyRing from a jsonified transaction object.
     * @param {Object} json - The jsonified transaction object.
     * @returns {KeyRing}
     */
    static fromJSON(h) {
      return new this().fromJSON(h);
    }
    /**
     * Calculate serialization size.
     * @returns {Number}
     */
    getSize() {
      let h = 0;
      return h += 1, this.privateKey ? (h += i.sizeVarBytes(this.privateKey), h += 1) : h += i.sizeVarBytes(this.publicKey), h += this.script ? this.script.getVarSize() : 1, h;
    }
    /**
     * Write the keyring to a buffer writer.
     * @param {BufferWriter} bw
     */
    toWriter(h) {
      return h.writeU8(0), this.privateKey ? (h.writeVarBytes(this.privateKey), h.writeU8(this.publicKey.length === 33 ? 1 : 0)) : h.writeVarBytes(this.publicKey), this.script ? h.writeVarBytes(this.script.toRaw()) : h.writeVarint(0), h;
    }
    /**
     * Serialize the keyring.
     * @returns {Buffer}
     */
    toRaw() {
      const h = this.getSize();
      return this.toWriter(d.write(h)).render();
    }
    /**
     * Inject properties from buffer reader.
     * @private
     * @param {BufferReader} br
     */
    fromReader(h) {
      h.readU8();
      const o = h.readVarBytes();
      if (o.length === 32) {
        const H = h.readU8() === 1;
        this.privateKey = o, this.publicKey = s.publicKeyCreate(o, H);
      } else
        this.publicKey = o, e(s.publicKeyVerify(o), "Invalid public key.");
      const S = h.readVarBytes();
      return S.length > 0 && (this.script = n.fromRaw(S)), this;
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     */
    fromRaw(h) {
      return this.fromReader(d.read(h));
    }
    /**
     * Instantiate a keyring from buffer reader.
     * @param {BufferReader} br
     * @returns {KeyRing}
     */
    static fromReader(h) {
      return new this().fromReader(h);
    }
    /**
     * Instantiate a keyring from serialized data.
     * @param {Buffer} data
     * @returns {KeyRing}
     */
    static fromRaw(h) {
      return new this().fromRaw(h);
    }
    /**
     * Test whether an object is a KeyRing.
     * @param {Object} obj
     * @returns {Boolean}
     */
    static isKeyRing(h) {
      return h instanceof E;
    }
  }
  function v(b) {
    return b && (b.privateKey ? b.privateKey : b.publicKey ? b.publicKey : b);
  }
  return aa = E, aa;
}
/*!
 * memblock.js - memblock block object for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var fa, jd;
function u9() {
  if (jd) return fa;
  jd = 1;
  const e = kt, c = Xn(), d = el(), w = Gn(), g = ii(), f = k.alloc(0);
  class n extends c {
    /**
     * Create a mem block.
     * @constructor
     */
    constructor() {
      super(), this._raw = f;
    }
    /**
     * Test whether the block is a memblock.
     * @returns {Boolean}
     */
    isMemory() {
      return !0;
    }
    /**
     * Serialize the block headers.
     * @returns {Buffer}
     */
    toHead() {
      return this._raw.slice(0, 80);
    }
    /**
     * Get the full block size.
     * @returns {Number}
     */
    getSize() {
      return this._raw.length;
    }
    /**
     * Verify the block.
     * @returns {Boolean}
     */
    verifyBody() {
      return !0;
    }
    /**
     * Retrieve the coinbase height
     * from the coinbase input script.
     * @returns {Number} height (-1 if not present).
     */
    getCoinbaseHeight() {
      if (this.version < 2)
        return -1;
      try {
        return this.parseCoinbaseHeight();
      } catch {
        return -1;
      }
    }
    /**
     * Parse the coinbase height
     * from the coinbase input script.
     * @private
     * @returns {Number} height (-1 if not present).
     */
    parseCoinbaseHeight() {
      const a = e.read(this._raw, !0);
      if (a.seek(80), a.readVarint() === 0)
        return -1;
      a.seek(4);
      let i = a.readVarint();
      if (i === 0 && a.readU8() !== 0 && (i = a.readVarint()), i === 0)
        return -1;
      a.seek(36);
      const p = a.readVarBytes();
      return g.getCoinbaseHeight(p);
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     */
    fromRaw(a) {
      const s = e.read(a, !0);
      return this.readHead(s), this._raw = s.data, this;
    }
    /**
     * Insantiate a memblock from serialized data.
     * @param {Buffer} data
     * @returns {MemBlock}
     */
    static fromRaw(a) {
      return new this().fromRaw(a);
    }
    /**
     * Return serialized block data.
     * @returns {Buffer}
     */
    toRaw() {
      return this._raw;
    }
    /**
     * Parse the serialized block data
     * and create an actual {@link Block}.
     * @returns {Block}
     * @throws Parse error
     */
    toBlock() {
      const a = d.fromRaw(this._raw);
      return a._hash = this._hash, a._hhash = this._hhash, a;
    }
    /**
     * Convert the block to a headers object.
     * @returns {Headers}
     */
    toHeaders() {
      return w.fromBlock(this);
    }
    /**
     * Test whether an object is a MemBlock.
     * @param {Object} obj
     * @returns {Boolean}
     */
    static isMemBlock(a) {
      return a instanceof n;
    }
  }
  return fa = n, fa;
}
var hs = { exports: {} };
/*!
 * mtx.js - mutable transaction object for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var Yd;
function cb() {
  return Yd || (Yd = 1, function(e, c) {
    const d = nt, { encoding: w } = kt, { BufferMap: g } = un, f = ii(), n = Jn(), u = eo(), a = Ui(), s = Js(), i = dn(), p = Jh(), m = Ci(), E = Xt(), v = ln(), b = Ni(), h = Ys(), o = ur(), { inspectSymbol: S } = fr();
    class H extends n {
      /**
       * Create a mutable transaction.
       * @alias module:primitives.MTX
       * @constructor
       * @param {Object} options
       */
      constructor(R) {
        super(), this.mutable = !0, this.changeIndex = -1, this.view = new p(), R && this.fromOptions(R);
      }
      /**
       * Inject properties from options object.
       * @private
       * @param {Object} options
       */
      fromOptions(R) {
        if (R.version != null && (d(
          R.version >>> 0 === R.version,
          "Version must a be uint32."
        ), this.version = R.version), R.inputs) {
          d(Array.isArray(R.inputs), "Inputs must be an array.");
          for (const V of R.inputs)
            this.addInput(V);
        }
        if (R.outputs) {
          d(Array.isArray(R.outputs), "Outputs must be an array.");
          for (const V of R.outputs)
            this.addOutput(V);
        }
        return R.locktime != null && (d(
          R.locktime >>> 0 === R.locktime,
          "Locktime must be a uint32."
        ), this.locktime = R.locktime), R.changeIndex != null && (R.changeIndex !== -1 ? (d(
          R.changeIndex >>> 0 === R.changeIndex,
          "Change index must be a uint32."
        ), this.changeIndex = R.changeIndex) : this.changeIndex = -1), this;
      }
      /**
       * Instantiate MTX from options.
       * @param {Object} options
       * @returns {MTX}
       */
      static fromOptions(R) {
        return new this().fromOptions(R);
      }
      /**
       * Clone the transaction. Note that
       * this will not carry over the view.
       * @returns {MTX}
       */
      clone() {
        const R = new this.constructor();
        return R.inject(this), R.changeIndex = this.changeIndex, R;
      }
      /**
       * Add an input to the transaction.
       * @param {Input|Object} options
       * @returns {Input}
       *
       * @example
       * mtx.addInput({ prevout: { hash: ... }, script: ... });
       * mtx.addInput(new Input());
       */
      addInput(R) {
        const V = u.fromOptions(R);
        return this.inputs.push(V), V;
      }
      /**
       * Add an outpoint as an input.
       * @param {Outpoint|Object} outpoint
       * @returns {Input}
       *
       * @example
       * mtx.addOutpoint({ hash: ..., index: 0 });
       * mtx.addOutpoint(new Outpoint(hash, index));
       */
      addOutpoint(R) {
        const V = i.fromOptions(R), fe = u.fromOutpoint(V);
        return this.inputs.push(fe), fe;
      }
      /**
       * Add a coin as an input. Note that this will
       * add the coin to the internal coin viewpoint.
       * @param {Coin} coin
       * @returns {Input}
       *
       * @example
       * mtx.addCoin(Coin.fromTX(tx, 0, -1));
       */
      addCoin(R) {
        d(R instanceof s, "Cannot add non-coin.");
        const V = u.fromCoin(R);
        return this.inputs.push(V), this.view.addCoin(R), V;
      }
      /**
       * Add a transaction as an input. Note that
       * this will add the coin to the internal
       * coin viewpoint.
       * @param {TX} tx
       * @param {Number} index
       * @param {Number?} height
       * @returns {Input}
       *
       * @example
       * mtx.addTX(tx, 0);
       */
      addTX(R, V, fe) {
        d(R instanceof n, "Cannot add non-transaction."), fe == null && (fe = -1);
        const ue = u.fromTX(R, V);
        return this.inputs.push(ue), this.view.addIndex(R, V, fe), ue;
      }
      /**
       * Add an output.
       * @param {Address|Script|Output|Object} script - Script or output options.
       * @param {Amount?} value
       * @returns {Output}
       *
       * @example
       * mtx.addOutput(new Output());
       * mtx.addOutput({ address: ..., value: 100000 });
       * mtx.addOutput(address, 100000);
       * mtx.addOutput(script, 100000);
       */
      addOutput(R, V) {
        let fe;
        return V != null ? fe = a.fromScript(R, V) : fe = a.fromOptions(R), this.outputs.push(fe), fe;
      }
      /**
       * Verify all transaction inputs.
       * @param {VerifyFlags} [flags=STANDARD_VERIFY_FLAGS]
       * @returns {Boolean} Whether the inputs are valid.
       * @throws {ScriptError} on invalid inputs
       */
      check(R) {
        return super.check(this.view, R);
      }
      /**
       * Verify the transaction inputs on the worker pool
       * (if workers are enabled).
       * @param {VerifyFlags?} [flags=STANDARD_VERIFY_FLAGS]
       * @param {WorkerPool?} pool
       * @returns {Promise}
       */
      checkAsync(R, V) {
        return super.checkAsync(this.view, R, V);
      }
      /**
       * Verify all transaction inputs.
       * @param {VerifyFlags} [flags=STANDARD_VERIFY_FLAGS]
       * @returns {Boolean} Whether the inputs are valid.
       */
      verify(R) {
        try {
          this.check(R);
        } catch (V) {
          if (V.type === "ScriptError")
            return !1;
          throw V;
        }
        return !0;
      }
      /**
       * Verify the transaction inputs on the worker pool
       * (if workers are enabled).
       * @param {VerifyFlags?} [flags=STANDARD_VERIFY_FLAGS]
       * @param {WorkerPool?} pool
       * @returns {Promise}
       */
      async verifyAsync(R, V) {
        try {
          await this.checkAsync(R, V);
        } catch (fe) {
          if (fe.type === "ScriptError")
            return !1;
          throw fe;
        }
        return !0;
      }
      /**
       * Calculate the fee for the transaction.
       * @returns {Amount} fee (zero if not all coins are available).
       */
      getFee() {
        return super.getFee(this.view);
      }
      /**
       * Calculate the total input value.
       * @returns {Amount} value
       */
      getInputValue() {
        return super.getInputValue(this.view);
      }
      /**
       * Get all input addresses.
       * @returns {Address[]} addresses
       */
      getInputAddresses() {
        return super.getInputAddresses(this.view);
      }
      /**
       * Get all addresses.
       * @returns {Address[]} addresses
       */
      getAddresses() {
        return super.getAddresses(this.view);
      }
      /**
       * Get all input address hashes.
       * @returns {Hash[]} hashes
       */
      getInputHashes(R) {
        return super.getInputHashes(this.view, R);
      }
      /**
       * Get all address hashes.
       * @returns {Hash[]} hashes
       */
      getHashes(R) {
        return super.getHashes(this.view, R);
      }
      /**
       * Test whether the transaction has
       * all coins available/filled.
       * @returns {Boolean}
       */
      hasCoins() {
        return super.hasCoins(this.view);
      }
      /**
       * Calculate virtual sigop count.
       * @param {VerifyFlags?} flags
       * @returns {Number} sigop count
       */
      getSigops(R) {
        return super.getSigops(this.view, R);
      }
      /**
       *  Calculate sigops count.
       *  @param {CoinView} view
       *  @param {VerifyFlags?} flags
       *  @returns {Number} sigop count
       */
      getSigopsCount(R) {
        return super.getSigopsCount(this.view, R);
      }
      /**
       * Perform contextual checks to verify input, output,
       * and fee values, as well as coinbase spend maturity
       * (coinbases can only be spent 100 blocks or more
       * after they're created). Note that this function is
       * consensus critical.
       * @param {Number} height - Height at which the
       * transaction is being spent. In the mempool this is
       * the chain height plus one at the time it entered the pool.
       * @returns {Boolean}
       */
      verifyInputs(R) {
        const [V] = this.checkInputs(R);
        return V !== -1;
      }
      /**
       * Perform contextual checks to verify input, output,
       * and fee values, as well as coinbase spend maturity
       * (coinbases can only be spent 100 blocks or more
       * after they're created). Note that this function is
       * consensus critical.
       * @param {Number} height - Height at which the
       * transaction is being spent. In the mempool this is
       * the chain height plus one at the time it entered the pool.
       * @returns {Array} [fee, reason, score]
       */
      checkInputs(R) {
        return super.checkInputs(this.view, R);
      }
      /**
       * Build input script (or witness) templates (with
       * OP_0 in place of signatures).
       * @param {Number} index - Input index.
       * @param {Coin|Output} coin
       * @param {KeyRing} ring
       * @returns {Boolean} Whether the script was able to be built.
       */
      scriptInput(R, V, fe) {
        const ue = this.inputs[R];
        if (d(ue, "Input does not exist."), d(V, "No coin passed."), ue.script.raw.length !== 0)
          return !0;
        const ae = V.script, D = ae.getScripthash();
        if (D) {
          const Z = fe.getRedeem(D);
          if (!Z)
            return !1;
          const oe = this.scriptVector(Z, fe);
          return oe ? (oe.push(Z.toRaw()), ue.script.fromStack(oe), !0) : !1;
        }
        const Q = this.scriptVector(ae, fe);
        return Q ? (ue.script.fromStack(Q), !0) : !1;
      }
      /**
       * Build script for a single vector
       * based on a previous script.
       * @param {Script} prev
       * @param {Buffer} ring
       * @return {Stack}
       */
      scriptVector(R, V) {
        const fe = R.getPubkey();
        if (fe) {
          if (!fe.equals(V.publicKey))
            return null;
          const D = new h();
          return D.pushInt(0), D;
        }
        const ue = R.getPubkeyhash();
        if (ue) {
          if (!ue.equals(V.getKeyHash()))
            return null;
          const D = new h();
          return D.pushInt(0), D.pushData(V.publicKey), D;
        }
        const [, ae] = R.getMultisig();
        if (ae !== -1) {
          if (R.indexOf(V.publicKey) === -1)
            return null;
          const D = new h();
          D.pushInt(0);
          for (let Q = 0; Q < ae; Q++)
            D.pushInt(0);
          return D;
        }
        return null;
      }
      /**
       * Sign a transaction input on the worker pool
       * (if workers are enabled).
       * @param {Number} index
       * @param {Coin|Output} coin
       * @param {KeyRing} ring
       * @param {SighashType?} type
       * @param {WorkerPool?} pool
       * @returns {Promise}
       */
      async signInputAsync(R, V, fe, ue, ae) {
        return ae ? await ae.signInput(this, R, V, fe, ue, ae) : this.signInput(R, V, fe, ue);
      }
      /**
       * Sign an input.
       * @param {Number} index - Index of input being signed.
       * @param {Coin|Output} coin
       * @param {KeyRing} ring - Private key.
       * @param {SighashType} type
       * @returns {Boolean} Whether the input was able to be signed.
       */
      signInput(R, V, fe, ue) {
        const ae = this.inputs[R], D = fe.privateKey;
        d(ae, "Input does not exist."), d(V, "No coin passed.");
        const Q = V.value;
        let Z = V.script;
        const oe = ae.script;
        let y = !1;
        ue == null && (ue = f.hashType.ALL), ue |= f.hashType.SIGHASH_FORKID;
        const Y = f.flags.VERIFY_SIGHASH_FORKID;
        if (Z.isScripthash()) {
          if (Z = ae.script.getRedeem(), !Z)
            throw new Error("Input has not been templated.");
          y = !0;
        }
        const he = this.signature(R, Z, Q, D, ue, Y);
        if (y) {
          const Ie = oe.toStack(), ve = Ie.pop(), C = this.signVector(Z, Ie, he, fe);
          return C ? (C.push(ve), oe.fromStack(C), !0) : !1;
        }
        const be = oe.toStack(), xe = this.signVector(Z, be, he, fe);
        return xe ? (oe.fromStack(xe), !0) : !1;
      }
      /**
       * Add a signature to a vector
       * based on a previous script.
       * @param {Script} prev
       * @param {Stack} vector
       * @param {Buffer} sig
       * @param {KeyRing} ring
       * @return {Boolean}
       */
      signVector(R, V, fe, ue) {
        const ae = R.getPubkey();
        if (ae) {
          if (!ue.publicKey.equals(ae))
            return null;
          if (V.length === 0)
            throw new Error("Input has not been templated.");
          return V.get(0).length > 0 || V.set(0, fe), V;
        }
        const D = R.getPubkeyhash();
        if (D) {
          if (!ue.getKeyHash().equals(D))
            return null;
          if (V.length !== 2)
            throw new Error("Input has not been templated.");
          if (V.get(1).length === 0)
            throw new Error("Input has not been templated.");
          return V.get(0).length > 0 || V.set(0, fe), V;
        }
        const [Q, Z] = R.getMultisig();
        if (Q !== -1) {
          if (V.length < 2)
            throw new Error("Input has not been templated.");
          if (V.get(0).length !== 0)
            throw new Error("Input has not been templated.");
          if (V.length - 1 > Z)
            throw new Error("Input has not been templated.");
          let oe = 0;
          for (let he = 1; he < V.length; he++)
            V.get(he).length > 0 && (oe += 1);
          if (oe === Q && V.length - 1 === Q)
            return V;
          for (; V.length - 1 < Z; )
            V.pushInt(0);
          const y = [];
          for (const he of R.code)
            he.data && y.push(he.data);
          let Y = -1;
          for (let he = 0; he < y.length; he++)
            if (y[he].equals(ue.publicKey)) {
              Y = he;
              break;
            }
          if (Y === -1)
            return null;
          if (Y += 1, Y < V.length && oe < Q && V.get(Y).length === 0 && (V.set(Y, fe), oe += 1), oe >= Q) {
            for (let he = V.length - 1; he >= 1; he--)
              V.get(he).length === 0 && V.remove(he);
            for (; oe > Q; )
              V.pop(), oe -= 1;
            d(oe === Q), d(V.length - 1 === Q);
          }
          return V;
        }
        return null;
      }
      /**
       * Test whether the transaction is fully-signed.
       * @returns {Boolean}
       */
      isSigned() {
        for (let R = 0; R < this.inputs.length; R++) {
          const { prevout: V } = this.inputs[R], fe = this.view.getOutput(V);
          if (!fe || !this.isInputSigned(R, fe))
            return !1;
        }
        return !0;
      }
      /**
       * Test whether an input is fully-signed.
       * @param {Number} index
       * @param {Coin|Output} coin
       * @returns {Boolean}
       */
      isInputSigned(R, V) {
        const fe = this.inputs[R];
        d(fe, "Input does not exist."), d(V, "No coin passed.");
        const ue = fe.script;
        let ae = V.script, D = !1;
        if (ae.isScripthash()) {
          if (ae = fe.script.getRedeem(), !ae)
            return !1;
          D = !0;
        }
        const Q = ue.toStack();
        return D && Q.pop(), this.isVectorSigned(ae, Q);
      }
      /**
       * Test whether a vector is fully-signed.
       * @param {Script} prev
       * @param {Stack} vector
       * @returns {Boolean}
       */
      isVectorSigned(R, V) {
        if (R.isPubkey())
          return !(V.length !== 1 || V.get(0).length === 0);
        if (R.isPubkeyhash())
          return !(V.length !== 2 || V.get(0).length === 0 || V.get(1).length === 0);
        const [fe] = R.getMultisig();
        if (fe !== -1) {
          if (V.length - 1 !== fe)
            return !1;
          for (let ue = 1; ue < V.length; ue++)
            if (V.get(ue).length === 0)
              return !1;
          return !0;
        }
        return !1;
      }
      /**
       * Build input scripts (or witnesses).
       * @param {KeyRing} ring - Address used to sign. The address
       * must be able to redeem the coin.
       * @returns {Number} Number of inputs templated.
       */
      template(R) {
        if (Array.isArray(R)) {
          let fe = 0;
          for (const ue of R)
            fe += this.template(ue);
          return fe;
        }
        let V = 0;
        for (let fe = 0; fe < this.inputs.length; fe++) {
          const { prevout: ue } = this.inputs[fe], ae = this.view.getOutput(ue);
          ae && R.ownOutput(ae) && this.scriptInput(fe, ae, R) && (V += 1);
        }
        return V;
      }
      /**
       * Built input scripts (or witnesses) and sign the inputs.
       * @param {KeyRing} ring - Address used to sign. The address
       * must be able to redeem the coin.
       * @param {SighashType} type
       * @returns {Number} Number of inputs signed.
       */
      sign(R, V) {
        if (Array.isArray(R)) {
          let ue = 0;
          for (const ae of R)
            ue += this.sign(ae, V);
          return ue;
        }
        d(R.privateKey, "No private key available.");
        let fe = 0;
        for (let ue = 0; ue < this.inputs.length; ue++) {
          const { prevout: ae } = this.inputs[ue], D = this.view.getOutput(ae);
          D && R.ownOutput(D) && this.scriptInput(ue, D, R) && this.signInput(ue, D, R, V) && (fe += 1);
        }
        return fe;
      }
      /**
       * Sign the transaction inputs on the worker pool
       * (if workers are enabled).
       * @param {KeyRing} ring
       * @param {SighashType?} type
       * @param {WorkerPool?} pool
       * @returns {Promise}
       */
      async signAsync(R, V, fe) {
        return fe ? await fe.sign(this, R, V) : this.sign(R, V);
      }
      /**
       * Estimate maximum possible size.
       * @param {Function?} estimate - Input script size estimator.
       * @returns {Number}
       */
      async estimateSize(R) {
        let V = 0;
        V += 4, V += w.sizeVarint(this.inputs.length), V += this.inputs.length * 40, V += w.sizeVarint(this.outputs.length);
        for (const fe of this.outputs)
          V += fe.getSize();
        V += 4;
        for (const { prevout: fe } of this.inputs) {
          const ue = this.view.getOutput(fe);
          if (!ue) {
            V += 110;
            continue;
          }
          const ae = ue.script;
          if (ae.isPubkey()) {
            V += 1, V += 74;
            continue;
          }
          if (ae.isPubkeyhash()) {
            V += 1, V += 74, V += 34;
            continue;
          }
          const [D] = ae.getMultisig();
          if (D !== -1) {
            let Q = 0;
            Q += 1, Q += 74 * D, Q += w.sizeVarint(Q), V += Q;
            continue;
          }
          if (R) {
            const Q = await R(ae);
            if (Q !== -1) {
              V += Q;
              continue;
            }
          }
          if (ae.isScripthash()) {
            V += 1, V += 149;
            continue;
          }
          V += 110;
        }
        return V;
      }
      /**
       * Select necessary coins based on total output value.
       * @param {Coin[]} coins
       * @param {Object?} options
       * @returns {CoinSelection}
       * @throws on not enough funds available.
       */
      selectCoins(R, V) {
        return new j(this, V).select(R);
      }
      /**
       * Attempt to subtract a fee from a single output.
       * @param {Number} index
       * @param {Amount} fee
       */
      subtractIndex(R, V) {
        d(typeof R == "number"), d(typeof V == "number");
        const fe = this.outputs[R];
        if (!fe)
          throw new Error("Subtraction index does not exist.");
        if (fe.value < V + fe.getDustThreshold())
          throw new Error("Could not subtract fee.");
        fe.value -= V;
      }
      /**
       * Attempt to subtract a fee from all outputs evenly.
       * @param {Amount} fee
       */
      subtractFee(R) {
        d(typeof R == "number");
        let V = 0;
        for (const ae of this.outputs)
          ae.script.isUnspendable() || (V += 1);
        if (V === 0)
          throw new Error("Could not subtract fee.");
        const fe = R % V, ue = (R - fe) / V;
        for (const ae of this.outputs)
          if (!ae.script.isUnspendable()) {
            if (ae.value < ue + ae.getDustThreshold())
              throw new Error("Could not subtract fee.");
            ae.value -= ue;
          }
        for (const ae of this.outputs)
          if (!ae.script.isUnspendable() && ae.value >= fe + ae.getDustThreshold()) {
            ae.value -= fe;
            return;
          }
        throw new Error("Could not subtract fee.");
      }
      /**
       * Select coins and fill the inputs.
       * @param {Coin[]} coins
       * @param {Object} options - See {@link MTX#selectCoins} options.
       * @returns {CoinSelector}
       */
      async fund(R, V) {
        d(V, "Options are required."), d(V.changeAddress, "Change address is required."), d(this.inputs.length === 0, "TX is already funded.");
        const fe = await this.selectCoins(R, V);
        for (const ae of fe.chosen)
          this.addCoin(ae);
        if (fe.subtractFee) {
          const ae = fe.subtractIndex;
          ae !== -1 ? this.subtractIndex(ae, fe.fee) : this.subtractFee(fe.fee);
        }
        const ue = new a();
        return ue.value = fe.change, ue.script.fromAddress(fe.changeAddress), ue.isDust(v.MIN_RELAY) ? (this.changeIndex = -1, d.strictEqual(this.getFee(), fe.fee + fe.change)) : (this.outputs.push(ue), this.changeIndex = this.outputs.length - 1, d.strictEqual(this.getFee(), fe.fee)), fe;
      }
      /**
       * Sort inputs and outputs according to BIP69.
       * @see https://github.com/bitcoin/bips/blob/master/bip-0069.mediawiki
       */
      sortMembers() {
        let R = null;
        this.changeIndex !== -1 && (R = this.outputs[this.changeIndex], d(R)), this.inputs.sort(q), this.outputs.sort(_), this.changeIndex !== -1 && (this.changeIndex = this.outputs.indexOf(R), d(this.changeIndex !== -1));
      }
      /**
       * Avoid fee sniping.
       * @param {Number} - Current chain height.
       * @see bitcoin/src/wallet/wallet.cpp
       */
      avoidFeeSniping(R) {
        d(typeof R == "number", "Must pass in height."), (Math.random() * 10 | 0) === 0 && (R -= Math.random() * 100 | 0, R < 0 && (R = 0)), this.setLocktime(R);
      }
      /**
       * Set locktime and sequences appropriately.
       * @param {Number} locktime
       */
      setLocktime(R) {
        d(R >>> 0 === R, "Locktime must be a uint32."), d(this.inputs.length > 0, "Cannot set sequence with no inputs.");
        for (const V of this.inputs)
          V.sequence === 4294967295 && (V.sequence = 4294967294);
        this.locktime = R;
      }
      /**
       * Set sequence locktime.
       * @param {Number} index - Input index.
       * @param {Number} locktime
       * @param {Boolean?} seconds
       */
      setSequence(R, V, fe) {
        const ue = this.inputs[R];
        d(ue, "Input does not exist."), d(V >>> 0 === V, "Locktime must be a uint32."), this.version = 2, fe ? (V >>>= E.SEQUENCE_GRANULARITY, V &= E.SEQUENCE_MASK, V |= E.SEQUENCE_TYPE_FLAG) : V &= E.SEQUENCE_MASK, ue.sequence = V;
      }
      /**
       * Inspect the transaction.
       * @returns {Object}
       */
      [S]() {
        return this.format();
      }
      /**
       * Inspect the transaction.
       * @returns {Object}
       */
      format() {
        return super.format(this.view);
      }
      /**
       * Convert transaction to JSON.
       * @returns {Object}
       */
      toJSON() {
        return super.toJSON(null, this.view);
      }
      /**
       * Convert transaction to JSON.
       * @param {Network} network
       * @returns {Object}
       */
      getJSON(R) {
        return super.getJSON(R, this.view);
      }
      /**
       * Inject properties from a json object
       * @param {Object} json
       */
      fromJSON(R) {
        super.fromJSON(R);
        for (let V = 0; V < R.inputs.length; V++) {
          const fe = R.inputs[V], { prevout: ue } = fe;
          if (!fe.coin)
            continue;
          const ae = s.fromJSON(fe.coin);
          ae.hash = o.fromRev(ue.hash), ae.index = ue.index, this.view.addCoin(ae);
        }
        return this;
      }
      /**
       * Instantiate a transaction from a
       * jsonified transaction object.
       * @param {Object} json - The jsonified transaction object.
       * @returns {MTX}
       */
      static fromJSON(R) {
        return new this().fromJSON(R);
      }
      /**
       * Instantiate a transaction from a buffer reader.
       * @param {BufferReader} br
       * @returns {MTX}
       */
      static fromReader(R) {
        return new this().fromReader(R);
      }
      /**
       * Instantiate a transaction from a serialized Buffer.
       * @param {Buffer} data
       * @param {String?} enc - Encoding, can be `'hex'` or null.
       * @returns {MTX}
       */
      static fromRaw(R, V) {
        return typeof R == "string" && (R = k.from(R, V)), new this().fromRaw(R);
      }
      /**
       * Convert the MTX to a TX.
       * @returns {TX}
       */
      toTX() {
        return new n().inject(this);
      }
      /**
       * Convert the MTX to a TX.
       * @returns {Array} [tx, view]
       */
      commit() {
        return [this.toTX(), this.view];
      }
      /**
       * Instantiate MTX from TX.
       * @param {TX} tx
       * @returns {MTX}
       */
      static fromTX(R) {
        return new this().inject(R);
      }
      /**
       * Test whether an object is an MTX.
       * @param {Object} obj
       * @returns {Boolean}
       */
      static isMTX(R) {
        return R instanceof H;
      }
    }
    class j {
      /**
       * Create a coin selector.
       * @constructor
       * @param {TX} tx
       * @param {Object?} options
       */
      constructor(R, V) {
        this.tx = R.clone(), this.coins = [], this.outputValue = 0, this.index = 0, this.chosen = [], this.change = 0, this.fee = j.MIN_FEE, this.selection = "value", this.subtractFee = !1, this.subtractIndex = -1, this.height = -1, this.depth = -1, this.hardFee = -1, this.rate = j.FEE_RATE, this.maxFee = -1, this.round = !1, this.changeAddress = null, this.inputs = new g(), this.estimate = null, this.injectInputs(), V && this.fromOptions(V);
      }
      /**
       * Initialize selector options.
       * @param {Object} options
       * @private
       */
      fromOptions(R) {
        if (R.selection && (d(typeof R.selection == "string"), this.selection = R.selection), R.subtractFee != null && (typeof R.subtractFee == "number" ? (d(Number.isSafeInteger(R.subtractFee)), d(R.subtractFee >= -1), this.subtractIndex = R.subtractFee, this.subtractFee = this.subtractIndex !== -1) : (d(typeof R.subtractFee == "boolean"), this.subtractFee = R.subtractFee)), R.subtractIndex != null && (d(Number.isSafeInteger(R.subtractIndex)), d(R.subtractIndex >= -1), this.subtractIndex = R.subtractIndex, this.subtractFee = this.subtractIndex !== -1), R.height != null && (d(Number.isSafeInteger(R.height)), d(R.height >= -1), this.height = R.height), R.confirmations != null && (d(Number.isSafeInteger(R.confirmations)), d(R.confirmations >= -1), this.depth = R.confirmations), R.depth != null && (d(Number.isSafeInteger(R.depth)), d(R.depth >= -1), this.depth = R.depth), R.hardFee != null && (d(Number.isSafeInteger(R.hardFee)), d(R.hardFee >= -1), this.hardFee = R.hardFee), R.rate != null && (d(Number.isSafeInteger(R.rate)), d(R.rate >= 0), this.rate = R.rate), R.maxFee != null && (d(Number.isSafeInteger(R.maxFee)), d(R.maxFee >= -1), this.maxFee = R.maxFee), R.round != null && (d(typeof R.round == "boolean"), this.round = R.round), R.changeAddress) {
          const V = R.changeAddress;
          typeof V == "string" ? this.changeAddress = m.fromString(V) : (d(V instanceof m), this.changeAddress = V);
        }
        if (R.estimate && (d(typeof R.estimate == "function"), this.estimate = R.estimate), R.inputs) {
          d(Array.isArray(R.inputs));
          for (let V = 0; V < R.inputs.length; V++) {
            const fe = R.inputs[V];
            d(fe && typeof fe == "object");
            const { hash: ue, index: ae } = fe;
            d(k.isBuffer(ue)), d(typeof ae == "number"), this.inputs.set(i.toKey(ue, ae), V);
          }
        }
        return this;
      }
      /**
       * Attempt to inject existing inputs.
       * @private
       */
      injectInputs() {
        if (this.tx.inputs.length > 0)
          for (let R = 0; R < this.tx.inputs.length; R++) {
            const { prevout: V } = this.tx.inputs[R];
            this.inputs.set(V.toKey(), R);
          }
      }
      /**
       * Initialize the selector with coins to select from.
       * @param {Coin[]} coins
       */
      init(R) {
        switch (this.coins = R.slice(), this.outputValue = this.tx.getOutputValue(), this.index = 0, this.chosen = [], this.change = 0, this.fee = j.MIN_FEE, this.tx.inputs.length = 0, this.selection) {
          case "all":
          case "random":
            this.coins.sort(z);
            break;
          case "age":
            this.coins.sort(N);
            break;
          case "value":
            this.coins.sort(A);
            break;
          default:
            throw new J(`Bad selection type: ${this.selection}.`);
        }
      }
      /**
       * Calculate total value required.
       * @returns {Amount}
       */
      total() {
        return this.subtractFee ? this.outputValue : this.outputValue + this.fee;
      }
      /**
       * Test whether the selector has
       * completely funded the transaction.
       * @returns {Boolean}
       */
      isFull() {
        return this.tx.getInputValue() >= this.total();
      }
      /**
       * Test whether a coin is spendable
       * with regards to the options.
       * @param {Coin} coin
       * @returns {Boolean}
       */
      isSpendable(R) {
        return this.tx.view.hasEntry(R) ? !1 : this.height === -1 ? !0 : R.coinbase ? !(R.height === -1 || this.height + 1 < R.height + E.COINBASE_MATURITY) : this.depth === -1 ? !0 : !(R.getDepth(this.height) < this.depth);
      }
      /**
       * Get the current fee based on a size.
       * @param {Number} size
       * @returns {Amount}
       */
      getFee(R) {
        if (this.round) {
          const fe = v.getRoundFee(R, this.rate);
          return Math.min(fe, j.MAX_FEE);
        }
        const V = v.getMinFee(R, this.rate);
        return Math.min(V, j.MAX_FEE);
      }
      /**
       * Fund the transaction with more
       * coins if the `output value + fee`
       * total was updated.
       */
      fund() {
        if (this.inputs.size > 0) {
          const R = [];
          for (let V = 0; V < this.inputs.size; V++)
            R.push(null);
          for (const V of this.coins) {
            const { hash: fe, index: ue } = V, ae = i.toKey(fe, ue), D = this.inputs.get(ae);
            D != null && (R[D] = V, this.inputs.delete(ae));
          }
          if (this.inputs.size > 0)
            throw new Error("Could not resolve preferred inputs.");
          for (const V of R)
            this.tx.addCoin(V), this.chosen.push(V);
        }
        for (; this.index < this.coins.length; ) {
          const R = this.coins[this.index++];
          if (this.isSpendable(R) && (this.tx.addCoin(R), this.chosen.push(R), this.selection !== "all" && this.isFull()))
            break;
        }
      }
      /**
       * Initiate selection from `coins`.
       * @param {Coin[]} coins
       * @returns {CoinSelector}
       */
      async select(R) {
        if (this.init(R), this.hardFee !== -1 ? this.selectHard() : await this.selectEstimate(), !this.isFull())
          throw new J(
            "Not enough funds.",
            this.tx.getInputValue(),
            this.total()
          );
        return this.change = this.tx.getInputValue() - this.total(), this;
      }
      /**
       * Initialize selection based on size estimate.
       */
      async selectEstimate() {
        this.fee = j.MIN_FEE, this.fund();
        const R = new a();
        this.changeAddress ? R.script.fromAddress(this.changeAddress) : R.script.fromPubkeyhash(k.allocUnsafe(20)), this.tx.outputs.push(R);
        do {
          const V = await this.tx.estimateSize(this.estimate);
          if (this.fee = this.getFee(V), this.maxFee > 0 && this.fee > this.maxFee)
            throw new J("Fee is too high.");
          this.isFull() || this.fund();
        } while (!this.isFull() && this.index < this.coins.length);
      }
      /**
       * Initiate selection based on a hard fee.
       */
      selectHard() {
        this.fee = Math.min(this.hardFee, j.MAX_FEE), this.fund();
      }
    }
    j.FEE_RATE = 1e4, j.MIN_FEE = 1e4, j.MAX_FEE = E.COIN / 10;
    class J extends Error {
      /**
       * Create a funding error.
       * @constructor
       * @param {String} msg
       * @param {Amount} available
       * @param {Amount} required
       */
      constructor(R, V, fe) {
        super(), this.type = "FundingError", this.message = R, this.availableFunds = -1, this.requiredFunds = -1, V != null && (this.message += ` (available=${b.btc(V)},`, this.message += ` required=${b.btc(fe)})`, this.availableFunds = V, this.requiredFunds = fe), Error.captureStackTrace && Error.captureStackTrace(this, J);
      }
    }
    function N(F, R) {
      return F = F.height === -1 ? 2147483647 : F.height, R = R.height === -1 ? 2147483647 : R.height, F - R;
    }
    function z(F, R) {
      return Math.random() > 0.5 ? 1 : -1;
    }
    function A(F, R) {
      return F.height === -1 && R.height !== -1 ? 1 : F.height !== -1 && R.height === -1 ? -1 : R.value - F.value;
    }
    function q(F, R) {
      return F.compare(R);
    }
    function _(F, R) {
      return F.compare(R);
    }
    c = H, c.MTX = H, c.Selector = j, c.FundingError = J, e.exports = c;
  }(hs, hs.exports)), hs.exports;
}
/*!
 * txmeta.js - extended transaction object for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var ca, Xd;
function h9() {
  if (Xd) return ca;
  Xd = 1;
  const e = nt, c = kt, d = ur(), w = Jn(), { inspectSymbol: g } = fr();
  class f {
    /**
     * Create an extended transaction.
     * @constructor
     * @param {Object?} options
     */
    constructor(u) {
      this.tx = new w(), this.mtime = d.now(), this.height = -1, this.block = null, this.time = 0, this.index = -1, u && this.fromOptions(u);
    }
    /**
     * Inject properties from options object.
     * @private
     * @param {Object} options
     */
    fromOptions(u) {
      return u.tx && (e(u.tx instanceof w), this.tx = u.tx), u.mtime != null && (e(u.mtime >>> 0 === u.mtime), this.mtime = u.mtime), u.height != null && (e(Number.isSafeInteger(u.height)), this.height = u.height), u.block !== void 0 && (e(u.block == null || k.isBuffer(u.block)), this.block = u.block), u.time != null && (e(u.time >>> 0 === u.time), this.time = u.time), u.index != null && (e(Number.isSafeInteger(u.index)), this.index = u.index), this;
    }
    /**
     * Instantiate TXMeta from options.
     * @param {Object} options
     * @returns {TXMeta}
     */
    static fromOptions(u) {
      return new this().fromOptions(u);
    }
    /**
     * Inject properties from options object.
     * @private
     * @param {Object} options
     */
    fromTX(u, a, s) {
      return this.tx = u, a && (this.height = a.height, this.block = a.hash, this.time = a.time, this.index = s), this;
    }
    /**
     * Instantiate TXMeta from options.
     * @param {Object} options
     * @returns {TXMeta}
     */
    static fromTX(u, a, s) {
      return new this().fromTX(u, a, s);
    }
    /**
     * Inspect the transaction.
     * @returns {Object}
     */
    [g]() {
      return this.format();
    }
    /**
     * Inspect the transaction.
     * @returns {Object}
     */
    format(u) {
      const a = this.tx.format(u, null, this.index);
      return a.mtime = this.mtime, a.height = this.height, a.block = this.block ? d.revHex(this.block) : null, a.time = this.time, a;
    }
    /**
     * Convert transaction to JSON.
     * @returns {Object}
     */
    toJSON() {
      return this.getJSON();
    }
    /**
     * Convert the transaction to an object suitable
     * for JSON serialization.
     * @param {Network} network
     * @param {CoinView} view
     * @returns {Object}
     */
    getJSON(u, a, s) {
      const i = this.tx.getJSON(u, a, null, this.index);
      return i.mtime = this.mtime, i.height = this.height, i.block = this.block ? d.revHex(this.block) : null, i.time = this.time, i.confirmations = 0, s != null && this.height !== -1 && (i.confirmations = s - this.height + 1), i;
    }
    /**
     * Inject properties from a json object.
     * @private
     * @param {Object} json
     */
    fromJSON(u) {
      return this.tx.fromJSON(u), e(u.mtime >>> 0 === u.mtime), e(Number.isSafeInteger(u.height)), e(!u.block || typeof u.block == "string"), e(u.time >>> 0 === u.time), e(Number.isSafeInteger(u.index)), this.mtime = u.mtime, this.height = u.height, this.block = d.fromRev(u.block), this.index = u.index, this;
    }
    /**
     * Instantiate a transaction from a
     * jsonified transaction object.
     * @param {Object} json - The jsonified transaction object.
     * @returns {TX}
     */
    static fromJSON(u) {
      return new this().fromJSON(u);
    }
    /**
     * Calculate serialization size.
     * @returns {Number}
     */
    getSize() {
      let u = 0;
      return u += this.tx.getSize(), u += 4, this.block ? (u += 1, u += 32, u += 12) : u += 1, u;
    }
    /**
     * Serialize a transaction to "extended format".
     * This is the serialization format bcoin uses internally
     * to store transactions in the database. The extended
     * serialization includes the height, block hash, index,
     * timestamp, and pending-since time.
     * @returns {Buffer}
     */
    toRaw() {
      const u = this.getSize(), a = c.write(u);
      return this.tx.toWriter(a), a.writeU32(this.mtime), this.block ? (a.writeU8(1), a.writeHash(this.block), a.writeU32(this.height), a.writeU32(this.time), a.writeU32(this.index)) : a.writeU8(0), a.render();
    }
    /**
     * Inject properties from "extended" serialization format.
     * @private
     * @param {Buffer} data
     */
    fromRaw(u) {
      const a = c.read(u);
      return this.tx.fromReader(a), this.mtime = a.readU32(), a.readU8() === 1 && (this.block = a.readHash(), this.height = a.readU32(), this.time = a.readU32(), this.index = a.readU32(), this.index === 2147483647 && (this.index = -1)), this;
    }
    /**
     * Instantiate a transaction from a Buffer
     * in "extended" serialization format.
     * @param {Buffer} data
     * @param {String?} enc - One of `"hex"` or `null`.
     * @returns {TX}
     */
    static fromRaw(u, a) {
      return typeof u == "string" && (u = k.from(u, a)), new this().fromRaw(u);
    }
    /**
     * Test whether an object is an TXMeta.
     * @param {Object} obj
     * @returns {Boolean}
     */
    static isTXMeta(u) {
      return u instanceof f;
    }
  }
  return ca = f, ca;
}
/*!
 * primitives/index.js - bitcoin primitives for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var Jd;
function l9() {
  return Jd || (Jd = 1, jt.AbstractBlock = Xn(), jt.Address = Ci(), jt.Block = el(), jt.Coin = Js(), jt.Headers = Gn(), jt.Input = eo(), jt.InvItem = Qs(), jt.KeyRing = fb(), jt.MemBlock = u9(), jt.MerkleBlock = Qh(), jt.MTX = cb(), jt.Outpoint = dn(), jt.Output = Ui(), jt.TX = Jn(), jt.TXMeta = h9()), jt;
}
var si = {}, ua = {};
/*!
 * errors.js - error objects for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var Gd;
function d9() {
  if (Gd) return ua;
  Gd = 1;
  const e = nt;
  class c extends Error {
    /**
     * Create a verify error.
     * @constructor
     * @param {Block|TX} msg
     * @param {String} code - Reject packet code.
     * @param {String} reason - Reject packet reason.
     * @param {Number} score - Ban score increase
     * (can be -1 for no reject packet).
     * @param {Boolean} malleated
     */
    constructor(w, g, f, n, u) {
      super(), e(typeof g == "string"), e(typeof f == "string"), e(n >= 0), this.type = "VerifyError", this.message = "", this.code = g, this.reason = f, this.score = n, this.hash = w.hash(), this.malleated = u || !1, this.message = `Verification failure: ${f} (code=${g} score=${n} hash=${w.rhash()})`, Error.captureStackTrace && Error.captureStackTrace(this, c);
    }
  }
  return ua.VerifyError = c, ua;
}
/*!
 * protocol/index.js - protocol constants for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var Wd;
function b9() {
  return Wd || (Wd = 1, si.consensus = Xt(), si.errors = d9(), si.Network = _r(), si.networks = Dh(), si.policy = ln(), si.timedata = V8()), si;
}
var Sr = {};
/*!
 * sigcache.js - signature cache for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var ha, Zd;
function ub() {
  if (Zd) return ha;
  Zd = 1;
  const e = nt, { BufferMap: c } = un, d = Fr();
  class w {
    /**
     * Create a signature cache.
     * @constructor
     * @param {Number} [size=10000]
     */
    constructor(n) {
      n == null && (n = 1e4), e(n >>> 0 === n), this.size = n, this.keys = [], this.valid = new c();
    }
    /**
     * Resize the sigcache.
     * @param {Number} size
     */
    resize(n) {
      e(n >>> 0 === n), this.size = n, this.keys.length = 0, this.valid.clear();
    }
    /**
     * Add item to the sigcache.
     * Potentially evict a random member.
     * @param {Hash} msg - Sig hash.
     * @param {Buffer} sig
     * @param {Buffer} key
     */
    add(n, u, a) {
      if (this.size !== 0)
        if (this.valid.set(n, new g(u, a)), this.keys.length >= this.size) {
          const s = Math.floor(Math.random() * this.keys.length), i = this.keys[s];
          this.valid.delete(i), this.keys[s] = n;
        } else
          this.keys.push(n);
    }
    /**
     * Test whether the sig exists.
     * @param {Hash} msg - Sig hash.
     * @param {Buffer} sig
     * @param {Buffer} key
     * @returns {Boolean}
     */
    has(n, u, a) {
      const s = this.valid.get(n);
      return s ? s.equals(u, a) : !1;
    }
    /**
     * Verify a signature, testing
     * it against the cache first.
     * @param {Buffer} msg
     * @param {Buffer} sig
     * @param {Buffer} key
     * @returns {Boolean}
     */
    verify(n, u, a) {
      return this.size === 0 ? d.verifyDER(n, u, a) : this.has(n, u, a) ? !0 : d.verifyDER(n, u, a) ? (this.add(n, u, a), !0) : !1;
    }
    /**
     * Verify a schnorr signature, testing
     * it against the cache first.
     * @param {Buffer} msg
     * @param {Buffer} sig
     * @param {Buffer} key
     * @returns {Boolean}
     */
    verifySchnorr(n, u, a) {
      return this.size === 0 ? d.schnorrVerify(n, u, a) : this.has(n, u, a) ? !0 : d.schnorrVerify(n, u, a) ? (this.add(n, u, a), !0) : !1;
    }
  }
  class g {
    /**
     * Create a cache entry.
     * @constructor
     * @param {Buffer} sig
     * @param {Buffer} key
     */
    constructor(n, u) {
      this.sig = k.from(n), this.key = k.from(u);
    }
    /**
     * Compare an entry to a sig and key.
     * @param {Buffer} sig
     * @param {Buffer} key
     * @returns {Boolean}
     */
    equals(n, u) {
      return this.sig.equals(n) && this.key.equals(u);
    }
  }
  return ha = w, ha;
}
/*!
 * script/index.js - bitcoin scripting for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var Qd;
function p9() {
  return Qd || (Qd = 1, Sr.common = Yn(), Sr.Opcode = Yh(), Sr.Script = ii(), Sr.ScriptError = js(), Sr.ScriptNum = Di(), Sr.sigcache = ub(), Sr.Stack = Ys(), Sr.Metrics = rb(), Sr.SLP = Xs()), Sr;
}
var la = {}, Pn = {};
/*!
 * aes.js - aes128/192/256 for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on openssl/openssl:
 *   Based on code entered into the public domain by Vincent Rijmen.
 *   https://github.com/openssl/openssl/blob/master/crypto/aes/aes_core.c
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/Advanced_Encryption_Standard
 *   http://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.197.pdf
 *   https://github.com/openssl/openssl/blob/master/crypto/aes/aes_core.c
 */
var da, e2;
function m9() {
  if (e2) return da;
  e2 = 1;
  const e = Bt(), c = new Uint32Array([
    3328402341,
    4168907908,
    4000806809,
    4135287693,
    4294111757,
    3597364157,
    3731845041,
    2445657428,
    1613770832,
    33620227,
    3462883241,
    1445669757,
    3892248089,
    3050821474,
    1303096294,
    3967186586,
    2412431941,
    528646813,
    2311702848,
    4202528135,
    4026202645,
    2992200171,
    2387036105,
    4226871307,
    1101901292,
    3017069671,
    1604494077,
    1169141738,
    597466303,
    1403299063,
    3832705686,
    2613100635,
    1974974402,
    3791519004,
    1033081774,
    1277568618,
    1815492186,
    2118074177,
    4126668546,
    2211236943,
    1748251740,
    1369810420,
    3521504564,
    4193382664,
    3799085459,
    2883115123,
    1647391059,
    706024767,
    134480908,
    2512897874,
    1176707941,
    2646852446,
    806885416,
    932615841,
    168101135,
    798661301,
    235341577,
    605164086,
    461406363,
    3756188221,
    3454790438,
    1311188841,
    2142417613,
    3933566367,
    302582043,
    495158174,
    1479289972,
    874125870,
    907746093,
    3698224818,
    3025820398,
    1537253627,
    2756858614,
    1983593293,
    3084310113,
    2108928974,
    1378429307,
    3722699582,
    1580150641,
    327451799,
    2790478837,
    3117535592,
    0,
    3253595436,
    1075847264,
    3825007647,
    2041688520,
    3059440621,
    3563743934,
    2378943302,
    1740553945,
    1916352843,
    2487896798,
    2555137236,
    2958579944,
    2244988746,
    3151024235,
    3320835882,
    1336584933,
    3992714006,
    2252555205,
    2588757463,
    1714631509,
    293963156,
    2319795663,
    3925473552,
    67240454,
    4269768577,
    2689618160,
    2017213508,
    631218106,
    1269344483,
    2723238387,
    1571005438,
    2151694528,
    93294474,
    1066570413,
    563977660,
    1882732616,
    4059428100,
    1673313503,
    2008463041,
    2950355573,
    1109467491,
    537923632,
    3858759450,
    4260623118,
    3218264685,
    2177748300,
    403442708,
    638784309,
    3287084079,
    3193921505,
    899127202,
    2286175436,
    773265209,
    2479146071,
    1437050866,
    4236148354,
    2050833735,
    3362022572,
    3126681063,
    840505643,
    3866325909,
    3227541664,
    427917720,
    2655997905,
    2749160575,
    1143087718,
    1412049534,
    999329963,
    193497219,
    2353415882,
    3354324521,
    1807268051,
    672404540,
    2816401017,
    3160301282,
    369822493,
    2916866934,
    3688947771,
    1681011286,
    1949973070,
    336202270,
    2454276571,
    201721354,
    1210328172,
    3093060836,
    2680341085,
    3184776046,
    1135389935,
    3294782118,
    965841320,
    831886756,
    3554993207,
    4068047243,
    3588745010,
    2345191491,
    1849112409,
    3664604599,
    26054028,
    2983581028,
    2622377682,
    1235855840,
    3630984372,
    2891339514,
    4092916743,
    3488279077,
    3395642799,
    4101667470,
    1202630377,
    268961816,
    1874508501,
    4034427016,
    1243948399,
    1546530418,
    941366308,
    1470539505,
    1941222599,
    2546386513,
    3421038627,
    2715671932,
    3899946140,
    1042226977,
    2521517021,
    1639824860,
    227249030,
    260737669,
    3765465232,
    2084453954,
    1907733956,
    3429263018,
    2420656344,
    100860677,
    4160157185,
    470683154,
    3261161891,
    1781871967,
    2924959737,
    1773779408,
    394692241,
    2579611992,
    974986535,
    664706745,
    3655459128,
    3958962195,
    731420851,
    571543859,
    3530123707,
    2849626480,
    126783113,
    865375399,
    765172662,
    1008606754,
    361203602,
    3387549984,
    2278477385,
    2857719295,
    1344809080,
    2782912378,
    59542671,
    1503764984,
    160008576,
    437062935,
    1707065306,
    3622233649,
    2218934982,
    3496503480,
    2185314755,
    697932208,
    1512910199,
    504303377,
    2075177163,
    2824099068,
    1841019862,
    739644986
  ]), d = new Uint32Array([
    2781242211,
    2230877308,
    2582542199,
    2381740923,
    234877682,
    3184946027,
    2984144751,
    1418839493,
    1348481072,
    50462977,
    2848876391,
    2102799147,
    434634494,
    1656084439,
    3863849899,
    2599188086,
    1167051466,
    2636087938,
    1082771913,
    2281340285,
    368048890,
    3954334041,
    3381544775,
    201060592,
    3963727277,
    1739838676,
    4250903202,
    3930435503,
    3206782108,
    4149453988,
    2531553906,
    1536934080,
    3262494647,
    484572669,
    2923271059,
    1783375398,
    1517041206,
    1098792767,
    49674231,
    1334037708,
    1550332980,
    4098991525,
    886171109,
    150598129,
    2481090929,
    1940642008,
    1398944049,
    1059722517,
    201851908,
    1385547719,
    1699095331,
    1587397571,
    674240536,
    2704774806,
    252314885,
    3039795866,
    151914247,
    908333586,
    2602270848,
    1038082786,
    651029483,
    1766729511,
    3447698098,
    2682942837,
    454166793,
    2652734339,
    1951935532,
    775166490,
    758520603,
    3000790638,
    4004797018,
    4217086112,
    4137964114,
    1299594043,
    1639438038,
    3464344499,
    2068982057,
    1054729187,
    1901997871,
    2534638724,
    4121318227,
    1757008337,
    0,
    750906861,
    1614815264,
    535035132,
    3363418545,
    3988151131,
    3201591914,
    1183697867,
    3647454910,
    1265776953,
    3734260298,
    3566750796,
    3903871064,
    1250283471,
    1807470800,
    717615087,
    3847203498,
    384695291,
    3313910595,
    3617213773,
    1432761139,
    2484176261,
    3481945413,
    283769337,
    100925954,
    2180939647,
    4037038160,
    1148730428,
    3123027871,
    3813386408,
    4087501137,
    4267549603,
    3229630528,
    2315620239,
    2906624658,
    3156319645,
    1215313976,
    82966005,
    3747855548,
    3245848246,
    1974459098,
    1665278241,
    807407632,
    451280895,
    251524083,
    1841287890,
    1283575245,
    337120268,
    891687699,
    801369324,
    3787349855,
    2721421207,
    3431482436,
    959321879,
    1469301956,
    4065699751,
    2197585534,
    1199193405,
    2898814052,
    3887750493,
    724703513,
    2514908019,
    2696962144,
    2551808385,
    3516813135,
    2141445340,
    1715741218,
    2119445034,
    2872807568,
    2198571144,
    3398190662,
    700968686,
    3547052216,
    1009259540,
    2041044702,
    3803995742,
    487983883,
    1991105499,
    1004265696,
    1449407026,
    1316239930,
    504629770,
    3683797321,
    168560134,
    1816667172,
    3837287516,
    1570751170,
    1857934291,
    4014189740,
    2797888098,
    2822345105,
    2754712981,
    936633572,
    2347923833,
    852879335,
    1133234376,
    1500395319,
    3084545389,
    2348912013,
    1689376213,
    3533459022,
    3762923945,
    3034082412,
    4205598294,
    133428468,
    634383082,
    2949277029,
    2398386810,
    3913789102,
    403703816,
    3580869306,
    2297460856,
    1867130149,
    1918643758,
    607656988,
    4049053350,
    3346248884,
    1368901318,
    600565992,
    2090982877,
    2632479860,
    557719327,
    3717614411,
    3697393085,
    2249034635,
    2232388234,
    2430627952,
    1115438654,
    3295786421,
    2865522278,
    3633334344,
    84280067,
    33027830,
    303828494,
    2747425121,
    1600795957,
    4188952407,
    3496589753,
    2434238086,
    1486471617,
    658119965,
    3106381470,
    953803233,
    334231800,
    3005978776,
    857870609,
    3151128937,
    1890179545,
    2298973838,
    2805175444,
    3056442267,
    574365214,
    2450884487,
    550103529,
    1233637070,
    4289353045,
    2018519080,
    2057691103,
    2399374476,
    4166623649,
    2148108681,
    387583245,
    3664101311,
    836232934,
    3330556482,
    3100665960,
    3280093505,
    2955516313,
    2002398509,
    287182607,
    3413881008,
    4238890068,
    3597515707,
    975967766
  ]), w = new Uint32Array([
    1671808611,
    2089089148,
    2006576759,
    2072901243,
    4061003762,
    1807603307,
    1873927791,
    3310653893,
    810573872,
    16974337,
    1739181671,
    729634347,
    4263110654,
    3613570519,
    2883997099,
    1989864566,
    3393556426,
    2191335298,
    3376449993,
    2106063485,
    4195741690,
    1508618841,
    1204391495,
    4027317232,
    2917941677,
    3563566036,
    2734514082,
    2951366063,
    2629772188,
    2767672228,
    1922491506,
    3227229120,
    3082974647,
    4246528509,
    2477669779,
    644500518,
    911895606,
    1061256767,
    4144166391,
    3427763148,
    878471220,
    2784252325,
    3845444069,
    4043897329,
    1905517169,
    3631459288,
    827548209,
    356461077,
    67897348,
    3344078279,
    593839651,
    3277757891,
    405286936,
    2527147926,
    84871685,
    2595565466,
    118033927,
    305538066,
    2157648768,
    3795705826,
    3945188843,
    661212711,
    2999812018,
    1973414517,
    152769033,
    2208177539,
    745822252,
    439235610,
    455947803,
    1857215598,
    1525593178,
    2700827552,
    1391895634,
    994932283,
    3596728278,
    3016654259,
    695947817,
    3812548067,
    795958831,
    2224493444,
    1408607827,
    3513301457,
    0,
    3979133421,
    543178784,
    4229948412,
    2982705585,
    1542305371,
    1790891114,
    3410398667,
    3201918910,
    961245753,
    1256100938,
    1289001036,
    1491644504,
    3477767631,
    3496721360,
    4012557807,
    2867154858,
    4212583931,
    1137018435,
    1305975373,
    861234739,
    2241073541,
    1171229253,
    4178635257,
    33948674,
    2139225727,
    1357946960,
    1011120188,
    2679776671,
    2833468328,
    1374921297,
    2751356323,
    1086357568,
    2408187279,
    2460827538,
    2646352285,
    944271416,
    4110742005,
    3168756668,
    3066132406,
    3665145818,
    560153121,
    271589392,
    4279952895,
    4077846003,
    3530407890,
    3444343245,
    202643468,
    322250259,
    3962553324,
    1608629855,
    2543990167,
    1154254916,
    389623319,
    3294073796,
    2817676711,
    2122513534,
    1028094525,
    1689045092,
    1575467613,
    422261273,
    1939203699,
    1621147744,
    2174228865,
    1339137615,
    3699352540,
    577127458,
    712922154,
    2427141008,
    2290289544,
    1187679302,
    3995715566,
    3100863416,
    339486740,
    3732514782,
    1591917662,
    186455563,
    3681988059,
    3762019296,
    844522546,
    978220090,
    169743370,
    1239126601,
    101321734,
    611076132,
    1558493276,
    3260915650,
    3547250131,
    2901361580,
    1655096418,
    2443721105,
    2510565781,
    3828863972,
    2039214713,
    3878868455,
    3359869896,
    928607799,
    1840765549,
    2374762893,
    3580146133,
    1322425422,
    2850048425,
    1823791212,
    1459268694,
    4094161908,
    3928346602,
    1706019429,
    2056189050,
    2934523822,
    135794696,
    3134549946,
    2022240376,
    628050469,
    779246638,
    472135708,
    2800834470,
    3032970164,
    3327236038,
    3894660072,
    3715932637,
    1956440180,
    522272287,
    1272813131,
    3185336765,
    2340818315,
    2323976074,
    1888542832,
    1044544574,
    3049550261,
    1722469478,
    1222152264,
    50660867,
    4127324150,
    236067854,
    1638122081,
    895445557,
    1475980887,
    3117443513,
    2257655686,
    3243809217,
    489110045,
    2662934430,
    3778599393,
    4162055160,
    2561878936,
    288563729,
    1773916777,
    3648039385,
    2391345038,
    2493985684,
    2612407707,
    505560094,
    2274497927,
    3911240169,
    3460925390,
    1442818645,
    678973480,
    3749357023,
    2358182796,
    2717407649,
    2306869641,
    219617805,
    3218761151,
    3862026214,
    1120306242,
    1756942440,
    1103331905,
    2578459033,
    762796589,
    252780047,
    2966125488,
    1425844308,
    3151392187,
    372911126
  ]), g = new Uint32Array([
    1667474886,
    2088535288,
    2004326894,
    2071694838,
    4075949567,
    1802223062,
    1869591006,
    3318043793,
    808472672,
    16843522,
    1734846926,
    724270422,
    4278065639,
    3621216949,
    2880169549,
    1987484396,
    3402253711,
    2189597983,
    3385409673,
    2105378810,
    4210693615,
    1499065266,
    1195886990,
    4042263547,
    2913856577,
    3570689971,
    2728590687,
    2947541573,
    2627518243,
    2762274643,
    1920112356,
    3233831835,
    3082273397,
    4261223649,
    2475929149,
    640051788,
    909531756,
    1061110142,
    4160160501,
    3435941763,
    875846760,
    2779116625,
    3857003729,
    4059105529,
    1903268834,
    3638064043,
    825316194,
    353713962,
    67374088,
    3351728789,
    589522246,
    3284360861,
    404236336,
    2526454071,
    84217610,
    2593830191,
    117901582,
    303183396,
    2155911963,
    3806477791,
    3958056653,
    656894286,
    2998062463,
    1970642922,
    151591698,
    2206440989,
    741110872,
    437923380,
    454765878,
    1852748508,
    1515908788,
    2694904667,
    1381168804,
    993742198,
    3604373943,
    3014905469,
    690584402,
    3823320797,
    791638366,
    2223281939,
    1398011302,
    3520161977,
    0,
    3991743681,
    538992704,
    4244381667,
    2981218425,
    1532751286,
    1785380564,
    3419096717,
    3200178535,
    960056178,
    1246420628,
    1280103576,
    1482221744,
    3486468741,
    3503319995,
    4025428677,
    2863326543,
    4227536621,
    1128514950,
    1296947098,
    859002214,
    2240123921,
    1162203018,
    4193849577,
    33687044,
    2139062782,
    1347481760,
    1010582648,
    2678045221,
    2829640523,
    1364325282,
    2745433693,
    1077985408,
    2408548869,
    2459086143,
    2644360225,
    943212656,
    4126475505,
    3166494563,
    3065430391,
    3671750063,
    555836226,
    269496352,
    4294908645,
    4092792573,
    3537006015,
    3452783745,
    202118168,
    320025894,
    3974901699,
    1600119230,
    2543297077,
    1145359496,
    387397934,
    3301201811,
    2812801621,
    2122220284,
    1027426170,
    1684319432,
    1566435258,
    421079858,
    1936954854,
    1616945344,
    2172753945,
    1330631070,
    3705438115,
    572679748,
    707427924,
    2425400123,
    2290647819,
    1179044492,
    4008585671,
    3099120491,
    336870440,
    3739122087,
    1583276732,
    185277718,
    3688593069,
    3772791771,
    842159716,
    976899700,
    168435220,
    1229577106,
    101059084,
    606366792,
    1549591736,
    3267517855,
    3553849021,
    2897014595,
    1650632388,
    2442242105,
    2509612081,
    3840161747,
    2038008818,
    3890688725,
    3368567691,
    926374254,
    1835907034,
    2374863873,
    3587531953,
    1313788572,
    2846482505,
    1819063512,
    1448540844,
    4109633523,
    3941213647,
    1701162954,
    2054852340,
    2930698567,
    134748176,
    3132806511,
    2021165296,
    623210314,
    774795868,
    471606328,
    2795958615,
    3031746419,
    3334885783,
    3907527627,
    3722280097,
    1953799400,
    522133822,
    1263263126,
    3183336545,
    2341176845,
    2324333839,
    1886425312,
    1044267644,
    3048588401,
    1718004428,
    1212733584,
    50529542,
    4143317495,
    235803164,
    1633788866,
    892690282,
    1465383342,
    3115962473,
    2256965911,
    3250673817,
    488449850,
    2661202215,
    3789633753,
    4177007595,
    2560144171,
    286339874,
    1768537042,
    3654906025,
    2391705863,
    2492770099,
    2610673197,
    505291324,
    2273808917,
    3924369609,
    3469625735,
    1431699370,
    673740880,
    3755965093,
    2358021891,
    2711746649,
    2307489801,
    218961690,
    3217021541,
    3873845719,
    1111672452,
    1751693520,
    1094828930,
    2576986153,
    757954394,
    252645662,
    2964376443,
    1414855848,
    3149649517,
    370555436
  ]), f = new Uint32Array([
    1374988112,
    2118214995,
    437757123,
    975658646,
    1001089995,
    530400753,
    2902087851,
    1273168787,
    540080725,
    2910219766,
    2295101073,
    4110568485,
    1340463100,
    3307916247,
    641025152,
    3043140495,
    3736164937,
    632953703,
    1172967064,
    1576976609,
    3274667266,
    2169303058,
    2370213795,
    1809054150,
    59727847,
    361929877,
    3211623147,
    2505202138,
    3569255213,
    1484005843,
    1239443753,
    2395588676,
    1975683434,
    4102977912,
    2572697195,
    666464733,
    3202437046,
    4035489047,
    3374361702,
    2110667444,
    1675577880,
    3843699074,
    2538681184,
    1649639237,
    2976151520,
    3144396420,
    4269907996,
    4178062228,
    1883793496,
    2403728665,
    2497604743,
    1383856311,
    2876494627,
    1917518562,
    3810496343,
    1716890410,
    3001755655,
    800440835,
    2261089178,
    3543599269,
    807962610,
    599762354,
    33778362,
    3977675356,
    2328828971,
    2809771154,
    4077384432,
    1315562145,
    1708848333,
    101039829,
    3509871135,
    3299278474,
    875451293,
    2733856160,
    92987698,
    2767645557,
    193195065,
    1080094634,
    1584504582,
    3178106961,
    1042385657,
    2531067453,
    3711829422,
    1306967366,
    2438237621,
    1908694277,
    67556463,
    1615861247,
    429456164,
    3602770327,
    2302690252,
    1742315127,
    2968011453,
    126454664,
    3877198648,
    2043211483,
    2709260871,
    2084704233,
    4169408201,
    0,
    159417987,
    841739592,
    504459436,
    1817866830,
    4245618683,
    260388950,
    1034867998,
    908933415,
    168810852,
    1750902305,
    2606453969,
    607530554,
    202008497,
    2472011535,
    3035535058,
    463180190,
    2160117071,
    1641816226,
    1517767529,
    470948374,
    3801332234,
    3231722213,
    1008918595,
    303765277,
    235474187,
    4069246893,
    766945465,
    337553864,
    1475418501,
    2943682380,
    4003061179,
    2743034109,
    4144047775,
    1551037884,
    1147550661,
    1543208500,
    2336434550,
    3408119516,
    3069049960,
    3102011747,
    3610369226,
    1113818384,
    328671808,
    2227573024,
    2236228733,
    3535486456,
    2935566865,
    3341394285,
    496906059,
    3702665459,
    226906860,
    2009195472,
    733156972,
    2842737049,
    294930682,
    1206477858,
    2835123396,
    2700099354,
    1451044056,
    573804783,
    2269728455,
    3644379585,
    2362090238,
    2564033334,
    2801107407,
    2776292904,
    3669462566,
    1068351396,
    742039012,
    1350078989,
    1784663195,
    1417561698,
    4136440770,
    2430122216,
    775550814,
    2193862645,
    2673705150,
    1775276924,
    1876241833,
    3475313331,
    3366754619,
    270040487,
    3902563182,
    3678124923,
    3441850377,
    1851332852,
    3969562369,
    2203032232,
    3868552805,
    2868897406,
    566021896,
    4011190502,
    3135740889,
    1248802510,
    3936291284,
    699432150,
    832877231,
    708780849,
    3332740144,
    899835584,
    1951317047,
    4236429990,
    3767586992,
    866637845,
    4043610186,
    1106041591,
    2144161806,
    395441711,
    1984812685,
    1139781709,
    3433712980,
    3835036895,
    2664543715,
    1282050075,
    3240894392,
    1181045119,
    2640243204,
    25965917,
    4203181171,
    4211818798,
    3009879386,
    2463879762,
    3910161971,
    1842759443,
    2597806476,
    933301370,
    1509430414,
    3943906441,
    3467192302,
    3076639029,
    3776767469,
    2051518780,
    2631065433,
    1441952575,
    404016761,
    1942435775,
    1408749034,
    1610459739,
    3745345300,
    2017778566,
    3400528769,
    3110650942,
    941896748,
    3265478751,
    371049330,
    3168937228,
    675039627,
    4279080257,
    967311729,
    135050206,
    3635733660,
    1683407248,
    2076935265,
    3576870512,
    1215061108,
    3501741890
  ]), n = new Uint32Array([
    1347548327,
    1400783205,
    3273267108,
    2520393566,
    3409685355,
    4045380933,
    2880240216,
    2471224067,
    1428173050,
    4138563181,
    2441661558,
    636813900,
    4233094615,
    3620022987,
    2149987652,
    2411029155,
    1239331162,
    1730525723,
    2554718734,
    3781033664,
    46346101,
    310463728,
    2743944855,
    3328955385,
    3875770207,
    2501218972,
    3955191162,
    3667219033,
    768917123,
    3545789473,
    692707433,
    1150208456,
    1786102409,
    2029293177,
    1805211710,
    3710368113,
    3065962831,
    401639597,
    1724457132,
    3028143674,
    409198410,
    2196052529,
    1620529459,
    1164071807,
    3769721975,
    2226875310,
    486441376,
    2499348523,
    1483753576,
    428819965,
    2274680428,
    3075636216,
    598438867,
    3799141122,
    1474502543,
    711349675,
    129166120,
    53458370,
    2592523643,
    2782082824,
    4063242375,
    2988687269,
    3120694122,
    1559041666,
    730517276,
    2460449204,
    4042459122,
    2706270690,
    3446004468,
    3573941694,
    533804130,
    2328143614,
    2637442643,
    2695033685,
    839224033,
    1973745387,
    957055980,
    2856345839,
    106852767,
    1371368976,
    4181598602,
    1033297158,
    2933734917,
    1179510461,
    3046200461,
    91341917,
    1862534868,
    4284502037,
    605657339,
    2547432937,
    3431546947,
    2003294622,
    3182487618,
    2282195339,
    954669403,
    3682191598,
    1201765386,
    3917234703,
    3388507166,
    0,
    2198438022,
    1211247597,
    2887651696,
    1315723890,
    4227665663,
    1443857720,
    507358933,
    657861945,
    1678381017,
    560487590,
    3516619604,
    975451694,
    2970356327,
    261314535,
    3535072918,
    2652609425,
    1333838021,
    2724322336,
    1767536459,
    370938394,
    182621114,
    3854606378,
    1128014560,
    487725847,
    185469197,
    2918353863,
    3106780840,
    3356761769,
    2237133081,
    1286567175,
    3152976349,
    4255350624,
    2683765030,
    3160175349,
    3309594171,
    878443390,
    1988838185,
    3704300486,
    1756818940,
    1673061617,
    3403100636,
    272786309,
    1075025698,
    545572369,
    2105887268,
    4174560061,
    296679730,
    1841768865,
    1260232239,
    4091327024,
    3960309330,
    3497509347,
    1814803222,
    2578018489,
    4195456072,
    575138148,
    3299409036,
    446754879,
    3629546796,
    4011996048,
    3347532110,
    3252238545,
    4270639778,
    915985419,
    3483825537,
    681933534,
    651868046,
    2755636671,
    3828103837,
    223377554,
    2607439820,
    1649704518,
    3270937875,
    3901806776,
    1580087799,
    4118987695,
    3198115200,
    2087309459,
    2842678573,
    3016697106,
    1003007129,
    2802849917,
    1860738147,
    2077965243,
    164439672,
    4100872472,
    32283319,
    2827177882,
    1709610350,
    2125135846,
    136428751,
    3874428392,
    3652904859,
    3460984630,
    3572145929,
    3593056380,
    2939266226,
    824852259,
    818324884,
    3224740454,
    930369212,
    2801566410,
    2967507152,
    355706840,
    1257309336,
    4148292826,
    243256656,
    790073846,
    2373340630,
    1296297904,
    1422699085,
    3756299780,
    3818836405,
    457992840,
    3099667487,
    2135319889,
    77422314,
    1560382517,
    1945798516,
    788204353,
    1521706781,
    1385356242,
    870912086,
    325965383,
    2358957921,
    2050466060,
    2388260884,
    2313884476,
    4006521127,
    901210569,
    3990953189,
    1014646705,
    1503449823,
    1062597235,
    2031621326,
    3212035895,
    3931371469,
    1533017514,
    350174575,
    2256028891,
    2177544179,
    1052338372,
    741876788,
    1606591296,
    1914052035,
    213705253,
    2334669897,
    1107234197,
    1899603969,
    3725069491,
    2631447780,
    2422494913,
    1635502980,
    1893020342,
    1950903388,
    1120974935
  ]), u = new Uint32Array([
    2807058932,
    1699970625,
    2764249623,
    1586903591,
    1808481195,
    1173430173,
    1487645946,
    59984867,
    4199882800,
    1844882806,
    1989249228,
    1277555970,
    3623636965,
    3419915562,
    1149249077,
    2744104290,
    1514790577,
    459744698,
    244860394,
    3235995134,
    1963115311,
    4027744588,
    2544078150,
    4190530515,
    1608975247,
    2627016082,
    2062270317,
    1507497298,
    2200818878,
    567498868,
    1764313568,
    3359936201,
    2305455554,
    2037970062,
    1047239e3,
    1910319033,
    1337376481,
    2904027272,
    2892417312,
    984907214,
    1243112415,
    830661914,
    861968209,
    2135253587,
    2011214180,
    2927934315,
    2686254721,
    731183368,
    1750626376,
    4246310725,
    1820824798,
    4172763771,
    3542330227,
    48394827,
    2404901663,
    2871682645,
    671593195,
    3254988725,
    2073724613,
    145085239,
    2280796200,
    2779915199,
    1790575107,
    2187128086,
    472615631,
    3029510009,
    4075877127,
    3802222185,
    4107101658,
    3201631749,
    1646252340,
    4270507174,
    1402811438,
    1436590835,
    3778151818,
    3950355702,
    3963161475,
    4020912224,
    2667994737,
    273792366,
    2331590177,
    104699613,
    95345982,
    3175501286,
    2377486676,
    1560637892,
    3564045318,
    369057872,
    4213447064,
    3919042237,
    1137477952,
    2658625497,
    1119727848,
    2340947849,
    1530455833,
    4007360968,
    172466556,
    266959938,
    516552836,
    0,
    2256734592,
    3980931627,
    1890328081,
    1917742170,
    4294704398,
    945164165,
    3575528878,
    958871085,
    3647212047,
    2787207260,
    1423022939,
    775562294,
    1739656202,
    3876557655,
    2530391278,
    2443058075,
    3310321856,
    547512796,
    1265195639,
    437656594,
    3121275539,
    719700128,
    3762502690,
    387781147,
    218828297,
    3350065803,
    2830708150,
    2848461854,
    428169201,
    122466165,
    3720081049,
    1627235199,
    648017665,
    4122762354,
    1002783846,
    2117360635,
    695634755,
    3336358691,
    4234721005,
    4049844452,
    3704280881,
    2232435299,
    574624663,
    287343814,
    612205898,
    1039717051,
    840019705,
    2708326185,
    793451934,
    821288114,
    1391201670,
    3822090177,
    376187827,
    3113855344,
    1224348052,
    1679968233,
    2361698556,
    1058709744,
    752375421,
    2431590963,
    1321699145,
    3519142200,
    2734591178,
    188127444,
    2177869557,
    3727205754,
    2384911031,
    3215212461,
    2648976442,
    2450346104,
    3432737375,
    1180849278,
    331544205,
    3102249176,
    4150144569,
    2952102595,
    2159976285,
    2474404304,
    766078933,
    313773861,
    2570832044,
    2108100632,
    1668212892,
    3145456443,
    2013908262,
    418672217,
    3070356634,
    2594734927,
    1852171925,
    3867060991,
    3473416636,
    3907448597,
    2614737639,
    919489135,
    164948639,
    2094410160,
    2997825956,
    590424639,
    2486224549,
    1723872674,
    3157750862,
    3399941250,
    3501252752,
    3625268135,
    2555048196,
    3673637356,
    1343127501,
    4130281361,
    3599595085,
    2957853679,
    1297403050,
    81781910,
    3051593425,
    2283490410,
    532201772,
    1367295589,
    3926170974,
    895287692,
    1953757831,
    1093597963,
    492483431,
    3528626907,
    1446242576,
    1192455638,
    1636604631,
    209336225,
    344873464,
    1015671571,
    669961897,
    3375740769,
    3857572124,
    2973530695,
    3747192018,
    1933530610,
    3464042516,
    935293895,
    3454686199,
    2858115069,
    1863638845,
    3683022916,
    4085369519,
    3292445032,
    875313188,
    1080017571,
    3279033885,
    621591778,
    1233856572,
    2504130317,
    24197544,
    3017672716,
    3835484340,
    3247465558,
    2220981195,
    3060847922,
    1551124588,
    1463996600
  ]), a = new Uint32Array([
    4104605777,
    1097159550,
    396673818,
    660510266,
    2875968315,
    2638606623,
    4200115116,
    3808662347,
    821712160,
    1986918061,
    3430322568,
    38544885,
    3856137295,
    718002117,
    893681702,
    1654886325,
    2975484382,
    3122358053,
    3926825029,
    4274053469,
    796197571,
    1290801793,
    1184342925,
    3556361835,
    2405426947,
    2459735317,
    1836772287,
    1381620373,
    3196267988,
    1948373848,
    3764988233,
    3385345166,
    3263785589,
    2390325492,
    1480485785,
    3111247143,
    3780097726,
    2293045232,
    548169417,
    3459953789,
    3746175075,
    439452389,
    1362321559,
    1400849762,
    1685577905,
    1806599355,
    2174754046,
    137073913,
    1214797936,
    1174215055,
    3731654548,
    2079897426,
    1943217067,
    1258480242,
    529487843,
    1437280870,
    3945269170,
    3049390895,
    3313212038,
    923313619,
    679998e3,
    3215307299,
    57326082,
    377642221,
    3474729866,
    2041877159,
    133361907,
    1776460110,
    3673476453,
    96392454,
    878845905,
    2801699524,
    777231668,
    4082475170,
    2330014213,
    4142626212,
    2213296395,
    1626319424,
    1906247262,
    1846563261,
    562755902,
    3708173718,
    1040559837,
    3871163981,
    1418573201,
    3294430577,
    114585348,
    1343618912,
    2566595609,
    3186202582,
    1078185097,
    3651041127,
    3896688048,
    2307622919,
    425408743,
    3371096953,
    2081048481,
    1108339068,
    2216610296,
    0,
    2156299017,
    736970802,
    292596766,
    1517440620,
    251657213,
    2235061775,
    2933202493,
    758720310,
    265905162,
    1554391400,
    1532285339,
    908999204,
    174567692,
    1474760595,
    4002861748,
    2610011675,
    3234156416,
    3693126241,
    2001430874,
    303699484,
    2478443234,
    2687165888,
    585122620,
    454499602,
    151849742,
    2345119218,
    3064510765,
    514443284,
    4044981591,
    1963412655,
    2581445614,
    2137062819,
    19308535,
    1928707164,
    1715193156,
    4219352155,
    1126790795,
    600235211,
    3992742070,
    3841024952,
    836553431,
    1669664834,
    2535604243,
    3323011204,
    1243905413,
    3141400786,
    4180808110,
    698445255,
    2653899549,
    2989552604,
    2253581325,
    3252932727,
    3004591147,
    1891211689,
    2487810577,
    3915653703,
    4237083816,
    4030667424,
    2100090966,
    865136418,
    1229899655,
    953270745,
    3399679628,
    3557504664,
    4118925222,
    2061379749,
    3079546586,
    2915017791,
    983426092,
    2022837584,
    1607244650,
    2118541908,
    2366882550,
    3635996816,
    972512814,
    3283088770,
    1568718495,
    3499326569,
    3576539503,
    621982671,
    2895723464,
    410887952,
    2623762152,
    1002142683,
    645401037,
    1494807662,
    2595684844,
    1335535747,
    2507040230,
    4293295786,
    3167684641,
    367585007,
    3885750714,
    1865862730,
    2668221674,
    2960971305,
    2763173681,
    1059270954,
    2777952454,
    2724642869,
    1320957812,
    2194319100,
    2429595872,
    2815956275,
    77089521,
    3973773121,
    3444575871,
    2448830231,
    1305906550,
    4021308739,
    2857194700,
    2516901860,
    3518358430,
    1787304780,
    740276417,
    1699839814,
    1592394909,
    2352307457,
    2272556026,
    188821243,
    1729977011,
    3687994002,
    274084841,
    3594982253,
    3613494426,
    2701949495,
    4162096729,
    322734571,
    2837966542,
    1640576439,
    484830689,
    1202797690,
    3537852828,
    4067639125,
    349075736,
    3342319475,
    4157467219,
    4255800159,
    1030690015,
    1155237496,
    2951971274,
    1757691577,
    607398968,
    2738905026,
    499347990,
    3794078908,
    1011452712,
    227885567,
    2818666809,
    213114376,
    3034881240,
    1455525988,
    3414450555,
    850817237,
    1817998408,
    3092726480
  ]), s = new Uint8Array([
    82,
    9,
    106,
    213,
    48,
    54,
    165,
    56,
    191,
    64,
    163,
    158,
    129,
    243,
    215,
    251,
    124,
    227,
    57,
    130,
    155,
    47,
    255,
    135,
    52,
    142,
    67,
    68,
    196,
    222,
    233,
    203,
    84,
    123,
    148,
    50,
    166,
    194,
    35,
    61,
    238,
    76,
    149,
    11,
    66,
    250,
    195,
    78,
    8,
    46,
    161,
    102,
    40,
    217,
    36,
    178,
    118,
    91,
    162,
    73,
    109,
    139,
    209,
    37,
    114,
    248,
    246,
    100,
    134,
    104,
    152,
    22,
    212,
    164,
    92,
    204,
    93,
    101,
    182,
    146,
    108,
    112,
    72,
    80,
    253,
    237,
    185,
    218,
    94,
    21,
    70,
    87,
    167,
    141,
    157,
    132,
    144,
    216,
    171,
    0,
    140,
    188,
    211,
    10,
    247,
    228,
    88,
    5,
    184,
    179,
    69,
    6,
    208,
    44,
    30,
    143,
    202,
    63,
    15,
    2,
    193,
    175,
    189,
    3,
    1,
    19,
    138,
    107,
    58,
    145,
    17,
    65,
    79,
    103,
    220,
    234,
    151,
    242,
    207,
    206,
    240,
    180,
    230,
    115,
    150,
    172,
    116,
    34,
    231,
    173,
    53,
    133,
    226,
    249,
    55,
    232,
    28,
    117,
    223,
    110,
    71,
    241,
    26,
    113,
    29,
    41,
    197,
    137,
    111,
    183,
    98,
    14,
    170,
    24,
    190,
    27,
    252,
    86,
    62,
    75,
    198,
    210,
    121,
    32,
    154,
    219,
    192,
    254,
    120,
    205,
    90,
    244,
    31,
    221,
    168,
    51,
    136,
    7,
    199,
    49,
    177,
    18,
    16,
    89,
    39,
    128,
    236,
    95,
    96,
    81,
    127,
    169,
    25,
    181,
    74,
    13,
    45,
    229,
    122,
    159,
    147,
    201,
    156,
    239,
    160,
    224,
    59,
    77,
    174,
    42,
    245,
    176,
    200,
    235,
    187,
    60,
    131,
    83,
    153,
    97,
    23,
    43,
    4,
    126,
    186,
    119,
    214,
    38,
    225,
    105,
    20,
    99,
    85,
    33,
    12,
    125
  ]), i = new Uint32Array([
    16777216,
    33554432,
    67108864,
    134217728,
    268435456,
    536870912,
    1073741824,
    2147483648,
    452984832,
    905969664
  ]);
  class p {
    constructor(h = 256) {
      e(h >>> 0 === h), this.bits = h, this.rounds = m(h), this.key = null, this.encKey = null, this.decKey = null;
    }
    get blockSize() {
      return 16;
    }
    init(h) {
      if (e(k.isBuffer(h)), h.length !== this.bits >>> 3)
        throw new Error("Invalid key size.");
      return this.destroy(), this.key = k.from(h), this.encKey = null, this.decKey = null, this;
    }
    createEncryptKey() {
      if (!this.key)
        throw new Error("Cipher is not initialized.");
      const h = this.key;
      if (h.length !== this.bits >>> 3)
        throw new Error("Invalid key size.");
      const o = new Uint32Array(60);
      o[0] = E(h, 0), o[1] = E(h, 4), o[2] = E(h, 8), o[3] = E(h, 12);
      let S = 0, H = 0;
      if (this.bits === 128) {
        for (; ; ) {
          const j = o[S + 3];
          if (o[S + 4] = o[S] ^ w[j >>> 16 & 255] & 4278190080 ^ g[j >>> 8 & 255] & 16711680 ^ c[j >>> 0 & 255] & 65280 ^ d[j >>> 24 & 255] & 255 ^ i[H], o[S + 5] = o[S + 1] ^ o[S + 4], o[S + 6] = o[S + 2] ^ o[S + 5], o[S + 7] = o[S + 3] ^ o[S + 6], H += 1, H === 10)
            break;
          S += 4;
        }
        return o;
      }
      if (o[S + 4] = E(h, 16), o[S + 5] = E(h, 20), this.bits === 192) {
        for (; ; ) {
          const j = o[S + 5];
          if (o[S + 6] = o[S] ^ w[j >>> 16 & 255] & 4278190080 ^ g[j >>> 8 & 255] & 16711680 ^ c[j >>> 0 & 255] & 65280 ^ d[j >>> 24 & 255] & 255 ^ i[H], o[S + 7] = o[S + 1] ^ o[S + 6], o[S + 8] = o[S + 2] ^ o[S + 7], o[S + 9] = o[S + 3] ^ o[S + 8], H += 1, H === 8)
            break;
          o[S + 10] = o[S + 4] ^ o[S + 9], o[S + 11] = o[S + 5] ^ o[S + 10], S += 6;
        }
        return o;
      }
      if (o[S + 6] = E(h, 24), o[S + 7] = E(h, 28), this.bits === 256) {
        for (; ; ) {
          let j = o[S + 7];
          if (o[S + 8] = o[S] ^ w[j >>> 16 & 255] & 4278190080 ^ g[j >>> 8 & 255] & 16711680 ^ c[j >>> 0 & 255] & 65280 ^ d[j >>> 24 & 255] & 255 ^ i[H], o[S + 9] = o[S + 1] ^ o[S + 8], o[S + 10] = o[S + 2] ^ o[S + 9], o[S + 11] = o[S + 3] ^ o[S + 10], H += 1, H === 7)
            break;
          j = o[S + 11], o[S + 12] = o[S + 4] ^ w[j >>> 24 & 255] & 4278190080 ^ g[j >>> 16 & 255] & 16711680 ^ c[j >>> 8 & 255] & 65280 ^ d[j >>> 0 & 255] & 255, o[S + 13] = o[S + 5] ^ o[S + 12], o[S + 14] = o[S + 6] ^ o[S + 13], o[S + 15] = o[S + 7] ^ o[S + 14], S += 8;
        }
        return o;
      }
      throw new Error("Bad key size.");
    }
    createDecryptKey() {
      const h = this.createEncryptKey();
      let o = 0;
      for (let S = 0, H = 4 * this.rounds; S < H; S += 4, H -= 4) {
        let j = h[o + S + 0];
        h[o + S + 0] = h[o + H + 0], h[o + H + 0] = j, j = h[o + S + 1], h[o + S + 1] = h[o + H + 1], h[o + H + 1] = j, j = h[o + S + 2], h[o + S + 2] = h[o + H + 2], h[o + H + 2] = j, j = h[o + S + 3], h[o + S + 3] = h[o + H + 3], h[o + H + 3] = j;
      }
      for (let S = 1; S < this.rounds; S++)
        o += 4, h[o + 0] = f[d[h[o + 0] >>> 24 & 255] & 255] ^ n[d[h[o + 0] >>> 16 & 255] & 255] ^ u[d[h[o + 0] >>> 8 & 255] & 255] ^ a[d[h[o + 0] >>> 0 & 255] & 255], h[o + 1] = f[d[h[o + 1] >>> 24 & 255] & 255] ^ n[d[h[o + 1] >>> 16 & 255] & 255] ^ u[d[h[o + 1] >>> 8 & 255] & 255] ^ a[d[h[o + 1] >>> 0 & 255] & 255], h[o + 2] = f[d[h[o + 2] >>> 24 & 255] & 255] ^ n[d[h[o + 2] >>> 16 & 255] & 255] ^ u[d[h[o + 2] >>> 8 & 255] & 255] ^ a[d[h[o + 2] >>> 0 & 255] & 255], h[o + 3] = f[d[h[o + 3] >>> 24 & 255] & 255] ^ n[d[h[o + 3] >>> 16 & 255] & 255] ^ u[d[h[o + 3] >>> 8 & 255] & 255] ^ a[d[h[o + 3] >>> 0 & 255] & 255];
      return h;
    }
    getEncryptKey() {
      return this.encKey || (this.encKey = this.createEncryptKey()), this.encKey;
    }
    getDecryptKey() {
      return this.decKey || (this.decKey = this.createDecryptKey()), this.decKey;
    }
    encrypt(h, o, S, H) {
      const j = this.getEncryptKey();
      let J = E(S, H + 0) ^ j[0], N = E(S, H + 4) ^ j[1], z = E(S, H + 8) ^ j[2], A = E(S, H + 12) ^ j[3], q = this.rounds >>> 1, _ = 0, F, R, V, fe;
      for (; F = c[J >>> 24 & 255] ^ d[N >>> 16 & 255] ^ w[z >>> 8 & 255] ^ g[A >>> 0 & 255] ^ j[_ + 4], R = c[N >>> 24 & 255] ^ d[z >>> 16 & 255] ^ w[A >>> 8 & 255] ^ g[J >>> 0 & 255] ^ j[_ + 5], V = c[z >>> 24 & 255] ^ d[A >>> 16 & 255] ^ w[J >>> 8 & 255] ^ g[N >>> 0 & 255] ^ j[_ + 6], fe = c[A >>> 24 & 255] ^ d[J >>> 16 & 255] ^ w[N >>> 8 & 255] ^ g[z >>> 0 & 255] ^ j[_ + 7], _ += 8, q -= 1, q !== 0; )
        J = c[F >>> 24 & 255] ^ d[R >>> 16 & 255] ^ w[V >>> 8 & 255] ^ g[fe >>> 0 & 255] ^ j[_ + 0], N = c[R >>> 24 & 255] ^ d[V >>> 16 & 255] ^ w[fe >>> 8 & 255] ^ g[F >>> 0 & 255] ^ j[_ + 1], z = c[V >>> 24 & 255] ^ d[fe >>> 16 & 255] ^ w[F >>> 8 & 255] ^ g[R >>> 0 & 255] ^ j[_ + 2], A = c[fe >>> 24 & 255] ^ d[F >>> 16 & 255] ^ w[R >>> 8 & 255] ^ g[V >>> 0 & 255] ^ j[_ + 3];
      return J = w[F >>> 24 & 255] & 4278190080 ^ g[R >>> 16 & 255] & 16711680 ^ c[V >>> 8 & 255] & 65280 ^ d[fe >>> 0 & 255] & 255 ^ j[_ + 0], N = w[R >>> 24 & 255] & 4278190080 ^ g[V >>> 16 & 255] & 16711680 ^ c[fe >>> 8 & 255] & 65280 ^ d[F >>> 0 & 255] & 255 ^ j[_ + 1], z = w[V >>> 24 & 255] & 4278190080 ^ g[fe >>> 16 & 255] & 16711680 ^ c[F >>> 8 & 255] & 65280 ^ d[R >>> 0 & 255] & 255 ^ j[_ + 2], A = w[fe >>> 24 & 255] & 4278190080 ^ g[F >>> 16 & 255] & 16711680 ^ c[R >>> 8 & 255] & 65280 ^ d[V >>> 0 & 255] & 255 ^ j[_ + 3], v(h, J, o + 0), v(h, N, o + 4), v(h, z, o + 8), v(h, A, o + 12), this;
    }
    decrypt(h, o, S, H) {
      const j = this.getDecryptKey();
      let J = E(S, H + 0) ^ j[0], N = E(S, H + 4) ^ j[1], z = E(S, H + 8) ^ j[2], A = E(S, H + 12) ^ j[3], q = this.rounds >>> 1, _ = 0, F, R, V, fe;
      for (; F = f[J >>> 24 & 255] ^ n[A >>> 16 & 255] ^ u[z >>> 8 & 255] ^ a[N >>> 0 & 255] ^ j[_ + 4], R = f[N >>> 24 & 255] ^ n[J >>> 16 & 255] ^ u[A >>> 8 & 255] ^ a[z >>> 0 & 255] ^ j[_ + 5], V = f[z >>> 24 & 255] ^ n[N >>> 16 & 255] ^ u[J >>> 8 & 255] ^ a[A >>> 0 & 255] ^ j[_ + 6], fe = f[A >>> 24 & 255] ^ n[z >>> 16 & 255] ^ u[N >>> 8 & 255] ^ a[J >>> 0 & 255] ^ j[_ + 7], _ += 8, q -= 1, q !== 0; )
        J = f[F >>> 24 & 255] ^ n[fe >>> 16 & 255] ^ u[V >>> 8 & 255] ^ a[R >>> 0 & 255] ^ j[_ + 0], N = f[R >>> 24 & 255] ^ n[F >>> 16 & 255] ^ u[fe >>> 8 & 255] ^ a[V >>> 0 & 255] ^ j[_ + 1], z = f[V >>> 24 & 255] ^ n[R >>> 16 & 255] ^ u[F >>> 8 & 255] ^ a[fe >>> 0 & 255] ^ j[_ + 2], A = f[fe >>> 24 & 255] ^ n[V >>> 16 & 255] ^ u[R >>> 8 & 255] ^ a[F >>> 0 & 255] ^ j[_ + 3];
      return J = s[F >>> 24 & 255] << 24 ^ s[fe >>> 16 & 255] << 16 ^ s[V >>> 8 & 255] << 8 ^ s[R >>> 0 & 255] << 0 ^ j[_ + 0], N = s[R >>> 24 & 255] << 24 ^ s[F >>> 16 & 255] << 16 ^ s[fe >>> 8 & 255] << 8 ^ s[V >>> 0 & 255] << 0 ^ j[_ + 1], z = s[V >>> 24 & 255] << 24 ^ s[R >>> 16 & 255] << 16 ^ s[F >>> 8 & 255] << 8 ^ s[fe >>> 0 & 255] << 0 ^ j[_ + 2], A = s[fe >>> 24 & 255] << 24 ^ s[V >>> 16 & 255] << 16 ^ s[R >>> 8 & 255] << 8 ^ s[F >>> 0 & 255] << 0 ^ j[_ + 3], v(h, J, o + 0), v(h, N, o + 4), v(h, z, o + 8), v(h, A, o + 12), this;
    }
    destroy() {
      if (this.key)
        for (let h = 0; h < this.key.length; h++)
          this.key[h] = 0;
      if (this.encKey)
        for (let h = 0; h < 60; h++)
          this.encKey[h] = 0;
      if (this.decKey)
        for (let h = 0; h < 60; h++)
          this.decKey[h] = 0;
      return this.key = null, this.encKey = null, this.decKey = null, this;
    }
  }
  function m(b) {
    switch (b) {
      case 128:
        return 10;
      case 192:
        return 12;
      case 256:
        return 14;
      default:
        throw new Error("Bad key size.");
    }
  }
  function E(b, h) {
    return b[h++] * 16777216 + b[h++] * 65536 + b[h++] * 256 + b[h];
  }
  function v(b, h, o) {
    return b[o++] = h >>> 24, b[o++] = h >>> 16, b[o++] = h >>> 8, b[o++] = h, o;
  }
  return da = p, da;
}
var wt = {};
/*!
 * ghash.js - ghash for javascript
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on golang/go:
 *   Copyright (c) 2009, The Go Authors. All rights reserved.
 *   https://github.com/golang/go
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/Galois/Counter_Mode
 *   https://dx.doi.org/10.6028/NIST.SP.800-38D
 *   https://github.com/golang/go/blob/master/src/crypto/cipher/gcm.go
 *   https://github.com/golang/go/blob/master/src/crypto/cipher/gcm_test.go
 *   https://github.com/DaGenix/rust-crypto/blob/master/src/ghash.rs
 */
var ba, t2;
function g9() {
  if (t2) return ba;
  t2 = 1;
  const e = Bt(), c = k.alloc(16, 0), d = -1, w = new Uint16Array([
    0,
    7200,
    14400,
    9312,
    28800,
    27808,
    18624,
    21728,
    57600,
    64800,
    55616,
    50528,
    37248,
    36256,
    43456,
    46560
  ]);
  class g {
    constructor() {
      this.state = new Uint32Array(4), this.block = k.alloc(16), this.size = d, this.adLen = 0, this.ctLen = 0, this.table = new Array(16);
      for (let p = 0; p < 16; p++)
        this.table[p] = new Uint32Array(4);
    }
    init(p) {
      e(k.isBuffer(p)), e(p.length === 16);
      for (let E = 0; E < 4; E++)
        this.state[E] = 0;
      this.size = 0, this.adLen = 0, this.ctLen = 0;
      for (let E = 0; E < 16; E++)
        for (let v = 0; v < 4; v++)
          this.table[E][v] = 0;
      const m = new Uint32Array(4);
      m[1] = a(p, 0), m[0] = a(p, 4), m[3] = a(p, 8), m[2] = a(p, 12), this.table[u(1)] = m;
      for (let E = 2; E < 16; E += 2)
        this.table[u(E)] = this.double(this.table[u(E >>> 1)]), this.table[u(E + 1)] = this.add(this.table[u(E)], m);
      return this;
    }
    absorb(p) {
      return this._absorb(p, p.length), this;
    }
    _absorb(p, m) {
      e(this.size !== d, "Context is not initialized.");
      let E = this.size & 15, v = 0;
      if (this.size += m, E > 0) {
        let b = 16 - E;
        if (b > m && (b = m), p.copy(this.block, E, v, v + b), E += b, m -= b, v += b, E < 16)
          return;
        this.transform(this.block, 0);
      }
      for (; m >= 16; )
        this.transform(p, v), v += 16, m -= 16;
      m > 0 && p.copy(this.block, 0, v, v + m);
    }
    transform(p, m) {
      this.state[1] ^= a(p, m + 0), this.state[0] ^= a(p, m + 4), this.state[3] ^= a(p, m + 8), this.state[2] ^= a(p, m + 12), this.mul(this.state);
    }
    pad() {
      const p = this.size & 15;
      p !== 0 && this._absorb(c, 16 - p);
    }
    aad(p) {
      return e(k.isBuffer(p)), e(this.ctLen === 0), this.adLen += p.length, this.absorb(p);
    }
    update(p) {
      return e(k.isBuffer(p)), p.length === 0 ? this : (this.ctLen === 0 && this.pad(), this.ctLen += p.length, this.absorb(p));
    }
    final() {
      const p = k.alloc(16);
      this.pad();
      const m = this.adLen * 8, E = this.ctLen * 8;
      this.state[1] ^= f(m), this.state[0] ^= n(m), this.state[3] ^= f(E), this.state[2] ^= n(E), this.mul(this.state), s(p, this.state[1], 0), s(p, this.state[0], 4), s(p, this.state[3], 8), s(p, this.state[2], 12);
      for (let v = 0; v < 4; v++)
        this.state[v] = 0;
      for (let v = 0; v < 16; v++)
        this.block[v] = 0;
      this.size = d, this.adLen = 0, this.ctLen = 0;
      for (let v = 0; v < 16; v++)
        for (let b = 0; b < 4; b++)
          this.table[v][b] = 0;
      return p;
    }
    destroy() {
      for (let p = 0; p < 4; p++)
        this.state[p] = 0;
      for (let p = 0; p < 16; p++)
        this.block[p] = 0;
      this.size = d, this.adLen = 0, this.ctLen = 0;
      for (let p = 0; p < 16; p++)
        for (let m = 0; m < 4; m++)
          this.table[p][m] = 0;
    }
    add(p, m) {
      e(p instanceof Uint32Array), e(p.length === 4), e(m instanceof Uint32Array), e(m.length === 4);
      const E = new Uint32Array(4);
      return E[0] = p[0] ^ m[0], E[1] = p[1] ^ m[1], E[2] = p[2] ^ m[2], E[3] = p[3] ^ m[3], E;
    }
    double(p) {
      e(p instanceof Uint32Array), e(p.length === 4);
      const m = new Uint32Array(4), E = (p[2] & 1) === 1;
      let v;
      return m[3] = p[3], m[2] = p[2], v = m[3] & 1, m[3] >>>= 1, m[2] >>>= 1, m[2] |= v << 31, m[3] |= (p[0] & 1) << 31, m[1] = p[1], m[0] = p[0], v = m[1] & 1, m[1] >>>= 1, m[0] >>>= 1, m[0] |= v << 31, E && (m[1] ^= 3774873600, m[0] ^= 0), m;
    }
    mul(p) {
      e(p instanceof Uint32Array), e(p.length === 4);
      const m = new Uint32Array(4), E = new Uint32Array(2);
      let v, b;
      for (let h = 0; h < 2; h++) {
        E[0] = p[2], E[1] = p[3], h === 1 && (E[0] = p[0], E[1] = p[1]);
        for (let o = 0; o < 64; o += 4) {
          const S = m[2] & 15;
          v = m[3] & 15, m[3] >>>= 4, m[2] >>>= 4, m[2] |= v << 28, m[3] |= m[0] << 28, v = m[1] & 15, m[1] >>>= 4, m[0] >>>= 4, m[0] |= v << 28, m[1] ^= w[S] << 16, b = this.table[E[0] & 15], m[0] ^= b[0], m[1] ^= b[1], m[2] ^= b[2], m[3] ^= b[3], v = E[1] & 15, E[1] >>>= 4, E[0] >>>= 4, E[0] |= v << 28;
        }
      }
      p[0] = m[0], p[1] = m[1], p[2] = m[2], p[3] = m[3];
    }
  }
  function f(i) {
    return i * (1 / 4294967296) >>> 0;
  }
  function n(i) {
    return i >>> 0;
  }
  function u(i) {
    return i = i << 2 & 12 | i >>> 2 & 3, i = i << 1 & 10 | i >>> 1 & 5, i;
  }
  function a(i, p) {
    return i[p++] * 16777216 + i[p++] * 65536 + i[p++] * 256 + i[p++];
  }
  function s(i, p, m) {
    return i[m++] = p >>> 24, i[m++] = p >>> 16, i[m++] = p >>> 8, i[m++] = p, m;
  }
  return ba = g, ba;
}
/*!
 * modes.js - cipher modes for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation
 */
var r2;
function x9() {
  if (r2) return wt;
  r2 = 1;
  const e = Bt(), c = g9(), d = k.alloc(0), w = new Uint32Array([
    27,
    // 8
    135,
    // 16
    1061,
    // 32
    0,
    293,
    // 64
    0,
    0,
    0,
    524355
    // 128
  ]);
  class g {
    constructor(C) {
      e(C && typeof C.encrypt == "function"), e(typeof C.blockSize == "number"), this.ctx = C;
    }
    get blockSize() {
      return this.ctx.blockSize;
    }
    init(C, I) {
      throw new Error("Not implemented.");
    }
    update(C) {
      throw new Error("Not implemented.");
    }
    crypt(C, I) {
      throw new Error("Not implemented.");
    }
    final() {
      throw new Error("Not implemented.");
    }
    destroy() {
      throw new Error("Not implemented.");
    }
    setAutoPadding(C) {
      return e(typeof C == "boolean"), this._setAutoPadding(C), this;
    }
    setAAD(C) {
      return e(k.isBuffer(C)), this._setAAD(C), this;
    }
    setCCM(C, I, se) {
      return e(C >>> 0 === C), e(I >>> 0 === I), e(se == null || k.isBuffer(se)), this._setCCM(C, I, se), this;
    }
    getAuthTag() {
      return this._getAuthTag();
    }
    setAuthTag(C) {
      return e(k.isBuffer(C)), this._setAuthTag(C), this;
    }
    _setAutoPadding(C) {
      throw new Error("Not available.");
    }
    _setAAD(C) {
      throw new Error("Cipher is not authenticated.");
    }
    _setCCM(C, I, se) {
      throw new Error("Not available.");
    }
    _getAuthTag() {
      throw new Error("Cipher is not authenticated.");
    }
    _setAuthTag(C) {
      throw new Error("Cipher is not authenticated.");
    }
  }
  class f extends g {
    constructor(C, I) {
      super(C), this.padding = !0, this.unpad = I, this.block = k.alloc(this.blockSize), this.blockPos = -1, this.last = null, this.lastSize = 0, I && (this.last = k.alloc(this.blockSize));
    }
    init(C, I) {
      return I == null && (I = d), e(k.isBuffer(C)), e(k.isBuffer(I)), this.ctx.init(C), this.blockPos = 0, this.lastSize = 0, this._init(C, I), this;
    }
    _updateSize(C) {
      if (this.blockPos + C < this.blockSize)
        return 0;
      let I = 0;
      return this.unpad && (I += this.lastSize), this.blockPos > 0 && (C -= this.blockSize - this.blockPos, I += this.blockSize), C >= this.blockSize && (I += C - C % this.blockSize), e(I >= this.blockSize), I;
    }
    update(C) {
      if (e(k.isBuffer(C)), this.blockPos === -1)
        throw new Error("Cipher is not initialized.");
      const I = this._updateSize(C.length), se = k.alloc(I);
      if (this.blockPos + C.length < this.blockSize)
        return this.blockPos += C.copy(this.block, this.blockPos, 0, C.length), se;
      let t = C.length, l = 0, B = 0;
      if (this.unpad && (B += this.last.copy(se, B, 0, this.lastSize)), this.blockPos > 0) {
        const U = this.blockSize - this.blockPos;
        l += C.copy(this.block, this.blockPos, l, l + U), t -= U, this._update(se, B, this.block, 0), B += this.blockSize, this.blockPos = 0;
      }
      for (; t >= this.blockSize; )
        this._update(se, B, C, l), l += this.blockSize, t -= this.blockSize, B += this.blockSize;
      return t > 0 && (this.blockPos = C.copy(this.block, 0, l, l + t)), e(B === I), this.unpad ? (this.lastSize = se.copy(this.last, 0, I - this.blockSize, I), se.slice(0, I - this.blockSize)) : se;
    }
    crypt(C, I) {
      if (e(k.isBuffer(C)), e(k.isBuffer(I)), e(C.length === I.length), this.blockPos === -1)
        throw new Error("Cipher is not initialized.");
      if (this.unpad || this.blockPos !== 0)
        throw new Error("Cannot crypt while buffering.");
      if (I.length % this.blockSize !== 0)
        throw new Error("Input must be a multiple of the block size.");
      const se = this.blockSize;
      let t = I.length, l = 0;
      for (; t > 0; )
        this._update(C, l, I, l), l += se, t -= se;
      return C;
    }
    final() {
      if (this.blockPos === -1)
        throw new Error("Cipher is not initialized.");
      try {
        return this._final();
      } finally {
        this.destroy();
      }
    }
    destroy() {
      this.ctx.destroy(), this.blockPos = -1, this.lastSize = 0;
      for (let C = 0; C < this.blockSize; C++)
        this.block[C] = 0;
      if (this.unpad)
        for (let C = 0; C < this.blockSize; C++)
          this.last[C] = 0;
      return this._destroy(), this;
    }
    _init(C, I) {
      throw new Error("Not implemented.");
    }
    _update(C, I, se, t) {
      throw new Error("Not implemented.");
    }
    _final() {
      throw new Error("Not implemented.");
    }
    _destroy() {
      throw new Error("Not implemented.");
    }
  }
  class n extends g {
    constructor(C) {
      super(C), this.pos = -1;
    }
    init(C, I) {
      return I == null && (I = d), e(k.isBuffer(C)), e(k.isBuffer(I)), this.ctx.init(C), this.pos = 0, this._init(C, I), this;
    }
    update(C) {
      if (e(k.isBuffer(C)), this.pos === -1)
        throw new Error("Cipher is not initialized.");
      const I = k.alloc(C.length);
      return this._crypt(I, C), I;
    }
    crypt(C, I) {
      if (e(k.isBuffer(C)), e(k.isBuffer(I)), e(C.length === I.length), this.pos === -1)
        throw new Error("Cipher is not initialized.");
      return this._crypt(C, I), C;
    }
    final() {
      if (this.pos === -1)
        throw new Error("Cipher is not initialized.");
      try {
        return this._final();
      } finally {
        this.destroy();
      }
    }
    destroy() {
      return this.ctx.destroy(), this.pos = -1, this._destroy(), this;
    }
    _init(C, I) {
      throw new Error("Not implemented.");
    }
    _crypt(C, I) {
      throw new Error("Not implemented.");
    }
    _final() {
      throw new Error("Not implemented.");
    }
    _destroy() {
      throw new Error("Not implemented.");
    }
  }
  class u extends f {
    constructor(C) {
      super(C, !1);
    }
    _init(C, I) {
      e(I.length === 0);
    }
    _update(C, I, se, t) {
      this.ctx.encrypt(C, I, se, t);
    }
    _final() {
      if (this.blockPos !== 0)
        throw new Error("Bad encrypt (trailing bytes).");
      return k.alloc(0);
    }
    _destroy() {
    }
  }
  class a extends f {
    constructor(C) {
      super(C, !1);
    }
    _init(C, I) {
      e(I.length === 0);
    }
    _update(C, I, se, t) {
      this.ctx.decrypt(C, I, se, t);
    }
    _final() {
      if (this.blockPos !== 0)
        throw new Error("Bad decrypt (trailing bytes).");
      return k.alloc(0);
    }
    _destroy() {
    }
  }
  class s extends f {
    constructor(C) {
      super(C, !1);
    }
    _final() {
      if (!this.padding) {
        if (this.blockPos !== 0)
          throw new Error("Bad encrypt (trailing bytes).");
        return k.alloc(0);
      }
      const C = this.blockSize - this.blockPos, I = k.from(this.block);
      for (let se = this.blockPos; se < this.blockSize; se++)
        I[se] = C;
      return this._update(I, 0, I, 0), I;
    }
    _setAutoPadding(C) {
      this.padding = C;
    }
  }
  class i extends f {
    constructor(C) {
      super(C, !0);
    }
    _final() {
      if (this.blockPos !== 0)
        throw new Error("Bad decrypt (trailing bytes).");
      if (!this.padding)
        return k.alloc(0);
      if (this.lastSize === 0)
        throw new Error("Bad decrypt (no data).");
      e(this.lastSize === this.last.length), e(this.lastSize === this.blockSize);
      const C = k.from(this.last);
      let I = C[C.length - 1], se = 1;
      se &= I - 1 >>> 31 ^ 1, se &= I - this.blockSize - 1 >>> 31, I &= -se;
      const t = this.blockSize - I;
      for (let l = 0; l < this.blockSize; l++) {
        const B = C[l];
        se &= l - t >>> 31 | (B ^ I) - 1 >>> 31;
      }
      if (!se)
        throw new Error("Bad decrypt (padding).");
      return C.slice(0, t);
    }
    _setAutoPadding(C) {
      if (this.lastSize !== 0 || this.blockPos !== 0)
        throw new Error("Cannot set auto padding.");
      this.padding = C, this.unpad = C;
    }
  }
  class p extends s {
    constructor(C) {
      super(C);
    }
    _init(C, I) {
      e(I.length === 0);
    }
    _update(C, I, se, t) {
      this.ctx.encrypt(C, I, se, t);
    }
    _destroy() {
    }
  }
  class m extends i {
    constructor(C) {
      super(C);
    }
    _init(C, I) {
      e(I.length === 0);
    }
    _update(C, I, se, t) {
      this.ctx.decrypt(C, I, se, t);
    }
    _destroy() {
    }
  }
  class E extends s {
    constructor(C) {
      super(C), this.prev = k.alloc(this.blockSize);
    }
    _init(C, I) {
      e(I.length === this.blockSize), I.copy(this.prev, 0);
    }
    _update(C, I, se, t) {
      for (let l = 0; l < this.blockSize; l++)
        this.prev[l] ^= se[t + l];
      this.ctx.encrypt(C, I, this.prev, 0), C.copy(this.prev, 0, I, I + this.blockSize);
    }
    _destroy() {
      for (let C = 0; C < this.blockSize; C++)
        this.prev[C] = 0;
    }
  }
  class v extends i {
    constructor(C) {
      super(C), this.prev = k.alloc(this.blockSize), this.tmp = k.alloc(this.blockSize);
    }
    _init(C, I) {
      e(I.length === this.blockSize), I.copy(this.prev, 0);
    }
    _update(C, I, se, t) {
      if (xe(C, I, se, t)) {
        this.prev.copy(this.tmp, 0), se.copy(this.prev, 0, t, t + this.blockSize), this.ctx.decrypt(C, I, se, t);
        for (let l = 0; l < this.blockSize; l++)
          C[I + l] ^= this.tmp[l];
      } else {
        this.ctx.decrypt(C, I, se, t);
        for (let l = 0; l < this.blockSize; l++)
          C[I + l] ^= this.prev[l];
        se.copy(this.prev, 0, t, t + this.blockSize);
      }
    }
    _destroy() {
      for (let C = 0; C < this.blockSize; C++)
        this.prev[C] = 0, this.tmp[C] = 0;
    }
  }
  class b extends f {
    constructor(C) {
      super(C, !0), this.prev = k.alloc(this.blockSize);
    }
    _init(C, I) {
      e(I.length === this.blockSize), I.copy(this.prev, 0);
    }
    _update(C, I, se, t) {
      for (let l = 0; l < this.blockSize; l++)
        this.prev[l] ^= se[t + l];
      this.ctx.encrypt(C, I, this.prev, 0), C.copy(this.prev, 0, I, I + this.blockSize);
    }
    _final() {
      if (!this.padding) {
        if (this.blockPos !== 0)
          throw new Error("Bad encrypt (trailing bytes).");
        return k.alloc(0);
      }
      if (this.lastSize === 0)
        throw new Error("Bad encrypt (no data).");
      for (let I = 0; I < this.blockPos; I++)
        this.prev[I] ^= this.block[I];
      this.ctx.encrypt(this.prev, 0, this.prev, 0);
      const C = this.last.slice(0, this.blockPos);
      return k.concat([this.prev, C]);
    }
    _destroy() {
      for (let C = 0; C < this.blockSize; C++)
        this.prev[C] = 0;
    }
    _setAutoPadding(C) {
      if (this.lastSize !== 0 || this.blockPos !== 0)
        throw new Error("Cannot set auto padding.");
      this.padding = C, this.unpad = C;
    }
  }
  class h extends f {
    constructor(C) {
      super(C, !0), this.prev = k.alloc(this.blockSize), this.tmp = k.alloc(this.blockSize);
    }
    _init(C, I) {
      e(I.length === this.blockSize), I.copy(this.prev, 0);
    }
    _update(C, I, se, t) {
      if (xe(C, I, se, t)) {
        this.prev.copy(this.tmp, 0), se.copy(this.prev, 0, t, t + this.blockSize), this.ctx.decrypt(C, I, se, t);
        for (let l = 0; l < this.blockSize; l++)
          C[I + l] ^= this.tmp[l];
      } else {
        this.ctx.decrypt(C, I, se, t);
        for (let l = 0; l < this.blockSize; l++)
          C[I + l] ^= this.prev[l];
        se.copy(this.prev, 0, t, t + this.blockSize);
      }
    }
    _final() {
      if (!this.padding) {
        if (this.blockPos !== 0)
          throw new Error("Bad decrypt (trailing bytes).");
        return k.alloc(0);
      }
      if (this.lastSize === 0)
        throw new Error("Bad decrypt (no data).");
      const C = k.alloc(this.blockSize);
      this.ctx.decrypt(this.prev, 0, this.prev, 0);
      for (let se = 0; se < this.blockSize; se++)
        C[se] = this.last[se] ^ this.prev[se];
      for (let se = 0; se < this.blockPos; se++)
        this.last[se] = this.block[se], this.block[se] ^= this.prev[se];
      for (let se = this.blockPos; se < this.blockSize; se++)
        this.last[se] = this.prev[se];
      this.ctx.decrypt(this.last, 0, this.last, 0);
      for (let se = 0; se < this.blockSize; se++)
        this.last[se] ^= C[se];
      const I = this.block.slice(0, this.blockPos);
      return k.concat([this.last, I]);
    }
    _destroy() {
      for (let C = 0; C < this.blockSize; C++)
        this.prev[C] = 0, this.tmp[C] = 0;
    }
    _setAutoPadding(C) {
      if (this.lastSize !== 0 || this.blockPos !== 0)
        throw new Error("Cannot set auto padding.");
      this.padding = C, this.unpad = C;
    }
  }
  class o extends f {
    constructor(C, I) {
      super(C, !0), this.encrypt = I, this.poly = w[this.blockSize >>> 4], this.tweak = k.alloc(this.blockSize), this.prev = k.alloc(this.blockSize);
    }
    init(C, I) {
      e(k.isBuffer(C)), e(k.isBuffer(I)), e(C.length > 0 && (C.length & 1) === 0), e(I.length === this.blockSize);
      const se = C.length >>> 1, t = C.slice(0, se), l = C.slice(se);
      if (Ie(t, l, se))
        throw new Error("XTS keys are equal.");
      return this.ctx.init(l), this.ctx.encrypt(this.tweak, 0, I, 0), this.ctx.init(t), this.blockPos = 0, this.lastSize = 0, this;
    }
    _shift() {
      let C = 0;
      this.encrypt || this.tweak.copy(this.prev, 0);
      for (let I = 0; I < this.blockSize; I++) {
        const se = this.tweak[I] >> 7;
        this.tweak[I] <<= 1, this.tweak[I] |= C, C = se;
      }
      C = -C & 255, this.tweak[2] ^= this.poly >> 16 & C, this.tweak[1] ^= this.poly >> 8 & C, this.tweak[0] ^= this.poly >> 0 & C;
    }
    _update(C, I, se, t) {
      for (let l = 0; l < this.blockSize; l++)
        C[I + l] = se[t + l] ^ this.tweak[l];
      this.encrypt ? this.ctx.encrypt(C, I, C, I) : this.ctx.decrypt(C, I, C, I);
      for (let l = 0; l < this.blockSize; l++)
        C[I + l] ^= this.tweak[l];
      this._shift();
    }
    _destroy() {
      for (let C = 0; C < this.blockSize; C++)
        this.tweak[C] = 0, this.prev[C] = 0;
    }
    _setAutoPadding(C) {
      if (this.lastSize !== 0 || this.blockPos !== 0)
        throw new Error("Cannot set auto padding.");
      this.padding = C, this.unpad = C;
    }
  }
  class S extends o {
    constructor(C) {
      super(C, !0);
    }
    _final() {
      if (!this.padding) {
        if (this.blockPos !== 0)
          throw new Error("Bad encrypt (trailing bytes).");
        return k.alloc(0);
      }
      if (this.lastSize === 0)
        throw new Error("Bad encrypt (no data).");
      if (this.blockPos === 0)
        return k.from(this.last);
      const C = k.alloc(this.blockPos);
      for (let I = 0; I < this.blockPos; I++)
        C[I] = this.last[I], this.last[I] = this.block[I];
      for (let I = 0; I < this.blockSize; I++)
        this.last[I] ^= this.tweak[I];
      this.ctx.encrypt(this.last, 0, this.last, 0);
      for (let I = 0; I < this.blockSize; I++)
        this.last[I] ^= this.tweak[I];
      return k.concat([this.last, C]);
    }
  }
  class H extends o {
    constructor(C) {
      super(C, !1);
    }
    _final() {
      if (!this.padding) {
        if (this.blockPos !== 0)
          throw new Error("Bad decrypt (trailing bytes).");
        return k.alloc(0);
      }
      if (this.lastSize === 0)
        throw new Error("Bad decrypt (no data).");
      if (this.blockPos === 0)
        return k.from(this.last);
      for (let I = 0; I < this.blockSize; I++)
        this.last[I] ^= this.prev[I];
      this.ctx.encrypt(this.last, 0, this.last, 0);
      for (let I = 0; I < this.blockSize; I++)
        this.last[I] ^= this.prev[I];
      for (let I = 0; I < this.blockSize; I++)
        this.last[I] ^= this.tweak[I];
      this.ctx.decrypt(this.last, 0, this.last, 0);
      for (let I = 0; I < this.blockSize; I++)
        this.last[I] ^= this.tweak[I];
      const C = k.alloc(this.blockPos);
      for (let I = 0; I < this.blockPos; I++)
        C[I] = this.last[I], this.last[I] = this.block[I];
      for (let I = 0; I < this.blockSize; I++)
        this.last[I] ^= this.prev[I];
      this.ctx.decrypt(this.last, 0, this.last, 0);
      for (let I = 0; I < this.blockSize; I++)
        this.last[I] ^= this.prev[I];
      return k.concat([this.last, C]);
    }
  }
  class j extends n {
    constructor(C) {
      super(C), this.state = k.alloc(this.blockSize), this.ctr = k.alloc(this.blockSize);
    }
    _init(C, I) {
      e(I.length === this.blockSize), I.copy(this.ctr, 0);
    }
    _increment() {
      for (let C = this.ctr.length - 1; C >= 0 && (this.ctr[C] += 1, this.ctr[C] === 0); C--)
        ;
    }
    _crypt(C, I) {
      const se = this.blockSize - 1;
      for (let t = 0; t < I.length; t++)
        (this.pos & se) === 0 && (this.ctx.encrypt(this.state, 0, this.ctr, 0), this._increment(), this.pos = 0), C[t] = I[t] ^ this.state[this.pos++];
    }
    _final() {
      return k.alloc(0);
    }
    _destroy() {
      for (let C = 0; C < this.blockSize; C++)
        this.state[C] = 0, this.ctr[C] = 0;
    }
  }
  class J extends j {
    constructor(C) {
      super(C);
    }
  }
  class N extends j {
    constructor(C) {
      super(C);
    }
  }
  class z extends n {
    constructor(C) {
      super(C), this.state = k.alloc(this.blockSize), this.prev = k.alloc(this.blockSize);
    }
    _init(C, I) {
      e(I.length === this.blockSize), I.copy(this.prev, 0);
    }
    _final() {
      return k.alloc(0);
    }
    _destroy() {
      for (let C = 0; C < this.blockSize; C++)
        this.state[C] = 0, this.prev[C] = 0;
    }
  }
  class A extends z {
    constructor(C) {
      super(C);
    }
    _crypt(C, I) {
      const se = this.blockSize - 1;
      for (let t = 0; t < I.length; t++)
        (this.pos & se) === 0 && (this.ctx.encrypt(this.state, 0, this.prev, 0), this.pos = 0), C[t] = I[t] ^ this.state[this.pos], this.prev[this.pos] = C[t], this.pos += 1;
    }
  }
  class q extends z {
    constructor(C) {
      super(C);
    }
    _crypt(C, I) {
      const se = this.blockSize - 1;
      for (let t = 0; t < I.length; t++)
        (this.pos & se) === 0 && (this.ctx.encrypt(this.state, 0, this.prev, 0), this.pos = 0), this.prev[this.pos] = I[t], C[t] = I[t] ^ this.state[this.pos], this.pos += 1;
    }
  }
  class _ extends n {
    constructor(C) {
      super(C), this.state = k.alloc(this.blockSize);
    }
    _init(C, I) {
      e(k.isBuffer(I)), e(I.length === this.blockSize), I.copy(this.state, 0);
    }
    _crypt(C, I) {
      const se = this.blockSize - 1;
      for (let t = 0; t < I.length; t++)
        (this.pos & se) === 0 && (this.ctx.encrypt(this.state, 0, this.state, 0), this.pos = 0), C[t] = I[t] ^ this.state[this.pos++];
    }
    _final() {
      return k.alloc(0);
    }
    _destroy() {
      for (let C = 0; C < this.blockSize; C++)
        this.state[C] = 0;
    }
  }
  class F extends _ {
    constructor(C) {
      super(C);
    }
  }
  class R extends _ {
    constructor(C) {
      super(C);
    }
  }
  class V extends n {
    constructor(C, I) {
      e(C.blockSize === 16), super(C), this.encrypt = I, this.hash = new c(), this.ctr = k.alloc(16), this.state = k.alloc(16), this.key = k.alloc(16), this.mask = k.alloc(16), this.tag = null, this.mac = null;
    }
    _init(C, I) {
      for (let se = 0; se < 16; se++)
        this.ctr[se] = 0, this.key[se] = 0, this.mask[se] = 0;
      return this._encipher(this.key, this.key), this.hash.init(this.key), I.length !== 12 && (this.hash.update(I), I = this.hash.final(), this.hash.init(this.key)), I.copy(this.ctr, 0), I.length === 12 && (this.ctr[12] = 0, this.ctr[13] = 0, this.ctr[14] = 0, this.ctr[15] = 1), this._encipher(this.mask, this.mask), this.tag = null, this.mac = null, this;
    }
    _increment() {
      let C = 1, I = 4;
      for (; I--; )
        C += this.ctr[12 + I], this.ctr[12 + I] = C, C >>= 8;
    }
    _encipher(C, I) {
      for (let se = 0; se < I.length; se++)
        (this.pos & 15) === 0 && (this.ctx.encrypt(this.state, 0, this.ctr, 0), this._increment(), this.pos = 0), C[se] = I[se] ^ this.state[this.pos++];
    }
    _crypt(C, I) {
      this.encrypt ? (this._encipher(C, I), this.hash.update(C)) : (this.hash.update(I), this._encipher(C, I));
    }
    _final() {
      const C = this.hash.final();
      for (let I = 0; I < 16; I++)
        C[I] ^= this.mask[I];
      if (this.encrypt)
        return this.mac = C, k.alloc(0);
      if (!this.tag)
        throw new Error("No tag provided.");
      if (!Ie(C, this.tag, this.tag.length))
        throw new Error("Invalid tag.");
      return k.alloc(0);
    }
    _destroy() {
      this.hash.destroy();
      for (let C = 0; C < 16; C++)
        this.ctr[C] = 0, this.state[C] = 0, this.key[C] = 0, this.mask[C] = 0;
      if (this.tag) {
        for (let C = 0; C < this.tag.length; C++)
          this.tag[C] = 0;
        this.tag = null;
      }
    }
    _setAAD(C) {
      if (this.pos === -1)
        throw new Error("Cipher is not initialized.");
      return this.hash.aad(C), this;
    }
    _getAuthTag() {
      if (!this.encrypt)
        throw new Error("Must be a cipher context.");
      if (!this.mac)
        throw new Error("Cipher is not finalized.");
      return k.from(this.mac);
    }
    _setAuthTag(C) {
      if (this.encrypt)
        throw new Error("Must be a decipher context.");
      if (this.pos === -1)
        throw new Error("Cipher is not initialized.");
      if (C.length !== 4 && C.length !== 8 && (C.length < 12 || C.length > 16))
        throw new RangeError("Invalid tag size.");
      return this.tag = k.from(C), this;
    }
  }
  class fe extends V {
    constructor(C) {
      super(C, !0);
    }
  }
  class ue extends V {
    constructor(C) {
      super(C, !1);
    }
  }
  class ae {
    constructor(C) {
      this.ctx = C, this.size = C.blockSize, this.mac = k.alloc(this.size), this.pos = -1;
    }
    init() {
      return this.mac.fill(0), this.pos = 0, this;
    }
    update(C) {
      if (e(k.isBuffer(C)), this.pos === -1)
        throw new Error("Context is not initialized.");
      for (let I = 0; I < C.length; I++)
        this.mac[this.pos++] ^= C[I], this.pos === this.size && (this.ctx.encrypt(this.mac, 0, this.mac, 0), this.pos = 0);
    }
    pad() {
      this.pos > 0 && (this.ctx.encrypt(this.mac, 0, this.mac, 0), this.pos = 0);
    }
    final() {
      if (this.pos === -1)
        throw new Error("Context is not initialized.");
      return this.pad(), this.pos = -1, k.from(this.mac);
    }
  }
  class D extends n {
    constructor(C, I) {
      e(C.blockSize === 16), super(C), this.encrypt = I, this.hash = new ae(C), this.state = k.alloc(16), this.ctr = k.alloc(16), this.tagLen = 0, this.iv = null, this.mac = null, this.tag = null;
    }
    _increment() {
      for (let C = 15; C >= 1 && (this.ctr[C] += 1, this.ctr[C] === 0); C--)
        ;
    }
    _encipher(C, I) {
      for (let se = 0; se < I.length; se++)
        (this.pos & 15) === 0 && (this.ctx.encrypt(this.state, 0, this.ctr, 0), this._increment(), this.pos = 0), C[se] = I[se] ^ this.state[this.pos++];
    }
    _init(C, I) {
      if (I.length < 7)
        throw new RangeError("Invalid nonce length.");
      I.length > 13 && (I = I.slice(0, 13)), this.iv = k.from(I), this.pos = -1, this.tagLen = 0, this.mac = null, this.tag = null;
    }
    _setCCM(C, I, se) {
      if (!this.iv)
        throw new Error("Cipher is not initialized.");
      let t = C, l = Math.ceil((32 - Math.clz32(t)) / 8);
      l < 2 && (l = 2);
      const B = I, U = 15 - l, G = (se && se.length > 0) | 0, T = k.alloc(16);
      if (B < 4 || B > 16 || (B & 1) !== 0)
        throw new RangeError("Invalid tag length.");
      T[0] = 64 * G + 8 * ((B - 2) / 2) + (l - 1), this.iv.copy(T, 1, 0, Math.min(U, this.iv.length));
      for (let M = 15; M >= 1 + U; M--)
        T[M] = t & 255, t >>>= 8;
      if (e(t === 0), this.hash.init(), this.hash.update(T), G) {
        if (se.length < 65280) {
          const M = k.alloc(2);
          M[0] = se.length >>> 8, M[1] = se.length >>> 0, this.hash.update(M);
        } else if (se.length < 4294967295) {
          const M = k.alloc(6);
          M[0] = 255, M[1] = 254, M[2] = se.length >>> 24, M[3] = se.length >>> 16, M[4] = se.length >>> 8, M[5] = se.length >>> 0, this.hash.update(M);
        } else
          throw new RangeError("Invalid AAD length.");
        this.hash.update(se), this.hash.pad();
      }
      T[0] &= 7, T[15] = 1;
      for (let M = 14; M >= 1 + U; M--)
        T[M] = 0;
      T.copy(this.ctr, 0), this.pos = 0, this.tagLen = B, this.iv = null;
    }
    _crypt(C, I) {
      this.encrypt ? (this.hash.update(I), this._encipher(C, I)) : (this._encipher(C, I), this.hash.update(C));
    }
    _final() {
      const C = this.hash.final();
      let I = 16 - ((this.ctr[0] & 7) + 1);
      for (; I < 16; )
        this.ctr[I++] = 0;
      if (this.pos = 0, this._encipher(C, C), this.encrypt)
        return this.mac = C.slice(0, this.tagLen), k.alloc(0);
      if (!this.tag)
        throw new Error("No tag provided.");
      if (!Ie(C, this.tag, this.tagLen))
        throw new Error("Invalid tag.");
      return k.alloc(0);
    }
    _destroy() {
      for (let C = 0; C < 16; C++)
        this.state[C] = 0, this.ctr[C] = 0;
      this.tagLen = 0, this.iv = null, this.tag = null;
    }
    _getAuthTag() {
      if (!this.encrypt)
        throw new Error("Must be a cipher context.");
      if (!this.mac)
        throw new Error("Cipher is not finalized.");
      return k.from(this.mac);
    }
    _setAuthTag(C) {
      if (this.encrypt)
        throw new Error("Must be a decipher context.");
      if (this.pos === -1)
        throw new Error("Cipher is not initialized.");
      if (this.tagLen === 0 || C.length !== this.tagLen)
        throw new RangeError("Invalid tag size.");
      return this.tag = k.from(C), this;
    }
  }
  class Q extends D {
    constructor(C) {
      super(C, !0);
    }
  }
  class Z extends D {
    constructor(C) {
      super(C, !1);
    }
  }
  class oe {
    constructor(C) {
      this.ctx = C, this.poly = w[C.blockSize >>> 4], this.size = C.blockSize, this.mac = k.alloc(this.size), this.pos = -1;
    }
    init(C) {
      return this.mac.fill(0), this.pos = 0, C != null && (this.mac[this.size - 1] ^= C, this.pos = this.size), this;
    }
    shift(C, I) {
      let se = 0;
      for (let t = this.size - 1; t >= 0; t--) {
        const l = I[t] >> 7;
        C[t] = I[t] << 1 | se, se = l;
      }
      se = -se & 255, C[this.size - 3] ^= this.poly >> 16 & se, C[this.size - 2] ^= this.poly >> 8 & se, C[this.size - 1] ^= this.poly >> 0 & se;
    }
    update(C) {
      if (e(k.isBuffer(C)), this.pos === -1)
        throw new Error("Context is not initialized.");
      for (let I = 0; I < C.length; I++)
        this.pos === this.size && (this.ctx.encrypt(this.mac, 0, this.mac, 0), this.pos = 0), this.mac[this.pos++] ^= C[I];
    }
    final() {
      if (this.pos === -1)
        throw new Error("Context is not initialized.");
      const C = k.alloc(this.size);
      this.ctx.encrypt(C, 0, C, 0), this.shift(C, C), this.pos < this.size && (this.mac[this.pos] ^= 128, this.shift(C, C));
      for (let I = 0; I < this.size; I++)
        this.mac[I] ^= C[I];
      return this.ctx.encrypt(this.mac, 0, this.mac, 0), this.pos = -1, k.from(this.mac);
    }
  }
  class y extends n {
    constructor(C, I) {
      super(C), this.encrypt = I, this.hash1 = new oe(C), this.hash2 = new oe(C), this.state = k.alloc(this.blockSize), this.ctr = k.alloc(this.blockSize), this.mask = k.alloc(this.blockSize), this.mac = null, this.tag = null;
    }
    _increment() {
      let C = this.blockSize, I = 1;
      for (; C--; )
        I += this.ctr[C], this.ctr[C] = I, I >>= 8;
    }
    _encipher(C, I) {
      const se = this.blockSize - 1;
      for (let t = 0; t < I.length; t++)
        (this.pos & se) === 0 && (this.ctx.encrypt(this.state, 0, this.ctr, 0), this._increment(), this.pos = 0), C[t] = I[t] ^ this.state[this.pos++];
    }
    _init(C, I) {
      e(I.length > 0), this.hash1.init(0), this.hash1.update(I), this.mask = this.hash1.final(), this.mask.copy(this.ctr, 0), this.hash1.init(1), this.hash2.init(2), this.mac = null, this.tag = null;
    }
    _crypt(C, I) {
      this.encrypt ? (this._encipher(C, I), this.hash2.update(C)) : (this.hash2.update(I), this._encipher(C, I));
    }
    _final() {
      const C = k.alloc(this.blockSize), I = this.hash1.final(), se = this.hash2.final();
      for (let t = 0; t < this.blockSize; t++)
        C[t] = I[t] ^ se[t] ^ this.mask[t];
      if (this.encrypt)
        return this.mac = C, k.alloc(0);
      if (!this.tag)
        throw new Error("No tag provided.");
      if (!Ie(C, this.tag, this.tag.length))
        throw new Error("Invalid tag.");
      return k.alloc(0);
    }
    _destroy() {
      for (let C = 0; C < this.blockSize; C++)
        this.state[C] = 0, this.ctr[C] = 0, this.mask[C] = 0;
      this.tag = null;
    }
    _setAAD(C) {
      if (this.pos === -1)
        throw new Error("Cipher is not initialized.");
      return this.hash1.update(C), this;
    }
    _getAuthTag() {
      if (!this.encrypt)
        throw new Error("Must be a cipher context.");
      if (!this.mac)
        throw new Error("Cipher is not finalized.");
      return k.from(this.mac);
    }
    _setAuthTag(C) {
      if (this.encrypt)
        throw new Error("Must be a decipher context.");
      if (this.pos === -1)
        throw new Error("Cipher is not initialized.");
      if (C.length === 0 || C.length > this.blockSize)
        throw new RangeError("Invalid tag size.");
      return this.tag = k.from(C), this;
    }
  }
  class Y extends y {
    constructor(C) {
      super(C, !0);
    }
  }
  class he extends y {
    constructor(C) {
      super(C, !1);
    }
  }
  function be(ve, C = !0) {
    switch (e(typeof ve == "string"), e(typeof C == "boolean"), ve) {
      case "RAW":
        return C ? u : a;
      case "ECB":
        return C ? p : m;
      case "CBC":
        return C ? E : v;
      case "CTS":
        return C ? b : h;
      case "XTS":
        return C ? S : H;
      case "CTR":
        return C ? J : N;
      case "CFB":
        return C ? A : q;
      case "OFB":
        return C ? F : R;
      case "GCM":
        return C ? fe : ue;
      case "CCM":
        return C ? Q : Z;
      case "EAX":
        return C ? Y : he;
      default:
        throw new Error(`Unknown mode: ${ve}.`);
    }
  }
  function xe(ve, C, I, se) {
    return ve.buffer === I.buffer && ve.byteOffset === I.byteOffset && C === se;
  }
  function Ie(ve, C, I) {
    let se = 0;
    for (let t = 0; t < I; t++)
      se |= ve[t] ^ C[t];
    return se - 1 >>> 31;
  }
  return wt.Mode = g, wt.Block = f, wt.Stream = n, wt.RawCipher = u, wt.RawDecipher = a, wt.PKCS7Cipher = s, wt.PKCS7Decipher = i, wt.ECBCipher = p, wt.ECBDecipher = m, wt.CBCCipher = E, wt.CBCDecipher = v, wt.CTSCipher = b, wt.CTSDecipher = h, wt.XTS = o, wt.XTSCipher = S, wt.XTSDecipher = H, wt.CTR = j, wt.CTRCipher = J, wt.CTRDecipher = N, wt.CFB = z, wt.CFBCipher = A, wt.CFBDecipher = q, wt.OFB = _, wt.OFBCipher = F, wt.OFBDecipher = R, wt.GCM = V, wt.GCMCipher = fe, wt.GCMDecipher = ue, wt.CBCMAC = ae, wt.CCM = D, wt.CCMCipher = Q, wt.CCMDecipher = Z, wt.CMAC = oe, wt.EAX = y, wt.EAXCipher = Y, wt.EAXDecipher = he, wt.get = be, wt;
}
/*!
 * aes.js - aes128/192/256 for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var i2;
function w9() {
  if (i2) return Pn;
  i2 = 1;
  const e = m9(), { CBCCipher: c, CBCDecipher: d } = x9();
  function w(f, n, u) {
    const a = new c(new e(256));
    return a.init(n, u), k.concat([a.update(f), a.final()]);
  }
  function g(f, n, u) {
    const a = new d(new e(256));
    return a.init(n, u), k.concat([a.update(f), a.final()]);
  }
  return Pn.native = 0, Pn.encipher = w, Pn.decipher = g, Pn;
}
/*!
 * keccak.js - Keccak/SHA3 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on emn178/js-sha3:
 *   Copyright (c) 2015-2017, Chen, Yi-Cyuan (MIT License).
 *   https://github.com/emn178/js-sha3
 *
 * Parts of this software are based on rhash/RHash:
 *   Copyright (c) 2005-2014, Aleksey Kravchenko
 *   https://github.com/rhash/RHash
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/SHA-3
 *   https://keccak.team/specifications.html
 *   https://csrc.nist.gov/projects/hash-functions/sha-3-project/sha-3-standardization
 *   http://dx.doi.org/10.6028/NIST.FIPS.202
 *   https://github.com/rhash/RHash/blob/master/librhash/sha3.c
 *   https://github.com/emn178/js-sha3/blob/master/src/sha3.js
 */
var pa, n2;
function hb() {
  if (n2) return pa;
  n2 = 1;
  const e = Bt(), c = ri(), d = 2147483648, w = new Uint32Array([
    1,
    0,
    32898,
    0,
    32906,
    2147483648,
    2147516416,
    2147483648,
    32907,
    0,
    2147483649,
    0,
    2147516545,
    2147483648,
    32777,
    2147483648,
    138,
    0,
    136,
    0,
    2147516425,
    0,
    2147483658,
    0,
    2147516555,
    0,
    139,
    2147483648,
    32905,
    2147483648,
    32771,
    2147483648,
    32770,
    2147483648,
    128,
    2147483648,
    32778,
    0,
    2147483658,
    2147483648,
    2147516545,
    2147483648,
    32896,
    2147483648,
    2147483649,
    0,
    2147516424,
    2147483648
  ]);
  class g {
    constructor() {
      this.state = new Uint32Array(50), this.block = k.alloc(200), this.bs = 136, this.pos = d;
    }
    init(u) {
      u == null && (u = 256), e(u >>> 0 === u), e(u >= 128), e(u <= 512);
      const a = 1600 - u * 2;
      return e(a >= 0 && (a & 63) === 0), this.bs = a >>> 3, this.pos = 0, this;
    }
    update(u) {
      e(k.isBuffer(u)), e(!(this.pos & d), "Context is not initialized.");
      let a = u.length, s = this.pos, i = 0;
      if (this.pos = (this.pos + a) % this.bs, s > 0) {
        let p = this.bs - s;
        if (p > a && (p = a), u.copy(this.block, s, i, i + p), s += p, a -= p, i += p, s < this.bs)
          return this;
        this._transform(this.block, 0);
      }
      for (; a >= this.bs; )
        this._transform(u, i), i += this.bs, a -= this.bs;
      return a > 0 && u.copy(this.block, 0, i, i + a), this;
    }
    final(u, a) {
      u == null && (u = 1), (a == null || a === 0) && (a = 100 - (this.bs >>> 1)), e((u & 255) === u), e(a >>> 0 === a), e(!(this.pos & d), "Context is not initialized."), this.block.fill(0, this.pos, this.bs), this.block[this.pos] |= u, this.block[this.bs - 1] |= 128, this._transform(this.block, 0), this.pos = d, e(a <= this.bs);
      const s = k.alloc(a);
      for (let i = 0; i < a; i++)
        s[i] = this.state[i >>> 2] >>> 8 * (i & 3);
      for (let i = 0; i < 50; i++)
        this.state[i] = 0;
      for (let i = 0; i < this.bs; i++)
        this.block[i] = 0;
      return s;
    }
    _transform(u, a) {
      const s = this.bs >>> 2, i = this.state;
      for (let p = 0; p < s; p++)
        i[p] ^= f(u, a + p * 4);
      for (let p = 0; p < 48; p += 2) {
        const m = i[0] ^ i[10] ^ i[20] ^ i[30] ^ i[40], E = i[1] ^ i[11] ^ i[21] ^ i[31] ^ i[41], v = i[2] ^ i[12] ^ i[22] ^ i[32] ^ i[42], b = i[3] ^ i[13] ^ i[23] ^ i[33] ^ i[43], h = i[4] ^ i[14] ^ i[24] ^ i[34] ^ i[44], o = i[5] ^ i[15] ^ i[25] ^ i[35] ^ i[45], S = i[6] ^ i[16] ^ i[26] ^ i[36] ^ i[46], H = i[7] ^ i[17] ^ i[27] ^ i[37] ^ i[47], j = i[8] ^ i[18] ^ i[28] ^ i[38] ^ i[48], J = i[9] ^ i[19] ^ i[29] ^ i[39] ^ i[49], N = j ^ (v << 1 | b >>> 31), z = J ^ (b << 1 | v >>> 31), A = m ^ (h << 1 | o >>> 31), q = E ^ (o << 1 | h >>> 31), _ = v ^ (S << 1 | H >>> 31), F = b ^ (H << 1 | S >>> 31), R = h ^ (j << 1 | J >>> 31), V = o ^ (J << 1 | j >>> 31), fe = S ^ (m << 1 | E >>> 31), ue = H ^ (E << 1 | m >>> 31);
        i[0] ^= N, i[1] ^= z, i[10] ^= N, i[11] ^= z, i[20] ^= N, i[21] ^= z, i[30] ^= N, i[31] ^= z, i[40] ^= N, i[41] ^= z, i[2] ^= A, i[3] ^= q, i[12] ^= A, i[13] ^= q, i[22] ^= A, i[23] ^= q, i[32] ^= A, i[33] ^= q, i[42] ^= A, i[43] ^= q, i[4] ^= _, i[5] ^= F, i[14] ^= _, i[15] ^= F, i[24] ^= _, i[25] ^= F, i[34] ^= _, i[35] ^= F, i[44] ^= _, i[45] ^= F, i[6] ^= R, i[7] ^= V, i[16] ^= R, i[17] ^= V, i[26] ^= R, i[27] ^= V, i[36] ^= R, i[37] ^= V, i[46] ^= R, i[47] ^= V, i[8] ^= fe, i[9] ^= ue, i[18] ^= fe, i[19] ^= ue, i[28] ^= fe, i[29] ^= ue, i[38] ^= fe, i[39] ^= ue, i[48] ^= fe, i[49] ^= ue;
        const ae = i[0], D = i[1], Q = i[11] << 4 | i[10] >>> 28, Z = i[10] << 4 | i[11] >>> 28, oe = i[20] << 3 | i[21] >>> 29, y = i[21] << 3 | i[20] >>> 29, Y = i[31] << 9 | i[30] >>> 23, he = i[30] << 9 | i[31] >>> 23, be = i[40] << 18 | i[41] >>> 14, xe = i[41] << 18 | i[40] >>> 14, Ie = i[2] << 1 | i[3] >>> 31, ve = i[3] << 1 | i[2] >>> 31, C = i[13] << 12 | i[12] >>> 20, I = i[12] << 12 | i[13] >>> 20, se = i[22] << 10 | i[23] >>> 22, t = i[23] << 10 | i[22] >>> 22, l = i[33] << 13 | i[32] >>> 19, B = i[32] << 13 | i[33] >>> 19, U = i[42] << 2 | i[43] >>> 30, G = i[43] << 2 | i[42] >>> 30, T = i[5] << 30 | i[4] >>> 2, M = i[4] << 30 | i[5] >>> 2, $ = i[14] << 6 | i[15] >>> 26, r = i[15] << 6 | i[14] >>> 26, x = i[25] << 11 | i[24] >>> 21, O = i[24] << 11 | i[25] >>> 21, L = i[34] << 15 | i[35] >>> 17, X = i[35] << 15 | i[34] >>> 17, P = i[45] << 29 | i[44] >>> 3, K = i[44] << 29 | i[45] >>> 3, re = i[6] << 28 | i[7] >>> 4, ce = i[7] << 28 | i[6] >>> 4, le = i[17] << 23 | i[16] >>> 9, me = i[16] << 23 | i[17] >>> 9, ne = i[26] << 25 | i[27] >>> 7, W = i[27] << 25 | i[26] >>> 7, te = i[36] << 21 | i[37] >>> 11, pe = i[37] << 21 | i[36] >>> 11, Ee = i[47] << 24 | i[46] >>> 8, Ae = i[46] << 24 | i[47] >>> 8, Oe = i[8] << 27 | i[9] >>> 5, Be = i[9] << 27 | i[8] >>> 5, ke = i[18] << 20 | i[19] >>> 12, Ne = i[19] << 20 | i[18] >>> 12, Ke = i[29] << 7 | i[28] >>> 25, Ce = i[28] << 7 | i[29] >>> 25, Ye = i[38] << 8 | i[39] >>> 24, vt = i[39] << 8 | i[38] >>> 24, Ve = i[48] << 14 | i[49] >>> 18, Xe = i[49] << 14 | i[48] >>> 18;
        i[0] = ae ^ ~C & x, i[1] = D ^ ~I & O, i[10] = re ^ ~ke & oe, i[11] = ce ^ ~Ne & y, i[20] = Ie ^ ~$ & ne, i[21] = ve ^ ~r & W, i[30] = Oe ^ ~Q & se, i[31] = Be ^ ~Z & t, i[40] = T ^ ~le & Ke, i[41] = M ^ ~me & Ce, i[2] = C ^ ~x & te, i[3] = I ^ ~O & pe, i[12] = ke ^ ~oe & l, i[13] = Ne ^ ~y & B, i[22] = $ ^ ~ne & Ye, i[23] = r ^ ~W & vt, i[32] = Q ^ ~se & L, i[33] = Z ^ ~t & X, i[42] = le ^ ~Ke & Y, i[43] = me ^ ~Ce & he, i[4] = x ^ ~te & Ve, i[5] = O ^ ~pe & Xe, i[14] = oe ^ ~l & P, i[15] = y ^ ~B & K, i[24] = ne ^ ~Ye & be, i[25] = W ^ ~vt & xe, i[34] = se ^ ~L & Ee, i[35] = t ^ ~X & Ae, i[44] = Ke ^ ~Y & U, i[45] = Ce ^ ~he & G, i[6] = te ^ ~Ve & ae, i[7] = pe ^ ~Xe & D, i[16] = l ^ ~P & re, i[17] = B ^ ~K & ce, i[26] = Ye ^ ~be & Ie, i[27] = vt ^ ~xe & ve, i[36] = L ^ ~Ee & Oe, i[37] = X ^ ~Ae & Be, i[46] = Y ^ ~U & T, i[47] = he ^ ~G & M, i[8] = Ve ^ ~ae & C, i[9] = Xe ^ ~D & I, i[18] = P ^ ~re & ke, i[19] = K ^ ~ce & Ne, i[28] = be ^ ~Ie & $, i[29] = xe ^ ~ve & r, i[38] = Ee ^ ~Oe & Q, i[39] = Ae ^ ~Be & Z, i[48] = U ^ ~T & le, i[49] = G ^ ~M & me, i[0] ^= w[p + 0], i[1] ^= w[p + 1];
      }
    }
    static hash() {
      return new g();
    }
    static hmac(u, a, s) {
      u == null && (u = 256), e(u >>> 0 === u);
      const i = 1600 - u * 2;
      return e(i >= 0 && (i & 63) === 0), new c(g, i >>> 3, [u], [a, s]);
    }
    static digest(u, a, s, i) {
      return g.ctx.init(a).update(u).final(s, i);
    }
    static root(u, a, s, i, p) {
      return s == null && (s = 256), p == null && (p = 0), p === 0 && (p = s >>> 3), e(s >>> 0 === s), e((s & 7) === 0), e(p >>> 0 === p), e(k.isBuffer(u) && u.length === p), e(k.isBuffer(a) && a.length === p), g.ctx.init(s).update(u).update(a).final(i, p);
    }
    static multi(u, a, s, i, p, m) {
      const { ctx: E } = g;
      return E.init(i), E.update(u), E.update(a), s && E.update(s), E.final(p, m);
    }
    static mac(u, a, s, i, p) {
      return g.hmac(s, i, p).init(a).update(u).final();
    }
  }
  g.native = 0, g.id = "KECCAK256", g.size = 32, g.bits = 256, g.blockSize = 136, g.zero = k.alloc(32, 0), g.ctx = new g();
  function f(n, u) {
    return n[u++] + n[u++] * 256 + n[u++] * 65536 + n[u] * 16777216;
  }
  return pa = g, pa;
}
var kn = {};
/*!
 * murmur3.js - murmur3 hash for bcrypto
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/MurmurHash
 *   https://github.com/aappleby/smhasher
 */
var s2;
function tl() {
  if (s2) return kn;
  s2 = 1;
  const e = Bt();
  function c(n, u) {
    e(k.isBuffer(n)), e(typeof u == "number");
    const a = n.length - (n.length & 3), s = 3432918353, i = 461845907;
    let p = u | 0;
    for (let E = 0; E < a; E += 4) {
      let v = f(n, E);
      v = w(v, s), v = g(v, 15), v = w(v, i), p ^= v, p = g(p, 13), p = w(p, 5) + 3864292196 | 0;
    }
    let m = 0;
    switch (n.length & 3) {
      case 3:
        m ^= n[a + 2] << 16;
      case 2:
        m ^= n[a + 1] << 8;
      case 1:
        m ^= n[a + 0], m = w(m, s), m = g(m, 15), m = w(m, i), p ^= m;
    }
    return p ^= n.length, p ^= p >>> 16, p = w(p, 2246822507), p ^= p >>> 13, p = w(p, 3266489909), p ^= p >>> 16, p >>> 0;
  }
  function d(n, u, a) {
    e(typeof u == "number"), e(typeof a == "number");
    const s = w(u, 4221880213) + (a | 0);
    return c(n, s);
  }
  function w(n, u) {
    const a = n & 65535, s = u & 65535, i = n >>> 16, p = u >>> 16, m = a * s;
    return i * s + p * a + (m >>> 16) << 16 | m & 65535;
  }
  function g(n, u) {
    return n << u | n >>> 32 - u;
  }
  function f(n, u) {
    return n[u++] + n[u++] * 256 + n[u++] * 65536 + n[u] * 16777216;
  }
  return kn.native = 0, kn.sum = c, kn.tweak = d, kn;
}
/*!
 * p224.js - ECDSA-P224 for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var ma, o2;
function lb() {
  if (o2) return ma;
  o2 = 1;
  const e = jn(), c = cr();
  return ma = new e("P224", c, c), ma;
}
/*!
 * p256.js - ECDSA-P256 for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var ga, a2;
function db() {
  if (a2) return ga;
  a2 = 1;
  const e = jn(), c = cr();
  return ga = new e("P256", c, c), ga;
}
/*!
 * sha384.js - SHA384 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/hash.js:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/hash.js
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/SHA-2
 *   https://tools.ietf.org/html/rfc4634
 *   https://github.com/indutny/hash.js/blob/master/lib/hash/sha/384.js
 */
var xa, f2;
function rl() {
  if (f2) return xa;
  f2 = 1;
  const e = Bt(), c = Fi(), d = ri();
  class w extends c {
    constructor() {
      super();
    }
    init() {
      return this.state[0] = 3418070365, this.state[1] = 3238371032, this.state[2] = 1654270250, this.state[3] = 914150663, this.state[4] = 2438529370, this.state[5] = 812702999, this.state[6] = 355462360, this.state[7] = 4144912697, this.state[8] = 1731405415, this.state[9] = 4290775857, this.state[10] = 2394180231, this.state[11] = 1750603025, this.state[12] = 3675008525, this.state[13] = 1694076839, this.state[14] = 1203062813, this.state[15] = 3204075428, this.size = 0, this;
    }
    final() {
      return super.final().slice(0, 48);
    }
    static hash() {
      return new w();
    }
    static hmac() {
      return new d(w, 128);
    }
    static digest(f) {
      return w.ctx.init().update(f).final();
    }
    static root(f, n) {
      return e(k.isBuffer(f) && f.length === 48), e(k.isBuffer(n) && n.length === 48), w.ctx.init().update(f).update(n).final();
    }
    static multi(f, n, u) {
      const { ctx: a } = w;
      return a.init(), a.update(f), a.update(n), u && a.update(u), a.final();
    }
    static mac(f, n) {
      return w.hmac().init(n).update(f).final();
    }
  }
  return w.native = 0, w.id = "SHA384", w.size = 48, w.bits = 384, w.blockSize = 128, w.zero = k.alloc(48, 0), w.ctx = new w(), xa = w, xa;
}
/*!
 * p384.js - ECDSA-P384 for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var wa, c2;
function bb() {
  if (c2) return wa;
  c2 = 1;
  const e = jn(), c = rl();
  return wa = new e("P384", c, c), wa;
}
/*!
 * shake.js - SHAKE implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/SHA-3
 *   https://keccak.team/specifications.html
 *   https://csrc.nist.gov/projects/hash-functions/sha-3-project/sha-3-standardization
 *   http://dx.doi.org/10.6028/NIST.FIPS.202
 */
var ya, u2;
function pb() {
  if (u2) return ya;
  u2 = 1;
  const e = hb();
  class c extends e {
    /**
     * Create a SHAKE Context.
     * @constructor
     */
    constructor() {
      super();
    }
    final(w) {
      return super.final(31, w);
    }
    static hash() {
      return new c();
    }
    static hmac(w, g) {
      return super.hmac(w, 31, g);
    }
    static digest(w, g, f) {
      return super.digest(w, g, 31, f);
    }
    static root(w, g, f, n) {
      return super.root(w, g, f, 31, n);
    }
    static multi(w, g, f, n, u) {
      return super.multi(w, g, f, n, 31, u);
    }
    static mac(w, g, f, n) {
      return super.mac(w, g, f, 31, n);
    }
  }
  return c.native = e.native, c.id = "SHAKE256", c.size = 32, c.bits = 256, c.blockSize = 136, c.zero = k.alloc(32, 0), c.ctx = new c(), ya = c, ya;
}
/*!
 * shake256.js - SHAKE256 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var va, h2;
function mb() {
  if (h2) return va;
  h2 = 1;
  const e = pb();
  class c extends e {
    constructor() {
      super();
    }
    init() {
      return super.init(256);
    }
    static hash() {
      return new c();
    }
    static hmac(w) {
      return super.hmac(256, w);
    }
    static digest(w, g) {
      return super.digest(w, 256, g);
    }
    static root(w, g, f) {
      return super.root(w, g, 256, f);
    }
    static multi(w, g, f, n) {
      return super.multi(w, g, f, 256, n);
    }
    static mac(w, g, f) {
      return super.mac(w, g, 256, f);
    }
  }
  return c.native = e.native, c.id = "SHAKE256", c.size = 32, c.bits = 256, c.blockSize = 136, c.zero = k.alloc(32, 0), c.ctx = new c(), va = c, va;
}
/*!
 * p521.js - ECDSA-P521 for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var Sa, l2;
function gb() {
  if (l2) return Sa;
  l2 = 1;
  const e = jn(), c = Fi(), d = mb();
  return Sa = new e("P521", c, d), Sa;
}
var zt = {}, Bn = {};
/*!
 * primes.js - Prime number generation for javascript
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on golang/go:
 *   Copyright (c) 2009, The Go Authors. All rights reserved.
 *   https://github.com/golang/go
 *
 * Parts of this software are based on indutny/miller-rabin:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/miller-rabin
 *
 * Resources:
 *   https://github.com/golang/go/blob/master/src/crypto/rsa/rsa.go
 *   https://github.com/golang/go/blob/master/src/math/big/prime.go
 *   https://github.com/golang/go/blob/master/src/math/big/int.go
 *   https://github.com/golang/go/blob/master/src/math/big/nat.go
 *   https://github.com/golang/go/blob/master/src/crypto/rand/util.go
 *   https://github.com/indutny/miller-rabin/blob/master/lib/mr.js
 */
var d2;
function y9() {
  if (d2) return Bn;
  d2 = 1;
  const e = Bt(), c = Ur(), d = Ti(), w = new Uint8Array([
    3,
    5,
    7,
    11,
    13,
    17,
    19,
    23,
    29,
    31,
    37,
    41,
    43,
    47,
    53
  ]), g = new c("16294579238595022365", 10), f = 10412 | 1 << 17 | 1 << 19 | 1 << 23 | 1 << 29 | 1 << 31, n = 35360 | 1 << 21 | 1 << 27 | 1 << 29, u = new c(1155 * 13 * 17 * 19 * 23 * 37), a = new c(899 * 41 * 43 * 47 * 53);
  function s(m, E = 20, v = d) {
    if (e(m >>> 0 === m), e(E >>> 0 === E), e(v != null), m < 2)
      throw new Error("Prime must be at least 2 bits.");
    for (; ; ) {
      const b = c.randomBits(v, m);
      b.setn(m - 1, 1), b.setn(m - 2, 1), b.setn(0, 1);
      const h = b.mod(g);
      e:
        for (let o = 0; o < 1 << 20; o += 2) {
          const S = h.addn(o);
          for (let H = 0; H < w.length; H++) {
            const j = w[H];
            if (S.modrn(j) === 0 && (m > 6 || S.cmpn(j) !== 0))
              continue e;
          }
          b.iaddn(o);
          break;
        }
      if (b.bitLength() === m && i(b, E, v))
        return b;
    }
  }
  function i(m, E, v = d) {
    if (e(m instanceof c), m.sign() <= 0)
      return !1;
    if (m.cmpn(64) < 0) {
      const o = m.word(0);
      return o > 31 ? (n & 1 << o - 32) !== 0 : (f & 1 << o) !== 0;
    }
    if (m.isEven())
      return !1;
    const b = m.mod(u).toNumber(), h = m.mod(a).toNumber();
    return b % 3 === 0 || b % 5 === 0 || b % 7 === 0 || b % 11 === 0 || b % 13 === 0 || b % 17 === 0 || b % 19 === 0 || b % 23 === 0 || b % 37 === 0 || h % 29 === 0 || h % 31 === 0 || h % 41 === 0 || h % 43 === 0 || h % 47 === 0 || h % 53 === 0 ? !1 : m.isPrime(v, E);
  }
  function p(m, E, v) {
    if (!i(m, E, v))
      return !1;
    const b = m.subn(1).iushrn(1);
    return !!i(b, E, v);
  }
  return Bn.randomPrime = s, Bn.isProbablePrime = i, Bn.isSafePrime = p, Bn;
}
var Jr = {};
/*!
 * base64.js - base64 for javascript
 * Copyright (c) 2019-2020, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://tools.ietf.org/html/rfc4648
 */
var b2;
function v9() {
  if (b2) return Jr;
  b2 = 1;
  const e = Bt(), c = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", d = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", w = [
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    62,
    -1,
    -1,
    -1,
    63,
    52,
    53,
    54,
    55,
    56,
    57,
    58,
    59,
    60,
    61,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    16,
    17,
    18,
    19,
    20,
    21,
    22,
    23,
    24,
    25,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    26,
    27,
    28,
    29,
    30,
    31,
    32,
    33,
    34,
    35,
    36,
    37,
    38,
    39,
    40,
    41,
    42,
    43,
    44,
    45,
    46,
    47,
    48,
    49,
    50,
    51,
    -1,
    -1,
    -1,
    -1,
    -1
  ], g = [
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    62,
    -1,
    -1,
    52,
    53,
    54,
    55,
    56,
    57,
    58,
    59,
    60,
    61,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    16,
    17,
    18,
    19,
    20,
    21,
    22,
    23,
    24,
    25,
    -1,
    -1,
    -1,
    -1,
    63,
    -1,
    26,
    27,
    28,
    29,
    30,
    31,
    32,
    33,
    34,
    35,
    36,
    37,
    38,
    39,
    40,
    41,
    42,
    43,
    44,
    45,
    46,
    47,
    48,
    49,
    50,
    51,
    -1,
    -1,
    -1,
    -1,
    -1
  ];
  function f(h, o, S) {
    e(k.isBuffer(h));
    let H = h.length, j = "", J = 0;
    for (; H >= 3; ) {
      const N = h[J++], z = h[J++], A = h[J++];
      j += o[N >> 2], j += o[(N & 3) << 4 | z >> 4], j += o[(z & 15) << 2 | A >> 6], j += o[A & 63], H -= 3;
    }
    switch (H) {
      case 1: {
        const N = h[J++];
        j += o[N >> 2], j += o[(N & 3) << 4], S && (j += "==");
        break;
      }
      case 2: {
        const N = h[J++], z = h[J++];
        j += o[N >> 2], j += o[(N & 3) << 4 | z >> 4], j += o[(z & 15) << 2], S && (j += "=");
        break;
      }
    }
    return j;
  }
  function n(h, o, S) {
    e(typeof h == "string");
    const H = k.alloc(S);
    let j = h.length, J = 0, N = 0;
    if (j > 0 && h[j - 1] === "=" && (j -= 1), j > 0 && h[j - 1] === "=" && (j -= 1), (j & 3) === 1)
      throw new Error("Invalid base64 string.");
    for (; j >= 4; ) {
      const z = h.charCodeAt(J++), A = h.charCodeAt(J++), q = h.charCodeAt(J++), _ = h.charCodeAt(J++);
      if ((z | A | q | _) & 65408)
        throw new Error("Invalid base64 string.");
      const F = o[z], R = o[A], V = o[q], fe = o[_];
      if ((F | R | V | fe) < 0)
        throw new Error("Invalid base64 string.");
      H[N++] = F << 2 | R >> 4, H[N++] = R << 4 | V >> 2, H[N++] = V << 6 | fe >> 0, j -= 4;
    }
    switch (j) {
      case 1:
        throw new Error("Invalid base64 string.");
      case 2: {
        const z = h.charCodeAt(J++), A = h.charCodeAt(J++);
        if ((z | A) & 65408)
          throw new Error("Invalid base64 string.");
        const q = o[z], _ = o[A];
        if ((q | _) < 0)
          throw new Error("Invalid base64 string.");
        if (H[N++] = q << 2 | _ >> 4, _ & 15)
          throw new Error("Invalid base64 string.");
        break;
      }
      case 3: {
        const z = h.charCodeAt(J++), A = h.charCodeAt(J++), q = h.charCodeAt(J++);
        if ((z | A | q) & 65408)
          throw new Error("Invalid base64 string.");
        const _ = o[z], F = o[A], R = o[q];
        if ((_ | F | R) < 0)
          throw new Error("Invalid base64 string.");
        if (H[N++] = _ << 2 | F >> 4, H[N++] = F << 4 | R >> 2, R & 3)
          throw new Error("Invalid base64 string.");
        break;
      }
    }
    return e(N === S), H;
  }
  function u(h, o) {
    e(typeof h == "string");
    let S = h.length;
    if (S > 0 && h[S - 1] === "=" && (S -= 1), S > 0 && h[S - 1] === "=" && (S -= 1), (S & 3) === 1)
      return !1;
    for (let H = 0; H < S; H++) {
      const j = h.charCodeAt(H);
      if (j & 65408 || o[j] === -1)
        return !1;
    }
    switch (S & 3) {
      case 1:
        return !1;
      case 2:
        return (o[h.charCodeAt(S - 1)] & 15) === 0;
      case 3:
        return (o[h.charCodeAt(S - 1)] & 3) === 0;
    }
    return !0;
  }
  function a(h) {
    return f(h, c, !0);
  }
  function s(h) {
    const o = v(h);
    if (!b(h, o))
      throw new Error("Invalid base64 padding.");
    return n(h, w, o);
  }
  function i(h) {
    const o = v(h);
    return b(h, o) ? u(h, w) : !1;
  }
  function p(h) {
    return f(h, d, !1);
  }
  function m(h) {
    const o = v(h);
    if (!b(h, 0))
      throw new Error("Invalid base64 padding.");
    return n(h, g, o);
  }
  function E(h) {
    return b(h, 0) ? u(h, g) : !1;
  }
  function v(h) {
    e(typeof h == "string");
    let o = h.length;
    o > 0 && h[o - 1] === "=" && (o -= 1), o > 0 && h[o - 1] === "=" && (o -= 1);
    let S = (o >>> 2) * 3;
    const H = o & 3;
    return H && (S += H - 1), S;
  }
  function b(h, o) {
    switch (e(typeof h == "string"), o % 3) {
      case 0:
        return h.length === 0 ? !0 : h.length === 1 ? h[0] !== "=" : h[h.length - 2] !== "=" && h[h.length - 1] !== "=";
      case 1:
        return h.length >= 4 && h[h.length - 2] === "=" && h[h.length - 1] === "=";
      case 2:
        return h.length >= 4 && h[h.length - 2] !== "=" && h[h.length - 1] === "=";
      default:
        throw new Error("unreachable");
    }
  }
  return Jr.native = 0, Jr.encode = a, Jr.decode = s, Jr.test = i, Jr.encodeURL = p, Jr.decodeURL = m, Jr.testURL = E, Jr;
}
var Gt = {};
/*!
 * safe.js - constant-time equals for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on golang/go:
 *   Copyright (c) 2009 The Go Authors. All rights reserved.
 *   https://github.com/golang/go
 *
 * Resources:
 *   https://github.com/golang/go/blob/master/src/crypto/subtle/constant_time.go
 */
var p2;
function xb() {
  if (p2) return Gt;
  p2 = 1;
  const e = Bt();
  function c(b, h) {
    if (e(k.isBuffer(b)), e(k.isBuffer(h)), g(b.length, 0))
      return g(h.length, 0);
    let o = b.length ^ h.length;
    for (let S = 0; S < h.length; S++)
      o |= b[S % b.length] ^ h[S];
    return o - 1 >>> 31;
  }
  function d(b, h) {
    if (e(k.isBuffer(b)), e(k.isBuffer(h)), !g(b.length, h.length))
      return 0;
    let o = 0;
    for (let S = 0; S < b.length; S++)
      o |= b[S] ^ h[S];
    return o - 1 >>> 31;
  }
  function w(b, h) {
    return g(b & 255, h & 255);
  }
  function g(b, h) {
    return (b ^ h) - 1 >>> 31;
  }
  function f(b, h, o) {
    return b & o - 1 | h & ~(o - 1);
  }
  function n(b, h) {
    return b - h >>> 31;
  }
  function u(b, h) {
    return b - h - 1 >>> 31;
  }
  function a(b, h) {
    return h - b >>> 31;
  }
  function s(b, h) {
    return h - b - 1 >>> 31;
  }
  function i(b, h) {
    return f(b, h, n(h, b));
  }
  function p(b, h) {
    return f(b, h, a(h, b));
  }
  function m(b) {
    return (b | 0) * (b >> 31 | 1);
  }
  function E(b) {
    return (b >> 31 | -b >> 31) & 1;
  }
  function v(b, h, o) {
    e(k.isBuffer(b)), e(k.isBuffer(h)), e(g(b.length, h.length));
    const S = o - 1 & 255, H = ~(o - 1) & 255;
    for (let j = 0; j < b.length; j++)
      b[j] = b[j] & S | h[j] & H;
  }
  return Gt.safeCompare = c, Gt.safeEqual = d, Gt.safeEqualByte = w, Gt.safeEqualInt = g, Gt.safeSelect = f, Gt.safeLT = n, Gt.safeLTE = u, Gt.safeGT = a, Gt.safeGTE = s, Gt.safeMin = i, Gt.safeMax = p, Gt.safeAbs = m, Gt.safeBool = E, Gt.safeCopy = v, Gt;
}
/*!
 * rsa.js - RSA for javascript
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on golang/go:
 *   Copyright (c) 2009 The Go Authors. All rights reserved.
 *   https://github.com/golang/go
 *
 * Parts of this software are based on indutny/miller-rabin:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/miller-rabin
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/RSA_(cryptosystem)
 *   https://tools.ietf.org/html/rfc3447
 *   https://tools.ietf.org/html/rfc8017
 *   https://github.com/openssl/openssl/blob/master/crypto/rsa/rsa_ossl.c
 *   https://github.com/openssl/openssl/blob/master/crypto/rsa/rsa_sign.c
 *   https://github.com/openssl/openssl/blob/master/crypto/rsa/rsa_oaep.c
 *   https://github.com/openssl/openssl/blob/master/crypto/rsa/rsa_pss.c
 *   https://github.com/openssl/openssl/blob/master/crypto/rsa/rsa_pk1.c
 *   https://github.com/golang/go/blob/master/src/crypto/rsa/rsa.go
 *   https://github.com/golang/go/blob/master/src/crypto/rsa/pkcs1v15.go
 *   https://github.com/golang/go/blob/master/src/crypto/rsa/pss.go
 *   https://github.com/golang/go/blob/master/src/crypto/subtle/constant_time.go
 *   https://github.com/ARMmbed/mbed-crypto/blob/master/library/rsa.c
 *
 * References:
 *
 *   [RFC8017] PKCS #1: RSA Cryptography Specifications Version 2.2
 *     K. Moriarty, B. Kaliski, J. Jonsson, A. Rusch
 *     https://tools.ietf.org/html/rfc8017
 *
 *   [FIPS186] Federal Information Processing Standards Publication 186-4
 *     National Institute of Standards and Technology
 *     https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf
 */
var m2;
function wb() {
  if (m2) return zt;
  m2 = 1;
  const e = Bt(), c = Ur(), d = Ti(), { randomPrime: w } = y9(), g = v9(), f = W8(), n = xb(), {
    safeEqual: u,
    safeEqualByte: a,
    safeSelect: s,
    safeLTE: i
  } = n, p = 2048, m = 65537, E = 512, v = 16384, b = 3, h = 2 ** 33 - 1, o = 33, S = 0, H = -1, j = k.alloc(8, 0), J = k.alloc(0), N = {
    __proto__: null,
    BLAKE2B160: k.from("3027300f060b2b060104018d3a0c02010505000414", "hex"),
    BLAKE2B256: k.from("3033300f060b2b060104018d3a0c02010805000420", "hex"),
    BLAKE2B384: k.from("3043300f060b2b060104018d3a0c02010c05000430", "hex"),
    BLAKE2B512: k.from("3053300f060b2b060104018d3a0c02011005000440", "hex"),
    BLAKE2S128: k.from("3023300f060b2b060104018d3a0c02020405000410", "hex"),
    BLAKE2S160: k.from("3027300f060b2b060104018d3a0c02020505000414", "hex"),
    BLAKE2S224: k.from("302f300f060b2b060104018d3a0c0202070500041c", "hex"),
    BLAKE2S256: k.from("3033300f060b2b060104018d3a0c02020805000420", "hex"),
    GOST94: k.from("302e300a06062a850302021405000420", "hex"),
    HASH160: k.from([20]),
    HASH256: k.from([32]),
    KECCAK224: k.from([28]),
    KECCAK256: k.from([32]),
    KECCAK384: k.from([48]),
    KECCAK512: k.from([64]),
    MD2: k.from("3020300c06082a864886f70d020205000410", "hex"),
    MD4: k.from("3020300c06082a864886f70d020405000410", "hex"),
    MD5: k.from("3020300c06082a864886f70d020505000410", "hex"),
    MD5SHA1: k.from([36]),
    RIPEMD160: k.from("3021300906052b2403020105000414", "hex"),
    SHA1: k.from("3021300906052b0e03021a05000414", "hex"),
    SHA224: k.from("302d300d06096086480165030402040500041c", "hex"),
    SHA256: k.from("3031300d060960864801650304020105000420", "hex"),
    SHA384: k.from("3041300d060960864801650304020205000430", "hex"),
    SHA512: k.from("3051300d060960864801650304020305000440", "hex"),
    SHA3_224: k.from("302d300d06096086480165030402070500041c", "hex"),
    SHA3_256: k.from("3031300d060960864801650304020805000420", "hex"),
    SHA3_384: k.from("3041300d060960864801650304020905000430", "hex"),
    SHA3_512: k.from("3051300d060960864801650304020a05000440", "hex"),
    SHAKE128: k.from("3021300d060960864801650304020b05000410", "hex"),
    SHAKE256: k.from("3031300d060960864801650304020c05000420", "hex"),
    WHIRLPOOL: k.from("304e300a060628cf0603003705000440", "hex")
  };
  class z {
    constructor() {
      this.n = new c(0), this.e = new c(0);
    }
    bits() {
      return this.n.bitLength();
    }
    size() {
      return this.n.byteLength();
    }
    isSane() {
      return this.n.sign() > 0 && this.e.sign() > 0 && this.n.bitLength() <= v && this.e.bitLength() <= o;
    }
    verify() {
      return !(!this.isSane() || this.n.bitLength() < E || !this.n.isOdd() || this.e.cmpn(b) < 0 || !this.e.isOdd());
    }
    encrypt(M) {
      e(k.isBuffer(M));
      const { n: $, e: r } = this, x = c.decode(M);
      if (x.cmp($) >= 0)
        throw new Error("Invalid RSA message size.");
      return x.powm(r, $).encode("be", $.byteLength());
    }
    encode() {
      const M = f.sizeInt(this.n) + f.sizeInt(this.e), $ = k.alloc(f.sizeSeq(M));
      let r = 0;
      return r = f.writeSeq($, r, M), r = f.writeInt($, r, this.n), r = f.writeInt($, r, this.e), e(r === $.length), $;
    }
    decode(M) {
      let $ = 0;
      if ($ = f.readSeq(M, $), [this.n, $] = f.readInt(M, $), [this.e, $] = f.readInt(M, $), $ !== M.length)
        throw new Error("Trailing bytes.");
      return this;
    }
    static decode(M) {
      return new z().decode(M);
    }
  }
  class A extends z {
    constructor() {
      super(), this.d = new c(0), this.p = new c(0), this.q = new c(0), this.dp = new c(0), this.dq = new c(0), this.qi = new c(0);
    }
    isSane() {
      return this.n.sign() > 0 && this.e.sign() > 0 && this.d.sign() > 0 && this.p.sign() > 0 && this.q.sign() > 0 && this.dp.sign() > 0 && this.dq.sign() > 0 && this.qi.sign() > 0 && this.n.bitLength() <= v && this.e.bitLength() <= o && this.d.bitLength() <= v && this.p.bitLength() <= v && this.q.bitLength() <= v && this.dp.bitLength() <= v && this.dq.bitLength() <= v && this.qi.bitLength() <= v;
    }
    verify() {
      if (!this.isSane() || this.n.bitLength() < E || !this.n.isOdd() || this.e.cmpn(b) < 0 || !this.e.isOdd() || this.p.cmpn(3) < 0 || !this.p.isOdd() || this.q.cmpn(3) < 0 || !this.q.isOdd())
        return !1;
      const M = this.p.subn(1), $ = this.q.subn(1), r = M.mul($);
      if (this.d.cmpn(2) < 0 || this.d.cmp(r) >= 0 || this.dp.sign() === 0 || this.dp.cmp(M) >= 0 || this.dq.sign() === 0 || this.dq.cmp($) >= 0 || this.qi.cmpn(2) < 0 || this.qi.cmp(this.p) >= 0 || this.p.cmp(this.q) === 0 || this.p.mul(this.q).cmp(this.n) !== 0)
        return !1;
      const x = r.div(M.gcd($));
      return !(this.e.mul(this.d).imod(x).cmpn(1) !== 0 || this.d.mod(M).cmp(this.dp) !== 0 || this.d.mod($).cmp(this.dq) !== 0 || this.q.mul(this.qi).imod(this.p).cmpn(1) !== 0);
    }
    decrypt(M) {
      e(k.isBuffer(M));
      const { n: $, e: r, p: x, q: O, dp: L, dq: X, qi: P } = this, K = c.decode(M);
      if (K.cmp($) >= 0)
        throw new Error("Invalid RSA message size.");
      let re, ce;
      for (; ; ) {
        const te = c.random(d, 1, $);
        try {
          ce = te.invert($);
        } catch {
          continue;
        }
        re = te.powm(r, $);
        break;
      }
      K.imul(re).imod($);
      const le = K.powm(L, x, !0), me = K.powm(X, O, !0), W = le.sub(me).mul(P).imod(x).mul(O).iadd(me).imod($);
      if (W.powm(r, $).cmp(K) !== 0)
        throw new Error("Invalid RSA private key.");
      return W.imul(ce).imod($), W.encode("be", $.byteLength());
    }
    generate(M, $) {
      e(M >>> 0 === M), e(Number.isSafeInteger($) && $ >= 0), e(M >= 64), e($ >= 3 && ($ & 1) !== 0);
      const r = new c($);
      for (; ; ) {
        const x = w((M >>> 1) + (M & 1)), O = w(M >>> 1);
        if (x.cmp(O) === 0 || (x.cmp(O) < 0 && x.swap(O), x.sub(O).bitLength() <= (M >>> 1) - 99))
          continue;
        const L = x.mul(O);
        if (L.bitLength() !== M)
          continue;
        const X = x.subn(1), P = O.subn(1), K = X.mul(P);
        if (r.gcd(K).cmpn(1) !== 0)
          continue;
        const re = K.div(X.gcd(P)), ce = r.invert(re);
        if (ce.bitLength() <= M + 1 >>> 1)
          continue;
        const le = ce.mod(X), me = ce.mod(P), ne = O.invert(x);
        return this.n = L, this.e = r, this.d = ce, this.p = x, this.q = O, this.dp = le, this.dq = me, this.qi = ne, this;
      }
    }
    async _generateSubtle(M, $) {
      e(M >>> 0 === M), e(Number.isSafeInteger($) && $ >= 0), e(M >= 64), e($ >= 3 && ($ & 1) !== 0);
      const r = sn.crypto || sn.msCrypto;
      if (!r)
        throw new Error("Crypto API not available.");
      const { subtle: x } = r;
      if (!x || !x.generateKey || !x.exportKey)
        throw new Error("Subtle API not available.");
      const O = new c($), L = {
        name: "RSASSA-PKCS1-v1_5",
        modulusLength: M,
        publicExponent: O.toArrayLike(Uint8Array, "be", 8),
        hash: { name: "SHA-256" }
      }, X = await x.generateKey(L, !0, ["sign"]), P = await x.exportKey("jwk", X.privateKey), K = c.decode(g.decodeURL(P.p)), re = c.decode(g.decodeURL(P.q));
      return this.fromPQE(K, re, O);
    }
    async generateAsync(M, $) {
      try {
        return await this._generateSubtle(M, $);
      } catch {
        return this.generate(M, $);
      }
    }
    fromPQE(M, $, r) {
      if (e(M instanceof c), e($ instanceof c), e(r instanceof c), M.cmp($) < 0 && ([M, $] = [$, M]), M.cmp($) === 0)
        throw new Error("Invalid RSA private key.");
      if (M.cmpn(3) < 0 || M.bitLength() > v)
        throw new Error("Invalid RSA private key.");
      if ($.cmpn(3) < 0 || $.bitLength() > v)
        throw new Error("Invalid RSA private key.");
      if (r.cmpn(b) < 0 || r.bitLength() > o)
        throw new Error("Invalid RSA private key.");
      if (!M.isOdd() || !$.isOdd() || !r.isOdd())
        throw new Error("Invalid RSA private key.");
      const x = M.mul($);
      if (e(x.isOdd()), x.bitLength() < E || x.bitLength() > v)
        throw new Error("Invalid RSA private key.");
      const O = M.subn(1), L = $.subn(1), X = O.lcm(L), P = r.invert(X), K = P.mod(O), re = P.mod(L), ce = $.invert(M);
      return this.n = x, this.e = r, this.d = P, this.p = M, this.q = $, this.dp = K, this.dq = re, this.qi = ce, this;
    }
    fromPQD(M, $, r) {
      if (e(M instanceof c), e($ instanceof c), e(r instanceof c), M.cmpn(3) < 0 || M.bitLength() > v)
        throw new Error("Invalid RSA private key.");
      if ($.cmpn(3) < 0 || $.bitLength() > v)
        throw new Error("Invalid RSA private key.");
      if (!M.isOdd() || !$.isOdd())
        throw new Error("Invalid RSA private key.");
      const x = M.subn(1), O = $.subn(1), L = x.mul(O);
      if (r.cmpn(2) < 0 || r.cmp(L) >= 0)
        throw new Error("Invalid RSA private key.");
      const X = L.div(x.gcd(O)), P = r.invert(X);
      return this.fromPQE(M, $, P);
    }
    fromNED(M, $, r) {
      if (e(M instanceof c), e($ instanceof c), e(r instanceof c), M.sign() < 0)
        throw new Error("Invalid RSA private key.");
      if (M.bitLength() < E || M.bitLength() > v)
        throw new Error("Invalid RSA private key.");
      if ($.cmpn(b) < 0 || $.bitLength() > o)
        throw new Error("Invalid RSA private key.");
      if (r.cmpn(2) < 0 || r.bitLength() > v)
        throw new Error("Invalid RSA private key.");
      if (!M.isOdd() || !$.isOdd())
        throw new Error("Invalid RSA private key.");
      const x = $.mul(r).isubn(1), O = M.subn(1), L = x.zeroBits(), X = x.ushrn(L);
      for (let P = 0; P < 64; P++) {
        let re = c.random(d, 2, O).powm(X, M);
        if (!(re.cmpn(1) === 0 || re.cmp(O) === 0))
          for (let ce = 1; ce < L; ce++) {
            const le = re.sqr().imod(M);
            if (le.cmpn(1) === 0) {
              const me = M.gcd(re.subn(1)), ne = M.gcd(re.addn(1));
              return this.fromPQE(me, ne, $);
            }
            if (le.cmp(O) === 0)
              break;
            re = le;
          }
      }
      throw new Error("Invalid RSA private key.");
    }
    toPublic() {
      const M = new z();
      return M.n = this.n, M.e = this.e, M;
    }
    encode() {
      let M = 0;
      M += f.sizeVersion(0), M += f.sizeInt(this.n), M += f.sizeInt(this.e), M += f.sizeInt(this.d), M += f.sizeInt(this.p), M += f.sizeInt(this.q), M += f.sizeInt(this.dp), M += f.sizeInt(this.dq), M += f.sizeInt(this.qi);
      const $ = k.alloc(f.sizeSeq(M));
      let r = 0;
      return r = f.writeSeq($, r, M), r = f.writeVersion($, r, 0), r = f.writeInt($, r, this.n), r = f.writeInt($, r, this.e), r = f.writeInt($, r, this.d), r = f.writeInt($, r, this.p), r = f.writeInt($, r, this.q), r = f.writeInt($, r, this.dp), r = f.writeInt($, r, this.dq), r = f.writeInt($, r, this.qi), e(r === $.length), $;
    }
    decode(M) {
      let $ = 0;
      if ($ = f.readSeq(M, $), $ = f.readVersion(M, $, 0), [this.n, $] = f.readInt(M, $), [this.e, $] = f.readInt(M, $), [this.d, $] = f.readInt(M, $), [this.p, $] = f.readInt(M, $), [this.q, $] = f.readInt(M, $), [this.dp, $] = f.readInt(M, $), [this.dq, $] = f.readInt(M, $), [this.qi, $] = f.readInt(M, $), $ !== M.length)
        throw new Error("Trailing bytes.");
      return this;
    }
    static generate(M, $) {
      return new A().generate(M, $);
    }
    static async generateAsync(M, $) {
      return new A().generateAsync(M, $);
    }
    static fromPQE(M, $, r) {
      return new A().fromPQE(M, $, r);
    }
    static fromPQD(M, $, r) {
      return new A().fromPQD(M, $, r);
    }
    static fromNED(M, $, r) {
      return new A().fromNED(M, $, r);
    }
    static decode(M) {
      return new A().decode(M);
    }
  }
  function q(T, M) {
    if (T == null && (T = p), M == null && (M = m), e(T >>> 0 === T), e(Number.isSafeInteger(M) && M >= 0), T < E || T > v)
      throw new RangeError(`"bits" ranges from ${E} to ${v}.`);
    if (M < b || M > h)
      throw new RangeError(`"exponent" ranges from ${b} to ${h}.`);
    if (M === 1 || (M & 1) === 0)
      throw new RangeError('"exponent" must be odd.');
    return A.generate(T, M).encode();
  }
  async function _(T, M) {
    if (T == null && (T = p), M == null && (M = m), e(T >>> 0 === T), e(Number.isSafeInteger(M) && M >= 0), T < E || T > v)
      throw new RangeError(`"bits" ranges from ${E} to ${v}.`);
    if (M < b || M > h)
      throw new RangeError(`"exponent" ranges from ${b} to ${h}.`);
    if (M === 1 || (M & 1) === 0)
      throw new RangeError('"exponent" must be odd.');
    return (await A.generateAsync(T, M)).encode();
  }
  function F(T) {
    const M = A.decode(T);
    if (!M.verify())
      throw new Error("Invalid RSA private key.");
    return M.bits();
  }
  function R(T) {
    e(k.isBuffer(T));
    let M;
    try {
      M = A.decode(T);
    } catch {
      return !1;
    }
    return M.verify();
  }
  function V(T) {
    e(T && typeof T == "object");
    let M = new A();
    return T.n != null && (M.n = c.decode(T.n)), T.e != null && (M.e = c.decode(T.e)), T.d != null && (M.d = c.decode(T.d)), T.p != null && (M.p = c.decode(T.p)), T.q != null && (M.q = c.decode(T.q)), T.dp != null && (M.dp = c.decode(T.dp)), T.dq != null && (M.dq = c.decode(T.dq)), T.qi != null && (M.qi = c.decode(T.qi)), M.verify() || (!M.p.isZero() && !M.q.isZero() ? M.e.isZero() ? M = A.fromPQD(M.p, M.q, M.d) : M = A.fromPQE(M.p, M.q, M.e) : M = A.fromNED(M.n, M.e, M.d)), M.encode();
  }
  function fe(T) {
    const M = A.decode(T);
    if (!M.verify())
      throw new Error("Invalid RSA private key.");
    return {
      n: M.n.encode(),
      e: M.e.encode(),
      d: M.d.encode(),
      p: M.p.encode(),
      q: M.q.encode(),
      dp: M.dp.encode(),
      dq: M.dq.encode(),
      qi: M.qi.encode()
    };
  }
  function ue(T) {
    const M = A.decode(T);
    if (!M.verify())
      throw new Error("Invalid RSA private key.");
    return M.toPublic().encode();
  }
  function ae(T) {
    const M = z.decode(T);
    if (!M.verify())
      throw new Error("Invalid RSA public key.");
    return M.bits();
  }
  function D(T) {
    e(k.isBuffer(T));
    let M;
    try {
      M = z.decode(T);
    } catch {
      return !1;
    }
    return M.verify();
  }
  function Q(T) {
    e(T && typeof T == "object");
    const M = new z();
    if (T.n != null && (M.n = c.decode(T.n)), T.e != null && (M.e = c.decode(T.e)), !M.verify())
      throw new Error("Invalid RSA public key.");
    return M.encode();
  }
  function Z(T) {
    const M = z.decode(T);
    if (!M.verify())
      throw new Error("Invalid RSA public key.");
    return {
      n: M.n.encode(),
      e: M.e.encode()
    };
  }
  function oe(T, M, $) {
    T && typeof T.id == "string" && (T = T.id), e(T == null || typeof T == "string"), e(k.isBuffer(M));
    const [r, x] = l(T, M);
    if (!r)
      throw new Error("Unknown RSA hash function.");
    if (M.length !== x)
      throw new Error("Invalid RSA message size.");
    const O = A.decode($);
    if (!O.verify())
      throw new Error("Invalid RSA private key.");
    const L = r.length + x, X = O.size();
    if (X < L + 11)
      throw new Error("Invalid RSA message size.");
    const P = k.alloc(X);
    P[0] = 0, P[1] = 1;
    for (let K = 2; K < X - L - 1; K++)
      P[K] = 255;
    return P[X - L - 1] = 0, r.copy(P, X - L), M.copy(P, X - x), O.decrypt(P);
  }
  function y(T, M, $, r) {
    T && typeof T.id == "string" && (T = T.id), e(T == null || typeof T == "string"), e(k.isBuffer(M)), e(k.isBuffer($)), e(k.isBuffer(r));
    try {
      return Y(T, M, $, r);
    } catch {
      return !1;
    }
  }
  function Y(T, M, $, r) {
    const [x, O] = l(T, M);
    if (!x || M.length !== O)
      return !1;
    const L = z.decode(r);
    if (!L.verify())
      return !1;
    const X = L.size();
    if ($.length !== X)
      return !1;
    const P = x.length + O;
    if (X < P + 11)
      return !1;
    const K = L.encrypt($);
    let re = 1;
    re &= a(K[0], 0), re &= a(K[1], 1);
    for (let ce = 2; ce < X - P - 1; ce++)
      re &= a(K[ce], 255);
    return re &= a(K[X - P - 1], 0), re &= u(K.slice(X - P, X - O), x), re &= u(K.slice(X - O, X), M), re === 1;
  }
  function he(T, M) {
    e(k.isBuffer(T));
    const $ = z.decode(M);
    if (!$.verify())
      throw new Error("Invalid RSA public key.");
    const r = $.size();
    if (T.length > r - 11)
      throw new Error("Invalid RSA message size.");
    const x = k.alloc(r), O = T.length, L = r - O - 3;
    x[0] = 0, x[1] = 2, d.randomFill(x, 2, L);
    for (let X = 2; X < 2 + L; X++)
      for (; x[X] === 0; )
        d.randomFill(x, X, 1);
    return x[r - O - 1] = 0, T.copy(x, r - O), $.encrypt(x);
  }
  function be(T, M) {
    e(k.isBuffer(T));
    const $ = A.decode(M);
    if (!$.verify())
      throw new Error("Invalid RSA private key.");
    const r = $.size();
    if (r < 11)
      throw new Error("Invalid RSA private key.");
    if (T.length !== r)
      throw new Error("Invalid RSA message size.");
    const x = $.decrypt(T), O = a(x[0], 0), L = a(x[1], 2);
    let X = 0, P = 1;
    for (let le = 2; le < x.length; le++) {
      const me = a(x[le], 0);
      X = s(X, le, P & me), P = s(P, 0, me);
    }
    const K = i(10, X), re = O & L & (P ^ 1) & K, ce = s(0, X + 1, re);
    if (re === 0)
      throw new Error("Invalid RSA ciphertext.");
    return x.slice(ce);
  }
  function xe(T, M, $, r) {
    if (r == null && (r = H), e(T && typeof T.id == "string"), e(k.isBuffer(M)), e((r | 0) === r), M.length !== T.size)
      throw new Error("Invalid RSA message size.");
    const x = A.decode($);
    if (!x.verify())
      throw new Error("Invalid RSA private key.");
    const O = x.bits(), L = O + 7 >>> 3, X = O + 6 >>> 3;
    if (r === S ? r = X - 2 - T.size : r === H && (r = T.size), r < 0 || r > L)
      throw new Error("Invalid PSS salt length.");
    const P = d.randomBytes(r), K = U(T, M, O - 1, P);
    return x.decrypt(K);
  }
  function Ie(T, M, $, r, x) {
    x == null && (x = H), e(T && typeof T.id == "string"), e(k.isBuffer(M)), e(k.isBuffer($)), e(k.isBuffer(r)), e((x | 0) === x);
    try {
      return ve(T, M, $, r, x);
    } catch {
      return !1;
    }
  }
  function ve(T, M, $, r, x) {
    if (M.length !== T.size)
      return !1;
    const O = z.decode(r);
    if (!O.verify())
      return !1;
    const L = O.bits(), X = L + 7 >>> 3;
    if ($.length !== X || (x === S ? x = 0 : x === H && (x = T.size), x < 0 || x > X))
      return !1;
    let P = O.encrypt($);
    if ((L - 1 & 7) === 0) {
      if (P[0] !== 0)
        return !1;
      P = P.slice(1);
    }
    return G(T, M, P, L - 1, x);
  }
  function C(T, M, $, r) {
    r == null && (r = J), e(T && typeof T.id == "string"), e(k.isBuffer(M)), e(k.isBuffer(r));
    const x = z.decode($);
    if (!x.verify())
      throw new Error("Invalid RSA public key.");
    const O = x.size(), L = M.length, X = T.size;
    if (L > O - 2 * X - 2)
      throw new Error("Invalid RSA message size.");
    const P = k.alloc(O), K = T.digest(r), re = P.slice(1, 1 + X), ce = P.slice(1 + X), le = ce.length;
    return P[0] = 0, d.randomFill(re, 0, re.length), K.copy(ce, 0), ce.fill(0, X, le - L - 1), ce[le - L - 1] = 1, M.copy(ce, le - L), B(T, ce, re), B(T, re, ce), x.encrypt(P);
  }
  function I(T, M, $, r) {
    r == null && (r = J), e(T && typeof T.id == "string"), e(k.isBuffer(M)), e(k.isBuffer(r));
    const x = A.decode($);
    if (!x.verify())
      throw new Error("Invalid RSA private key.");
    const O = x.size(), L = M.length, X = T.size;
    if (O < X * 2 + 2)
      throw new Error("Invalid RSA private key size.");
    if (L !== O)
      throw new Error("Invalid RSA message size.");
    const P = x.decrypt(M), K = T.digest(r), re = a(P[0], 0), ce = P.slice(1, X + 1), le = P.slice(X + 1);
    B(T, ce, le), B(T, le, ce);
    const me = le.slice(0, X), ne = u(me, K), W = le.slice(X);
    let te = 1, pe = 0, Ee = 0;
    for (let Oe = 0; Oe < W.length; Oe++) {
      const Be = a(W[Oe], 0), ke = a(W[Oe], 1);
      pe = s(pe, Oe, te & ke), te = s(te, 0, ke), Ee = s(Ee, 1, te & (Be ^ 1));
    }
    if ((re & ne & (Ee ^ 1) & (te ^ 1)) === 0)
      throw new Error("Invalid RSA ciphertext.");
    return W.slice(pe + 1);
  }
  function se(T, M, $) {
    e(k.isBuffer(T)), e(M >>> 0 === M);
    const r = z.decode($);
    if (!r.verify())
      throw new Error("Invalid RSA public key.");
    if (T.length !== r.size())
      throw new Error("Invalid RSA ciphertext.");
    if (M < r.bits())
      throw new Error("Cannot make ciphertext smaller.");
    const x = M + 7 >>> 3, O = c.decode(T);
    if (O.cmp(r.n) >= 0)
      throw new Error("Invalid RSA ciphertext.");
    const L = c.shift(1, M), X = L.sub(O).iadd(r.n).isubn(1).div(r.n);
    e(X.sign() > 0);
    let P = L;
    for (; P.cmp(L) >= 0; ) {
      const K = c.random(d, 0, X);
      P = O.add(K.mul(r.n));
    }
    return e(P.mod(r.n).cmp(O) === 0), e(P.bitLength() <= M), P.encode("be", x);
  }
  function t(T, M, $) {
    e(k.isBuffer(T)), e(M >>> 0 === M);
    const r = z.decode($);
    if (!r.verify())
      throw new Error("Invalid RSA public key.");
    const x = r.size();
    if (T.length < x)
      throw new Error("Invalid RSA ciphertext.");
    const O = c.decode(T);
    if (M !== 0 && O.bitLength() > M)
      throw new Error("Invalid RSA ciphertext.");
    return O.imod(r.n).encode("be", x);
  }
  function l(T, M) {
    if (e(T == null || typeof T == "string"), e(k.isBuffer(M)), T == null)
      return [J, M.length];
    const $ = N[T];
    return $ == null ? [null, 0] : $.length === 1 ? [J, $[0]] : [
      $,
      $[$.length - 1]
    ];
  }
  function B(T, M, $) {
    e(T && typeof T.id == "string"), e(k.isBuffer(M)), e(k.isBuffer($));
    const r = k.alloc(4, 0);
    let x = 0;
    for (; x < M.length; ) {
      const O = T.multi($, r);
      let L = 0;
      for (; x < M.length && L < O.length; )
        M[x++] ^= O[L++];
      for (L = 3; L >= 0 && (r[L] += 1, r[L] === 0); L--)
        ;
    }
  }
  function U(T, M, $, r) {
    e(T && typeof T.id == "string"), e(k.isBuffer(M)), e($ >>> 0 === $), e(k.isBuffer(r));
    const x = T.size, O = r.length, L = $ + 7 >>> 3;
    if (M.length !== x)
      throw new Error("Invalid RSA message size.");
    if (L < x + O + 2)
      throw new Error("Message too long.");
    const X = k.alloc(L), P = X.slice(0, L - x - 1), K = X.slice(L - x - 1, L - 1), re = T.multi(j, M, r), ce = 255 >>> 8 * L - $;
    return P.fill(0, 0, L - O - x - 2), P[L - O - x - 2] = 1, r.copy(P, L - O - x - 1), re.copy(K, 0), X[L - 1] = 188, B(T, P, K), P[0] &= ce, X;
  }
  function G(T, M, $, r, x) {
    e(T && typeof T.id == "string"), e(k.isBuffer(M)), e(k.isBuffer($)), e(r >>> 0 === r), e(x >>> 0 === x);
    const O = T.size, L = r + 7 >>> 3;
    if (M.length !== O || L < O + x + 2 || $[L - 1] !== 188)
      return !1;
    const X = $.slice(0, L - O - 1), P = $.slice(L - O - 1, L - 1), K = 255 >>> 8 * L - r;
    if ($[0] & ~K)
      return !1;
    if (B(T, X, P), X[0] &= K, x === 0) {
      x = -1;
      for (let le = 0; le < X.length; le++)
        if (X[le] !== 0) {
          if (X[le] === 1) {
            x = X.length - (le + 1);
            break;
          }
          return !1;
        }
      if (x === -1)
        return !1;
    } else {
      const le = X.length - x - 1;
      for (let me = 0; me < le; me++)
        if (X[me] !== 0)
          return !1;
      if (X[le] !== 1)
        return !1;
    }
    const re = X.slice(X.length - x);
    return T.multi(j, M, re).equals(P);
  }
  return zt.native = 0, zt.SALT_LENGTH_AUTO = S, zt.SALT_LENGTH_HASH = H, zt.privateKeyGenerate = q, zt.privateKeyGenerateAsync = _, zt.privateKeyBits = F, zt.privateKeyVerify = R, zt.privateKeyImport = V, zt.privateKeyExport = fe, zt.publicKeyCreate = ue, zt.publicKeyBits = ae, zt.publicKeyVerify = D, zt.publicKeyImport = Q, zt.publicKeyExport = Z, zt.sign = oe, zt.verify = y, zt.encrypt = he, zt.decrypt = be, zt.signPSS = xe, zt.verifyPSS = Ie, zt.encryptOAEP = C, zt.decryptOAEP = I, zt.veil = se, zt.unveil = t, zt;
}
var Mn = {};
/*!
 * scrypt.js - scrypt for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on Tarsnap/scrypt:
 *   Copyright (c) 2005-2016, Colin Percival. All rights reserved.
 *   Copyright (c) 2005-2016, Tarsnap Backup Inc. All rights reserved.
 *   Copyright (c) 2014, Sean Kelly. All rights reserved.
 *   https://github.com/Tarsnap/scrypt
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/Scrypt
 *   http://www.tarsnap.com/scrypt.html
 *   http://www.tarsnap.com/scrypt/scrypt.pdf
 *   https://github.com/Tarsnap/scrypt/blob/master/lib/crypto/crypto_scrypt-ref.c
 */
var g2;
function S9() {
  if (g2) return Mn;
  g2 = 1;
  const e = Bt(), c = Gh(), d = cr(), w = k.alloc(64), g = new Uint32Array(16), f = new Uint32Array(16);
  function n(j, J, N, z, A, q) {
    if (typeof j == "string" && (j = k.from(j, "utf8")), typeof J == "string" && (J = k.from(J, "utf8")), J == null && (J = k.alloc(0)), e(k.isBuffer(j)), e(k.isBuffer(J)), e(N >>> 0 === N), e(z >>> 0 === z), e(A >>> 0 === A), e(q >>> 0 === q), z * A >= 1 << 30)
      throw new Error("EFBIG");
    if ((N & N - 1) !== 0 || N === 0)
      throw new Error("EINVAL");
    if (N > 4294967295)
      throw new Error("EINVAL");
    const _ = k.alloc(256 * z), F = k.alloc(128 * z * N), R = c.derive(d, j, J, 1, A * 128 * z);
    for (let V = 0; V < A; V++)
      m(R, V * 128 * z, z, N, F, _);
    return o(), c.derive(d, j, R, 1, q);
  }
  async function u(j, J, N, z, A, q) {
    if (typeof j == "string" && (j = k.from(j, "utf8")), typeof J == "string" && (J = k.from(J, "utf8")), J == null && (J = k.alloc(0)), e(k.isBuffer(j)), e(k.isBuffer(J)), e(N >>> 0 === N), e(z >>> 0 === z), e(A >>> 0 === A), e(q >>> 0 === q), z * A >= 1 << 30)
      throw new Error("EFBIG");
    if ((N & N - 1) !== 0 || N === 0)
      throw new Error("EINVAL");
    if (N > 4294967295)
      throw new Error("EINVAL");
    const _ = k.alloc(256 * z), F = k.alloc(128 * z * N), R = await c.deriveAsync(d, j, J, 1, A * 128 * z);
    for (let V = 0; V < A; V++)
      await E(R, V * 128 * z, z, N, F, _);
    return o(), c.deriveAsync(d, j, R, 1, q);
  }
  function a(j) {
    const J = g, N = f;
    for (let z = 0; z < 16; z++)
      J[z] = S(j, z * 4);
    for (let z = 0; z < 16; z++)
      N[z] = J[z];
    for (let z = 0; z < 8; z += 2)
      N[4] ^= s(N[0] + N[12], 7), N[8] ^= s(N[4] + N[0], 9), N[12] ^= s(N[8] + N[4], 13), N[0] ^= s(N[12] + N[8], 18), N[9] ^= s(N[5] + N[1], 7), N[13] ^= s(N[9] + N[5], 9), N[1] ^= s(N[13] + N[9], 13), N[5] ^= s(N[1] + N[13], 18), N[14] ^= s(N[10] + N[6], 7), N[2] ^= s(N[14] + N[10], 9), N[6] ^= s(N[2] + N[14], 13), N[10] ^= s(N[6] + N[2], 18), N[3] ^= s(N[15] + N[11], 7), N[7] ^= s(N[3] + N[15], 9), N[11] ^= s(N[7] + N[3], 13), N[15] ^= s(N[11] + N[7], 18), N[1] ^= s(N[0] + N[3], 7), N[2] ^= s(N[1] + N[0], 9), N[3] ^= s(N[2] + N[1], 13), N[0] ^= s(N[3] + N[2], 18), N[6] ^= s(N[5] + N[4], 7), N[7] ^= s(N[6] + N[5], 9), N[4] ^= s(N[7] + N[6], 13), N[5] ^= s(N[4] + N[7], 18), N[11] ^= s(N[10] + N[9], 7), N[8] ^= s(N[11] + N[10], 9), N[9] ^= s(N[8] + N[11], 13), N[10] ^= s(N[9] + N[8], 18), N[12] ^= s(N[15] + N[14], 7), N[13] ^= s(N[12] + N[15], 9), N[14] ^= s(N[13] + N[12], 13), N[15] ^= s(N[14] + N[13], 18);
    for (let z = 0; z < 16; z++)
      J[z] += N[z];
    for (let z = 0; z < 16; z++)
      H(j, J[z], 4 * z);
  }
  function s(j, J) {
    return j << J | j >>> 32 - J;
  }
  function i(j, J, N, z) {
    const A = w;
    v(A, j, 0, (2 * z - 1) * 64, 64);
    for (let q = 0; q < 2 * z; q++)
      b(A, j, 0, q * 64, 64), a(A), v(J, A, N + q * 64, 0, 64);
    for (let q = 0; q < z; q++)
      v(j, J, q * 64, N + q * 2 * 64, 64);
    for (let q = 0; q < z; q++)
      v(j, J, (q + z) * 64, N + (q * 2 + 1) * 64, 64);
  }
  function p(j, J) {
    return S(j, (2 * J - 1) * 64);
  }
  function m(j, J, N, z, A, q) {
    const _ = q, F = q;
    v(_, j, 0, J, 128 * N);
    for (let R = 0; R < z; R++)
      v(A, _, R * (128 * N), 0, 128 * N), i(_, F, 128 * N, N);
    for (let R = 0; R < z; R++) {
      const V = p(_, N) & z - 1;
      b(_, A, 0, V * (128 * N), 128 * N), i(_, F, 128 * N, N);
    }
    v(j, _, J, 0, 128 * N);
  }
  async function E(j, J, N, z, A, q) {
    const _ = q, F = q;
    v(_, j, 0, J, 128 * N);
    for (let R = 0; R < z; R++)
      v(A, _, R * (128 * N), 0, 128 * N), i(_, F, 128 * N, N), await h();
    for (let R = 0; R < z; R++) {
      const V = p(_, N) & z - 1;
      b(_, A, 0, V * (128 * N), 128 * N), i(_, F, 128 * N, N), await h();
    }
    v(j, _, J, 0, 128 * N);
  }
  function v(j, J, N, z, A) {
    J.copy(j, N, z, z + A);
  }
  function b(j, J, N, z, A) {
    for (let q = 0; q < A; q++)
      j[N + q] ^= J[z + q];
  }
  function h() {
    return new Promise((j) => setImmediate(j));
  }
  function o() {
    for (let j = 0; j < 64; j++)
      w[j] = 0;
    for (let j = 0; j < 16; j++)
      g[j] = 0, f[j] = 0;
  }
  function S(j, J) {
    return j[J++] + j[J++] * 256 + j[J++] * 65536 + j[J] * 16777216;
  }
  function H(j, J, N) {
    return j[N++] = J, J >>>= 8, j[N++] = J, J >>>= 8, j[N++] = J, J >>>= 8, j[N++] = J, N;
  }
  return Mn.native = 0, Mn.derive = n, Mn.deriveAsync = u, Mn;
}
/*!
 * sha224.js - SHA224 implementation for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/hash.js:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/hash.js
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/SHA-2
 *   https://tools.ietf.org/html/rfc4634
 *   https://github.com/indutny/hash.js/blob/master/lib/hash/sha/224.js
 */
var Ea, x2;
function yb() {
  if (x2) return Ea;
  x2 = 1;
  const e = Bt(), c = cr(), d = ri();
  class w extends c {
    constructor() {
      super();
    }
    init() {
      return this.state[0] = 3238371032, this.state[1] = 914150663, this.state[2] = 812702999, this.state[3] = 4144912697, this.state[4] = 4290775857, this.state[5] = 1750603025, this.state[6] = 1694076839, this.state[7] = 3204075428, this.size = 0, this;
    }
    final() {
      return super.final().slice(0, 28);
    }
    static hash() {
      return new w();
    }
    static hmac() {
      return new d(w, 64);
    }
    static digest(f) {
      return w.ctx.init().update(f).final();
    }
    static root(f, n) {
      return e(k.isBuffer(f) && f.length === 28), e(k.isBuffer(n) && n.length === 28), w.ctx.init().update(f).update(n).final();
    }
    static multi(f, n, u) {
      const { ctx: a } = w;
      return a.init(), a.update(f), a.update(n), u && a.update(u), a.final();
    }
    static mac(f, n) {
      return w.hmac().init(n).update(f).final();
    }
  }
  return w.native = 0, w.id = "SHA224", w.size = 28, w.bits = 224, w.blockSize = 64, w.zero = k.alloc(28, 0), w.ctx = new w(), Ea = w, Ea;
}
/*!
 * bcrypto.js - crypto for bcrypto
 * Copyright (c) 2014-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var w2;
function E9() {
  return w2 || (w2 = 1, function(e) {
    e.aes = w9(), e.BN = Ur(), e.ChaCha20 = Z8(), e.cleanse = Zs(), e.Hash160 = hn(), e.Hash256 = Or(), e.HmacDRBG = Q8(), e.Keccak = hb(), e.merkle = ab(), e.murmur3 = tl(), e.p224 = lb(), e.p256 = db(), e.p384 = bb(), e.p521 = gb(), e.pbkdf2 = Gh(), e.random = Ti(), e.RIPEMD160 = _h(), e.rsa = wb(), e.safe = xb(), e.scrypt = S9(), e.secp256k1 = Fr(), e.SHA1 = tb(), e.SHA224 = yb(), e.SHA256 = cr(), e.SHA384 = rl(), e.SHA512 = Fi(), e.SHAKE = pb(), e.SHAKE256 = mb(), e.version = "5.5.1", e.native = e.SHA256.native;
  }(la)), la;
}
var ls = {};
/*!
 * bloom.js - bloom filter for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var Ia, y2;
function I9() {
  if (y2) return Ia;
  y2 = 1;
  const { enforce: e } = nt, c = kt, d = tl(), w = k.alloc(0), g = 0.48045301391820144, f = 0.6931471805599453;
  class n extends c.Struct {
    /**
     * Create a bloom filter.
     * @constructor
     * @param {Number} size - Filter size in bits.
     * @param {Number} n - Number of hash functions.
     * @param {Number} tweak - Seed value.
     * @param {Number|String} - Update type.
     * @property {Buffer} filter
     * @property {Number} size
     * @property {Number} n
     * @property {Number} tweak
     * @property {Number} update - Update flag (see {@link BloomFilter.flags}).
     */
    constructor(s, i, p, m) {
      super(), this.filter = w, this.size = 0, this.n = 0, this.tweak = 0, this.update = n.flags.NONE, s != null && this.fromOptions(s, i, p, m);
    }
    /**
     * Inject properties from options.
     * @private
     * @param {Number} size - Filter size in bits.
     * @param {Number} n - Number of hash functions.
     * @param {Number} tweak - Seed value.
     * @param {Number|String} - Update type.
     * @returns {BloomFilter}
     */
    fromOptions(s, i, p, m) {
      return (p == null || p === -1) && (p = Math.random() * 4294967296 >>> 0), (m == null || m === -1) && (m = n.flags.NONE), typeof m == "string" && (m = n.flags[m.toUpperCase()], e(m != null, "update", "flag")), e(Number.isSafeInteger(s) && s >= 0, "size", "integer"), e(Number.isSafeInteger(i) && i >= 0, "n", "integer"), e(p >>> 0 === p, "tweak", "integer"), e(m >>> 0 === m, "update", "integer"), e(m <= 2, "update", "range between 0 and 2"), s < 8 && (s = 8), i === 0 && (i = 1), s -= s & 7, this.filter = k.alloc(s / 8, 0), this.size = s, this.n = i, this.tweak = p, this.update = m, this;
    }
    /**
     * Instantiate bloom filter from options.
     * @param {Number} size - Filter size in bits.
     * @param {Number} n - Number of hash functions.
     * @param {Number} tweak - Seed value.
     * @param {Number|String} - Update type.
     * @returns {BloomFilter}
     */
    static fromOptions(s, i, p, m) {
      return new this().fromOptions(s, i, p, m);
    }
    /**
     * Perform the mumur3 hash on data.
     * @param {Buffer} value
     * @param {Number} n
     * @returns {Number}
     */
    hash(s, i) {
      return d.tweak(s, i, this.tweak) % this.size;
    }
    /**
     * Reset the filter.
     */
    reset() {
      this.filter.fill(0);
    }
    /**
     * Add data to the filter.
     * @param {Buffer|String}
     * @param {String?} enc - Can be any of the Buffer object's encodings.
     */
    add(s, i) {
      const p = u(s, i);
      for (let m = 0; m < this.n; m++) {
        const E = this.hash(p, m);
        this.filter[E >>> 3] |= 1 << (7 & E);
      }
    }
    /**
     * Test whether data is present in the filter.
     * @param {Buffer|String} value
     * @param {String?} enc - Can be any of the Buffer object's encodings.
     * @returns {Boolean}
     */
    test(s, i) {
      const p = u(s, i);
      for (let m = 0; m < this.n; m++) {
        const E = this.hash(p, m);
        if ((this.filter[E >>> 3] & 1 << (7 & E)) === 0)
          return !1;
      }
      return !0;
    }
    /**
     * Test whether data is present in the
     * filter and potentially add data.
     * @param {Buffer|String} value
     * @param {String?} enc - Can be any of the Buffer object's encodings.
     * @returns {Boolean} Whether data was added.
     */
    added(s, i) {
      const p = u(s, i);
      let m = !1;
      for (let E = 0; E < this.n; E++) {
        const v = this.hash(p, E);
        !m && (this.filter[v >>> 3] & 1 << (7 & v)) === 0 && (m = !0), this.filter[v >>> 3] |= 1 << (7 & v);
      }
      return m;
    }
    /**
     * Create a filter from a false positive rate.
     * @param {Number} items - Expected number of items.
     * @param {Number} rate - False positive rate (0.0-1.0).
     * @param {Number|String} update
     * @example
     * BloomFilter.fromRate(800000, 0.0001, 'none');
     * @returns {BloomFilter}
     */
    static fromRate(s, i, p) {
      e(Number.isSafeInteger(s) && s > 0, "items", "integer"), e(typeof i == "number" && isFinite(i), "rate", "number"), e(i >= 0 && i <= 1, "rate", "range between 0.1 and 1.0.");
      const m = -1 / g * s * Math.log(i) | 0, E = Math.max(8, m);
      if (p !== -1 && E > n.MAX_BLOOM_FILTER_SIZE * 8)
        throw new Error("Bloom filter size violates policy limits!");
      const v = Math.max(1, E / s * f | 0);
      if (p !== -1 && v > n.MAX_HASH_FUNCS)
        throw new Error("Bloom filter size violates policy limits!");
      return new this(E, v, -1, p);
    }
    /**
     * Ensure the filter is within the size limits.
     * @returns {Boolean}
     */
    isWithinConstraints() {
      return !(this.size > n.MAX_BLOOM_FILTER_SIZE * 8 || this.n > n.MAX_HASH_FUNCS);
    }
    /**
     * Get serialization size.
     * @returns {Number}
     */
    getSize() {
      return c.sizeVarBytes(this.filter) + 9;
    }
    /**
     * Write filter to buffer writer.
     * @param {BufferWriter} bw
     */
    write(s) {
      return s.writeVarBytes(this.filter), s.writeU32(this.n), s.writeU32(this.tweak), s.writeU8(this.update), s;
    }
    /**
     * Inject properties from buffer reader.
     * @private
     * @param {BufferReader} br
     */
    read(s) {
      if (this.filter = s.readVarBytes(), this.size = this.filter.length * 8, this.n = s.readU32(), this.tweak = s.readU32(), this.update = s.readU8(), this.update > 2)
        throw new Error("Invalid update flag.");
      return this;
    }
  }
  n.MAX_BLOOM_FILTER_SIZE = 36e3, n.MAX_HASH_FUNCS = 50, n.flags = {
    /**
     * Never update the filter with outpoints.
     */
    NONE: 0,
    /**
     * Always update the filter with outpoints.
     */
    ALL: 1,
    /**
     * Only update the filter with outpoints if it is
     * "asymmetric" in terms of addresses (pubkey/multisig).
     */
    PUBKEY_ONLY: 2
  }, n.flagsByVal = [
    "NONE",
    "ALL",
    "PUBKEY_ONLY"
  ];
  function u(a, s) {
    return typeof a != "string" ? (e(k.isBuffer(a), "value", "buffer"), a) : (e(typeof s == "string", "enc", "string"), k.from(a, s));
  }
  return Ia = n, Ia;
}
/*!
 * rollingfilter.js - rolling bloom filter for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var Aa, v2;
function A9() {
  if (v2) return Aa;
  v2 = 1;
  const { enforce: e } = nt, { encoding: c } = kt, d = tl(), w = k.alloc(0);
  class g {
    /**
     * Create a rolling bloom filter.
     * @constructor
     * @param {Number} items - Expected number of items.
     * @param {Number} rate - False positive rate (0.0-1.0).
     */
    constructor(i, p) {
      this.entries = 0, this.generation = 1, this.n = 0, this.limit = 0, this.size = 0, this.items = 0, this.tweak = 0, this.filter = w, i != null && this.fromRate(i, p);
    }
    /**
     * Inject properties from items and FPR.
     * @private
     * @param {Number} items - Expected number of items.
     * @param {Number} rate - False positive rate (0.0-1.0).
     * @returns {RollingFilter}
     */
    fromRate(i, p) {
      e(Number.isSafeInteger(i) && i > 0, "items", "integer"), e(typeof p == "number" && isFinite(p), "rate", "number"), e(p >= 0 && p <= 1, "rate", "range between 0.1 and 1.0.");
      const m = Math.log(p), E = Math.max(1, Math.min(Math.round(m / Math.log(0.5)), 50)), v = (i + 1) / 2 | 0, b = v * 3;
      let h = -1 * E * b / Math.log(1 - Math.exp(m / E));
      h = Math.ceil(h), i = ((h + 63) / 64 | 0) << 1, i >>>= 0, i = Math.max(1, i);
      const o = Math.random() * 4294967296 >>> 0, S = k.alloc(i * 8, 0);
      return this.n = E, this.limit = v, this.size = h, this.items = i, this.tweak = o, this.filter = S, this;
    }
    /**
     * Instantiate rolling filter from items and FPR.
     * @param {Number} items - Expected number of items.
     * @param {Number} rate - False positive rate (0.0-1.0).
     * @returns {RollingFilter}
     */
    static fromRate(i, p) {
      return new this().fromRate(i, p);
    }
    /**
     * Perform the mumur3 hash on data.
     * @param {Buffer} value
     * @param {Number} seed
     * @returns {Number}
     */
    hash(i, p) {
      return d.tweak(i, p, this.tweak);
    }
    /**
     * Reset the filter.
     */
    reset() {
      this.entries !== 0 && (this.entries = 0, this.generation = 1, this.filter.fill(0));
    }
    /**
     * Add data to the filter.
     * @param {Buffer|String}
     * @param {String?} enc - Can be any of the Buffer object's encodings.
     */
    add(i, p) {
      const m = a(i, p);
      if (this.entries === this.limit) {
        this.entries = 0, this.generation += 1, this.generation === 4 && (this.generation = 1);
        const E = (this.generation & 1) * 4294967295, v = (this.generation >>> 1) * 4294967295;
        for (let b = 0; b < this.items; b += 2) {
          const h = b * 8, o = (b + 1) * 8, S = n(this.filter, h), H = n(this.filter, o), j = S.hi ^ E | H.hi ^ v, J = S.lo ^ E | H.lo ^ v;
          S.hi &= j, S.lo &= J, H.hi &= j, H.lo &= J, u(this.filter, S, h), u(this.filter, H, o);
        }
      }
      this.entries += 1;
      for (let E = 0; E < this.n; E++) {
        const v = this.hash(m, E), b = v & 63, h = (v >>> 6) % this.items, o = (h & -2) * 8, S = (h | 1) * 8, H = b % 8, j = (b - H) / 8;
        this.filter[o + j] &= ~(1 << H), this.filter[o + j] |= (this.generation & 1) << H, this.filter[S + j] &= ~(1 << H), this.filter[S + j] |= this.generation >>> 1 << H;
      }
    }
    /**
     * Test whether data is present in the filter.
     * @param {Buffer|String} value
     * @param {String?} enc - Can be any of the Buffer object's encodings.
     * @returns {Boolean}
     */
    test(i, p) {
      if (this.entries === 0)
        return !1;
      const m = a(i, p);
      for (let E = 0; E < this.n; E++) {
        const v = this.hash(m, E), b = v & 63, h = (v >>> 6) % this.items, o = (h & -2) * 8, S = (h | 1) * 8, H = b % 8, j = (b - H) / 8, J = this.filter[o + j] >>> H & 1, N = this.filter[S + j] >>> H & 1;
        if ((J | N) === 0)
          return !1;
      }
      return !0;
    }
    /**
     * Test whether data is present in the
     * filter and potentially add data.
     * @param {Buffer|String} value
     * @param {String?} enc - Can be any of the Buffer object's encodings.
     * @returns {Boolean} Whether data was added.
     */
    added(i, p) {
      const m = a(i, p);
      return this.test(m) ? !1 : (this.add(m), !0);
    }
  }
  class f {
    constructor(i, p) {
      this.hi = i, this.lo = p;
    }
  }
  function n(s, i) {
    const p = c.readU32(s, i + 4), m = c.readU32(s, i);
    return new f(p, m);
  }
  function u(s, i, p) {
    c.writeU32(s, i.hi, p + 4), c.writeU32(s, i.lo, p);
  }
  function a(s, i) {
    return typeof s != "string" ? (e(k.isBuffer(s), "value", "buffer"), s) : (e(typeof i == "string", "enc", "string"), k.from(s, i));
  }
  return Aa = g, Aa;
}
/*!
 * bfilter.js - bloom filters for javascript
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var S2;
function O9() {
  if (S2) return ls;
  S2 = 1;
  const e = I9(), c = A9();
  return ls.BloomFilter = e, ls.RollingFilter = c, ls;
}
var oi = {}, Oa, E2;
function vb() {
  return E2 || (E2 = 1, Oa = [
    k.from(
      "ebd41040e4bb3ec742c9e381d31ef2a41a48b6685c96e7cef3c1df6cd4331c99",
      "hex"
    ),
    k.from(
      "ca42dd41745fd0b81eb902362cf9d8bf719da1bd1b1efc946f5b4c99f42c1b9e",
      "hex"
    ),
    k.from(
      "eb04cf5eb1f39afa762f2bb120f296cba520c1b97db1589565b81cb9a17b7244",
      "hex"
    ),
    k.from(
      "6dc47172e01cbcb0bf62580d895fe2b8ac9ad4f873801e0c10b9c837d21eb177",
      "hex"
    ),
    k.from(
      "16af57a9f676b0ab126095aa5ebadef22ab31119d644ac95cd4b93dbf3f26aeb",
      "hex"
    ),
    k.from(
      "687fa451382278fff0c8b11f8d43d576671c6eb2bceab413fb83d965d06d2ff2",
      "hex"
    ),
    k.from(
      "73c176434f1bc6d5adf45b0e76e727287c8de57616c1e6e6141a2b2cbc7d8e4c",
      "hex"
    ),
    k.from(
      "ff856a2d251dcd88d36656f450126798cfabaade40799c722de4d2b5db36a73a",
      "hex"
    ),
    k.from(
      "a0459b9f63b22559f5fa5d4c6db3f9f72ff19342033578f073bf1d1b46cbb912",
      "hex"
    ),
    k.from(
      "a0234f3bc8527ca5628eec81ad5d69895da5680dc91d1cb8477f33f878b95b0b",
      "hex"
    ),
    k.from(
      "69fac9bd55fb0ac78d53bbee5cf1d597989fd0aaab20a25151bdf1733ee7d122",
      "hex"
    ),
    k.from(
      "d7a7a0fb5d7e2731d771e9484ebcdef71d5f0c3e0a2948782bc83ee0ea699ef4",
      "hex"
    ),
    k.from(
      "a45ede3bbbf09c8ae15c72efc07268d693a21c996fd51e67ca079460fd6d8873",
      "hex"
    ),
    k.from(
      "85a0dd7dd720adb7ff05f83d542b209dc7ff4528f7d677b18389fea5e5c49e86",
      "hex"
    ),
    k.from(
      "18f1fc7f205df8adddeb7fe007dd57e3af375a9c4d8d73546bf4f1fed1e18d35",
      "hex"
    ),
    k.from(
      "e75e72ed9f560eec6eb4800073a43fc3ad19195a392282017895974a99026b6c",
      "hex"
    ),
    k.from(
      "7908b40314c138100b518d0735807ffbfcf8518a0095337105ba386b153dd927",
      "hex"
    ),
    k.from(
      "cecddc905099d8dadfc5b1d209b737cbe2c18cfb2c10c0ff0bcf0d3286fc1aa2",
      "hex"
    ),
    k.from(
      "c3846bf24b9e93ca64274c0ec67c1ecc5e024ffcacd2d74019350e81fe546ae4",
      "hex"
    ),
    k.from(
      "1465fa205397b876faa6f0a9958e5590e40fcc7faa4fb7c2c8677521fb5fb658",
      "hex"
    ),
    k.from(
      "7600295eefe85b9e1fd624db76062aaaae59818a54d2774cd4c0b2c01131e1b3",
      "hex"
    ),
    k.from(
      "3e9099b5015e8f486c00bcea9d111ee721faba355a89bcf1df69561e3dc6325c",
      "hex"
    ),
    k.from(
      "4348a0e9444c78cb265e058d5e8944b4d84f9662bd26db257f8934a443c70161",
      "hex"
    ),
    k.from(
      "7431e5f4c3c1ce4690774f0b61e05440883ba9a01ed00ba6abd7806ed3b118cf",
      "hex"
    ),
    k.from(
      "0f993c8aef97baaf5687140ed59ad1821bb4afacf0aa9a58b5d57a338a3afbcb",
      "hex"
    ),
    k.from(
      "0687260331a72403d909f105e69bcf0d32e1bd2493ffc6d9206d11bcd6770739",
      "hex"
    ),
    k.from(
      "62dd0be9b9f50a163ea0f8e75c053b1eca57ea55c8688f647c6881f2c8357b95",
      "hex"
    ),
    k.from(
      "be6c4da2bbb9ba59b6f3939768374246c3c005993fa98f020d1dedbed48a81d5",
      "hex"
    ),
    k.from(
      "37d51006c512eaab626421f1ec8c92013fc5f82ae98ee533eb4619b8deb4d06c",
      "hex"
    ),
    k.from(
      "8d722f81a9c113c0791df136a2966db26c950a971db46b4199f4ea54b78bfb9f",
      "hex"
    ),
    k.from(
      "9acfab7e43c8d880d06b262a94deeee4b4659989c3d0caf19baf6405e41ab7df",
      "hex"
    ),
    k.from(
      "f1c1b50ae5a20dd8030ec9f6bc24823dd367b5255759b4e71b61fce9f7375d73",
      "hex"
    ),
    k.from(
      "4200f5043ac8590ebb527d209ed1503029fbcbd41ca1b506ec27f15ade7dac69",
      "hex"
    ),
    k.from(
      "0c2cd63df7806fa399ede809116b575bf87989f06518f9808c860503178baf66",
      "hex"
    ),
    k.from(
      "15f0ba00a3ac7af3ac884c072b1011a077bd77c097f40164b2f8598abd83860c",
      "hex"
    ),
    k.from(
      "1793927a0614549789adce2f8f34f7f0b66d0f3ae3a3b84d21ec15dbba4fadc7",
      "hex"
    ),
    k.from(
      "41c923866ab4cad6b7ad578081582e020797a6cbdf4fff78ce8396b38937d7f5",
      "hex"
    ),
    k.from(
      "e3b6a2db2ed7ce48842f7ac53241c7b71d54144bfb40c11f3f1d0b42f5eea12d",
      "hex"
    ),
    k.from(
      "b6191a50d0c3977f7da99bcdaac86a227daeb9679ec70ba3b0c9d92271c170d3",
      "hex"
    ),
    k.from(
      "960adf0063e96356750c2965dd0a0867da0b9cbd6e77714aeafb2349ab393da3",
      "hex"
    ),
    k.from(
      "c0a6f4dc63a24bfdcf54ef2a6a082a0a72de35803e2ff5ff527ae5d87206dfd5",
      "hex"
    ),
    k.from(
      "eaa962c4fa4a6bafebe415196d351ccd888d4f53f3fa8ae6d7c466a94e6042bb",
      "hex"
    ),
    k.from(
      "b478b812250df878635c2aa7ec7d155eaa625ee82916e2cd294361886cd1fbd4",
      "hex"
    ),
    k.from(
      "a4310d50af18a6447190372a86afaf8b951ffb431d837f1e5688b45971ed1557",
      "hex"
    ),
    k.from(
      "4b03f45807ad70f21bfc2cae71c9fde4604c064cf5ffb686bae5dbaad7fdd34c",
      "hex"
    ),
    k.from(
      "5edb7ac43b82a06a8761e8d7be4979ebf2611f7dd79bf91c1c6b566a219ed766",
      "hex"
    ),
    k.from(
      "2399561127a57125de8cefea610ddf2fa078b5c8067f4e828290bfb860e84b3c",
      "hex"
    ),
    k.from(
      "69ddd7ea90bb57c93e135dc85ea6fcd5480b603239bdc454fc758b2a26cf7f79",
      "hex"
    ),
    k.from(
      "6c61dac3a2def031506be036d2a6fe401994fbd13df9c8d466599274c446ec98",
      "hex"
    ),
    k.from(
      "668c83947da63b724bece1743c31a0e6aed0db8ec5b31be377bb784f91b6716f",
      "hex"
    ),
    k.from(
      "f9e67d336c51002ac054c632022d66dda2e7e3fff10ad061ed31d8bbb410cfb2",
      "hex"
    ),
    k.from(
      "bf0feefb9e3a581ad5f9e9db7589985743d261085c4d314f6f5d7259aa421612",
      "hex"
    ),
    k.from(
      "3c5f81fea5fab82c64bfa2eaecafcde8e077fc8620a7cae537163df36edbf378",
      "hex"
    ),
    k.from(
      "cbb522d7b7f127ad6a0113865bdf1cd4102e7d0759af635a7cf4720dc963c53b",
      "hex"
    ),
    k.from(
      "04048028bf1f2864d48f9ad4d83294366a828856553f3b14303f90147f5d40ef",
      "hex"
    ),
    k.from(
      "2530cc8e98321502bad96f9b1fba1b099e2d299e0f4548bb914f363bc0d4531f",
      "hex"
    ),
    k.from(
      "063e4afac491dfd332f3089b8542e94617d893d7fe944e10a7937ee29d9693c0",
      "hex"
    ),
    k.from(
      "136335439334a7698016a0d324de72284e079d7b5220bb8fbd747816eebebaca",
      "hex"
    ),
    k.from(
      "45140b3247eb9cc8c5b4f0d7b53091f73292089e6e5a63e2749dd3aca9198eda",
      "hex"
    ),
    k.from(
      "2ce1cb0bf9d2f9e102993fbe215152c3b2dd0cabde1c68e5319b839154dbb7f5",
      "hex"
    ),
    k.from(
      "568d6905a2c88708a4b3025190edcfedb1974a606a13c6e5290fcb2ae63edab5",
      "hex"
    ),
    k.from(
      "0376ab1d54c5f9803ce4b2e201a0ee7eef7b57b636e8a93c9b8d4860c96f5fa7",
      "hex"
    ),
    k.from(
      "0a81ec5a929777f145904af38d5d509f66b5e2c58fcdb531058b0e17f3f0b41b",
      "hex"
    ),
    k.from(
      "70a73f7f376b60074248904534b11482d5bf0e698ecc498df52577ebf2e93b9a",
      "hex"
    ),
    k.from(
      "bd71fdf6da97e4cf62d1647add2581b07d79adf8397eb4ecba9c5e8488821423",
      "hex"
    ),
    k.from(
      "5c58468d55f58e497e743982d2b50010b6d165374acf83a7d4a32db768c4408e",
      "hex"
    ),
    k.from(
      "bfd88fe1101c41ae3e801bf8be56350ee9bad1a6b9bd515edc5c6d5b8711ac44",
      "hex"
    ),
    k.from(
      "513b2cecb810d4cde5dd85391adfc6c2dd60d87bb736d2b521484aa47a0ebef6",
      "hex"
    ),
    k.from(
      "88497f01602f3154246ae28c4d5aef10f1d87ebb76626f4ae0b7f95ba7968799",
      "hex"
    ),
    k.from(
      "bc104f15a48be709dca542a7e1d4b9df6f054527e802eaa92d595444258afe71",
      "hex"
    ),
    k.from(
      "55926084ec963a64b96e2abe01ce0ba86a64fbfebcc7aab5afc155b37fd76066",
      "hex"
    ),
    k.from(
      "c1b48299aba5208fe9630ace55ca68a03eda5a519c8802a0d3a673be8f8e557d",
      "hex"
    ),
    k.from(
      "9a114025197c5bb95d94e63d55cd43790847b646b23cdf11ada4a00eff15fb48",
      "hex"
    ),
    k.from(
      "edf7ebbca27a2a384d387b7d4010c666e2edb4843e4c29b4ae1d5b9332e6b24d",
      "hex"
    ),
    k.from(
      "fd73dad31c644ff1b43bef0ccdda96710b9cd9875eca7e31707af3e96d522bbd",
      "hex"
    ),
    k.from(
      "3e84ba4342908516e77573c0992f0979ca084e4685681ff195ccba8a229b8a76",
      "hex"
    ),
    k.from(
      "49e7a442acf0ea6287050054b52564b650e4f49e42e348d6aa38e039e957b1c1",
      "hex"
    ),
    k.from(
      "eec5496b988ce98625b934092eec2908bed0b0f316c2d4730c84eaf1f3d34881",
      "hex"
    ),
    k.from(
      "e23d4a036d7b70e9f595b1422079d2b91edfbb1fb651a0633eaa8a9dc5f80703",
      "hex"
    ),
    k.from(
      "9a6ec012e1a7da9dbe34194d478ad7c0db1822fb071df12981496ed104384113",
      "hex"
    ),
    k.from(
      "59769007f7685d0fcd50872f9f95d5755a5b2b457d81f3692b610a98672f0e1b",
      "hex"
    ),
    k.from(
      "dd6936fe21f8f077c123a1a521c12224f72255b73e03a7260693e8a24b0fa389",
      "hex"
    ),
    k.from(
      "b0bfd52bb0d7d9bd92bf5d4dc13da255c02c542f378365ea893911f55e55f23c",
      "hex"
    ),
    k.from(
      "91e2f5788d5810eba7ba58737de1548a8ecacd014598bc0b143e041b17052552",
      "hex"
    ),
    k.from(
      "f356bea244b7a91eb35d53ca9ad7864ace018e2d35d5f8f96ddf68a6f41aa474",
      "hex"
    ),
    k.from(
      "8a866fd1b276b57e578e921c65828a2bed58e9f2f288054134b7f1f4bfc9cc74",
      "hex"
    ),
    k.from(
      "8fe4fb0af93a4d0d67db0bebb23e37c71bf325dcbcdd240ea04daf58b47e1840",
      "hex"
    ),
    k.from(
      "88ef81de202eb018452e43f864725cea5fbd1fc2d9d205730709c5d8b8690f46",
      "hex"
    ),
    k.from(
      "7d05ebb682339f8c9451ee094eebfefa7953a114edb2f44949452fab7d2fc185",
      "hex"
    ),
    k.from(
      "7e37cb8b4c47090cab36551ba6f45db840680fba166a952db100717f43053fc2",
      "hex"
    ),
    k.from(
      "cb3ccbb76031e5e0138f8dd39a23f9de47ffc35e43c1144cea27d46a5ab1cb5f",
      "hex"
    ),
    k.from(
      "31ad6648f8104138c738f39ea4320133393e3a18cc02296ef97c2ac9ef6731d0",
      "hex"
    ),
    k.from(
      "552f7bdcf1a7af9e6ce672017f4f12abf77240c78e761ac203d1d9d20ac89988",
      "hex"
    ),
    k.from(
      "52f0e1c4e58ec629291b60317f074671b85d7ea80d5b07273463534b32b40234",
      "hex"
    ),
    k.from(
      "e793c9b02fd8aa13e21c31228accb08119643b749c898964b1746d46c3d4cbd2",
      "hex"
    ),
    k.from(
      "4ff460d54b9c86dabfbcfc5712e0400d2bed3fbc4d4fbdaa86e06adcd2a9ad7a",
      "hex"
    ),
    k.from(
      "bec94911c2955676db6c0a550986d76e3ba005667c442c9762b4fbb773de228c",
      "hex"
    ),
    k.from(
      "179fbc148a3dd00fd24ea13458cc43bfa7f59c8182d783a513f6ebec100c8924",
      "hex"
    ),
    k.from(
      "3c4fb0b95ab8b30032f432b86f535fe172c185d0fd39865837cf36187fa6f428",
      "hex"
    ),
    k.from(
      "4d2491414cfe956746ec4cefa6cf6f72e28a1329432f9d8a907ac4cb5dadc15a",
      "hex"
    ),
    k.from(
      "5d56499be4d2e08bcfcad08a3e38723d50503bde706948e42f55603019e528ae",
      "hex"
    ),
    k.from(
      "30d0895a9a448a262091635522d1f52010b5867acae12c78ef958fd4f4389f2f",
      "hex"
    ),
    k.from(
      "43df5774b03e7fef5fe40d931a7bedf1bb2e6b42738c4e6d3841103d3aa7f339",
      "hex"
    ),
    k.from(
      "02ed0eb28c14da45165c566791700d6451d7fb56f0b2ab1d3b8eb070e56edff5",
      "hex"
    ),
    k.from(
      "5cc3d78e4e1d5e45547a04e6873e64f90cf9536d1ccc2ef800f355c4c5fd70fd",
      "hex"
    ),
    k.from(
      "49351b903444c185ccdc5c693d24d8555cb208d6a8141307699f4af063199d78",
      "hex"
    ),
    k.from(
      "2a99f5bc1174b73cbb1d620884e01c34e51ccb3978da125f0e33268883bf4158",
      "hex"
    ),
    k.from(
      "6b9c08e86eb0f767cfad65cd98b62149e5494a67f5845e7bd1ed019f27b86bd6",
      "hex"
    ),
    k.from(
      "a1339d33281a0b56e557d3d32b1ce7f9367eb094bd5fa72a7e5004c8ded7cafe",
      "hex"
    ),
    k.from(
      "b676f2eddae8775cd36cb0f63cd1d4603961f49e6265ba013a2f0307b6d0b804",
      "hex"
    ),
    k.from(
      "a040929a02ce53b4acf4f2ffc6981ce4496f755e6d45fe0b2a692bcd52523f36",
      "hex"
    ),
    k.from(
      "44b545aa8a25e65a73ca15dc27fc36d24c1cb9953a066539b11582dc487b4833",
      "hex"
    ),
    k.from(
      "152a402bfcdf2cd548054d2275b39c7fca3ec0978078b0f0ea76e561a6c7433e",
      "hex"
    ),
    k.from(
      "6cc05041e6445e74696c4cfbc9f80f543b7eabbb44b4ce6f787c6a9971c42f17",
      "hex"
    ),
    k.from(
      "56c77128d98c18d91b4cfdffbc25ee9103d4758ea2abad826a90f3457d460eb4",
      "hex"
    ),
    k.from(
      "27995829fe6a7515c1bfe848f9c4761db16c225929257bf40d0894f29ea8baf2",
      "hex"
    ),
    k.from(
      "b7c36231706e81078c367cb896198f1e3208dd926949dd8f5709a410f75b6292",
      "hex"
    ),
    k.from(
      "96bcec06264976f37460779acf28c5a7cfe8a3c0aae11a8ffcee05c0bddf08c6",
      "hex"
    ),
    k.from(
      "ebc5570c29018c4d67b1aa127baf12f703b4611ebc17b7dab5573894179b93fa",
      "hex"
    ),
    k.from(
      "8ecde6884f3d87b1125ba31ac3fcb13d7016de7f57cc904fe1cb97c6ae98196e",
      "hex"
    ),
    k.from(
      "1ba5b2aa8c65401a82960118f80bec4f62304d83cec4713a19c39c011ea46db4",
      "hex"
    ),
    k.from(
      "18ce6cfe7bf14e60b2e347b8dfe868cb31d02ebb3ada271569f50343b46db3a4",
      "hex"
    ),
    k.from(
      "e35d28419ed02025cfa69038cd623962458da5c695fbdea3c22b0bfb25897092",
      "hex"
    ),
    k.from(
      "54455f7129c20b1447c418f997168f24c58fc5023bf5da5be2eb6e1dd8902ed5",
      "hex"
    ),
    k.from(
      "46edc3689046d53a453fb3104ab80dcaec658b2660ea1629dd7e867990648716",
      "hex"
    ),
    k.from(
      "bfff8fd04433487d6a8aa60c1a29767a9fc2bbb05e420f713a13b992891d3893",
      "hex"
    ),
    k.from(
      "d40e9c86cd8fe468c1776959f49ea774fa548684b6c406f3909261f4dce2575c",
      "hex"
    ),
    k.from(
      "0753e940378c1bd5e3836e395daea5cb839e5046f1bd0eae1951cf10fec7c965",
      "hex"
    ),
    k.from(
      "5a885db19c01d912c5759388938cafbbdf031ab2d48e91ee15589b42971d039c",
      "hex"
    ),
    k.from(
      "85666a562ee0be5ce925c1d8890a6f76a87ec16d4d7d5f29ea7419cf20123b69",
      "hex"
    ),
    k.from(
      "3417bb06cc6007da1b961c920b8ab4ce3fad820e4aa30b9acbc4a74ebdcebc65",
      "hex"
    ),
    k.from(
      "2e7bf16cc22485a7bbe2aa8696750761b0ae39be3b2fe9d0cc6d4ef73491425c",
      "hex"
    ),
    k.from(
      "22a2c1f7bded704cc1e701b5f408c310880fe956b5de2a4a44f99c873a25a7c8",
      "hex"
    ),
    k.from(
      "67add1166b020ae61b8f5fc96813c04c2aa589960796865572a3c7e737613dfd",
      "hex"
    ),
    // R3 (Let's Encrypt)
    k.from(
      "96bcec06264976f37460779acf28c5a7cfe8a3c0aae11a8ffcee05c0bddf08c6",
      "hex"
    )
    // ISRG Root X1 (Let's Encrypt)
  ]), Oa;
}
/*!
 * protoreader.js - protobufs for bcoin
 * Copyright (c) 2016-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var _a, I2;
function to() {
  if (I2) return _a;
  I2 = 1;
  const e = nt, c = cp, d = {
    VARINT: 0,
    FIXED64: 1,
    DELIMITED: 2,
    START_GROUP: 3,
    END_GROUP: 4,
    FIXED32: 5
  };
  class w extends c {
    /**
     * Create a protoreader.
     * @constructor
     */
    constructor(a, s) {
      super(a, s);
    }
    readVarint() {
      const { size: a, value: s } = g(this.data, this.offset);
      return this.offset += a, s;
    }
    readFieldValue(a, s) {
      const i = this.readField(a, s);
      return i ? (e(i.value != null), i.value) : -1;
    }
    readFieldU64(a, s) {
      const i = this.readField(a, s);
      return i ? (e(i.type === d.VARINT || i.type === d.FIXED64), i.value) : -1;
    }
    readFieldU32(a, s) {
      const i = this.readField(a, s);
      return i ? (e(i.type === d.VARINT || i.type === d.FIXED32), i.value) : -1;
    }
    readFieldBytes(a, s) {
      const i = this.readField(a, s);
      return i ? (e(i.data), i.data) : null;
    }
    readFieldString(a, s, i) {
      const p = this.readField(a, s);
      return p ? (e(p.data), p.data.toString(i || "utf8")) : null;
    }
    nextTag() {
      if (this.left() === 0)
        return -1;
      const a = this.readField();
      return this.seek(-a.size), a.tag;
    }
    readField(a, s) {
      const i = this.offset, p = this.readVarint(), m = new f(p);
      if (a != null && m.tag !== a)
        return e(s, "Non-optional field not present."), this.offset = i, null;
      switch (m.type) {
        case d.VARINT:
          m.value = this.readVarint();
          break;
        case d.FIXED64:
          m.value = this.readU64();
          break;
        case d.DELIMITED:
          m.data = this.readVarBytes();
          break;
        case d.START_GROUP:
          for (m.group = []; ; ) {
            const E = this.readField();
            if (E.type === d.END_GROUP)
              break;
            m.group.push(E);
          }
          break;
        case d.END_GROUP:
          e(!1, "Unexpected end group.");
          break;
        case d.FIXED32:
          m.value = this.readU32();
          break;
        default:
          e(!1, "Bad wire type.");
          break;
      }
      return m.size = this.offset - i, m;
    }
  }
  function g(u, a) {
    let s = 0, i = 128, p = 0;
    for (; i & 128; ) {
      if (a >= u.length) {
        s = 0;
        break;
      }
      switch (i = u[a], p) {
        case 0:
        case 1:
        case 2:
        case 3:
          s += (i & 127) << 7 * p;
          break;
        case 4:
          s += (i & 127) * (1 << 7 * p);
          break;
        default:
          s += (i & 127) * Math.pow(2, 7 * p);
          break;
      }
      a += 1, p += 1, e(p < 7, "Number exceeds 2^53-1.");
    }
    return new n(p, s);
  }
  class f {
    constructor(a) {
      this.tag = a >>> 3, this.type = a & 7, this.size = 0, this.value = 0, this.data = null, this.group = null;
    }
  }
  class n {
    constructor(a, s) {
      this.size = a, this.value = s;
    }
  }
  return _a = w, _a;
}
/*!
 * protowriter.js - protobufs for bcoin
 * Copyright (c) 2016-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var Ra, A2;
function ro() {
  if (A2) return Ra;
  A2 = 1;
  const e = nt, c = hp, d = {
    VARINT: 0,
    DELIMITED: 2
  };
  class w extends c {
    /**
     * Create a protowriter.
     * @constructor
     */
    constructor() {
      super();
    }
    writeVarint(a) {
      const s = n(a);
      switch (s) {
        case 6: {
          const i = f(a);
          this.writeU32BE(i / 65536 | 0), this.writeU16BE(i & 65535);
          break;
        }
        case 5: {
          const i = f(a);
          this.writeU32BE(i / 256 | 0), this.writeU8(i & 255);
          break;
        }
        case 4: {
          const i = f(a);
          this.writeU32BE(i);
          break;
        }
        case 3: {
          const i = f(a);
          this.writeU16BE(i >> 8), this.writeU8(i & 255);
          break;
        }
        case 2: {
          const i = f(a);
          this.writeU16BE(i);
          break;
        }
        case 1: {
          const i = f(a);
          this.writeU8(i);
          break;
        }
        default: {
          const i = k.allocUnsafe(s);
          g(i, a, 0), this.writeBytes(i);
          break;
        }
      }
    }
    writeFieldVarint(a, s) {
      const i = a << 3 | d.VARINT;
      this.writeVarint(i), this.writeVarint(s);
    }
    writeFieldU64(a, s) {
      e(Number.isSafeInteger(s)), this.writeFieldVarint(a, s);
    }
    writeFieldU32(a, s) {
      e(s <= 4294967295), this.writeFieldVarint(a, s);
    }
    writeFieldBytes(a, s) {
      const i = a << 3 | d.DELIMITED;
      this.writeVarint(i), this.writeVarint(s.length), this.writeBytes(s);
    }
    writeFieldString(a, s, i) {
      typeof s == "string" && (s = k.from(s, i || "utf8")), this.writeFieldBytes(a, s);
    }
  }
  function g(u, a, s) {
    e(Number.isSafeInteger(a), "Number exceeds 2^53-1.");
    do {
      e(s < u.length);
      let i = a & 127;
      a -= a % 128, a /= 128, a !== 0 && (i |= 128), u[s] = i, s += 1;
    } while (a > 0);
    return s;
  }
  function f(u) {
    e(Number.isSafeInteger(u), "Number exceeds 2^53-1.");
    let a = 0, s = 0;
    do {
      e(s < 7);
      let i = u & 127;
      u -= u % 128, u /= 128, u !== 0 && (i |= 128), a *= 256, a += i, s += 1;
    } while (u > 0);
    return a;
  }
  function n(u) {
    e(Number.isSafeInteger(u), "Number exceeds 2^53-1.");
    let a = 0;
    do
      u -= u % 128, u /= 128, a += 1;
    while (u > 0);
    return a;
  }
  return Ra = w, Ra;
}
/*!
 * paymentdetails.js - bip70 paymentdetails for bcoin
 * Copyright (c) 2016-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var Pa, O2;
function il() {
  if (O2) return Pa;
  O2 = 1;
  const e = nt, c = to(), d = ro();
  class w {
    /**
     * Create payment details.
     * @constructor
     * @param {Object?} options
     * @property {String|null} network
     * @property {Object[]} outputs
     * @property {Number} time
     * @property {Number} expires
     * @property {String|null} memo
     * @property {String|null} paymentUrl
     * @property {Buffer|null} merchantData
     */
    constructor(f) {
      this.network = null, this.outputs = [], this.time = Math.floor(Date.now() / 1e3), this.expires = -1, this.memo = null, this.paymentUrl = null, this.merchantData = null, f && this.fromOptions(f);
    }
    /**
     * Inject properties from options.
     * @private
     * @param {Object} options
     * @returns {PaymentDetails}
     */
    fromOptions(f) {
      if (f.network != null && (e(typeof f.network == "string"), this.network = f.network), f.outputs) {
        e(Array.isArray(f.outputs));
        for (const n of f.outputs)
          e(n && typeof n == "object"), e(Number.isSafeInteger(n.value) && n.value >= 0), e(k.isBuffer(n.script)), this.outputs.push(n);
      }
      return f.time != null && (e(Number.isSafeInteger(f.time)), this.time = f.time), f.expires != null && (e(Number.isSafeInteger(f.expires)), this.expires = f.expires), f.memo != null && (e(typeof f.memo == "string"), this.memo = f.memo), f.paymentUrl != null && (e(typeof f.paymentUrl == "string"), this.paymentUrl = f.paymentUrl), f.merchantData && this.setData(f.merchantData), this;
    }
    /**
     * Instantiate payment details from options.
     * @param {Object} options
     * @returns {PaymentDetails}
     */
    static fromOptions(f) {
      return new w().fromOptions(f);
    }
    /**
     * Test whether the payment is expired.
     * @returns {Boolean}
     */
    isExpired() {
      return this.expires === -1 ? !1 : Math.floor(Date.now() / 1e3) > this.expires;
    }
    /**
     * Set payment details.
     * @param {Object} data
     * @param {String?} enc
     */
    setData(f, n) {
      if (f == null || k.isBuffer(f)) {
        this.merchantData = f;
        return;
      }
      if (typeof f != "string") {
        e(!n || n === "json"), this.merchantData = k.from(JSON.stringify(f), "utf8");
        return;
      }
      this.merchantData = k.from(f, n);
    }
    /**
     * Get payment details.
     * @param {String?} enc
     * @returns {String|Object|null}
     */
    getData(f) {
      let n = this.merchantData;
      if (!n)
        return null;
      if (!f)
        return n;
      if (f === "json") {
        n = n.toString("utf8");
        try {
          n = JSON.parse(n);
        } catch {
          return null;
        }
        return n;
      }
      return n.toString(f);
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     * @returns {PaymentDetails}
     */
    fromRaw(f) {
      const n = new c(f);
      for (this.network = n.readFieldString(1, !0); n.nextTag() === 2; ) {
        const u = new c(n.readFieldBytes(2)), a = {
          value: u.readFieldU64(1, !0),
          script: u.readFieldBytes(2, !0)
        };
        this.outputs.push(a);
      }
      return this.time = n.readFieldU64(3), this.expires = n.readFieldU64(4, !0), this.memo = n.readFieldString(5, !0), this.paymentUrl = n.readFieldString(6, !0), this.merchantData = n.readFieldBytes(7, !0), this;
    }
    /**
     * Instantiate payment details from serialized data.
     * @param {Buffer} data
     * @returns {PaymentDetails}
     */
    static fromRaw(f, n) {
      return typeof f == "string" && (f = k.from(f, n)), new w().fromRaw(f);
    }
    /**
     * Serialize the payment details (protobuf).
     * @returns {Buffer}
     */
    toRaw() {
      const f = new d();
      this.network != null && f.writeFieldString(1, this.network);
      for (const n of this.outputs) {
        const u = new d();
        u.writeFieldU64(1, n.value), u.writeFieldBytes(2, n.script), f.writeFieldBytes(2, u.render());
      }
      return f.writeFieldU64(3, this.time), this.expires !== -1 && f.writeFieldU64(4, this.expires), this.memo != null && f.writeFieldString(5, this.memo), this.paymentUrl != null && f.writeFieldString(6, this.paymentUrl), this.merchantData && f.writeFieldString(7, this.merchantData), f.render();
    }
  }
  return Pa = w, Pa;
}
/*!
 * payment.js - bip70 payment for bcoin
 * Copyright (c) 2016-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var ka, _2;
function Sb() {
  if (_2) return ka;
  _2 = 1;
  const e = nt, c = to(), d = ro(), { setData: w, getData: g } = il().prototype;
  class f {
    /**
     * Create a payment.
     * @constructor
     * @param {Object?} options
     * @property {Buffer} merchantData
     * @property {Buffer[]} transactions
     * @property {Buffer[]} refundTo
     * @property {String|null} memo
     */
    constructor(u) {
      this.merchantData = null, this.transactions = [], this.refundTo = [], this.memo = null, u && this.fromOptions(u);
    }
    /**
     * Inject properties from options.
     * @private
     * @param {Object} options
     * @returns {Payment}
     */
    fromOptions(u) {
      if (u.merchantData && this.setData(u.merchantData), u.transactions) {
        e(Array.isArray(u.transactions));
        for (const a of u.transactions)
          e(k.isBuffer(a)), this.transactions.push(a);
      }
      if (u.refundTo) {
        e(Array.isArray(u.refundTo));
        for (const a of u.refundTo)
          e(a && typeof a == "object"), e(Number.isSafeInteger(a.value) && a.value >= 0), e(k.isBuffer(a.script)), this.refundTo.push(a);
      }
      return u.memo != null && (e(typeof u.memo == "string"), this.memo = u.memo), this;
    }
    /**
     * Instantiate payment from options.
     * @param {Object} options
     * @returns {Payment}
     */
    static fromOptions(u) {
      return new f().fromOptions(u);
    }
    /**
     * Set payment details.
     * @param {Object} data
     * @param {String?} enc
     */
    setData(u, a) {
      return w.call(this, u, a);
    }
    /**
     * Get payment details.
     * @param {String?} enc
     * @returns {String|Object|null}
     */
    getData(u) {
      return g.call(this, u);
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     * @returns {Payment}
     */
    fromRaw(u) {
      const a = new c(u);
      for (this.merchantData = a.readFieldBytes(1, !0); a.nextTag() === 2; ) {
        const s = a.readFieldBytes(2);
        this.transactions.push(s);
      }
      for (; a.nextTag() === 3; ) {
        const s = new c(a.readFieldBytes(3)), i = {
          value: s.readFieldU64(1, !0),
          script: s.readFieldBytes(2, !0)
        };
        this.refundTo.push(i);
      }
      return this.memo = a.readFieldString(4, !0), this;
    }
    /**
     * Instantiate payment from serialized data.
     * @param {Buffer} data
     * @returns {Payment}
     */
    static fromRaw(u, a) {
      return typeof u == "string" && (u = k.from(u, a)), new f().fromRaw(u);
    }
    /**
     * Serialize the payment (protobuf).
     * @returns {Buffer}
     */
    toRaw() {
      const u = new d();
      this.merchantData && u.writeFieldBytes(1, this.merchantData);
      for (const a of this.transactions)
        u.writeFieldBytes(2, a);
      for (const a of this.refundTo) {
        const s = new d();
        s.writeFieldU64(1, a.value), s.writeFieldBytes(2, a.script), u.writeFieldBytes(3, s.render());
      }
      return this.memo != null && u.writeFieldString(4, this.memo), u.render();
    }
  }
  return ka = f, ka;
}
/*!
 * paymentack.js - bip70 paymentack for bcoin
 * Copyright (c) 2016-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var Ba, R2;
function _9() {
  if (R2) return Ba;
  R2 = 1;
  const e = nt, c = to(), d = ro(), w = Sb();
  class g {
    /**
     * Create a payment ack.
     * @constructor
     * @param {Object?} options
     * @property {Payment} payment
     * @property {String|null} memo
     */
    constructor(n) {
      this.payment = new w(), this.memo = null, n && this.fromOptions(n);
    }
    /**
     * Inject properties from options.
     * @private
     * @param {Object} options
     * @returns {PaymentACK}
     */
    fromOptions(n) {
      return n.payment && this.payment.fromOptions(n.payment), n.memo != null && (e(typeof n.memo == "string"), this.memo = n.memo), this;
    }
    /**
     * Instantiate payment ack from options.
     * @param {Object} options
     * @returns {PaymentACK}
     */
    static fromOptions(n) {
      return new g().fromOptions(n);
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     * @returns {PaymentACK}
     */
    fromRaw(n) {
      const u = new c(n);
      return this.payment.fromRaw(u.readFieldBytes(1)), this.memo = u.readFieldString(2, !0), this;
    }
    /**
     * Instantiate payment ack from serialized data.
     * @param {Buffer} data
     * @returns {PaymentACK}
     */
    static fromRaw(n, u) {
      return typeof n == "string" && (n = k.from(n, u)), new g().fromRaw(n);
    }
    /**
     * Serialize the payment ack (protobuf).
     * @returns {Buffer}
     */
    toRaw() {
      const n = new d();
      return n.writeFieldBytes(1, this.payment.toRaw()), this.memo != null && n.writeFieldString(2, this.memo), n.render();
    }
  }
  return Ba = g, Ba;
}
var Ma = {}, Na = {};
/*!
 * asn1.js - asn1 parsing for bcoin
 * Copyright (c) 2016-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 *
 * Parts of this software are based on asn1.js.
 * https://github.com/indutny/asn1.js
 *
 * Copyright Fedor Indutny, 2013.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 */
var P2;
function R9() {
  return P2 || (P2 = 1, function(e) {
    const c = kt, d = e;
    d.readTag = function(g) {
      let f = g.readU8();
      const n = (f & 32) === 0;
      if ((f & 31) === 31) {
        let u = f;
        for (f = 0; (u & 128) === 128; )
          u = g.readU8(), f <<= 7, f |= u & 127;
      } else
        f &= 31;
      return {
        type: f,
        primitive: n,
        size: d.readSize(g, n)
      };
    }, d.readSize = function(g, f) {
      let n = g.readU8();
      if (!f && n === 128)
        throw new Error("Indefinite size.");
      if ((n & 128) === 0)
        return n;
      const u = n & 127;
      if (u > 3)
        throw new Error("Length octet is too long.");
      n = 0;
      for (let a = 0; a < u; a++)
        n <<= 8, n |= g.readU8();
      return n;
    }, d.readSeq = function(g) {
      const f = d.implicit(g, 16);
      return g.readBytes(f.size);
    }, d.implicit = function(g, f) {
      const n = d.readTag(g);
      if (n.type !== f)
        throw new Error(`Unexpected tag: ${n.type}.`);
      return n;
    }, d.explicit = function(g, f) {
      const n = g.offset;
      return d.readTag(g).type !== f ? (g.offset = n, !1) : !0;
    }, d.seq = function(g) {
      return c.read(d.readSeq(g), !0);
    }, d.readInt = function(g, f) {
      const n = d.implicit(g, 2), u = g.readBytes(n.size);
      return f ? u.readUIntBE(0, u.length) : u;
    }, d.readExplicitInt = function(g, f, n) {
      return d.explicit(g, f) ? d.readInt(g, n) : -1;
    }, d.readBitstr = function(g) {
      const f = d.implicit(g, 3), n = g.readBytes(f.size);
      return d.alignBitstr(n);
    }, d.readString = function(g) {
      const f = d.readTag(g);
      switch (f.type) {
        case 3: {
          const n = g.readBytes(f.size);
          return d.alignBitstr(n).toString("utf8");
        }
        // Note:
        // Fuck all these.
        case 4:
        // octstr
        case 18:
        // numstr
        case 19:
        // prinstr
        case 20:
        // t61str
        case 21:
        // videostr
        case 22:
        // ia5str
        case 25:
        // graphstr
        case 12:
        // utf8str
        case 26:
        // iso646str
        case 27:
        // genstr
        case 28:
        // unistr
        case 29:
        // charstr
        case 30:
          return g.readString(f.size, "utf8");
        default:
          throw new Error(`Unexpected tag: ${f.type}.`);
      }
    }, d.alignBitstr = function(g) {
      const f = g[0], n = (g.length - 1) * 8 - f, u = g.slice(1), a = 8 - n % 8;
      if (a === 8 || u.length === 0)
        return u;
      const s = k.allocUnsafe(u.length);
      s[0] = u[0] >>> a;
      for (let i = 1; i < u.length; i++)
        s[i] = u[i - 1] << 8 - a, s[i] |= u[i] >>> a;
      return s;
    }, d.readCert = function(g) {
      const f = g;
      return f.start(), g = d.seq(f), {
        tbs: d.readTBS(g),
        sigAlg: d.readAlgIdent(g),
        sig: d.readBitstr(g),
        raw: f.endData(!0)
      };
    }, d.readTBS = function(g) {
      const f = g;
      return f.start(), g = d.seq(f), {
        version: d.readExplicitInt(g, 0, !0),
        serial: d.readInt(g),
        sig: d.readAlgIdent(g),
        issuer: d.readName(g),
        validity: d.readValidity(g),
        subject: d.readName(g),
        pubkey: d.readPubkey(g),
        raw: f.endData(!0)
      };
    }, d.readPubkey = function(g) {
      return g = d.seq(g), {
        alg: d.readAlgIdent(g),
        pubkey: d.readBitstr(g)
      };
    }, d.readName = function(g) {
      const f = [];
      for (g = d.seq(g); g.left(); )
        d.implicit(g, 17), d.implicit(g, 16), f.push({
          type: d.readOID(g),
          value: d.readString(g)
        });
      return f;
    }, d.readValidity = function(g) {
      return g = d.seq(g), {
        notBefore: d.readTime(g),
        notAfter: d.readTime(g)
      };
    }, d.readTime = function(g) {
      const f = d.readTag(g), n = g.readString(f.size, "ascii");
      let u, a, s, i, p, m;
      switch (f.type) {
        case 23:
          u = n.slice(0, 2) | 0, a = n.slice(2, 4) | 0, s = n.slice(4, 6) | 0, i = n.slice(6, 8) | 0, p = n.slice(8, 10) | 0, m = n.slice(10, 12) | 0, u < 70 ? u = 2e3 + u : u = 1900 + u;
          break;
        case 24:
          u = n.slice(0, 4) | 0, a = n.slice(4, 6) | 0, s = n.slice(6, 8) | 0, i = n.slice(8, 10) | 0, p = n.slice(10, 12) | 0, m = n.slice(12, 14) | 0;
          break;
        default:
          throw new Error(`Unexpected tag: ${f.type}.`);
      }
      return Date.UTC(u, a - 1, s, i, p, m, 0) / 1e3;
    }, d.readOID = function(g) {
      const f = d.implicit(g, 6), n = g.readBytes(f.size);
      return d.formatOID(n);
    }, d.formatOID = function(g) {
      const f = c.read(g), n = [];
      let u = 0, a = 0;
      for (; f.left(); )
        a = f.readU8(), u <<= 7, u |= a & 127, (a & 128) === 0 && (n.push(u), u = 0);
      a & 128 && n.push(u);
      const s = n[0] / 40 | 0, i = n[0] % 40;
      return [s, i].concat(n.slice(1)).join(".");
    }, d.readAlgIdent = function(g) {
      let f = null;
      g = d.seq(g);
      const n = d.readOID(g);
      if (g.left() > 0) {
        const u = d.readTag(g);
        f = g.readBytes(u.size), f.length === 0 && (f = null);
      }
      return {
        alg: n,
        params: f
      };
    }, d.readRSAPublic = function(g) {
      return g = d.seq(g), {
        modulus: d.readInt(g),
        publicExponent: d.readInt(g)
      };
    }, d.readRSAPrivate = function(g) {
      return g = d.seq(g), {
        version: d.readInt(g, !0),
        modulus: d.readInt(g),
        publicExponent: d.readInt(g),
        privateExponent: d.readInt(g),
        prime1: d.readInt(g),
        prime2: d.readInt(g),
        exponent1: d.readInt(g),
        exponent2: d.readInt(g),
        coefficient: d.readInt(g)
      };
    }, d.parseRSAPublic = function(g) {
      return d.readRSAPublic(c.read(g, !0));
    }, d.parseRSAPrivate = function(g) {
      return d.readRSAPrivate(c.read(g, !0));
    }, d.parseCert = function(g) {
      return d.readCert(c.read(g, !0));
    }, d.parseTBS = function(g) {
      return d.readTBS(c.read(g, !0));
    };
  }(Na)), Na;
}
var ds = {};
/*!
 * pk.js - public key algorithms for bcoin
 * Copyright (c) 2016-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var k2;
function P9() {
  if (k2) return ds;
  k2 = 1;
  const e = nt, c = yb(), d = cr(), w = rl(), g = Fi(), f = wb(), n = lb(), u = db(), a = bb(), s = gb();
  ds.verify = function(E, v, b, h) {
    const o = i(E);
    if (!o)
      return !1;
    switch (h.alg) {
      case "rsa":
        return f.verify(o, o.digest(v), b, h.data);
      case "ecdsa": {
        const S = p(h.curve);
        return S ? S.verifyDER(o.digest(v), b, h.data) : !1;
      }
      default:
        throw new Error(`Unsupported algorithm: ${h.alg}.`);
    }
  }, ds.sign = function(E, v, b) {
    const h = i(E);
    if (!h)
      throw new Error(`Unsupported hash algorithm: ${E}.`);
    switch (b.alg) {
      case "rsa":
        return f.sign(h, h.digest(v), b.data);
      case "ecdsa": {
        const o = p(b.curve);
        if (!o)
          throw new Error(`Unsupported curve: ${b.curve}.`);
        return o.signDER(h.digest(v), b.data);
      }
      default:
        throw new Error(`Unsupported algorithm: ${b.alg}.`);
    }
  };
  function i(m) {
    switch (e(typeof m == "string"), m) {
      case "sha224":
        return c;
      case "sha256":
        return d;
      case "sha384":
        return w;
      case "sha512":
        return g;
      default:
        return null;
    }
  }
  function p(m) {
    switch (e(typeof m == "string"), m) {
      case "p224":
        return n;
      case "p256":
        return u;
      case "p384":
        return a;
      case "p521":
        return s;
      default:
        return null;
    }
  }
  return ds;
}
/*!
 * x509.js - x509 handling for bcoin
 * Copyright (c) 2016-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var B2;
function Eb() {
  return B2 || (B2 = 1, function(e) {
    const c = nt, d = cr(), w = R9(), g = P9(), f = vb(), n = e;
    n.trusted = /* @__PURE__ */ new Set(), n.allowUntrusted = !1, n.oid = {
      "1.2.840.10040.4.1": { key: "dsa", hash: null },
      "1.2.840.10040.4.2": { key: "dsa", hash: null },
      "1.2.840.10040.4.3": { key: "dsa", hash: "sha1" },
      "1.2.840.113549.1.1.1": { key: "rsa", hash: null },
      "1.2.840.113549.1.1.2": { key: "rsa", hash: "md2" },
      "1.2.840.113549.1.1.3": { key: "rsa", hash: "md4" },
      "1.2.840.113549.1.1.4": { key: "rsa", hash: "md5" },
      "1.2.840.113549.1.1.5": { key: "rsa", hash: "sha1" },
      "1.2.840.113549.1.1.11": { key: "rsa", hash: "sha256" },
      "1.2.840.113549.1.1.12": { key: "rsa", hash: "sha384" },
      "1.2.840.113549.1.1.13": { key: "rsa", hash: "sha512" },
      "1.2.840.113549.1.1.14": { key: "rsa", hash: "sha224" },
      "2.16.840.1.101.3.4.2.8": { key: "rsa", hash: "sha3-256" },
      "2.16.840.1.101.3.4.2.9": { key: "rsa", hash: "sha3-384" },
      "2.16.840.1.101.3.4.2.10": { key: "rsa", hash: "sha3-512" },
      "1.2.840.10045.2.1": { key: "ecdsa", hash: null },
      "1.2.840.10045.4.1": { key: "ecdsa", hash: "sha1" },
      "1.2.840.10045.4.3.1": { key: "ecdsa", hash: "sha224" },
      "1.2.840.10045.4.3.2": { key: "ecdsa", hash: "sha256" },
      "1.2.840.10045.4.3.3": { key: "ecdsa", hash: "sha384" },
      "1.2.840.10045.4.3.4": { key: "ecdsa", hash: "sha512" }
    }, n.curves = {
      "1.3.132.0.33": "p224",
      "1.2.840.10045.3.1.7": "p256",
      "1.3.132.0.34": "p384",
      "1.3.132.0.35": "p521"
    }, n.getSubjectOID = function(a, s) {
      const i = a.tbs.subject;
      for (const p of i)
        if (p.type === s)
          return p.value;
      return null;
    }, n.getCAName = function(a) {
      return n.getSubjectOID(a, "2.5.4.3") || n.getSubjectOID(a, "2.5.4.11") || n.getSubjectOID(a, "2.5.4.10") || "Unknown";
    }, n.isTrusted = function(a) {
      const i = d.digest(a.raw).toString("hex");
      return n.trusted.has(i);
    }, n.setTrust = function(a) {
      c(Array.isArray(a), "Certs must be an array.");
      for (const s of a) {
        c(k.isBuffer(s), "Certificates must be DER.");
        const i = n.parse(s), m = d.digest(i.raw).toString("hex");
        n.trusted.add(m);
      }
    }, n.setFingerprints = function(a) {
      c(Array.isArray(a), "Certs must be an array.");
      for (const s of a) {
        c(k.isBuffer(s), "Fingerprint must be a buffer."), c(s.length === 32, "Fingerprint must be a sha256 hash.");
        const i = s.toString("hex");
        n.trusted.add(i);
      }
    }, n.getKeyAlgorithm = function(a) {
      const s = a.tbs.pubkey.alg.alg, i = n.oid[s];
      if (!i)
        throw new Error(`Unknown key algorithm: ${s}.`);
      return i;
    }, n.getSigAlgorithm = function(a) {
      const s = a.sigAlg.alg, i = n.oid[s];
      if (!i || !i.hash)
        throw new Error(`Unknown signature algorithm: ${s}.`);
      return i;
    }, n.getCurve = function(a) {
      let s;
      try {
        s = w.formatOID(a);
      } catch {
        throw new Error("Could not parse curve OID.");
      }
      const i = n.curves[s];
      if (!i)
        throw new Error(`Unknown ECDSA curve: ${s}.`);
      return i;
    }, n.parse = function(a) {
      try {
        return w.parseCert(a);
      } catch {
        throw new Error("Could not parse DER certificate.");
      }
    }, n.getPublicKey = function(a) {
      const s = n.getKeyAlgorithm(a), i = a.tbs.pubkey.pubkey, p = a.tbs.pubkey.alg.params;
      let m = null;
      if (s.key === "ecdsa") {
        if (!p)
          throw new Error("No curve selected for ECDSA (cert).");
        m = n.getCurve(p);
      }
      return {
        alg: s.key,
        data: i,
        params: p,
        curve: m
      };
    }, n.verifyTime = function(a) {
      const s = a.tbs.validity, i = Math.floor(Date.now() / 1e3);
      return i > s.notBefore && i < s.notAfter;
    }, n.getSigningKey = function(a, s) {
      c(s.length !== 0, "No chain available.");
      const i = n.parse(s[0]), p = n.getPublicKey(i);
      return {
        alg: p.alg,
        data: a,
        params: p.params,
        curve: p.curve
      };
    }, n.signSubject = function(a, s, i, p) {
      const m = n.getSigningKey(i, p);
      return g.sign(a, s, m);
    }, n.getVerifyKey = function(a) {
      if (a.length === 0)
        throw new Error("No verify key available (cert chain).");
      const s = n.parse(a[0]);
      return n.getPublicKey(s);
    }, n.verifySubject = function(a, s, i, p) {
      const m = n.getVerifyKey(p);
      return g.verify(a, s, i, m);
    }, n.parseChain = function(a) {
      const s = [];
      for (const i of a) {
        const p = n.parse(i);
        s.push(p);
      }
      return s;
    }, n.verifyTimes = function(a) {
      for (const s of a)
        if (!n.verifyTime(s))
          return !1;
      return !0;
    }, n.verifyTrust = function(a) {
      if (n.allowUntrusted)
        return !0;
      for (const s of a)
        if (n.isTrusted(s))
          return !0;
      return !1;
    }, n.verifyChain = function(a) {
      const s = n.parseChain(a);
      if (!n.verifyTimes(s))
        throw new Error("Invalid certificate times.");
      for (let i = 1; i < s.length; i++) {
        const p = s[i - 1], m = s[i], E = n.getSigAlgorithm(p), v = n.getPublicKey(m), b = p.tbs.raw, h = p.sig;
        if (!g.verify(E.hash, b, h, v))
          throw new Error(`${E.key} verification failed for chain.`);
      }
      if (!n.verifyTrust(s))
        throw new Error("Certificate chain is untrusted.");
      return !0;
    }, n.setFingerprints(f);
  }(Ma)), Ma;
}
/*!
 * paymentrequest.js - bip70 paymentrequest for bcoin
 * Copyright (c) 2016-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var qa, M2;
function k9() {
  if (M2) return qa;
  M2 = 1;
  const e = nt, c = to(), d = ro(), w = il(), g = Eb();
  class f {
    /**
     * Create a payment request.
     * @constructor
     * @param {Object?} options
     * @property {Number} version
     * @property {String|null} pkiType
     * @property {Buffer|null} pkiData
     * @property {PaymentDetails} paymentDetails
     * @property {Buffer|null} signature
     */
    constructor(s) {
      this.version = -1, this.pkiType = null, this.pkiData = null, this.paymentDetails = new w(), this.signature = null, s && this.fromOptions(s);
    }
    /**
     * Inject properties from options.
     * @private
     * @param {Object} options
     * @returns {PaymentRequest}
     */
    fromOptions(s) {
      return s.version != null && (e((s.version | 0) === s.version), this.version = s.version), s.pkiType != null && (e(typeof s.pkiType == "string"), this.pkiType = s.pkiType), s.pkiData && (e(k.isBuffer(s.pkiData)), this.pkiData = s.pkiData), s.paymentDetails && this.paymentDetails.fromOptions(s.paymentDetails), s.signature && (e(k.isBuffer(s.signature)), this.signature = s.signature), s.chain && this.setChain(s.chain), this;
    }
    /**
     * Instantiate payment request from options.
     * @param {Object} options
     * @returns {PaymentRequest}
     */
    static fromOptions(s) {
      return new f().fromOptions(s);
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     * @returns {PaymentRequest}
     */
    fromRaw(s) {
      const i = new c(s);
      return this.version = i.readFieldU32(1, !0), this.pkiType = i.readFieldString(2, !0), this.pkiData = i.readFieldBytes(3, !0), this.paymentDetails.fromRaw(i.readFieldBytes(4)), this.signature = i.readFieldBytes(5, !0), this;
    }
    /**
     * Instantiate payment request from serialized data.
     * @param {Buffer} data
     * @returns {PaymentRequest}
     */
    static fromRaw(s, i) {
      return typeof s == "string" && (s = k.from(s, i)), new f().fromRaw(s);
    }
    /**
     * Serialize the payment request (protobuf).
     * @returns {Buffer}
     */
    toRaw() {
      const s = new d();
      return this.version !== -1 && s.writeFieldU32(1, this.version), this.pkiType != null && s.writeFieldString(2, this.pkiType), this.pkiData && s.writeFieldBytes(3, this.pkiData), s.writeFieldBytes(4, this.paymentDetails.toRaw()), this.signature && s.writeFieldBytes(5, this.signature), s.render();
    }
    /**
     * Get payment request signature algorithm.
     * @returns {Object|null}
     */
    getAlgorithm() {
      if (!this.pkiType)
        throw new Error("No PKI type available.");
      const s = this.pkiType.split("+");
      if (s.length !== 2)
        throw new Error("Could not parse PKI algorithm.");
      if (s[0] !== "x509")
        throw new Error(`Unknown PKI type: ${s[0]}.`);
      if (s[1] !== "sha1" && s[1] !== "sha256")
        throw new Error(`Unknown hash algorithm: ${s[1]}.`);
      return new n(s[0], s[1]);
    }
    /**
     * Serialize payment request for sighash.
     * @returns {Buffer}
     */
    signatureData() {
      const s = this.signature;
      this.signature = k.alloc(0);
      const i = this.toRaw();
      return this.signature = s, i;
    }
    /**
     * Set x509 certificate chain.
     * @param {Buffer[]} chain
     */
    setChain(s) {
      const i = new d();
      e(Array.isArray(s), "Chain must be an array.");
      for (const p of s)
        e(k.isBuffer(p), "Certificates must be DER."), i.writeFieldBytes(1, p);
      this.pkiData = i.render();
    }
    /**
     * Get x509 certificate chain.
     * @returns {Buffer[]}
     */
    getChain() {
      const s = [];
      if (!this.pkiData)
        return s;
      const i = new c(this.pkiData);
      for (; i.nextTag() === 1; )
        s.push(i.readFieldBytes(1));
      return s;
    }
    /**
     * Sign payment request (chain must be set).
     * @param {Buffer} key
     * @param {Buffer[]?} certs
     */
    sign(s, i) {
      i && this.setChain(i), this.pkiType || (this.pkiType = "x509+sha256");
      const p = this.getAlgorithm(), m = this.signatureData(), E = this.getChain();
      this.signature = g.signSubject(p.hash, m, s, E);
    }
    /**
     * Verify payment request signature.
     * @returns {Boolean}
     */
    verify() {
      if (!this.pkiType || this.pkiType === "none" || !this.signature)
        return !1;
      let s;
      try {
        s = this.getAlgorithm();
      } catch {
        return !1;
      }
      const i = this.signatureData(), p = this.signature, m = this.getChain();
      try {
        return g.verifySubject(s.hash, i, p, m);
      } catch {
        return !1;
      }
    }
    /**
     * Verify x509 certificate chain.
     * @returns {Boolean}
     */
    verifyChain() {
      if (!this.pkiType || this.pkiType === "none")
        return !1;
      try {
        return g.verifyChain(this.getChain());
      } catch {
        return !1;
      }
    }
    /**
     * Get root certificate authority.
     * @returns {Object|null}
     */
    getCA() {
      if (!this.pkiType || this.pkiType === "none")
        throw new Error("No CA found (pkiType).");
      const s = this.getChain();
      if (s.length === 0)
        throw new Error("No CA found (chain).");
      const i = g.parse(s[s.length - 1]);
      return new u(i);
    }
  }
  class n {
    /**
     * Create an algorithm.
     * @constructor
     * @ignore
     */
    constructor(s, i) {
      this.key = s, this.hash = i;
    }
  }
  class u {
    /**
     * Create a CA.
     * @constructor
     * @ignore
     */
    constructor(s) {
      this.name = g.getCAName(s), this.trusted = g.isTrusted(s), this.cert = s;
    }
  }
  return qa = f, qa;
}
/*!
 * b70.js - bip70 for bcoin
 * Copyright (c) 2016-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var N2;
function B9() {
  return N2 || (N2 = 1, oi.certs = vb(), oi.PaymentACK = _9(), oi.PaymentDetails = il(), oi.Payment = Sb(), oi.PaymentRequest = k9(), oi.x509 = Eb()), oi;
}
var za = {}, M9 = "@hansekontor/checkout-components", N9 = "1.3.0", q2 = {
  name: M9,
  version: N9
};
/*!
 * pkg.js - package constants
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * Copyright (c) 2018, bcash developers.
 * https://github.com/bcoin-org/bcash
 */
var z2;
function q9() {
  return z2 || (z2 = 1, function(e) {
    const c = e;
    c.name = q2.name, c.core = "bcash", c.organization = "badger-cash", c.currency = "bitcoin cash", c.unit = "bch", c.base = "satoshi", c.cfg = `${c.core}.conf`, c.url = `https://github.com/${c.organization}/${c.name}`, c.version = q2.version;
  }(za)), za;
}
/*!
 * bcoin.js - a javascript bitcoin library.
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License).
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var T2;
function z9() {
  return T2 || (T2 = 1, function(e, c) {
    const d = c;
    d.set = function(g) {
      return d.Network.set(g), d;
    }, d.btc = Zm(), d.Amount = Ni(), d.URI = eb(), d.coins = Qm(), d.Coins = Xh(), d.CoinEntry = Gs(), d.CoinView = Jh(), d.hd = c9(), d.HDPrivateKey = ob(), d.HDPublicKey = Zh(), e.exports.Mnemonic = Wh(), d.primitives = l9(), d.Address = Ci(), d.Block = el(), d.Coin = Js(), d.Headers = Gn(), d.Input = eo(), d.InvItem = Qs(), d.KeyRing = fb(), d.MerkleBlock = Qh(), d.MTX = cb(), d.Outpoint = dn(), d.Output = Ui(), d.TX = Jn(), d.protocol = b9(), d.consensus = Xt(), d.Network = _r(), d.networks = Dh(), d.policy = ln(), d.script = p9(), d.Opcode = Yh(), d.Script = ii(), d.ScriptNum = Di(), d.SigCache = ub(), d.Stack = Ys(), d.utils = fr(), d.util = ur(), d.bcrypto = E9(), d.bfilter = O9(), d.b70 = B9(), d.pkg = q9();
  }(fs, fs.exports)), fs.exports;
}
var T9 = z9(), Wn = /* @__PURE__ */ lp(T9), C9 = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, Ta = Math.ceil, br = Math.floor, or = "[BigNumber Error] ", C2 = or + "Number primitive has more than 15 significant digits: ", Er = 1e14, xt = 14, Ca = 9007199254740991, Da = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], ai = 1e7, Vt = 1e9;
function Ib(e) {
  var c, d, w, g = S.prototype = { constructor: S, toString: null, valueOf: null }, f = new S(1), n = 20, u = 4, a = -7, s = 21, i = -1e7, p = 1e7, m = !1, E = 1, v = 0, b = {
    prefix: "",
    groupSize: 3,
    secondaryGroupSize: 0,
    groupSeparator: ",",
    decimalSeparator: ".",
    fractionGroupSize: 0,
    fractionGroupSeparator: "",
    // non-breaking space
    suffix: ""
  }, h = "0123456789abcdefghijklmnopqrstuvwxyz", o = !0;
  function S(A, q) {
    var _, F, R, V, fe, ue, ae, D, Q = this;
    if (!(Q instanceof S)) return new S(A, q);
    if (q == null) {
      if (A && A._isBigNumber === !0) {
        Q.s = A.s, !A.c || A.e > p ? Q.c = Q.e = null : A.e < i ? Q.c = [Q.e = 0] : (Q.e = A.e, Q.c = A.c.slice());
        return;
      }
      if ((ue = typeof A == "number") && A * 0 == 0) {
        if (Q.s = 1 / A < 0 ? (A = -A, -1) : 1, A === ~~A) {
          for (V = 0, fe = A; fe >= 10; fe /= 10, V++) ;
          V > p ? Q.c = Q.e = null : (Q.e = V, Q.c = [A]);
          return;
        }
        D = String(A);
      } else {
        if (!C9.test(D = String(A))) return w(Q, D, ue);
        Q.s = D.charCodeAt(0) == 45 ? (D = D.slice(1), -1) : 1;
      }
      (V = D.indexOf(".")) > -1 && (D = D.replace(".", "")), (fe = D.search(/e/i)) > 0 ? (V < 0 && (V = fe), V += +D.slice(fe + 1), D = D.substring(0, fe)) : V < 0 && (V = D.length);
    } else {
      if (Dt(q, 2, h.length, "Base"), q == 10 && o)
        return Q = new S(A), N(Q, n + Q.e + 1, u);
      if (D = String(A), ue = typeof A == "number") {
        if (A * 0 != 0) return w(Q, D, ue, q);
        if (Q.s = 1 / A < 0 ? (D = D.slice(1), -1) : 1, S.DEBUG && D.replace(/^0\.0*|\./, "").length > 15)
          throw Error(C2 + A);
      } else
        Q.s = D.charCodeAt(0) === 45 ? (D = D.slice(1), -1) : 1;
      for (_ = h.slice(0, q), V = fe = 0, ae = D.length; fe < ae; fe++)
        if (_.indexOf(F = D.charAt(fe)) < 0) {
          if (F == ".") {
            if (fe > V) {
              V = ae;
              continue;
            }
          } else if (!R && (D == D.toUpperCase() && (D = D.toLowerCase()) || D == D.toLowerCase() && (D = D.toUpperCase()))) {
            R = !0, fe = -1, V = 0;
            continue;
          }
          return w(Q, String(A), ue, q);
        }
      ue = !1, D = d(D, q, 10, Q.s), (V = D.indexOf(".")) > -1 ? D = D.replace(".", "") : V = D.length;
    }
    for (fe = 0; D.charCodeAt(fe) === 48; fe++) ;
    for (ae = D.length; D.charCodeAt(--ae) === 48; ) ;
    if (D = D.slice(fe, ++ae)) {
      if (ae -= fe, ue && S.DEBUG && ae > 15 && (A > Ca || A !== br(A)))
        throw Error(C2 + Q.s * A);
      if ((V = V - fe - 1) > p)
        Q.c = Q.e = null;
      else if (V < i)
        Q.c = [Q.e = 0];
      else {
        if (Q.e = V, Q.c = [], fe = (V + 1) % xt, V < 0 && (fe += xt), fe < ae) {
          for (fe && Q.c.push(+D.slice(0, fe)), ae -= xt; fe < ae; )
            Q.c.push(+D.slice(fe, fe += xt));
          fe = xt - (D = D.slice(fe)).length;
        } else
          fe -= ae;
        for (; fe--; D += "0") ;
        Q.c.push(+D);
      }
    } else
      Q.c = [Q.e = 0];
  }
  S.clone = Ib, S.ROUND_UP = 0, S.ROUND_DOWN = 1, S.ROUND_CEIL = 2, S.ROUND_FLOOR = 3, S.ROUND_HALF_UP = 4, S.ROUND_HALF_DOWN = 5, S.ROUND_HALF_EVEN = 6, S.ROUND_HALF_CEIL = 7, S.ROUND_HALF_FLOOR = 8, S.EUCLID = 9, S.config = S.set = function(A) {
    var q, _;
    if (A != null)
      if (typeof A == "object") {
        if (A.hasOwnProperty(q = "DECIMAL_PLACES") && (_ = A[q], Dt(_, 0, Vt, q), n = _), A.hasOwnProperty(q = "ROUNDING_MODE") && (_ = A[q], Dt(_, 0, 8, q), u = _), A.hasOwnProperty(q = "EXPONENTIAL_AT") && (_ = A[q], _ && _.pop ? (Dt(_[0], -Vt, 0, q), Dt(_[1], 0, Vt, q), a = _[0], s = _[1]) : (Dt(_, -Vt, Vt, q), a = -(s = _ < 0 ? -_ : _))), A.hasOwnProperty(q = "RANGE"))
          if (_ = A[q], _ && _.pop)
            Dt(_[0], -Vt, -1, q), Dt(_[1], 1, Vt, q), i = _[0], p = _[1];
          else if (Dt(_, -Vt, Vt, q), _)
            i = -(p = _ < 0 ? -_ : _);
          else
            throw Error(or + q + " cannot be zero: " + _);
        if (A.hasOwnProperty(q = "CRYPTO"))
          if (_ = A[q], _ === !!_)
            if (_)
              if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes))
                m = _;
              else
                throw m = !_, Error(or + "crypto unavailable");
            else
              m = _;
          else
            throw Error(or + q + " not true or false: " + _);
        if (A.hasOwnProperty(q = "MODULO_MODE") && (_ = A[q], Dt(_, 0, 9, q), E = _), A.hasOwnProperty(q = "POW_PRECISION") && (_ = A[q], Dt(_, 0, Vt, q), v = _), A.hasOwnProperty(q = "FORMAT"))
          if (_ = A[q], typeof _ == "object") b = _;
          else throw Error(or + q + " not an object: " + _);
        if (A.hasOwnProperty(q = "ALPHABET"))
          if (_ = A[q], typeof _ == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(_))
            o = _.slice(0, 10) == "0123456789", h = _;
          else
            throw Error(or + q + " invalid: " + _);
      } else
        throw Error(or + "Object expected: " + A);
    return {
      DECIMAL_PLACES: n,
      ROUNDING_MODE: u,
      EXPONENTIAL_AT: [a, s],
      RANGE: [i, p],
      CRYPTO: m,
      MODULO_MODE: E,
      POW_PRECISION: v,
      FORMAT: b,
      ALPHABET: h
    };
  }, S.isBigNumber = function(A) {
    if (!A || A._isBigNumber !== !0) return !1;
    if (!S.DEBUG) return !0;
    var q, _, F = A.c, R = A.e, V = A.s;
    e: if ({}.toString.call(F) == "[object Array]") {
      if ((V === 1 || V === -1) && R >= -Vt && R <= Vt && R === br(R)) {
        if (F[0] === 0) {
          if (R === 0 && F.length === 1) return !0;
          break e;
        }
        if (q = (R + 1) % xt, q < 1 && (q += xt), String(F[0]).length == q) {
          for (q = 0; q < F.length; q++)
            if (_ = F[q], _ < 0 || _ >= Er || _ !== br(_)) break e;
          if (_ !== 0) return !0;
        }
      }
    } else if (F === null && R === null && (V === null || V === 1 || V === -1))
      return !0;
    throw Error(or + "Invalid BigNumber: " + A);
  }, S.maximum = S.max = function() {
    return j(arguments, -1);
  }, S.minimum = S.min = function() {
    return j(arguments, 1);
  }, S.random = function() {
    var A = 9007199254740992, q = Math.random() * A & 2097151 ? function() {
      return br(Math.random() * A);
    } : function() {
      return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
    };
    return function(_) {
      var F, R, V, fe, ue, ae = 0, D = [], Q = new S(f);
      if (_ == null ? _ = n : Dt(_, 0, Vt), fe = Ta(_ / xt), m)
        if (crypto.getRandomValues) {
          for (F = crypto.getRandomValues(new Uint32Array(fe *= 2)); ae < fe; )
            ue = F[ae] * 131072 + (F[ae + 1] >>> 11), ue >= 9e15 ? (R = crypto.getRandomValues(new Uint32Array(2)), F[ae] = R[0], F[ae + 1] = R[1]) : (D.push(ue % 1e14), ae += 2);
          ae = fe / 2;
        } else if (crypto.randomBytes) {
          for (F = crypto.randomBytes(fe *= 7); ae < fe; )
            ue = (F[ae] & 31) * 281474976710656 + F[ae + 1] * 1099511627776 + F[ae + 2] * 4294967296 + F[ae + 3] * 16777216 + (F[ae + 4] << 16) + (F[ae + 5] << 8) + F[ae + 6], ue >= 9e15 ? crypto.randomBytes(7).copy(F, ae) : (D.push(ue % 1e14), ae += 7);
          ae = fe / 7;
        } else
          throw m = !1, Error(or + "crypto unavailable");
      if (!m)
        for (; ae < fe; )
          ue = q(), ue < 9e15 && (D[ae++] = ue % 1e14);
      for (fe = D[--ae], _ %= xt, fe && _ && (ue = Da[xt - _], D[ae] = br(fe / ue) * ue); D[ae] === 0; D.pop(), ae--) ;
      if (ae < 0)
        D = [V = 0];
      else {
        for (V = -1; D[0] === 0; D.splice(0, 1), V -= xt) ;
        for (ae = 1, ue = D[0]; ue >= 10; ue /= 10, ae++) ;
        ae < xt && (V -= xt - ae);
      }
      return Q.e = V, Q.c = D, Q;
    };
  }(), S.sum = function() {
    for (var A = 1, q = arguments, _ = new S(q[0]); A < q.length; ) _ = _.plus(q[A++]);
    return _;
  }, d = /* @__PURE__ */ function() {
    var A = "0123456789";
    function q(_, F, R, V) {
      for (var fe, ue = [0], ae, D = 0, Q = _.length; D < Q; ) {
        for (ae = ue.length; ae--; ue[ae] *= F) ;
        for (ue[0] += V.indexOf(_.charAt(D++)), fe = 0; fe < ue.length; fe++)
          ue[fe] > R - 1 && (ue[fe + 1] == null && (ue[fe + 1] = 0), ue[fe + 1] += ue[fe] / R | 0, ue[fe] %= R);
      }
      return ue.reverse();
    }
    return function(_, F, R, V, fe) {
      var ue, ae, D, Q, Z, oe, y, Y, he = _.indexOf("."), be = n, xe = u;
      for (he >= 0 && (Q = v, v = 0, _ = _.replace(".", ""), Y = new S(F), oe = Y.pow(_.length - he), v = Q, Y.c = q(
        Gr(dr(oe.c), oe.e, "0"),
        10,
        R,
        A
      ), Y.e = Y.c.length), y = q(_, F, R, fe ? (ue = h, A) : (ue = A, h)), D = Q = y.length; y[--Q] == 0; y.pop()) ;
      if (!y[0]) return ue.charAt(0);
      if (he < 0 ? --D : (oe.c = y, oe.e = D, oe.s = V, oe = c(oe, Y, be, xe, R), y = oe.c, Z = oe.r, D = oe.e), ae = D + be + 1, he = y[ae], Q = R / 2, Z = Z || ae < 0 || y[ae + 1] != null, Z = xe < 4 ? (he != null || Z) && (xe == 0 || xe == (oe.s < 0 ? 3 : 2)) : he > Q || he == Q && (xe == 4 || Z || xe == 6 && y[ae - 1] & 1 || xe == (oe.s < 0 ? 8 : 7)), ae < 1 || !y[0])
        _ = Z ? Gr(ue.charAt(1), -be, ue.charAt(0)) : ue.charAt(0);
      else {
        if (y.length = ae, Z)
          for (--R; ++y[--ae] > R; )
            y[ae] = 0, ae || (++D, y = [1].concat(y));
        for (Q = y.length; !y[--Q]; ) ;
        for (he = 0, _ = ""; he <= Q; _ += ue.charAt(y[he++])) ;
        _ = Gr(_, D, ue.charAt(0));
      }
      return _;
    };
  }(), c = /* @__PURE__ */ function() {
    function A(F, R, V) {
      var fe, ue, ae, D, Q = 0, Z = F.length, oe = R % ai, y = R / ai | 0;
      for (F = F.slice(); Z--; )
        ae = F[Z] % ai, D = F[Z] / ai | 0, fe = y * ae + D * oe, ue = oe * ae + fe % ai * ai + Q, Q = (ue / V | 0) + (fe / ai | 0) + y * D, F[Z] = ue % V;
      return Q && (F = [Q].concat(F)), F;
    }
    function q(F, R, V, fe) {
      var ue, ae;
      if (V != fe)
        ae = V > fe ? 1 : -1;
      else
        for (ue = ae = 0; ue < V; ue++)
          if (F[ue] != R[ue]) {
            ae = F[ue] > R[ue] ? 1 : -1;
            break;
          }
      return ae;
    }
    function _(F, R, V, fe) {
      for (var ue = 0; V--; )
        F[V] -= ue, ue = F[V] < R[V] ? 1 : 0, F[V] = ue * fe + F[V] - R[V];
      for (; !F[0] && F.length > 1; F.splice(0, 1)) ;
    }
    return function(F, R, V, fe, ue) {
      var ae, D, Q, Z, oe, y, Y, he, be, xe, Ie, ve, C, I, se, t, l, B = F.s == R.s ? 1 : -1, U = F.c, G = R.c;
      if (!U || !U[0] || !G || !G[0])
        return new S(
          // Return NaN if either NaN, or both Infinity or 0.
          !F.s || !R.s || (U ? G && U[0] == G[0] : !G) ? NaN : (
            // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
            U && U[0] == 0 || !G ? B * 0 : B / 0
          )
        );
      for (he = new S(B), be = he.c = [], D = F.e - R.e, B = V + D + 1, ue || (ue = Er, D = pr(F.e / xt) - pr(R.e / xt), B = B / xt | 0), Q = 0; G[Q] == (U[Q] || 0); Q++) ;
      if (G[Q] > (U[Q] || 0) && D--, B < 0)
        be.push(1), Z = !0;
      else {
        for (I = U.length, t = G.length, Q = 0, B += 2, oe = br(ue / (G[0] + 1)), oe > 1 && (G = A(G, oe, ue), U = A(U, oe, ue), t = G.length, I = U.length), C = t, xe = U.slice(0, t), Ie = xe.length; Ie < t; xe[Ie++] = 0) ;
        l = G.slice(), l = [0].concat(l), se = G[0], G[1] >= ue / 2 && se++;
        do {
          if (oe = 0, ae = q(G, xe, t, Ie), ae < 0) {
            if (ve = xe[0], t != Ie && (ve = ve * ue + (xe[1] || 0)), oe = br(ve / se), oe > 1)
              for (oe >= ue && (oe = ue - 1), y = A(G, oe, ue), Y = y.length, Ie = xe.length; q(y, xe, Y, Ie) == 1; )
                oe--, _(y, t < Y ? l : G, Y, ue), Y = y.length, ae = 1;
            else
              oe == 0 && (ae = oe = 1), y = G.slice(), Y = y.length;
            if (Y < Ie && (y = [0].concat(y)), _(xe, y, Ie, ue), Ie = xe.length, ae == -1)
              for (; q(G, xe, t, Ie) < 1; )
                oe++, _(xe, t < Ie ? l : G, Ie, ue), Ie = xe.length;
          } else ae === 0 && (oe++, xe = [0]);
          be[Q++] = oe, xe[0] ? xe[Ie++] = U[C] || 0 : (xe = [U[C]], Ie = 1);
        } while ((C++ < I || xe[0] != null) && B--);
        Z = xe[0] != null, be[0] || be.splice(0, 1);
      }
      if (ue == Er) {
        for (Q = 1, B = be[0]; B >= 10; B /= 10, Q++) ;
        N(he, V + (he.e = Q + D * xt - 1) + 1, fe, Z);
      } else
        he.e = D, he.r = +Z;
      return he;
    };
  }();
  function H(A, q, _, F) {
    var R, V, fe, ue, ae;
    if (_ == null ? _ = u : Dt(_, 0, 8), !A.c) return A.toString();
    if (R = A.c[0], fe = A.e, q == null)
      ae = dr(A.c), ae = F == 1 || F == 2 && (fe <= a || fe >= s) ? ps(ae, fe) : Gr(ae, fe, "0");
    else if (A = N(new S(A), q, _), V = A.e, ae = dr(A.c), ue = ae.length, F == 1 || F == 2 && (q <= V || V <= a)) {
      for (; ue < q; ae += "0", ue++) ;
      ae = ps(ae, V);
    } else if (q -= fe + (F === 2 && V > fe), ae = Gr(ae, V, "0"), V + 1 > ue) {
      if (--q > 0) for (ae += "."; q--; ae += "0") ;
    } else if (q += V - ue, q > 0)
      for (V + 1 == ue && (ae += "."); q--; ae += "0") ;
    return A.s < 0 && R ? "-" + ae : ae;
  }
  function j(A, q) {
    for (var _, F, R = 1, V = new S(A[0]); R < A.length; R++)
      F = new S(A[R]), (!F.s || (_ = vi(V, F)) === q || _ === 0 && V.s === q) && (V = F);
    return V;
  }
  function J(A, q, _) {
    for (var F = 1, R = q.length; !q[--R]; q.pop()) ;
    for (R = q[0]; R >= 10; R /= 10, F++) ;
    return (_ = F + _ * xt - 1) > p ? A.c = A.e = null : _ < i ? A.c = [A.e = 0] : (A.e = _, A.c = q), A;
  }
  w = /* @__PURE__ */ function() {
    var A = /^(-?)0([xbo])(?=\w[\w.]*$)/i, q = /^([^.]+)\.$/, _ = /^\.([^.]+)$/, F = /^-?(Infinity|NaN)$/, R = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
    return function(V, fe, ue, ae) {
      var D, Q = ue ? fe : fe.replace(R, "");
      if (F.test(Q))
        V.s = isNaN(Q) ? null : Q < 0 ? -1 : 1;
      else {
        if (!ue && (Q = Q.replace(A, function(Z, oe, y) {
          return D = (y = y.toLowerCase()) == "x" ? 16 : y == "b" ? 2 : 8, !ae || ae == D ? oe : Z;
        }), ae && (D = ae, Q = Q.replace(q, "$1").replace(_, "0.$1")), fe != Q))
          return new S(Q, D);
        if (S.DEBUG)
          throw Error(or + "Not a" + (ae ? " base " + ae : "") + " number: " + fe);
        V.s = null;
      }
      V.c = V.e = null;
    };
  }();
  function N(A, q, _, F) {
    var R, V, fe, ue, ae, D, Q, Z = A.c, oe = Da;
    if (Z) {
      e: {
        for (R = 1, ue = Z[0]; ue >= 10; ue /= 10, R++) ;
        if (V = q - R, V < 0)
          V += xt, fe = q, ae = Z[D = 0], Q = br(ae / oe[R - fe - 1] % 10);
        else if (D = Ta((V + 1) / xt), D >= Z.length)
          if (F) {
            for (; Z.length <= D; Z.push(0)) ;
            ae = Q = 0, R = 1, V %= xt, fe = V - xt + 1;
          } else
            break e;
        else {
          for (ae = ue = Z[D], R = 1; ue >= 10; ue /= 10, R++) ;
          V %= xt, fe = V - xt + R, Q = fe < 0 ? 0 : br(ae / oe[R - fe - 1] % 10);
        }
        if (F = F || q < 0 || // Are there any non-zero digits after the rounding digit?
        // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
        // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
        Z[D + 1] != null || (fe < 0 ? ae : ae % oe[R - fe - 1]), F = _ < 4 ? (Q || F) && (_ == 0 || _ == (A.s < 0 ? 3 : 2)) : Q > 5 || Q == 5 && (_ == 4 || F || _ == 6 && // Check whether the digit to the left of the rounding digit is odd.
        (V > 0 ? fe > 0 ? ae / oe[R - fe] : 0 : Z[D - 1]) % 10 & 1 || _ == (A.s < 0 ? 8 : 7)), q < 1 || !Z[0])
          return Z.length = 0, F ? (q -= A.e + 1, Z[0] = oe[(xt - q % xt) % xt], A.e = -q || 0) : Z[0] = A.e = 0, A;
        if (V == 0 ? (Z.length = D, ue = 1, D--) : (Z.length = D + 1, ue = oe[xt - V], Z[D] = fe > 0 ? br(ae / oe[R - fe] % oe[fe]) * ue : 0), F)
          for (; ; )
            if (D == 0) {
              for (V = 1, fe = Z[0]; fe >= 10; fe /= 10, V++) ;
              for (fe = Z[0] += ue, ue = 1; fe >= 10; fe /= 10, ue++) ;
              V != ue && (A.e++, Z[0] == Er && (Z[0] = 1));
              break;
            } else {
              if (Z[D] += ue, Z[D] != Er) break;
              Z[D--] = 0, ue = 1;
            }
        for (V = Z.length; Z[--V] === 0; Z.pop()) ;
      }
      A.e > p ? A.c = A.e = null : A.e < i && (A.c = [A.e = 0]);
    }
    return A;
  }
  function z(A) {
    var q, _ = A.e;
    return _ === null ? A.toString() : (q = dr(A.c), q = _ <= a || _ >= s ? ps(q, _) : Gr(q, _, "0"), A.s < 0 ? "-" + q : q);
  }
  return g.absoluteValue = g.abs = function() {
    var A = new S(this);
    return A.s < 0 && (A.s = 1), A;
  }, g.comparedTo = function(A, q) {
    return vi(this, new S(A, q));
  }, g.decimalPlaces = g.dp = function(A, q) {
    var _, F, R, V = this;
    if (A != null)
      return Dt(A, 0, Vt), q == null ? q = u : Dt(q, 0, 8), N(new S(V), A + V.e + 1, q);
    if (!(_ = V.c)) return null;
    if (F = ((R = _.length - 1) - pr(this.e / xt)) * xt, R = _[R]) for (; R % 10 == 0; R /= 10, F--) ;
    return F < 0 && (F = 0), F;
  }, g.dividedBy = g.div = function(A, q) {
    return c(this, new S(A, q), n, u);
  }, g.dividedToIntegerBy = g.idiv = function(A, q) {
    return c(this, new S(A, q), 0, 1);
  }, g.exponentiatedBy = g.pow = function(A, q) {
    var _, F, R, V, fe, ue, ae, D, Q, Z = this;
    if (A = new S(A), A.c && !A.isInteger())
      throw Error(or + "Exponent not an integer: " + z(A));
    if (q != null && (q = new S(q)), ue = A.e > 14, !Z.c || !Z.c[0] || Z.c[0] == 1 && !Z.e && Z.c.length == 1 || !A.c || !A.c[0])
      return Q = new S(Math.pow(+z(Z), ue ? A.s * (2 - bs(A)) : +z(A))), q ? Q.mod(q) : Q;
    if (ae = A.s < 0, q) {
      if (q.c ? !q.c[0] : !q.s) return new S(NaN);
      F = !ae && Z.isInteger() && q.isInteger(), F && (Z = Z.mod(q));
    } else {
      if (A.e > 9 && (Z.e > 0 || Z.e < -1 || (Z.e == 0 ? Z.c[0] > 1 || ue && Z.c[1] >= 24e7 : Z.c[0] < 8e13 || ue && Z.c[0] <= 9999975e7)))
        return V = Z.s < 0 && bs(A) ? -0 : 0, Z.e > -1 && (V = 1 / V), new S(ae ? 1 / V : V);
      v && (V = Ta(v / xt + 2));
    }
    for (ue ? (_ = new S(0.5), ae && (A.s = 1), D = bs(A)) : (R = Math.abs(+z(A)), D = R % 2), Q = new S(f); ; ) {
      if (D) {
        if (Q = Q.times(Z), !Q.c) break;
        V ? Q.c.length > V && (Q.c.length = V) : F && (Q = Q.mod(q));
      }
      if (R) {
        if (R = br(R / 2), R === 0) break;
        D = R % 2;
      } else if (A = A.times(_), N(A, A.e + 1, 1), A.e > 14)
        D = bs(A);
      else {
        if (R = +z(A), R === 0) break;
        D = R % 2;
      }
      Z = Z.times(Z), V ? Z.c && Z.c.length > V && (Z.c.length = V) : F && (Z = Z.mod(q));
    }
    return F ? Q : (ae && (Q = f.div(Q)), q ? Q.mod(q) : V ? N(Q, v, u, fe) : Q);
  }, g.integerValue = function(A) {
    var q = new S(this);
    return A == null ? A = u : Dt(A, 0, 8), N(q, q.e + 1, A);
  }, g.isEqualTo = g.eq = function(A, q) {
    return vi(this, new S(A, q)) === 0;
  }, g.isFinite = function() {
    return !!this.c;
  }, g.isGreaterThan = g.gt = function(A, q) {
    return vi(this, new S(A, q)) > 0;
  }, g.isGreaterThanOrEqualTo = g.gte = function(A, q) {
    return (q = vi(this, new S(A, q))) === 1 || q === 0;
  }, g.isInteger = function() {
    return !!this.c && pr(this.e / xt) > this.c.length - 2;
  }, g.isLessThan = g.lt = function(A, q) {
    return vi(this, new S(A, q)) < 0;
  }, g.isLessThanOrEqualTo = g.lte = function(A, q) {
    return (q = vi(this, new S(A, q))) === -1 || q === 0;
  }, g.isNaN = function() {
    return !this.s;
  }, g.isNegative = function() {
    return this.s < 0;
  }, g.isPositive = function() {
    return this.s > 0;
  }, g.isZero = function() {
    return !!this.c && this.c[0] == 0;
  }, g.minus = function(A, q) {
    var _, F, R, V, fe = this, ue = fe.s;
    if (A = new S(A, q), q = A.s, !ue || !q) return new S(NaN);
    if (ue != q)
      return A.s = -q, fe.plus(A);
    var ae = fe.e / xt, D = A.e / xt, Q = fe.c, Z = A.c;
    if (!ae || !D) {
      if (!Q || !Z) return Q ? (A.s = -q, A) : new S(Z ? fe : NaN);
      if (!Q[0] || !Z[0])
        return Z[0] ? (A.s = -q, A) : new S(Q[0] ? fe : (
          // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
          u == 3 ? -0 : 0
        ));
    }
    if (ae = pr(ae), D = pr(D), Q = Q.slice(), ue = ae - D) {
      for ((V = ue < 0) ? (ue = -ue, R = Q) : (D = ae, R = Z), R.reverse(), q = ue; q--; R.push(0)) ;
      R.reverse();
    } else
      for (F = (V = (ue = Q.length) < (q = Z.length)) ? ue : q, ue = q = 0; q < F; q++)
        if (Q[q] != Z[q]) {
          V = Q[q] < Z[q];
          break;
        }
    if (V && (R = Q, Q = Z, Z = R, A.s = -A.s), q = (F = Z.length) - (_ = Q.length), q > 0) for (; q--; Q[_++] = 0) ;
    for (q = Er - 1; F > ue; ) {
      if (Q[--F] < Z[F]) {
        for (_ = F; _ && !Q[--_]; Q[_] = q) ;
        --Q[_], Q[F] += Er;
      }
      Q[F] -= Z[F];
    }
    for (; Q[0] == 0; Q.splice(0, 1), --D) ;
    return Q[0] ? J(A, Q, D) : (A.s = u == 3 ? -1 : 1, A.c = [A.e = 0], A);
  }, g.modulo = g.mod = function(A, q) {
    var _, F, R = this;
    return A = new S(A, q), !R.c || !A.s || A.c && !A.c[0] ? new S(NaN) : !A.c || R.c && !R.c[0] ? new S(R) : (E == 9 ? (F = A.s, A.s = 1, _ = c(R, A, 0, 3), A.s = F, _.s *= F) : _ = c(R, A, 0, E), A = R.minus(_.times(A)), !A.c[0] && E == 1 && (A.s = R.s), A);
  }, g.multipliedBy = g.times = function(A, q) {
    var _, F, R, V, fe, ue, ae, D, Q, Z, oe, y, Y, he, be, xe = this, Ie = xe.c, ve = (A = new S(A, q)).c;
    if (!Ie || !ve || !Ie[0] || !ve[0])
      return !xe.s || !A.s || Ie && !Ie[0] && !ve || ve && !ve[0] && !Ie ? A.c = A.e = A.s = null : (A.s *= xe.s, !Ie || !ve ? A.c = A.e = null : (A.c = [0], A.e = 0)), A;
    for (F = pr(xe.e / xt) + pr(A.e / xt), A.s *= xe.s, ae = Ie.length, Z = ve.length, ae < Z && (Y = Ie, Ie = ve, ve = Y, R = ae, ae = Z, Z = R), R = ae + Z, Y = []; R--; Y.push(0)) ;
    for (he = Er, be = ai, R = Z; --R >= 0; ) {
      for (_ = 0, oe = ve[R] % be, y = ve[R] / be | 0, fe = ae, V = R + fe; V > R; )
        D = Ie[--fe] % be, Q = Ie[fe] / be | 0, ue = y * D + Q * oe, D = oe * D + ue % be * be + Y[V] + _, _ = (D / he | 0) + (ue / be | 0) + y * Q, Y[V--] = D % he;
      Y[V] = _;
    }
    return _ ? ++F : Y.splice(0, 1), J(A, Y, F);
  }, g.negated = function() {
    var A = new S(this);
    return A.s = -A.s || null, A;
  }, g.plus = function(A, q) {
    var _, F = this, R = F.s;
    if (A = new S(A, q), q = A.s, !R || !q) return new S(NaN);
    if (R != q)
      return A.s = -q, F.minus(A);
    var V = F.e / xt, fe = A.e / xt, ue = F.c, ae = A.c;
    if (!V || !fe) {
      if (!ue || !ae) return new S(R / 0);
      if (!ue[0] || !ae[0]) return ae[0] ? A : new S(ue[0] ? F : R * 0);
    }
    if (V = pr(V), fe = pr(fe), ue = ue.slice(), R = V - fe) {
      for (R > 0 ? (fe = V, _ = ae) : (R = -R, _ = ue), _.reverse(); R--; _.push(0)) ;
      _.reverse();
    }
    for (R = ue.length, q = ae.length, R - q < 0 && (_ = ae, ae = ue, ue = _, q = R), R = 0; q; )
      R = (ue[--q] = ue[q] + ae[q] + R) / Er | 0, ue[q] = Er === ue[q] ? 0 : ue[q] % Er;
    return R && (ue = [R].concat(ue), ++fe), J(A, ue, fe);
  }, g.precision = g.sd = function(A, q) {
    var _, F, R, V = this;
    if (A != null && A !== !!A)
      return Dt(A, 1, Vt), q == null ? q = u : Dt(q, 0, 8), N(new S(V), A, q);
    if (!(_ = V.c)) return null;
    if (R = _.length - 1, F = R * xt + 1, R = _[R]) {
      for (; R % 10 == 0; R /= 10, F--) ;
      for (R = _[0]; R >= 10; R /= 10, F++) ;
    }
    return A && V.e + 1 > F && (F = V.e + 1), F;
  }, g.shiftedBy = function(A) {
    return Dt(A, -Ca, Ca), this.times("1e" + A);
  }, g.squareRoot = g.sqrt = function() {
    var A, q, _, F, R, V = this, fe = V.c, ue = V.s, ae = V.e, D = n + 4, Q = new S("0.5");
    if (ue !== 1 || !fe || !fe[0])
      return new S(!ue || ue < 0 && (!fe || fe[0]) ? NaN : fe ? V : 1 / 0);
    if (ue = Math.sqrt(+z(V)), ue == 0 || ue == 1 / 0 ? (q = dr(fe), (q.length + ae) % 2 == 0 && (q += "0"), ue = Math.sqrt(+q), ae = pr((ae + 1) / 2) - (ae < 0 || ae % 2), ue == 1 / 0 ? q = "5e" + ae : (q = ue.toExponential(), q = q.slice(0, q.indexOf("e") + 1) + ae), _ = new S(q)) : _ = new S(ue + ""), _.c[0]) {
      for (ae = _.e, ue = ae + D, ue < 3 && (ue = 0); ; )
        if (R = _, _ = Q.times(R.plus(c(V, R, D, 1))), dr(R.c).slice(0, ue) === (q = dr(_.c)).slice(0, ue))
          if (_.e < ae && --ue, q = q.slice(ue - 3, ue + 1), q == "9999" || !F && q == "4999") {
            if (!F && (N(R, R.e + n + 2, 0), R.times(R).eq(V))) {
              _ = R;
              break;
            }
            D += 4, ue += 4, F = 1;
          } else {
            (!+q || !+q.slice(1) && q.charAt(0) == "5") && (N(_, _.e + n + 2, 1), A = !_.times(_).eq(V));
            break;
          }
    }
    return N(_, _.e + n + 1, u, A);
  }, g.toExponential = function(A, q) {
    return A != null && (Dt(A, 0, Vt), A++), H(this, A, q, 1);
  }, g.toFixed = function(A, q) {
    return A != null && (Dt(A, 0, Vt), A = A + this.e + 1), H(this, A, q);
  }, g.toFormat = function(A, q, _) {
    var F, R = this;
    if (_ == null)
      A != null && q && typeof q == "object" ? (_ = q, q = null) : A && typeof A == "object" ? (_ = A, A = q = null) : _ = b;
    else if (typeof _ != "object")
      throw Error(or + "Argument not an object: " + _);
    if (F = R.toFixed(A, q), R.c) {
      var V, fe = F.split("."), ue = +_.groupSize, ae = +_.secondaryGroupSize, D = _.groupSeparator || "", Q = fe[0], Z = fe[1], oe = R.s < 0, y = oe ? Q.slice(1) : Q, Y = y.length;
      if (ae && (V = ue, ue = ae, ae = V, Y -= V), ue > 0 && Y > 0) {
        for (V = Y % ue || ue, Q = y.substr(0, V); V < Y; V += ue) Q += D + y.substr(V, ue);
        ae > 0 && (Q += D + y.slice(V)), oe && (Q = "-" + Q);
      }
      F = Z ? Q + (_.decimalSeparator || "") + ((ae = +_.fractionGroupSize) ? Z.replace(
        new RegExp("\\d{" + ae + "}\\B", "g"),
        "$&" + (_.fractionGroupSeparator || "")
      ) : Z) : Q;
    }
    return (_.prefix || "") + F + (_.suffix || "");
  }, g.toFraction = function(A) {
    var q, _, F, R, V, fe, ue, ae, D, Q, Z, oe, y = this, Y = y.c;
    if (A != null && (ue = new S(A), !ue.isInteger() && (ue.c || ue.s !== 1) || ue.lt(f)))
      throw Error(or + "Argument " + (ue.isInteger() ? "out of range: " : "not an integer: ") + z(ue));
    if (!Y) return new S(y);
    for (q = new S(f), D = _ = new S(f), F = ae = new S(f), oe = dr(Y), V = q.e = oe.length - y.e - 1, q.c[0] = Da[(fe = V % xt) < 0 ? xt + fe : fe], A = !A || ue.comparedTo(q) > 0 ? V > 0 ? q : D : ue, fe = p, p = 1 / 0, ue = new S(oe), ae.c[0] = 0; Q = c(ue, q, 0, 1), R = _.plus(Q.times(F)), R.comparedTo(A) != 1; )
      _ = F, F = R, D = ae.plus(Q.times(R = D)), ae = R, q = ue.minus(Q.times(R = q)), ue = R;
    return R = c(A.minus(_), F, 0, 1), ae = ae.plus(R.times(D)), _ = _.plus(R.times(F)), ae.s = D.s = y.s, V = V * 2, Z = c(D, F, V, u).minus(y).abs().comparedTo(
      c(ae, _, V, u).minus(y).abs()
    ) < 1 ? [D, F] : [ae, _], p = fe, Z;
  }, g.toNumber = function() {
    return +z(this);
  }, g.toPrecision = function(A, q) {
    return A != null && Dt(A, 1, Vt), H(this, A, q, 2);
  }, g.toString = function(A) {
    var q, _ = this, F = _.s, R = _.e;
    return R === null ? F ? (q = "Infinity", F < 0 && (q = "-" + q)) : q = "NaN" : (A == null ? q = R <= a || R >= s ? ps(dr(_.c), R) : Gr(dr(_.c), R, "0") : A === 10 && o ? (_ = N(new S(_), n + R + 1, u), q = Gr(dr(_.c), _.e, "0")) : (Dt(A, 2, h.length, "Base"), q = d(Gr(dr(_.c), R, "0"), 10, A, F, !0)), F < 0 && _.c[0] && (q = "-" + q)), q;
  }, g.valueOf = g.toJSON = function() {
    return z(this);
  }, g._isBigNumber = !0, g[Symbol.toStringTag] = "BigNumber", g[Symbol.for("nodejs.util.inspect.custom")] = g.valueOf, e != null && S.set(e), S;
}
function pr(e) {
  var c = e | 0;
  return e > 0 || e === c ? c : c - 1;
}
function dr(e) {
  for (var c, d, w = 1, g = e.length, f = e[0] + ""; w < g; ) {
    for (c = e[w++] + "", d = xt - c.length; d--; c = "0" + c) ;
    f += c;
  }
  for (g = f.length; f.charCodeAt(--g) === 48; ) ;
  return f.slice(0, g + 1 || 1);
}
function vi(e, c) {
  var d, w, g = e.c, f = c.c, n = e.s, u = c.s, a = e.e, s = c.e;
  if (!n || !u) return null;
  if (d = g && !g[0], w = f && !f[0], d || w) return d ? w ? 0 : -u : n;
  if (n != u) return n;
  if (d = n < 0, w = a == s, !g || !f) return w ? 0 : !g ^ d ? 1 : -1;
  if (!w) return a > s ^ d ? 1 : -1;
  for (u = (a = g.length) < (s = f.length) ? a : s, n = 0; n < u; n++) if (g[n] != f[n]) return g[n] > f[n] ^ d ? 1 : -1;
  return a == s ? 0 : a > s ^ d ? 1 : -1;
}
function Dt(e, c, d, w) {
  if (e < c || e > d || e !== br(e))
    throw Error(or + (w || "Argument") + (typeof e == "number" ? e < c || e > d ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(e));
}
function bs(e) {
  var c = e.c.length - 1;
  return pr(e.e / xt) == c && e.c[c] % 2 != 0;
}
function ps(e, c) {
  return (e.length > 1 ? e.charAt(0) + "." + e.slice(1) : e) + (c < 0 ? "e" : "e+") + c;
}
function Gr(e, c, d) {
  var w, g;
  if (c < 0) {
    for (g = d + "."; ++c; g += d) ;
    e = g + e;
  } else if (w = e.length, ++c > w) {
    for (g = d, c -= w; --c; g += d) ;
    e += g;
  } else c < w && (e = e.slice(0, c) + "." + e.slice(c));
  return e;
}
var xr = Ib();
class D9 {
  balances;
  utxos;
  slpBalancesAndUtxos;
  parsedTxHistory;
  constructor() {
    this.balances = {
      totalBalance: 0,
      totalBalanceInSatoshis: 0
    }, this.utxos = [], this.parsedTxHistory = [], this.slpBalancesAndUtxos = {
      tokens: new Ab(),
      slpUtxos: [],
      nonSlpUtxos: []
    };
  }
}
class Ab {
  prod;
  sandbox;
  constructor() {
    this.prod = {
      balance: new xr(0),
      info: {},
      tokenId: ""
    }, this.sandbox = {
      balance: 0,
      info: {
        tokenId: "4075459e0ac841f234bc73fc4fe46fe5490be4ed98bc8ca3f9b898443a5a381a",
        ticker: "BUXs",
        name: "BUX (Sandbox)",
        uri: "",
        hash: "",
        decimals: 4,
        version: 2,
        vaultScriptHash: "16748bbeb9fa3f2bdeb0fc5f7e23dd9ad166ace6"
      },
      tokenId: "4075459e0ac841f234bc73fc4fe46fe5490be4ed98bc8ca3f9b898443a5a381a"
    };
  }
}
const { Mnemonic: U9, HDPrivateKey: F9, KeyRing: H9 } = Wn, L9 = () => new U9({
  language: "english"
}), K9 = (e, c) => {
  const d = e.derivePath(c), w = d.toPublic().publicKey.toString("hex"), g = H9.fromPrivate(d.privateKey, null), f = g.getAddress("string"), n = Oi.decode(f), u = Oi.encode(
    "etoken",
    n.type,
    n.hash
  ), a = g.toSecret(), s = g.getAddress("base58");
  return {
    publicKey: w,
    cashAddress: f,
    slpAddress: u,
    fundingWif: a,
    legacyAddress: s
  };
}, V9 = (e) => {
  const c = F9.fromPhrase(e.getPhrase()), w = K9(c, "m/44'/1899'/0'/0/0"), g = w.cashAddress.slice(12, 17);
  return {
    mnemonic: e,
    name: g,
    Path1899: w,
    state: new D9()
  };
}, $9 = (e, c) => c ? !c.find((g) => g.mnemonic.toString() === e.toString()) : !0, j9 = (e, c) => {
  const d = [e];
  for (let w = 0; w < c.length; w++)
    c[w].name === e.name || d.push(c[w]);
  return d;
};
class Y9 {
  wallets;
  constructor(c = []) {
    this.wallets = c;
  }
}
const Ob = "https://ecash.badger.cash:8332", X9 = async (e) => await (await fetch(`${Ob}/coin/address/${e}?slp=true`)).json(), J9 = (e) => {
  const c = e.nonSlpUtxos.reduce(
    (g, f) => g + f.value,
    0
  );
  return {
    totalBalance: Q9(c),
    totalBalanceInSatoshis: c
  };
}, G9 = (e) => {
  const c = e.filter(
    (f) => !f.slp || f.slp && f.slp.value == "0"
  ), d = e.filter(
    (f) => f.slp && (f.slp.value != "0" || f.slp.type == "MINT")
  ), w = new Ab();
  for (let f = 0; f < d.length; f++) {
    const n = d[f];
    console.log("slputxo i", f, n);
    const u = n.slp.tokenId, a = u === w.prod.tokenId, s = u === w.sandbox.tokenId;
    (a || s) && (n.slp.type === "BATON" || (a ? w.prod.balance = new xr(w.prod.balance).plus(
      new xr(n.slp.value)
    ) : w.sandbox.balance = new xr(w.sandbox.balance).plus(
      new xr(n.slp.value)
    )));
  }
  return {
    tokens: w,
    nonSlpUtxos: c,
    slpUtxos: d
  };
}, W9 = async (e) => {
  const c = `${Ob}/tx/address/${e}?slp=true`;
  return await (await fetch(c)).json();
}, Z9 = (e) => e, Q9 = (e) => {
  const d = new xr(e), w = new xr(10 ** -2);
  return d.times(w).toNumber();
};
class eg {
  listeners;
  constructor() {
    this.listeners = {};
  }
  on(c, d) {
    !!this.listeners[c] || (this.listeners[c] = []), this.listeners[c].push(d);
  }
  off(c, d) {
    !!this.listeners[c] && (this.listeners[c] = this.listeners[c].filter(
      (g) => g !== d
    ));
  }
  emit(c, d) {
    !!this.listeners[c] && this.listeners[c].forEach((g) => g(c, d));
  }
}
const ms = new eg(), { Mnemonic: tg } = Wn, _b = vh({}), rg = ({ children: e }) => {
  const [c, d] = Un(), [w, g] = Un(new Y9()), [f, n] = Un(!1), [u, a] = Un(!1);
  ph(() => {
    s();
  }, []), ph(() => {
    u && w.wallets.length > 0 ? (m(w), n(!1)) : u && n(!1);
  }, [u, w.wallets[0]?.name]);
  const s = async () => {
    console.log("loadCashtabState()"), n(!0);
    const b = await Bl.getItem("wallets");
    if (console.log("loadCashtabState found wallets", b), b) {
      console.log("set stored wallets clause");
      const h = Object.assign(w, { wallets: b });
      console.log("new cashtab state", h), g(h);
    } else
      n(!1);
    a(!0);
  }, i = async (b) => {
    console.log("createWallet()");
    const h = b ? tg.fromPhrase(b) : L9();
    if ($9(h, [])) {
      const S = V9(h);
      console.log("newWallet", S), await p("wallets", [...w.wallets, S]), ms.emit("WALLET_ADDED", "success");
    } else
      console.error("Wallet already exists");
  }, p = async (b, h) => {
    console.log("updateCashtabState key", b, "value", h), g({ ...w, [`${b}`]: h }), n(!0), await Bl.setItem(b, h), n(!1);
  }, m = async (b) => {
    console.log("update()");
    const h = b.wallets[0];
    if (!h)
      throw new Error("No wallet found");
    const o = await X9(h.Path1899.cashAddress), S = G9(o), H = J9(S), j = await W9(h.Path1899.cashAddress), J = Z9(j), N = {
      balances: H,
      utxos: o,
      slpBalancesAndUtxos: S,
      parsedTxHistory: J
    };
    h.state = N;
    const z = b.wallets.slice(1);
    await p("wallets", [h, ...z]), d(h), ms.emit("WALLET_UPDATED", "success");
  };
  return /* @__PURE__ */ Qi(_b, { value: {
    wallet: c,
    cashtab: w,
    createWallet: i,
    activateWallet: async (b) => {
      const h = j9(b, w.wallets);
      await p("wallets", h), ms.emit("WALLET_CHANGED", "success");
    },
    removeWallet: async (b) => {
      const h = w.wallets.filter((o) => o.name !== b.name);
      await p("wallets", h), ms.emit("WALLET_DELETED", "success");
    },
    update: m,
    walletLoading: f
  }, children: e });
}, ig = () => {
  const e = Sh(_b);
  if (!e)
    throw new Error("useWallet must be used within an WalletProvider");
  return e;
}, { Mnemonic: ng } = Wn, D2 = (e) => {
  let c;
  try {
    return c = ng.fromPhrase(e), c.toString() === e;
  } catch (d) {
    return console.error(d), !1;
  }
};
var fi = {}, Ua, U2;
function Rb() {
  return U2 || (U2 = 1, Ua = [
    k.from(
      "ebd41040e4bb3ec742c9e381d31ef2a41a48b6685c96e7cef3c1df6cd4331c99",
      "hex"
    ),
    k.from(
      "ca42dd41745fd0b81eb902362cf9d8bf719da1bd1b1efc946f5b4c99f42c1b9e",
      "hex"
    ),
    k.from(
      "eb04cf5eb1f39afa762f2bb120f296cba520c1b97db1589565b81cb9a17b7244",
      "hex"
    ),
    k.from(
      "6dc47172e01cbcb0bf62580d895fe2b8ac9ad4f873801e0c10b9c837d21eb177",
      "hex"
    ),
    k.from(
      "16af57a9f676b0ab126095aa5ebadef22ab31119d644ac95cd4b93dbf3f26aeb",
      "hex"
    ),
    k.from(
      "687fa451382278fff0c8b11f8d43d576671c6eb2bceab413fb83d965d06d2ff2",
      "hex"
    ),
    k.from(
      "73c176434f1bc6d5adf45b0e76e727287c8de57616c1e6e6141a2b2cbc7d8e4c",
      "hex"
    ),
    k.from(
      "ff856a2d251dcd88d36656f450126798cfabaade40799c722de4d2b5db36a73a",
      "hex"
    ),
    k.from(
      "a0459b9f63b22559f5fa5d4c6db3f9f72ff19342033578f073bf1d1b46cbb912",
      "hex"
    ),
    k.from(
      "a0234f3bc8527ca5628eec81ad5d69895da5680dc91d1cb8477f33f878b95b0b",
      "hex"
    ),
    k.from(
      "69fac9bd55fb0ac78d53bbee5cf1d597989fd0aaab20a25151bdf1733ee7d122",
      "hex"
    ),
    k.from(
      "d7a7a0fb5d7e2731d771e9484ebcdef71d5f0c3e0a2948782bc83ee0ea699ef4",
      "hex"
    ),
    k.from(
      "a45ede3bbbf09c8ae15c72efc07268d693a21c996fd51e67ca079460fd6d8873",
      "hex"
    ),
    k.from(
      "85a0dd7dd720adb7ff05f83d542b209dc7ff4528f7d677b18389fea5e5c49e86",
      "hex"
    ),
    k.from(
      "18f1fc7f205df8adddeb7fe007dd57e3af375a9c4d8d73546bf4f1fed1e18d35",
      "hex"
    ),
    k.from(
      "e75e72ed9f560eec6eb4800073a43fc3ad19195a392282017895974a99026b6c",
      "hex"
    ),
    k.from(
      "7908b40314c138100b518d0735807ffbfcf8518a0095337105ba386b153dd927",
      "hex"
    ),
    k.from(
      "cecddc905099d8dadfc5b1d209b737cbe2c18cfb2c10c0ff0bcf0d3286fc1aa2",
      "hex"
    ),
    k.from(
      "c3846bf24b9e93ca64274c0ec67c1ecc5e024ffcacd2d74019350e81fe546ae4",
      "hex"
    ),
    k.from(
      "1465fa205397b876faa6f0a9958e5590e40fcc7faa4fb7c2c8677521fb5fb658",
      "hex"
    ),
    k.from(
      "7600295eefe85b9e1fd624db76062aaaae59818a54d2774cd4c0b2c01131e1b3",
      "hex"
    ),
    k.from(
      "3e9099b5015e8f486c00bcea9d111ee721faba355a89bcf1df69561e3dc6325c",
      "hex"
    ),
    k.from(
      "4348a0e9444c78cb265e058d5e8944b4d84f9662bd26db257f8934a443c70161",
      "hex"
    ),
    k.from(
      "7431e5f4c3c1ce4690774f0b61e05440883ba9a01ed00ba6abd7806ed3b118cf",
      "hex"
    ),
    k.from(
      "0f993c8aef97baaf5687140ed59ad1821bb4afacf0aa9a58b5d57a338a3afbcb",
      "hex"
    ),
    k.from(
      "0687260331a72403d909f105e69bcf0d32e1bd2493ffc6d9206d11bcd6770739",
      "hex"
    ),
    k.from(
      "62dd0be9b9f50a163ea0f8e75c053b1eca57ea55c8688f647c6881f2c8357b95",
      "hex"
    ),
    k.from(
      "be6c4da2bbb9ba59b6f3939768374246c3c005993fa98f020d1dedbed48a81d5",
      "hex"
    ),
    k.from(
      "37d51006c512eaab626421f1ec8c92013fc5f82ae98ee533eb4619b8deb4d06c",
      "hex"
    ),
    k.from(
      "8d722f81a9c113c0791df136a2966db26c950a971db46b4199f4ea54b78bfb9f",
      "hex"
    ),
    k.from(
      "9acfab7e43c8d880d06b262a94deeee4b4659989c3d0caf19baf6405e41ab7df",
      "hex"
    ),
    k.from(
      "f1c1b50ae5a20dd8030ec9f6bc24823dd367b5255759b4e71b61fce9f7375d73",
      "hex"
    ),
    k.from(
      "4200f5043ac8590ebb527d209ed1503029fbcbd41ca1b506ec27f15ade7dac69",
      "hex"
    ),
    k.from(
      "0c2cd63df7806fa399ede809116b575bf87989f06518f9808c860503178baf66",
      "hex"
    ),
    k.from(
      "15f0ba00a3ac7af3ac884c072b1011a077bd77c097f40164b2f8598abd83860c",
      "hex"
    ),
    k.from(
      "1793927a0614549789adce2f8f34f7f0b66d0f3ae3a3b84d21ec15dbba4fadc7",
      "hex"
    ),
    k.from(
      "41c923866ab4cad6b7ad578081582e020797a6cbdf4fff78ce8396b38937d7f5",
      "hex"
    ),
    k.from(
      "e3b6a2db2ed7ce48842f7ac53241c7b71d54144bfb40c11f3f1d0b42f5eea12d",
      "hex"
    ),
    k.from(
      "b6191a50d0c3977f7da99bcdaac86a227daeb9679ec70ba3b0c9d92271c170d3",
      "hex"
    ),
    k.from(
      "960adf0063e96356750c2965dd0a0867da0b9cbd6e77714aeafb2349ab393da3",
      "hex"
    ),
    k.from(
      "c0a6f4dc63a24bfdcf54ef2a6a082a0a72de35803e2ff5ff527ae5d87206dfd5",
      "hex"
    ),
    k.from(
      "eaa962c4fa4a6bafebe415196d351ccd888d4f53f3fa8ae6d7c466a94e6042bb",
      "hex"
    ),
    k.from(
      "b478b812250df878635c2aa7ec7d155eaa625ee82916e2cd294361886cd1fbd4",
      "hex"
    ),
    k.from(
      "a4310d50af18a6447190372a86afaf8b951ffb431d837f1e5688b45971ed1557",
      "hex"
    ),
    k.from(
      "4b03f45807ad70f21bfc2cae71c9fde4604c064cf5ffb686bae5dbaad7fdd34c",
      "hex"
    ),
    k.from(
      "5edb7ac43b82a06a8761e8d7be4979ebf2611f7dd79bf91c1c6b566a219ed766",
      "hex"
    ),
    k.from(
      "2399561127a57125de8cefea610ddf2fa078b5c8067f4e828290bfb860e84b3c",
      "hex"
    ),
    k.from(
      "69ddd7ea90bb57c93e135dc85ea6fcd5480b603239bdc454fc758b2a26cf7f79",
      "hex"
    ),
    k.from(
      "6c61dac3a2def031506be036d2a6fe401994fbd13df9c8d466599274c446ec98",
      "hex"
    ),
    k.from(
      "668c83947da63b724bece1743c31a0e6aed0db8ec5b31be377bb784f91b6716f",
      "hex"
    ),
    k.from(
      "f9e67d336c51002ac054c632022d66dda2e7e3fff10ad061ed31d8bbb410cfb2",
      "hex"
    ),
    k.from(
      "bf0feefb9e3a581ad5f9e9db7589985743d261085c4d314f6f5d7259aa421612",
      "hex"
    ),
    k.from(
      "3c5f81fea5fab82c64bfa2eaecafcde8e077fc8620a7cae537163df36edbf378",
      "hex"
    ),
    k.from(
      "cbb522d7b7f127ad6a0113865bdf1cd4102e7d0759af635a7cf4720dc963c53b",
      "hex"
    ),
    k.from(
      "04048028bf1f2864d48f9ad4d83294366a828856553f3b14303f90147f5d40ef",
      "hex"
    ),
    k.from(
      "2530cc8e98321502bad96f9b1fba1b099e2d299e0f4548bb914f363bc0d4531f",
      "hex"
    ),
    k.from(
      "063e4afac491dfd332f3089b8542e94617d893d7fe944e10a7937ee29d9693c0",
      "hex"
    ),
    k.from(
      "136335439334a7698016a0d324de72284e079d7b5220bb8fbd747816eebebaca",
      "hex"
    ),
    k.from(
      "45140b3247eb9cc8c5b4f0d7b53091f73292089e6e5a63e2749dd3aca9198eda",
      "hex"
    ),
    k.from(
      "2ce1cb0bf9d2f9e102993fbe215152c3b2dd0cabde1c68e5319b839154dbb7f5",
      "hex"
    ),
    k.from(
      "568d6905a2c88708a4b3025190edcfedb1974a606a13c6e5290fcb2ae63edab5",
      "hex"
    ),
    k.from(
      "0376ab1d54c5f9803ce4b2e201a0ee7eef7b57b636e8a93c9b8d4860c96f5fa7",
      "hex"
    ),
    k.from(
      "0a81ec5a929777f145904af38d5d509f66b5e2c58fcdb531058b0e17f3f0b41b",
      "hex"
    ),
    k.from(
      "70a73f7f376b60074248904534b11482d5bf0e698ecc498df52577ebf2e93b9a",
      "hex"
    ),
    k.from(
      "bd71fdf6da97e4cf62d1647add2581b07d79adf8397eb4ecba9c5e8488821423",
      "hex"
    ),
    k.from(
      "5c58468d55f58e497e743982d2b50010b6d165374acf83a7d4a32db768c4408e",
      "hex"
    ),
    k.from(
      "bfd88fe1101c41ae3e801bf8be56350ee9bad1a6b9bd515edc5c6d5b8711ac44",
      "hex"
    ),
    k.from(
      "513b2cecb810d4cde5dd85391adfc6c2dd60d87bb736d2b521484aa47a0ebef6",
      "hex"
    ),
    k.from(
      "88497f01602f3154246ae28c4d5aef10f1d87ebb76626f4ae0b7f95ba7968799",
      "hex"
    ),
    k.from(
      "bc104f15a48be709dca542a7e1d4b9df6f054527e802eaa92d595444258afe71",
      "hex"
    ),
    k.from(
      "55926084ec963a64b96e2abe01ce0ba86a64fbfebcc7aab5afc155b37fd76066",
      "hex"
    ),
    k.from(
      "c1b48299aba5208fe9630ace55ca68a03eda5a519c8802a0d3a673be8f8e557d",
      "hex"
    ),
    k.from(
      "9a114025197c5bb95d94e63d55cd43790847b646b23cdf11ada4a00eff15fb48",
      "hex"
    ),
    k.from(
      "edf7ebbca27a2a384d387b7d4010c666e2edb4843e4c29b4ae1d5b9332e6b24d",
      "hex"
    ),
    k.from(
      "fd73dad31c644ff1b43bef0ccdda96710b9cd9875eca7e31707af3e96d522bbd",
      "hex"
    ),
    k.from(
      "3e84ba4342908516e77573c0992f0979ca084e4685681ff195ccba8a229b8a76",
      "hex"
    ),
    k.from(
      "49e7a442acf0ea6287050054b52564b650e4f49e42e348d6aa38e039e957b1c1",
      "hex"
    ),
    k.from(
      "eec5496b988ce98625b934092eec2908bed0b0f316c2d4730c84eaf1f3d34881",
      "hex"
    ),
    k.from(
      "e23d4a036d7b70e9f595b1422079d2b91edfbb1fb651a0633eaa8a9dc5f80703",
      "hex"
    ),
    k.from(
      "9a6ec012e1a7da9dbe34194d478ad7c0db1822fb071df12981496ed104384113",
      "hex"
    ),
    k.from(
      "59769007f7685d0fcd50872f9f95d5755a5b2b457d81f3692b610a98672f0e1b",
      "hex"
    ),
    k.from(
      "dd6936fe21f8f077c123a1a521c12224f72255b73e03a7260693e8a24b0fa389",
      "hex"
    ),
    k.from(
      "b0bfd52bb0d7d9bd92bf5d4dc13da255c02c542f378365ea893911f55e55f23c",
      "hex"
    ),
    k.from(
      "91e2f5788d5810eba7ba58737de1548a8ecacd014598bc0b143e041b17052552",
      "hex"
    ),
    k.from(
      "f356bea244b7a91eb35d53ca9ad7864ace018e2d35d5f8f96ddf68a6f41aa474",
      "hex"
    ),
    k.from(
      "8a866fd1b276b57e578e921c65828a2bed58e9f2f288054134b7f1f4bfc9cc74",
      "hex"
    ),
    k.from(
      "8fe4fb0af93a4d0d67db0bebb23e37c71bf325dcbcdd240ea04daf58b47e1840",
      "hex"
    ),
    k.from(
      "88ef81de202eb018452e43f864725cea5fbd1fc2d9d205730709c5d8b8690f46",
      "hex"
    ),
    k.from(
      "7d05ebb682339f8c9451ee094eebfefa7953a114edb2f44949452fab7d2fc185",
      "hex"
    ),
    k.from(
      "7e37cb8b4c47090cab36551ba6f45db840680fba166a952db100717f43053fc2",
      "hex"
    ),
    k.from(
      "cb3ccbb76031e5e0138f8dd39a23f9de47ffc35e43c1144cea27d46a5ab1cb5f",
      "hex"
    ),
    k.from(
      "31ad6648f8104138c738f39ea4320133393e3a18cc02296ef97c2ac9ef6731d0",
      "hex"
    ),
    k.from(
      "552f7bdcf1a7af9e6ce672017f4f12abf77240c78e761ac203d1d9d20ac89988",
      "hex"
    ),
    k.from(
      "52f0e1c4e58ec629291b60317f074671b85d7ea80d5b07273463534b32b40234",
      "hex"
    ),
    k.from(
      "e793c9b02fd8aa13e21c31228accb08119643b749c898964b1746d46c3d4cbd2",
      "hex"
    ),
    k.from(
      "4ff460d54b9c86dabfbcfc5712e0400d2bed3fbc4d4fbdaa86e06adcd2a9ad7a",
      "hex"
    ),
    k.from(
      "bec94911c2955676db6c0a550986d76e3ba005667c442c9762b4fbb773de228c",
      "hex"
    ),
    k.from(
      "179fbc148a3dd00fd24ea13458cc43bfa7f59c8182d783a513f6ebec100c8924",
      "hex"
    ),
    k.from(
      "3c4fb0b95ab8b30032f432b86f535fe172c185d0fd39865837cf36187fa6f428",
      "hex"
    ),
    k.from(
      "4d2491414cfe956746ec4cefa6cf6f72e28a1329432f9d8a907ac4cb5dadc15a",
      "hex"
    ),
    k.from(
      "5d56499be4d2e08bcfcad08a3e38723d50503bde706948e42f55603019e528ae",
      "hex"
    ),
    k.from(
      "30d0895a9a448a262091635522d1f52010b5867acae12c78ef958fd4f4389f2f",
      "hex"
    ),
    k.from(
      "43df5774b03e7fef5fe40d931a7bedf1bb2e6b42738c4e6d3841103d3aa7f339",
      "hex"
    ),
    k.from(
      "02ed0eb28c14da45165c566791700d6451d7fb56f0b2ab1d3b8eb070e56edff5",
      "hex"
    ),
    k.from(
      "5cc3d78e4e1d5e45547a04e6873e64f90cf9536d1ccc2ef800f355c4c5fd70fd",
      "hex"
    ),
    k.from(
      "49351b903444c185ccdc5c693d24d8555cb208d6a8141307699f4af063199d78",
      "hex"
    ),
    k.from(
      "2a99f5bc1174b73cbb1d620884e01c34e51ccb3978da125f0e33268883bf4158",
      "hex"
    ),
    k.from(
      "6b9c08e86eb0f767cfad65cd98b62149e5494a67f5845e7bd1ed019f27b86bd6",
      "hex"
    ),
    k.from(
      "a1339d33281a0b56e557d3d32b1ce7f9367eb094bd5fa72a7e5004c8ded7cafe",
      "hex"
    ),
    k.from(
      "b676f2eddae8775cd36cb0f63cd1d4603961f49e6265ba013a2f0307b6d0b804",
      "hex"
    ),
    k.from(
      "a040929a02ce53b4acf4f2ffc6981ce4496f755e6d45fe0b2a692bcd52523f36",
      "hex"
    ),
    k.from(
      "44b545aa8a25e65a73ca15dc27fc36d24c1cb9953a066539b11582dc487b4833",
      "hex"
    ),
    k.from(
      "152a402bfcdf2cd548054d2275b39c7fca3ec0978078b0f0ea76e561a6c7433e",
      "hex"
    ),
    k.from(
      "6cc05041e6445e74696c4cfbc9f80f543b7eabbb44b4ce6f787c6a9971c42f17",
      "hex"
    ),
    k.from(
      "56c77128d98c18d91b4cfdffbc25ee9103d4758ea2abad826a90f3457d460eb4",
      "hex"
    ),
    k.from(
      "27995829fe6a7515c1bfe848f9c4761db16c225929257bf40d0894f29ea8baf2",
      "hex"
    ),
    k.from(
      "b7c36231706e81078c367cb896198f1e3208dd926949dd8f5709a410f75b6292",
      "hex"
    ),
    k.from(
      "96bcec06264976f37460779acf28c5a7cfe8a3c0aae11a8ffcee05c0bddf08c6",
      "hex"
    ),
    k.from(
      "ebc5570c29018c4d67b1aa127baf12f703b4611ebc17b7dab5573894179b93fa",
      "hex"
    ),
    k.from(
      "8ecde6884f3d87b1125ba31ac3fcb13d7016de7f57cc904fe1cb97c6ae98196e",
      "hex"
    ),
    k.from(
      "1ba5b2aa8c65401a82960118f80bec4f62304d83cec4713a19c39c011ea46db4",
      "hex"
    ),
    k.from(
      "18ce6cfe7bf14e60b2e347b8dfe868cb31d02ebb3ada271569f50343b46db3a4",
      "hex"
    ),
    k.from(
      "e35d28419ed02025cfa69038cd623962458da5c695fbdea3c22b0bfb25897092",
      "hex"
    ),
    k.from(
      "54455f7129c20b1447c418f997168f24c58fc5023bf5da5be2eb6e1dd8902ed5",
      "hex"
    ),
    k.from(
      "46edc3689046d53a453fb3104ab80dcaec658b2660ea1629dd7e867990648716",
      "hex"
    ),
    k.from(
      "bfff8fd04433487d6a8aa60c1a29767a9fc2bbb05e420f713a13b992891d3893",
      "hex"
    ),
    k.from(
      "d40e9c86cd8fe468c1776959f49ea774fa548684b6c406f3909261f4dce2575c",
      "hex"
    ),
    k.from(
      "0753e940378c1bd5e3836e395daea5cb839e5046f1bd0eae1951cf10fec7c965",
      "hex"
    ),
    k.from(
      "5a885db19c01d912c5759388938cafbbdf031ab2d48e91ee15589b42971d039c",
      "hex"
    ),
    k.from(
      "85666a562ee0be5ce925c1d8890a6f76a87ec16d4d7d5f29ea7419cf20123b69",
      "hex"
    ),
    k.from(
      "3417bb06cc6007da1b961c920b8ab4ce3fad820e4aa30b9acbc4a74ebdcebc65",
      "hex"
    ),
    k.from(
      "2e7bf16cc22485a7bbe2aa8696750761b0ae39be3b2fe9d0cc6d4ef73491425c",
      "hex"
    ),
    k.from(
      "22a2c1f7bded704cc1e701b5f408c310880fe956b5de2a4a44f99c873a25a7c8",
      "hex"
    ),
    k.from(
      "67add1166b020ae61b8f5fc96813c04c2aa589960796865572a3c7e737613dfd",
      "hex"
    )
    // R3 (Let's Encrypt)
  ]), Ua;
}
/*!
 * protoreader.js - protobufs for bcoin
 * Copyright (c) 2016-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var Fa, F2;
function io() {
  if (F2) return Fa;
  F2 = 1;
  const e = $e(), c = Ts(), d = {
    VARINT: 0,
    FIXED64: 1,
    DELIMITED: 2,
    START_GROUP: 3,
    END_GROUP: 4,
    FIXED32: 5
  };
  class w extends c {
    /**
     * Create a protoreader.
     * @constructor
     */
    constructor(a, s) {
      super(a, s);
    }
    readVarint() {
      const { size: a, value: s } = g(this.data, this.offset);
      return this.offset += a, s;
    }
    readFieldValue(a, s) {
      const i = this.readField(a, s);
      return i ? (e(i.value != null), i.value) : -1;
    }
    readFieldU64(a, s) {
      const i = this.readField(a, s);
      return i ? (e(i.type === d.VARINT || i.type === d.FIXED64), i.value) : -1;
    }
    readFieldU32(a, s) {
      const i = this.readField(a, s);
      return i ? (e(i.type === d.VARINT || i.type === d.FIXED32), i.value) : -1;
    }
    readFieldBytes(a, s) {
      const i = this.readField(a, s);
      return i ? (e(i.data), i.data) : null;
    }
    readFieldString(a, s, i) {
      const p = this.readField(a, s);
      return p ? (e(p.data), p.data.toString(i || "utf8")) : null;
    }
    nextTag() {
      if (this.left() === 0)
        return -1;
      const a = this.readField();
      return this.seek(-a.size), a.tag;
    }
    readField(a, s) {
      const i = this.offset, p = this.readVarint(), m = new f(p);
      if (a != null && m.tag !== a)
        return e(s, "Non-optional field not present."), this.offset = i, null;
      switch (m.type) {
        case d.VARINT:
          m.value = this.readVarint();
          break;
        case d.FIXED64:
          m.value = this.readU64();
          break;
        case d.DELIMITED:
          m.data = this.readVarBytes();
          break;
        case d.START_GROUP:
          for (m.group = []; ; ) {
            const E = this.readField();
            if (E.type === d.END_GROUP)
              break;
            m.group.push(E);
          }
          break;
        case d.END_GROUP:
          e(!1, "Unexpected end group.");
          break;
        case d.FIXED32:
          m.value = this.readU32();
          break;
        default:
          e(!1, "Bad wire type.");
          break;
      }
      return m.size = this.offset - i, m;
    }
  }
  function g(u, a) {
    let s = 0, i = 128, p = 0;
    for (; i & 128; ) {
      if (a >= u.length) {
        s = 0;
        break;
      }
      switch (i = u[a], p) {
        case 0:
        case 1:
        case 2:
        case 3:
          s += (i & 127) << 7 * p;
          break;
        case 4:
          s += (i & 127) * (1 << 7 * p);
          break;
        default:
          s += (i & 127) * Math.pow(2, 7 * p);
          break;
      }
      a += 1, p += 1, e(p < 7, "Number exceeds 2^53-1.");
    }
    return new n(p, s);
  }
  class f {
    constructor(a) {
      this.tag = a >>> 3, this.type = a & 7, this.size = 0, this.value = 0, this.data = null, this.group = null;
    }
  }
  class n {
    constructor(a, s) {
      this.size = a, this.value = s;
    }
  }
  return Fa = w, Fa;
}
var Ha, H2;
function no() {
  if (H2) return Ha;
  H2 = 1;
  const e = $e(), c = Cs(), d = {
    VARINT: 0,
    DELIMITED: 2
  };
  class w extends c {
    /**
     * Create a protowriter.
     * @constructor
     */
    constructor() {
      super();
    }
    writeVarint(a) {
      const s = n(a);
      switch (s) {
        case 6: {
          const i = f(a);
          this.writeU32BE(i / 65536 | 0), this.writeU16BE(i & 65535);
          break;
        }
        case 5: {
          const i = f(a);
          this.writeU32BE(i / 256 | 0), this.writeU8(i & 255);
          break;
        }
        case 4: {
          const i = f(a);
          this.writeU32BE(i);
          break;
        }
        case 3: {
          const i = f(a);
          this.writeU16BE(i >> 8), this.writeU8(i & 255);
          break;
        }
        case 2: {
          const i = f(a);
          this.writeU16BE(i);
          break;
        }
        case 1: {
          const i = f(a);
          this.writeU8(i);
          break;
        }
        default: {
          const i = k.allocUnsafe(s);
          g(i, a, 0), this.writeBytes(i);
          break;
        }
      }
    }
    writeFieldVarint(a, s) {
      const i = a << 3 | d.VARINT;
      this.writeVarint(i), this.writeVarint(s);
    }
    writeFieldU64(a, s) {
      e(Number.isSafeInteger(s)), this.writeFieldVarint(a, s);
    }
    writeFieldU32(a, s) {
      e(s <= 4294967295), this.writeFieldVarint(a, s);
    }
    writeFieldBytes(a, s) {
      const i = a << 3 | d.DELIMITED;
      this.writeVarint(i), this.writeVarint(s.length), this.writeBytes(s);
    }
    writeFieldString(a, s, i) {
      typeof s == "string" && (s = k.from(s, i || "utf8")), this.writeFieldBytes(a, s);
    }
  }
  function g(u, a, s) {
    e(Number.isSafeInteger(a), "Number exceeds 2^53-1.");
    do {
      e(s < u.length);
      let i = a & 127;
      a -= a % 128, a /= 128, a !== 0 && (i |= 128), u[s] = i, s += 1;
    } while (a > 0);
    return s;
  }
  function f(u) {
    e(Number.isSafeInteger(u), "Number exceeds 2^53-1.");
    let a = 0, s = 0;
    do {
      e(s < 7);
      let i = u & 127;
      u -= u % 128, u /= 128, u !== 0 && (i |= 128), a *= 256, a += i, s += 1;
    } while (u > 0);
    return a;
  }
  function n(u) {
    e(Number.isSafeInteger(u), "Number exceeds 2^53-1.");
    let a = 0;
    do
      u -= u % 128, u /= 128, a += 1;
    while (u > 0);
    return a;
  }
  return Ha = w, Ha;
}
var La, L2;
function nl() {
  if (L2) return La;
  L2 = 1;
  const e = $e(), c = io(), d = no();
  class w {
    /**
     * Create payment details.
     * @constructor
     * @param {Object?} options
     * @property {String|null} network
     * @property {Object[]} outputs
     * @property {Number} time
     * @property {Number} expires
     * @property {String|null} memo
     * @property {String|null} paymentUrl
     * @property {Buffer|null} merchantData
     */
    constructor(f) {
      this.network = null, this.outputs = [], this.time = Math.floor(Date.now() / 1e3), this.expires = -1, this.memo = null, this.paymentUrl = null, this.merchantData = null, f && this.fromOptions(f);
    }
    /**
     * Inject properties from options.
     * @private
     * @param {Object} options
     * @returns {PaymentDetails}
     */
    fromOptions(f) {
      if (f.network != null && (e(typeof f.network == "string"), this.network = f.network), f.outputs) {
        e(Array.isArray(f.outputs));
        for (const n of f.outputs)
          e(n && typeof n == "object"), e(Number.isSafeInteger(n.value) && n.value >= 0), e(k.isBuffer(n.script)), this.outputs.push(n);
      }
      return f.time != null && (e(Number.isSafeInteger(f.time)), this.time = f.time), f.expires != null && (e(Number.isSafeInteger(f.expires)), this.expires = f.expires), f.memo != null && (e(typeof f.memo == "string"), this.memo = f.memo), f.paymentUrl != null && (e(typeof f.paymentUrl == "string"), this.paymentUrl = f.paymentUrl), f.merchantData && this.setData(f.merchantData), this;
    }
    /**
     * Instantiate payment details from options.
     * @param {Object} options
     * @returns {PaymentDetails}
     */
    static fromOptions(f) {
      return new w().fromOptions(f);
    }
    /**
     * Test whether the payment is expired.
     * @returns {Boolean}
     */
    isExpired() {
      return this.expires === -1 ? !1 : Math.floor(Date.now() / 1e3) > this.expires;
    }
    /**
     * Set payment details.
     * @param {Object} data
     * @param {String?} enc
     */
    setData(f, n) {
      if (f == null || k.isBuffer(f)) {
        this.merchantData = f;
        return;
      }
      if (typeof f != "string") {
        e(!n || n === "json"), this.merchantData = k.from(JSON.stringify(f), "utf8");
        return;
      }
      this.merchantData = k.from(f, n);
    }
    /**
     * Get payment details.
     * @param {String?} enc
     * @returns {String|Object|null}
     */
    getData(f) {
      let n = this.merchantData;
      if (!n)
        return null;
      if (!f)
        return n;
      if (f === "json") {
        n = n.toString("utf8");
        try {
          n = JSON.parse(n);
        } catch {
          return null;
        }
        return n;
      }
      return n.toString(f);
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     * @returns {PaymentDetails}
     */
    fromRaw(f) {
      const n = new c(f);
      for (this.network = n.readFieldString(1, !0); n.nextTag() === 2; ) {
        const u = new c(n.readFieldBytes(2)), a = {
          value: u.readFieldU64(1, !0),
          script: u.readFieldBytes(2, !0)
        };
        this.outputs.push(a);
      }
      return this.time = n.readFieldU64(3), this.expires = n.readFieldU64(4, !0), this.memo = n.readFieldString(5, !0), this.paymentUrl = n.readFieldString(6, !0), this.merchantData = n.readFieldBytes(7, !0), this;
    }
    /**
     * Instantiate payment details from serialized data.
     * @param {Buffer} data
     * @returns {PaymentDetails}
     */
    static fromRaw(f, n) {
      return typeof f == "string" && (f = k.from(f, n)), new w().fromRaw(f);
    }
    /**
     * Serialize the payment details (protobuf).
     * @returns {Buffer}
     */
    toRaw() {
      const f = new d();
      this.network != null && f.writeFieldString(1, this.network);
      for (const n of this.outputs) {
        const u = new d();
        u.writeFieldU64(1, n.value), u.writeFieldBytes(2, n.script), f.writeFieldBytes(2, u.render());
      }
      return f.writeFieldU64(3, this.time), this.expires !== -1 && f.writeFieldU64(4, this.expires), this.memo != null && f.writeFieldString(5, this.memo), this.paymentUrl != null && f.writeFieldString(6, this.paymentUrl), this.merchantData && f.writeFieldString(7, this.merchantData), f.render();
    }
  }
  return La = w, La;
}
var Ka, K2;
function Pb() {
  if (K2) return Ka;
  K2 = 1;
  const e = $e(), c = io(), d = no(), { setData: w, getData: g } = nl().prototype;
  class f {
    /**
     * Create a payment.
     * @constructor
     * @param {Object?} options
     * @property {Buffer} merchantData
     * @property {Buffer[]} transactions
     * @property {Buffer[]} refundTo
     * @property {String|null} memo
     */
    constructor(u) {
      this.merchantData = null, this.transactions = [], this.refundTo = [], this.memo = null, u && this.fromOptions(u);
    }
    /**
     * Inject properties from options.
     * @private
     * @param {Object} options
     * @returns {Payment}
     */
    fromOptions(u) {
      if (u.merchantData && this.setData(u.merchantData), u.transactions) {
        e(Array.isArray(u.transactions));
        for (const a of u.transactions)
          e(k.isBuffer(a)), this.transactions.push(a);
      }
      if (u.refundTo) {
        e(Array.isArray(u.refundTo));
        for (const a of u.refundTo)
          e(a && typeof a == "object"), e(Number.isSafeInteger(a.value) && a.value >= 0), e(k.isBuffer(a.script)), this.refundTo.push(a);
      }
      return u.memo != null && (e(typeof u.memo == "string"), this.memo = u.memo), this;
    }
    /**
     * Instantiate payment from options.
     * @param {Object} options
     * @returns {Payment}
     */
    static fromOptions(u) {
      return new f().fromOptions(u);
    }
    /**
     * Set payment details.
     * @param {Object} data
     * @param {String?} enc
     */
    setData(u, a) {
      return w.call(this, u, a);
    }
    /**
     * Get payment details.
     * @param {String?} enc
     * @returns {String|Object|null}
     */
    getData(u) {
      return g.call(this, u);
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     * @returns {Payment}
     */
    fromRaw(u) {
      const a = new c(u);
      for (this.merchantData = a.readFieldBytes(1, !0); a.nextTag() === 2; ) {
        const s = a.readFieldBytes(2);
        this.transactions.push(s);
      }
      for (; a.nextTag() === 3; ) {
        const s = new c(a.readFieldBytes(3)), i = {
          value: s.readFieldU64(1, !0),
          script: s.readFieldBytes(2, !0)
        };
        this.refundTo.push(i);
      }
      return this.memo = a.readFieldString(4, !0), this;
    }
    /**
     * Instantiate payment from serialized data.
     * @param {Buffer} data
     * @returns {Payment}
     */
    static fromRaw(u, a) {
      return typeof u == "string" && (u = k.from(u, a)), new f().fromRaw(u);
    }
    /**
     * Serialize the payment (protobuf).
     * @returns {Buffer}
     */
    toRaw() {
      const u = new d();
      this.merchantData && u.writeFieldBytes(1, this.merchantData);
      for (const a of this.transactions)
        u.writeFieldBytes(2, a);
      for (const a of this.refundTo) {
        const s = new d();
        s.writeFieldU64(1, a.value), s.writeFieldBytes(2, a.script), u.writeFieldBytes(3, s.render());
      }
      return this.memo != null && u.writeFieldString(4, this.memo), u.render();
    }
  }
  return Ka = f, Ka;
}
var Va, V2;
function sg() {
  if (V2) return Va;
  V2 = 1;
  const e = $e(), c = io(), d = no(), w = Pb();
  class g {
    /**
     * Create a payment ack.
     * @constructor
     * @param {Object?} options
     * @property {Payment} payment
     * @property {String|null} memo
     */
    constructor(n) {
      this.payment = new w(), this.memo = null, n && this.fromOptions(n);
    }
    /**
     * Inject properties from options.
     * @private
     * @param {Object} options
     * @returns {PaymentACK}
     */
    fromOptions(n) {
      return n.payment && this.payment.fromOptions(n.payment), n.memo != null && (e(typeof n.memo == "string"), this.memo = n.memo), this;
    }
    /**
     * Instantiate payment ack from options.
     * @param {Object} options
     * @returns {PaymentACK}
     */
    static fromOptions(n) {
      return new g().fromOptions(n);
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     * @returns {PaymentACK}
     */
    fromRaw(n) {
      const u = new c(n);
      return this.payment.fromRaw(u.readFieldBytes(1)), this.memo = u.readFieldString(2, !0), this;
    }
    /**
     * Instantiate payment ack from serialized data.
     * @param {Buffer} data
     * @returns {PaymentACK}
     */
    static fromRaw(n, u) {
      return typeof n == "string" && (n = k.from(n, u)), new g().fromRaw(n);
    }
    /**
     * Serialize the payment ack (protobuf).
     * @returns {Buffer}
     */
    toRaw() {
      const n = new d();
      return n.writeFieldBytes(1, this.payment.toRaw()), this.memo != null && n.writeFieldString(2, this.memo), n.render();
    }
  }
  return Va = g, Va;
}
var $a = {}, ja = {}, gs = {}, Ya = {};
/*!
 * fixed.js - fixed number parsing
 * Copyright (c) 2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var $2;
function kb() {
  return $2 || ($2 = 1, function(e) {
    const c = $e();
    e.encode = function(n, u) {
      c(Number.isSafeInteger(n), "Invalid integer value.");
      let a = "";
      n < 0 && (n = -n, a = "-");
      const s = d(u);
      let i = n % s, p = (n - i) / s;
      for (i = i.toString(10), p = p.toString(10); i.length < u; )
        i = "0" + i;
      return i = i.replace(/0+$/, ""), c(i.length <= u, "Invalid integer value."), i.length === 0 && (i = "0"), u === 0 ? `${a}${p}` : `${a}${p}.${i}`;
    }, e.decode = function(n, u) {
      c(typeof n == "string"), c(n.length <= 32, "Fixed number string too large.");
      let a = 1;
      n.length > 0 && n[0] === "-" && (n = n.substring(1), a = -1);
      let s = n, i = "0";
      const p = n.indexOf(".");
      for (p !== -1 && (s = n.substring(0, p), i = n.substring(p + 1)), s = s.replace(/^0+/, ""), i = i.replace(/0+$/, ""), c(
        s.length <= 16 - u,
        "Fixed number string exceeds 2^53-1."
      ), c(
        i.length <= u,
        "Too many decimal places in fixed number string."
      ), s.length === 0 && (s = "0"); i.length < u; )
        i += "0";
      i.length === 0 && (i = "0"), c(
        /^\d+$/.test(s) && /^\d+$/.test(i),
        "Non-numeric characters in fixed number string."
      ), s = parseInt(s, 10), i = parseInt(i, 10);
      const m = d(u), E = w(m), v = g(m);
      return c(
        s < v || s === v && i <= E,
        "Fixed number string exceeds 2^53-1."
      ), a * (s * m + i);
    }, e.toFloat = function(n, u) {
      return parseFloat(e.encode(n, u));
    }, e.fromFloat = function(n, u) {
      return c(typeof n == "number" && isFinite(n)), c(Number.isSafeInteger(u)), e.decode(n.toFixed(u), u);
    };
    function d(f) {
      switch (f) {
        case 0:
          return 1;
        case 1:
          return 10;
        case 2:
          return 100;
        case 3:
          return 1e3;
        case 4:
          return 1e4;
        case 5:
          return 1e5;
        case 6:
          return 1e6;
        case 7:
          return 1e7;
        case 8:
          return 1e8;
      }
      throw new Error("Exponent is too large.");
    }
    function w(f) {
      switch (f) {
        case 1:
          return 0;
        case 10:
          return 1;
        case 100:
          return 91;
        case 1e3:
          return 991;
        case 1e4:
          return 991;
        case 1e5:
          return 40991;
        case 1e6:
          return 740991;
        case 1e7:
          return 4740991;
        case 1e8:
          return 54740991;
      }
      throw new Error("Exponent is too large.");
    }
    function g(f) {
      switch (f) {
        case 1:
          return 9007199254740991;
        case 10:
          return 900719925474099;
        case 100:
          return 90071992547409;
        case 1e3:
          return 9007199254740;
        case 1e4:
          return 900719925474;
        case 1e5:
          return 90071992547;
        case 1e6:
          return 9007199254;
        case 1e7:
          return 900719925;
        case 1e8:
          return 90071992;
      }
      throw new Error("Exponent is too large.");
    }
  }(Ya)), Ya;
}
/*!
 * amount.js - amount object for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var Xa, j2;
function bi() {
  if (j2) return Xa;
  j2 = 1;
  const e = $e(), c = kb();
  class d {
    /**
     * Create an amount.
     * @constructor
     * @param {(String|Number)?} value
     * @param {String?} unit
     */
    constructor(g, f) {
      this.value = 0, g != null && this.fromOptions(g, f);
    }
    /**
     * Inject properties from options.
     * @private
     * @param {(String|Number)?} value
     * @param {String?} unit
     * @returns {Amount}
     */
    fromOptions(g, f) {
      return typeof f == "string" ? this.from(f, g) : typeof g == "number" ? this.fromValue(g) : this.fromBTC(g);
    }
    /**
     * Get satoshi value.
     * @returns {Amount}
     */
    toValue() {
      return this.value;
    }
    /**
     * Get satoshi string or value.
     * @param {Boolean?} num
     * @returns {String|Amount}
     */
    toSatoshis(g) {
      return g ? this.value : this.value.toString(10);
    }
    /**
     * Get bits string or value.
     * @param {Boolean?} num
     * @returns {String|Amount}
     */
    toBits(g) {
      return d.encode(this.value, 2, g);
    }
    /**
     * Get mbtc string or value.
     * @param {Boolean?} num
     * @returns {String|Amount}
     */
    toMBTC(g) {
      return d.encode(this.value, 5, g);
    }
    /**
     * Get btc string or value.
     * @param {Boolean?} num
     * @returns {String|Amount}
     */
    toBTC(g) {
      return d.encode(this.value, 8, g);
    }
    /**
     * Get unit string or value.
     * @param {String} unit - Can be `sat`,
     * `ubtc`, `bits`, `mbtc`, or `btc`.
     * @param {Boolean?} num
     * @returns {String|Amount}
     */
    to(g, f) {
      switch (g) {
        case "sat":
          return this.toSatoshis(f);
        case "ubtc":
        case "bits":
          return this.toBits(f);
        case "mbtc":
          return this.toMBTC(f);
        case "btc":
          return this.toBTC(f);
      }
      throw new Error(`Unknown unit "${g}".`);
    }
    /**
     * Convert amount to bitcoin string.
     * @returns {String}
     */
    toString() {
      return this.toBTC();
    }
    /**
     * Inject properties from value.
     * @private
     * @param {Amount} value
     * @returns {Amount}
     */
    fromValue(g) {
      return e(
        Number.isSafeInteger(g) && g >= 0,
        "Value must be an int64."
      ), this.value = g, this;
    }
    /**
     * Inject properties from satoshis.
     * @private
     * @param {Number|String} value
     * @returns {Amount}
     */
    fromSatoshis(g) {
      return this.value = d.decode(g, 0), this;
    }
    /**
     * Inject properties from bits.
     * @private
     * @param {Number|String} value
     * @returns {Amount}
     */
    fromBits(g) {
      return this.value = d.decode(g, 2), this;
    }
    /**
     * Inject properties from mbtc.
     * @private
     * @param {Number|String} value
     * @returns {Amount}
     */
    fromMBTC(g) {
      return this.value = d.decode(g, 5), this;
    }
    /**
     * Inject properties from btc.
     * @private
     * @param {Number|String} value
     * @returns {Amount}
     */
    fromBTC(g) {
      return this.value = d.decode(g, 8), this;
    }
    /**
     * Inject properties from unit.
     * @private
     * @param {String} unit
     * @param {Number|String} value
     * @returns {Amount}
     */
    from(g, f) {
      switch (g) {
        case "sat":
          return this.fromSatoshis(f);
        case "ubtc":
        case "bits":
          return this.fromBits(f);
        case "mbtc":
          return this.fromMBTC(f);
        case "btc":
          return this.fromBTC(f);
      }
      throw new Error(`Unknown unit "${g}".`);
    }
    /**
     * Instantiate amount from options.
     * @param {(String|Number)?} value
     * @param {String?} unit
     * @returns {Amount}
     */
    static fromOptions(g, f) {
      return new this().fromOptions(g, f);
    }
    /**
     * Instantiate amount from value.
     * @private
     * @param {Amount} value
     * @returns {Amount}
     */
    static fromValue(g) {
      return new this().fromValue(g);
    }
    /**
     * Instantiate amount from satoshis.
     * @param {Number|String} value
     * @returns {Amount}
     */
    static fromSatoshis(g) {
      return new this().fromSatoshis(g);
    }
    /**
     * Instantiate amount from bits.
     * @param {Number|String} value
     * @returns {Amount}
     */
    static fromBits(g) {
      return new this().fromBits(g);
    }
    /**
     * Instantiate amount from mbtc.
     * @param {Number|String} value
     * @returns {Amount}
     */
    static fromMBTC(g) {
      return new this().fromMBTC(g);
    }
    /**
     * Instantiate amount from btc.
     * @param {Number|String} value
     * @returns {Amount}
     */
    static fromBTC(g) {
      return new this().fromBTC(g);
    }
    /**
     * Instantiate amount from unit.
     * @param {String} unit
     * @param {Number|String} value
     * @returns {Amount}
     */
    static from(g, f) {
      return new this().from(g, f);
    }
    /**
     * Inspect amount.
     * @returns {String}
     */
    inspect() {
      return `<Amount: ${this.toString()}>`;
    }
    /**
     * Safely convert satoshis to a BTC string.
     * This function explicitly avoids any
     * floating point arithmetic.
     * @param {Amount} value - Satoshis.
     * @returns {String} BTC string.
     */
    static btc(g, f) {
      return typeof g == "string" ? g : d.encode(g, 8, f);
    }
    /**
     * Safely convert a BTC string to satoshis.
     * @param {String} str - BTC
     * @returns {Amount} Satoshis.
     * @throws on parse error
     */
    static value(g) {
      return typeof g == "number" ? g : d.decode(g, 8);
    }
    /**
     * Safely convert satoshis to a BTC string.
     * @param {Amount} value
     * @param {Number} exp - Exponent.
     * @param {Boolean} num - Return a number.
     * @returns {String|Number}
     */
    static encode(g, f, n) {
      return n ? c.toFloat(g, f) : c.encode(g, f);
    }
    /**
     * Safely convert a BTC string to satoshis.
     * @param {String|Number} value - BTC
     * @param {Number} exp - Exponent.
     * @returns {Amount} Satoshis.
     * @throws on parse error
     */
    static decode(g, f) {
      return typeof g == "number" ? c.fromFloat(g, f) : c.decode(g, f);
    }
  }
  return Xa = d, Xa;
}
/*!
 * assert.js - assert for bcrypto
 * Copyright (c) 2020, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var Ja, Y2;
function Mt() {
  if (Y2) return Ja;
  Y2 = 1;
  function e(c, d) {
    if (!c) {
      const w = new Error(d || "Assertion failed");
      throw Error.captureStackTrace && Error.captureStackTrace(w, e), w;
    }
  }
  return Ja = e, Ja;
}
var Ga, X2;
function ni() {
  if (X2) return Ga;
  X2 = 1;
  const e = Mt();
  class c {
    /**
     * Create an HMAC.
     * @param {Function} Hash
     * @param {Number} size
     * @param {Array} [x=[]]
     * @param {Array} [y=[]]
     */
    constructor(w, g, f = [], n = []) {
      e(typeof w == "function"), e(g >>> 0 === g), e(Array.isArray(f)), e(Array.isArray(n)), this.hash = w, this.size = g, this.x = f, this.y = n, this.inner = new w(), this.outer = new w();
    }
    /**
     * Initialize HMAC context.
     * @param {Buffer} data
     */
    init(w) {
      if (e(k.isBuffer(w)), w.length > this.size) {
        const f = this.hash, n = new f();
        n.init(...this.x), n.update(w), w = n.final(...this.y), e(w.length <= this.size);
      }
      const g = k.alloc(this.size);
      for (let f = 0; f < w.length; f++)
        g[f] = w[f] ^ 54;
      for (let f = w.length; f < g.length; f++)
        g[f] = 54;
      this.inner.init(...this.x), this.inner.update(g);
      for (let f = 0; f < w.length; f++)
        g[f] = w[f] ^ 92;
      for (let f = w.length; f < g.length; f++)
        g[f] = 92;
      return this.outer.init(...this.x), this.outer.update(g), this;
    }
    /**
     * Update HMAC context.
     * @param {Buffer} data
     */
    update(w) {
      return this.inner.update(w), this;
    }
    /**
     * Finalize HMAC context.
     * @returns {Buffer}
     */
    final() {
      return this.outer.update(this.inner.final(...this.y)), this.outer.final(...this.y);
    }
  }
  return Ga = c, Ga;
}
var Wa, J2;
function wr() {
  if (J2) return Wa;
  J2 = 1;
  const e = Mt(), c = ni(), d = -1, w = k.alloc(8, 0), g = k.alloc(64, 0);
  g[0] = 128;
  const f = new Uint32Array([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ]);
  class n {
    constructor() {
      this.state = new Uint32Array(8), this.msg = new Uint32Array(64), this.block = k.alloc(64), this.size = d;
    }
    init() {
      return this.state[0] = 1779033703, this.state[1] = 3144134277, this.state[2] = 1013904242, this.state[3] = 2773480762, this.state[4] = 1359893119, this.state[5] = 2600822924, this.state[6] = 528734635, this.state[7] = 1541459225, this.size = 0, this;
    }
    update(h) {
      return e(k.isBuffer(h)), this._update(h, h.length), this;
    }
    final() {
      return this._final(k.alloc(32));
    }
    _update(h, o) {
      e(this.size !== d, "Context is not initialized.");
      let S = this.size & 63, H = 0;
      if (this.size += o, S > 0) {
        let j = 64 - S;
        if (j > o && (j = o), h.copy(this.block, S, H, H + j), S += j, o -= j, H += j, S < 64)
          return;
        this._transform(this.block, 0);
      }
      for (; o >= 64; )
        this._transform(h, H), H += 64, o -= 64;
      o > 0 && h.copy(this.block, 0, H, H + o);
    }
    _final(h) {
      e(this.size !== d, "Context is not initialized.");
      const o = this.size & 63, S = this.size * 8;
      v(w, S * (1 / 4294967296) >>> 0, 0), v(w, S >>> 0, 4), this._update(g, 1 + (119 - o & 63)), this._update(w, 8);
      for (let H = 0; H < 8; H++)
        v(h, this.state[H], H * 4), this.state[H] = 0;
      for (let H = 0; H < 64; H++)
        this.msg[H] = 0;
      for (let H = 0; H < 64; H++)
        this.block[H] = 0;
      return this.size = d, h;
    }
    _transform(h, o) {
      const S = this.msg;
      let H = this.state[0], j = this.state[1], J = this.state[2], N = this.state[3], z = this.state[4], A = this.state[5], q = this.state[6], _ = this.state[7], F = 0;
      for (; F < 16; F++)
        S[F] = E(h, o + F * 4);
      for (; F < 64; F++)
        S[F] = i(S[F - 2]) + S[F - 7] + s(S[F - 15]) + S[F - 16];
      for (F = 0; F < 64; F++) {
        const R = _ + a(z) + p(z, A, q) + f[F] + S[F], V = u(H) + m(H, j, J);
        _ = q, q = A, A = z, z = N + R >>> 0, N = J, J = j, j = H, H = R + V >>> 0;
      }
      this.state[0] += H, this.state[1] += j, this.state[2] += J, this.state[3] += N, this.state[4] += z, this.state[5] += A, this.state[6] += q, this.state[7] += _;
    }
    static hash() {
      return new n();
    }
    static hmac() {
      return new c(n, 64);
    }
    static digest(h) {
      return n.ctx.init().update(h).final();
    }
    static root(h, o) {
      return e(k.isBuffer(h) && h.length === 32), e(k.isBuffer(o) && o.length === 32), n.ctx.init().update(h).update(o).final();
    }
    static multi(h, o, S) {
      const { ctx: H } = n;
      return H.init(), H.update(h), H.update(o), S && H.update(S), H.final();
    }
    static mac(h, o) {
      return n.hmac().init(o).update(h).final();
    }
  }
  n.native = 0, n.id = "SHA256", n.size = 32, n.bits = 256, n.blockSize = 64, n.zero = k.alloc(32, 0), n.ctx = new n();
  function u(b) {
    return (b >>> 2 | b << 30) ^ (b >>> 13 | b << 19) ^ (b >>> 22 | b << 10);
  }
  function a(b) {
    return (b >>> 6 | b << 26) ^ (b >>> 11 | b << 21) ^ (b >>> 25 | b << 7);
  }
  function s(b) {
    return (b >>> 7 | b << 25) ^ (b >>> 18 | b << 14) ^ b >>> 3;
  }
  function i(b) {
    return (b >>> 17 | b << 15) ^ (b >>> 19 | b << 13) ^ b >>> 10;
  }
  function p(b, h, o) {
    return o ^ b & (h ^ o);
  }
  function m(b, h, o) {
    return b & h | o & (b | h);
  }
  function E(b, h) {
    return b[h++] * 16777216 + b[h++] * 65536 + b[h++] * 256 + b[h];
  }
  function v(b, h, o) {
    return b[o++] = h >>> 24, b[o++] = h >>> 16, b[o++] = h >>> 8, b[o++] = h, o;
  }
  return Wa = n, Wa;
}
var Za, G2;
function sl() {
  if (G2) return Za;
  G2 = 1;
  const e = Mt(), c = ni(), d = -1, w = k.alloc(8, 0), g = k.alloc(64, 0);
  g[0] = 128;
  const f = new Uint8Array([
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    7,
    4,
    13,
    1,
    10,
    6,
    15,
    3,
    12,
    0,
    9,
    5,
    2,
    14,
    11,
    8,
    3,
    10,
    14,
    4,
    9,
    15,
    8,
    1,
    2,
    7,
    0,
    6,
    13,
    11,
    5,
    12,
    1,
    9,
    11,
    10,
    0,
    8,
    12,
    4,
    13,
    3,
    7,
    15,
    14,
    5,
    6,
    2,
    4,
    0,
    5,
    9,
    7,
    12,
    2,
    10,
    14,
    1,
    3,
    8,
    11,
    6,
    15,
    13
  ]), n = new Uint8Array([
    5,
    14,
    7,
    0,
    9,
    2,
    11,
    4,
    13,
    6,
    15,
    8,
    1,
    10,
    3,
    12,
    6,
    11,
    3,
    7,
    0,
    13,
    5,
    10,
    14,
    15,
    8,
    12,
    4,
    9,
    1,
    2,
    15,
    5,
    1,
    3,
    7,
    14,
    6,
    9,
    11,
    8,
    12,
    2,
    10,
    0,
    4,
    13,
    8,
    6,
    4,
    1,
    3,
    11,
    15,
    0,
    5,
    12,
    2,
    13,
    9,
    7,
    10,
    14,
    12,
    15,
    10,
    4,
    1,
    5,
    8,
    7,
    6,
    2,
    13,
    14,
    0,
    3,
    9,
    11
  ]), u = new Uint8Array([
    11,
    14,
    15,
    12,
    5,
    8,
    7,
    9,
    11,
    13,
    14,
    15,
    6,
    7,
    9,
    8,
    7,
    6,
    8,
    13,
    11,
    9,
    7,
    15,
    7,
    12,
    15,
    9,
    11,
    7,
    13,
    12,
    11,
    13,
    6,
    7,
    14,
    9,
    13,
    15,
    14,
    8,
    13,
    6,
    5,
    12,
    7,
    5,
    11,
    12,
    14,
    15,
    14,
    15,
    9,
    8,
    9,
    14,
    5,
    6,
    8,
    6,
    5,
    12,
    9,
    15,
    5,
    11,
    6,
    8,
    13,
    12,
    5,
    12,
    13,
    14,
    11,
    8,
    5,
    6
  ]), a = new Uint8Array([
    8,
    9,
    9,
    11,
    13,
    15,
    15,
    5,
    7,
    7,
    8,
    11,
    14,
    14,
    12,
    6,
    9,
    13,
    15,
    7,
    12,
    8,
    9,
    11,
    7,
    7,
    12,
    7,
    6,
    15,
    13,
    11,
    9,
    7,
    15,
    11,
    8,
    6,
    6,
    14,
    12,
    13,
    5,
    14,
    13,
    13,
    7,
    5,
    15,
    5,
    8,
    11,
    14,
    14,
    6,
    14,
    6,
    9,
    12,
    9,
    12,
    5,
    15,
    8,
    8,
    5,
    12,
    9,
    12,
    5,
    14,
    6,
    8,
    13,
    6,
    5,
    15,
    13,
    11,
    11
  ]);
  class s {
    constructor() {
      this.state = new Uint32Array(5), this.msg = new Uint32Array(16), this.block = k.alloc(64), this.size = d;
    }
    init() {
      return this.state[0] = 1732584193, this.state[1] = 4023233417, this.state[2] = 2562383102, this.state[3] = 271733878, this.state[4] = 3285377520, this.size = 0, this;
    }
    update(o) {
      return e(k.isBuffer(o)), this._update(o, o.length), this;
    }
    final() {
      return this._final(k.alloc(20));
    }
    _update(o, S) {
      e(this.size !== d, "Context is not initialized.");
      let H = this.size & 63, j = 0;
      if (this.size += S, H > 0) {
        let J = 64 - H;
        if (J > S && (J = S), o.copy(this.block, H, j, j + J), H += J, S -= J, j += J, H < 64)
          return;
        this._transform(this.block, 0);
      }
      for (; S >= 64; )
        this._transform(o, j), j += 64, S -= 64;
      S > 0 && o.copy(this.block, 0, j, j + S);
    }
    _final(o) {
      e(this.size !== d, "Context is not initialized.");
      const S = this.size & 63, H = this.size * 8;
      b(w, H >>> 0, 0), b(w, H * (1 / 4294967296) >>> 0, 4), this._update(g, 1 + (119 - S & 63)), this._update(w, 8);
      for (let j = 0; j < 5; j++)
        b(o, this.state[j], j * 4), this.state[j] = 0;
      for (let j = 0; j < 16; j++)
        this.msg[j] = 0;
      for (let j = 0; j < 64; j++)
        this.block[j] = 0;
      return this.size = d, o;
    }
    _transform(o, S) {
      const H = this.msg;
      let j = this.state[0], J = this.state[1], N = this.state[2], z = this.state[3], A = this.state[4], q = j, _ = J, F = N, R = z, V = A;
      for (let ue = 0; ue < 16; ue++)
        H[ue] = v(o, S + ue * 4);
      for (let ue = 0; ue < 80; ue++) {
        let ae = j + p(ue, J, N, z) + H[f[ue]] + m(ue), D = i(ae, u[ue]), Q = D + A;
        j = A, A = z, z = i(N, 10), N = J, J = Q, ae = q + p(79 - ue, _, F, R) + H[n[ue]] + E(ue), D = i(ae, a[ue]), Q = D + V, q = V, V = R, R = i(F, 10), F = _, _ = Q;
      }
      const fe = this.state[1] + N + R;
      this.state[1] = this.state[2] + z + V, this.state[2] = this.state[3] + A + q, this.state[3] = this.state[4] + j + _, this.state[4] = this.state[0] + J + F, this.state[0] = fe;
    }
    static hash() {
      return new s();
    }
    static hmac() {
      return new c(s, 64);
    }
    static digest(o) {
      return s.ctx.init().update(o).final();
    }
    static root(o, S) {
      return e(k.isBuffer(o) && o.length === 20), e(k.isBuffer(S) && S.length === 20), s.ctx.init().update(o).update(S).final();
    }
    static multi(o, S, H) {
      const { ctx: j } = s;
      return j.init(), j.update(o), j.update(S), H && j.update(H), j.final();
    }
    static mac(o, S) {
      return s.hmac().init(S).update(o).final();
    }
  }
  s.native = 0, s.id = "RIPEMD160", s.size = 20, s.bits = 160, s.blockSize = 64, s.zero = k.alloc(20, 0), s.ctx = new s();
  function i(h, o) {
    return h << o | h >>> 32 - o;
  }
  function p(h, o, S, H) {
    return h <= 15 ? o ^ S ^ H : h <= 31 ? o & S | ~o & H : h <= 47 ? (o | ~S) ^ H : h <= 63 ? o & H | S & ~H : o ^ (S | ~H);
  }
  function m(h) {
    return h <= 15 ? 0 : h <= 31 ? 1518500249 : h <= 47 ? 1859775393 : h <= 63 ? 2400959708 : 2840853838;
  }
  function E(h) {
    return h <= 15 ? 1352829926 : h <= 31 ? 1548603684 : h <= 47 ? 1836072691 : h <= 63 ? 2053994217 : 0;
  }
  function v(h, o) {
    return h[o++] + h[o++] * 256 + h[o++] * 65536 + h[o] * 16777216;
  }
  function b(h, o, S) {
    return h[S++] = o, o >>>= 8, h[S++] = o, o >>>= 8, h[S++] = o, o >>>= 8, h[S++] = o, S;
  }
  return Za = s, Za;
}
var Qa, W2;
function Hi() {
  if (W2) return Qa;
  W2 = 1;
  const e = Mt(), c = wr(), d = sl(), w = ni(), g = new d();
  class f {
    constructor() {
      this.ctx = new c();
    }
    init() {
      return this.ctx.init(), this;
    }
    update(u) {
      return this.ctx.update(u), this;
    }
    final() {
      const u = k.alloc(32);
      return this.ctx._final(u), g.init(), g.update(u), g._final(u), u.slice(0, 20);
    }
    static hash() {
      return new f();
    }
    static hmac() {
      return new w(f, 64);
    }
    static digest(u) {
      return f.ctx.init().update(u).final();
    }
    static root(u, a) {
      return e(k.isBuffer(u) && u.length === 20), e(k.isBuffer(a) && a.length === 20), f.ctx.init().update(u).update(a).final();
    }
    static multi(u, a, s) {
      const { ctx: i } = f;
      return i.init(), i.update(u), i.update(a), s && i.update(s), i.final();
    }
    static mac(u, a) {
      return f.hmac().init(a).update(u).final();
    }
  }
  return f.native = 0, f.id = "HASH160", f.size = 20, f.bits = 160, f.blockSize = 64, f.zero = k.alloc(20, 0), f.ctx = new f(), Qa = f, Qa;
}
var ef, Z2;
function hr() {
  if (Z2) return ef;
  Z2 = 1;
  const e = Mt(), c = wr(), d = ni();
  class w {
    constructor() {
      this.ctx = new c();
    }
    init() {
      return this.ctx.init(), this;
    }
    update(f) {
      return this.ctx.update(f), this;
    }
    final() {
      const f = k.alloc(32);
      return this.ctx._final(f), this.ctx.init(), this.ctx.update(f), this.ctx._final(f), f;
    }
    static hash() {
      return new w();
    }
    static hmac() {
      return new d(w, 64);
    }
    static digest(f) {
      return w.ctx.init().update(f).final();
    }
    static root(f, n) {
      return e(k.isBuffer(f) && f.length === 32), e(k.isBuffer(n) && n.length === 32), w.ctx.init().update(f).update(n).final();
    }
    static multi(f, n, u) {
      const { ctx: a } = w;
      return a.init(), a.update(f), a.update(n), u && a.update(u), a.final();
    }
    static mac(f, n) {
      return w.hmac().init(n).update(f).final();
    }
  }
  return w.native = 0, w.id = "HASH256", w.size = 32, w.bits = 256, w.blockSize = 64, w.zero = k.alloc(32, 0), w.ctx = new w(), ef = w, ef;
}
var tf = {};
/*!
 * binary.js - binary search utils for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var Q2;
function so() {
  return Q2 || (Q2 = 1, function(e) {
    e.search = function(w, g, f, n) {
      let u = 0, a = w.length - 1;
      for (; u <= a; ) {
        const s = u + a >>> 1, i = f(w[s], g);
        if (i === 0)
          return s;
        i < 0 ? u = s + 1 : a = s - 1;
      }
      return n ? u : -1;
    }, e.insert = function(w, g, f, n) {
      const u = e.search(w, g, f, !0);
      return n && u < w.length && f(w[u], g) === 0 ? -1 : (u === 0 ? w.unshift(g) : u === w.length ? w.push(g) : w.splice(u, 0, g), u);
    }, e.remove = function(w, g, f) {
      const n = e.search(w, g, f, !1);
      return n === -1 ? !1 : (c(w, n), !0);
    };
    function c(d, w) {
      if (w === 0) {
        d.shift();
        return;
      }
      let g = w + 1;
      for (; g < d.length; )
        d[w++] = d[g++];
      d.pop();
    }
  }(tf)), tf;
}
var rf = {}, nf = {}, sf = {}, of = {}, af, e6;
function ol() {
  return e6 || (e6 = 1, af = function() {
    if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
      return !1;
    if (typeof Symbol.iterator == "symbol")
      return !0;
    var c = {}, d = Symbol("test"), w = Object(d);
    if (typeof d == "string" || Object.prototype.toString.call(d) !== "[object Symbol]" || Object.prototype.toString.call(w) !== "[object Symbol]")
      return !1;
    var g = 42;
    c[d] = g;
    for (var f in c)
      return !1;
    if (typeof Object.keys == "function" && Object.keys(c).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(c).length !== 0)
      return !1;
    var n = Object.getOwnPropertySymbols(c);
    if (n.length !== 1 || n[0] !== d || !Object.prototype.propertyIsEnumerable.call(c, d))
      return !1;
    if (typeof Object.getOwnPropertyDescriptor == "function") {
      var u = (
        /** @type {PropertyDescriptor} */
        Object.getOwnPropertyDescriptor(c, d)
      );
      if (u.value !== g || u.enumerable !== !0)
        return !1;
    }
    return !0;
  }), af;
}
var ff, t6;
function oo() {
  if (t6) return ff;
  t6 = 1;
  var e = ol();
  return ff = function() {
    return e() && !!Symbol.toStringTag;
  }, ff;
}
var cf, r6;
function al() {
  return r6 || (r6 = 1, cf = Object), cf;
}
var uf, i6;
function og() {
  return i6 || (i6 = 1, uf = Error), uf;
}
var hf, n6;
function ag() {
  return n6 || (n6 = 1, hf = EvalError), hf;
}
var lf, s6;
function fg() {
  return s6 || (s6 = 1, lf = RangeError), lf;
}
var df, o6;
function cg() {
  return o6 || (o6 = 1, df = ReferenceError), df;
}
var bf, a6;
function Bb() {
  return a6 || (a6 = 1, bf = SyntaxError), bf;
}
var pf, f6;
function Zn() {
  return f6 || (f6 = 1, pf = TypeError), pf;
}
var mf, c6;
function ug() {
  return c6 || (c6 = 1, mf = URIError), mf;
}
var gf, u6;
function hg() {
  return u6 || (u6 = 1, gf = Math.abs), gf;
}
var xf, h6;
function lg() {
  return h6 || (h6 = 1, xf = Math.floor), xf;
}
var wf, l6;
function dg() {
  return l6 || (l6 = 1, wf = Math.max), wf;
}
var yf, d6;
function bg() {
  return d6 || (d6 = 1, yf = Math.min), yf;
}
var vf, b6;
function pg() {
  return b6 || (b6 = 1, vf = Math.pow), vf;
}
var Sf, p6;
function mg() {
  return p6 || (p6 = 1, Sf = Math.round), Sf;
}
var Ef, m6;
function gg() {
  return m6 || (m6 = 1, Ef = Number.isNaN || function(c) {
    return c !== c;
  }), Ef;
}
var If, g6;
function xg() {
  if (g6) return If;
  g6 = 1;
  var e = /* @__PURE__ */ gg();
  return If = function(d) {
    return e(d) || d === 0 ? d : d < 0 ? -1 : 1;
  }, If;
}
var Af, x6;
function wg() {
  return x6 || (x6 = 1, Af = Object.getOwnPropertyDescriptor), Af;
}
var Of, w6;
function bn() {
  if (w6) return Of;
  w6 = 1;
  var e = /* @__PURE__ */ wg();
  if (e)
    try {
      e([], "length");
    } catch {
      e = null;
    }
  return Of = e, Of;
}
var _f, y6;
function ao() {
  if (y6) return _f;
  y6 = 1;
  var e = Object.defineProperty || !1;
  if (e)
    try {
      e({}, "a", { value: 1 });
    } catch {
      e = !1;
    }
  return _f = e, _f;
}
var Rf, v6;
function yg() {
  if (v6) return Rf;
  v6 = 1;
  var e = typeof Symbol < "u" && Symbol, c = ol();
  return Rf = function() {
    return typeof e != "function" || typeof Symbol != "function" || typeof e("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : c();
  }, Rf;
}
var Pf, S6;
function Mb() {
  return S6 || (S6 = 1, Pf = typeof Reflect < "u" && Reflect.getPrototypeOf || null), Pf;
}
var kf, E6;
function Nb() {
  if (E6) return kf;
  E6 = 1;
  var e = /* @__PURE__ */ al();
  return kf = e.getPrototypeOf || null, kf;
}
var Bf, I6;
function vg() {
  if (I6) return Bf;
  I6 = 1;
  var e = "Function.prototype.bind called on incompatible ", c = Object.prototype.toString, d = Math.max, w = "[object Function]", g = function(a, s) {
    for (var i = [], p = 0; p < a.length; p += 1)
      i[p] = a[p];
    for (var m = 0; m < s.length; m += 1)
      i[m + a.length] = s[m];
    return i;
  }, f = function(a, s) {
    for (var i = [], p = s, m = 0; p < a.length; p += 1, m += 1)
      i[m] = a[p];
    return i;
  }, n = function(u, a) {
    for (var s = "", i = 0; i < u.length; i += 1)
      s += u[i], i + 1 < u.length && (s += a);
    return s;
  };
  return Bf = function(a) {
    var s = this;
    if (typeof s != "function" || c.apply(s) !== w)
      throw new TypeError(e + s);
    for (var i = f(arguments, 1), p, m = function() {
      if (this instanceof p) {
        var o = s.apply(
          this,
          g(i, arguments)
        );
        return Object(o) === o ? o : this;
      }
      return s.apply(
        a,
        g(i, arguments)
      );
    }, E = d(0, s.length - i.length), v = [], b = 0; b < E; b++)
      v[b] = "$" + b;
    if (p = Function("binder", "return function (" + n(v, ",") + "){ return binder.apply(this,arguments); }")(m), s.prototype) {
      var h = function() {
      };
      h.prototype = s.prototype, p.prototype = new h(), h.prototype = null;
    }
    return p;
  }, Bf;
}
var Mf, A6;
function Qn() {
  if (A6) return Mf;
  A6 = 1;
  var e = vg();
  return Mf = Function.prototype.bind || e, Mf;
}
var Nf, O6;
function fl() {
  return O6 || (O6 = 1, Nf = Function.prototype.call), Nf;
}
var qf, _6;
function cl() {
  return _6 || (_6 = 1, qf = Function.prototype.apply), qf;
}
var zf, R6;
function Sg() {
  return R6 || (R6 = 1, zf = typeof Reflect < "u" && Reflect && Reflect.apply), zf;
}
var Tf, P6;
function qb() {
  if (P6) return Tf;
  P6 = 1;
  var e = Qn(), c = cl(), d = fl(), w = Sg();
  return Tf = w || e.call(d, c), Tf;
}
var Cf, k6;
function ul() {
  if (k6) return Cf;
  k6 = 1;
  var e = Qn(), c = /* @__PURE__ */ Zn(), d = fl(), w = qb();
  return Cf = function(f) {
    if (f.length < 1 || typeof f[0] != "function")
      throw new c("a function is required");
    return w(e, d, f);
  }, Cf;
}
var Df, B6;
function Eg() {
  if (B6) return Df;
  B6 = 1;
  var e = ul(), c = /* @__PURE__ */ bn(), d;
  try {
    d = /** @type {{ __proto__?: typeof Array.prototype }} */
    [].__proto__ === Array.prototype;
  } catch (n) {
    if (!n || typeof n != "object" || !("code" in n) || n.code !== "ERR_PROTO_ACCESS")
      throw n;
  }
  var w = !!d && c && c(
    Object.prototype,
    /** @type {keyof typeof Object.prototype} */
    "__proto__"
  ), g = Object, f = g.getPrototypeOf;
  return Df = w && typeof w.get == "function" ? e([w.get]) : typeof f == "function" ? (
    /** @type {import('./get')} */
    function(u) {
      return f(u == null ? u : g(u));
    }
  ) : !1, Df;
}
var Uf, M6;
function hl() {
  if (M6) return Uf;
  M6 = 1;
  var e = Mb(), c = Nb(), d = /* @__PURE__ */ Eg();
  return Uf = e ? function(g) {
    return e(g);
  } : c ? function(g) {
    if (!g || typeof g != "object" && typeof g != "function")
      throw new TypeError("getProto: not an object");
    return c(g);
  } : d ? function(g) {
    return d(g);
  } : null, Uf;
}
var Ff, N6;
function zb() {
  if (N6) return Ff;
  N6 = 1;
  var e = Function.prototype.call, c = Object.prototype.hasOwnProperty, d = Qn();
  return Ff = d.call(e, c), Ff;
}
var Hf, q6;
function ll() {
  if (q6) return Hf;
  q6 = 1;
  var e, c = /* @__PURE__ */ al(), d = /* @__PURE__ */ og(), w = /* @__PURE__ */ ag(), g = /* @__PURE__ */ fg(), f = /* @__PURE__ */ cg(), n = /* @__PURE__ */ Bb(), u = /* @__PURE__ */ Zn(), a = /* @__PURE__ */ ug(), s = /* @__PURE__ */ hg(), i = /* @__PURE__ */ lg(), p = /* @__PURE__ */ dg(), m = /* @__PURE__ */ bg(), E = /* @__PURE__ */ pg(), v = /* @__PURE__ */ mg(), b = /* @__PURE__ */ xg(), h = Function, o = function(I) {
    try {
      return h('"use strict"; return (' + I + ").constructor;")();
    } catch {
    }
  }, S = /* @__PURE__ */ bn(), H = /* @__PURE__ */ ao(), j = function() {
    throw new u();
  }, J = S ? function() {
    try {
      return arguments.callee, j;
    } catch {
      try {
        return S(arguments, "callee").get;
      } catch {
        return j;
      }
    }
  }() : j, N = yg()(), z = hl(), A = Nb(), q = Mb(), _ = cl(), F = fl(), R = {}, V = typeof Uint8Array > "u" || !z ? e : z(Uint8Array), fe = {
    __proto__: null,
    "%AggregateError%": typeof AggregateError > "u" ? e : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer > "u" ? e : ArrayBuffer,
    "%ArrayIteratorPrototype%": N && z ? z([][Symbol.iterator]()) : e,
    "%AsyncFromSyncIteratorPrototype%": e,
    "%AsyncFunction%": R,
    "%AsyncGenerator%": R,
    "%AsyncGeneratorFunction%": R,
    "%AsyncIteratorPrototype%": R,
    "%Atomics%": typeof Atomics > "u" ? e : Atomics,
    "%BigInt%": typeof BigInt > "u" ? e : BigInt,
    "%BigInt64Array%": typeof BigInt64Array > "u" ? e : BigInt64Array,
    "%BigUint64Array%": typeof BigUint64Array > "u" ? e : BigUint64Array,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView > "u" ? e : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": d,
    "%eval%": eval,
    // eslint-disable-line no-eval
    "%EvalError%": w,
    "%Float16Array%": typeof Float16Array > "u" ? e : Float16Array,
    "%Float32Array%": typeof Float32Array > "u" ? e : Float32Array,
    "%Float64Array%": typeof Float64Array > "u" ? e : Float64Array,
    "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? e : FinalizationRegistry,
    "%Function%": h,
    "%GeneratorFunction%": R,
    "%Int8Array%": typeof Int8Array > "u" ? e : Int8Array,
    "%Int16Array%": typeof Int16Array > "u" ? e : Int16Array,
    "%Int32Array%": typeof Int32Array > "u" ? e : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": N && z ? z(z([][Symbol.iterator]())) : e,
    "%JSON%": typeof JSON == "object" ? JSON : e,
    "%Map%": typeof Map > "u" ? e : Map,
    "%MapIteratorPrototype%": typeof Map > "u" || !N || !z ? e : z((/* @__PURE__ */ new Map())[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": c,
    "%Object.getOwnPropertyDescriptor%": S,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise > "u" ? e : Promise,
    "%Proxy%": typeof Proxy > "u" ? e : Proxy,
    "%RangeError%": g,
    "%ReferenceError%": f,
    "%Reflect%": typeof Reflect > "u" ? e : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set > "u" ? e : Set,
    "%SetIteratorPrototype%": typeof Set > "u" || !N || !z ? e : z((/* @__PURE__ */ new Set())[Symbol.iterator]()),
    "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? e : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": N && z ? z(""[Symbol.iterator]()) : e,
    "%Symbol%": N ? Symbol : e,
    "%SyntaxError%": n,
    "%ThrowTypeError%": J,
    "%TypedArray%": V,
    "%TypeError%": u,
    "%Uint8Array%": typeof Uint8Array > "u" ? e : Uint8Array,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? e : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array > "u" ? e : Uint16Array,
    "%Uint32Array%": typeof Uint32Array > "u" ? e : Uint32Array,
    "%URIError%": a,
    "%WeakMap%": typeof WeakMap > "u" ? e : WeakMap,
    "%WeakRef%": typeof WeakRef > "u" ? e : WeakRef,
    "%WeakSet%": typeof WeakSet > "u" ? e : WeakSet,
    "%Function.prototype.call%": F,
    "%Function.prototype.apply%": _,
    "%Object.defineProperty%": H,
    "%Object.getPrototypeOf%": A,
    "%Math.abs%": s,
    "%Math.floor%": i,
    "%Math.max%": p,
    "%Math.min%": m,
    "%Math.pow%": E,
    "%Math.round%": v,
    "%Math.sign%": b,
    "%Reflect.getPrototypeOf%": q
  };
  if (z)
    try {
      null.error;
    } catch (I) {
      var ue = z(z(I));
      fe["%Error.prototype%"] = ue;
    }
  var ae = function I(se) {
    var t;
    if (se === "%AsyncFunction%")
      t = o("async function () {}");
    else if (se === "%GeneratorFunction%")
      t = o("function* () {}");
    else if (se === "%AsyncGeneratorFunction%")
      t = o("async function* () {}");
    else if (se === "%AsyncGenerator%") {
      var l = I("%AsyncGeneratorFunction%");
      l && (t = l.prototype);
    } else if (se === "%AsyncIteratorPrototype%") {
      var B = I("%AsyncGenerator%");
      B && z && (t = z(B.prototype));
    }
    return fe[se] = t, t;
  }, D = {
    __proto__: null,
    "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
    "%ArrayPrototype%": ["Array", "prototype"],
    "%ArrayProto_entries%": ["Array", "prototype", "entries"],
    "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
    "%ArrayProto_keys%": ["Array", "prototype", "keys"],
    "%ArrayProto_values%": ["Array", "prototype", "values"],
    "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
    "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
    "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
    "%BooleanPrototype%": ["Boolean", "prototype"],
    "%DataViewPrototype%": ["DataView", "prototype"],
    "%DatePrototype%": ["Date", "prototype"],
    "%ErrorPrototype%": ["Error", "prototype"],
    "%EvalErrorPrototype%": ["EvalError", "prototype"],
    "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
    "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
    "%FunctionPrototype%": ["Function", "prototype"],
    "%Generator%": ["GeneratorFunction", "prototype"],
    "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
    "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
    "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
    "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
    "%JSONParse%": ["JSON", "parse"],
    "%JSONStringify%": ["JSON", "stringify"],
    "%MapPrototype%": ["Map", "prototype"],
    "%NumberPrototype%": ["Number", "prototype"],
    "%ObjectPrototype%": ["Object", "prototype"],
    "%ObjProto_toString%": ["Object", "prototype", "toString"],
    "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
    "%PromisePrototype%": ["Promise", "prototype"],
    "%PromiseProto_then%": ["Promise", "prototype", "then"],
    "%Promise_all%": ["Promise", "all"],
    "%Promise_reject%": ["Promise", "reject"],
    "%Promise_resolve%": ["Promise", "resolve"],
    "%RangeErrorPrototype%": ["RangeError", "prototype"],
    "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
    "%RegExpPrototype%": ["RegExp", "prototype"],
    "%SetPrototype%": ["Set", "prototype"],
    "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
    "%StringPrototype%": ["String", "prototype"],
    "%SymbolPrototype%": ["Symbol", "prototype"],
    "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
    "%TypedArrayPrototype%": ["TypedArray", "prototype"],
    "%TypeErrorPrototype%": ["TypeError", "prototype"],
    "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
    "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
    "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
    "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
    "%URIErrorPrototype%": ["URIError", "prototype"],
    "%WeakMapPrototype%": ["WeakMap", "prototype"],
    "%WeakSetPrototype%": ["WeakSet", "prototype"]
  }, Q = Qn(), Z = /* @__PURE__ */ zb(), oe = Q.call(F, Array.prototype.concat), y = Q.call(_, Array.prototype.splice), Y = Q.call(F, String.prototype.replace), he = Q.call(F, String.prototype.slice), be = Q.call(F, RegExp.prototype.exec), xe = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, Ie = /\\(\\)?/g, ve = function(se) {
    var t = he(se, 0, 1), l = he(se, -1);
    if (t === "%" && l !== "%")
      throw new n("invalid intrinsic syntax, expected closing `%`");
    if (l === "%" && t !== "%")
      throw new n("invalid intrinsic syntax, expected opening `%`");
    var B = [];
    return Y(se, xe, function(U, G, T, M) {
      B[B.length] = T ? Y(M, Ie, "$1") : G || U;
    }), B;
  }, C = function(se, t) {
    var l = se, B;
    if (Z(D, l) && (B = D[l], l = "%" + B[0] + "%"), Z(fe, l)) {
      var U = fe[l];
      if (U === R && (U = ae(l)), typeof U > "u" && !t)
        throw new u("intrinsic " + se + " exists, but is not available. Please file an issue!");
      return {
        alias: B,
        name: l,
        value: U
      };
    }
    throw new n("intrinsic " + se + " does not exist!");
  };
  return Hf = function(se, t) {
    if (typeof se != "string" || se.length === 0)
      throw new u("intrinsic name must be a non-empty string");
    if (arguments.length > 1 && typeof t != "boolean")
      throw new u('"allowMissing" argument must be a boolean');
    if (be(/^%?[^%]*%?$/, se) === null)
      throw new n("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    var l = ve(se), B = l.length > 0 ? l[0] : "", U = C("%" + B + "%", t), G = U.name, T = U.value, M = !1, $ = U.alias;
    $ && (B = $[0], y(l, oe([0, 1], $)));
    for (var r = 1, x = !0; r < l.length; r += 1) {
      var O = l[r], L = he(O, 0, 1), X = he(O, -1);
      if ((L === '"' || L === "'" || L === "`" || X === '"' || X === "'" || X === "`") && L !== X)
        throw new n("property names with quotes must have matching quotes");
      if ((O === "constructor" || !x) && (M = !0), B += "." + O, G = "%" + B + "%", Z(fe, G))
        T = fe[G];
      else if (T != null) {
        if (!(O in T)) {
          if (!t)
            throw new u("base intrinsic for " + se + " exists, but the property is not available.");
          return;
        }
        if (S && r + 1 >= l.length) {
          var P = S(T, O);
          x = !!P, x && "get" in P && !("originalValue" in P.get) ? T = P.get : T = T[O];
        } else
          x = Z(T, O), T = T[O];
        x && !M && (fe[G] = T);
      }
    }
    return T;
  }, Hf;
}
var Lf, z6;
function pn() {
  if (z6) return Lf;
  z6 = 1;
  var e = /* @__PURE__ */ ll(), c = ul(), d = c([e("%String.prototype.indexOf%")]);
  return Lf = function(g, f) {
    var n = (
      /** @type {(this: unknown, ...args: unknown[]) => unknown} */
      e(g, !!f)
    );
    return typeof n == "function" && d(g, ".prototype.") > -1 ? c(
      /** @type {const} */
      [n]
    ) : n;
  }, Lf;
}
var Kf, T6;
function Ig() {
  if (T6) return Kf;
  T6 = 1;
  var e = oo()(), c = /* @__PURE__ */ pn(), d = c("Object.prototype.toString"), w = function(u) {
    return e && u && typeof u == "object" && Symbol.toStringTag in u ? !1 : d(u) === "[object Arguments]";
  }, g = function(u) {
    return w(u) ? !0 : u !== null && typeof u == "object" && "length" in u && typeof u.length == "number" && u.length >= 0 && d(u) !== "[object Array]" && "callee" in u && d(u.callee) === "[object Function]";
  }, f = function() {
    return w(arguments);
  }();
  return w.isLegacyArguments = g, Kf = f ? w : g, Kf;
}
var Vf, C6;
function Ag() {
  if (C6) return Vf;
  C6 = 1;
  var e = /* @__PURE__ */ pn(), c = oo()(), d = /* @__PURE__ */ zb(), w = /* @__PURE__ */ bn(), g;
  if (c) {
    var f = e("RegExp.prototype.exec"), n = {}, u = function() {
      throw n;
    }, a = {
      toString: u,
      valueOf: u
    };
    typeof Symbol.toPrimitive == "symbol" && (a[Symbol.toPrimitive] = u), g = function(m) {
      if (!m || typeof m != "object")
        return !1;
      var E = (
        /** @type {NonNullable<typeof gOPD>} */
        w(
          /** @type {{ lastIndex?: unknown }} */
          m,
          "lastIndex"
        )
      ), v = E && d(E, "value");
      if (!v)
        return !1;
      try {
        f(
          m,
          /** @type {string} */
          /** @type {unknown} */
          a
        );
      } catch (b) {
        return b === n;
      }
    };
  } else {
    var s = e("Object.prototype.toString"), i = "[object RegExp]";
    g = function(m) {
      return !m || typeof m != "object" && typeof m != "function" ? !1 : s(m) === i;
    };
  }
  return Vf = g, Vf;
}
var $f, D6;
function Og() {
  if (D6) return $f;
  D6 = 1;
  var e = /* @__PURE__ */ pn(), c = Ag(), d = e("RegExp.prototype.exec"), w = /* @__PURE__ */ Zn();
  return $f = function(f) {
    if (!c(f))
      throw new w("`regex` must be a RegExp");
    return function(u) {
      return d(f, u) !== null;
    };
  }, $f;
}
var jf, U6;
function _g() {
  if (U6) return jf;
  U6 = 1;
  var e = /* @__PURE__ */ pn(), c = /* @__PURE__ */ Og(), d = c(/^\s*(?:function)?\*/), w = oo()(), g = hl(), f = e("Object.prototype.toString"), n = e("Function.prototype.toString"), u = function() {
    if (!w)
      return !1;
    try {
      return Function("return function*() {}")();
    } catch {
    }
  }, a;
  return jf = function(i) {
    if (typeof i != "function")
      return !1;
    if (d(n(i)))
      return !0;
    if (!w) {
      var p = f(i);
      return p === "[object GeneratorFunction]";
    }
    if (!g)
      return !1;
    if (typeof a > "u") {
      var m = u();
      a = m ? (
        /** @type {GeneratorFunctionConstructor} */
        g(m)
      ) : !1;
    }
    return g(i) === a;
  }, jf;
}
var Yf, F6;
function Rg() {
  if (F6) return Yf;
  F6 = 1;
  var e = Function.prototype.toString, c = typeof Reflect == "object" && Reflect !== null && Reflect.apply, d, w;
  if (typeof c == "function" && typeof Object.defineProperty == "function")
    try {
      d = Object.defineProperty({}, "length", {
        get: function() {
          throw w;
        }
      }), w = {}, c(function() {
        throw 42;
      }, null, d);
    } catch (S) {
      S !== w && (c = null);
    }
  else
    c = null;
  var g = /^\s*class\b/, f = function(H) {
    try {
      var j = e.call(H);
      return g.test(j);
    } catch {
      return !1;
    }
  }, n = function(H) {
    try {
      return f(H) ? !1 : (e.call(H), !0);
    } catch {
      return !1;
    }
  }, u = Object.prototype.toString, a = "[object Object]", s = "[object Function]", i = "[object GeneratorFunction]", p = "[object HTMLAllCollection]", m = "[object HTML document.all class]", E = "[object HTMLCollection]", v = typeof Symbol == "function" && !!Symbol.toStringTag, b = !(0 in [,]), h = function() {
    return !1;
  };
  if (typeof document == "object") {
    var o = document.all;
    u.call(o) === u.call(document.all) && (h = function(H) {
      if ((b || !H) && (typeof H > "u" || typeof H == "object"))
        try {
          var j = u.call(H);
          return (j === p || j === m || j === E || j === a) && H("") == null;
        } catch {
        }
      return !1;
    });
  }
  return Yf = c ? function(H) {
    if (h(H))
      return !0;
    if (!H || typeof H != "function" && typeof H != "object")
      return !1;
    try {
      c(H, null, d);
    } catch (j) {
      if (j !== w)
        return !1;
    }
    return !f(H) && n(H);
  } : function(H) {
    if (h(H))
      return !0;
    if (!H || typeof H != "function" && typeof H != "object")
      return !1;
    if (v)
      return n(H);
    if (f(H))
      return !1;
    var j = u.call(H);
    return j !== s && j !== i && !/^\[object HTML/.test(j) ? !1 : n(H);
  }, Yf;
}
var Xf, H6;
function Pg() {
  if (H6) return Xf;
  H6 = 1;
  var e = Rg(), c = Object.prototype.toString, d = Object.prototype.hasOwnProperty, w = function(a, s, i) {
    for (var p = 0, m = a.length; p < m; p++)
      d.call(a, p) && (i == null ? s(a[p], p, a) : s.call(i, a[p], p, a));
  }, g = function(a, s, i) {
    for (var p = 0, m = a.length; p < m; p++)
      i == null ? s(a.charAt(p), p, a) : s.call(i, a.charAt(p), p, a);
  }, f = function(a, s, i) {
    for (var p in a)
      d.call(a, p) && (i == null ? s(a[p], p, a) : s.call(i, a[p], p, a));
  };
  function n(u) {
    return c.call(u) === "[object Array]";
  }
  return Xf = function(a, s, i) {
    if (!e(s))
      throw new TypeError("iterator must be a function");
    var p;
    arguments.length >= 3 && (p = i), n(a) ? w(a, s, p) : typeof a == "string" ? g(a, s, p) : f(a, s, p);
  }, Xf;
}
var Jf, L6;
function kg() {
  return L6 || (L6 = 1, Jf = [
    "Float16Array",
    "Float32Array",
    "Float64Array",
    "Int8Array",
    "Int16Array",
    "Int32Array",
    "Uint8Array",
    "Uint8ClampedArray",
    "Uint16Array",
    "Uint32Array",
    "BigInt64Array",
    "BigUint64Array"
  ]), Jf;
}
var Gf, K6;
function Bg() {
  if (K6) return Gf;
  K6 = 1;
  var e = /* @__PURE__ */ kg(), c = typeof globalThis > "u" ? Lt : globalThis;
  return Gf = function() {
    for (var w = [], g = 0; g < e.length; g++)
      typeof c[e[g]] == "function" && (w[w.length] = e[g]);
    return w;
  }, Gf;
}
var Wf = { exports: {} }, Zf, V6;
function Tb() {
  if (V6) return Zf;
  V6 = 1;
  var e = /* @__PURE__ */ ao(), c = /* @__PURE__ */ Bb(), d = /* @__PURE__ */ Zn(), w = /* @__PURE__ */ bn();
  return Zf = function(f, n, u) {
    if (!f || typeof f != "object" && typeof f != "function")
      throw new d("`obj` must be an object or a function`");
    if (typeof n != "string" && typeof n != "symbol")
      throw new d("`property` must be a string or a symbol`");
    if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null)
      throw new d("`nonEnumerable`, if provided, must be a boolean or null");
    if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null)
      throw new d("`nonWritable`, if provided, must be a boolean or null");
    if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null)
      throw new d("`nonConfigurable`, if provided, must be a boolean or null");
    if (arguments.length > 6 && typeof arguments[6] != "boolean")
      throw new d("`loose`, if provided, must be a boolean");
    var a = arguments.length > 3 ? arguments[3] : null, s = arguments.length > 4 ? arguments[4] : null, i = arguments.length > 5 ? arguments[5] : null, p = arguments.length > 6 ? arguments[6] : !1, m = !!w && w(f, n);
    if (e)
      e(f, n, {
        configurable: i === null && m ? m.configurable : !i,
        enumerable: a === null && m ? m.enumerable : !a,
        value: u,
        writable: s === null && m ? m.writable : !s
      });
    else if (p || !a && !s && !i)
      f[n] = u;
    else
      throw new c("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
  }, Zf;
}
var Qf, $6;
function Cb() {
  if ($6) return Qf;
  $6 = 1;
  var e = /* @__PURE__ */ ao(), c = function() {
    return !!e;
  };
  return c.hasArrayLengthDefineBug = function() {
    if (!e)
      return null;
    try {
      return e([], "length", { value: 1 }).length !== 1;
    } catch {
      return !0;
    }
  }, Qf = c, Qf;
}
var ec, j6;
function Mg() {
  if (j6) return ec;
  j6 = 1;
  var e = /* @__PURE__ */ ll(), c = /* @__PURE__ */ Tb(), d = /* @__PURE__ */ Cb()(), w = /* @__PURE__ */ bn(), g = /* @__PURE__ */ Zn(), f = e("%Math.floor%");
  return ec = function(u, a) {
    if (typeof u != "function")
      throw new g("`fn` is not a function");
    if (typeof a != "number" || a < 0 || a > 4294967295 || f(a) !== a)
      throw new g("`length` must be a positive 32-bit integer");
    var s = arguments.length > 2 && !!arguments[2], i = !0, p = !0;
    if ("length" in u && w) {
      var m = w(u, "length");
      m && !m.configurable && (i = !1), m && !m.writable && (p = !1);
    }
    return (i || p || !s) && (d ? c(
      /** @type {Parameters<define>[0]} */
      u,
      "length",
      a,
      !0,
      !0
    ) : c(
      /** @type {Parameters<define>[0]} */
      u,
      "length",
      a
    )), u;
  }, ec;
}
var tc, Y6;
function Ng() {
  if (Y6) return tc;
  Y6 = 1;
  var e = Qn(), c = cl(), d = qb();
  return tc = function() {
    return d(e, c, arguments);
  }, tc;
}
var X6;
function fo() {
  return X6 || (X6 = 1, function(e) {
    var c = /* @__PURE__ */ Mg(), d = /* @__PURE__ */ ao(), w = ul(), g = Ng();
    e.exports = function(n) {
      var u = w(arguments), a = n.length - (arguments.length - 1);
      return c(
        u,
        1 + (a > 0 ? a : 0),
        !0
      );
    }, d ? d(e.exports, "apply", { value: g }) : e.exports.apply = g;
  }(Wf)), Wf.exports;
}
var rc, J6;
function Db() {
  if (J6) return rc;
  J6 = 1;
  var e = Pg(), c = /* @__PURE__ */ Bg(), d = fo(), w = /* @__PURE__ */ pn(), g = /* @__PURE__ */ bn(), f = hl(), n = w("Object.prototype.toString"), u = oo()(), a = typeof globalThis > "u" ? Lt : globalThis, s = c(), i = w("String.prototype.slice"), p = w("Array.prototype.indexOf", !0) || function(h, o) {
    for (var S = 0; S < h.length; S += 1)
      if (h[S] === o)
        return S;
    return -1;
  }, m = { __proto__: null };
  u && g && f ? e(s, function(b) {
    var h = new a[b]();
    if (Symbol.toStringTag in h && f) {
      var o = f(h), S = g(o, Symbol.toStringTag);
      if (!S && o) {
        var H = f(o);
        S = g(H, Symbol.toStringTag);
      }
      m["$" + b] = d(S.get);
    }
  }) : e(s, function(b) {
    var h = new a[b](), o = h.slice || h.set;
    o && (m[
      /** @type {`$${import('.').TypedArrayName}`} */
      "$" + b
    ] = /** @type {import('./types').BoundSlice | import('./types').BoundSet} */
    // @ts-expect-error TODO FIXME
    d(o));
  });
  var E = function(h) {
    var o = !1;
    return e(
      /** @type {Record<`\$${import('.').TypedArrayName}`, Getter>} */
      m,
      /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
      function(S, H) {
        if (!o)
          try {
            "$" + S(h) === H && (o = /** @type {import('.').TypedArrayName} */
            i(H, 1));
          } catch {
          }
      }
    ), o;
  }, v = function(h) {
    var o = !1;
    return e(
      /** @type {Record<`\$${import('.').TypedArrayName}`, Getter>} */
      m,
      /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
      function(S, H) {
        if (!o)
          try {
            S(h), o = /** @type {import('.').TypedArrayName} */
            i(H, 1);
          } catch {
          }
      }
    ), o;
  };
  return rc = function(h) {
    if (!h || typeof h != "object")
      return !1;
    if (!u) {
      var o = i(n(h), 8, -1);
      return p(s, o) > -1 ? o : o !== "Object" ? !1 : v(h);
    }
    return g ? E(h) : null;
  }, rc;
}
var ic, G6;
function qg() {
  if (G6) return ic;
  G6 = 1;
  var e = /* @__PURE__ */ Db();
  return ic = function(d) {
    return !!e(d);
  }, ic;
}
var W6;
function zg() {
  return W6 || (W6 = 1, function(e) {
    var c = /* @__PURE__ */ Ig(), d = _g(), w = /* @__PURE__ */ Db(), g = /* @__PURE__ */ qg();
    function f(r) {
      return r.call.bind(r);
    }
    var n = typeof BigInt < "u", u = typeof Symbol < "u", a = f(Object.prototype.toString), s = f(Number.prototype.valueOf), i = f(String.prototype.valueOf), p = f(Boolean.prototype.valueOf);
    if (n)
      var m = f(BigInt.prototype.valueOf);
    if (u)
      var E = f(Symbol.prototype.valueOf);
    function v(r, x) {
      if (typeof r != "object")
        return !1;
      try {
        return x(r), !0;
      } catch {
        return !1;
      }
    }
    e.isArgumentsObject = c, e.isGeneratorFunction = d, e.isTypedArray = g;
    function b(r) {
      return typeof Promise < "u" && r instanceof Promise || r !== null && typeof r == "object" && typeof r.then == "function" && typeof r.catch == "function";
    }
    e.isPromise = b;
    function h(r) {
      return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(r) : g(r) || he(r);
    }
    e.isArrayBufferView = h;
    function o(r) {
      return w(r) === "Uint8Array";
    }
    e.isUint8Array = o;
    function S(r) {
      return w(r) === "Uint8ClampedArray";
    }
    e.isUint8ClampedArray = S;
    function H(r) {
      return w(r) === "Uint16Array";
    }
    e.isUint16Array = H;
    function j(r) {
      return w(r) === "Uint32Array";
    }
    e.isUint32Array = j;
    function J(r) {
      return w(r) === "Int8Array";
    }
    e.isInt8Array = J;
    function N(r) {
      return w(r) === "Int16Array";
    }
    e.isInt16Array = N;
    function z(r) {
      return w(r) === "Int32Array";
    }
    e.isInt32Array = z;
    function A(r) {
      return w(r) === "Float32Array";
    }
    e.isFloat32Array = A;
    function q(r) {
      return w(r) === "Float64Array";
    }
    e.isFloat64Array = q;
    function _(r) {
      return w(r) === "BigInt64Array";
    }
    e.isBigInt64Array = _;
    function F(r) {
      return w(r) === "BigUint64Array";
    }
    e.isBigUint64Array = F;
    function R(r) {
      return a(r) === "[object Map]";
    }
    R.working = typeof Map < "u" && R(/* @__PURE__ */ new Map());
    function V(r) {
      return typeof Map > "u" ? !1 : R.working ? R(r) : r instanceof Map;
    }
    e.isMap = V;
    function fe(r) {
      return a(r) === "[object Set]";
    }
    fe.working = typeof Set < "u" && fe(/* @__PURE__ */ new Set());
    function ue(r) {
      return typeof Set > "u" ? !1 : fe.working ? fe(r) : r instanceof Set;
    }
    e.isSet = ue;
    function ae(r) {
      return a(r) === "[object WeakMap]";
    }
    ae.working = typeof WeakMap < "u" && ae(/* @__PURE__ */ new WeakMap());
    function D(r) {
      return typeof WeakMap > "u" ? !1 : ae.working ? ae(r) : r instanceof WeakMap;
    }
    e.isWeakMap = D;
    function Q(r) {
      return a(r) === "[object WeakSet]";
    }
    Q.working = typeof WeakSet < "u" && Q(/* @__PURE__ */ new WeakSet());
    function Z(r) {
      return Q(r);
    }
    e.isWeakSet = Z;
    function oe(r) {
      return a(r) === "[object ArrayBuffer]";
    }
    oe.working = typeof ArrayBuffer < "u" && oe(new ArrayBuffer());
    function y(r) {
      return typeof ArrayBuffer > "u" ? !1 : oe.working ? oe(r) : r instanceof ArrayBuffer;
    }
    e.isArrayBuffer = y;
    function Y(r) {
      return a(r) === "[object DataView]";
    }
    Y.working = typeof ArrayBuffer < "u" && typeof DataView < "u" && Y(new DataView(new ArrayBuffer(1), 0, 1));
    function he(r) {
      return typeof DataView > "u" ? !1 : Y.working ? Y(r) : r instanceof DataView;
    }
    e.isDataView = he;
    var be = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : void 0;
    function xe(r) {
      return a(r) === "[object SharedArrayBuffer]";
    }
    function Ie(r) {
      return typeof be > "u" ? !1 : (typeof xe.working > "u" && (xe.working = xe(new be())), xe.working ? xe(r) : r instanceof be);
    }
    e.isSharedArrayBuffer = Ie;
    function ve(r) {
      return a(r) === "[object AsyncFunction]";
    }
    e.isAsyncFunction = ve;
    function C(r) {
      return a(r) === "[object Map Iterator]";
    }
    e.isMapIterator = C;
    function I(r) {
      return a(r) === "[object Set Iterator]";
    }
    e.isSetIterator = I;
    function se(r) {
      return a(r) === "[object Generator]";
    }
    e.isGeneratorObject = se;
    function t(r) {
      return a(r) === "[object WebAssembly.Module]";
    }
    e.isWebAssemblyCompiledModule = t;
    function l(r) {
      return v(r, s);
    }
    e.isNumberObject = l;
    function B(r) {
      return v(r, i);
    }
    e.isStringObject = B;
    function U(r) {
      return v(r, p);
    }
    e.isBooleanObject = U;
    function G(r) {
      return n && v(r, m);
    }
    e.isBigIntObject = G;
    function T(r) {
      return u && v(r, E);
    }
    e.isSymbolObject = T;
    function M(r) {
      return l(r) || B(r) || U(r) || G(r) || T(r);
    }
    e.isBoxedPrimitive = M;
    function $(r) {
      return typeof Uint8Array < "u" && (y(r) || Ie(r));
    }
    e.isAnyArrayBuffer = $, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(r) {
      Object.defineProperty(e, r, {
        enumerable: !1,
        value: function() {
          throw new Error(r + " is not supported in userland");
        }
      });
    });
  }(of)), of;
}
var nc, Z6;
function Tg() {
  return Z6 || (Z6 = 1, nc = function(c) {
    return c && typeof c == "object" && typeof c.copy == "function" && typeof c.fill == "function" && typeof c.readUInt8 == "function";
  }), nc;
}
var xs = { exports: {} }, Q6;
function Cg() {
  return Q6 || (Q6 = 1, typeof Object.create == "function" ? xs.exports = function(c, d) {
    d && (c.super_ = d, c.prototype = Object.create(d.prototype, {
      constructor: {
        value: c,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }));
  } : xs.exports = function(c, d) {
    if (d) {
      c.super_ = d;
      var w = function() {
      };
      w.prototype = d.prototype, c.prototype = new w(), c.prototype.constructor = c;
    }
  }), xs.exports;
}
var e5;
function Mi() {
  return e5 || (e5 = 1, function(e) {
    var c = Object.getOwnPropertyDescriptors || function(he) {
      for (var be = Object.keys(he), xe = {}, Ie = 0; Ie < be.length; Ie++)
        xe[be[Ie]] = Object.getOwnPropertyDescriptor(he, be[Ie]);
      return xe;
    }, d = /%[sdj%]/g;
    e.format = function(Y) {
      if (!J(Y)) {
        for (var he = [], be = 0; be < arguments.length; be++)
          he.push(n(arguments[be]));
        return he.join(" ");
      }
      for (var be = 1, xe = arguments, Ie = xe.length, ve = String(Y).replace(d, function(I) {
        if (I === "%%") return "%";
        if (be >= Ie) return I;
        switch (I) {
          case "%s":
            return String(xe[be++]);
          case "%d":
            return Number(xe[be++]);
          case "%j":
            try {
              return JSON.stringify(xe[be++]);
            } catch {
              return "[Circular]";
            }
          default:
            return I;
        }
      }), C = xe[be]; be < Ie; C = xe[++be])
        S(C) || !q(C) ? ve += " " + C : ve += " " + n(C);
      return ve;
    }, e.deprecate = function(Y, he) {
      if (typeof It < "u" && It.noDeprecation === !0)
        return Y;
      if (typeof It > "u")
        return function() {
          return e.deprecate(Y, he).apply(this, arguments);
        };
      var be = !1;
      function xe() {
        if (!be) {
          if (It.throwDeprecation)
            throw new Error(he);
          It.traceDeprecation ? console.trace(he) : console.error(he), be = !0;
        }
        return Y.apply(this, arguments);
      }
      return xe;
    };
    var w = {}, g = /^$/;
    if (It.env.NODE_DEBUG) {
      var f = It.env.NODE_DEBUG;
      f = f.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), g = new RegExp("^" + f + "$", "i");
    }
    e.debuglog = function(Y) {
      if (Y = Y.toUpperCase(), !w[Y])
        if (g.test(Y)) {
          var he = It.pid;
          w[Y] = function() {
            var be = e.format.apply(e, arguments);
            console.error("%s %d: %s", Y, he, be);
          };
        } else
          w[Y] = function() {
          };
      return w[Y];
    };
    function n(Y, he) {
      var be = {
        seen: [],
        stylize: a
      };
      return arguments.length >= 3 && (be.depth = arguments[2]), arguments.length >= 4 && (be.colors = arguments[3]), o(he) ? be.showHidden = he : he && e._extend(be, he), z(be.showHidden) && (be.showHidden = !1), z(be.depth) && (be.depth = 2), z(be.colors) && (be.colors = !1), z(be.customInspect) && (be.customInspect = !0), be.colors && (be.stylize = u), i(be, Y, be.depth);
    }
    e.inspect = n, n.colors = {
      bold: [1, 22],
      italic: [3, 23],
      underline: [4, 24],
      inverse: [7, 27],
      white: [37, 39],
      grey: [90, 39],
      black: [30, 39],
      blue: [34, 39],
      cyan: [36, 39],
      green: [32, 39],
      magenta: [35, 39],
      red: [31, 39],
      yellow: [33, 39]
    }, n.styles = {
      special: "cyan",
      number: "yellow",
      boolean: "yellow",
      undefined: "grey",
      null: "bold",
      string: "green",
      date: "magenta",
      // "name": intentionally not styling
      regexp: "red"
    };
    function u(Y, he) {
      var be = n.styles[he];
      return be ? "\x1B[" + n.colors[be][0] + "m" + Y + "\x1B[" + n.colors[be][1] + "m" : Y;
    }
    function a(Y, he) {
      return Y;
    }
    function s(Y) {
      var he = {};
      return Y.forEach(function(be, xe) {
        he[be] = !0;
      }), he;
    }
    function i(Y, he, be) {
      if (Y.customInspect && he && R(he.inspect) && // Filter out the util module, it's inspect function is special
      he.inspect !== e.inspect && // Also filter out any prototype objects using the circular check.
      !(he.constructor && he.constructor.prototype === he)) {
        var xe = he.inspect(be, Y);
        return J(xe) || (xe = i(Y, xe, be)), xe;
      }
      var Ie = p(Y, he);
      if (Ie)
        return Ie;
      var ve = Object.keys(he), C = s(ve);
      if (Y.showHidden && (ve = Object.getOwnPropertyNames(he)), F(he) && (ve.indexOf("message") >= 0 || ve.indexOf("description") >= 0))
        return m(he);
      if (ve.length === 0) {
        if (R(he)) {
          var I = he.name ? ": " + he.name : "";
          return Y.stylize("[Function" + I + "]", "special");
        }
        if (A(he))
          return Y.stylize(RegExp.prototype.toString.call(he), "regexp");
        if (_(he))
          return Y.stylize(Date.prototype.toString.call(he), "date");
        if (F(he))
          return m(he);
      }
      var se = "", t = !1, l = ["{", "}"];
      if (h(he) && (t = !0, l = ["[", "]"]), R(he)) {
        var B = he.name ? ": " + he.name : "";
        se = " [Function" + B + "]";
      }
      if (A(he) && (se = " " + RegExp.prototype.toString.call(he)), _(he) && (se = " " + Date.prototype.toUTCString.call(he)), F(he) && (se = " " + m(he)), ve.length === 0 && (!t || he.length == 0))
        return l[0] + se + l[1];
      if (be < 0)
        return A(he) ? Y.stylize(RegExp.prototype.toString.call(he), "regexp") : Y.stylize("[Object]", "special");
      Y.seen.push(he);
      var U;
      return t ? U = E(Y, he, be, C, ve) : U = ve.map(function(G) {
        return v(Y, he, be, C, G, t);
      }), Y.seen.pop(), b(U, se, l);
    }
    function p(Y, he) {
      if (z(he))
        return Y.stylize("undefined", "undefined");
      if (J(he)) {
        var be = "'" + JSON.stringify(he).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return Y.stylize(be, "string");
      }
      if (j(he))
        return Y.stylize("" + he, "number");
      if (o(he))
        return Y.stylize("" + he, "boolean");
      if (S(he))
        return Y.stylize("null", "null");
    }
    function m(Y) {
      return "[" + Error.prototype.toString.call(Y) + "]";
    }
    function E(Y, he, be, xe, Ie) {
      for (var ve = [], C = 0, I = he.length; C < I; ++C)
        Q(he, String(C)) ? ve.push(v(
          Y,
          he,
          be,
          xe,
          String(C),
          !0
        )) : ve.push("");
      return Ie.forEach(function(se) {
        se.match(/^\d+$/) || ve.push(v(
          Y,
          he,
          be,
          xe,
          se,
          !0
        ));
      }), ve;
    }
    function v(Y, he, be, xe, Ie, ve) {
      var C, I, se;
      if (se = Object.getOwnPropertyDescriptor(he, Ie) || { value: he[Ie] }, se.get ? se.set ? I = Y.stylize("[Getter/Setter]", "special") : I = Y.stylize("[Getter]", "special") : se.set && (I = Y.stylize("[Setter]", "special")), Q(xe, Ie) || (C = "[" + Ie + "]"), I || (Y.seen.indexOf(se.value) < 0 ? (S(be) ? I = i(Y, se.value, null) : I = i(Y, se.value, be - 1), I.indexOf(`
`) > -1 && (ve ? I = I.split(`
`).map(function(t) {
        return "  " + t;
      }).join(`
`).slice(2) : I = `
` + I.split(`
`).map(function(t) {
        return "   " + t;
      }).join(`
`))) : I = Y.stylize("[Circular]", "special")), z(C)) {
        if (ve && Ie.match(/^\d+$/))
          return I;
        C = JSON.stringify("" + Ie), C.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (C = C.slice(1, -1), C = Y.stylize(C, "name")) : (C = C.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), C = Y.stylize(C, "string"));
      }
      return C + ": " + I;
    }
    function b(Y, he, be) {
      var xe = Y.reduce(function(Ie, ve) {
        return ve.indexOf(`
`) >= 0, Ie + ve.replace(/\u001b\[\d\d?m/g, "").length + 1;
      }, 0);
      return xe > 60 ? be[0] + (he === "" ? "" : he + `
 `) + " " + Y.join(`,
  `) + " " + be[1] : be[0] + he + " " + Y.join(", ") + " " + be[1];
    }
    e.types = zg();
    function h(Y) {
      return Array.isArray(Y);
    }
    e.isArray = h;
    function o(Y) {
      return typeof Y == "boolean";
    }
    e.isBoolean = o;
    function S(Y) {
      return Y === null;
    }
    e.isNull = S;
    function H(Y) {
      return Y == null;
    }
    e.isNullOrUndefined = H;
    function j(Y) {
      return typeof Y == "number";
    }
    e.isNumber = j;
    function J(Y) {
      return typeof Y == "string";
    }
    e.isString = J;
    function N(Y) {
      return typeof Y == "symbol";
    }
    e.isSymbol = N;
    function z(Y) {
      return Y === void 0;
    }
    e.isUndefined = z;
    function A(Y) {
      return q(Y) && fe(Y) === "[object RegExp]";
    }
    e.isRegExp = A, e.types.isRegExp = A;
    function q(Y) {
      return typeof Y == "object" && Y !== null;
    }
    e.isObject = q;
    function _(Y) {
      return q(Y) && fe(Y) === "[object Date]";
    }
    e.isDate = _, e.types.isDate = _;
    function F(Y) {
      return q(Y) && (fe(Y) === "[object Error]" || Y instanceof Error);
    }
    e.isError = F, e.types.isNativeError = F;
    function R(Y) {
      return typeof Y == "function";
    }
    e.isFunction = R;
    function V(Y) {
      return Y === null || typeof Y == "boolean" || typeof Y == "number" || typeof Y == "string" || typeof Y == "symbol" || // ES6 symbol
      typeof Y > "u";
    }
    e.isPrimitive = V, e.isBuffer = Tg();
    function fe(Y) {
      return Object.prototype.toString.call(Y);
    }
    function ue(Y) {
      return Y < 10 ? "0" + Y.toString(10) : Y.toString(10);
    }
    var ae = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    function D() {
      var Y = /* @__PURE__ */ new Date(), he = [
        ue(Y.getHours()),
        ue(Y.getMinutes()),
        ue(Y.getSeconds())
      ].join(":");
      return [Y.getDate(), ae[Y.getMonth()], he].join(" ");
    }
    e.log = function() {
      console.log("%s - %s", D(), e.format.apply(e, arguments));
    }, e.inherits = Cg(), e._extend = function(Y, he) {
      if (!he || !q(he)) return Y;
      for (var be = Object.keys(he), xe = be.length; xe--; )
        Y[be[xe]] = he[be[xe]];
      return Y;
    };
    function Q(Y, he) {
      return Object.prototype.hasOwnProperty.call(Y, he);
    }
    var Z = typeof Symbol < "u" ? Symbol("util.promisify.custom") : void 0;
    e.promisify = function(he) {
      if (typeof he != "function")
        throw new TypeError('The "original" argument must be of type Function');
      if (Z && he[Z]) {
        var be = he[Z];
        if (typeof be != "function")
          throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        return Object.defineProperty(be, Z, {
          value: be,
          enumerable: !1,
          writable: !1,
          configurable: !0
        }), be;
      }
      function be() {
        for (var xe, Ie, ve = new Promise(function(se, t) {
          xe = se, Ie = t;
        }), C = [], I = 0; I < arguments.length; I++)
          C.push(arguments[I]);
        C.push(function(se, t) {
          se ? Ie(se) : xe(t);
        });
        try {
          he.apply(this, C);
        } catch (se) {
          Ie(se);
        }
        return ve;
      }
      return Object.setPrototypeOf(be, Object.getPrototypeOf(he)), Z && Object.defineProperty(be, Z, {
        value: be,
        enumerable: !1,
        writable: !1,
        configurable: !0
      }), Object.defineProperties(
        be,
        c(he)
      );
    }, e.promisify.custom = Z;
    function oe(Y, he) {
      if (!Y) {
        var be = new Error("Promise was rejected with a falsy value");
        be.reason = Y, Y = be;
      }
      return he(Y);
    }
    function y(Y) {
      if (typeof Y != "function")
        throw new TypeError('The "original" argument must be of type Function');
      function he() {
        for (var be = [], xe = 0; xe < arguments.length; xe++)
          be.push(arguments[xe]);
        var Ie = be.pop();
        if (typeof Ie != "function")
          throw new TypeError("The last argument must be of type Function");
        var ve = this, C = function() {
          return Ie.apply(ve, arguments);
        };
        Y.apply(this, be).then(
          function(I) {
            It.nextTick(C.bind(null, null, I));
          },
          function(I) {
            It.nextTick(oe.bind(null, I, C));
          }
        );
      }
      return Object.setPrototypeOf(he, Object.getPrototypeOf(Y)), Object.defineProperties(
        he,
        c(Y)
      ), he;
    }
    e.callbackify = y;
  }(sf)), sf;
}
/*!
 * custom.js - custom inspect symbol for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var t5;
function Ub() {
  if (t5) return nf;
  t5 = 1;
  const { inspect: e } = Mi();
  return nf.custom = e.custom || "inspect", nf;
}
var sc, r5;
function Hr() {
  if (r5) return sc;
  r5 = 1;
  const { custom: e } = Ub(), c = [
    "",
    "0",
    "00",
    "000",
    "0000",
    "00000",
    "000000",
    "0000000",
    "00000000",
    "000000000",
    "0000000000",
    "00000000000",
    "000000000000",
    "0000000000000",
    "00000000000000",
    "000000000000000",
    "0000000000000000",
    "00000000000000000",
    "000000000000000000",
    "0000000000000000000",
    "00000000000000000000",
    "000000000000000000000",
    "0000000000000000000000",
    "00000000000000000000000",
    "000000000000000000000000",
    "0000000000000000000000000"
  ], d = [
    0,
    25,
    16,
    12,
    11,
    10,
    9,
    8,
    8,
    7,
    7,
    7,
    7,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5
  ], w = [
    0,
    33554432,
    43046721,
    16777216,
    48828125,
    60466176,
    40353607,
    16777216,
    43046721,
    1e7,
    19487171,
    35831808,
    62748517,
    7529536,
    11390625,
    16777216,
    24137569,
    34012224,
    47045881,
    64e6,
    4084101,
    5153632,
    6436343,
    7962624,
    9765625,
    11881376,
    14348907,
    17210368,
    20511149,
    243e5,
    28629151,
    33554432,
    39135393,
    45435424,
    52521875,
    60466176
  ], g = {
    p192: null,
    p224: null,
    p521: null,
    k256: null,
    p251: null,
    p25519: null,
    p448: null
  }, f = {
    NONE: 0,
    QUO: 1,
    REM: 2,
    BOTH: 3,
    EUCLID: 4,
    ALL: 7
  }, n = 4, u = 1 << n - 1, a = typeof BigInt == "function";
  class s {
    constructor(t, l, B) {
      this.words = [0], this.length = 1, this.negative = 0, this.red = null, this.from(t, l, B);
    }
    /*
     * Addition Engine
     */
    _iadd(t, l) {
      let B = 0, U = 0;
      for (t.length < l.length && ([t, l] = [l, t]), t !== this && this._alloc(t.length); U < l.length; U++) {
        const G = (t.words[U] | 0) + (l.words[U] | 0) + B;
        this.words[U] = G & 67108863, B = G >>> 26;
      }
      for (; B !== 0 && U < t.length; U++) {
        const G = (t.words[U] | 0) + B;
        this.words[U] = G & 67108863, B = G >>> 26;
      }
      if (this.length = t.length, B !== 0)
        this._alloc(this.length + 1), this.words[this.length++] = B;
      else if (t !== this)
        for (; U < t.length; U++)
          this.words[U] = t.words[U];
      return this;
    }
    _iaddn(t) {
      if (this.words[0] += t, this.words[0] < 67108864)
        return this;
      let l = 0;
      for (this._alloc(this.length + 1), this.words[this.length] = 0; l < this.length && this.words[l] >= 67108864; l++)
        this.words[l] -= 67108864, this.words[l + 1] += 1;
      return this.length = Math.max(this.length, l + 1), this;
    }
    /*
     * Addition
     */
    iadd(t) {
      if (_(s.isBN(t), "num", "bignum"), this.negative === t.negative)
        this._iadd(this, t);
      else {
        const l = this.ucmp(t);
        if (l === 0)
          return this.words[0] = 0, this.length = 1, this.negative = 0, this;
        l < 0 ? (this._isub(t, this), this.negative ^= 1) : this._isub(this, t);
      }
      return this;
    }
    iaddn(t) {
      _(D(t), "num", "smi");
      const l = t < 0 | 0;
      return l && (t = -t), this.negative === l ? this._iaddn(t) : this.length === 1 && this.words[0] < t ? (this.words[0] = t - this.words[0], this.negative ^= 1) : this._isubn(t), this;
    }
    add(t) {
      return _(s.isBN(t), "num", "bignum"), t.length > this.length ? t.clone().iadd(this) : this.clone().iadd(t);
    }
    addn(t) {
      return this.clone().iaddn(t);
    }
    /*
     * Subtraction Engine
     */
    _isub(t, l) {
      let B = 0, U = 0;
      for (q(t.length >= l.length), t !== this && this._alloc(t.length); U < l.length; U++) {
        const G = (t.words[U] | 0) - (l.words[U] | 0) + B;
        B = G >> 26, this.words[U] = G & 67108863;
      }
      for (; B !== 0 && U < t.length; U++) {
        const G = (t.words[U] | 0) + B;
        B = G >> 26, this.words[U] = G & 67108863;
      }
      if (q(B === 0), t !== this)
        for (; U < t.length; U++)
          this.words[U] = t.words[U];
      return this.length = Math.max(this.length, U), this._strip();
    }
    _isubn(t) {
      if (this.words[0] -= t, this.words[0] >= 0)
        return this._normalize();
      q(this.length !== 1), this._alloc(this.length + 1);
      for (let l = 0; l < this.length && this.words[l] < 0; l++)
        this.words[l] += 67108864, this.words[l + 1] -= 1;
      return this.words[this.length] = 0, this._strip();
    }
    /*
     * Subtraction
     */
    isub(t) {
      if (_(s.isBN(t), "num", "bignum"), this.negative !== t.negative)
        this._iadd(this, t);
      else {
        const l = this.ucmp(t);
        if (l === 0)
          return this.words[0] = 0, this.length = 1, this.negative = 0, this;
        l < 0 ? (this._isub(t, this), this.negative ^= 1) : this._isub(this, t);
      }
      return this;
    }
    isubn(t) {
      _(D(t), "num", "smi");
      const l = t < 0 | 0;
      return l && (t = -t), this.negative !== l ? this._iaddn(t) : this.length === 1 && this.words[0] < t ? (this.words[0] = t - this.words[0], this.negative ^= 1) : this._isubn(t), this;
    }
    sub(t) {
      return this.clone().isub(t);
    }
    subn(t) {
      return this.clone().isubn(t);
    }
    /*
     * Multiplication Engine
     */
    _mul(t, l) {
      if (_(s.isBN(t), "num", "bignum"), _(s.isBN(l), "out", "bignum"), this.length === 10 && t.length === 10)
        return I(this, t, l);
      const B = this.length + t.length;
      return B < 63 ? Ie(this, t, l) : B < 1024 ? ve(this, t, l) : C(this, t, l);
    }
    /*
     * Multiplication
     */
    imul(t) {
      return this.mul(t)._move(this);
    }
    imuln(t) {
      _(D(t), "num", "smi");
      const l = t < 0 | 0;
      l && (t = -t);
      let B = 0;
      for (let U = 0; U < this.length; U++) {
        const G = this.words[U] * t, T = (G & 67108863) + (B & 67108863);
        B >>= 26, B += G / 67108864 | 0, B += T >>> 26, this.words[U] = T & 67108863;
      }
      return this.negative ^= l, B !== 0 ? (this._alloc(this.length + 1), this.words[this.length++] = B) : this._strip(), this;
    }
    mul(t) {
      _(s.isBN(t), "num", "bignum");
      const l = this.length + t.length, B = new s();
      B.words = new Array(l);
      for (let U = 0; U < l; U++)
        B.words[U] = 0;
      return this._mul(t, B);
    }
    muln(t) {
      return this.clone().imuln(t);
    }
    /*
     * Multiplication + Shift
     */
    mulShift(t, l) {
      _(s.isBN(t), "num", "bignum"), _(l >>> 0 === l, "bits", "uint32");
      const B = this.mul(t), U = B.utestn(l - 1);
      return B.iushrn(l), this.negative ^ t.negative ? B.isubn(U) : B.iaddn(U);
    }
    /*
     * Division Engine
     */
    _div(t, l) {
      _(s.isBN(t), "num", "bignum"), q((l & f.ALL) === l), q(l !== f.NONE);
      const B = this, U = t;
      if (fe(!U.isZero()), B.isZero())
        return [new s(0), new s(0)];
      const G = B.negative, T = U.negative;
      B.negative = 0, U.negative = 0;
      let M = null, $ = null;
      return B.ucmp(U) < 0 ? (l & f.QUO && (M = new s(0)), l & f.REM && ($ = B.clone())) : U.length === 1 ? (l & f.QUO && (M = B.quon(U.words[0])), l & f.REM && ($ = B.remn(U.words[0]))) : [M, $] = B._wordDiv(U, l), B.negative = G, U.negative = T, l & f.QUO && (M.negative = B.negative ^ U.negative, M._normalize()), l & f.REM && ($.negative = B.negative, $._normalize()), l & f.EUCLID && (l & f.QUO && (q((l & f.REM) !== 0), $.negative !== 0 && (U.negative !== 0 ? M.iaddn(1) : M.isubn(1))), l & f.REM && $.negative !== 0 && (U.negative !== 0 ? $.isub(U) : $.iadd(U))), [M, $];
    }
    _wordDiv(t, l) {
      let B = this.clone(), U = t, G = null, T;
      const M = U.words[U.length - 1] | 0, $ = 26 - oe(M);
      $ !== 0 ? (U = U.clone(), B.iushln($), U.iushln($), T = U.words[U.length - 1] | 0) : T = M;
      const r = B.length - U.length;
      if (q(r >= 0), l & f.QUO) {
        G = new s(0), G.length = r + 1, G.words = new Array(G.length);
        for (let O = 0; O < G.length; O++)
          G.words[O] = 0;
      }
      const x = B.clone();
      x._ishlnsubmul(U, 1, r), x.negative === 0 && (G && (G.words[r] = 1), B = x);
      for (let O = r - 1; O >= 0; O--) {
        const L = B.words[U.length + O], X = B.words[U.length + O - 1], P = (L * 67108864 + X) / T | 0;
        let K = Math.min(P, 67108863);
        for (B._ishlnsubmul(U, K, O); B.negative !== 0; )
          K -= 1, B.negative = 0, B._ishlnsubmul(U, 1, O), B.ineg();
        G && (G.words[O] = K);
      }
      return G && G._strip(), l & f.REM && $ !== 0 && B.iushrn($), [G, B];
    }
    _ishlnsubmul(t, l, B) {
      let U = 0, G = 0;
      for (this._expand(t.length + B); G < t.length; G++) {
        const T = (this.words[G + B] | 0) + U, M = t.words[G] * l, $ = T - (M & 67108863);
        U = ($ >> 26) - (M / 67108864 | 0), this.words[G + B] = $ & 67108863;
      }
      for (; G < this.length - B; G++) {
        const T = (this.words[G + B] | 0) + U;
        U = T >> 26, this.words[G + B] = T & 67108863;
      }
      if (U === 0)
        return this._strip();
      q(U === -1), U = 0;
      for (let T = 0; T < this.length; T++) {
        const M = -(this.words[T] | 0) + U;
        U = M >> 26, this.words[T] = M & 67108863;
      }
      return this.negative = 1, this._strip();
    }
    /*
     * Truncation Division + Modulo
     */
    quorem(t) {
      return this._div(t, f.BOTH);
    }
    /*
     * Truncation Division
     */
    iquo(t) {
      return this.quo(t)._move(this);
    }
    iquon(t) {
      _(D(t), "num", "smi"), fe(t !== 0);
      const l = t < 0 | 0;
      l && (t = -t);
      let B = 0;
      for (let U = this.length - 1; U >= 0; U--) {
        const G = (this.words[U] | 0) + B * 67108864;
        this.words[U] = G / t | 0, B = G % t;
      }
      return this.negative ^= l, this._strip();
    }
    quo(t) {
      return this._div(t, f.QUO)[0];
    }
    quon(t) {
      return this.clone().iquon(t);
    }
    /*
     * Truncation Modulo
     */
    irem(t) {
      return this.rem(t)._move(this);
    }
    iremn(t) {
      let l = this.remrn(t);
      return l < 0 && (l = -l), this.words[0] = l, this.length = 1, this._normalize();
    }
    rem(t) {
      return this._div(t, f.REM)[1];
    }
    remn(t) {
      return this.clone().iremn(t);
    }
    remrn(t) {
      _(D(t), "num", "smi"), fe(t !== 0), t < 0 && (t = -t);
      const l = (1 << 26) % t;
      let B = 0;
      for (let U = this.length - 1; U >= 0; U--)
        B = (l * B + (this.words[U] | 0)) % t;
      return this.negative !== 0 ? -B | 0 : B;
    }
    /*
     * Euclidean Division + Modulo
     */
    divmod(t) {
      return this._div(t, f.BOTH | f.EUCLID);
    }
    /*
     * Euclidean Division
     */
    idiv(t) {
      return this.div(t)._move(this);
    }
    idivn(t) {
      if (this.negative === 0)
        return this.iquon(t);
      const l = this.remrn(t);
      return this.iquon(t), l < 0 && (t < 0 ? this.iaddn(1) : this.isubn(1)), this;
    }
    div(t) {
      return this._div(t, f.BOTH | f.EUCLID)[0];
    }
    divn(t) {
      return this.clone().idivn(t);
    }
    /*
     * Euclidean Modulo
     */
    imod(t) {
      return this.ucmp(t) < 0 ? (this.negative !== 0 && (this._isub(t, this), this.negative = 0), this) : this.mod(t)._move(this);
    }
    imodn(t) {
      return this.words[0] = this.modrn(t), this.length = 1, this.negative = 0, this;
    }
    mod(t) {
      return this._div(t, f.REM | f.EUCLID)[1];
    }
    modn(t) {
      return this.clone().imodn(t);
    }
    modrn(t) {
      _(D(t), "num", "smi");
      let l = this.remrn(t);
      return l < 0 && (t < 0 ? l -= t : l += t), l;
    }
    /*
     * Round Division
     */
    divRound(t) {
      const [l, B] = this.quorem(t);
      if (B.isZero())
        return l;
      const U = t.words[0] & 1;
      t.iushrn(1);
      const G = B.ucmp(t);
      return t.iushln(1), t.words[0] |= U, G < 0 || t.isOdd() && G === 0 ? l : this.negative ^ t.negative ? l.isubn(1) : l.iaddn(1);
    }
    /*
     * Exponentiation
     */
    ipow(t) {
      return this.pow(t)._move(this);
    }
    ipown(t) {
      return this.pown(t)._move(this);
    }
    pow(t) {
      _(s.isBN(t), "num", "bignum");
      let l = oe(t.words[t.length - 1]), B = new s(1);
      for (let U = t.length - 1; U >= 0; U--) {
        const G = t.words[U];
        for (let T = l - 1; T >= 0; T--)
          B = B.sqr(), G >> T & 1 && (B = B.mul(this));
        l = 26;
      }
      return B;
    }
    pown(t) {
      if (_(D(t), "num", "smi"), t < 0 && (t = -t), t === 0)
        return new s(1);
      if (t === 1)
        return this.clone();
      const l = oe(t);
      let B = this;
      for (let U = l - 2; U >= 0; U--)
        B = B.sqr(), t >> U & 1 && (B = B.mul(this));
      return B;
    }
    isqr() {
      return this.imul(this);
    }
    sqr() {
      return this.mul(this);
    }
    /*
     * Roots Engine
     */
    _rootrem(t, l) {
      if (_(t >>> 0 === t, "num", "uint32"), t === 0)
        throw new RangeError("Zeroth root.");
      if (~t & this.negative)
        throw new RangeError("Negative with even root.");
      if (this.ucmpn(1) <= 0)
        return [this.clone(), new s(0)];
      let B = new s(0), U = s.shift(1, this.bitLength() / t + 1 | 0), G, T;
      if (this.negative !== 0 && U.ineg(), t === 2)
        do
          B = U, U = this.quo(B), U.iadd(B), U.iushrn(1);
        while (U.ucmp(B) < 0);
      else
        do
          B = U, U = B.pown(t - 1), U = this.quo(U), G = B.muln(t - 1), U.iadd(G), U = U.quon(t);
        while (U.ucmp(B) < 0);
      return l && (U = B.pown(t), T = this.sub(U)), [B, T];
    }
    /*
     * Roots
     */
    rootrem(t) {
      return this._rootrem(t, 1);
    }
    iroot(t) {
      return this.root(t)._move(this);
    }
    root(t) {
      return this._rootrem(t, 0)[0];
    }
    isPower(t) {
      if (_(t >>> 0 === t, "num", "uint32"), t === 0 || ~t & this.negative)
        return !1;
      const [, l] = this.rootrem(t);
      return l.sign() === 0;
    }
    sqrtrem() {
      return this.rootrem(2);
    }
    isqrt() {
      return this.sqrt()._move(this);
    }
    sqrt() {
      return this.root(2);
    }
    isSquare() {
      return this.isPower(2);
    }
    /*
     * AND
     */
    iand(t) {
      _(s.isBN(t), "num", "bignum");
      let l = this, B = t;
      if (l === B)
        return l;
      if ((l.negative | B.negative) === 0)
        return l.iuand(B);
      if ((l.negative & B.negative) === 1)
        return l.iaddn(1), B.iaddn(1), l.iuor(B), l.isubn(1), B.isubn(1), l;
      l.negative !== 0 && ([l, B] = [B.clone(), l]);
      const U = l.bitLength();
      return B.iaddn(1), B.inotn(U), l.iuand(B), B.inotn(U), B.isubn(1), l._move(this);
    }
    iandn(t) {
      return _(D(t), "num", "smi"), (this.negative | t < 0) !== 0 ? this.iand(new s(t)) : (this.words[0] &= t, this.length = 1, this);
    }
    and(t) {
      return this.clone().iand(t);
    }
    andn(t) {
      return this.clone().iandn(t);
    }
    andrn(t) {
      if (_(D(t), "num", "smi"), (this.negative | t < 0) !== 0) {
        const l = this.iand(new s(t));
        if (l.length > 1)
          throw new RangeError("Number exceeds 26 bits.");
        return l.negative !== 0 ? -l.words[0] : l.words[0];
      }
      return this.words[0] & t;
    }
    /*
     * Unsigned AND
     */
    iuand(t) {
      _(s.isBN(t), "num", "bignum"), this.length = Math.min(this.length, t.length);
      for (let l = 0; l < this.length; l++)
        this.words[l] &= t.words[l];
      return this._strip();
    }
    iuandn(t) {
      return _(D(t), "num", "smi"), this.words[0] &= Math.abs(t), this.length = 1, this._normalize();
    }
    uand(t) {
      return this.clone().iuand(t);
    }
    uandn(t) {
      return this.clone().iuandn(t);
    }
    uandrn(t) {
      _(D(t), "num", "smi");
      const l = this.words[0] & Math.abs(t);
      return this.negative !== 0 ? -l | 0 : l;
    }
    /*
     * OR
     */
    ior(t) {
      _(s.isBN(t), "num", "bignum");
      let l = this, B = t;
      return l === B ? l : (l.negative | B.negative) === 0 ? l.iuor(B) : (l.negative & B.negative) === 1 ? (l.iaddn(1), B.iaddn(1), l.iuand(B), l.isubn(1), B.isubn(1), l) : (B = B.clone(), l.negative !== 0 && ([l, B] = [B, l]), B.iaddn(1), l.inotn(B.bitLength()), B.iuand(l), B.isubn(1), B._move(this));
    }
    iorn(t) {
      return _(D(t), "num", "smi"), (this.negative | t < 0) !== 0 ? this.ior(new s(t)) : (this.words[0] |= t, this);
    }
    or(t) {
      return this.clone().ior(t);
    }
    orn(t) {
      return this.clone().iorn(t);
    }
    /*
     * Unsigned OR
     */
    iuor(t) {
      _(s.isBN(t), "num", "bignum"), this._expand(t.length);
      for (let l = 0; l < t.length; l++)
        this.words[l] |= t.words[l];
      return this;
    }
    iuorn(t) {
      return _(D(t), "num", "smi"), this.words[0] |= Math.abs(t), this;
    }
    uor(t) {
      return this.clone().iuor(t);
    }
    uorn(t) {
      return this.clone().iuorn(t);
    }
    /*
     * XOR
     */
    ixor(t) {
      _(s.isBN(t), "num", "bignum");
      let l = this, B = t;
      return l === B ? (l.words[0] = 0, l.length = 1, l.negative = 0, l) : (l.negative | B.negative) === 0 ? l.iuxor(B) : (l.negative & B.negative) === 1 ? (l.iaddn(1), B.iaddn(1), l.iuxor(B), l.ineg(), B.isubn(1), l) : (l.negative !== 0 && ([l, B] = [B.clone(), l]), B.iaddn(1), l.iuxor(B), l.iaddn(1), l.ineg(), B.isubn(1), l._move(this));
    }
    ixorn(t) {
      return _(D(t), "num", "smi"), (this.negative | t < 0) !== 0 ? this.ixor(new s(t)) : (this.words[0] ^= t, this);
    }
    xor(t) {
      return this.clone().ixor(t);
    }
    xorn(t) {
      return this.clone().ixorn(t);
    }
    /*
     * Unsigned XOR
     */
    iuxor(t) {
      _(s.isBN(t), "num", "bignum");
      let l = this, B = t;
      l.length < B.length && ([l, B] = [B, l]);
      let U = 0;
      for (; U < B.length; U++)
        this.words[U] = l.words[U] ^ B.words[U];
      if (l !== this)
        for (this._alloc(l.length); U < l.length; U++)
          this.words[U] = l.words[U];
      return this.length = l.length, this._strip();
    }
    iuxorn(t) {
      return _(D(t), "num", "smi"), this.words[0] ^= Math.abs(t), this._normalize();
    }
    uxor(t) {
      return this.clone().iuxor(t);
    }
    uxorn(t) {
      return this.clone().iuxorn(t);
    }
    /*
     * NOT
     */
    inot() {
      return this.negative !== 0 ? this.ineg().isubn(1) : this.iaddn(1).ineg(), this;
    }
    not() {
      return this.clone().inot();
    }
    inotn(t) {
      _(t >>> 0 === t, "width", "uint32");
      const l = t % 26;
      let B = Math.ceil(t / 26), U = 0;
      for (this._expand(B), l > 0 && (B -= 1); U < B; U++)
        this.words[U] ^= 67108863;
      return l > 0 && (this.words[U] ^= (1 << l) - 1), this._strip();
    }
    notn(t) {
      return this.clone().inotn(t);
    }
    /*
     * Left Shift
     */
    ishl(t) {
      return _(s.isBN(t), "bits", "bignum"), _(t.bitLength() <= 32, "bits", "uint32"), this.ishln(t.toNumber());
    }
    ishln(t) {
      return this.iushln(t);
    }
    shl(t) {
      return this.clone().ishl(t);
    }
    shln(t) {
      return this.clone().ishln(t);
    }
    /*
     * Unsigned Left Shift
     */
    iushl(t) {
      return _(s.isBN(t), "bits", "bignum"), _(t.bitLength() <= 32, "bits", "uint32"), this.iushln(t.toNumber());
    }
    iushln(t) {
      _(t >>> 0 === t, "bits", "uint32");
      const l = t % 26, B = (t - l) / 26, U = (1 << l) - 1 << 26 - l;
      if (l !== 0) {
        let G = 0;
        for (let T = 0; T < this.length; T++) {
          const M = this.words[T] & U, $ = (this.words[T] | 0) - M << l;
          this.words[T] = $ | G, G = M >>> 26 - l;
        }
        G !== 0 && (this._alloc(this.length + 1), this.words[this.length++] = G);
      }
      if (B !== 0) {
        this._alloc(this.length + B);
        for (let G = this.length - 1; G >= 0; G--)
          this.words[G + B] = this.words[G];
        for (let G = 0; G < B; G++)
          this.words[G] = 0;
        this.length += B;
      }
      return this._strip();
    }
    ushl(t) {
      return this.clone().iushl(t);
    }
    ushln(t) {
      return this.clone().iushln(t);
    }
    /*
     * Right Shift Engine
     */
    _split(t, l) {
      const B = t % 26, U = Math.min((t - B) / 26, this.length), G = (1 << B) - 1;
      if (l) {
        l._alloc(U);
        for (let M = 0; M < U; M++)
          l.words[M] = this.words[M];
        l.length = U;
      }
      if (U !== 0) if (this.length > U) {
        this.length -= U;
        for (let M = 0; M < this.length; M++)
          this.words[M] = this.words[M + U];
      } else
        this.words[0] = 0, this.length = 1;
      let T = 0;
      if (B !== 0)
        for (let M = this.length - 1; M >= 0; M--) {
          const $ = this.words[M] | 0;
          this.words[M] = T << 26 - B | $ >>> B, T = $ & G;
        }
      return l && (T !== 0 ? (l._alloc(l.length + 1), l.words[l.length++] = T) : (l.length === 0 && (l.words[l.length++] = 0), l._strip())), this._strip();
    }
    /*
     * Right Shift
     */
    ishr(t) {
      return _(s.isBN(t), "bits", "bignum"), _(t.bitLength() <= 32, "bits", "uint32"), this.ishrn(t.toNumber());
    }
    ishrn(t) {
      return _(t >>> 0 === t, "bits", "uint32"), this.negative !== 0 ? (this.iaddn(1), this.iushrn(t), this.isubn(1), this) : this.iushrn(t);
    }
    shr(t) {
      return this.clone().ishr(t);
    }
    shrn(t) {
      return this.clone().ishrn(t);
    }
    /*
     * Unsigned Right Shift
     */
    iushr(t) {
      return _(s.isBN(t), "bits", "bignum"), _(t.bitLength() <= 32, "bits", "uint32"), this.iushrn(t.toNumber());
    }
    iushrn(t) {
      return _(t >>> 0 === t, "bits", "uint32"), this._split(t, null);
    }
    ushr(t) {
      return this.clone().iushr(t);
    }
    ushrn(t) {
      return this.clone().iushrn(t);
    }
    /*
     * Bit Manipulation
     */
    setn(t, l) {
      return _(t >>> 0 === t, "bit", "uint32"), this.negative !== 0 ? (this.iaddn(1), this.usetn(t, !l), this.isubn(1), this) : this.usetn(t, l);
    }
    usetn(t, l) {
      _(t >>> 0 === t, "bit", "uint32");
      const B = t % 26, U = (t - B) / 26;
      return this._expand(U + 1), l ? this.words[U] |= 1 << B : this.words[U] &= ~(1 << B), this._strip();
    }
    testn(t) {
      _(t >>> 0 === t, "bit", "uint32");
      const l = t % 26, B = (t - l) / 26;
      if (this.length <= B)
        return this.negative;
      const U = this.words[B], G = U >> l & 1;
      if (this.negative !== 0) {
        if (l > 0 && U & (1 << l) - 1)
          return G ^ 1;
        let T = B;
        for (; T--; )
          if (this.words[T] > 0)
            return G ^ 1;
      }
      return G;
    }
    utestn(t) {
      _(t >>> 0 === t, "bit", "uint32");
      const l = t % 26, B = (t - l) / 26;
      return this.length <= B ? 0 : this.words[B] >> l & 1;
    }
    imaskn(t) {
      return _(t >>> 0 === t, "bits", "uint32"), this.negative !== 0 && (this.iaddn(1), this.inotn(t + 1), this.ineg()), this.iumaskn(t);
    }
    maskn(t) {
      return this.clone().imaskn(t);
    }
    iumaskn(t) {
      _(t >>> 0 === t, "bits", "uint32");
      const l = t % 26;
      let B = (t - l) / 26;
      return this.length <= B ? this : (l !== 0 && (B += 1), this.length = Math.min(B, this.length), l !== 0 && (this.words[this.length - 1] &= (1 << l) - 1), this.length === 0 && (this.words[this.length++] = 0), this._strip());
    }
    umaskn(t) {
      return this.clone().iumaskn(t);
    }
    andln(t) {
      return this.words[0] & t;
    }
    bit(t) {
      return this.utestn(t);
    }
    bits(t, l) {
      _(t >>> 0 === t, "pos", "uint32"), _(l >>> 0 === l, "width", "uint32"), _(l <= 26, "width", "width");
      const B = t % 26, U = (t - B) / 26;
      if (U >= this.length)
        return 0;
      let G = this.words[U] >> B & (1 << l) - 1;
      if (B + l > 26 && U + 1 < this.length) {
        const T = B + l - 26, M = this.words[U + 1] & (1 << T) - 1;
        G |= M << 26 - B;
      }
      return G;
    }
    /*
     * Negation
     */
    ineg() {
      return this.isZero() || (this.negative ^= 1), this;
    }
    neg() {
      return this.clone().ineg();
    }
    iabs() {
      return this.negative = 0, this;
    }
    abs() {
      return this.clone().iabs();
    }
    /*
     * Comparison
     */
    cmp(t) {
      if (_(s.isBN(t), "num", "bignum"), this.negative !== t.negative)
        return t.negative - this.negative;
      const l = this.ucmp(t);
      return this.negative !== 0 ? -l | 0 : l;
    }
    cmpn(t) {
      _(D(t), "num", "smi");
      const l = t < 0 | 0;
      if (this.negative !== l)
        return l - this.negative;
      const B = this.ucmpn(t);
      return this.negative !== 0 ? -B | 0 : B;
    }
    eq(t) {
      return this.cmp(t) === 0;
    }
    eqn(t) {
      return this.cmpn(t) === 0;
    }
    gt(t) {
      return this.cmp(t) > 0;
    }
    gtn(t) {
      return this.cmpn(t) > 0;
    }
    gte(t) {
      return this.cmp(t) >= 0;
    }
    gten(t) {
      return this.cmpn(t) >= 0;
    }
    lt(t) {
      return this.cmp(t) < 0;
    }
    ltn(t) {
      return this.cmpn(t) < 0;
    }
    lte(t) {
      return this.cmp(t) <= 0;
    }
    lten(t) {
      return this.cmpn(t) <= 0;
    }
    sign() {
      return this.negative !== 0 ? -1 : this.length === 1 && this.words[0] === 0 ? 0 : 1;
    }
    isZero() {
      return this.length === 1 && this.words[0] === 0;
    }
    isNeg() {
      return this.negative !== 0;
    }
    isPos() {
      return this.negative === 0;
    }
    isOdd() {
      return (this.words[0] & 1) === 1;
    }
    isEven() {
      return (this.words[0] & 1) === 0;
    }
    /*
     * Unsigned Comparison
     */
    ucmp(t) {
      if (_(s.isBN(t), "num", "bignum"), this.length < t.length)
        return -1;
      if (this.length > t.length)
        return 1;
      for (let l = this.length - 1; l >= 0; l--) {
        const B = this.words[l] | 0, U = t.words[l] | 0;
        if (B !== U)
          return (B > U) - (B < U);
      }
      return 0;
    }
    ucmpn(t) {
      if (_(D(t), "num", "smi"), this.length > 1)
        return 1;
      const l = this.words[0] | 0;
      return t < 0 && (t = -t), (l > t) - (l < t);
    }
    /*
     * Number Theoretic Functions
     */
    legendre(t) {
      const l = a ? s.red(t) : s.mont(t);
      return this.toRed(l).redLegendre();
    }
    jacobi(t) {
      if (_(s.isBN(t), "num", "bignum"), t.isZero() || t.isEven())
        throw new Error("jacobi: `num` must be odd.");
      let l = this._cloneNormal(), B = t.clone(), U = 1;
      for (B.isNeg() && (l.isNeg() && (U = -1), B.ineg()), (l.isNeg() || l.ucmp(B) >= 0) && l.imod(B); !l.isZero(); ) {
        if (l._makeOdd() & 1) {
          const M = B.andln(7);
          (M === 3 || M === 5) && (U = -U);
        }
        l.ucmp(B) < 0 && ([l, B] = [B, l], l.andln(3) === 3 && B.andln(3) === 3 && (U = -U)), l._isub(l, B).iushrn(1);
        const T = B.andln(7);
        (T === 3 || T === 5) && (U = -U);
      }
      return B.cmpn(1) !== 0 ? 0 : U;
    }
    kronecker(t) {
      if (_(s.isBN(t), "num", "bignum"), this.isZero())
        return t.ucmpn(1) === 0 ? 1 : 0;
      if (t.isZero())
        return this.ucmpn(1) === 0 ? 1 : 0;
      if (((this.words[0] | t.words[0]) & 1) === 0)
        return 0;
      const l = this, B = t.clone(), U = B._makeOdd(), G = [0, 1, 0, -1, 0, -1, 0, 1];
      let T = l.jacobi(B);
      return U & 1 && (T *= G[l.andln(7)]), T | 0;
    }
    igcd(t) {
      return this.gcd(t)._move(this);
    }
    gcd(t) {
      if (_(s.isBN(t), "num", "bignum"), this.isZero())
        return t.abs();
      if (t.isZero())
        return this.abs();
      let l = this.clone(), B = t.clone();
      l.negative = 0, B.negative = 0;
      const U = l._factor2(B);
      for (U !== 0 && (l.iushrn(U), B.iushrn(U)); ; ) {
        l._makeOdd(), B._makeOdd();
        const G = l.ucmp(B);
        if (G < 0)
          [l, B] = [B, l];
        else if (G === 0 || B.ucmpn(1) === 0)
          break;
        l._isub(l, B);
      }
      return B.iushln(U);
    }
    ilcm(t) {
      return this.lcm(t)._move(this);
    }
    lcm(t) {
      return _(s.isBN(t), "num", "bignum"), this.isZero() || t.isZero() ? new s(0) : this.quo(this.gcd(t)).mul(t).iabs();
    }
    egcd(t) {
      if (_(s.isBN(t), "num", "bignum"), this.isZero())
        return [
          new s(0),
          new s(t.sign()),
          t.abs()
        ];
      if (t.isZero())
        return [
          new s(this.sign()),
          new s(0),
          this.abs()
        ];
      const l = this.clone(), B = t.clone();
      l.negative = 0, B.negative = 0;
      const U = new s(1), G = new s(0), T = new s(0), M = new s(1), $ = l._factor2(B);
      $ > 0 && (l.iushrn($), B.iushrn($));
      const r = l.clone(), x = B.clone();
      for (; !l.isZero(); ) {
        let O = l._makeOdd(), L = B._makeOdd();
        for (; O--; )
          (U.isOdd() || G.isOdd()) && (U.iadd(x), G.isub(r)), U.iushrn(1), G.iushrn(1);
        for (; L--; )
          (T.isOdd() || M.isOdd()) && (T.iadd(x), M.isub(r)), T.iushrn(1), M.iushrn(1);
        l.cmp(B) >= 0 ? (l.isub(B), U.isub(T), G.isub(M)) : (B.isub(l), T.isub(U), M.isub(G));
      }
      return this.negative !== 0 && T.ineg(), t.negative !== 0 && M.ineg(), [T, M, B.iushln($)];
    }
    iinvert(t) {
      return this.invert(t)._move(this);
    }
    invert(t) {
      if (_(s.isBN(t), "num", "bignum"), F(t.sign() > 0, "invert"), t.isOdd())
        return this._invertp(t);
      if (t.cmpn(1) === 0)
        throw new RangeError("Not invertible.");
      const [l, , B] = this.egcd(t);
      if (B.cmpn(1) !== 0)
        throw new RangeError("Not invertible.");
      return l.imod(t);
    }
    ifermat(t) {
      return this.fermat(t)._move(this);
    }
    fermat(t) {
      const l = a ? s.red(t) : s.mont(t);
      return this.toRed(l).redFermat().fromRed();
    }
    ipowm(t, l, B) {
      return this.powm(t, l, B)._move(this);
    }
    powm(t, l, B) {
      const U = !a && B ? s.mont(l) : s.red(l);
      return this.toRed(U).redPow(t).fromRed();
    }
    ipowmn(t, l, B) {
      return this.powmn(t, l, B)._move(this);
    }
    powmn(t, l, B) {
      const U = B ? s.mont(l) : s.red(l);
      return this.toRed(U).redPown(t).fromRed();
    }
    isqrtm(t) {
      return this.sqrtm(t)._move(this);
    }
    sqrtm(t) {
      _(s.isBN(t), "p", "bignum");
      let l;
      return t.andln(3) === 3 || t.andln(7) === 5 ? l = s.red(t) : l = s.mont(t), this.toRed(l).redSqrt().fromRed();
    }
    isqrtpq(t, l) {
      return this.sqrtpq(t, l)._move(this);
    }
    sqrtpq(t, l) {
      const B = this.sqrtm(t), U = this.sqrtm(l), [G, T] = t.egcd(l), M = U.mul(G).mul(t), $ = B.mul(T).mul(l), r = t.mul(l);
      return M.iadd($).imod(r);
    }
    /*
     * Primality Testing
     */
    isPrime(t, l, B) {
      return _(l >>> 0 === l, "reps", "uint32"), !(!this.isPrimeMR(t, l + 1, !0) || !this.isPrimeLucas(B));
    }
    isPrimeMR(t, l, B = !1) {
      _(l >>> 0 === l, "reps", "uint32"), _(l > 0, "reps", "integer"), _(typeof B == "boolean", "force2", "boolean");
      const U = this;
      if (U.cmpn(7) < 0)
        return U.cmpn(2) === 0 || U.cmpn(3) === 0 || U.cmpn(5) === 0;
      if (U.isEven())
        return !1;
      const G = U.subn(1), T = G.subn(2), M = G.zeroBits(), $ = G.ushrn(M), r = s.red(U), x = G.toRed(r), O = new s(1).toRed(r);
      e:
        for (let L = 0; L < l; L++) {
          let X;
          L === l - 1 && B ? X = new s(2) : (X = s.random(t, 0, T), X.iaddn(2));
          let P = X.toRed(r).redPow($);
          if (!(P.cmp(O) === 0 || P.cmp(x) === 0)) {
            for (let K = 1; K < M; K++) {
              if (P = P.redSqr(), P.cmp(x) === 0)
                continue e;
              if (P.cmp(O) === 0)
                return !1;
            }
            return !1;
          }
        }
      return !0;
    }
    isPrimeLucas(t = 0) {
      _(t >>> 0 === t, "limit", "uint32");
      const l = this;
      if (l.cmpn(1) <= 0)
        return !1;
      if (l.isEven())
        return l.cmpn(2) === 0;
      let B = 3;
      for (; ; ) {
        if (B > 1e4)
          throw new Error(`Cannot find (D/n) = -1 for ${l.toString(10)}.`);
        if (t !== 0 && B > t)
          return !1;
        const r = new s(B * B - 4).jacobi(l);
        if (r === -1)
          break;
        if (r === 0)
          return l.cmpn(B + 2) === 0;
        if (B === 40 && l.isSquare())
          return !1;
        B += 1;
      }
      const U = l.addn(1), G = U._makeOdd();
      let T = new s(2), M = new s(B);
      for (let $ = U.bitLength(); $ >= 0; $--)
        U.utestn($) ? (T = T.mul(M).isubn(B).imod(l), M = M.sqr().isubn(2).imod(l)) : (M = M.mul(T).isubn(B).imod(l), T = T.sqr().isubn(2).imod(l));
      if (T.cmpn(2) === 0 || T.cmp(l.subn(2)) === 0) {
        const $ = T.muln(B).imod(l), r = M.ushln(1).imod(l);
        if ($.cmp(r) === 0)
          return !0;
      }
      for (let $ = 0; $ < G - 1; $++) {
        if (T.isZero())
          return !0;
        if (T.cmpn(2) === 0)
          return !1;
        T = T.sqr().isubn(2).imod(l);
      }
      return !1;
    }
    /*
     * Twos Complement
     */
    toTwos(t) {
      return this.negative !== 0 ? this.abs().inotn(t).iaddn(1) : this.clone();
    }
    fromTwos(t) {
      return _(t >>> 0 === t, "width", "uint32"), F(t > 0, "width"), this.testn(t - 1) ? this.notn(t).iaddn(1).ineg() : this.clone();
    }
    /*
     * Reduction Context
     */
    toRed(t) {
      if (_(t instanceof J, "ctx", "reduction context"), this.red)
        throw new Error("Already in reduction context.");
      return t.convertTo(this);
    }
    fromRed() {
      return R(this.red, "fromRed"), this.red.convertFrom(this);
    }
    forceRed(t) {
      if (_(t instanceof J, "ctx", "reduction context"), this.red) {
        if (!t.m.eq(this.red.m) || t.mont !== this.red.mont)
          throw new Error("Already in reduction context.");
      } else
        F(this.negative === 0, "red"), F(this.ucmp(t.m) < 0, "red");
      return this.clone()._forceRed(t);
    }
    redIAdd(t) {
      return _(s.isBN(t), "num", "bignum"), R(this.red, "redIAdd"), this.red.iadd(this, t);
    }
    redAdd(t) {
      return _(s.isBN(t), "num", "bignum"), R(this.red, "redAdd"), this.red.add(this, t);
    }
    redIAddn(t) {
      return _(D(t), "num", "smi"), R(this.red, "redIAddn"), this.red.iaddn(this, t);
    }
    redAddn(t) {
      return _(D(t), "num", "smi"), R(this.red, "redAddn"), this.red.addn(this, t);
    }
    redISub(t) {
      return _(s.isBN(t), "num", "bignum"), R(this.red, "redISub"), this.red.isub(this, t);
    }
    redSub(t) {
      return _(s.isBN(t), "num", "bignum"), R(this.red, "redSub"), this.red.sub(this, t);
    }
    redISubn(t) {
      return _(D(t), "num", "smi"), R(this.red, "redISubn"), this.red.isubn(this, t);
    }
    redSubn(t) {
      return _(D(t), "num", "smi"), R(this.red, "redSubn"), this.red.subn(this, t);
    }
    redIMul(t) {
      return _(s.isBN(t), "num", "bignum"), R(this.red, "redIMul"), this.red.imul(this, t);
    }
    redMul(t) {
      return _(s.isBN(t), "num", "bignum"), R(this.red, "redMul"), this.red.mul(this, t);
    }
    redIMuln(t) {
      return _(D(t), "num", "smi"), R(this.red, "redIMuln"), this.red.imuln(this, t);
    }
    redMuln(t) {
      return _(D(t), "num", "smi"), R(this.red, "redMuln"), this.red.muln(this, t);
    }
    redIDiv(t) {
      return _(s.isBN(t), "num", "bignum"), R(this.red, "redIDiv"), this.red.idiv(this, t);
    }
    redDiv(t) {
      return _(s.isBN(t), "num", "bignum"), R(this.red, "redDiv"), this.red.div(this, t);
    }
    redIDivn(t) {
      return _(D(t), "num", "smi"), R(this.red, "redIDivn"), this.red.idivn(this, t);
    }
    redDivn(t) {
      return _(D(t), "num", "smi"), R(this.red, "redDivn"), this.red.divn(this, t);
    }
    redIPow(t) {
      return _(s.isBN(t), "num", "bignum"), R(this.red, "redIPow"), V(!t.red, "redIPow"), this.red.ipow(this, t);
    }
    redPow(t) {
      return _(s.isBN(t), "num", "bignum"), R(this.red, "redPow"), V(!t.red, "redPow"), this.red.pow(this, t);
    }
    redIPown(t) {
      return _(D(t), "num", "smi"), R(this.red, "redIPown"), this.red.ipown(this, t);
    }
    redPown(t) {
      return _(D(t), "num", "smi"), R(this.red, "redPown"), this.red.pown(this, t);
    }
    redISqr() {
      return R(this.red, "redISqr"), this.red.isqr(this);
    }
    redSqr() {
      return R(this.red, "redSqr"), this.red.sqr(this);
    }
    redISqrt() {
      return R(this.red, "redISqrt"), this.red.isqrt(this);
    }
    redSqrt() {
      return R(this.red, "redSqrt"), this.red.sqrt(this);
    }
    redIDivSqrt(t) {
      return R(this.red, "redIDivSqrt"), this.red.idivsqrt(this, t);
    }
    redDivSqrt(t) {
      return R(this.red, "redDivSqrt"), this.red.divsqrt(this, t);
    }
    redIsSquare() {
      return R(this.red, "redIsSquare"), this.red.isSquare(this);
    }
    redIShl(t) {
      return _(s.isBN(t), "num", "bignum"), R(this.red, "redIShl"), V(!t.red, "redIShl"), this.red.ishl(this, t);
    }
    redShl(t) {
      return _(s.isBN(t), "num", "bignum"), R(this.red, "redShl"), V(!t.red, "redShl"), this.red.shl(this, t);
    }
    redIShln(t) {
      return _(t >>> 0 === t, "num", "uint32"), R(this.red, "redIShln"), this.red.ishln(this, t);
    }
    redShln(t) {
      return _(t >>> 0 === t, "num", "uint32"), R(this.red, "redShln"), this.red.shln(this, t);
    }
    redINeg() {
      return R(this.red, "redINeg"), this.red.ineg(this);
    }
    redNeg() {
      return R(this.red, "redNeg"), this.red.neg(this);
    }
    redEq(t) {
      return _(s.isBN(t), "num", "bignum"), R(this.red, "redEq"), this.red.eq(this, t);
    }
    redEqn(t) {
      return _(D(t), "num", "smi"), R(this.red, "redEqn"), this.red.eqn(this, t);
    }
    redIsHigh() {
      return R(this.red, "redIsHigh"), this.red.isHigh(this);
    }
    redIsLow() {
      return R(this.red, "redIsLow"), this.red.isLow(this);
    }
    redIsOdd() {
      return R(this.red, "redIsOdd"), this.red.isOdd(this);
    }
    redIsEven() {
      return R(this.red, "redIsEven"), this.red.isEven(this);
    }
    redLegendre() {
      return R(this.red, "redLegendre"), this.red.legendre(this);
    }
    redJacobi() {
      return R(this.red, "redJacobi"), this.red.jacobi(this);
    }
    redKronecker() {
      return R(this.red, "redKronecker"), this.red.kronecker(this);
    }
    redIInvert() {
      return R(this.red, "redIInvert"), this.red.iinvert(this);
    }
    redInvert() {
      return R(this.red, "redInvert"), this.red.invert(this);
    }
    redIFermat() {
      return R(this.red, "redIFermat"), this.red.ifermat(this);
    }
    redFermat() {
      return R(this.red, "redFermat"), this.red.fermat(this);
    }
    /*
     * Internal
     */
    _move(t) {
      return t.words = this.words, t.length = this.length, t.negative = this.negative, t.red = this.red, t;
    }
    _alloc(t) {
      for (; this.words.length < t; )
        this.words.push(0);
      return this;
    }
    _expand(t) {
      for (this._alloc(t); this.length < t; )
        this.words[this.length++] = 0;
      return this;
    }
    _strip() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length -= 1;
      return this._normalize();
    }
    _normalize() {
      return q(this.length > 0), this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }
    _check() {
      return q(this.length > 0), q(this.length <= this.words.length), this.length === 1 ? (this.words[0] === 0 && q(this.negative === 0), this) : (q(this.words[this.length - 1] !== 0), this);
    }
    _invertp(t) {
      if (_(s.isBN(t), "p", "bignum"), F(t.sign() > 0, "invert"), q(t.isOdd()), t.cmpn(1) === 0)
        throw new RangeError("Not invertible.");
      const l = this.clone(), B = t.clone(), U = new s(1), G = new s(0);
      for ((l.isNeg() || l.ucmp(B) >= 0) && l.imod(B); !l.isZero(); ) {
        let T = l._makeOdd(), M = B._makeOdd();
        for (; T--; )
          U.isOdd() && U._iadd(U, t), U.iushrn(1);
        for (; M--; )
          G.isOdd() && G._iadd(G, t), G.iushrn(1);
        l.ucmp(B) >= 0 ? (l._isub(l, B), U.ucmp(G) < 0 ? (U._isub(G, U), U._isub(t, U)) : U._isub(U, G)) : (B._isub(B, l), G.ucmp(U) < 0 ? (G._isub(U, G), G._isub(t, G)) : G._isub(G, U));
      }
      if (B.cmpn(1) !== 0)
        throw new RangeError("Not invertible.");
      return q(G.negative === 0), q(G.ucmp(t) < 0), G;
    }
    _makeOdd() {
      const t = this.zeroBits();
      return t > 0 && this.iushrn(t), t;
    }
    _factor2(t) {
      if ((this.words[0] | t.words[0]) & 1)
        return 0;
      const l = Math.min(this.length, t.length);
      let B = 0;
      for (let U = 0; U < l; U++) {
        const G = y(this.words[U] | t.words[U]);
        if (B += G, G !== 26)
          break;
      }
      return B;
    }
    _cloneNormal() {
      return this.red ? this.fromRed() : this.clone();
    }
    _forceRed(t) {
      return this.red = t, this;
    }
    /*
     * Helpers
     */
    clone() {
      const t = new s();
      t.words = new Array(this.length);
      for (let l = 0; l < this.length; l++)
        t.words[l] = this.words[l];
      return t.length = this.length, t.negative = this.negative, t.red = this.red, t;
    }
    inject(t) {
      _(s.isBN(t), "num", "bignum"), this._alloc(t.length);
      for (let l = 0; l < t.length; l++)
        this.words[l] = t.words[l];
      return this.length = t.length, this.negative = t.negative, this.red = t.red, this;
    }
    set(t, l) {
      return this.fromNumber(t, l);
    }
    swap(t) {
      _(s.isBN(t), "num", "bignum");
      const l = this, B = t;
      return [l.words, B.words] = [B.words, l.words], [l.length, B.length] = [B.length, l.length], [l.negative, B.negative] = [B.negative, l.negative], [l.red, B.red] = [B.red, l.red], l;
    }
    reverse() {
      const t = this.negative;
      return this.fromBuffer(this.toBuffer("be"), "le"), this.negative = t, this;
    }
    byteLength() {
      return Math.ceil(this.bitLength() / 8);
    }
    bitLength() {
      const t = this.words[this.length - 1], l = oe(t);
      return (this.length - 1) * 26 + l;
    }
    zeroBits() {
      if (this.isZero() || this.isOdd())
        return 0;
      let t = 0;
      for (let l = 0; l < this.length; l++) {
        const B = y(this.words[l]);
        if (t += B, B !== 26)
          break;
      }
      return t;
    }
    isSafe() {
      return this.length <= 2 || this.length === 3 && this.words[2] === 1;
    }
    word(t) {
      return _(t >>> 0 === t, "pos", "uint32"), t >= this.length ? 0 : this.words[t];
    }
    [e]() {
      let t = "BN";
      return this.red && (t = "BN-R"), `<${t}: ${this.toString(10)}>`;
    }
    /*
     * Conversion
     */
    toNumber() {
      let t = this.words[0];
      if (this.length === 2)
        t += this.words[1] * 67108864;
      else if (this.length === 3 && this.words[2] === 1)
        t += 4503599627370496 + this.words[1] * 67108864;
      else if (this.length > 2)
        throw new RangeError("Number can only safely store up to 53 bits.");
      return this.negative !== 0 ? -t : t;
    }
    toDouble() {
      let t = 0;
      for (let l = this.length - 1; l >= 0; l--)
        t = t * 67108864 + this.words[l];
      return this.negative !== 0 ? -t : t;
    }
    valueOf() {
      return this.toDouble();
    }
    toBigInt() {
      if (!a)
        throw new Error("BigInt is not supported!");
      const t = BigInt(52), l = BigInt(26);
      let B = this.length - 1, U = BigInt(0);
      for (; B >= 1; B -= 2) {
        const G = this.words[B] * 67108864, T = this.words[B - 1];
        U = U << t | BigInt(G + T);
      }
      return B >= 0 && (U = U << l | BigInt(this.words[0])), this.negative !== 0 ? -U : U;
    }
    toBool() {
      return !this.isZero();
    }
    toString(t, l) {
      if (t = Z(t), l == null && (l = 0), l === 0 && (l = 1), _(t >>> 0 === t, "base", "uint32"), _(l >>> 0 === l, "padding", "uint32"), t < 2 || t > 36)
        throw new RangeError("Base ranges between 2 and 36.");
      if (this._check(), t === 16) {
        let M = "", $ = 0, r = 0;
        for (let x = 0; x < this.length; x++) {
          const O = this.words[x], L = ((O << $ | r) & 16777215).toString(16);
          r = O >>> 24 - $ & 16777215, r !== 0 || x !== this.length - 1 ? M = c[6 - L.length] + L + M : M = L + M, $ += 2, $ >= 26 && ($ -= 26, x -= 1);
        }
        for (r !== 0 && (M = r.toString(16) + M); M.length % l !== 0; )
          M = "0" + M;
        return this.negative !== 0 && (M = "-" + M), M;
      }
      const B = d[t - 1], U = w[t - 1], G = this.clone();
      let T = "";
      for (G.negative = 0; !G.isZero(); ) {
        const M = G.remrn(U).toString(t);
        G.iquon(U), G.isZero() ? T = M + T : T = c[B - M.length] + M + T;
      }
      for (this.isZero() && (T = "0"); T.length % l !== 0; )
        T = "0" + T;
      return this.negative !== 0 && (T = "-" + T), T;
    }
    toJSON() {
      return this.toString(16, 2);
    }
    toArray(t, l) {
      return this.toArrayLike(Array, t, l);
    }
    toBuffer(t, l) {
      return this.toArrayLike(k, t, l);
    }
    toArrayLike(t, l, B) {
      l == null && (l = "be"), B == null && (B = 0), _(typeof t == "function", "ArrayType", "function"), _(l === "be" || l === "le", "endian", "endianness"), _(B >>> 0 === B, "length", "uint32"), this._check();
      const U = this.byteLength(), G = B || Math.max(1, U);
      if (U > G)
        throw new RangeError("Byte array longer than desired length.");
      const T = Q(t, G);
      if (l === "be") {
        let M = T.length - 1, $ = 0;
        for (let r = 0; r < this.length; r++) {
          const x = (r & 3) << 1, O = this.words[r] << x | $;
          T[M--] = O & 255, M >= 0 && (T[M--] = O >>> 8 & 255), M >= 0 && (T[M--] = O >>> 16 & 255), x === 6 ? (M >= 0 && (T[M--] = O >>> 24 & 255), $ = 0) : $ = O >>> 24;
        }
        if (M >= 0) {
          for (T[M--] = $; M >= 0; )
            T[M--] = 0;
          $ = 0;
        }
        q($ === 0);
      } else {
        let M = 0, $ = 0;
        for (let r = 0; r < this.length; r++) {
          const x = (r & 3) << 1, O = this.words[r] << x | $;
          T[M++] = O & 255, M < T.length && (T[M++] = O >>> 8 & 255), M < T.length && (T[M++] = O >>> 16 & 255), x === 6 ? (M < T.length && (T[M++] = O >>> 24 & 255), $ = 0) : $ = O >>> 24;
        }
        if (M < T.length) {
          for (T[M++] = $; M < T.length; )
            T[M++] = 0;
          $ = 0;
        }
        q($ === 0);
      }
      return T;
    }
    encode(t, l) {
      return this.toBuffer(t, l);
    }
    /*
     * Instantiation
     */
    of(t, l) {
      return this.fromNumber(t, l);
    }
    fromNumber(t, l) {
      l == null && (l = "be"), _(ae(t), "num", "integer"), _(l === "be" || l === "le", "endian", "endianness");
      const B = t < 0 | 0;
      return B && (t = -t), t < 67108864 ? (this.words[0] = t & 67108863, this.length = 1) : t < 4503599627370496 ? (this.words = [
        t & 67108863,
        t / 67108864 & 67108863
      ], this.length = 2) : (this.words = [
        t & 67108863,
        t / 67108864 & 67108863,
        1
      ], this.length = 3), this.negative = B, l === "le" && this.reverse(), this;
    }
    fromDouble(t, l) {
      l == null && (l = "be"), _(typeof t == "number", "num", "double"), _(l === "be" || l === "le", "endian", "endianness"), isFinite(t) || (t = 0);
      const B = t <= -1 | 0;
      for (t < 0 && (t = -t), t = Math.floor(t), this.words = []; t > 0; ) {
        const U = t % 67108864, G = (t - U) / 67108864;
        this.words.push(U), t = G;
      }
      return this.words.length === 0 && this.words.push(0), this.length = this.words.length, this.negative = B, l === "le" && this.reverse(), this;
    }
    fromBigInt(t, l) {
      if (l == null && (l = "be"), _(typeof t == "bigint", "num", "bigint"), _(l === "be" || l === "le", "endian", "endianness"), !a)
        throw new Error("BigInt is not supported!");
      const B = t < BigInt(0) | 0;
      return this._fromHex(t.toString(16), B), this.negative = B, l === "le" && this.reverse(), this;
    }
    fromBool(t) {
      return _(typeof t == "boolean", "value", "boolean"), this.words[0] = t | 0, this.length = 1, this.negative = 0, this;
    }
    fromString(t, l, B) {
      if ((l === "le" || l === "be") && ([l, B] = [B, l]), l = Z(l), B == null && (B = "be"), _(typeof t == "string", "string", "string"), _(l >>> 0 === l, "base", "uint32"), _(B === "be" || B === "le", "endian", "endianness"), l < 2 || l > 36)
        throw new Error("Base ranges between 2 and 36.");
      t = t.replace(/\s+/g, "");
      let U = 0;
      return t.length > 0 && t.charCodeAt(0) === 45 && (U = 1), l === 16 ? this._fromHex(t, U) : this._fromBase(t, l, U), this.negative = U, this._normalize(), B === "le" && this.reverse(), this;
    }
    _fromHex(t, l) {
      this.length = Math.max(2, Math.ceil((t.length - l) / 6)), this.words = new Array(this.length);
      for (let T = 0; T < this.length; T++)
        this.words[T] = 0;
      let B = 0, U = t.length - 6, G = 0;
      for (; U >= l; U -= 6) {
        const T = Y(t, U, U + 6);
        this.words[G] |= T << B & 67108863, this.words[G + 1] |= T >>> 26 - B & 4194303, B += 24, B >= 26 && (B -= 26, G += 1);
      }
      if (U + 6 !== l) {
        const T = Y(t, l, U + 6);
        this.words[G] |= T << B & 67108863, this.words[G + 1] |= T >>> 26 - B & 4194303;
      }
      return this._strip();
    }
    _fromBase(t, l, B) {
      this.words[0] = 0, this.length = 1, this.negative = 0;
      let U = 0, G = 1;
      for (; G <= 67108863; G *= l)
        U += 1;
      U -= 1, G = G / l | 0;
      const T = t.length - B, M = T % U, $ = Math.min(T, T - M) + B;
      let r = B;
      for (; r < $; r += U) {
        const x = he(t, r, r + U, l);
        this.imuln(G), this._iaddn(x);
      }
      if (M !== 0) {
        const x = Math.pow(l, M), O = he(t, r, t.length, l);
        this.imuln(x), this._iaddn(O);
      }
      return this;
    }
    fromJSON(t) {
      if (s.isBN(t))
        return t.red ? t.fromRed() : t.clone();
      if (Array.isArray(t)) {
        for (const l of t)
          _(typeof l == "string", "chunk", "string");
        t = t.join("");
      }
      return this.fromString(t, 16);
    }
    fromBN(t) {
      return this.inject(t);
    }
    fromArray(t, l) {
      return _(Array.isArray(t), "data", "array"), this.fromArrayLike(t, l);
    }
    fromBuffer(t, l) {
      return _(k.isBuffer(t), "data", "buffer"), this.fromArrayLike(t, l);
    }
    fromArrayLike(t, l) {
      if (l == null && (l = "be"), _(t && t.length >>> 0 === t.length, "data", "array-like"), _(l === "be" || l === "le", "endian", "endianness"), t.length === 0)
        return this.words[0] = 0, this.length = 1, this.negative = 0, this;
      this.length = Math.max(2, Math.ceil(t.length / 3)), this.words = new Array(this.length), this.negative = 0;
      for (let M = 0; M < this.length; M++)
        this.words[M] = 0;
      const B = t.length % 3;
      let U = 0, G = 0, T = 0;
      if (l === "be") {
        for (let M = t.length - 1; M >= 2; M -= 3) {
          const $ = t[M] | t[M - 1] << 8 | t[M - 2] << 16;
          this.words[G] |= $ << U & 67108863, this.words[G + 1] = $ >>> 26 - U & 67108863, U += 24, U >= 26 && (U -= 26, G += 1);
        }
        switch (B) {
          case 2:
            T = t[1] | t[0] << 8;
            break;
          case 1:
            T = t[0];
            break;
        }
      } else {
        const M = t.length - B;
        for (let $ = 0; $ < M; $ += 3) {
          const r = t[$] | t[$ + 1] << 8 | t[$ + 2] << 16;
          this.words[G] |= r << U & 67108863, this.words[G + 1] = r >>> 26 - U & 67108863, U += 24, U >= 26 && (U -= 26, G += 1);
        }
        switch (B) {
          case 2:
            T = t[M] | t[M + 1] << 8;
            break;
          case 1:
            T = t[M];
            break;
        }
      }
      return B > 0 && (this.words[G] |= T << U & 67108863, this.words[G + 1] = T >>> 26 - U & 67108863), this._strip();
    }
    decode(t, l) {
      return this.fromBuffer(t, l);
    }
    from(t, l, B) {
      if (t == null)
        return this;
      if ((l === "le" || l === "be") && ([l, B] = [B, l]), typeof t == "number")
        return this.fromNumber(t, B);
      if (typeof t == "bigint")
        return this.fromBigInt(t, B);
      if (typeof t == "string")
        return this.fromString(t, l, B);
      if (typeof t == "object") {
        if (s.isBN(t))
          return this.fromBN(t, B);
        if (t.length >>> 0 === t.length)
          return this.fromArrayLike(t, B);
      }
      if (typeof t == "boolean")
        return this.fromBool(t);
      throw new TypeError("Non-numeric object passed to BN.");
    }
    /*
     * Static Methods
     */
    static min(...t) {
      let l = null;
      for (const B of t)
        _(s.isBN(B), "num", "bignum"), (!l || B.cmp(l) < 0) && (l = B);
      return l || new s(0);
    }
    static max(...t) {
      let l = null;
      for (const B of t)
        _(s.isBN(B), "num", "bignum"), (!l || B.cmp(l) > 0) && (l = B);
      return l || new s(0);
    }
    static cmp(t, l) {
      return _(s.isBN(t), "a", "bignum"), t.cmp(l);
    }
    static ucmp(t, l) {
      return _(s.isBN(t), "a", "bignum"), t.ucmp(l);
    }
    static red(t) {
      return new J(t);
    }
    static barrett(t) {
      return new N(t);
    }
    static mont(t) {
      return new z(t);
    }
    static _prime(t) {
      if (g[t])
        return g[t];
      let l;
      if (t === "p192")
        l = new v();
      else if (t === "p224")
        l = new b();
      else if (t === "p521")
        l = new h();
      else if (t === "k256")
        l = new o();
      else if (t === "p251")
        l = new S();
      else if (t === "p25519")
        l = new H();
      else if (t === "p448")
        l = new j();
      else
        throw new Error(`Unknown prime: "${t}".`);
      return g[t] = l, l;
    }
    static prime(t) {
      return s._prime(t).p.clone();
    }
    static pow(t, l) {
      return t === 2 ? s.shift(1, l) : new s().fromNumber(t).pown(l);
    }
    static shift(t, l) {
      return t === 1 ? new s(0).usetn(l, 1) : new s().fromNumber(t).ishln(l);
    }
    static mask(t) {
      return s.shift(1, t).isubn(1);
    }
    static randomBits(t, l) {
      if (_(t != null, "rng", "rng"), _(l >>> 0 === l, "bits", "uint32"), typeof t == "object") {
        _(typeof t.randomBytes == "function", "rng", "rng");
        const U = l + 7 >>> 3, G = U * 8, T = t.randomBytes(U);
        if (_(k.isBuffer(T), "bytes", "buffer"), T.length !== U)
          throw new RangeError("Invalid number of bytes returned from RNG.");
        const M = s.fromBuffer(T);
        return G > l && M.iushrn(G - l), M;
      }
      _(typeof t == "function", "rng", "rng");
      const B = t(l);
      if (_(s.isBN(B), "num", "bignum"), F(B.negative === 0, "RNG"), V(!B.red, "RNG"), B.bitLength() > l)
        throw new RangeError("Invalid number of bits returned from RNG.");
      return B;
    }
    static random(t, l, B) {
      if (l = s.cast(l, 16), B = s.cast(B, 16), l.cmp(B) > 0)
        throw new RangeError("Minimum cannot be greater than maximum.");
      const U = B.sub(l).iabs(), G = U.bitLength();
      if (G === 0)
        return l.clone();
      for (; ; ) {
        const T = s.randomBits(t, G);
        if (!(T.cmp(U) >= 0))
          return T.iadd(l), T;
      }
    }
    static of(t, l) {
      return new s().of(t, l);
    }
    static fromNumber(t, l) {
      return new s().fromNumber(t, l);
    }
    static fromDouble(t, l) {
      return new s().fromDouble(t, l);
    }
    static fromBigInt(t, l) {
      return new s().fromBigInt(t, l);
    }
    static fromBool(t) {
      return new s().fromBool(t);
    }
    static fromString(t, l, B) {
      return new s().fromString(t, l, B);
    }
    static fromJSON(t) {
      return new s().fromJSON(t);
    }
    static fromBN(t) {
      return new s().fromBN(t);
    }
    static fromArray(t, l) {
      return new s().fromArray(t, l);
    }
    static fromBuffer(t, l) {
      return new s().fromBuffer(t, l);
    }
    static fromArrayLike(t, l) {
      return new s().fromArrayLike(t, l);
    }
    static decode(t, l) {
      return new s().decode(t, l);
    }
    static from(t, l, B) {
      return new s().from(t, l, B);
    }
    static cast(t, l, B) {
      return s.isBN(t) ? t : new s(t, l, B);
    }
    static isBN(t) {
      return t instanceof s;
    }
  }
  s.BN = s, s.wordSize = 26, s.native = 0;
  class i {
    constructor(t, l) {
      this.name = t, this.p = new s(l, 16), this.n = this.p.bitLength(), this.k = s.shift(1, this.n).isub(this.p), this.lo = this.p.clone(), this.one = this.p.clone();
    }
    ireduce(t) {
      const l = t.negative !== 0;
      let B = t.bitLength();
      for (q(B <= this.n * 2), t.negative = 0; B > this.n; )
        this.split(t, this.lo), this.imulK(t), t._iadd(t, this.lo), B = t.bitLength();
      const U = B < this.n ? -1 : t.ucmp(this.p);
      return U === 0 ? (t.words[0] = 0, t.length = 1) : U > 0 && t._isub(t, this.p), l && !t.isZero() && t._isub(this.p, t), t;
    }
    split(t, l) {
      t._split(this.n, l);
    }
    imulK(t) {
      return t.imul(this.k);
    }
    pm2(t) {
      throw new Error("Not implemented.");
    }
    fermat(t) {
      return this.pm2(t);
    }
  }
  class p extends i {
    constructor(t, l) {
      super(t, l);
    }
    pm3d4(t) {
      throw new Error("Not implemented.");
    }
    pp1d4(t) {
      throw new Error("Not implemented.");
    }
    sqrt(t) {
      const { red: l } = t, B = this.pp1d4(t);
      if (!l.sqr(B).eq(t))
        throw new ue(B);
      return B;
    }
    divsqrt(t, l) {
      const { red: B } = t, U = B.sqr(t), G = B.mul(U, t), T = B.mul(G, U), M = B.mul(B.sqr(l), l), $ = this.pm3d4(B.mul(T, M)), r = B.mul(B.mul(G, l), $);
      if (B.mul(l, B.sqr(r)).eq(t))
        return r;
      throw new ue(r);
    }
  }
  class m extends i {
    constructor(t, l, B) {
      super(t, l), this.sm1 = new s(B, 16);
    }
    pm5d8(t) {
      throw new Error("Not implemented.");
    }
    pp3d8(t) {
      throw new Error("Not implemented.");
    }
    sqrt(t) {
      const { red: l } = t, B = this.sm1._forceRed(l), U = this.pp3d8(t);
      if (l.sqr(U).eq(t))
        return U;
      const G = l.mul(U, B);
      if (l.sqr(G).eq(t))
        return G;
      throw new ue(U);
    }
    divsqrt(t, l) {
      const { red: B } = t, U = this.sm1._forceRed(B), G = B.mul(B.sqr(l), l), T = B.mul(B.sqr(G), l), M = this.pm5d8(B.mul(t, T)), $ = B.mul(B.mul(t, G), M), r = B.mul(l, B.sqr($));
      if (r.eq(t))
        return $;
      const x = B.ineg(r);
      if (x.eq(t))
        return B.mul($, U);
      throw x.eq(B.mul(t, U)) ? new ue(B.mul($, U)) : new ue($);
    }
  }
  class E extends i {
    constructor(t, l, B) {
      super(t, l), this.g = new s(B, 16), this.z = this.p.subn(1).zeroBits();
    }
    powS(t) {
      throw new Error("Not implemented.");
    }
    powE(t) {
      throw new Error("Not implemented.");
    }
    sqrt(t) {
      const { red: l } = t;
      switch (l.jacobi(t)) {
        case -1:
          throw new ue(t);
        case 0:
          return t.clone();
      }
      let B = this.g._forceRed(l), U = this.powE(t), G = this.powS(t), T = this.z;
      for (; ; ) {
        let M = G, $ = 0;
        for (; M.cmpn(1) !== 0 && $ < T; )
          M = l.sqr(M), $ += 1;
        if ($ === 0)
          break;
        q($ < T), M = l.sqrn(B, T - $ - 1), B = l.sqr(M), U = l.mul(U, M), G = l.mul(G, B), T = $;
      }
      return U;
    }
    divsqrt(t, l) {
      const { red: B } = t;
      if (l.isZero())
        throw new ue(l);
      return this.sqrt(B.div(t, l));
    }
  }
  class v extends p {
    constructor() {
      super("p192", "ffffffff ffffffff ffffffff fffffffeffffffff ffffffff");
    }
    imulK(t) {
      const l = this.one.inject(t);
      return t.iushln(64)._iadd(t, l);
    }
    core(t) {
      const { red: l } = t, B = l.sqrnmul(t, 1, t), U = l.sqrnmul(B, 1, t), G = l.sqrnmul(U, 3, U), T = l.sqrnmul(G, 6, G), M = l.sqrnmul(T, 12, T), $ = l.sqrnmul(M, 6, G), r = l.sqrnmul($, 1, t), x = l.sqrnmul(r, 31, r), O = l.sqrnmul(x, 62, x), L = l.sqrnmul(O, 3, U), X = l.sqrn(L, 1);
      return l.sqrnmul(X, 62, x);
    }
    pm3d4(t) {
      return this.core(t);
    }
    pm2(t) {
      const { red: l } = t, B = this.core(t), U = l.sqrn(B, 1);
      return l.sqrnmul(U, 1, t);
    }
    pp1d4(t) {
      const { red: l } = t, B = l.sqrnmul(t, 1, t), U = l.sqrnmul(B, 2, B), G = l.sqrnmul(U, 4, U), T = l.sqrnmul(G, 8, G), M = l.sqrnmul(T, 16, T), $ = l.sqrnmul(M, 32, M), r = l.sqrnmul($, 64, $);
      return l.sqrn(r, 62);
    }
  }
  class b extends E {
    constructor() {
      super(
        "p224",
        "ffffffff ffffffff ffffffff ffffffff00000000 00000000 00000001",
        "6a0fec67 8598a792 0c55b2d4 0b2d6ffbbea3d8ce f3fb3632 dc691b74"
      );
    }
    imulK(t) {
      const l = this.one.inject(t);
      return t.iushln(96)._isub(t, l);
    }
    powS(t) {
      const { red: l } = t, B = l.sqrnmul(t, 1, t), U = l.sqrnmul(B, 2, B), G = l.sqrnmul(U, 4, U), T = l.sqrnmul(G, 8, G), M = l.sqrnmul(T, 16, T), $ = l.sqrnmul(M, 32, M);
      return l.sqrnmul($, 64, $);
    }
    powE(t) {
      const { red: l } = t;
      return l.sqrn(t, 127);
    }
    pm2(t) {
      const { red: l } = t, B = l.sqrnmul(t, 1, t), U = l.sqrnmul(B, 1, t), G = l.sqrnmul(U, 3, U), T = l.sqrnmul(G, 6, G), M = l.sqrnmul(T, 12, T), $ = l.sqrnmul(M, 24, M), r = l.sqrnmul($, 48, $), x = l.sqrnmul(r, 24, M), O = l.sqrnmul(x, 6, G), L = l.sqrnmul(O, 1, t), X = l.sqrn(L, 1);
      return l.sqrnmul(X, 96, r);
    }
  }
  class h extends p {
    constructor() {
      super("p521", "000001ff ffffffff ffffffff ffffffffffffffff ffffffff ffffffff ffffffffffffffff ffffffff ffffffff ffffffffffffffff ffffffff ffffffff ffffffffffffffff");
    }
    imulK(t) {
      return t;
    }
    core(t) {
      const { red: l } = t, B = l.sqrnmul(t, 1, t), U = l.sqrnmul(B, 1, t), G = l.sqrnmul(U, 3, U), T = l.sqrnmul(G, 1, t), M = l.sqrnmul(T, 1, t), $ = l.sqrnmul(M, 8, M), r = l.sqrnmul($, 16, $), x = l.sqrnmul(r, 32, r), O = l.sqrnmul(x, 64, x), L = l.sqrnmul(O, 128, O), X = l.sqrnmul(L, 256, L);
      return l.sqrnmul(X, 7, T);
    }
    pm3d4(t) {
      return this.core(t);
    }
    pm2(t) {
      const { red: l } = t, B = this.core(t), U = l.sqrn(B, 1);
      return l.sqrnmul(U, 1, t);
    }
    pp1d4(t) {
      const { red: l } = t;
      return l.sqrn(t, 519);
    }
  }
  class o extends p {
    constructor() {
      super("k256", "ffffffff ffffffff ffffffff ffffffffffffffff ffffffff fffffffe fffffc2f");
    }
    split(t, l) {
      const U = Math.min(t.length, 9);
      l._alloc(U + 1);
      for (let M = 0; M < U; M++)
        l.words[M] = t.words[M];
      if (l.length = U, t.length <= 9) {
        l._strip(), t.words[0] = 0, t.length = 1;
        return;
      }
      let G = t.words[9], T = 10;
      for (l.words[l.length++] = G & 4194303, l._strip(); T < t.length; T++) {
        const M = t.words[T] | 0;
        t.words[T - 10] = (M & 4194303) << 4 | G >>> 22, G = M;
      }
      G >>>= 22, t.words[T - 10] = G, G === 0 && t.length > 10 ? t.length -= 10 : t.length -= 9, t._strip();
    }
    imulK(t) {
      t._expand(t.length + 2);
      let l = 0;
      for (let B = 0; B < t.length; B++) {
        const U = t.words[B];
        l += U * 977, t.words[B] = l & 67108863, l = U * 64 + Math.floor(l / 67108864);
      }
      return t.words[t.length - 1] === 0 && (t.length -= 1, t.words[t.length - 1] === 0 && (t.length -= 1)), t;
    }
    core(t, l) {
      const { red: B } = t, U = B.sqrnmul(l, 1, t), G = B.sqrnmul(U, 3, U), T = B.sqrnmul(G, 3, U), M = B.sqrnmul(T, 2, l), $ = B.sqrnmul(M, 11, M), r = B.sqrnmul($, 22, $), x = B.sqrnmul(r, 44, r), O = B.sqrnmul(x, 88, x), L = B.sqrnmul(O, 44, r), X = B.sqrnmul(L, 3, U), P = B.sqrn(X, 1), K = B.sqrnmul(P, 22, $);
      return B.sqrn(K, 4);
    }
    pm3d4(t) {
      const { red: l } = t, B = l.sqrnmul(t, 1, t), U = this.core(t, B), G = l.sqrnmul(U, 1, t), T = l.sqrn(G, 1);
      return l.sqrnmul(T, 2, B);
    }
    pm2(t) {
      const { red: l } = t, B = l.sqrnmul(t, 1, t), U = this.core(t, B), G = l.sqrnmul(U, 1, t), T = l.sqrn(G, 1), M = l.sqrnmul(T, 2, B), $ = l.sqrn(M, 1);
      return l.sqrnmul($, 1, t);
    }
    pp1d4(t) {
      const { red: l } = t, B = l.sqrnmul(t, 1, t), U = this.core(t, B), G = l.sqrnmul(U, 2, B);
      return l.sqrn(G, 2);
    }
  }
  class S extends p {
    constructor() {
      super("p251", "07ffffff ffffffff ffffffff ffffffffffffffff ffffffff ffffffff fffffff7");
    }
    imulK(t) {
      if (t.isZero())
        return t;
      let l = 0;
      for (let B = 0; B < t.length; B++) {
        const U = t.words[B] * 9 + l;
        l = U >>> 26, t.words[B] = U & 67108863;
      }
      return l !== 0 && (t._alloc(t.length + 1), t.words[t.length++] = l), t;
    }
    core(t) {
      const { red: l } = t, B = l.sqrnmul(t, 1, t), U = l.sqrnmul(B, 1, t), G = l.sqrnmul(U, 3, U), T = l.sqrnmul(G, 6, G), M = l.sqrnmul(T, 12, T), $ = l.sqrnmul(M, 24, M), r = l.sqrnmul($, 48, $), x = l.sqrnmul(r, 96, r), O = l.sqrnmul(x, 48, $), L = l.sqrnmul(O, 6, G);
      return l.sqrnmul(L, 1, t);
    }
    pm3d4(t) {
      const { red: l } = t, B = this.core(t), U = l.sqrn(B, 1);
      return l.sqrnmul(U, 1, t);
    }
    pm2(t) {
      const { red: l } = t, B = this.core(t), U = l.sqrn(B, 1), G = l.sqrnmul(U, 1, t), T = l.sqrn(G, 1);
      return l.sqrnmul(T, 1, t);
    }
    pp1d4(t) {
      const { red: l } = t, B = this.core(t), U = l.sqrnmul(B, 1, t);
      return l.sqrn(U, 1);
    }
  }
  class H extends m {
    constructor() {
      super(
        "p25519",
        "7fffffff ffffffff ffffffff ffffffffffffffff ffffffff ffffffff ffffffed",
        "2b832480 4fc1df0b 2b4d0099 3dfbd7a72f431806 ad2fe478 c4ee1b27 4a0ea0b0"
      );
    }
    imulK(t) {
      let l = 0;
      for (let B = 0; B < t.length; B++) {
        const U = t.words[B] * 19 + l;
        l = U >>> 26, t.words[B] = U & 67108863;
      }
      return l !== 0 && (t._alloc(t.length + 1), t.words[t.length++] = l), t;
    }
    core(t, l) {
      const { red: B } = t, U = B.sqrnmul(l, 2, l), G = B.sqrnmul(U, 1, t), T = B.sqrnmul(G, 5, G), M = B.sqrnmul(T, 10, T), $ = B.sqrnmul(M, 20, M), r = B.sqrnmul($, 10, T), x = B.sqrnmul(r, 50, r), O = B.sqrnmul(x, 100, x);
      return B.sqrnmul(O, 50, r);
    }
    pm5d8(t) {
      const { red: l } = t, B = l.sqrnmul(t, 1, t), U = this.core(t, B), G = l.sqrn(U, 1);
      return l.sqrnmul(G, 1, t);
    }
    pm2(t) {
      const { red: l } = t, B = l.sqrnmul(t, 1, t), U = this.core(t, B), G = l.sqrn(U, 1), T = l.sqrnmul(G, 1, t), M = l.sqrn(T, 1);
      return l.sqrnmul(M, 2, B);
    }
    pp3d8(t) {
      const { red: l } = t, B = l.sqrnmul(t, 1, t), U = this.core(t, B), G = l.sqrnmul(U, 1, t);
      return l.sqrn(G, 1);
    }
  }
  class j extends p {
    constructor() {
      super("p448", "ffffffff ffffffff ffffffff ffffffffffffffff ffffffff fffffffe ffffffffffffffff ffffffff ffffffff ffffffffffffffff ffffffff");
    }
    imulK(t) {
      const l = this.one.inject(t);
      return t.iushln(224)._iadd(t, l);
    }
    core(t, l) {
      const { red: B } = t, U = B.sqrnmul(l, 1, t), G = B.sqrnmul(U, 3, U), T = B.sqrnmul(G, 3, U), M = B.sqrnmul(T, 2, l), $ = B.sqrnmul(M, 11, M), r = B.sqrnmul($, 22, $), x = B.sqrnmul(r, 44, r), O = B.sqrnmul(x, 88, x), L = B.sqrnmul(O, 44, r);
      return B.sqrnmul(L, 2, l);
    }
    pm3d4(t) {
      const { red: l } = t, B = l.sqrnmul(t, 1, t), U = this.core(t, B), G = l.sqrnmul(U, 1, t), T = l.sqrn(G, 1);
      return l.sqrnmul(T, 222, U);
    }
    pm2(t) {
      const { red: l } = t, B = this.pm3d4(t), U = l.sqrn(B, 1);
      return l.sqrnmul(U, 1, t);
    }
    pp1d4(t) {
      const { red: l } = t, B = l.sqrnmul(t, 1, t), U = this.core(t, B), G = l.sqrnmul(U, 2, B);
      return l.sqrn(G, 222);
    }
  }
  class J {
    constructor(t) {
      let l = null;
      typeof t == "string" && (l = s._prime(t), t = l.p), _(s.isBN(t), "m", "bignum"), V(!t.red, "reduction"), F(t.sign() > 0, "reduction"), this.m = t, this.prime = l, this.mb = null, this.sm1 = null;
    }
    _verify1(t) {
      F(t.negative === 0, "red"), R(t.red != null, "red");
    }
    _verify2(t, l) {
      F((t.negative | l.negative) === 0, "red"), R(t.red != null && t.red === l.red, "red");
    }
    get mont() {
      return !1;
    }
    precompute() {
      if (this.sm1 === null && this.m.andln(7) === 5)
        if (this.prime)
          this.sm1 = this.prime.sm1.clone()._forceRed(this);
        else {
          const t = new s(2).toRed(this), l = this.m.subn(1).iushrn(2);
          this.sm1 = this.pow(t, l);
        }
      return this;
    }
    convertTo(t) {
      const l = t.mod(this.m);
      return l.red = this, l;
    }
    convertFrom(t) {
      const l = t.clone();
      return l.red = null, l;
    }
    intTo(t) {
      return t;
    }
    intFrom(t) {
      return t;
    }
    imod(t) {
      return this.prime ? this.prime.ireduce(t)._forceRed(this) : t.imod(this.m)._forceRed(this);
    }
    iadd(t, l) {
      return this._verify2(t, l), t._iadd(t, l), t.ucmp(this.m) >= 0 && t._isub(t, this.m), t;
    }
    add(t, l) {
      return t.length < l.length ? this.iadd(l.clone(), t) : this.iadd(t.clone(), l);
    }
    iaddn(t, l) {
      return this._verify1(t), l < 0 ? this.isubn(t, -l) : (this.m.length === 1 && (l %= this.m.words[0]), t._iaddn(l), t.ucmp(this.m) >= 0 && t._isub(t, this.m), t);
    }
    addn(t, l) {
      return this.iaddn(t.clone(), l);
    }
    isub(t, l) {
      this._verify2(t, l);
      const B = t.ucmp(l);
      return B === 0 ? (t.words[0] = 0, t.length = 1, t) : (B < 0 ? (t._isub(l, t), t._isub(this.m, t)) : t._isub(t, l), t);
    }
    sub(t, l) {
      return this.isub(t.clone(), l);
    }
    isubn(t, l) {
      return this._verify1(t), l < 0 ? this.iaddn(t, -l) : (this.m.length === 1 && (l %= this.m.words[0]), t.length === 1 && t.words[0] < l ? (t.words[0] = l - t.words[0], t._isub(this.m, t)) : t._isubn(l), t);
    }
    subn(t, l) {
      return this.isubn(t.clone(), l);
    }
    imul(t, l) {
      return this._verify2(t, l), this.imod(t.imul(l));
    }
    mul(t, l) {
      return this._verify2(t, l), this.imod(t.mul(l));
    }
    imuln(t, l) {
      if (this._verify1(t), t.isZero())
        return t;
      if (l === 0)
        return t.words[0] = 0, t.length = 1, t;
      const B = l < 0;
      if (B && (l = -l), this.m.length === 1 && (l %= this.m.words[0]), t.imuln(l), l <= 16)
        for (; t.ucmp(this.m) >= 0; )
          t._isub(t, this.m);
      else
        this.imod(t);
      return B && this.ineg(t), t;
    }
    muln(t, l) {
      return this.imuln(t.clone(), l);
    }
    idiv(t, l) {
      return this.div(t, l)._move(t);
    }
    div(t, l) {
      return this.mul(t, this.invert(l));
    }
    idivn(t, l) {
      return this.divn(t, l)._move(t);
    }
    divn(t, l) {
      return this.div(t, this.convertTo(new s(l)));
    }
    ipow(t, l) {
      return this.pow(t, l)._move(t);
    }
    pow(t, l) {
      return this._verify1(t), l.isNeg() && (t = this.invert(t)), l.length === 1 ? this.pown(t, l.words[0]) : a && !this.prime ? this.powInt(t, l) : this.powNum(t, l);
    }
    powNum(t, l) {
      const B = new s(1).toRed(this), U = new Array(u), G = this.sqr(t);
      U[0] = t;
      for (let $ = 1; $ < u; $++)
        U[$] = this.mul(U[$ - 1], G);
      let T = l.bitLength(), M = B;
      for (; T >= n; ) {
        let $ = n, r = l.bits(T - $, $);
        if (r < u) {
          M = this.sqr(M), T -= 1;
          continue;
        }
        for (; (r & 1) === 0; )
          $ -= 1, r >>= 1;
        M === B ? M = U[r >> 1].clone() : (M = this.sqrn(M, $), M = this.mul(M, U[r >> 1])), T -= $;
      }
      if (T > 0) {
        const $ = l.bits(0, T);
        for (; T--; )
          M = this.sqr(M), $ >> T & 1 && (M = this.mul(M, t));
      }
      return M;
    }
    powInt(t, l) {
      this.mb === null && (this.mb = this.m.toBigInt());
      const B = this.intFrom(t.toBigInt()), U = be(B, l, this.mb), G = this.intTo(U);
      return s.fromBigInt(G)._forceRed(this);
    }
    sqrn(t, l) {
      for (; l--; )
        t = this.sqr(t);
      return t;
    }
    sqrnmul(t, l, B) {
      return this.mul(this.sqrn(t, l), B);
    }
    ipown(t, l) {
      return this.pown(t, l)._move(t);
    }
    pown(t, l) {
      if (this._verify1(t), l < 0 && (t = this.invert(t), l = -l), l === 0)
        return new s(1).toRed(this);
      if (l === 1)
        return t.clone();
      const B = oe(l);
      let U = t;
      for (let G = B - 2; G >= 0; G--)
        U = this.sqr(U), l >> G & 1 && (U = this.mul(U, t));
      return U;
    }
    isqr(t) {
      return this.imul(t, t);
    }
    sqr(t) {
      return this.mul(t, t);
    }
    isqrt(t) {
      return this.sqrt(t)._move(t);
    }
    sqrt(t) {
      return this._verify1(t), this.prime ? this.prime.sqrt(t) : this.m.andln(3) === 3 ? this.sqrt3mod4(t) : this.m.andln(7) === 5 ? this.sm1 != null ? this.sqrt5mod8sm1(t) : this.sqrt5mod8(t) : this.sqrt0(t);
    }
    sqrt3mod4(t) {
      const l = this.m.addn(1).iushrn(2), B = this.pow(t, l);
      if (!this.sqr(B).eq(t))
        throw new ue(B);
      return B;
    }
    sqrt5mod8(t) {
      const l = new s(1).toRed(this), B = this.m.ushrn(3), U = this.add(t, t), G = this.pow(U, B), T = this.mul(U, this.sqr(G)), M = this.mul(this.mul(G, t), this.isub(T, l));
      if (!this.sqr(M).eq(t))
        throw new ue(M);
      return M;
    }
    sqrt5mod8sm1(t) {
      const l = this.m.addn(3).iushrn(3), B = this.pow(t, l);
      if (this.sqr(B).eq(t))
        return B;
      const U = this.mul(B, this.sm1);
      if (this.sqr(U).eq(t))
        return U;
      throw new ue(B);
    }
    sqrt0(t) {
      if (this.m.cmpn(1) === 0 || !this.m.isOdd())
        throw new Error("Invalid prime.");
      switch (this.jacobi(t)) {
        case -1:
          throw new ue(t);
        case 0:
          return t.clone();
      }
      const l = new s(1).toRed(this), B = this.m.subn(1), U = B._makeOdd(), G = new s(2).toRed(this);
      for (; this.jacobi(G) !== -1; )
        this.iadd(G, l);
      let T = this.pow(G, B), M = this.pow(t, B), $ = this.pow(t, B.iaddn(1).iushrn(1)), r = U;
      for (; ; ) {
        let x = M, O = 0;
        for (; !x.eq(l) && O < r; )
          x = this.sqr(x), O += 1;
        if (O === 0)
          break;
        q(O < r), x = this.sqrn(T, r - O - 1), T = this.sqr(x), $ = this.mul($, x), M = this.mul(M, T), r = O;
      }
      return $;
    }
    idivsqrt(t, l) {
      return this.divsqrt(t, l)._move(t);
    }
    divsqrt(t, l) {
      if (this._verify2(t, l), t.isZero() && l.isZero())
        throw new ue(l);
      if (this.prime)
        return this.prime.divsqrt(t, l);
      if (this.m.andln(3) === 3)
        return this.divsqrt3mod4(t, l);
      if (this.sm1 != null && this.m.andln(7) === 5)
        return this.divsqrt5mod8(t, l);
      if (l.isZero())
        throw new ue(l);
      return this.sqrt(this.div(t, l));
    }
    divsqrt3mod4(t, l) {
      const B = this.m.subn(3).iushrn(2), U = this.sqr(t), G = this.mul(U, t), T = this.mul(G, U), M = this.mul(this.sqr(l), l), $ = this.pow(this.mul(T, M), B), r = this.mul(this.mul(G, l), $);
      if (this.mul(l, this.sqr(r)).eq(t))
        return r;
      throw new ue(r);
    }
    divsqrt5mod8(t, l) {
      const B = this.m.subn(5).iushrn(3), U = this.mul(this.sqr(l), l), G = this.mul(this.sqr(U), l), T = this.pow(this.mul(t, G), B), M = this.mul(this.mul(t, U), T), $ = this.mul(l, this.sqr(M));
      if ($.eq(t))
        return M;
      const r = this.ineg($);
      if (r.eq(t))
        return this.mul(M, this.sm1);
      throw r.eq(this.mul(t, this.sm1)) ? new ue(this.mul(M, this.sm1)) : new ue(M);
    }
    isSquare(t) {
      return this.m.isOdd() ? this.jacobi(t) >= 0 : this.kronecker(t) >= 0;
    }
    ishl(t, l) {
      return this._verify1(t), this.imod(t.iushl(l));
    }
    shl(t, l) {
      return this.ishl(t.clone(), l);
    }
    ishln(t, l) {
      if (this._verify1(t), t.iushln(l), l <= 4)
        for (; t.ucmp(this.m) >= 0; )
          t._isub(t, this.m);
      else
        this.imod(t);
      return t;
    }
    shln(t, l) {
      return this.ishln(t.clone(), l);
    }
    ineg(t) {
      return this._verify1(t), t.isZero() || t._isub(this.m, t), t;
    }
    neg(t) {
      return this.ineg(t.clone());
    }
    eq(t, l) {
      return this._verify2(t, l), t.ucmp(l) === 0;
    }
    eqn(t, l) {
      if (this._verify1(t), this.m.length === 1)
        return l %= this.m.words[0], l < 0 && (l += this.m.words[0]), t.ucmpn(l) === 0;
      if (l < 0) {
        this.m._isubn(-l);
        const B = t.ucmp(this.m);
        return this.m._iaddn(-l), B === 0;
      }
      return t.ucmpn(l) === 0;
    }
    isHigh(t) {
      return !this.isLow(t);
    }
    isLow(t) {
      return this._verify1(t), t.ucmp(this.m.ushrn(1)) <= 0;
    }
    isOdd(t) {
      return this._verify1(t), t.isOdd();
    }
    isEven(t) {
      return this._verify1(t), t.isEven();
    }
    legendre(t) {
      if (this._verify1(t), this.m.isEven())
        throw new Error("legendre: `num` must be odd.");
      const l = this.m.subn(1).iushrn(1), B = this.pow(t, l);
      if (B.isZero())
        return 0;
      const U = new s(1).toRed(this);
      if (B.eq(U))
        return 1;
      if (B.eq(this.ineg(U)))
        return -1;
      throw new Error("Invalid prime.");
    }
    jacobi(t) {
      return this._verify1(t), t.jacobi(this.m);
    }
    kronecker(t) {
      return this._verify1(t), t.kronecker(this.m);
    }
    iinvert(t) {
      return this.invert(t)._move(t);
    }
    invert(t) {
      return this._verify1(t), t.invert(this.m)._forceRed(this);
    }
    ifermat(t) {
      return this.fermat(t)._move(t);
    }
    fermat(t) {
      if (this._verify1(t), t.isZero() || this.m.cmpn(1) === 0)
        throw new RangeError("Not invertible.");
      return this.prime ? this.prime.fermat(t) : this.pow(t, this.m.subn(2));
    }
    invertAll(t) {
      _(Array.isArray(t), "elems", "array");
      for (const G of t)
        _(s.isBN(G), "elem", "bignum"), this._verify1(G);
      if (this.m.cmpn(1) === 0 || this.m.isEven())
        throw new RangeError("Not invertible.");
      const l = t.length, B = new Array(l);
      if (l === 0)
        return B;
      let U = new s(1).toRed(this);
      for (let G = 0; G < l; G++) {
        if (t[G].isZero()) {
          B[G] = t[G].clone();
          continue;
        }
        B[G] = U, U = this.mul(U, t[G]);
      }
      U = this.invert(U);
      for (let G = l - 1; G >= 0; G--)
        t[G].isZero() || (B[G] = this.mul(U, B[G]), U = this.mul(U, t[G]));
      return B;
    }
    [e]() {
      return this.prime ? `<Red: ${this.prime.name}>` : `<Red: ${this.m.toString(10)}>`;
    }
  }
  class N extends J {
    constructor(t) {
      super(t), this.prime = null, this.n = this.m.bitLength(), this.n % 26 !== 0 && (this.n += 26 - this.n % 26), this.k = this.n * 2, this.w = this.k / 26, this.b = s.shift(1, this.k).div(this.m);
    }
    convertTo(t) {
      return t.length > this.w ? super.convertTo(t) : this.imod(t.clone());
    }
    _shift(t) {
      let l = 0, B = this.w;
      for (; B < t.length; )
        t.words[l++] = t.words[B++];
      l === 0 && (t.words[l++] = 0), t.length = l;
    }
    imod(t) {
      const l = t.negative;
      q(t.length <= this.w), t.negative = 0;
      const B = t.mul(this.b);
      return this._shift(B), t._isub(t, B.mul(this.m)), t.ucmp(this.m) >= 0 && t._isub(t, this.m), l && !t.isZero() && t._isub(this.m, t), t.red = this, t;
    }
  }
  class z extends J {
    constructor(t) {
      super(t), this.prime = null, this.n = this.m.length * 26, this.r = s.shift(1, this.n), this.r2 = s.shift(1, this.n * 2).imod(this.m), this.ri = this.r.invert(this.m), this.mi = this.r.mul(this.ri).isubn(1).div(this.m), this.rib = null;
    }
    get mont() {
      return !0;
    }
    convertTo(t) {
      return t.isNeg() || t.ucmp(this.m) >= 0 ? this.imod(t.ushln(this.n)) : this.mul(t, this.r2);
    }
    convertFrom(t) {
      const l = this.mul(t, new s(1));
      return l.red = null, l;
    }
    intTo(t) {
      return (t << BigInt(this.n)) % this.mb;
    }
    intFrom(t) {
      return this.rib === null && (this.rib = this.ri.toBigInt()), t * this.rib % this.mb;
    }
    iaddn(t, l) {
      return this.iadd(t, this.convertTo(new s(l)));
    }
    isubn(t, l) {
      return this.isub(t, this.convertTo(new s(l)));
    }
    imul(t, l) {
      return this.mul(t, l)._move(t);
    }
    mul(t, l) {
      if (t.isZero() || l.isZero())
        return new s(0)._forceRed(this);
      const B = t.mul(l), U = B.umaskn(this.n).mul(this.mi).iumaskn(this.n), G = B.iadd(U.mul(this.m)).iushrn(this.n);
      return G.ucmp(this.m) >= 0 && G._isub(G, this.m), G._forceRed(this);
    }
    imuln(t, l) {
      if (this._verify1(t), t.isZero())
        return t;
      if (l === 0)
        return t.words[0] = 0, t.length = 1, t;
      const B = l < 0;
      B && (l = -l), this.m.length === 1 && (l %= this.m.words[0]);
      const U = oe(l);
      if (U > 5)
        this.imul(t, this.convertTo(new s(l)));
      else if ((l & l - 1) === 0)
        for (let G = 0; G < U - 1; G++)
          this.iadd(t, t);
      else {
        const G = t.clone();
        for (let T = U - 2; T >= 0; T--)
          this.iadd(t, t), l >> T & 1 && this.iadd(t, G);
      }
      return B && this.ineg(t), t;
    }
    eqn(t, l) {
      return this._verify1(t), l === 0 ? t.isZero() : t.ucmp(this.convertTo(new s(l))) === 0;
    }
    isLow(t) {
      return this._verify1(t), this.convertFrom(t).ucmp(this.m.ushrn(1)) <= 0;
    }
    isOdd(t) {
      return this._verify1(t), this.convertFrom(t).isOdd();
    }
    isEven(t) {
      return this._verify1(t), this.convertFrom(t).isEven();
    }
    invert(t) {
      return this._verify1(t), this.imod(t.invert(this.m).mul(this.r2));
    }
  }
  function A(se, t, l) {
    const B = new se(t);
    return se.captureStackTrace && se.captureStackTrace(B, l), B;
  }
  function q(se, t) {
    if (!se)
      throw A(Error, t || "Assertion failed.", q);
  }
  function _(se, t, l) {
    if (!se) {
      const B = `"${t}" must be a(n) ${l}.`;
      throw A(TypeError, B, _);
    }
  }
  function F(se, t) {
    if (!se) {
      const l = `"${t}" only works with positive numbers.`;
      throw A(RangeError, l, F);
    }
  }
  function R(se, t) {
    if (!se) {
      const l = `"${t}" only works with red numbers.`;
      throw A(TypeError, l, R);
    }
  }
  function V(se, t) {
    if (!se) {
      const l = `"${t}" only works with normal numbers.`;
      throw A(TypeError, l, V);
    }
  }
  function fe(se) {
    if (!se)
      throw A(RangeError, "Cannot divide by zero.", fe);
  }
  class ue extends Error {
    constructor(t) {
      super(), this.name = "SquareRootError", this.message = "X is not a square mod P.", this.result = t.fromRed(), Error.captureStackTrace && Error.captureStackTrace(this, ue);
    }
  }
  function ae(se) {
    return Number.isSafeInteger(se);
  }
  function D(se) {
    return ae(se) && se >= -67108863 && se <= 67108863;
  }
  function Q(se, t) {
    return se.allocUnsafeSlow ? se.allocUnsafeSlow(t) : new se(t);
  }
  function Z(se) {
    if (se == null)
      return 10;
    if (typeof se == "number")
      return se;
    switch (se) {
      case "bin":
        return 2;
      case "oct":
        return 8;
      case "dec":
        return 10;
      case "hex":
        return 16;
    }
    return 0;
  }
  function oe(se) {
    if (Math.clz32)
      return 32 - Math.clz32(se);
    let t = se, l = 0;
    return t >= 4096 && (l += 13, t >>>= 13), t >= 64 && (l += 7, t >>>= 7), t >= 8 && (l += 4, t >>>= 4), t >= 2 && (l += 2, t >>>= 2), l + t;
  }
  function y(se) {
    if (se === 0)
      return 26;
    let t = se, l = 0;
    return (t & 8191) === 0 && (l += 13, t >>>= 13), (t & 127) === 0 && (l += 7, t >>>= 7), (t & 15) === 0 && (l += 4, t >>>= 4), (t & 3) === 0 && (l += 2, t >>>= 2), (t & 1) === 0 && (l += 1), l;
  }
  function Y(se, t, l) {
    const B = Math.min(se.length, l);
    let U = 0, G = 0;
    for (let T = t; T < B; T++) {
      const M = se.charCodeAt(T) - 48;
      U <<= 4;
      let $;
      M >= 49 && M <= 54 ? $ = M - 49 + 10 : M >= 17 && M <= 22 ? $ = M - 17 + 10 : $ = M, U |= $, G |= $;
    }
    if (G & -16)
      throw new Error("Invalid string.");
    return U;
  }
  function he(se, t, l, B) {
    const U = Math.min(se.length, l);
    let G = 0;
    for (let T = t; T < U; T++) {
      const M = se.charCodeAt(T) - 48;
      G *= B;
      let $;
      if (M >= 49 ? $ = M - 49 + 10 : M >= 17 ? $ = M - 17 + 10 : $ = M, M < 0 || M > 207 || $ >= B)
        throw new Error("Invalid string.");
      G += $;
    }
    return G;
  }
  function be(se, t, l) {
    const B = BigInt(1), U = new Array(u), G = se * se % l;
    U[0] = se;
    for (let $ = 1; $ < u; $++)
      U[$] = U[$ - 1] * G % l;
    let T = t.bitLength(), M = B;
    for (; T >= n; ) {
      let $ = n, r = t.bits(T - $, $);
      if (r < u) {
        M = M * M % l, T -= 1;
        continue;
      }
      for (; (r & 1) === 0; )
        $ -= 1, r >>= 1;
      M === B ? M = U[r >> 1] : (M = xe(M, $, l), M = M * U[r >> 1] % l), T -= $;
    }
    if (T > 0) {
      const $ = t.bits(0, T);
      for (; T--; )
        M = M * M % l, $ >> T & 1 && (M = M * se % l);
    }
    return M;
  }
  function xe(se, t, l) {
    for (let B = 0; B < t; B++)
      se = se * se % l;
    return se;
  }
  function Ie(se, t, l) {
    const B = se.length + t.length;
    l.negative = se.negative ^ t.negative, l._alloc(B), l.length = B;
    const U = se.words[0], G = t.words[0], T = U * G, M = T & 67108863;
    let $ = T / 67108864 | 0, r = 1;
    for (l.words[0] = M; r < l.length - 1; r++) {
      let x = $ >>> 26, O = $ & 67108863;
      const L = Math.max(0, r - se.length + 1), X = Math.min(r, t.length - 1);
      for (let P = L; P <= X; P++) {
        const K = r - P, re = se.words[K], ce = t.words[P], le = re * ce + O;
        x += le / 67108864 | 0, O = le & 67108863;
      }
      l.words[r] = O | 0, $ = x | 0;
    }
    return $ !== 0 ? l.words[r] = $ | 0 : l.length -= 1, l._strip();
  }
  function ve(se, t, l) {
    const B = se.length + t.length;
    l.negative = se.negative ^ t.negative, l._alloc(B), l.length = B;
    let U = 0, G = 0, T = 0;
    for (; T < l.length - 1; T++) {
      let M = G;
      G = 0;
      let $ = U & 67108863;
      const r = Math.max(0, T - se.length + 1), x = Math.min(T, t.length - 1);
      for (let O = r; O <= x; O++) {
        const L = T - O, X = se.words[L], P = t.words[O], K = X * P;
        let re = K & 67108863;
        M = M + (K / 67108864 | 0) | 0, re = re + $ | 0, $ = re & 67108863, M = M + (re >>> 26) | 0, G += M >>> 26, M &= 67108863;
      }
      l.words[T] = $, U = M, M = G;
    }
    return U !== 0 ? l.words[T] = U : l.length -= 1, l._strip();
  }
  function C(se, t, l) {
    if (!a || se.length + t.length > 82595519)
      return ve(se, t, l);
    const B = BigInt(0), U = BigInt(67108863), G = BigInt(26);
    let T = se.toBigInt() * t.toBigInt();
    const M = T < B | 0;
    M && (T = -T);
    let $ = 0;
    for (; T > B; )
      l.words[$++] = Number(T & U), T >>= G;
    return $ === 0 && (l.words[$++] = 0), l.length = $, l.negative = M, l;
  }
  function I(se, t, l) {
    const B = se.words, U = t.words, G = l.words, T = B[0] | 0, M = T & 8191, $ = T >>> 13, r = B[1] | 0, x = r & 8191, O = r >>> 13, L = B[2] | 0, X = L & 8191, P = L >>> 13, K = B[3] | 0, re = K & 8191, ce = K >>> 13, le = B[4] | 0, me = le & 8191, ne = le >>> 13, W = B[5] | 0, te = W & 8191, pe = W >>> 13, Ee = B[6] | 0, Ae = Ee & 8191, Oe = Ee >>> 13, Be = B[7] | 0, ke = Be & 8191, Ne = Be >>> 13, Ke = B[8] | 0, Ce = Ke & 8191, Ye = Ke >>> 13, vt = B[9] | 0, Ve = vt & 8191, Xe = vt >>> 13, qt = U[0] | 0, Ge = qt & 8191, Je = qt >>> 13, Rt = U[1] | 0, We = Rt & 8191, Ze = Rt >>> 13, Ft = U[2] | 0, Qe = Ft & 8191, st = Ft >>> 13, Kr = U[3] | 0, ct = Kr & 8191, ut = Kr >>> 13, Vr = U[4] | 0, rt = Vr & 8191, ht = Vr >>> 13, $r = U[5] | 0, lt = $r & 8191, dt = $r >>> 13, jr = U[6] | 0, bt = jr & 8191, pt = jr >>> 13, Yr = U[7] | 0, ot = Yr & 8191, mt = Yr >>> 13, kr = U[8] | 0, et = kr & 8191, at = kr >>> 13, ir = U[9] | 0, it = ir & 8191, tt = ir >>> 13;
    let Le = 0, ye, ee, we;
    l.negative = se.negative ^ t.negative, l._alloc(20), l.length = 19, ye = Math.imul(M, Ge), ee = Math.imul(M, Je), ee = ee + Math.imul($, Ge) | 0, we = Math.imul($, Je);
    let Ct = (Le + ye | 0) + ((ee & 8191) << 13) | 0;
    Le = (we + (ee >>> 13) | 0) + (Ct >>> 26) | 0, Ct &= 67108863, ye = Math.imul(x, Ge), ee = Math.imul(x, Je), ee = ee + Math.imul(O, Ge) | 0, we = Math.imul(O, Je), ye = ye + Math.imul(M, We) | 0, ee = ee + Math.imul(M, Ze) | 0, ee = ee + Math.imul($, We) | 0, we = we + Math.imul($, Ze) | 0;
    let ge = (Le + ye | 0) + ((ee & 8191) << 13) | 0;
    Le = (we + (ee >>> 13) | 0) + (ge >>> 26) | 0, ge &= 67108863, ye = Math.imul(X, Ge), ee = Math.imul(X, Je), ee = ee + Math.imul(P, Ge) | 0, we = Math.imul(P, Je), ye = ye + Math.imul(x, We) | 0, ee = ee + Math.imul(x, Ze) | 0, ee = ee + Math.imul(O, We) | 0, we = we + Math.imul(O, Ze) | 0, ye = ye + Math.imul(M, Qe) | 0, ee = ee + Math.imul(M, st) | 0, ee = ee + Math.imul($, Qe) | 0, we = we + Math.imul($, st) | 0;
    let ie = (Le + ye | 0) + ((ee & 8191) << 13) | 0;
    Le = (we + (ee >>> 13) | 0) + (ie >>> 26) | 0, ie &= 67108863, ye = Math.imul(re, Ge), ee = Math.imul(re, Je), ee = ee + Math.imul(ce, Ge) | 0, we = Math.imul(ce, Je), ye = ye + Math.imul(X, We) | 0, ee = ee + Math.imul(X, Ze) | 0, ee = ee + Math.imul(P, We) | 0, we = we + Math.imul(P, Ze) | 0, ye = ye + Math.imul(x, Qe) | 0, ee = ee + Math.imul(x, st) | 0, ee = ee + Math.imul(O, Qe) | 0, we = we + Math.imul(O, st) | 0, ye = ye + Math.imul(M, ct) | 0, ee = ee + Math.imul(M, ut) | 0, ee = ee + Math.imul($, ct) | 0, we = we + Math.imul($, ut) | 0;
    let de = (Le + ye | 0) + ((ee & 8191) << 13) | 0;
    Le = (we + (ee >>> 13) | 0) + (de >>> 26) | 0, de &= 67108863, ye = Math.imul(me, Ge), ee = Math.imul(me, Je), ee = ee + Math.imul(ne, Ge) | 0, we = Math.imul(ne, Je), ye = ye + Math.imul(re, We) | 0, ee = ee + Math.imul(re, Ze) | 0, ee = ee + Math.imul(ce, We) | 0, we = we + Math.imul(ce, Ze) | 0, ye = ye + Math.imul(X, Qe) | 0, ee = ee + Math.imul(X, st) | 0, ee = ee + Math.imul(P, Qe) | 0, we = we + Math.imul(P, st) | 0, ye = ye + Math.imul(x, ct) | 0, ee = ee + Math.imul(x, ut) | 0, ee = ee + Math.imul(O, ct) | 0, we = we + Math.imul(O, ut) | 0, ye = ye + Math.imul(M, rt) | 0, ee = ee + Math.imul(M, ht) | 0, ee = ee + Math.imul($, rt) | 0, we = we + Math.imul($, ht) | 0;
    let Se = (Le + ye | 0) + ((ee & 8191) << 13) | 0;
    Le = (we + (ee >>> 13) | 0) + (Se >>> 26) | 0, Se &= 67108863, ye = Math.imul(te, Ge), ee = Math.imul(te, Je), ee = ee + Math.imul(pe, Ge) | 0, we = Math.imul(pe, Je), ye = ye + Math.imul(me, We) | 0, ee = ee + Math.imul(me, Ze) | 0, ee = ee + Math.imul(ne, We) | 0, we = we + Math.imul(ne, Ze) | 0, ye = ye + Math.imul(re, Qe) | 0, ee = ee + Math.imul(re, st) | 0, ee = ee + Math.imul(ce, Qe) | 0, we = we + Math.imul(ce, st) | 0, ye = ye + Math.imul(X, ct) | 0, ee = ee + Math.imul(X, ut) | 0, ee = ee + Math.imul(P, ct) | 0, we = we + Math.imul(P, ut) | 0, ye = ye + Math.imul(x, rt) | 0, ee = ee + Math.imul(x, ht) | 0, ee = ee + Math.imul(O, rt) | 0, we = we + Math.imul(O, ht) | 0, ye = ye + Math.imul(M, lt) | 0, ee = ee + Math.imul(M, dt) | 0, ee = ee + Math.imul($, lt) | 0, we = we + Math.imul($, dt) | 0;
    let _e = (Le + ye | 0) + ((ee & 8191) << 13) | 0;
    Le = (we + (ee >>> 13) | 0) + (_e >>> 26) | 0, _e &= 67108863, ye = Math.imul(Ae, Ge), ee = Math.imul(Ae, Je), ee = ee + Math.imul(Oe, Ge) | 0, we = Math.imul(Oe, Je), ye = ye + Math.imul(te, We) | 0, ee = ee + Math.imul(te, Ze) | 0, ee = ee + Math.imul(pe, We) | 0, we = we + Math.imul(pe, Ze) | 0, ye = ye + Math.imul(me, Qe) | 0, ee = ee + Math.imul(me, st) | 0, ee = ee + Math.imul(ne, Qe) | 0, we = we + Math.imul(ne, st) | 0, ye = ye + Math.imul(re, ct) | 0, ee = ee + Math.imul(re, ut) | 0, ee = ee + Math.imul(ce, ct) | 0, we = we + Math.imul(ce, ut) | 0, ye = ye + Math.imul(X, rt) | 0, ee = ee + Math.imul(X, ht) | 0, ee = ee + Math.imul(P, rt) | 0, we = we + Math.imul(P, ht) | 0, ye = ye + Math.imul(x, lt) | 0, ee = ee + Math.imul(x, dt) | 0, ee = ee + Math.imul(O, lt) | 0, we = we + Math.imul(O, dt) | 0, ye = ye + Math.imul(M, bt) | 0, ee = ee + Math.imul(M, pt) | 0, ee = ee + Math.imul($, bt) | 0, we = we + Math.imul($, pt) | 0;
    let Pe = (Le + ye | 0) + ((ee & 8191) << 13) | 0;
    Le = (we + (ee >>> 13) | 0) + (Pe >>> 26) | 0, Pe &= 67108863, ye = Math.imul(ke, Ge), ee = Math.imul(ke, Je), ee = ee + Math.imul(Ne, Ge) | 0, we = Math.imul(Ne, Je), ye = ye + Math.imul(Ae, We) | 0, ee = ee + Math.imul(Ae, Ze) | 0, ee = ee + Math.imul(Oe, We) | 0, we = we + Math.imul(Oe, Ze) | 0, ye = ye + Math.imul(te, Qe) | 0, ee = ee + Math.imul(te, st) | 0, ee = ee + Math.imul(pe, Qe) | 0, we = we + Math.imul(pe, st) | 0, ye = ye + Math.imul(me, ct) | 0, ee = ee + Math.imul(me, ut) | 0, ee = ee + Math.imul(ne, ct) | 0, we = we + Math.imul(ne, ut) | 0, ye = ye + Math.imul(re, rt) | 0, ee = ee + Math.imul(re, ht) | 0, ee = ee + Math.imul(ce, rt) | 0, we = we + Math.imul(ce, ht) | 0, ye = ye + Math.imul(X, lt) | 0, ee = ee + Math.imul(X, dt) | 0, ee = ee + Math.imul(P, lt) | 0, we = we + Math.imul(P, dt) | 0, ye = ye + Math.imul(x, bt) | 0, ee = ee + Math.imul(x, pt) | 0, ee = ee + Math.imul(O, bt) | 0, we = we + Math.imul(O, pt) | 0, ye = ye + Math.imul(M, ot) | 0, ee = ee + Math.imul(M, mt) | 0, ee = ee + Math.imul($, ot) | 0, we = we + Math.imul($, mt) | 0;
    let Re = (Le + ye | 0) + ((ee & 8191) << 13) | 0;
    Le = (we + (ee >>> 13) | 0) + (Re >>> 26) | 0, Re &= 67108863, ye = Math.imul(Ce, Ge), ee = Math.imul(Ce, Je), ee = ee + Math.imul(Ye, Ge) | 0, we = Math.imul(Ye, Je), ye = ye + Math.imul(ke, We) | 0, ee = ee + Math.imul(ke, Ze) | 0, ee = ee + Math.imul(Ne, We) | 0, we = we + Math.imul(Ne, Ze) | 0, ye = ye + Math.imul(Ae, Qe) | 0, ee = ee + Math.imul(Ae, st) | 0, ee = ee + Math.imul(Oe, Qe) | 0, we = we + Math.imul(Oe, st) | 0, ye = ye + Math.imul(te, ct) | 0, ee = ee + Math.imul(te, ut) | 0, ee = ee + Math.imul(pe, ct) | 0, we = we + Math.imul(pe, ut) | 0, ye = ye + Math.imul(me, rt) | 0, ee = ee + Math.imul(me, ht) | 0, ee = ee + Math.imul(ne, rt) | 0, we = we + Math.imul(ne, ht) | 0, ye = ye + Math.imul(re, lt) | 0, ee = ee + Math.imul(re, dt) | 0, ee = ee + Math.imul(ce, lt) | 0, we = we + Math.imul(ce, dt) | 0, ye = ye + Math.imul(X, bt) | 0, ee = ee + Math.imul(X, pt) | 0, ee = ee + Math.imul(P, bt) | 0, we = we + Math.imul(P, pt) | 0, ye = ye + Math.imul(x, ot) | 0, ee = ee + Math.imul(x, mt) | 0, ee = ee + Math.imul(O, ot) | 0, we = we + Math.imul(O, mt) | 0, ye = ye + Math.imul(M, et) | 0, ee = ee + Math.imul(M, at) | 0, ee = ee + Math.imul($, et) | 0, we = we + Math.imul($, at) | 0;
    let Me = (Le + ye | 0) + ((ee & 8191) << 13) | 0;
    Le = (we + (ee >>> 13) | 0) + (Me >>> 26) | 0, Me &= 67108863, ye = Math.imul(Ve, Ge), ee = Math.imul(Ve, Je), ee = ee + Math.imul(Xe, Ge) | 0, we = Math.imul(Xe, Je), ye = ye + Math.imul(Ce, We) | 0, ee = ee + Math.imul(Ce, Ze) | 0, ee = ee + Math.imul(Ye, We) | 0, we = we + Math.imul(Ye, Ze) | 0, ye = ye + Math.imul(ke, Qe) | 0, ee = ee + Math.imul(ke, st) | 0, ee = ee + Math.imul(Ne, Qe) | 0, we = we + Math.imul(Ne, st) | 0, ye = ye + Math.imul(Ae, ct) | 0, ee = ee + Math.imul(Ae, ut) | 0, ee = ee + Math.imul(Oe, ct) | 0, we = we + Math.imul(Oe, ut) | 0, ye = ye + Math.imul(te, rt) | 0, ee = ee + Math.imul(te, ht) | 0, ee = ee + Math.imul(pe, rt) | 0, we = we + Math.imul(pe, ht) | 0, ye = ye + Math.imul(me, lt) | 0, ee = ee + Math.imul(me, dt) | 0, ee = ee + Math.imul(ne, lt) | 0, we = we + Math.imul(ne, dt) | 0, ye = ye + Math.imul(re, bt) | 0, ee = ee + Math.imul(re, pt) | 0, ee = ee + Math.imul(ce, bt) | 0, we = we + Math.imul(ce, pt) | 0, ye = ye + Math.imul(X, ot) | 0, ee = ee + Math.imul(X, mt) | 0, ee = ee + Math.imul(P, ot) | 0, we = we + Math.imul(P, mt) | 0, ye = ye + Math.imul(x, et) | 0, ee = ee + Math.imul(x, at) | 0, ee = ee + Math.imul(O, et) | 0, we = we + Math.imul(O, at) | 0, ye = ye + Math.imul(M, it) | 0, ee = ee + Math.imul(M, tt) | 0, ee = ee + Math.imul($, it) | 0, we = we + Math.imul($, tt) | 0;
    let qe = (Le + ye | 0) + ((ee & 8191) << 13) | 0;
    Le = (we + (ee >>> 13) | 0) + (qe >>> 26) | 0, qe &= 67108863, ye = Math.imul(Ve, We), ee = Math.imul(Ve, Ze), ee = ee + Math.imul(Xe, We) | 0, we = Math.imul(Xe, Ze), ye = ye + Math.imul(Ce, Qe) | 0, ee = ee + Math.imul(Ce, st) | 0, ee = ee + Math.imul(Ye, Qe) | 0, we = we + Math.imul(Ye, st) | 0, ye = ye + Math.imul(ke, ct) | 0, ee = ee + Math.imul(ke, ut) | 0, ee = ee + Math.imul(Ne, ct) | 0, we = we + Math.imul(Ne, ut) | 0, ye = ye + Math.imul(Ae, rt) | 0, ee = ee + Math.imul(Ae, ht) | 0, ee = ee + Math.imul(Oe, rt) | 0, we = we + Math.imul(Oe, ht) | 0, ye = ye + Math.imul(te, lt) | 0, ee = ee + Math.imul(te, dt) | 0, ee = ee + Math.imul(pe, lt) | 0, we = we + Math.imul(pe, dt) | 0, ye = ye + Math.imul(me, bt) | 0, ee = ee + Math.imul(me, pt) | 0, ee = ee + Math.imul(ne, bt) | 0, we = we + Math.imul(ne, pt) | 0, ye = ye + Math.imul(re, ot) | 0, ee = ee + Math.imul(re, mt) | 0, ee = ee + Math.imul(ce, ot) | 0, we = we + Math.imul(ce, mt) | 0, ye = ye + Math.imul(X, et) | 0, ee = ee + Math.imul(X, at) | 0, ee = ee + Math.imul(P, et) | 0, we = we + Math.imul(P, at) | 0, ye = ye + Math.imul(x, it) | 0, ee = ee + Math.imul(x, tt) | 0, ee = ee + Math.imul(O, it) | 0, we = we + Math.imul(O, tt) | 0;
    let De = (Le + ye | 0) + ((ee & 8191) << 13) | 0;
    Le = (we + (ee >>> 13) | 0) + (De >>> 26) | 0, De &= 67108863, ye = Math.imul(Ve, Qe), ee = Math.imul(Ve, st), ee = ee + Math.imul(Xe, Qe) | 0, we = Math.imul(Xe, st), ye = ye + Math.imul(Ce, ct) | 0, ee = ee + Math.imul(Ce, ut) | 0, ee = ee + Math.imul(Ye, ct) | 0, we = we + Math.imul(Ye, ut) | 0, ye = ye + Math.imul(ke, rt) | 0, ee = ee + Math.imul(ke, ht) | 0, ee = ee + Math.imul(Ne, rt) | 0, we = we + Math.imul(Ne, ht) | 0, ye = ye + Math.imul(Ae, lt) | 0, ee = ee + Math.imul(Ae, dt) | 0, ee = ee + Math.imul(Oe, lt) | 0, we = we + Math.imul(Oe, dt) | 0, ye = ye + Math.imul(te, bt) | 0, ee = ee + Math.imul(te, pt) | 0, ee = ee + Math.imul(pe, bt) | 0, we = we + Math.imul(pe, pt) | 0, ye = ye + Math.imul(me, ot) | 0, ee = ee + Math.imul(me, mt) | 0, ee = ee + Math.imul(ne, ot) | 0, we = we + Math.imul(ne, mt) | 0, ye = ye + Math.imul(re, et) | 0, ee = ee + Math.imul(re, at) | 0, ee = ee + Math.imul(ce, et) | 0, we = we + Math.imul(ce, at) | 0, ye = ye + Math.imul(X, it) | 0, ee = ee + Math.imul(X, tt) | 0, ee = ee + Math.imul(P, it) | 0, we = we + Math.imul(P, tt) | 0;
    let Ue = (Le + ye | 0) + ((ee & 8191) << 13) | 0;
    Le = (we + (ee >>> 13) | 0) + (Ue >>> 26) | 0, Ue &= 67108863, ye = Math.imul(Ve, ct), ee = Math.imul(Ve, ut), ee = ee + Math.imul(Xe, ct) | 0, we = Math.imul(Xe, ut), ye = ye + Math.imul(Ce, rt) | 0, ee = ee + Math.imul(Ce, ht) | 0, ee = ee + Math.imul(Ye, rt) | 0, we = we + Math.imul(Ye, ht) | 0, ye = ye + Math.imul(ke, lt) | 0, ee = ee + Math.imul(ke, dt) | 0, ee = ee + Math.imul(Ne, lt) | 0, we = we + Math.imul(Ne, dt) | 0, ye = ye + Math.imul(Ae, bt) | 0, ee = ee + Math.imul(Ae, pt) | 0, ee = ee + Math.imul(Oe, bt) | 0, we = we + Math.imul(Oe, pt) | 0, ye = ye + Math.imul(te, ot) | 0, ee = ee + Math.imul(te, mt) | 0, ee = ee + Math.imul(pe, ot) | 0, we = we + Math.imul(pe, mt) | 0, ye = ye + Math.imul(me, et) | 0, ee = ee + Math.imul(me, at) | 0, ee = ee + Math.imul(ne, et) | 0, we = we + Math.imul(ne, at) | 0, ye = ye + Math.imul(re, it) | 0, ee = ee + Math.imul(re, tt) | 0, ee = ee + Math.imul(ce, it) | 0, we = we + Math.imul(ce, tt) | 0;
    let He = (Le + ye | 0) + ((ee & 8191) << 13) | 0;
    Le = (we + (ee >>> 13) | 0) + (He >>> 26) | 0, He &= 67108863, ye = Math.imul(Ve, rt), ee = Math.imul(Ve, ht), ee = ee + Math.imul(Xe, rt) | 0, we = Math.imul(Xe, ht), ye = ye + Math.imul(Ce, lt) | 0, ee = ee + Math.imul(Ce, dt) | 0, ee = ee + Math.imul(Ye, lt) | 0, we = we + Math.imul(Ye, dt) | 0, ye = ye + Math.imul(ke, bt) | 0, ee = ee + Math.imul(ke, pt) | 0, ee = ee + Math.imul(Ne, bt) | 0, we = we + Math.imul(Ne, pt) | 0, ye = ye + Math.imul(Ae, ot) | 0, ee = ee + Math.imul(Ae, mt) | 0, ee = ee + Math.imul(Oe, ot) | 0, we = we + Math.imul(Oe, mt) | 0, ye = ye + Math.imul(te, et) | 0, ee = ee + Math.imul(te, at) | 0, ee = ee + Math.imul(pe, et) | 0, we = we + Math.imul(pe, at) | 0, ye = ye + Math.imul(me, it) | 0, ee = ee + Math.imul(me, tt) | 0, ee = ee + Math.imul(ne, it) | 0, we = we + Math.imul(ne, tt) | 0;
    let je = (Le + ye | 0) + ((ee & 8191) << 13) | 0;
    Le = (we + (ee >>> 13) | 0) + (je >>> 26) | 0, je &= 67108863, ye = Math.imul(Ve, lt), ee = Math.imul(Ve, dt), ee = ee + Math.imul(Xe, lt) | 0, we = Math.imul(Xe, dt), ye = ye + Math.imul(Ce, bt) | 0, ee = ee + Math.imul(Ce, pt) | 0, ee = ee + Math.imul(Ye, bt) | 0, we = we + Math.imul(Ye, pt) | 0, ye = ye + Math.imul(ke, ot) | 0, ee = ee + Math.imul(ke, mt) | 0, ee = ee + Math.imul(Ne, ot) | 0, we = we + Math.imul(Ne, mt) | 0, ye = ye + Math.imul(Ae, et) | 0, ee = ee + Math.imul(Ae, at) | 0, ee = ee + Math.imul(Oe, et) | 0, we = we + Math.imul(Oe, at) | 0, ye = ye + Math.imul(te, it) | 0, ee = ee + Math.imul(te, tt) | 0, ee = ee + Math.imul(pe, it) | 0, we = we + Math.imul(pe, tt) | 0;
    let ft = (Le + ye | 0) + ((ee & 8191) << 13) | 0;
    Le = (we + (ee >>> 13) | 0) + (ft >>> 26) | 0, ft &= 67108863, ye = Math.imul(Ve, bt), ee = Math.imul(Ve, pt), ee = ee + Math.imul(Xe, bt) | 0, we = Math.imul(Xe, pt), ye = ye + Math.imul(Ce, ot) | 0, ee = ee + Math.imul(Ce, mt) | 0, ee = ee + Math.imul(Ye, ot) | 0, we = we + Math.imul(Ye, mt) | 0, ye = ye + Math.imul(ke, et) | 0, ee = ee + Math.imul(ke, at) | 0, ee = ee + Math.imul(Ne, et) | 0, we = we + Math.imul(Ne, at) | 0, ye = ye + Math.imul(Ae, it) | 0, ee = ee + Math.imul(Ae, tt) | 0, ee = ee + Math.imul(Oe, it) | 0, we = we + Math.imul(Oe, tt) | 0;
    let St = (Le + ye | 0) + ((ee & 8191) << 13) | 0;
    Le = (we + (ee >>> 13) | 0) + (St >>> 26) | 0, St &= 67108863, ye = Math.imul(Ve, ot), ee = Math.imul(Ve, mt), ee = ee + Math.imul(Xe, ot) | 0, we = Math.imul(Xe, mt), ye = ye + Math.imul(Ce, et) | 0, ee = ee + Math.imul(Ce, at) | 0, ee = ee + Math.imul(Ye, et) | 0, we = we + Math.imul(Ye, at) | 0, ye = ye + Math.imul(ke, it) | 0, ee = ee + Math.imul(ke, tt) | 0, ee = ee + Math.imul(Ne, it) | 0, we = we + Math.imul(Ne, tt) | 0;
    let Et = (Le + ye | 0) + ((ee & 8191) << 13) | 0;
    Le = (we + (ee >>> 13) | 0) + (Et >>> 26) | 0, Et &= 67108863, ye = Math.imul(Ve, et), ee = Math.imul(Ve, at), ee = ee + Math.imul(Xe, et) | 0, we = Math.imul(Xe, at), ye = ye + Math.imul(Ce, it) | 0, ee = ee + Math.imul(Ce, tt) | 0, ee = ee + Math.imul(Ye, it) | 0, we = we + Math.imul(Ye, tt) | 0;
    let Pt = (Le + ye | 0) + ((ee & 8191) << 13) | 0;
    Le = (we + (ee >>> 13) | 0) + (Pt >>> 26) | 0, Pt &= 67108863, ye = Math.imul(Ve, it), ee = Math.imul(Ve, tt), ee = ee + Math.imul(Xe, it) | 0, we = Math.imul(Xe, tt);
    let Ot = (Le + ye | 0) + ((ee & 8191) << 13) | 0;
    return Le = (we + (ee >>> 13) | 0) + (Ot >>> 26) | 0, Ot &= 67108863, G[0] = Ct, G[1] = ge, G[2] = ie, G[3] = de, G[4] = Se, G[5] = _e, G[6] = Pe, G[7] = Re, G[8] = Me, G[9] = qe, G[10] = De, G[11] = Ue, G[12] = He, G[13] = je, G[14] = ft, G[15] = St, G[16] = Et, G[17] = Pt, G[18] = Ot, Le !== 0 && (G[19] = Le, l.length += 1), l;
  }
  return Math.imul || (I = Ie), s.Red = J, sc = s, sc;
}
var i5;
function dl() {
  return i5 || (i5 = 1, function(e) {
    const c = Hr(), d = e;
    function w(a) {
      return k.from(a, "hex");
    }
    d.types = ["main", "testnet", "regtest", "simnet"];
    const g = {};
    g.type = "main", g.seeds = [
      "seed.flowee.cash",
      "seed-bch.bitcoinforks.org",
      "btccash-seeder.bitcoinunlimited.info",
      "seed.bchd.cash",
      "seed.bch.loping.net",
      "dnsseed.electroncash.de"
    ], g.magic = 3908297187, g.port = 8333, g.checkpointMap = {
      11111: w("1d7c6eb2fd42f55925e92efad68b61edd22fba29fde8783df744e26900000000"),
      33333: w("a6d0b5df7d0df069ceb1e736a216ad187a50b07aaa4e78748a58d52d00000000"),
      74e3: w("201a66b853f9e7814a820e2af5f5dc79c07144e31ce4c9a39339570000000000"),
      105e3: w("97dc6b1d15fbeef373a744fee0b254b0d2c820a3ae7f0228ce91020000000000"),
      134444: w("feb0d2420d4a18914c81ac30f494a5d4ff34cd15d34cfd2fb105000000000000"),
      168e3: w("63b703835cb735cb9a89d733cbe66f212f63795e0172ea619e09000000000000"),
      193e3: w("17138bca83bdc3e6f60f01177c3877a98266de40735f2a459f05000000000000"),
      21e4: w("2e3471a19b8e22b7f939c63663076603cf692f19837e34958b04000000000000"),
      216116: w("4edf231bf170234e6a811460f95c94af9464e41ee833b4f4b401000000000000"),
      225430: w("32595730b165f097e7b806a679cf7f3e439040f750433808c101000000000000"),
      25e4: w("14d2f24d29bed75354f3f88a5fb50022fc064b02291fdf873800000000000000"),
      279e3: w("407ebde958e44190fa9e810ea1fc3a7ef601c3b0a0728cae0100000000000000"),
      295e3: w("83a93246c67003105af33ae0b29dd66f689d0f0ff54e9b4d0000000000000000"),
      300255: w("b2f3a0f0de4120c1089d5f5280a263059f9b6e7c520428160000000000000000"),
      319400: w("3bf115fd057391587ca39a531c5d4989e1adec9b2e05c6210000000000000000"),
      343185: w("548536d48e7678fcfa034202dd45d4a76b1ad061f38b2b070000000000000000"),
      352940: w("ffc9520143e41c94b6e03c2fa3e62bb76b55ba2df45d75100000000000000000"),
      382320: w("b28afdde92b0899715e40362f56afdb20e3d135bedc68d0a0000000000000000"),
      401465: w("eed16cb3e893ed9366f27c39a9ecd95465d02e3ef40e45010000000000000000"),
      42e4: w("a1ff746b2d42b834cb7d6b8981b09c265c2cabc016e8cc020000000000000000"),
      44e4: w("9bf296b8de5f834f7635d5e258a434ad51b4dbbcf7c08c030000000000000000"),
      45e4: w("0ba2070c62cd9da1f8cef88a0648c661a411d33e728340010000000000000000"),
      46e4: w("8c25fc7e414d3e868d6ce0ec473c30ad44e7e8bc1b75ef000000000000000000"),
      47e4: w("89756d1ed75901437300af10d5ab69070a282e729c536c000000000000000000"),
      // UAHF fork block:
      478559: w("ec5e1a193601f25ff1d94b421ddead0dbefcb99cf91e65000000000000000000"),
      48e4: w("f93408ffca92d88a6e46d3b90046f97bde6be0c08e7ed40c0000000000000000"),
      49e4: w("d1c65d766c6dc270b8ff4f1edb052fb71dc2b4750ede8a010000000000000000"),
      5e5: w("01b2328355f4a4dc9efa5c610687304507b7df9f3f4de1050000000000000000"),
      // DAA fork block
      504031: w("9cabb6ee1b1a4c3b659d70be75810be83d0a0db665bf1e010000000000000000"),
      51e4: w("040e6b1f2f4cb198a5780d366bf81e591de257642b9267030000000000000000"),
      525e3: w("c994fba2bf168333fd969bcfa64f03ca1b62074f9a8f1b010000000000000000"),
      // Monolith Activation
      530359: w("0391c40195cf8ae3436f3955f1a8444f07468fd08bda1a010000000000000000"),
      // Magnetic Anomaly Activation:
      556767: w("6cd5e644acccee5743ce2e93c541d34169933b6eff2646000000000000000000"),
      // Great Wall Activation:
      582680: w("18cc7d8c39ca16dc749acb7278a471964f7dec6ae3b8b4010000000000000000"),
      // Graviton Activation:
      609136: w("b1c55b4f69aa2e3209c91ae413c355c65aacfa07b28bb4000000000000000000"),
      // Phonon Activation:
      635259: w("f73075b2c598f49b3a19558c070b52d5a5d6c21fefdf33000000000000000000"),
      // Axion Activation:
      661648: w("7d7510f907bdc9bd2907e56beceaef31f78f2c8b9d4c28040000000000000000"),
      664198: w("60824622a1d2b689fbb234ce2c5939ff92e8ed8c57902f0c0000000000000000"),
      680140: w("0b7c2ff6c3658cb3f846aa092145c44a1d45638b56482c230000000000000000"),
      // Tachyon Activation
      686621: w("45b7e5be980bd6e98a22f895fcdc80546d9f0a57f7e68f3c0000000000000000"),
      // Selectron Activation
      713661: w("8defaaea383ab73c75ceea3f08190f3ab5ccc70743f876060000000000000000"),
      // Gluon activation
      739536: w("617bfc596bce59b129242fe67b5afe0509560946cd04db060000000000000000"),
      // Jefferson activation
      766195: w("94e0246db72955957dedb431eb1096de9a5b715348c92b100000000000000000")
    }, g.lastCheckpoint = 525e3, g.halvingInterval = 21e4, g.genesis = {
      version: 1,
      hash: w("6fe28c0ab6f1b372c1a6a246ae63f74f931e8365e15a089c68d6190000000000"),
      prevBlock: w("0000000000000000000000000000000000000000000000000000000000000000"),
      merkleRoot: w("3ba3edfd7a7b12b27ac72c3e67768f617fc81bc3888a51323a9fb8aa4b1e5e4a"),
      time: 1231006505,
      bits: 486604799,
      nonce: 2083236893,
      height: 0
    }, g.genesisBlock = "0100000000000000000000000000000000000000000000000000000000000000000000003ba3edfd7a7b12b27ac72c3e67768f617fc81bc3888a51323a9fb8aa4b1e5e4a29ab5f49ffff001d1dac2b7c0101000000010000000000000000000000000000000000000000000000000000000000000000ffffffff4d04ffff001d0104455468652054696d65732030332f4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66207365636f6e64206261696c6f757420666f722062616e6b73ffffffff0100f2052a01000000434104678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5fac00000000", g.pow = {
      /**
       * Default target.
       * @const {BN}
       */
      limit: new c(
        "00000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
        "hex"
      ),
      /**
       * Compact pow limit.
       * @const {Number}
       * @default
       */
      bits: 486604799,
      /**
       * Half Life value used in DAA.
       * Represents the value of two days in seconds
       * @const {Number}
       * @default
       */
      halfLife: 172800,
      /**
       * Minimum chainwork for best chain.
       * @const {BN}
       */
      chainwork: new c(
        "0000000000000000000000000000000000000000013c95e14d4d9db91d671020",
        "hex"
      ),
      /**
       * Desired retarget period in seconds.
       * @const {Number}
       * @default
       */
      targetTimespan: 336 * 60 * 60,
      /**
       * Average block time.
       * @const {Number}
       * @default
       */
      targetSpacing: 600,
      /**
       * Retarget interval in blocks.
       * @const {Number}
       * @default
       */
      retargetInterval: 2016,
      /**
       * Whether to reset target if a block
       * has not been mined recently.
       * @const {Boolean}
       * @default
       */
      targetReset: !1,
      /**
       * Do not allow retargetting.
       * @const {Boolean}
       * @default
       */
      noRetargeting: !1
    }, g.block = {
      /**
       * Height at which bip34 was activated.
       * Used for avoiding bip30 checks.
       */
      bip34height: 227931,
      /**
       * Hash of the block that activated bip34.
       */
      bip34hash: w("b808089c756add1591b1d17bab44bba3fed9e02f942ab4894b02000000000000"),
      /**
       * Height at which bip65 was activated.
       */
      bip65height: 388381,
      /**
       * Hash of the block that activated bip65.
       */
      bip65hash: w("f035476cfaeb9f677c2cdad00fd908c556775ded24b6c2040000000000000000"),
      /**
       * Height at which bip66 was activated.
       */
      bip66height: 363725,
      /**
       * Hash of the block that activated bip66.
       */
      bip66hash: w("3109b588941188a9f1c2576aae462d729b8cce9da1ea79030000000000000000"),
      /**
       * Height at which UAHF was activated.
       */
      uahfHeight: 478558,
      /**
       * Hash of the block that activated UAHF.
       */
      uahfHash: w("432d350741fbf28f2e1486eabe2c4e143bfe2241af6518010000000000000000"),
      /**
       * Height at which DAA was activated.
       * November 13, 2017 hard fork
       */
      daaHeight: 504031,
      /**
       * Hash of the block that activated DAA
       */
      daaHash: w("9cabb6ee1b1a4c3b659d70be75810be83d0a0db665bf1e010000000000000000"),
      /**
       * Height at which Magnetic Anomaly was activated.
       * Nov 15, 2018 hard fork
       */
      magneticAnomalyHeight: 556767,
      /**
       * Hash of the block that activatd Magnetic Anomaly.
       * November 15, 2018
       */
      maaHash: w("6cd5e644acccee5743ce2e93c541d34169933b6eff2646000000000000000000"),
      /**
       * Height at which Great Wall was activated.
       * Wed, 15 May 2019 hard fork
       */
      greatWallActivationHeight: 582680,
      /**
       * Hash of the block that activated Great Wall.
       * May 15, 2019
       */
      gwaHash: w("18cc7d8c39ca16dc749acb7278a471964f7dec6ae3b8b4010000000000000000"),
      /**
       * Graviton Hard Fork activation time.
       * Nov 15, 2019 12:00:00 UTC
       */
      gravitonActivationTime: 1573819200,
      /**
       * Height at which Graviton was activated.
       * Friday, 15 November 2019 hard fork
       */
      gravitonHeight: 609136,
      /**
       * Hash of the block that activated Graviton.
       * November 15th, 2019
       */
      gravitonHash: w("b1c55b4f69aa2e3209c91ae413c355c65aacfa07b28bb4000000000000000000"),
      /**
       * Time at which Phonon was activated.
       * May 15, 2020 12:00:00 UTC
       */
      phononActivationTime: 1589544e3,
      /**
      * Height at which Phonon Activation occured.
      * May 15, 2020
      */
      phononHeight: 635259,
      /**
      * Hash of the block that activated Phonon.
      * May 15th 2020
      */
      phononHash: w("f73075b2c598f49b3a19558c070b52d5a5d6c21fefdf33000000000000000000"),
      /**
       * Time at which Asert3d-2i was activated.
       * November 15, 2020 12:00:00 UTC
       */
      asertActivationTime: 1605441600,
      /**
       * Time at which Axion was activated.
       * November 15, 2020 12:00:00 UTC
       */
      axionActivationTime: 1605441600,
      /**
      * Height at which Axion Activation occured.
      * November 15, 2020
      */
      axionHeight: 661648,
      /**
      * Hash of the block that activated Axion.
      * November 15th 2020
      */
      axionHash: w("7d7510f907bdc9bd2907e56beceaef31f78f2c8b9d4c28040000000000000000"),
      /**
       * Time at which Tachyon was activated.
       * May 15, 2021 12:00:00 UTC
       */
      tachyonActivationTime: 162108e4,
      /**
      * Height at which Tachyon Activation occured.
      * May 15, 2021 12:00:00 UTC
      */
      tachyonHeight: 686621,
      /**
      * Hash of the block that activated Tachyon.
      * May 15, 2021 12:00:00 UTC
      */
      tachyonHash: w("45b7e5be980bd6e98a22f895fcdc80546d9f0a57f7e68f3c0000000000000000"),
      /**
       * Time at which Selectron was activated.
       * November 15, 2021 12:00:00 UTC
       */
      selectronActivationTime: 1636977600,
      /**
      * Height at which Selectron Activation occured.
      *  November 15, 2021 12:00:00 UTC
      */
      selectronHeight: 713661,
      /**
      * Hash of the block that activated Selectron.
      * November 15, 2021 12:00:00 UTC
      */
      selectronHash: w("8defaaea383ab73c75ceea3f08190f3ab5ccc70743f876060000000000000000"),
      /**
       * Time at which Gluon was activated.
       * May 15, 2022 12:00:00 UTC
       */
      gluonActivationTime: 1652572800,
      /**
      * Height at which Gluon activation occured.
      *  May 15, 2022 12:00:00 UTC
      */
      gluonHeight: 739536,
      /**
      * Hash of the block that activated Gluon.
      * May 15, 2022 12:00:00 UTC
      */
      gluonHash: w("617bfc596bce59b129242fe67b5afe0509560946cd04db060000000000000000"),
      /**
       * Time at which Jefferson was activated.
       * November 15, 2022 12:00:00 UTC
       */
      jeffersonActivationTime: 1668470400,
      /**
      * Height at which Gluon activation occured.
      *  November 15, 2022 12:00:00 UTC
      */
      jeffersonHeight: 766195,
      /**
      * Hash of the block that activated Gluon.
      * November 15, 2022 12:00:00 UTC
      */
      jeffersonHash: w("94e0246db72955957dedb431eb1096de9a5b715348c92b100000000000000000"),
      /**
       * Time at which Wellington was activated.
       * May 15, 2023 12:00:00 UTC
       */
      wellingtonActivationTime: 1684108800,
      /**
       * Safe height to start pruning.
       */
      pruneAfterHeight: 1e3,
      /**
       * Safe number of blocks to keep.
       */
      keepBlocks: 288,
      /**
       * Age used for the time delta to
       * determine whether the chain is synced.
       */
      maxTipAge: 1440 * 60,
      /**
       * Height at which block processing is
       * slow enough that we can output
       * logs without spamming.
       */
      slowHeight: 325e3
    }, g.bip30 = {
      91842: w("eccae000e3c8e4e093936360431f3b7603c563c1ff6181390a4d0a0000000000"),
      91880: w("21d77ccb4c08386a04ac0196ae10f6a1d2c2a377558ca190f143070000000000")
    }, g.activationThreshold = 1916, g.minerWindow = 2016, g.deployments = {
      csv: {
        name: "csv",
        bit: 0,
        startTime: 1462060800,
        // May 1st, 2016
        timeout: 1493596800,
        // May 1st, 2017
        threshold: -1,
        window: -1,
        required: !1,
        force: !0
      },
      testdummy: {
        name: "testdummy",
        bit: 28,
        startTime: 1199145601,
        // January 1, 2008
        timeout: 1230767999,
        // December 31, 2008
        threshold: -1,
        window: -1,
        required: !1,
        force: !0
      }
    }, g.deploys = [
      g.deployments.csv,
      g.deployments.testdummy
    ], g.keyPrefix = {
      privkey: 128,
      xpubkey: 76067358,
      xprivkey: 76066276,
      xpubkey58: "xpub",
      xprivkey58: "xprv",
      coinType: 0
    }, g.addressPrefix = {
      pubkeyhash: 0,
      scripthash: 5,
      cashaddr: "ecash"
    }, g.requireStandard = !0, g.rpcPort = 8332, g.walletPort = 8334, g.minRelay = 1e3, g.feeRate = 1e5, g.maxFeeRate = 4e5, g.selfConnect = !1, g.requestMempool = !1;
    const f = {};
    f.type = "testnet", f.seeds = [
      "testnet-seed.bitcoinabc.org",
      // Bitcoin ABC seeder
      "testnet-seed-abc.bitcoinforks.org",
      // bitcoinforks seeders
      "testnet-seed.deadalnix.me",
      // Amaury SCHET
      "testnet-seed.bchd.cash"
    ], f.magic = 4109624820, f.port = 18333, f.checkpointMap = {
      546: w("70cb6af7ebbcb1315d3414029c556c55f3e2fc353c4c9063a76c932a00000000"),
      1e4: w("02a1b43f52591e53b660069173ac83b675798e12599dbb0442b7580000000000"),
      5e4: w("0c6ceabe803cec55ba2831e445956d0a43ba9521743a802cddac7e0700000000"),
      9e4: w("cafc21e17faf90461a5905aa03302c394912651ed9475ae711723e0d00000000"),
      1e5: w("1e0a16bbadccde1d80c66597b1939e45f91b570d29f95fc158299e0000000000"),
      14e4: w("92c0877b54c556889b72175ccbe0c91a1208f6ef7efb2c006101062300000000"),
      17e4: w("508125560d202b89757889bb0e49c712477be20440058f05db4f0e0000000000"),
      21e4: w("32365454b5f29a826bff8ad9b0448cad0072fc73d50e482d91a3dece00000000"),
      23e4: w("b11a447e62643e0b27406eb0fc270cb8126d7b5b70822fb642d9513400000000"),
      27e4: w("1c42b811cf9c163932f6e95ec55bf9b5e2cb5324e7e93001572e000000000000"),
      3e5: w("a141bf3972424853f04367b47995e220e0b5a2706e5618766f22000000000000"),
      34e4: w("67edd4d92e405608109164b15f92b193377d49325b0ed036739c010000000000"),
      35e4: w("592b44bc0f7a4286cf07ead8497114c6952c1c7dea7305193deacf8e00000000"),
      39e4: w("f217e183484fb6d695609cc71fa2ae24c3020943407e0150b298030000000000"),
      42e4: w("de9e73a3b91fbb014e036e8583a17d6b638a699aeb2de8573d12580800000000"),
      46e4: w("2e8baaffc107f15c87aebe01664b63d07476afa53bcbada1281a030000000000"),
      5e5: w("06f60922a2aab2757317820fc6ffaf6a470e2cbb0f63a2aac0a7010000000000"),
      54e4: w("8dd0bebfbc4878f5af09d3e848dcc57827d2c1cebea8ec5d8cbe420500000000"),
      57e4: w("87acbd4cd3c40ec9bd648f8698ed226b31187274c06cc7a9af79030000000000"),
      6e5: w("169a05b3bb04b7d13ad628915630900a5ed2e89f3a9dc6064f62000000000000"),
      63e4: w("bbbe117035432a6a4effcb297207a02b031735b43e0d19a9217c000000000000"),
      67e4: w("080bfe75caed8624fcfdfbc65973c8f962d7bdc495a891f5d16b7d0000000000"),
      7e5: w("c14d3f6a1e7c7d66fd940951e44f3c3be1273bea4d2ab1786140000000000000"),
      74e4: w("b3b423f0462fd78a01e4f1a59a2737a0525b5dbb9bba0b4634f9000000000000"),
      78e4: w("0381582e34c3755964dc2813e2b33e521e5596367144e1670851050000000000"),
      8e5: w("03b5f8ab257e02903f509f5ff2935220eec2e77b1819651d099b200000000000"),
      84e4: w("dac1648107bd4394e57e4083c86d42b548b1cfb119665f179ea80a0000000000"),
      88e4: w("ff90b4bb07eded8e96715bf595c09c7d21dd8c61b8306ff48705d60000000000"),
      9e5: w("9bd8ac418beeb1a2cf5d68c8b5c6ebaa947a5b766e5524898d6f350000000000"),
      94e4: w("c98f1651a475b00d12f8c25eb166ee843affaa90610e36a19d68030000000000"),
      98e4: w("cc8e9774542d044a9698ca2336ae02d5987157e676f1c76aa3877c0000000000"),
      101e4: w("9d9fb11abc2712d80368229e97b8d827b2a07d27eb5335e5c924000000000000"),
      105e4: w("d8190cf0af7f08e179cab51d67db0b44b87951a78f7fdc31b4a01a0000000000"),
      109e4: w("41f83c47e02a8852d033ac884df7cca877726b384a461fb9e802000000000000"),
      113e4: w("b8d63c3830e3c5685d3f7d2c2271fdb2ce3315619a473c324ea1a4ce00000000"),
      // UAHF fork block.
      1155875: w("38f1ae7f0ea8c1b589884c5fbd0b83721e3ab6759a4b897206857cf100000000"),
      // DAA fork block.
      1188697: w("fb47e0ab0d2448f71192a09fe61bc9c46cd3b4e7bd778091d00e170000000000"),
      // GWA fork block.
      1303885: w("d323ee8d7ede5bef62f84db98f93cc8c47fae4f02e8938914700000000000000"),
      // Graviton fork block
      1341712: w("5ba3af2992073940ed9e5a9d9eef9194bbfba905d92b202eea44fcff00000000"),
      // Phonon fork block.
      1378461: w("d715e9fab7bbdf301081eeadbe6e931db282cf6b92b1365f9b50f59900000000")
    }, f.lastCheckpoint = 1341712, f.halvingInterval = 21e4, f.genesis = {
      version: 1,
      hash: w("43497fd7f826957108f4a30fd9cec3aeba79972084e90ead01ea330900000000"),
      prevBlock: w("0000000000000000000000000000000000000000000000000000000000000000"),
      merkleRoot: w("3ba3edfd7a7b12b27ac72c3e67768f617fc81bc3888a51323a9fb8aa4b1e5e4a"),
      time: 1296688602,
      bits: 486604799,
      nonce: 414098458,
      height: 0
    }, f.genesisBlock = "0100000000000000000000000000000000000000000000000000000000000000000000003ba3edfd7a7b12b27ac72c3e67768f617fc81bc3888a51323a9fb8aa4b1e5e4adae5494dffff001d1aa4ae180101000000010000000000000000000000000000000000000000000000000000000000000000ffffffff4d04ffff001d0104455468652054696d65732030332f4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66207365636f6e64206261696c6f757420666f722062616e6b73ffffffff0100f2052a01000000434104678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5fac00000000", f.pow = {
      limit: new c(
        "00000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
        "hex"
      ),
      bits: 486604799,
      chainwork: new c(
        "00000000000000000000000000000000000000000000006956e7298fb096a1cc",
        "hex"
      ),
      halfLife: 172800,
      targetTimespan: 336 * 60 * 60,
      targetSpacing: 600,
      retargetInterval: 2016,
      targetReset: !0,
      noRetargeting: !1
    }, f.block = {
      bip34height: 21111,
      bip34hash: w("f88ecd9912d00d3f5c2a8e0f50417d3e415c75b3abe584346da9b32300000000"),
      bip65height: 581885,
      bip65hash: w("b61e864fbec41dfaf09da05d1d76dc068b0dd82ee7982ff255667f0000000000"),
      bip66height: 330776,
      bip66hash: w("82a14b9e5ea81d4832b8e2cd3c2a6092b5a3853285a8995ec4c8042100000000"),
      uahfHeight: 1155875,
      uahfHash: w("38f1ae7f0ea8c1b589884c5fbd0b83721e3ab6759a4b897206857cf100000000"),
      daaHeight: 1188697,
      daaHash: w("fb47e0ab0d2448f71192a09fe61bc9c46cd3b4e7bd778091d00e170000000000"),
      magneticAnomalyHeight: 1267996,
      maaHash: w("244b485f4871816d3ca060f6f363abe81c6fa1bed45c09e0fa01000000000000"),
      greatWallActivationHeight: 1303885,
      gwaHash: w("d323ee8d7ede5bef62f84db98f93cc8c47fae4f02e8938914700000000000000"),
      gravitonActivationTime: 1573819200,
      gravitonHeight: 1341712,
      gravitonHash: w("5ba3af2992073940ed9e5a9d9eef9194bbfba905d92b202eea44fcff00000000"),
      phononActivationTime: 1589544e3,
      asertActivationTime: 1605441600,
      pruneAfterHeight: 1e3,
      keepBlocks: 1e4,
      maxTipAge: 1440 * 60,
      slowHeight: 95e4
    }, f.bip30 = {}, f.activationThreshold = 1512, f.minerWindow = 2016, f.deployments = {
      csv: {
        name: "csv",
        bit: 0,
        startTime: 1456790400,
        // March 1st, 2016
        timeout: 1493596800,
        // May 1st, 2017
        threshold: -1,
        window: -1,
        required: !1,
        force: !0
      },
      testdummy: {
        name: "testdummy",
        bit: 28,
        startTime: 1199145601,
        // January 1, 2008
        timeout: 1230767999,
        // December 31, 2008
        threshold: -1,
        window: -1,
        required: !1,
        force: !0
      }
    }, f.deploys = [
      f.deployments.csv,
      f.deployments.testdummy
    ], f.keyPrefix = {
      privkey: 239,
      xpubkey: 70617039,
      xprivkey: 70615956,
      xpubkey58: "tpub",
      xprivkey58: "tprv",
      coinType: 1
    }, f.addressPrefix = {
      pubkeyhash: 111,
      scripthash: 196,
      cashaddr: "xectest"
    }, f.requireStandard = !1, f.rpcPort = 18332, f.walletPort = 18334, f.minRelay = 1e3, f.feeRate = 2e4, f.maxFeeRate = 6e4, f.selfConnect = !1, f.requestMempool = !1;
    const n = {};
    n.type = "regtest", n.seeds = [
      "127.0.0.1"
    ], n.magic = 4206867930, n.port = 48444, n.checkpointMap = {}, n.lastCheckpoint = 0, n.halvingInterval = 150, n.genesis = {
      version: 1,
      hash: w("06226e46111a0b59caaf126043eb5bbf28c34f3a5e332a1fc7b2b73cf188910f"),
      prevBlock: w("0000000000000000000000000000000000000000000000000000000000000000"),
      merkleRoot: w("3ba3edfd7a7b12b27ac72c3e67768f617fc81bc3888a51323a9fb8aa4b1e5e4a"),
      time: 1296688602,
      bits: 545259519,
      nonce: 2,
      height: 0
    }, n.genesisBlock = "0100000000000000000000000000000000000000000000000000000000000000000000003ba3edfd7a7b12b27ac72c3e67768f617fc81bc3888a51323a9fb8aa4b1e5e4adae5494dffff7f20020000000101000000010000000000000000000000000000000000000000000000000000000000000000ffffffff4d04ffff001d0104455468652054696d65732030332f4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66207365636f6e64206261696c6f757420666f722062616e6b73ffffffff0100f2052a01000000434104678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5fac00000000", n.pow = {
      limit: new c(
        "7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
        "hex"
      ),
      bits: 545259519,
      chainwork: new c(
        "0000000000000000000000000000000000000000000000000000000000000002",
        "hex"
      ),
      halfLife: 172800,
      targetTimespan: 336 * 60 * 60,
      targetSpacing: 600,
      retargetInterval: 2016,
      targetReset: !0,
      noRetargeting: !0
    }, n.block = {
      bip34height: 1e8,
      bip34hash: null,
      bip65height: 1351,
      bip65hash: null,
      bip66height: 1251,
      bip66hash: null,
      uahfHeight: 0,
      uahfHash: null,
      daaHeight: 0,
      daaHash: null,
      magneticAnomalyHeight: 0,
      maaHash: null,
      greatWallActivationHeight: 0,
      gwaHash: null,
      gravitonHeight: 0,
      gravitonHash: null,
      phononActivationTime: 0,
      asertActivationTime: 0,
      pruneAfterHeight: 1e3,
      keepBlocks: 1e4,
      maxTipAge: 4294967295,
      slowHeight: 0
    }, n.bip30 = {}, n.activationThreshold = 108, n.minerWindow = 144, n.deployments = {
      csv: {
        name: "csv",
        bit: 0,
        startTime: 0,
        timeout: 4294967295,
        threshold: -1,
        window: -1,
        required: !1,
        force: !0
      },
      testdummy: {
        name: "testdummy",
        bit: 28,
        startTime: 0,
        timeout: 4294967295,
        threshold: -1,
        window: -1,
        required: !1,
        force: !0
      }
    }, n.deploys = [
      n.deployments.csv,
      n.deployments.testdummy
    ], n.keyPrefix = {
      privkey: 90,
      xpubkey: 3937729029,
      xprivkey: 3937666247,
      xpubkey58: "rpub",
      xprivkey58: "rprv",
      coinType: 1
    }, n.addressPrefix = {
      pubkeyhash: 60,
      scripthash: 38,
      cashaddr: "xecreg"
    }, n.requireStandard = !1, n.rpcPort = 48332, n.walletPort = 48334, n.minRelay = 1e3, n.feeRate = 2e4, n.maxFeeRate = 6e4, n.selfConnect = !0, n.requestMempool = !0;
    const u = {};
    u.type = "simnet", u.seeds = [
      "127.0.0.1"
    ], u.magic = 4076531172, u.port = 18555, u.checkpointMap = {}, u.lastCheckpoint = 0, u.halvingInterval = 21e4, u.genesis = {
      version: 1,
      hash: w("f67ad7695d9b662a72ff3d8edbbb2de0bfa67b13974bb9910d116d5cbd863e68"),
      prevBlock: w("0000000000000000000000000000000000000000000000000000000000000000"),
      merkleRoot: w("3ba3edfd7a7b12b27ac72c3e67768f617fc81bc3888a51323a9fb8aa4b1e5e4a"),
      time: 1401292357,
      bits: 545259519,
      nonce: 2,
      height: 0
    }, u.genesisBlock = "0100000000000000000000000000000000000000000000000000000000000000000000003ba3edfd7a7b12b27ac72c3e67768f617fc81bc3888a51323a9fb8aa4b1e5e4a45068653ffff7f20020000000101000000010000000000000000000000000000000000000000000000000000000000000000ffffffff4d04ffff001d0104455468652054696d65732030332f4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66207365636f6e64206261696c6f757420666f722062616e6b73ffffffff0100f2052a01000000434104678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5fac00000000", u.pow = {
      limit: new c(
        // High target of 0x207fffff (545259519)
        "7fffff0000000000000000000000000000000000000000000000000000000000",
        "hex"
      ),
      bits: 545259519,
      chainwork: new c(
        "0000000000000000000000000000000000000000000000000000000000000002",
        "hex"
      ),
      halfLife: 172800,
      targetTimespan: 336 * 60 * 60,
      targetSpacing: 600,
      retargetInterval: 2016,
      targetReset: !0,
      noRetargeting: !1
    }, u.block = {
      bip34height: 0,
      bip34hash: w("f67ad7695d9b662a72ff3d8edbbb2de0bfa67b13974bb9910d116d5cbd863e68"),
      bip65height: 0,
      bip65hash: w("f67ad7695d9b662a72ff3d8edbbb2de0bfa67b13974bb9910d116d5cbd863e68"),
      bip66height: 0,
      bip66hash: w("f67ad7695d9b662a72ff3d8edbbb2de0bfa67b13974bb9910d116d5cbd863e68"),
      uahfHeight: 0,
      uahfHash: null,
      daaHeight: 0,
      daaHash: null,
      magneticAnomalyActivationTime: 15423e5,
      greatWallActivationTime: 1557921600,
      pruneAfterHeight: 1e3,
      keepBlocks: 1e4,
      maxTipAge: 4294967295,
      slowHeight: 0
    }, u.bip30 = {}, u.activationThreshold = 75, u.minerWindow = 100, u.deployments = {
      csv: {
        name: "csv",
        bit: 0,
        startTime: 0,
        // March 1st, 2016
        timeout: 4294967295,
        // May 1st, 2017
        threshold: -1,
        window: -1,
        required: !1,
        force: !0
      },
      testdummy: {
        name: "testdummy",
        bit: 28,
        startTime: 1199145601,
        // January 1, 2008
        timeout: 1230767999,
        // December 31, 2008
        threshold: -1,
        window: -1,
        required: !1,
        force: !0
      }
    }, u.deploys = [
      u.deployments.csv,
      u.deployments.testdummy
    ], u.keyPrefix = {
      privkey: 100,
      xpubkey: 69254458,
      xprivkey: 69253376,
      xpubkey58: "spub",
      xprivkey58: "sprv",
      coinType: 115
    }, u.addressPrefix = {
      pubkeyhash: 63,
      scripthash: 123,
      cashaddr: "xecsim"
    }, u.requireStandard = !1, u.rpcPort = 18556, u.walletPort = 18558, u.minRelay = 1e3, u.feeRate = 2e4, u.maxFeeRate = 6e4, u.selfConnect = !1, u.requestMempool = !1, d.main = g, d.testnet = f, d.regtest = n, d.simnet = u;
  }(rf)), rf;
}
var oc = {}, n5;
function Ht() {
  return n5 || (n5 = 1, function(e) {
    const c = $e(), d = Hr();
    e.COIN = 1e8, e.MAX_MONEY = 21e6 * e.COIN, e.BASE_REWARD = 50 * e.COIN, e.HALF_REWARD = Math.floor(e.BASE_REWARD / 2), e.MAX_BLOCK_SIZE = 1e6, e.MAX_FORK_BLOCK_SIZE = 32e6, e.MAX_TX_VERSION = 2, e.MAX_TX_SIZE = 1e6, e.MAX_TX_SIGCHECKS = 3e3, e.MAX_BLOCK_SIGCHECKS_RATIO = 141, e.MIN_TX_SIZE = 100, e.MAX_RAW_BLOCK_SIZE = 32e6, e.MAX_BLOCK_SIGOPS_PER_MB = 2e4, e.MAX_TX_SIGOPS = 2e4, e.MAX_BLOCK_SIGOPS_COST = 8e4, e.MAX_COINBASE_SCRIPTSIG_SIZE = 100, e.COINBASE_RULE_ADDR = [
      "ecash:pqnqv9lt7e5vjyp0w88zf2af0l92l8rxdg2jj94l5j",
      "ecash:prfhcnyqnl5cgrnmlfmms675w93ld7mvvqd0y8lz07"
    ], e.MEDIAN_TIMESPAN = 11, e.VERSION_TOP_BITS = 536870912, e.VERSION_TOP_MASK = 3758096384, e.COINBASE_MATURITY = 100, e.LOCKTIME_THRESHOLD = 5e8, e.SEQUENCE_DISABLE_FLAG = 1 << 31 >>> 0, e.SEQUENCE_TYPE_FLAG = 1 << 22, e.SEQUENCE_GRANULARITY = 9, e.SEQUENCE_MASK = 65535, e.MAX_SCRIPT_SIZE = 1e4, e.MAX_SCRIPT_STACK = 1e3, e.MAX_SCRIPT_PUSH = 520, e.MAX_SCRIPT_OPS = 201, e.MAX_MULTISIG_PUBKEYS = 20, e.BIP16_TIME = 1333238400, e.ZERO_HASH = k.alloc(32, 0), e.NULL_HASH = "0000000000000000000000000000000000000000000000000000000000000000", e.ANTI_REPLAY_COMMITMENT = "Bitcoin: A Peer-to-Peer Electronic Cash System", e.fromCompact = function(g) {
      if (g === 0)
        return new d(0);
      const f = g >>> 24, n = g >>> 23 & 1;
      let u = g & 8388607, a;
      return f <= 3 ? (u >>>= 8 * (3 - f), a = new d(u)) : (a = new d(u), a.iushln(8 * (f - 3))), n && a.ineg(), a;
    }, e.toCompact = function(g) {
      if (g.isZero())
        return 0;
      let f = g.byteLength(), n;
      f <= 3 ? (n = g.toNumber(), n <<= 8 * (3 - f)) : n = g.ushrn(8 * (f - 3)).toNumber(), n & 8388608 && (n >>= 8, f++);
      let u = f << 24 | n;
      return g.isNeg() && (u |= 8388608), u >>>= 0, u;
    }, e.verifyPOW = function(g, f) {
      const n = e.fromCompact(f);
      return !(n.isNeg() || n.isZero() || n.bitLength() > 256 || new d(g, "le").gt(n));
    }, e.getReward = function(g, f) {
      c(g >= 0, "Bad height for reward.");
      const n = Math.floor(g / f);
      return n >= 33 ? 0 : n === 0 ? e.BASE_REWARD : e.HALF_REWARD >>> n - 1;
    }, e.hasBit = function(g, f) {
      const n = e.VERSION_TOP_MASK, u = e.VERSION_TOP_BITS, a = (g & n) >>> 0, s = 1 << f;
      return a === u && (g & s) !== 0;
    }, e.maxBlockSigops = function(g) {
      return (1 + ((g - 1) / 1e6 | 0)) * e.MAX_BLOCK_SIGOPS_PER_MB;
    }, e.maxBlockSigchecks = function(g) {
      return g / e.MAX_BLOCK_SIGCHECKS_RATIO;
    };
  }(oc)), oc;
}
var ws = { exports: {} }, s5;
function co() {
  if (s5) return ws.exports;
  s5 = 1;
  var e = typeof Reflect == "object" ? Reflect : null, c = e && typeof e.apply == "function" ? e.apply : function(J, N, z) {
    return Function.prototype.apply.call(J, N, z);
  }, d;
  e && typeof e.ownKeys == "function" ? d = e.ownKeys : Object.getOwnPropertySymbols ? d = function(J) {
    return Object.getOwnPropertyNames(J).concat(Object.getOwnPropertySymbols(J));
  } : d = function(J) {
    return Object.getOwnPropertyNames(J);
  };
  function w(j) {
    console && console.warn && console.warn(j);
  }
  var g = Number.isNaN || function(J) {
    return J !== J;
  };
  function f() {
    f.init.call(this);
  }
  ws.exports = f, ws.exports.once = o, f.EventEmitter = f, f.prototype._events = void 0, f.prototype._eventsCount = 0, f.prototype._maxListeners = void 0;
  var n = 10;
  function u(j) {
    if (typeof j != "function")
      throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof j);
  }
  Object.defineProperty(f, "defaultMaxListeners", {
    enumerable: !0,
    get: function() {
      return n;
    },
    set: function(j) {
      if (typeof j != "number" || j < 0 || g(j))
        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + j + ".");
      n = j;
    }
  }), f.init = function() {
    (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
  }, f.prototype.setMaxListeners = function(J) {
    if (typeof J != "number" || J < 0 || g(J))
      throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + J + ".");
    return this._maxListeners = J, this;
  };
  function a(j) {
    return j._maxListeners === void 0 ? f.defaultMaxListeners : j._maxListeners;
  }
  f.prototype.getMaxListeners = function() {
    return a(this);
  }, f.prototype.emit = function(J) {
    for (var N = [], z = 1; z < arguments.length; z++) N.push(arguments[z]);
    var A = J === "error", q = this._events;
    if (q !== void 0)
      A = A && q.error === void 0;
    else if (!A)
      return !1;
    if (A) {
      var _;
      if (N.length > 0 && (_ = N[0]), _ instanceof Error)
        throw _;
      var F = new Error("Unhandled error." + (_ ? " (" + _.message + ")" : ""));
      throw F.context = _, F;
    }
    var R = q[J];
    if (R === void 0)
      return !1;
    if (typeof R == "function")
      c(R, this, N);
    else
      for (var V = R.length, fe = v(R, V), z = 0; z < V; ++z)
        c(fe[z], this, N);
    return !0;
  };
  function s(j, J, N, z) {
    var A, q, _;
    if (u(N), q = j._events, q === void 0 ? (q = j._events = /* @__PURE__ */ Object.create(null), j._eventsCount = 0) : (q.newListener !== void 0 && (j.emit(
      "newListener",
      J,
      N.listener ? N.listener : N
    ), q = j._events), _ = q[J]), _ === void 0)
      _ = q[J] = N, ++j._eventsCount;
    else if (typeof _ == "function" ? _ = q[J] = z ? [N, _] : [_, N] : z ? _.unshift(N) : _.push(N), A = a(j), A > 0 && _.length > A && !_.warned) {
      _.warned = !0;
      var F = new Error("Possible EventEmitter memory leak detected. " + _.length + " " + String(J) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      F.name = "MaxListenersExceededWarning", F.emitter = j, F.type = J, F.count = _.length, w(F);
    }
    return j;
  }
  f.prototype.addListener = function(J, N) {
    return s(this, J, N, !1);
  }, f.prototype.on = f.prototype.addListener, f.prototype.prependListener = function(J, N) {
    return s(this, J, N, !0);
  };
  function i() {
    if (!this.fired)
      return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
  }
  function p(j, J, N) {
    var z = { fired: !1, wrapFn: void 0, target: j, type: J, listener: N }, A = i.bind(z);
    return A.listener = N, z.wrapFn = A, A;
  }
  f.prototype.once = function(J, N) {
    return u(N), this.on(J, p(this, J, N)), this;
  }, f.prototype.prependOnceListener = function(J, N) {
    return u(N), this.prependListener(J, p(this, J, N)), this;
  }, f.prototype.removeListener = function(J, N) {
    var z, A, q, _, F;
    if (u(N), A = this._events, A === void 0)
      return this;
    if (z = A[J], z === void 0)
      return this;
    if (z === N || z.listener === N)
      --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete A[J], A.removeListener && this.emit("removeListener", J, z.listener || N));
    else if (typeof z != "function") {
      for (q = -1, _ = z.length - 1; _ >= 0; _--)
        if (z[_] === N || z[_].listener === N) {
          F = z[_].listener, q = _;
          break;
        }
      if (q < 0)
        return this;
      q === 0 ? z.shift() : b(z, q), z.length === 1 && (A[J] = z[0]), A.removeListener !== void 0 && this.emit("removeListener", J, F || N);
    }
    return this;
  }, f.prototype.off = f.prototype.removeListener, f.prototype.removeAllListeners = function(J) {
    var N, z, A;
    if (z = this._events, z === void 0)
      return this;
    if (z.removeListener === void 0)
      return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : z[J] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete z[J]), this;
    if (arguments.length === 0) {
      var q = Object.keys(z), _;
      for (A = 0; A < q.length; ++A)
        _ = q[A], _ !== "removeListener" && this.removeAllListeners(_);
      return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
    }
    if (N = z[J], typeof N == "function")
      this.removeListener(J, N);
    else if (N !== void 0)
      for (A = N.length - 1; A >= 0; A--)
        this.removeListener(J, N[A]);
    return this;
  };
  function m(j, J, N) {
    var z = j._events;
    if (z === void 0)
      return [];
    var A = z[J];
    return A === void 0 ? [] : typeof A == "function" ? N ? [A.listener || A] : [A] : N ? h(A) : v(A, A.length);
  }
  f.prototype.listeners = function(J) {
    return m(this, J, !0);
  }, f.prototype.rawListeners = function(J) {
    return m(this, J, !1);
  }, f.listenerCount = function(j, J) {
    return typeof j.listenerCount == "function" ? j.listenerCount(J) : E.call(j, J);
  }, f.prototype.listenerCount = E;
  function E(j) {
    var J = this._events;
    if (J !== void 0) {
      var N = J[j];
      if (typeof N == "function")
        return 1;
      if (N !== void 0)
        return N.length;
    }
    return 0;
  }
  f.prototype.eventNames = function() {
    return this._eventsCount > 0 ? d(this._events) : [];
  };
  function v(j, J) {
    for (var N = new Array(J), z = 0; z < J; ++z)
      N[z] = j[z];
    return N;
  }
  function b(j, J) {
    for (; J + 1 < j.length; J++)
      j[J] = j[J + 1];
    j.pop();
  }
  function h(j) {
    for (var J = new Array(j.length), N = 0; N < J.length; ++N)
      J[N] = j[N].listener || j[N];
    return J;
  }
  function o(j, J) {
    return new Promise(function(N, z) {
      function A(_) {
        j.removeListener(J, q), z(_);
      }
      function q() {
        typeof j.removeListener == "function" && j.removeListener("error", A), N([].slice.call(arguments));
      }
      H(j, J, q, { once: !0 }), J !== "error" && S(j, A, { once: !0 });
    });
  }
  function S(j, J, N) {
    typeof j.on == "function" && H(j, "error", J, N);
  }
  function H(j, J, N, z) {
    if (typeof j.on == "function")
      z.once ? j.once(J, N) : j.on(J, N);
    else if (typeof j.addEventListener == "function")
      j.addEventListener(J, function A(q) {
        z.once && j.removeEventListener(J, A), N(q);
      });
    else
      throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof j);
  }
  return ws.exports;
}
var ac = {}, o5;
function Zt() {
  return o5 || (o5 = 1, function(e) {
    const c = $e(), d = e;
    d.bench = function(g) {
      if (!It.hrtime) {
        const f = Date.now();
        if (g) {
          const [s, i] = g, p = s * 1e3 + i / 1e6;
          return f - p;
        }
        const n = f % 1e3, u = (f - n) / 1e3, a = n * 1e6;
        return [u, a];
      }
      if (g) {
        const [f, n] = It.hrtime(g);
        return f * 1e3 + n / 1e6;
      }
      return It.hrtime();
    }, d.now = function() {
      return Math.floor(Date.now() / 1e3);
    }, d.ms = function() {
      return Date.now();
    }, d.date = function(g) {
      return g == null && (g = d.now()), new Date(g * 1e3).toISOString().slice(0, -5) + "Z";
    }, d.time = function(g) {
      return g == null ? d.now() : new Date(g) / 1e3 | 0;
    }, d.revHex = function(g) {
      return c(k.isBuffer(g)), k.from(g).reverse().toString("hex");
    }, d.fromRev = function(g) {
      return c(typeof g == "string"), c((g.length & 1) === 0), k.from(g, "hex").reverse();
    };
  }(ac)), ac;
}
/*!
 * timedata.js - time management for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var fc, a5;
function Fb() {
  if (a5) return fc;
  a5 = 1;
  const e = co(), c = Zt(), d = so();
  class w extends e {
    /**
     * Create time data.
     * @constructor
     * @param {Number} [limit=200]
     */
    constructor(n) {
      super(), n == null && (n = 200), this.samples = [], this.known = /* @__PURE__ */ new Map(), this.limit = n, this.offset = 0, this.checked = !1;
    }
    /**
     * Add time data.
     * @param {String} id
     * @param {Number} time
     */
    add(n, u) {
      if (this.samples.length >= this.limit || this.known.has(n))
        return;
      const a = u - c.now();
      if (this.known.set(n, a), d.insert(this.samples, a, g), this.emit("sample", a, this.samples.length), this.samples.length >= 5 && this.samples.length % 2 === 1) {
        let s = this.samples[this.samples.length >>> 1];
        if (Math.abs(s) >= 4200) {
          if (!this.checked) {
            let i = !1;
            for (const p of this.samples)
              if (p !== 0 && Math.abs(p) < 300) {
                i = !0;
                break;
              }
            i || (this.checked = !0, this.emit("mismatch"));
          }
          s = 0;
        }
        this.offset = s, this.emit("offset", this.offset);
      }
    }
    /**
     * Get the current adjusted time.
     * @returns {Number} Adjusted Time.
     */
    now() {
      return c.now() + this.offset;
    }
    /**
     * Adjust a timestamp.
     * @param {Number} time
     * @returns {Number} Adjusted Time.
     */
    adjust(n) {
      return n + this.offset;
    }
    /**
     * Unadjust a timestamp.
     * @param {Number} time
     * @returns {Number} Local Time.
     */
    local(n) {
      return n - this.offset;
    }
    /**
     * Get the current adjusted time in milliseconds.
     * @returns {Number} Adjusted Time.
     */
    ms() {
      return Date.now() + this.offset * 1e3;
    }
  }
  function g(f, n) {
    return f - n;
  }
  return fc = w, fc;
}
var cc, f5;
function yr() {
  if (f5) return cc;
  f5 = 1;
  const e = $e(), c = so(), d = dl(), w = Ht(), g = Fb();
  class f {
    /**
     * Create a network.
     * @constructor
     * @param {Object} options
     */
    constructor(o) {
      e(!f[o.type], "Cannot create two networks."), this.type = o.type, this.seeds = o.seeds, this.magic = o.magic, this.port = o.port, this.checkpointMap = o.checkpointMap, this.lastCheckpoint = o.lastCheckpoint, this.checkpoints = [], this.halvingInterval = o.halvingInterval, this.genesis = o.genesis, this.genesisBlock = o.genesisBlock, this.pow = o.pow, this.block = o.block, this.bip30 = o.bip30, this.activationThreshold = o.activationThreshold, this.minerWindow = o.minerWindow, this.deployments = o.deployments, this.deploys = o.deploys, this.unknownBits = ~w.VERSION_TOP_MASK, this.keyPrefix = o.keyPrefix, this.addressPrefix = o.addressPrefix, this.requireStandard = o.requireStandard, this.rpcPort = o.rpcPort, this.walletPort = o.walletPort, this.minRelay = o.minRelay, this.feeRate = o.feeRate, this.maxFeeRate = o.maxFeeRate, this.selfConnect = o.selfConnect, this.requestMempool = o.requestMempool, this.time = new g(), this.init();
    }
    /**
     * Get a deployment by bit index.
     * @param {Number} bit
     * @returns {Object}
     */
    init() {
      let o = 0;
      for (const S of this.deploys)
        o |= 1 << S.bit;
      o |= w.VERSION_TOP_MASK, this.unknownBits = ~o >>> 0;
      for (const S of Object.keys(this.checkpointMap)) {
        const H = this.checkpointMap[S], j = Number(S);
        this.checkpoints.push({ hash: H, height: j });
      }
      this.checkpoints.sort(u);
    }
    /**
     * Get a deployment by bit index.
     * @param {Number} bit
     * @returns {Object}
     */
    byBit(o) {
      const S = c.search(this.deploys, o, n);
      return S === -1 ? null : this.deploys[S];
    }
    /**
     * Get network adjusted time.
     * @returns {Number}
     */
    now() {
      return this.time.now();
    }
    /**
     * Get network adjusted time in milliseconds.
     * @returns {Number}
     */
    ms() {
      return this.time.ms();
    }
    /**
     * Create a network. Get existing network if possible.
     * @param {NetworkType|Object} options
     * @returns {Network}
     */
    static create(o) {
      if (typeof o == "string" && (o = d[o]), e(o, "Unknown network."), f[o.type])
        return f[o.type];
      const S = new f(o);
      return f[S.type] = S, f.primary || (f.primary = S), S;
    }
    /**
     * Set the default network. This network will be used
     * if nothing is passed as the `network` option for
     * certain objects.
     * @param {NetworkType} type - Network type.
     * @returns {Network}
     */
    static set(o) {
      return e(typeof o == "string", "Bad network."), f.primary = f.get(o), f.type = o, f.primary;
    }
    /**
     * Get a network with a string or a Network object.
     * @param {NetworkType|Network} type - Network type.
     * @returns {Network}
     */
    static get(o) {
      if (!o)
        return e(f.primary, "No default network."), f.primary;
      if (o instanceof f)
        return o;
      if (typeof o == "string")
        return f.create(o);
      throw new Error("Unknown network.");
    }
    /**
     * Get a network with a string or a Network object.
     * @param {NetworkType|Network} type - Network type.
     * @returns {Network}
     */
    static ensure(o) {
      return o ? o instanceof f ? o : typeof o == "string" && d[o] ? f.create(o) : (e(f.primary, "No default network."), f.primary) : (e(f.primary, "No default network."), f.primary);
    }
    /**
     * Get a network by an associated comparator.
     * @private
     * @param {Object} value
     * @param {Function} compare
     * @param {Network|null} network
     * @param {String} name
     * @returns {Network}
     */
    static by(o, S, H, j) {
      if (H) {
        if (H = f.get(H), S(H, o))
          return H;
        throw new Error(`Network mismatch for ${j}.`);
      }
      for (const J of d.types)
        if (H = d[J], S(H, o))
          return f.get(J);
      throw new Error(`Network not found for ${j}.`);
    }
    /**
     * Get a network by its magic number.
     * @param {Number} value
     * @param {Network?} network
     * @returns {Network}
     */
    static fromMagic(o, S) {
      return f.by(o, a, S, "magic number");
    }
    /**
     * Get a network by its WIF prefix.
     * @param {Number} value
     * @param {Network?} network
     * @returns {Network}
     */
    static fromWIF(o, S) {
      return f.by(o, s, S, "WIF");
    }
    /**
     * Get a network by its xpubkey prefix.
     * @param {Number} value
     * @param {Network?} network
     * @returns {Network}
     */
    static fromPublic(o, S) {
      return f.by(o, i, S, "xpubkey");
    }
    /**
     * Get a network by its xprivkey prefix.
     * @param {Number} value
     * @param {Network?} network
     * @returns {Network}
     */
    static fromPrivate(o, S) {
      return f.by(o, p, S, "xprivkey");
    }
    /**
     * Get a network by its xpubkey base58 prefix.
     * @param {String} prefix
     * @param {Network?} network
     * @returns {Network}
     */
    static fromPublic58(o, S) {
      return f.by(o, m, S, "xpubkey");
    }
    /**
     * Get a network by its xprivkey base58 prefix.
     * @param {String} prefix
     * @param {Network?} network
     * @returns {Network}
     */
    static fromPrivate58(o, S) {
      return f.by(o, E, S, "xprivkey");
    }
    /**
     * Get a network by its base58 address prefix.
     * @param {Number} value
     * @param {Network?} network
     * @returns {Network}
     */
    static fromAddress(o, S) {
      return f.by(o, v, S, "base58 address");
    }
    /**
     * Get a network by its cashaddr address prefix.
     * @param {String} hrp
     * @param {Network?} network
     * @returns {Network}
     */
    static fromCashAddr(o, S) {
      return f.by(o, b, S, "cashaddr address");
    }
    /**
     * Convert the network to a string.
     * @returns {String}
     */
    toString() {
      return this.type;
    }
    /**
     * Inspect the network.
     * @returns {String}
     */
    inspect() {
      return `<Network: ${this.type}>`;
    }
    /**
     * Test an object to see if it is a Network.
     * @param {Object} obj
     * @returns {Boolean}
     */
    static isNetwork(o) {
      return o instanceof f;
    }
  }
  f.primary = null, f.type = null, f.main = null, f.testnet = null, f.regtest = null, f.segnet4 = null, f.simnet = null, f.set(It.env.BCASH_NETWORK || "main");
  function n(h, o) {
    return h.bit - o;
  }
  function u(h, o) {
    return h.height - o.height;
  }
  function a(h, o) {
    return h.magic === o;
  }
  function s(h, o) {
    return h.keyPrefix.privkey === o;
  }
  function i(h, o) {
    return h.keyPrefix.xpubkey === o;
  }
  function p(h, o) {
    return h.keyPrefix.xprivkey === o;
  }
  function m(h, o) {
    return h.keyPrefix.xpubkey58 === o;
  }
  function E(h, o) {
    return h.keyPrefix.xprivkey58 === o;
  }
  function v(h, o) {
    const S = h.addressPrefix;
    switch (o) {
      case S.pubkeyhash:
      case S.scripthash:
        return !0;
    }
    return !1;
  }
  function b(h, o) {
    return h.addressPrefix.cashaddr === o;
  }
  return cc = f, cc;
}
var Si = {}, uc = {}, Ei = {}, c5;
function pi() {
  if (c5) return Ei;
  c5 = 1;
  const e = Mt(), c = Lt.crypto || Lt.msCrypto, d = c && typeof c.getRandomValues == "function", w = d ? c.getRandomValues.bind(c) : null, g = new Uint32Array(16), f = 65536;
  let n = 0;
  function u(E) {
    e(E >>> 0 === E);
    const v = k.alloc(E);
    return m(v, 0, E), v;
  }
  function a(E, v, b) {
    return e(k.isBuffer(E)), v == null && (v = 0), e(v >>> 0 === v), b == null && (b = E.length - v), e(b >>> 0 === b), e(v + b <= E.length), m(E, v, b), E;
  }
  function s() {
    return (n & 15) === 0 && (p(g), n = 0), g[n++];
  }
  function i(E, v) {
    e(E >>> 0 === E), e(v >>> 0 === v), e(v >= E);
    const b = v - E;
    if (b === 0)
      return E;
    const h = -b >>> 0;
    let o, S;
    do
      o = s(), S = o % b;
    while (o - S > h);
    return S + E;
  }
  function p(E) {
    if (!d)
      throw new Error("Entropy source not available.");
    return w(E);
  }
  function m(E, v, b) {
    if (e(k.isBuffer(E)), e(E.buffer instanceof ArrayBuffer), e(E.byteOffset >>> 0 === E.byteOffset), e(E.byteLength >>> 0 === E.byteLength), e(v >>> 0 === v), e(b >>> 0 === b), e(v + b <= E.byteLength), b > 2 ** 31 - 1)
      throw new RangeError('The value "size" is out of range.');
    const h = E.byteOffset + v, o = new Uint8Array(E.buffer, h, b);
    if (o.length > f)
      for (let S = 0; S < o.length; S += f) {
        let H = S + f;
        H > o.length && (H = o.length), p(o.subarray(S, H));
      }
    else
      o.length > 0 && p(o);
  }
  return Ei.native = 0, Ei.randomBytes = u, Ei.randomFill = a, Ei.randomInt = s, Ei.randomRange = i, Ei;
}
var sr = {}, hc = { exports: {} }, lc = {}, u5;
function Hb() {
  if (u5) return lc;
  u5 = 1;
  function e(S) {
    "@babel/helpers - typeof";
    return e = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(H) {
      return typeof H;
    } : function(H) {
      return H && typeof Symbol == "function" && H.constructor === Symbol && H !== Symbol.prototype ? "symbol" : typeof H;
    }, e(S);
  }
  function c(S, H, j) {
    return Object.defineProperty(S, "prototype", { writable: !1 }), S;
  }
  function d(S, H) {
    if (!(S instanceof H))
      throw new TypeError("Cannot call a class as a function");
  }
  function w(S, H) {
    if (typeof H != "function" && H !== null)
      throw new TypeError("Super expression must either be null or a function");
    S.prototype = Object.create(H && H.prototype, { constructor: { value: S, writable: !0, configurable: !0 } }), Object.defineProperty(S, "prototype", { writable: !1 }), H && g(S, H);
  }
  function g(S, H) {
    return g = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(J, N) {
      return J.__proto__ = N, J;
    }, g(S, H);
  }
  function f(S) {
    var H = a();
    return function() {
      var J = s(S), N;
      if (H) {
        var z = s(this).constructor;
        N = Reflect.construct(J, arguments, z);
      } else
        N = J.apply(this, arguments);
      return n(this, N);
    };
  }
  function n(S, H) {
    if (H && (e(H) === "object" || typeof H == "function"))
      return H;
    if (H !== void 0)
      throw new TypeError("Derived constructors may only return object or undefined");
    return u(S);
  }
  function u(S) {
    if (S === void 0)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return S;
  }
  function a() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
    if (typeof Proxy == "function") return !0;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      })), !0;
    } catch {
      return !1;
    }
  }
  function s(S) {
    return s = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(j) {
      return j.__proto__ || Object.getPrototypeOf(j);
    }, s(S);
  }
  var i = {}, p, m;
  function E(S, H, j) {
    j || (j = Error);
    function J(z, A, q) {
      return typeof H == "string" ? H : H(z, A, q);
    }
    var N = /* @__PURE__ */ function(z) {
      w(q, z);
      var A = f(q);
      function q(_, F, R) {
        var V;
        return d(this, q), V = A.call(this, J(_, F, R)), V.code = S, V;
      }
      return c(q);
    }(j);
    i[S] = N;
  }
  function v(S, H) {
    if (Array.isArray(S)) {
      var j = S.length;
      return S = S.map(function(J) {
        return String(J);
      }), j > 2 ? "one of ".concat(H, " ").concat(S.slice(0, j - 1).join(", "), ", or ") + S[j - 1] : j === 2 ? "one of ".concat(H, " ").concat(S[0], " or ").concat(S[1]) : "of ".concat(H, " ").concat(S[0]);
    } else
      return "of ".concat(H, " ").concat(String(S));
  }
  function b(S, H, j) {
    return S.substr(0, H.length) === H;
  }
  function h(S, H, j) {
    return (j === void 0 || j > S.length) && (j = S.length), S.substring(j - H.length, j) === H;
  }
  function o(S, H, j) {
    return typeof j != "number" && (j = 0), j + H.length > S.length ? !1 : S.indexOf(H, j) !== -1;
  }
  return E("ERR_AMBIGUOUS_ARGUMENT", 'The "%s" argument is ambiguous. %s', TypeError), E("ERR_INVALID_ARG_TYPE", function(S, H, j) {
    p === void 0 && (p = yh()), p(typeof S == "string", "'name' must be a string");
    var J;
    typeof H == "string" && b(H, "not ") ? (J = "must not be", H = H.replace(/^not /, "")) : J = "must be";
    var N;
    if (h(S, " argument"))
      N = "The ".concat(S, " ").concat(J, " ").concat(v(H, "type"));
    else {
      var z = o(S, ".") ? "property" : "argument";
      N = 'The "'.concat(S, '" ').concat(z, " ").concat(J, " ").concat(v(H, "type"));
    }
    return N += ". Received type ".concat(e(j)), N;
  }, TypeError), E("ERR_INVALID_ARG_VALUE", function(S, H) {
    var j = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "is invalid";
    m === void 0 && (m = Mi());
    var J = m.inspect(H);
    return J.length > 128 && (J = "".concat(J.slice(0, 128), "...")), "The argument '".concat(S, "' ").concat(j, ". Received ").concat(J);
  }, TypeError), E("ERR_INVALID_RETURN_VALUE", function(S, H, j) {
    var J;
    return j && j.constructor && j.constructor.name ? J = "instance of ".concat(j.constructor.name) : J = "type ".concat(e(j)), "Expected ".concat(S, ' to be returned from the "').concat(H, '"') + " function but got ".concat(J, ".");
  }, TypeError), E("ERR_MISSING_ARGS", function() {
    for (var S = arguments.length, H = new Array(S), j = 0; j < S; j++)
      H[j] = arguments[j];
    p === void 0 && (p = yh()), p(H.length > 0, "At least one arg needs to be specified");
    var J = "The ", N = H.length;
    switch (H = H.map(function(z) {
      return '"'.concat(z, '"');
    }), N) {
      case 1:
        J += "".concat(H[0], " argument");
        break;
      case 2:
        J += "".concat(H[0], " and ").concat(H[1], " arguments");
        break;
      default:
        J += H.slice(0, N - 1).join(", "), J += ", and ".concat(H[N - 1], " arguments");
        break;
    }
    return "".concat(J, " must be specified");
  }, TypeError), lc.codes = i, lc;
}
var dc, h5;
function Dg() {
  if (h5) return dc;
  h5 = 1;
  function e(Z, oe) {
    var y = Object.keys(Z);
    if (Object.getOwnPropertySymbols) {
      var Y = Object.getOwnPropertySymbols(Z);
      oe && (Y = Y.filter(function(he) {
        return Object.getOwnPropertyDescriptor(Z, he).enumerable;
      })), y.push.apply(y, Y);
    }
    return y;
  }
  function c(Z) {
    for (var oe = 1; oe < arguments.length; oe++) {
      var y = arguments[oe] != null ? arguments[oe] : {};
      oe % 2 ? e(Object(y), !0).forEach(function(Y) {
        d(Z, Y, y[Y]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(Z, Object.getOwnPropertyDescriptors(y)) : e(Object(y)).forEach(function(Y) {
        Object.defineProperty(Z, Y, Object.getOwnPropertyDescriptor(y, Y));
      });
    }
    return Z;
  }
  function d(Z, oe, y) {
    return oe = n(oe), oe in Z ? Object.defineProperty(Z, oe, { value: y, enumerable: !0, configurable: !0, writable: !0 }) : Z[oe] = y, Z;
  }
  function w(Z, oe) {
    if (!(Z instanceof oe))
      throw new TypeError("Cannot call a class as a function");
  }
  function g(Z, oe) {
    for (var y = 0; y < oe.length; y++) {
      var Y = oe[y];
      Y.enumerable = Y.enumerable || !1, Y.configurable = !0, "value" in Y && (Y.writable = !0), Object.defineProperty(Z, n(Y.key), Y);
    }
  }
  function f(Z, oe, y) {
    return oe && g(Z.prototype, oe), Object.defineProperty(Z, "prototype", { writable: !1 }), Z;
  }
  function n(Z) {
    var oe = u(Z, "string");
    return S(oe) === "symbol" ? oe : String(oe);
  }
  function u(Z, oe) {
    if (S(Z) !== "object" || Z === null) return Z;
    var y = Z[Symbol.toPrimitive];
    if (y !== void 0) {
      var Y = y.call(Z, oe);
      if (S(Y) !== "object") return Y;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return String(Z);
  }
  function a(Z, oe) {
    if (typeof oe != "function" && oe !== null)
      throw new TypeError("Super expression must either be null or a function");
    Z.prototype = Object.create(oe && oe.prototype, { constructor: { value: Z, writable: !0, configurable: !0 } }), Object.defineProperty(Z, "prototype", { writable: !1 }), oe && h(Z, oe);
  }
  function s(Z) {
    var oe = v();
    return function() {
      var Y = o(Z), he;
      if (oe) {
        var be = o(this).constructor;
        he = Reflect.construct(Y, arguments, be);
      } else
        he = Y.apply(this, arguments);
      return i(this, he);
    };
  }
  function i(Z, oe) {
    if (oe && (S(oe) === "object" || typeof oe == "function"))
      return oe;
    if (oe !== void 0)
      throw new TypeError("Derived constructors may only return object or undefined");
    return p(Z);
  }
  function p(Z) {
    if (Z === void 0)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return Z;
  }
  function m(Z) {
    var oe = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
    return m = function(Y) {
      if (Y === null || !b(Y)) return Y;
      if (typeof Y != "function")
        throw new TypeError("Super expression must either be null or a function");
      if (typeof oe < "u") {
        if (oe.has(Y)) return oe.get(Y);
        oe.set(Y, he);
      }
      function he() {
        return E(Y, arguments, o(this).constructor);
      }
      return he.prototype = Object.create(Y.prototype, { constructor: { value: he, enumerable: !1, writable: !0, configurable: !0 } }), h(he, Y);
    }, m(Z);
  }
  function E(Z, oe, y) {
    return v() ? E = Reflect.construct.bind() : E = function(he, be, xe) {
      var Ie = [null];
      Ie.push.apply(Ie, be);
      var ve = Function.bind.apply(he, Ie), C = new ve();
      return xe && h(C, xe.prototype), C;
    }, E.apply(null, arguments);
  }
  function v() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
    if (typeof Proxy == "function") return !0;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      })), !0;
    } catch {
      return !1;
    }
  }
  function b(Z) {
    return Function.toString.call(Z).indexOf("[native code]") !== -1;
  }
  function h(Z, oe) {
    return h = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(Y, he) {
      return Y.__proto__ = he, Y;
    }, h(Z, oe);
  }
  function o(Z) {
    return o = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(y) {
      return y.__proto__ || Object.getPrototypeOf(y);
    }, o(Z);
  }
  function S(Z) {
    "@babel/helpers - typeof";
    return S = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(oe) {
      return typeof oe;
    } : function(oe) {
      return oe && typeof Symbol == "function" && oe.constructor === Symbol && oe !== Symbol.prototype ? "symbol" : typeof oe;
    }, S(Z);
  }
  var H = Mi(), j = H.inspect, J = Hb(), N = J.codes.ERR_INVALID_ARG_TYPE;
  function z(Z, oe, y) {
    return (y === void 0 || y > Z.length) && (y = Z.length), Z.substring(y - oe.length, y) === oe;
  }
  function A(Z, oe) {
    if (oe = Math.floor(oe), Z.length == 0 || oe == 0) return "";
    var y = Z.length * oe;
    for (oe = Math.floor(Math.log(oe) / Math.log(2)); oe; )
      Z += Z, oe--;
    return Z += Z.substring(0, y - Z.length), Z;
  }
  var q = "", _ = "", F = "", R = "", V = {
    deepStrictEqual: "Expected values to be strictly deep-equal:",
    strictEqual: "Expected values to be strictly equal:",
    strictEqualObject: 'Expected "actual" to be reference-equal to "expected":',
    deepEqual: "Expected values to be loosely deep-equal:",
    equal: "Expected values to be loosely equal:",
    notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:',
    notStrictEqual: 'Expected "actual" to be strictly unequal to:',
    notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":',
    notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:',
    notEqual: 'Expected "actual" to be loosely unequal to:',
    notIdentical: "Values identical but not reference-equal:"
  }, fe = 10;
  function ue(Z) {
    var oe = Object.keys(Z), y = Object.create(Object.getPrototypeOf(Z));
    return oe.forEach(function(Y) {
      y[Y] = Z[Y];
    }), Object.defineProperty(y, "message", {
      value: Z.message
    }), y;
  }
  function ae(Z) {
    return j(Z, {
      compact: !1,
      customInspect: !1,
      depth: 1e3,
      maxArrayLength: 1 / 0,
      // Assert compares only enumerable properties (with a few exceptions).
      showHidden: !1,
      // Having a long line as error is better than wrapping the line for
      // comparison for now.
      // TODO(BridgeAR): `breakLength` should be limited as soon as soon as we
      // have meta information about the inspected properties (i.e., know where
      // in what line the property starts and ends).
      breakLength: 1 / 0,
      // Assert does not detect proxies currently.
      showProxy: !1,
      sorted: !0,
      // Inspect getters as we also check them when comparing entries.
      getters: !0
    });
  }
  function D(Z, oe, y) {
    var Y = "", he = "", be = 0, xe = "", Ie = !1, ve = ae(Z), C = ve.split(`
`), I = ae(oe).split(`
`), se = 0, t = "";
    if (y === "strictEqual" && S(Z) === "object" && S(oe) === "object" && Z !== null && oe !== null && (y = "strictEqualObject"), C.length === 1 && I.length === 1 && C[0] !== I[0]) {
      var l = C[0].length + I[0].length;
      if (l <= fe) {
        if ((S(Z) !== "object" || Z === null) && (S(oe) !== "object" || oe === null) && (Z !== 0 || oe !== 0))
          return "".concat(V[y], `

`) + "".concat(C[0], " !== ").concat(I[0], `
`);
      } else if (y !== "strictEqualObject") {
        var B = It.stderr && It.stderr.isTTY ? It.stderr.columns : 80;
        if (l < B) {
          for (; C[0][se] === I[0][se]; )
            se++;
          se > 2 && (t = `
  `.concat(A(" ", se), "^"), se = 0);
        }
      }
    }
    for (var U = C[C.length - 1], G = I[I.length - 1]; U === G && (se++ < 2 ? xe = `
  `.concat(U).concat(xe) : Y = U, C.pop(), I.pop(), !(C.length === 0 || I.length === 0)); )
      U = C[C.length - 1], G = I[I.length - 1];
    var T = Math.max(C.length, I.length);
    if (T === 0) {
      var M = ve.split(`
`);
      if (M.length > 30)
        for (M[26] = "".concat(q, "...").concat(R); M.length > 27; )
          M.pop();
      return "".concat(V.notIdentical, `

`).concat(M.join(`
`), `
`);
    }
    se > 3 && (xe = `
`.concat(q, "...").concat(R).concat(xe), Ie = !0), Y !== "" && (xe = `
  `.concat(Y).concat(xe), Y = "");
    var $ = 0, r = V[y] + `
`.concat(_, "+ actual").concat(R, " ").concat(F, "- expected").concat(R), x = " ".concat(q, "...").concat(R, " Lines skipped");
    for (se = 0; se < T; se++) {
      var O = se - be;
      if (C.length < se + 1)
        O > 1 && se > 2 && (O > 4 ? (he += `
`.concat(q, "...").concat(R), Ie = !0) : O > 3 && (he += `
  `.concat(I[se - 2]), $++), he += `
  `.concat(I[se - 1]), $++), be = se, Y += `
`.concat(F, "-").concat(R, " ").concat(I[se]), $++;
      else if (I.length < se + 1)
        O > 1 && se > 2 && (O > 4 ? (he += `
`.concat(q, "...").concat(R), Ie = !0) : O > 3 && (he += `
  `.concat(C[se - 2]), $++), he += `
  `.concat(C[se - 1]), $++), be = se, he += `
`.concat(_, "+").concat(R, " ").concat(C[se]), $++;
      else {
        var L = I[se], X = C[se], P = X !== L && (!z(X, ",") || X.slice(0, -1) !== L);
        P && z(L, ",") && L.slice(0, -1) === X && (P = !1, X += ","), P ? (O > 1 && se > 2 && (O > 4 ? (he += `
`.concat(q, "...").concat(R), Ie = !0) : O > 3 && (he += `
  `.concat(C[se - 2]), $++), he += `
  `.concat(C[se - 1]), $++), be = se, he += `
`.concat(_, "+").concat(R, " ").concat(X), Y += `
`.concat(F, "-").concat(R, " ").concat(L), $ += 2) : (he += Y, Y = "", (O === 1 || se === 0) && (he += `
  `.concat(X), $++));
      }
      if ($ > 20 && se < T - 2)
        return "".concat(r).concat(x, `
`).concat(he, `
`).concat(q, "...").concat(R).concat(Y, `
`) + "".concat(q, "...").concat(R);
    }
    return "".concat(r).concat(Ie ? x : "", `
`).concat(he).concat(Y).concat(xe).concat(t);
  }
  var Q = /* @__PURE__ */ function(Z, oe) {
    a(Y, Z);
    var y = s(Y);
    function Y(he) {
      var be;
      if (w(this, Y), S(he) !== "object" || he === null)
        throw new N("options", "Object", he);
      var xe = he.message, Ie = he.operator, ve = he.stackStartFn, C = he.actual, I = he.expected, se = Error.stackTraceLimit;
      if (Error.stackTraceLimit = 0, xe != null)
        be = y.call(this, String(xe));
      else if (It.stderr && It.stderr.isTTY && (It.stderr && It.stderr.getColorDepth && It.stderr.getColorDepth() !== 1 ? (q = "\x1B[34m", _ = "\x1B[32m", R = "\x1B[39m", F = "\x1B[31m") : (q = "", _ = "", R = "", F = "")), S(C) === "object" && C !== null && S(I) === "object" && I !== null && "stack" in C && C instanceof Error && "stack" in I && I instanceof Error && (C = ue(C), I = ue(I)), Ie === "deepStrictEqual" || Ie === "strictEqual")
        be = y.call(this, D(C, I, Ie));
      else if (Ie === "notDeepStrictEqual" || Ie === "notStrictEqual") {
        var t = V[Ie], l = ae(C).split(`
`);
        if (Ie === "notStrictEqual" && S(C) === "object" && C !== null && (t = V.notStrictEqualObject), l.length > 30)
          for (l[26] = "".concat(q, "...").concat(R); l.length > 27; )
            l.pop();
        l.length === 1 ? be = y.call(this, "".concat(t, " ").concat(l[0])) : be = y.call(this, "".concat(t, `

`).concat(l.join(`
`), `
`));
      } else {
        var B = ae(C), U = "", G = V[Ie];
        Ie === "notDeepEqual" || Ie === "notEqual" ? (B = "".concat(V[Ie], `

`).concat(B), B.length > 1024 && (B = "".concat(B.slice(0, 1021), "..."))) : (U = "".concat(ae(I)), B.length > 512 && (B = "".concat(B.slice(0, 509), "...")), U.length > 512 && (U = "".concat(U.slice(0, 509), "...")), Ie === "deepEqual" || Ie === "equal" ? B = "".concat(G, `

`).concat(B, `

should equal

`) : U = " ".concat(Ie, " ").concat(U)), be = y.call(this, "".concat(B).concat(U));
      }
      return Error.stackTraceLimit = se, be.generatedMessage = !xe, Object.defineProperty(p(be), "name", {
        value: "AssertionError [ERR_ASSERTION]",
        enumerable: !1,
        writable: !0,
        configurable: !0
      }), be.code = "ERR_ASSERTION", be.actual = C, be.expected = I, be.operator = Ie, Error.captureStackTrace && Error.captureStackTrace(p(be), ve), be.stack, be.name = "AssertionError", i(be);
    }
    return f(Y, [{
      key: "toString",
      value: function() {
        return "".concat(this.name, " [").concat(this.code, "]: ").concat(this.message);
      }
    }, {
      key: oe,
      value: function(be, xe) {
        return j(this, c(c({}, xe), {}, {
          customInspect: !1,
          depth: 0
        }));
      }
    }]), Y;
  }(/* @__PURE__ */ m(Error), j.custom);
  return dc = Q, dc;
}
var bc, l5;
function Lb() {
  if (l5) return bc;
  l5 = 1;
  var e = Object.prototype.toString;
  return bc = function(d) {
    var w = e.call(d), g = w === "[object Arguments]";
    return g || (g = w !== "[object Array]" && d !== null && typeof d == "object" && typeof d.length == "number" && d.length >= 0 && e.call(d.callee) === "[object Function]"), g;
  }, bc;
}
var pc, d5;
function Ug() {
  if (d5) return pc;
  d5 = 1;
  var e;
  if (!Object.keys) {
    var c = Object.prototype.hasOwnProperty, d = Object.prototype.toString, w = Lb(), g = Object.prototype.propertyIsEnumerable, f = !g.call({ toString: null }, "toString"), n = g.call(function() {
    }, "prototype"), u = [
      "toString",
      "toLocaleString",
      "valueOf",
      "hasOwnProperty",
      "isPrototypeOf",
      "propertyIsEnumerable",
      "constructor"
    ], a = function(m) {
      var E = m.constructor;
      return E && E.prototype === m;
    }, s = {
      $applicationCache: !0,
      $console: !0,
      $external: !0,
      $frame: !0,
      $frameElement: !0,
      $frames: !0,
      $innerHeight: !0,
      $innerWidth: !0,
      $onmozfullscreenchange: !0,
      $onmozfullscreenerror: !0,
      $outerHeight: !0,
      $outerWidth: !0,
      $pageXOffset: !0,
      $pageYOffset: !0,
      $parent: !0,
      $scrollLeft: !0,
      $scrollTop: !0,
      $scrollX: !0,
      $scrollY: !0,
      $self: !0,
      $webkitIndexedDB: !0,
      $webkitStorageInfo: !0,
      $window: !0
    }, i = function() {
      if (typeof window > "u")
        return !1;
      for (var m in window)
        try {
          if (!s["$" + m] && c.call(window, m) && window[m] !== null && typeof window[m] == "object")
            try {
              a(window[m]);
            } catch {
              return !0;
            }
        } catch {
          return !0;
        }
      return !1;
    }(), p = function(m) {
      if (typeof window > "u" || !i)
        return a(m);
      try {
        return a(m);
      } catch {
        return !1;
      }
    };
    e = function(E) {
      var v = E !== null && typeof E == "object", b = d.call(E) === "[object Function]", h = w(E), o = v && d.call(E) === "[object String]", S = [];
      if (!v && !b && !h)
        throw new TypeError("Object.keys called on a non-object");
      var H = n && b;
      if (o && E.length > 0 && !c.call(E, 0))
        for (var j = 0; j < E.length; ++j)
          S.push(String(j));
      if (h && E.length > 0)
        for (var J = 0; J < E.length; ++J)
          S.push(String(J));
      else
        for (var N in E)
          !(H && N === "prototype") && c.call(E, N) && S.push(String(N));
      if (f)
        for (var z = p(E), A = 0; A < u.length; ++A)
          !(z && u[A] === "constructor") && c.call(E, u[A]) && S.push(u[A]);
      return S;
    };
  }
  return pc = e, pc;
}
var mc, b5;
function Kb() {
  if (b5) return mc;
  b5 = 1;
  var e = Array.prototype.slice, c = Lb(), d = Object.keys, w = d ? function(n) {
    return d(n);
  } : Ug(), g = Object.keys;
  return w.shim = function() {
    if (Object.keys) {
      var n = function() {
        var u = Object.keys(arguments);
        return u && u.length === arguments.length;
      }(1, 2);
      n || (Object.keys = function(a) {
        return c(a) ? g(e.call(a)) : g(a);
      });
    } else
      Object.keys = w;
    return Object.keys || w;
  }, mc = w, mc;
}
var gc, p5;
function Fg() {
  if (p5) return gc;
  p5 = 1;
  var e = Kb(), c = ol()(), d = /* @__PURE__ */ pn(), w = /* @__PURE__ */ al(), g = d("Array.prototype.push"), f = d("Object.prototype.propertyIsEnumerable"), n = c ? w.getOwnPropertySymbols : null;
  return gc = function(a, s) {
    if (a == null)
      throw new TypeError("target must be an object");
    var i = w(a);
    if (arguments.length === 1)
      return i;
    for (var p = 1; p < arguments.length; ++p) {
      var m = w(arguments[p]), E = e(m), v = c && (w.getOwnPropertySymbols || n);
      if (v)
        for (var b = v(m), h = 0; h < b.length; ++h) {
          var o = b[h];
          f(m, o) && g(E, o);
        }
      for (var S = 0; S < E.length; ++S) {
        var H = E[S];
        if (f(m, H)) {
          var j = m[H];
          i[H] = j;
        }
      }
    }
    return i;
  }, gc;
}
var xc, m5;
function Hg() {
  if (m5) return xc;
  m5 = 1;
  var e = Fg(), c = function() {
    if (!Object.assign)
      return !1;
    for (var w = "abcdefghijklmnopqrst", g = w.split(""), f = {}, n = 0; n < g.length; ++n)
      f[g[n]] = g[n];
    var u = Object.assign({}, f), a = "";
    for (var s in u)
      a += s;
    return w !== a;
  }, d = function() {
    if (!Object.assign || !Object.preventExtensions)
      return !1;
    var w = Object.preventExtensions({ 1: 2 });
    try {
      Object.assign(w, "xy");
    } catch {
      return w[1] === "y";
    }
    return !1;
  };
  return xc = function() {
    return !Object.assign || c() || d() ? e : Object.assign;
  }, xc;
}
var wc, g5;
function Vb() {
  if (g5) return wc;
  g5 = 1;
  var e = function(c) {
    return c !== c;
  };
  return wc = function(d, w) {
    return d === 0 && w === 0 ? 1 / d === 1 / w : !!(d === w || e(d) && e(w));
  }, wc;
}
var yc, x5;
function bl() {
  if (x5) return yc;
  x5 = 1;
  var e = Vb();
  return yc = function() {
    return typeof Object.is == "function" ? Object.is : e;
  }, yc;
}
var vc, w5;
function Lg() {
  if (w5) return vc;
  w5 = 1;
  var e = /* @__PURE__ */ ll(), c = fo(), d = c(e("String.prototype.indexOf"));
  return vc = function(g, f) {
    var n = e(g, !!f);
    return typeof n == "function" && d(g, ".prototype.") > -1 ? c(n) : n;
  }, vc;
}
var Sc, y5;
function uo() {
  if (y5) return Sc;
  y5 = 1;
  var e = Kb(), c = typeof Symbol == "function" && typeof Symbol("foo") == "symbol", d = Object.prototype.toString, w = Array.prototype.concat, g = /* @__PURE__ */ Tb(), f = function(s) {
    return typeof s == "function" && d.call(s) === "[object Function]";
  }, n = /* @__PURE__ */ Cb()(), u = function(s, i, p, m) {
    if (i in s) {
      if (m === !0) {
        if (s[i] === p)
          return;
      } else if (!f(m) || !m())
        return;
    }
    n ? g(s, i, p, !0) : g(s, i, p);
  }, a = function(s, i) {
    var p = arguments.length > 2 ? arguments[2] : {}, m = e(i);
    c && (m = w.call(m, Object.getOwnPropertySymbols(i)));
    for (var E = 0; E < m.length; E += 1)
      u(s, m[E], i[m[E]], p[m[E]]);
  };
  return a.supportsDescriptors = !!n, Sc = a, Sc;
}
var Ec, v5;
function Kg() {
  if (v5) return Ec;
  v5 = 1;
  var e = bl(), c = uo();
  return Ec = function() {
    var w = e();
    return c(Object, { is: w }, {
      is: function() {
        return Object.is !== w;
      }
    }), w;
  }, Ec;
}
var Ic, S5;
function Vg() {
  if (S5) return Ic;
  S5 = 1;
  var e = uo(), c = fo(), d = Vb(), w = bl(), g = Kg(), f = c(w(), Object);
  return e(f, {
    getPolyfill: w,
    implementation: d,
    shim: g
  }), Ic = f, Ic;
}
var Ac, E5;
function $b() {
  return E5 || (E5 = 1, Ac = function(c) {
    return c !== c;
  }), Ac;
}
var Oc, I5;
function jb() {
  if (I5) return Oc;
  I5 = 1;
  var e = $b();
  return Oc = function() {
    return Number.isNaN && Number.isNaN(NaN) && !Number.isNaN("a") ? Number.isNaN : e;
  }, Oc;
}
var _c, A5;
function $g() {
  if (A5) return _c;
  A5 = 1;
  var e = uo(), c = jb();
  return _c = function() {
    var w = c();
    return e(Number, { isNaN: w }, {
      isNaN: function() {
        return Number.isNaN !== w;
      }
    }), w;
  }, _c;
}
var Rc, O5;
function jg() {
  if (O5) return Rc;
  O5 = 1;
  var e = fo(), c = uo(), d = $b(), w = jb(), g = $g(), f = e(w(), Number);
  return c(f, {
    getPolyfill: w,
    implementation: d,
    shim: g
  }), Rc = f, Rc;
}
var Pc, _5;
function Yg() {
  if (_5) return Pc;
  _5 = 1;
  function e(P, K) {
    return f(P) || g(P, K) || d(P, K) || c();
  }
  function c() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  function d(P, K) {
    if (P) {
      if (typeof P == "string") return w(P, K);
      var re = Object.prototype.toString.call(P).slice(8, -1);
      if (re === "Object" && P.constructor && (re = P.constructor.name), re === "Map" || re === "Set") return Array.from(P);
      if (re === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(re)) return w(P, K);
    }
  }
  function w(P, K) {
    (K == null || K > P.length) && (K = P.length);
    for (var re = 0, ce = new Array(K); re < K; re++) ce[re] = P[re];
    return ce;
  }
  function g(P, K) {
    var re = P == null ? null : typeof Symbol < "u" && P[Symbol.iterator] || P["@@iterator"];
    if (re != null) {
      var ce, le, me, ne, W = [], te = !0, pe = !1;
      try {
        if (me = (re = re.call(P)).next, K !== 0) for (; !(te = (ce = me.call(re)).done) && (W.push(ce.value), W.length !== K); te = !0) ;
      } catch (Ee) {
        pe = !0, le = Ee;
      } finally {
        try {
          if (!te && re.return != null && (ne = re.return(), Object(ne) !== ne)) return;
        } finally {
          if (pe) throw le;
        }
      }
      return W;
    }
  }
  function f(P) {
    if (Array.isArray(P)) return P;
  }
  function n(P) {
    "@babel/helpers - typeof";
    return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(K) {
      return typeof K;
    } : function(K) {
      return K && typeof Symbol == "function" && K.constructor === Symbol && K !== Symbol.prototype ? "symbol" : typeof K;
    }, n(P);
  }
  var u = /a/g.flags !== void 0, a = function(K) {
    var re = [];
    return K.forEach(function(ce) {
      return re.push(ce);
    }), re;
  }, s = function(K) {
    var re = [];
    return K.forEach(function(ce, le) {
      return re.push([le, ce]);
    }), re;
  }, i = Object.is ? Object.is : Vg(), p = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function() {
    return [];
  }, m = Number.isNaN ? Number.isNaN : jg();
  function E(P) {
    return P.call.bind(P);
  }
  var v = E(Object.prototype.hasOwnProperty), b = E(Object.prototype.propertyIsEnumerable), h = E(Object.prototype.toString), o = Mi().types, S = o.isAnyArrayBuffer, H = o.isArrayBufferView, j = o.isDate, J = o.isMap, N = o.isRegExp, z = o.isSet, A = o.isNativeError, q = o.isBoxedPrimitive, _ = o.isNumberObject, F = o.isStringObject, R = o.isBooleanObject, V = o.isBigIntObject, fe = o.isSymbolObject, ue = o.isFloat32Array, ae = o.isFloat64Array;
  function D(P) {
    if (P.length === 0 || P.length > 10) return !0;
    for (var K = 0; K < P.length; K++) {
      var re = P.charCodeAt(K);
      if (re < 48 || re > 57) return !0;
    }
    return P.length === 10 && P >= Math.pow(2, 32);
  }
  function Q(P) {
    return Object.keys(P).filter(D).concat(p(P).filter(Object.prototype.propertyIsEnumerable.bind(P)));
  }
  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   */
  function Z(P, K) {
    if (P === K)
      return 0;
    for (var re = P.length, ce = K.length, le = 0, me = Math.min(re, ce); le < me; ++le)
      if (P[le] !== K[le]) {
        re = P[le], ce = K[le];
        break;
      }
    return re < ce ? -1 : ce < re ? 1 : 0;
  }
  var oe = !0, y = !1, Y = 0, he = 1, be = 2, xe = 3;
  function Ie(P, K) {
    return u ? P.source === K.source && P.flags === K.flags : RegExp.prototype.toString.call(P) === RegExp.prototype.toString.call(K);
  }
  function ve(P, K) {
    if (P.byteLength !== K.byteLength)
      return !1;
    for (var re = 0; re < P.byteLength; re++)
      if (P[re] !== K[re])
        return !1;
    return !0;
  }
  function C(P, K) {
    return P.byteLength !== K.byteLength ? !1 : Z(new Uint8Array(P.buffer, P.byteOffset, P.byteLength), new Uint8Array(K.buffer, K.byteOffset, K.byteLength)) === 0;
  }
  function I(P, K) {
    return P.byteLength === K.byteLength && Z(new Uint8Array(P), new Uint8Array(K)) === 0;
  }
  function se(P, K) {
    return _(P) ? _(K) && i(Number.prototype.valueOf.call(P), Number.prototype.valueOf.call(K)) : F(P) ? F(K) && String.prototype.valueOf.call(P) === String.prototype.valueOf.call(K) : R(P) ? R(K) && Boolean.prototype.valueOf.call(P) === Boolean.prototype.valueOf.call(K) : V(P) ? V(K) && BigInt.prototype.valueOf.call(P) === BigInt.prototype.valueOf.call(K) : fe(K) && Symbol.prototype.valueOf.call(P) === Symbol.prototype.valueOf.call(K);
  }
  function t(P, K, re, ce) {
    if (P === K)
      return P !== 0 ? !0 : re ? i(P, K) : !0;
    if (re) {
      if (n(P) !== "object")
        return typeof P == "number" && m(P) && m(K);
      if (n(K) !== "object" || P === null || K === null || Object.getPrototypeOf(P) !== Object.getPrototypeOf(K))
        return !1;
    } else {
      if (P === null || n(P) !== "object")
        return K === null || n(K) !== "object" ? P == K : !1;
      if (K === null || n(K) !== "object")
        return !1;
    }
    var le = h(P), me = h(K);
    if (le !== me)
      return !1;
    if (Array.isArray(P)) {
      if (P.length !== K.length)
        return !1;
      var ne = Q(P), W = Q(K);
      return ne.length !== W.length ? !1 : B(P, K, re, ce, he, ne);
    }
    if (le === "[object Object]" && (!J(P) && J(K) || !z(P) && z(K)))
      return !1;
    if (j(P)) {
      if (!j(K) || Date.prototype.getTime.call(P) !== Date.prototype.getTime.call(K))
        return !1;
    } else if (N(P)) {
      if (!N(K) || !Ie(P, K))
        return !1;
    } else if (A(P) || P instanceof Error) {
      if (P.message !== K.message || P.name !== K.name)
        return !1;
    } else if (H(P)) {
      if (!re && (ue(P) || ae(P))) {
        if (!ve(P, K))
          return !1;
      } else if (!C(P, K))
        return !1;
      var te = Q(P), pe = Q(K);
      return te.length !== pe.length ? !1 : B(P, K, re, ce, Y, te);
    } else {
      if (z(P))
        return !z(K) || P.size !== K.size ? !1 : B(P, K, re, ce, be);
      if (J(P))
        return !J(K) || P.size !== K.size ? !1 : B(P, K, re, ce, xe);
      if (S(P)) {
        if (!I(P, K))
          return !1;
      } else if (q(P) && !se(P, K))
        return !1;
    }
    return B(P, K, re, ce, Y);
  }
  function l(P, K) {
    return K.filter(function(re) {
      return b(P, re);
    });
  }
  function B(P, K, re, ce, le, me) {
    if (arguments.length === 5) {
      me = Object.keys(P);
      var ne = Object.keys(K);
      if (me.length !== ne.length)
        return !1;
    }
    for (var W = 0; W < me.length; W++)
      if (!v(K, me[W]))
        return !1;
    if (re && arguments.length === 5) {
      var te = p(P);
      if (te.length !== 0) {
        var pe = 0;
        for (W = 0; W < te.length; W++) {
          var Ee = te[W];
          if (b(P, Ee)) {
            if (!b(K, Ee))
              return !1;
            me.push(Ee), pe++;
          } else if (b(K, Ee))
            return !1;
        }
        var Ae = p(K);
        if (te.length !== Ae.length && l(K, Ae).length !== pe)
          return !1;
      } else {
        var Oe = p(K);
        if (Oe.length !== 0 && l(K, Oe).length !== 0)
          return !1;
      }
    }
    if (me.length === 0 && (le === Y || le === he && P.length === 0 || P.size === 0))
      return !0;
    if (ce === void 0)
      ce = {
        val1: /* @__PURE__ */ new Map(),
        val2: /* @__PURE__ */ new Map(),
        position: 0
      };
    else {
      var Be = ce.val1.get(P);
      if (Be !== void 0) {
        var ke = ce.val2.get(K);
        if (ke !== void 0)
          return Be === ke;
      }
      ce.position++;
    }
    ce.val1.set(P, ce.position), ce.val2.set(K, ce.position);
    var Ne = O(P, K, re, me, ce, le);
    return ce.val1.delete(P), ce.val2.delete(K), Ne;
  }
  function U(P, K, re, ce) {
    for (var le = a(P), me = 0; me < le.length; me++) {
      var ne = le[me];
      if (t(K, ne, re, ce))
        return P.delete(ne), !0;
    }
    return !1;
  }
  function G(P) {
    switch (n(P)) {
      case "undefined":
        return null;
      case "object":
        return;
      case "symbol":
        return !1;
      case "string":
        P = +P;
      // Loose equal entries exist only if the string is possible to convert to
      // a regular number and not NaN.
      // Fall through
      case "number":
        if (m(P))
          return !1;
    }
    return !0;
  }
  function T(P, K, re) {
    var ce = G(re);
    return ce ?? (K.has(ce) && !P.has(ce));
  }
  function M(P, K, re, ce, le) {
    var me = G(re);
    if (me != null)
      return me;
    var ne = K.get(me);
    return ne === void 0 && !K.has(me) || !t(ce, ne, !1, le) ? !1 : !P.has(me) && t(ce, ne, !1, le);
  }
  function $(P, K, re, ce) {
    for (var le = null, me = a(P), ne = 0; ne < me.length; ne++) {
      var W = me[ne];
      if (n(W) === "object" && W !== null)
        le === null && (le = /* @__PURE__ */ new Set()), le.add(W);
      else if (!K.has(W)) {
        if (re || !T(P, K, W))
          return !1;
        le === null && (le = /* @__PURE__ */ new Set()), le.add(W);
      }
    }
    if (le !== null) {
      for (var te = a(K), pe = 0; pe < te.length; pe++) {
        var Ee = te[pe];
        if (n(Ee) === "object" && Ee !== null) {
          if (!U(le, Ee, re, ce)) return !1;
        } else if (!re && !P.has(Ee) && !U(le, Ee, re, ce))
          return !1;
      }
      return le.size === 0;
    }
    return !0;
  }
  function r(P, K, re, ce, le, me) {
    for (var ne = a(P), W = 0; W < ne.length; W++) {
      var te = ne[W];
      if (t(re, te, le, me) && t(ce, K.get(te), le, me))
        return P.delete(te), !0;
    }
    return !1;
  }
  function x(P, K, re, ce) {
    for (var le = null, me = s(P), ne = 0; ne < me.length; ne++) {
      var W = e(me[ne], 2), te = W[0], pe = W[1];
      if (n(te) === "object" && te !== null)
        le === null && (le = /* @__PURE__ */ new Set()), le.add(te);
      else {
        var Ee = K.get(te);
        if (Ee === void 0 && !K.has(te) || !t(pe, Ee, re, ce)) {
          if (re || !M(P, K, te, pe, ce)) return !1;
          le === null && (le = /* @__PURE__ */ new Set()), le.add(te);
        }
      }
    }
    if (le !== null) {
      for (var Ae = s(K), Oe = 0; Oe < Ae.length; Oe++) {
        var Be = e(Ae[Oe], 2), ke = Be[0], Ne = Be[1];
        if (n(ke) === "object" && ke !== null) {
          if (!r(le, P, ke, Ne, re, ce)) return !1;
        } else if (!re && (!P.has(ke) || !t(P.get(ke), Ne, !1, ce)) && !r(le, P, ke, Ne, !1, ce))
          return !1;
      }
      return le.size === 0;
    }
    return !0;
  }
  function O(P, K, re, ce, le, me) {
    var ne = 0;
    if (me === be) {
      if (!$(P, K, re, le))
        return !1;
    } else if (me === xe) {
      if (!x(P, K, re, le))
        return !1;
    } else if (me === he)
      for (; ne < P.length; ne++)
        if (v(P, ne)) {
          if (!v(K, ne) || !t(P[ne], K[ne], re, le))
            return !1;
        } else {
          if (v(K, ne))
            return !1;
          for (var W = Object.keys(P); ne < W.length; ne++) {
            var te = W[ne];
            if (!v(K, te) || !t(P[te], K[te], re, le))
              return !1;
          }
          return W.length === Object.keys(K).length;
        }
    for (ne = 0; ne < ce.length; ne++) {
      var pe = ce[ne];
      if (!t(P[pe], K[pe], re, le))
        return !1;
    }
    return !0;
  }
  function L(P, K) {
    return t(P, K, y);
  }
  function X(P, K) {
    return t(P, K, oe);
  }
  return Pc = {
    isDeepEqual: L,
    isDeepStrictEqual: X
  }, Pc;
}
var R5;
function yh() {
  if (R5) return hc.exports;
  R5 = 1;
  function e(be) {
    "@babel/helpers - typeof";
    return e = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(xe) {
      return typeof xe;
    } : function(xe) {
      return xe && typeof Symbol == "function" && xe.constructor === Symbol && xe !== Symbol.prototype ? "symbol" : typeof xe;
    }, e(be);
  }
  function c(be, xe, Ie) {
    return Object.defineProperty(be, "prototype", { writable: !1 }), be;
  }
  function d(be, xe) {
    if (!(be instanceof xe))
      throw new TypeError("Cannot call a class as a function");
  }
  var w = Hb(), g = w.codes, f = g.ERR_AMBIGUOUS_ARGUMENT, n = g.ERR_INVALID_ARG_TYPE, u = g.ERR_INVALID_ARG_VALUE, a = g.ERR_INVALID_RETURN_VALUE, s = g.ERR_MISSING_ARGS, i = Dg(), p = Mi(), m = p.inspect, E = Mi().types, v = E.isPromise, b = E.isRegExp, h = Hg()(), o = bl()(), S = Lg()("RegExp.prototype.test"), H, j;
  function J() {
    var be = Yg();
    H = be.isDeepEqual, j = be.isDeepStrictEqual;
  }
  var N = !1, z = hc.exports = R, A = {};
  function q(be) {
    throw be.message instanceof Error ? be.message : new i(be);
  }
  function _(be, xe, Ie, ve, C) {
    var I = arguments.length, se;
    if (I === 0)
      se = "Failed";
    else if (I === 1)
      Ie = be, be = void 0;
    else {
      if (N === !1) {
        N = !0;
        var t = It.emitWarning ? It.emitWarning : console.warn.bind(console);
        t("assert.fail() with more than one argument is deprecated. Please use assert.strictEqual() instead or only pass a message.", "DeprecationWarning", "DEP0094");
      }
      I === 2 && (ve = "!=");
    }
    if (Ie instanceof Error) throw Ie;
    var l = {
      actual: be,
      expected: xe,
      operator: ve === void 0 ? "fail" : ve,
      stackStartFn: C || _
    };
    Ie !== void 0 && (l.message = Ie);
    var B = new i(l);
    throw se && (B.message = se, B.generatedMessage = !0), B;
  }
  z.fail = _, z.AssertionError = i;
  function F(be, xe, Ie, ve) {
    if (!Ie) {
      var C = !1;
      if (xe === 0)
        C = !0, ve = "No value argument passed to `assert.ok()`";
      else if (ve instanceof Error)
        throw ve;
      var I = new i({
        actual: Ie,
        expected: !0,
        message: ve,
        operator: "==",
        stackStartFn: be
      });
      throw I.generatedMessage = C, I;
    }
  }
  function R() {
    for (var be = arguments.length, xe = new Array(be), Ie = 0; Ie < be; Ie++)
      xe[Ie] = arguments[Ie];
    F.apply(void 0, [R, xe.length].concat(xe));
  }
  z.ok = R, z.equal = function be(xe, Ie, ve) {
    if (arguments.length < 2)
      throw new s("actual", "expected");
    xe != Ie && q({
      actual: xe,
      expected: Ie,
      message: ve,
      operator: "==",
      stackStartFn: be
    });
  }, z.notEqual = function be(xe, Ie, ve) {
    if (arguments.length < 2)
      throw new s("actual", "expected");
    xe == Ie && q({
      actual: xe,
      expected: Ie,
      message: ve,
      operator: "!=",
      stackStartFn: be
    });
  }, z.deepEqual = function be(xe, Ie, ve) {
    if (arguments.length < 2)
      throw new s("actual", "expected");
    H === void 0 && J(), H(xe, Ie) || q({
      actual: xe,
      expected: Ie,
      message: ve,
      operator: "deepEqual",
      stackStartFn: be
    });
  }, z.notDeepEqual = function be(xe, Ie, ve) {
    if (arguments.length < 2)
      throw new s("actual", "expected");
    H === void 0 && J(), H(xe, Ie) && q({
      actual: xe,
      expected: Ie,
      message: ve,
      operator: "notDeepEqual",
      stackStartFn: be
    });
  }, z.deepStrictEqual = function be(xe, Ie, ve) {
    if (arguments.length < 2)
      throw new s("actual", "expected");
    H === void 0 && J(), j(xe, Ie) || q({
      actual: xe,
      expected: Ie,
      message: ve,
      operator: "deepStrictEqual",
      stackStartFn: be
    });
  }, z.notDeepStrictEqual = V;
  function V(be, xe, Ie) {
    if (arguments.length < 2)
      throw new s("actual", "expected");
    H === void 0 && J(), j(be, xe) && q({
      actual: be,
      expected: xe,
      message: Ie,
      operator: "notDeepStrictEqual",
      stackStartFn: V
    });
  }
  z.strictEqual = function be(xe, Ie, ve) {
    if (arguments.length < 2)
      throw new s("actual", "expected");
    o(xe, Ie) || q({
      actual: xe,
      expected: Ie,
      message: ve,
      operator: "strictEqual",
      stackStartFn: be
    });
  }, z.notStrictEqual = function be(xe, Ie, ve) {
    if (arguments.length < 2)
      throw new s("actual", "expected");
    o(xe, Ie) && q({
      actual: xe,
      expected: Ie,
      message: ve,
      operator: "notStrictEqual",
      stackStartFn: be
    });
  };
  var fe = /* @__PURE__ */ c(function be(xe, Ie, ve) {
    var C = this;
    d(this, be), Ie.forEach(function(I) {
      I in xe && (ve !== void 0 && typeof ve[I] == "string" && b(xe[I]) && S(xe[I], ve[I]) ? C[I] = ve[I] : C[I] = xe[I]);
    });
  });
  function ue(be, xe, Ie, ve, C, I) {
    if (!(Ie in be) || !j(be[Ie], xe[Ie])) {
      if (!ve) {
        var se = new fe(be, C), t = new fe(xe, C, be), l = new i({
          actual: se,
          expected: t,
          operator: "deepStrictEqual",
          stackStartFn: I
        });
        throw l.actual = be, l.expected = xe, l.operator = I.name, l;
      }
      q({
        actual: be,
        expected: xe,
        message: ve,
        operator: I.name,
        stackStartFn: I
      });
    }
  }
  function ae(be, xe, Ie, ve) {
    if (typeof xe != "function") {
      if (b(xe)) return S(xe, be);
      if (arguments.length === 2)
        throw new n("expected", ["Function", "RegExp"], xe);
      if (e(be) !== "object" || be === null) {
        var C = new i({
          actual: be,
          expected: xe,
          message: Ie,
          operator: "deepStrictEqual",
          stackStartFn: ve
        });
        throw C.operator = ve.name, C;
      }
      var I = Object.keys(xe);
      if (xe instanceof Error)
        I.push("name", "message");
      else if (I.length === 0)
        throw new u("error", xe, "may not be an empty object");
      return H === void 0 && J(), I.forEach(function(se) {
        typeof be[se] == "string" && b(xe[se]) && S(xe[se], be[se]) || ue(be, xe, se, Ie, I, ve);
      }), !0;
    }
    return xe.prototype !== void 0 && be instanceof xe ? !0 : Error.isPrototypeOf(xe) ? !1 : xe.call({}, be) === !0;
  }
  function D(be) {
    if (typeof be != "function")
      throw new n("fn", "Function", be);
    try {
      be();
    } catch (xe) {
      return xe;
    }
    return A;
  }
  function Q(be) {
    return v(be) || be !== null && e(be) === "object" && typeof be.then == "function" && typeof be.catch == "function";
  }
  function Z(be) {
    return Promise.resolve().then(function() {
      var xe;
      if (typeof be == "function") {
        if (xe = be(), !Q(xe))
          throw new a("instance of Promise", "promiseFn", xe);
      } else if (Q(be))
        xe = be;
      else
        throw new n("promiseFn", ["Function", "Promise"], be);
      return Promise.resolve().then(function() {
        return xe;
      }).then(function() {
        return A;
      }).catch(function(Ie) {
        return Ie;
      });
    });
  }
  function oe(be, xe, Ie, ve) {
    if (typeof Ie == "string") {
      if (arguments.length === 4)
        throw new n("error", ["Object", "Error", "Function", "RegExp"], Ie);
      if (e(xe) === "object" && xe !== null) {
        if (xe.message === Ie)
          throw new f("error/message", 'The error message "'.concat(xe.message, '" is identical to the message.'));
      } else if (xe === Ie)
        throw new f("error/message", 'The error "'.concat(xe, '" is identical to the message.'));
      ve = Ie, Ie = void 0;
    } else if (Ie != null && e(Ie) !== "object" && typeof Ie != "function")
      throw new n("error", ["Object", "Error", "Function", "RegExp"], Ie);
    if (xe === A) {
      var C = "";
      Ie && Ie.name && (C += " (".concat(Ie.name, ")")), C += ve ? ": ".concat(ve) : ".";
      var I = be.name === "rejects" ? "rejection" : "exception";
      q({
        actual: void 0,
        expected: Ie,
        operator: be.name,
        message: "Missing expected ".concat(I).concat(C),
        stackStartFn: be
      });
    }
    if (Ie && !ae(xe, Ie, ve, be))
      throw xe;
  }
  function y(be, xe, Ie, ve) {
    if (xe !== A) {
      if (typeof Ie == "string" && (ve = Ie, Ie = void 0), !Ie || ae(xe, Ie)) {
        var C = ve ? ": ".concat(ve) : ".", I = be.name === "doesNotReject" ? "rejection" : "exception";
        q({
          actual: xe,
          expected: Ie,
          operator: be.name,
          message: "Got unwanted ".concat(I).concat(C, `
`) + 'Actual message: "'.concat(xe && xe.message, '"'),
          stackStartFn: be
        });
      }
      throw xe;
    }
  }
  z.throws = function be(xe) {
    for (var Ie = arguments.length, ve = new Array(Ie > 1 ? Ie - 1 : 0), C = 1; C < Ie; C++)
      ve[C - 1] = arguments[C];
    oe.apply(void 0, [be, D(xe)].concat(ve));
  }, z.rejects = function be(xe) {
    for (var Ie = arguments.length, ve = new Array(Ie > 1 ? Ie - 1 : 0), C = 1; C < Ie; C++)
      ve[C - 1] = arguments[C];
    return Z(xe).then(function(I) {
      return oe.apply(void 0, [be, I].concat(ve));
    });
  }, z.doesNotThrow = function be(xe) {
    for (var Ie = arguments.length, ve = new Array(Ie > 1 ? Ie - 1 : 0), C = 1; C < Ie; C++)
      ve[C - 1] = arguments[C];
    y.apply(void 0, [be, D(xe)].concat(ve));
  }, z.doesNotReject = function be(xe) {
    for (var Ie = arguments.length, ve = new Array(Ie > 1 ? Ie - 1 : 0), C = 1; C < Ie; C++)
      ve[C - 1] = arguments[C];
    return Z(xe).then(function(I) {
      return y.apply(void 0, [be, I].concat(ve));
    });
  }, z.ifError = function be(xe) {
    if (xe != null) {
      var Ie = "ifError got unwanted exception: ";
      e(xe) === "object" && typeof xe.message == "string" ? xe.message.length === 0 && xe.constructor ? Ie += xe.constructor.name : Ie += xe.message : Ie += m(xe);
      var ve = new i({
        actual: xe,
        expected: null,
        operator: "ifError",
        message: Ie,
        stackStartFn: be
      }), C = xe.stack;
      if (typeof C == "string") {
        var I = C.split(`
`);
        I.shift();
        for (var se = ve.stack.split(`
`), t = 0; t < I.length; t++) {
          var l = se.indexOf(I[t]);
          if (l !== -1) {
            se = se.slice(0, l);
            break;
          }
        }
        ve.stack = "".concat(se.join(`
`), `
`).concat(I.join(`
`));
      }
      throw ve;
    }
  };
  function Y(be, xe, Ie, ve, C) {
    if (!b(xe))
      throw new n("regexp", "RegExp", xe);
    var I = C === "match";
    if (typeof be != "string" || S(xe, be) !== I) {
      if (Ie instanceof Error)
        throw Ie;
      var se = !Ie;
      Ie = Ie || (typeof be != "string" ? 'The "string" argument must be of type string. Received type ' + "".concat(e(be), " (").concat(m(be), ")") : (I ? "The input did not match the regular expression " : "The input was expected to not match the regular expression ") + "".concat(m(xe), `. Input:

`).concat(m(be), `
`));
      var t = new i({
        actual: be,
        expected: xe,
        message: Ie,
        operator: C,
        stackStartFn: ve
      });
      throw t.generatedMessage = se, t;
    }
  }
  z.match = function be(xe, Ie, ve) {
    Y(xe, Ie, ve, be, "match");
  }, z.doesNotMatch = function be(xe, Ie, ve) {
    Y(xe, Ie, ve, be, "doesNotMatch");
  };
  function he() {
    for (var be = arguments.length, xe = new Array(be), Ie = 0; Ie < be; Ie++)
      xe[Ie] = arguments[Ie];
    F.apply(void 0, [he, xe.length].concat(xe));
  }
  return z.strict = h(he, z, {
    equal: z.strictEqual,
    deepEqual: z.deepStrictEqual,
    notEqual: z.notStrictEqual,
    notDeepEqual: z.notDeepStrictEqual
  }), z.strict.strict = z.strict, hc.exports;
}
var P5;
function Yb() {
  if (P5) return sr;
  P5 = 1;
  const e = yh(), c = Hr();
  function d(v, b, h) {
    if (e(k.isBuffer(v)), e(b >>> 0 === b), e(typeof h == "boolean"), b >= v.length)
      throw new Error("Invalid size.");
    const o = v[b], S = o & 127;
    if (b += 1, (o & 128) === 0)
      return [S, b];
    if (h && S === 0)
      throw new Error("Indefinite length.");
    let H = 0;
    for (let j = 0; j < S; j++) {
      e(b < v.length);
      const J = v[b];
      if (b += 1, H >= 1 << 24)
        throw new Error("Length too large.");
      if (H *= 256, H += J, h && H === 0)
        throw new Error("Unexpected leading zeroes.");
    }
    if (h && H < 128)
      throw new Error("Non-minimal length.");
    return [H, b];
  }
  function w(v, b, h = !0) {
    if (e(k.isBuffer(v)), e(b >>> 0 === b), e(typeof h == "boolean"), b >= v.length || v[b] !== 48)
      throw new Error("Invalid sequence tag.");
    b += 1;
    let o;
    if ([o, b] = d(v, b, h), h && b + o !== v.length)
      throw new Error("Trailing bytes.");
    return b;
  }
  function g(v, b, h = !0) {
    if (e(k.isBuffer(v)), e(b >>> 0 === b), e(typeof h == "boolean"), b >= v.length || v[b] !== 2)
      throw new Error("Invalid integer tag.");
    b += 1;
    let o;
    if ([o, b] = d(v, b, h), b + o > v.length)
      throw new Error("Integer body out of bounds.");
    if (h) {
      if (o === 0)
        throw new Error("Zero length integer.");
      if (v[b] & 128)
        throw new Error("Integers must be positive.");
      if (o > 1 && v[b] === 0 && (v[b + 1] & 128) === 0)
        throw new Error("Unexpected leading zeroes.");
    }
    for (; o > 0 && v[b] === 0; )
      b += 1, o -= 1;
    if (o > 2048)
      throw new Error("Invalid integer size.");
    const S = c.decode(v.slice(b, b + o));
    return b += o, [S, b];
  }
  function f(v, b, h, o = !0) {
    e(k.isBuffer(v)), e(b >>> 0 === b), e((h & 255) === h), e(typeof o == "boolean");
    let S;
    if ([S, b] = g(v, b, o), S.cmpn(h) !== 0)
      throw new Error("Invalid version.");
    return b;
  }
  function n(v) {
    return e(v >>> 0 === v), v <= 127 ? 1 : v <= 255 ? 2 : (e(v <= 65535), 3);
  }
  function u(v) {
    return 1 + n(v) + v;
  }
  function a(v) {
    e(v instanceof c);
    const b = v.bitLength();
    let h = b + 7 >>> 3;
    return b > 0 && (b & 7) === 0 && (h += v.testn(b - 1)), b === 0 && (h = 1), 1 + n(h) + h;
  }
  function s(v) {
    return e((v & 255) === v), 3;
  }
  function i(v, b, h) {
    return e(k.isBuffer(v)), e(b >>> 0 === b), e(h >>> 0 === h), h <= 127 ? v[b++] = h : h <= 255 ? (v[b++] = 129, v[b++] = h) : (e(h <= 65535), v[b++] = 130, v[b++] = h >> 8, v[b++] = h & 255), e(b <= v.length), b;
  }
  function p(v, b, h) {
    return e(k.isBuffer(v)), e(b >>> 0 === b), v[b++] = 48, i(v, b, h);
  }
  function m(v, b, h) {
    e(k.isBuffer(v)), e(b >>> 0 === b), e(h instanceof c);
    const o = h.bitLength();
    let S = o + 7 >>> 3, H = 0;
    return o > 0 && (o & 7) === 0 && (H = h.testn(o - 1)), o === 0 && (S = 1), v[b++] = 2, b = i(v, b, H + S), H && (v[b++] = 0), o !== 0 ? h.encode().copy(v, b) : v[b] = 0, b += S, e(b <= v.length), b;
  }
  function E(v, b, h) {
    return e(k.isBuffer(v)), e(b >>> 0 === b), e((h & 255) === h), e(b + 3 <= v.length), v[b++] = 2, v[b++] = 1, v[b++] = h, b;
  }
  return sr.readSize = d, sr.readSeq = w, sr.readInt = g, sr.readVersion = f, sr.sizeSize = n, sr.sizeSeq = u, sr.sizeInt = a, sr.sizeVersion = s, sr.writeSize = i, sr.writeSeq = p, sr.writeInt = m, sr.writeVersion = E, sr;
}
var kc, k5;
function Xb() {
  if (k5) return kc;
  k5 = 1;
  const e = Mt(), c = new Int8Array(new Int16Array([1]).buffer)[0] === 0;
  class d {
    /**
     * Create a ChaCha20 context.
     * @constructor
     */
    constructor() {
      this.state = new Uint32Array(16), this.stream = new Uint32Array(16), this.bytes = new Uint8Array(this.stream.buffer), this.pos = -1, c && (this.bytes = k.alloc(64));
    }
    /**
     * Initialize chacha20 with a key, nonce, and counter.
     * @param {Buffer} key
     * @param {Buffer} nonce
     * @param {Number} counter
     */
    init(a, s, i) {
      if (i == null && (i = 0), e(k.isBuffer(a)), e(k.isBuffer(s)), e(Number.isSafeInteger(i)), a.length !== 16 && a.length !== 32)
        throw new RangeError("Invalid key size.");
      if (s.length >= 24 && (a = d.derive(a, s.slice(0, 16)), s = s.slice(16)), this.state[0] = 1634760805, this.state[1] = a.length < 32 ? 824206446 : 857760878, this.state[2] = a.length < 32 ? 2036477238 : 2036477234, this.state[3] = 1797285236, this.state[4] = f(a, 0), this.state[5] = f(a, 4), this.state[6] = f(a, 8), this.state[7] = f(a, 12), this.state[8] = f(a, 16 % a.length), this.state[9] = f(a, 20 % a.length), this.state[10] = f(a, 24 % a.length), this.state[11] = f(a, 28 % a.length), this.state[12] = i >>> 0, s.length === 8)
        this.state[13] = i / 4294967296 >>> 0, this.state[14] = f(s, 0), this.state[15] = f(s, 4);
      else if (s.length === 12)
        this.state[13] = f(s, 0), this.state[14] = f(s, 4), this.state[15] = f(s, 8);
      else if (s.length === 16)
        this.state[12] = f(s, 0), this.state[13] = f(s, 4), this.state[14] = f(s, 8), this.state[15] = f(s, 12);
      else
        throw new RangeError("Invalid nonce size.");
      return this.pos = 0, this;
    }
    /**
     * Encrypt/decrypt data.
     * @param {Buffer} data - Will be mutated.
     * @returns {Buffer}
     */
    encrypt(a) {
      if (e(k.isBuffer(a)), this.pos === -1)
        throw new Error("Context is not initialized.");
      for (let s = 0; s < a.length; s++)
        (this.pos & 63) === 0 && (this._block(), this.pos = 0), a[s] ^= this.bytes[this.pos++];
      return a;
    }
    /**
     * Stir the stream.
     */
    _block() {
      for (let a = 0; a < 16; a++)
        this.stream[a] = this.state[a];
      for (let a = 0; a < 10; a++)
        w(this.stream, 0, 4, 8, 12), w(this.stream, 1, 5, 9, 13), w(this.stream, 2, 6, 10, 14), w(this.stream, 3, 7, 11, 15), w(this.stream, 0, 5, 10, 15), w(this.stream, 1, 6, 11, 12), w(this.stream, 2, 7, 8, 13), w(this.stream, 3, 4, 9, 14);
      for (let a = 0; a < 16; a++)
        this.stream[a] += this.state[a];
      if (c)
        for (let a = 0; a < 16; a++)
          n(this.bytes, this.stream[a], a * 4);
      this.state[12] += 1, this.state[12] === 0 && (this.state[13] += 1);
    }
    /**
     * Destroy context.
     */
    destroy() {
      for (let a = 0; a < 16; a++)
        this.state[a] = 0, this.stream[a] = 0;
      if (c)
        for (let a = 0; a < 64; a++)
          this.bytes[a] = 0;
      return this.pos = -1, this;
    }
    /**
     * Derive key with XChaCha20.
     * @param {Buffer} key
     * @param {Buffer} nonce
     * @returns {Buffer}
     */
    static derive(a, s) {
      if (e(k.isBuffer(a)), e(k.isBuffer(s)), a.length !== 16 && a.length !== 32)
        throw new RangeError("Invalid key size.");
      if (s.length !== 16)
        throw new RangeError("Invalid nonce size.");
      const i = new Uint32Array(16);
      i[0] = 1634760805, i[1] = a.length < 32 ? 824206446 : 857760878, i[2] = a.length < 32 ? 2036477238 : 2036477234, i[3] = 1797285236, i[4] = f(a, 0), i[5] = f(a, 4), i[6] = f(a, 8), i[7] = f(a, 12), i[8] = f(a, 16 % a.length), i[9] = f(a, 20 % a.length), i[10] = f(a, 24 % a.length), i[11] = f(a, 28 % a.length), i[12] = f(s, 0), i[13] = f(s, 4), i[14] = f(s, 8), i[15] = f(s, 12);
      for (let m = 0; m < 10; m++)
        w(i, 0, 4, 8, 12), w(i, 1, 5, 9, 13), w(i, 2, 6, 10, 14), w(i, 3, 7, 11, 15), w(i, 0, 5, 10, 15), w(i, 1, 6, 11, 12), w(i, 2, 7, 8, 13), w(i, 3, 4, 9, 14);
      const p = k.alloc(32);
      return n(p, i[0], 0), n(p, i[1], 4), n(p, i[2], 8), n(p, i[3], 12), n(p, i[12], 16), n(p, i[13], 20), n(p, i[14], 24), n(p, i[15], 28), p;
    }
  }
  d.native = 0;
  function w(u, a, s, i, p) {
    u[a] += u[s], u[p] = g(u[p] ^ u[a], 16), u[i] += u[p], u[s] = g(u[s] ^ u[i], 12), u[a] += u[s], u[p] = g(u[p] ^ u[a], 8), u[i] += u[p], u[s] = g(u[s] ^ u[i], 7);
  }
  function g(u, a) {
    return u << a | u >>> 32 - a;
  }
  function f(u, a) {
    return u[a++] + u[a++] * 256 + u[a++] * 65536 + u[a] * 16777216;
  }
  function n(u, a, s) {
    return u[s++] = a, a >>>= 8, u[s++] = a, a >>>= 8, u[s++] = a, a >>>= 8, u[s++] = a, s;
  }
  return kc = d, kc;
}
var Bc, B5;
function Xg() {
  if (B5) return Bc;
  B5 = 1;
  const e = Mt(), c = Hr(), d = Xb(), w = wr();
  class g {
    constructor(n, u = (a) => a) {
      this.curve = n, this.encode = u, this.hash = new w(), this.chacha = new d(), this.key = k.alloc(32, 0), this.iv = k.alloc(8, 0), this.cache = [new c(1), new c(1)];
    }
    init(n) {
      e(Array.isArray(n)), this.hash.init();
      for (const [u, a, s] of n)
        this.hash.update(w.digest(u)), this.hash.update(a), this.hash.update(this.encode(s));
      return this.key = this.hash.final(), this.cache[0] = new c(1), this.cache[1] = new c(1), this;
    }
    encrypt(n) {
      const u = this.curve.scalarSize * 2, a = k.alloc(u, 0), s = a.slice(0, this.curve.scalarSize), i = a.slice(this.curve.scalarSize);
      return this.chacha.init(this.key, this.iv, n), this.chacha.encrypt(a), [
        this.curve.decodeScalar(s),
        this.curve.decodeScalar(i)
      ];
    }
    refresh(n) {
      let u = 0;
      for (; ; ) {
        this.iv[4] = u, this.iv[5] = u >>> 8, this.iv[6] = u >>> 16, this.iv[7] = u >>> 24, u += 1;
        const [a, s] = this.encrypt(n);
        if (!(a.isZero() || a.cmp(this.curve.n) >= 0) && !(s.isZero() || s.cmp(this.curve.n) >= 0)) {
          this.cache[0] = a, this.cache[1] = s;
          break;
        }
      }
    }
    generate(n) {
      return e(n >>> 0 === n), n & 1 && this.refresh(n >>> 1), this.cache[n & 1];
    }
  }
  return Bc = g, Bc;
}
var Mc, M5;
function Jg() {
  if (M5) return Mc;
  M5 = 1;
  const e = Mt(), c = Xg(), d = Hr();
  class w {
    constructor(f, n) {
      this.curve = f, this.hash = n, this.rng = new c(this.curve, this.encode.bind(this));
    }
    check() {
      if (this.curve.p.andln(3) !== 3)
        throw new Error(`Schnorr is not supported for ${this.curve.id}.`);
    }
    encode(f) {
      e(k.isBuffer(f));
      const { fieldSize: n } = this.curve;
      if (f.length === 1 + n)
        return f;
      if (f.length !== 1 + n * 2)
        throw new Error("Invalid point.");
      const u = k.alloc(1 + n);
      return u[0] = 2 | f[f.length - 1] & 1, f.copy(u, 1, 1, 1 + n), u;
    }
    hashInt(...f) {
      const n = new this.hash();
      n.init();
      for (const s of f)
        n.update(s);
      let u = n.final(this.curve.scalarSize);
      u.length > this.curve.scalarSize && (u = u.slice(0, this.curve.scalarSize));
      const a = d.decode(u, this.curve.endian);
      return a.iumaskn(this.curve.scalarBits), a.imod(this.curve.n);
    }
    hashNonce(f, n) {
      return this.hashInt(f, n);
    }
    hashChallenge(f, n, u) {
      return this.hashInt(f, this.encode(n), u);
    }
    sign(f, n) {
      return e(k.isBuffer(f)), this.check(), this._sign(f, n);
    }
    _sign(f, n) {
      const { n: u } = this.curve, a = this.curve.g, s = this.curve.decodeScalar(n);
      if (s.isZero() || s.cmp(u) >= 0)
        throw new Error("Invalid private key.");
      const i = a.mulBlind(s), p = this.hashNonce(n, f);
      if (p.isZero())
        throw new Error("Signing failed (k' = 0).");
      const m = a.mulBlind(p);
      m.isSquare() || p.ineg().imod(u);
      const E = m.encodeX(), v = i.encode(), b = this.hashChallenge(E, v, f), h = p.add(b.mul(s)).imod(u);
      return k.concat([E, this.curve.encodeScalar(h)]);
    }
    verify(f, n, u) {
      if (e(k.isBuffer(f)), e(k.isBuffer(n)), e(k.isBuffer(u)), this.check(), n.length !== this.curve.fieldSize + this.curve.scalarSize)
        return !1;
      try {
        return this._verify(f, n, u);
      } catch {
        return !1;
      }
    }
    _verify(f, n, u) {
      const { p: a, n: s } = this.curve, i = this.curve.g, p = n.slice(0, this.curve.fieldSize), m = n.slice(this.curve.fieldSize), E = this.curve.decodeField(p), v = this.curve.decodeScalar(m), b = this.curve.decodePoint(u);
      if (E.cmp(a) >= 0 || v.cmp(s) >= 0)
        return !1;
      const h = this.hashChallenge(p, u, f), o = i.jmulAdd(v, b, h.ineg().imod(s));
      return !(!o.isSquare() || !o.eqX(E));
    }
    verifyBatch(f) {
      e(Array.isArray(f)), this.check();
      for (const n of f) {
        e(Array.isArray(n) && n.length === 3);
        const [u, a, s] = n;
        if (e(k.isBuffer(u)), e(k.isBuffer(a)), e(k.isBuffer(s)), a.length !== this.curve.fieldSize + this.curve.scalarSize)
          return !1;
      }
      try {
        return this._verifyBatch(f);
      } catch {
        return !1;
      }
    }
    _verifyBatch(f) {
      const { n } = this.curve, u = this.curve.g, a = new Array(1 + f.length * 2), s = new Array(1 + f.length * 2), i = new d(0);
      this.rng.init(f), a[0] = u, s[0] = i;
      for (let p = 0; p < f.length; p++) {
        const [m, E, v] = f[p], b = E.slice(0, this.curve.fieldSize), h = E.slice(this.curve.fieldSize), o = this.curve.decodeSquare(b), S = this.curve.decodeScalar(h), H = this.curve.decodePoint(v);
        if (S.cmp(n) >= 0)
          return !1;
        const j = this.hashChallenge(b, v, m), J = this.rng.generate(p), N = j.mul(J).imod(n);
        i.iadd(S.mul(J)).imod(n), a[1 + p * 2 + 0] = o, s[1 + p * 2 + 0] = J, a[1 + p * 2 + 1] = H, s[1 + p * 2 + 1] = N;
      }
      return i.ineg().imod(n), this.curve.jmulAll(a, s).isInfinity();
    }
  }
  return Mc = w, Mc;
}
var Nc, N5;
function Jb() {
  if (N5) return Nc;
  N5 = 1;
  const e = Mt(), c = 281474976710656, d = k.from([0]), w = k.from([1]);
  class g {
    constructor(n, u, a, s) {
      e(n && typeof n.id == "string"), this.hash = n, this.minEntropy = n.id === "SHA1" ? 10 : 24, this.K = k.alloc(n.size), this.V = k.alloc(n.size), this.rounds = 0, u && this.init(u, a, s);
    }
    init(n, u, a) {
      u == null && (u = k.alloc(0)), a == null && (a = k.alloc(0)), e(k.isBuffer(n)), e(k.isBuffer(u)), e(k.isBuffer(a));
      for (let i = 0; i < this.V.length; i++)
        this.K[i] = 0, this.V[i] = 1;
      const s = k.concat([n, u, a]);
      if (s.length < this.minEntropy)
        throw new Error("Not enough entropy.");
      return this.update(s), this.rounds = 1, this;
    }
    reseed(n, u) {
      if (u == null && (u = k.alloc(0)), e(k.isBuffer(n)), e(k.isBuffer(u)), this.rounds === 0)
        throw new Error("DRBG not initialized.");
      const a = k.concat([n, u]);
      if (a.length < this.minEntropy)
        throw new Error("Not enough entropy.");
      return this.update(a), this.rounds = 1, this;
    }
    generate(n, u) {
      if (e(n >>> 0 === n), e(u == null || k.isBuffer(u)), this.rounds === 0)
        throw new Error("DRBG not initialized.");
      if (this.rounds > c)
        throw new Error("Reseed is required.");
      u && u.length > 0 && this.update(u);
      const a = Math.ceil(n / this.hash.size), s = k.alloc(a * this.hash.size);
      for (let i = 0; i < a; i++)
        this.V = this.mac(this.V), this.V.copy(s, i * this.hash.size);
      return this.update(u), this.rounds += 1, s.slice(0, n);
    }
    randomBytes(n) {
      return this.generate(n);
    }
    /*
     * Helpers
     */
    mac(n) {
      return this.hash.mac(n, this.K);
    }
    hmac() {
      return this.hash.hmac().init(this.K);
    }
    update(n) {
      e(n == null || k.isBuffer(n));
      const u = this.hmac();
      if (u.update(this.V), u.update(d), n && u.update(n), this.K = u.final(), this.V = this.mac(this.V), n && n.length > 0) {
        const a = this.hmac();
        a.update(this.V), a.update(w), a.update(n), this.K = a.final(), this.V = this.mac(this.V);
      }
      return this;
    }
  }
  return g.native = 0, Nc = g, Nc;
}
var er = {}, q5;
function Gg() {
  if (q5) return er;
  q5 = 1;
  const { custom: e } = Ub(), c = Hr(), d = {
    AFFINE: 0,
    JACOBIAN: 1,
    PROJECTIVE: 2,
    EXTENDED: 3
  }, w = [
    -3,
    // -1 -1
    -1,
    // -1 0
    -5,
    // -1 1
    -7,
    // 0 -1
    0,
    // 0 0
    7,
    // 0 1
    5,
    // 1 -1
    1,
    // 1 0
    3
    // 1 1
  ];
  let g = 0;
  class f {
    constructor(r, x, O) {
      this.Point = null, this.id = null, this.uid = g++, this.ossl = null, this.type = "base", this.endian = "be", this.hash = null, this.prefix = null, this.context = !1, this.prime = null, this.p = null, this.red = null, this.fieldSize = 0, this.fieldBits = 0, this.adjustedSize = 0, this.signBit = 0, this.mask = 0, this.n = null, this.h = null, this.q = null, this.z = null, this.g = null, this.nh = null, this.scalarSize = 0, this.scalarBits = 0, this.zero = null, this.one = null, this.two = null, this.three = null, this.four = null, this.i2 = null, this.i3 = null, this.i4 = null, this.i6 = null, this.torsion = null, this.endo = null, this.hi = null, this._init(r, x, O);
    }
    _init(r, x, O) {
      I(typeof r == "function"), I(typeof x == "string"), I(O && typeof O == "object"), I(O.red == null || O.red instanceof c.Red), I(O.p != null, "Must pass a prime."), I(O.id == null || typeof O.id == "string"), I(O.ossl == null || typeof O.ossl == "string"), I(O.endian == null || typeof O.endian == "string"), I(O.hash == null || typeof O.hash == "string"), I(O.prefix == null || typeof O.prefix == "string"), I(O.context == null || typeof O.context == "boolean"), I(O.prime == null || typeof O.prime == "string"), I(O.torsion == null || Array.isArray(O.torsion)), this.Point = r, this.id = O.id || null, this.ossl = O.ossl || null, this.type = x, this.endian = O.endian || (x === "short" ? "be" : "le"), this.hash = O.hash || null, this.prefix = O.prefix ? k.from(O.prefix, "binary") : null, this.context = O.context || !1, this.prime = O.prime || null, this.p = c.fromJSON(O.p), O.red ? this.red = O.red : (this.red = O.prime ? c.red(O.prime) : c.mont(this.p), this.red.precompute()), this.fieldSize = this.p.byteLength(), this.fieldBits = this.p.bitLength(), this.adjustedSize = this.fieldSize + ((this.fieldBits & 7) === 0), this.signBit = this.adjustedSize * 8 - 1, this.mask = 255, (this.fieldBits & 7) !== 0 && (this.mask = (1 << (this.fieldBits & 7)) - 1), this.n = c.fromJSON(O.n || "0"), this.h = c.fromJSON(O.h || "1"), this.q = this.n.mul(this.h), this.z = c.fromJSON(O.z || "0").toRed(this.red), this.g = null, this.nh = this.n.ushrn(1), this.scalarSize = this.n.byteLength(), this.scalarBits = this.n.bitLength(), this.zero = new c(0).toRed(this.red), this.one = new c(1).toRed(this.red), this.two = new c(2).toRed(this.red), this.three = new c(3).toRed(this.red), this.four = new c(4).toRed(this.red), this.i2 = this.two.redInvert(), this.i3 = this.three.redInvert(), this.i4 = this.i2.redSqr(), this.i6 = this.i2.redMul(this.i3), this.torsion = new Array(this.h.word(0));
      for (let L = 0; L < this.torsion.length; L++)
        this.torsion[L] = this.point();
      return this.endo = null, this.hi = null, this._scale = T(this._scale, this), this.isIsomorphic = T(this.isIsomorphic, this), this.isIsogenous = T(this.isIsogenous, this), I(this.p.sign() > 0 && this.p.isOdd()), I(this.n.sign() >= 0), I(this.h.sign() > 0 && this.h.cmpn(255) <= 0), I(this.endian === "be" || this.endian === "le"), this;
    }
    _finalize(r) {
      if (I(r && typeof r == "object"), this.g = r.g ? this.pointFromJSON(r.g) : this.point(), r.torsion) {
        I(r.torsion.length === this.torsion.length);
        for (let x = 0; x < this.torsion.length; x++)
          this.torsion[x] = this.pointFromJSON(r.torsion[x]);
      }
      return this;
    }
    _findTorsion() {
      I(!this.n.isZero());
      const r = this.h.word(0), x = this.one.redNeg(), O = [this.point()], L = /* @__PURE__ */ new Set();
      let X = r;
      for (; O.length < X; ) {
        let P;
        x.redIAdd(this.one);
        try {
          P = this.pointFromX(x.clone());
        } catch {
          continue;
        }
        try {
          P = P.mul(this.n);
        } catch {
          X = 2;
          continue;
        }
        if (!P.isInfinity()) {
          P.normalize();
          for (const K of [P, P.neg()]) {
            const re = K.key();
            L.has(re) || (O.push(K), L.add(re));
          }
        }
      }
      for (O.sort((P, K) => P.cmp(K)); O.length < r; )
        O.push(this.point());
      return O;
    }
    _fixedMul(r, x) {
      I(r instanceof n), I(x instanceof c), I(r.pre && r.pre.windows);
      const { width: O, points: L } = r._getWindows(0, 0), X = 1 << O, K = (x.bitLength() + O - 1) / O >>> 0;
      let re = this.jpoint();
      for (let ce = 0; ce < K; ce++) {
        const le = x.bits(ce * O, O);
        re = re.add(L[ce * X + le]);
      }
      return x.isNeg() && (re = re.neg()), re;
    }
    _fixedNafMul(r, x) {
      I(r instanceof n), I(x instanceof c), I(r.pre && r.pre.doubles);
      const { step: O, points: L } = r._getDoubles(0, 0), X = Ie(x, 2, x.bitLength() + 1, O), P = ((1 << O + 1) - (O % 2 === 0 ? 2 : 1)) / 3;
      let K = this.jpoint(), re = this.jpoint();
      for (let ce = P; ce > 0; ce--) {
        for (let le = 0; le < X.length; le++) {
          const me = X[le];
          me === ce ? re = re.add(L[le]) : me === -ce && (re = re.sub(L[le]));
        }
        K = K.add(re);
      }
      return K;
    }
    _wnafMul(r, x, O) {
      I(x instanceof n), I(O instanceof c);
      const { width: L, points: X } = x._safeNAF(r), P = xe(O, L, O.bitLength() + 1);
      let K = this.jpoint();
      for (let re = P.length - 1; re >= 0; re--) {
        const ce = P[re];
        re !== P.length - 1 && (K = K.dbl()), ce > 0 ? K = K.add(X[ce - 1 >> 1]) : ce < 0 && (K = K.sub(X[-ce - 1 >> 1]));
      }
      return K;
    }
    _wnafMulAdd(r, x, O) {
      I(r >>> 0 === r), I(Array.isArray(x)), I(Array.isArray(O)), I(x.length === O.length);
      const L = x.length, X = new Array(L), P = new Array(L);
      let K = 0;
      for (let ne = 0; ne < L; ne++) {
        const W = x[ne], te = O[ne];
        if (I(W instanceof n), I(te instanceof c), ne > 0 && W.type !== x[ne - 1].type)
          throw new Error("Cannot mix points.");
        X[ne] = null, P[ne] = null, K = Math.max(K, te.bitLength() + 1);
      }
      let re = null, ce = null, le = 0;
      for (let ne = 0; ne < L; ne++) {
        const W = x[ne], te = O[ne], pe = W._getNAF(0);
        if (pe) {
          X[le] = pe.points, P[le] = xe(te, pe.width, K), le += 1;
          continue;
        }
        if (!re) {
          re = W, ce = te;
          continue;
        }
        X[le] = re._getJNAF(W), P[le] = C(ce, te, K), re = null, ce = null, le += 1;
      }
      if (re) {
        const ne = re._safeNAF(r);
        X[le] = ne.points, P[le] = xe(ce, ne.width, K), le += 1;
      }
      let me = this.jpoint();
      for (let ne = K - 1; ne >= 0; ne--) {
        ne !== K - 1 && (me = me.dbl());
        for (let W = 0; W < le; W++) {
          const te = P[W][ne];
          te > 0 ? me = me.add(X[W][te - 1 >> 1]) : te < 0 && (me = me.sub(X[W][-te - 1 >> 1]));
        }
      }
      return me;
    }
    _endoWnafMulAdd(r, x) {
      throw new Error("Not implemented.");
    }
    _scale(r, x) {
      switch (I(r instanceof f), I(r.p.eq(this.p)), r.type) {
        case "short":
          return this._scaleShort(r, x);
        case "mont":
          return this._scaleMont(r, x);
        case "edwards":
          return this._scaleEdwards(r, x);
        default:
          throw new Error("Not implemented.");
      }
    }
    _scaleShort(r, x) {
      throw new Error("Not implemented.");
    }
    _scaleMont(r, x) {
      throw new Error("Not implemented.");
    }
    _scaleEdwards(r, x) {
      throw new Error("Not implemented.");
    }
    isElliptic() {
      throw new Error("Not implemented.");
    }
    jinv() {
      throw new Error("Not implemented.");
    }
    isComplete() {
      return !1;
    }
    precompute(r) {
      return I(!this.g.isInfinity(), "Must have base point."), I(!this.n.isZero(), "Must have order."), this.g.precompute(this.n.bitLength(), r), this;
    }
    scalar(r, x, O) {
      const L = new c(r, x, O);
      return I(!L.red), this.n.isZero() ? L : L.imod(this.n);
    }
    field(r, x, O) {
      const L = c.cast(r, x, O);
      return L.red ? L.forceRed(this.red) : L.toRed(this.red);
    }
    point(r, x) {
      throw new Error("Not implemented.");
    }
    jpoint(r, x, O) {
      throw new Error("Not implemented.");
    }
    xpoint(r, x) {
      throw new Error("Not implemented.");
    }
    cpoint(r, x, O, L) {
      if (I(r instanceof c), I(x instanceof c), I(O instanceof c), I(L instanceof c), x.isZero() || L.isZero())
        return this.point();
      const X = x.redMul(L).redInvert(), P = r.redMul(L).redMul(X), K = O.redMul(x).redMul(X);
      return this.point(P, K);
    }
    solveX2(r) {
      throw new Error("Not implemented.");
    }
    solveX(r) {
      return this.solveX2(r).redSqrt();
    }
    solveY2(r) {
      throw new Error("Not implemented.");
    }
    solveY(r) {
      return this.solveY2(r).redSqrt();
    }
    validate(r) {
      throw new Error("Not implemented.");
    }
    pointFromX(r, x) {
      throw new Error("Not implemented.");
    }
    pointFromY(r, x) {
      throw new Error("Not implemented.");
    }
    isIsomorphic(r) {
      throw new Error("Not implemented.");
    }
    isIsogenous(r) {
      throw new Error("Not implemented.");
    }
    pointFromShort(r) {
      throw new Error("Not implemented.");
    }
    pointFromMont(r, x) {
      throw new Error("Not implemented.");
    }
    pointFromEdwards(r) {
      throw new Error("Not implemented.");
    }
    pointFromUniform(r) {
      throw new Error("Not implemented.");
    }
    pointToUniform(r) {
      throw new Error("Not implemented.");
    }
    pointFromHash(r, x = !1) {
      if (I(k.isBuffer(r)), I(typeof x == "boolean"), r.length !== this.fieldSize * 2)
        throw new Error("Invalid hash size.");
      const O = r.slice(0, this.fieldSize), L = r.slice(this.fieldSize), X = this.decodeUniform(O), P = this.decodeUniform(L), K = this.pointFromUniform(X), re = this.pointFromUniform(P), ce = K.add(re);
      return x ? ce.mulH() : ce;
    }
    pointToHash(r, x, O) {
      I(r instanceof this.Point), I(x >>> 0 === x);
      const L = x % this.torsion.length, X = r.add(this.torsion[L]);
      for (; ; ) {
        const P = this.randomField(O), K = this.pointFromUniform(P);
        if (K.neg().eq(K))
          continue;
        const re = X.sub(K), ce = G(O);
        let le;
        try {
          le = this.pointToUniform(re, ce & 15);
        } catch (W) {
          if (W.message === "Invalid point.")
            continue;
          throw W;
        }
        const me = this.encodeUniform(P, ce >>> 8), ne = this.encodeUniform(le, ce >>> 16);
        return k.concat([me, ne]);
      }
    }
    randomScalar(r) {
      const x = this.n.isZero() ? this.p : this.n;
      return c.random(r, 1, x);
    }
    randomField(r) {
      return c.random(r, 1, this.p).toRed(this.red);
    }
    randomPoint(r) {
      let x;
      for (; ; ) {
        const O = this.randomField(r), L = (G(r) & 1) !== 0;
        try {
          x = this.pointFromX(O, L);
        } catch {
          continue;
        }
        return I(x.validate()), x.mulH();
      }
    }
    mulAll(r, x) {
      return this.jmulAll(r, x);
    }
    jmulAll(r, x) {
      return I(Array.isArray(r)), I(r.length === 0 || r[0] instanceof n), this.endo && r.length > 0 && r[0].type === d.AFFINE ? this._endoWnafMulAdd(r, x) : this._wnafMulAdd(5, r, x);
    }
    mulH(r) {
      return I(r instanceof c), this.imulH(r.clone());
    }
    imulH(r) {
      I(r instanceof c), I(!r.red);
      const x = this.h.word(0);
      if ((x & x - 1) === 0) {
        const O = this.h.bitLength();
        return r.iushln(O - 1).imod(this.n);
      }
      return r.imuln(x).imod(this.n);
    }
    normalizeAll(r) {
      I(Array.isArray(r));
      const x = r.length, O = new Array(x);
      for (let P = 0; P < x; P++) {
        const K = r[P];
        if (I(K instanceof n), I(K.curve === this), K.type === d.AFFINE) {
          O[P] = this.one;
          continue;
        }
        O[P] = K.z;
      }
      const L = this.red.invertAll(O), X = new Array(x);
      for (let P = 0; P < x; P++)
        X[P] = r[P].scale(L[P]);
      return X;
    }
    affinizeAll(r) {
      return this.normalizeAll(r);
    }
    clamp(r) {
      I(k.isBuffer(r)), I(r.length === this.scalarSize), I(this.scalarSize <= this.fieldSize);
      let x = this.fieldBits & 7 || 8, O = 0, L = this.scalarSize - 1;
      return this.endian === "be" && ([O, L] = [L, O]), this.scalarSize < this.fieldSize && (x = 8), r[O] &= -this.h.word(0) & 255, r[L] &= (1 << x) - 1, r[L] |= 1 << x - 1, r;
    }
    splitHash(r) {
      I(k.isBuffer(r)), I(r.length === this.adjustedSize * 2), I(this.scalarSize <= this.adjustedSize);
      let x = 0;
      this.endian === "be" && (x = this.adjustedSize - this.scalarSize);
      const O = r.slice(x, x + this.scalarSize), L = r.slice(this.adjustedSize);
      return this.clamp(O), [O, L];
    }
    encodeField(r) {
      return I(r instanceof c), I(!r.red), r.encode(this.endian, this.fieldSize);
    }
    decodeField(r) {
      if (I(k.isBuffer(r)), r.length !== this.fieldSize)
        throw new Error("Invalid field element size.");
      return c.decode(r, this.endian);
    }
    encodeAdjusted(r) {
      return I(r instanceof c), I(!r.red), r.encode(this.endian, this.adjustedSize);
    }
    decodeAdjusted(r) {
      if (I(k.isBuffer(r)), r.length !== this.adjustedSize)
        throw new Error("Invalid field element size.");
      return c.decode(r, this.endian);
    }
    encodeScalar(r) {
      return I(r instanceof c), I(!r.red), r.encode(this.endian, this.scalarSize);
    }
    decodeScalar(r) {
      if (I(k.isBuffer(r)), r.length !== this.scalarSize)
        throw new Error("Invalid scalar size.");
      return c.decode(r, this.endian);
    }
    encodeClamped(r) {
      return this.clamp(this.encodeScalar(r));
    }
    decodeClamped(r) {
      if (I(k.isBuffer(r)), r.length !== this.scalarSize)
        throw new Error("Invalid scalar size.");
      const x = this.clamp(k.from(r));
      return c.decode(x, this.endian);
    }
    encodeUniform(r, x) {
      I(r instanceof c), I(x >>> 0 === x);
      const O = this.endian === "le" ? this.fieldSize - 1 : 0, L = r.fromRed().encode(this.endian, this.fieldSize);
      return L[O] |= x & ~this.mask & 255, L;
    }
    decodeUniform(r) {
      if (I(k.isBuffer(r)), r.length !== this.fieldSize)
        throw new Error("Invalid field size.");
      const x = c.decode(r, this.endian);
      return x.iumaskn(this.fieldBits), x.toRed(this.red);
    }
    encodePoint(r, x) {
      return I(r instanceof n), r.encode(x);
    }
    decodePoint(r) {
      throw new Error("Not implemented.");
    }
    encodeX(r) {
      throw new Error("Not implemented.");
    }
    decodeX(r) {
      throw new Error("Not implemented.");
    }
    decodeEven(r) {
      throw new Error("Not implemented.");
    }
    decodeSquare(r) {
      throw new Error("Not implemented.");
    }
    toShort() {
      throw new Error("Not implemented.");
    }
    toMont(r) {
      throw new Error("Not implemented.");
    }
    toEdwards(r) {
      throw new Error("Not implemented.");
    }
    pointToJSON(r, x) {
      return I(r instanceof n), r.toJSON(x);
    }
    pointFromJSON(r) {
      throw new Error("Not implemented.");
    }
    toJSON(r) {
      let x, O, L, X, P;
      return this.type === "edwards" && (x = this.prefix ? this.prefix.toString() : null, O = this.context), this.n.isZero() || (L = this.n.toJSON()), this.z.isZero() || (X = this.z.fromRed(), this.z.redIsHigh() && X.isub(this.p), X = X.toString(16)), this.endo && (P = this.endo.toJSON()), {
        id: this.id,
        ossl: this.ossl,
        type: this.type,
        endian: this.endian,
        hash: this.hash,
        prefix: x,
        context: O,
        prime: this.prime,
        p: this.p.toJSON(),
        a: void 0,
        b: void 0,
        d: void 0,
        n: L,
        h: this.h.toString(16),
        s: void 0,
        z: X,
        c: void 0,
        g: this.g.toJSON(r),
        endo: P
      };
    }
    static fromJSON(r) {
      return new this(r);
    }
  }
  class n {
    constructor(r, x) {
      I(r instanceof f), I(x >>> 0 === x), this.curve = r, this.type = x, this.pre = null;
    }
    _init() {
      throw new Error("Not implemented.");
    }
    _safeNAF(r) {
      if (I(r >>> 0 === r), this.pre && this.pre.naf)
        return this.pre.naf;
      if (r === 0)
        return null;
      const x = 1 << r - 2, O = new Array(x), L = this.toJ(), X = x === 1 ? null : L.dbl();
      O[0] = L;
      for (let P = 1; P < x; P++)
        O[P] = O[P - 1].add(X);
      return new h(r, O);
    }
    _getNAF(r) {
      if (I(r >>> 0 === r), this.pre && this.pre.naf)
        return this.pre.naf;
      if (r === 0)
        return null;
      const x = this._safeNAF(r).points, O = this.curve.affinizeAll(x);
      return new h(r, O);
    }
    _getWindows(r, x) {
      if (I(r >>> 0 === r), I(x >>> 0 === x), this.pre && this.pre.windows)
        return this.pre.windows;
      if (r === 0)
        return null;
      const O = 1 << r, L = (x + r - 1) / r >>> 0, X = new Array(L * O);
      let P = this.toJ();
      for (let re = 0; re < L; re++) {
        X[re * O] = this.curve.jpoint();
        for (let ce = 1; ce < O; ce++)
          X[re * O + ce] = X[re * O + ce - 1].add(P);
        P = P.dblp(r);
      }
      const K = this.curve.affinizeAll(X);
      return new o(r, x, K);
    }
    _getDoubles(r, x) {
      if (I(r >>> 0 === r), I(x >>> 0 === x), this.pre && this.pre.doubles)
        return this.pre.doubles;
      if (r === 0)
        return null;
      const O = Math.ceil(x / r) + 1, L = new Array(O);
      let X = this.toJ(), P = 0;
      L[P++] = X;
      for (let re = 0; re < x; re += r) {
        for (let ce = 0; ce < r; ce++)
          X = X.dbl();
        L[P++] = X;
      }
      I(P === O);
      const K = this.curve.affinizeAll(L);
      return new S(r, K);
    }
    _getBeta() {
      return null;
    }
    _getBlinding(r) {
      if (this.pre && this.pre.blinding)
        return this.pre.blinding;
      if (!r || this.curve.n.isZero())
        return null;
      const x = this.curve.randomScalar(r), O = this.mul(x);
      return new H(x, O);
    }
    _hasWindows(r) {
      if (I(r instanceof c), !this.pre || !this.pre.windows)
        return !1;
      const { width: x, bits: O } = this.pre.windows, L = (O + x - 1) / x >>> 0;
      return r.bitLength() <= L * x;
    }
    _hasDoubles(r) {
      if (I(r instanceof c), !this.pre || !this.pre.doubles)
        return !1;
      const { step: x, points: O } = this.pre.doubles, L = r.bitLength() + 1;
      return O.length >= Math.ceil(L / x) + 1;
    }
    _getJNAF(r) {
      return I(r instanceof n), I(r.type === this.type), [
        this,
        // 1
        this.add(r),
        // 3
        this.sub(r),
        // 5
        r
        // 7
      ];
    }
    _blind(r, x) {
      if (I(r instanceof c), I(!r.red), this.pre && this.pre.blinding) {
        const { blind: L, unblind: X } = this.pre.blinding, P = r.sub(L);
        return [this, P, X];
      }
      if (!x)
        return [this, r, null];
      if (this.pre) {
        if (this.curve.n.isZero())
          return [this, r, null];
        const P = this.curve.randomScalar(x).mul(this.curve.n).iadd(r);
        return [this, P, null];
      }
      return [this.randomize(x), r, null];
    }
    clone() {
      throw new Error("Not implemented.");
    }
    precompute(r, x) {
      return I(r >>> 0 === r), this.pre || (this.pre = new b()), this.pre.naf || (this.pre.naf = this._getNAF(9)), this.pre.doubles || (this.pre.doubles = this._getDoubles(4, r + 1)), this.pre.beta || (this.pre.beta = this._getBeta()), this.pre.blinding || (this.pre.blinding = this._getBlinding(x)), this;
    }
    validate() {
      return this.curve.validate(this);
    }
    normalize() {
      return this;
    }
    scale(r) {
      throw new Error("Not implemented.");
    }
    randomize(r) {
      const x = this.curve.randomField(r);
      return this.scale(x);
    }
    neg() {
      throw new Error("Not implemented.");
    }
    add(r) {
      throw new Error("Not implemented.");
    }
    sub(r) {
      return I(r instanceof n), this.add(r.neg());
    }
    dbl() {
      throw new Error("Not implemented.");
    }
    dblp(r) {
      I(r >>> 0 === r);
      let x = this;
      for (let O = 0; O < r; O++)
        x = x.dbl();
      return x;
    }
    diffAddDbl(r, x) {
      throw new Error("Not implemented.");
    }
    getX() {
      throw new Error("Not implemented.");
    }
    getY() {
      throw new Error("Not implemented.");
    }
    eq(r) {
      throw new Error("Not implemented.");
    }
    cmp(r) {
      throw new Error("Not implemented.");
    }
    isInfinity() {
      throw new Error("Not implemented.");
    }
    isOrder2() {
      throw new Error("Not implemented.");
    }
    isOdd() {
      throw new Error("Not implemented.");
    }
    isEven() {
      throw new Error("Not implemented.");
    }
    isSquare() {
      throw new Error("Not implemented.");
    }
    eqX(r) {
      throw new Error("Not implemented.");
    }
    eqR(r) {
      throw new Error("Not implemented.");
    }
    isSmall() {
      return this.isInfinity() ? !1 : this.jmulH().isInfinity();
    }
    hasTorsion() {
      return this.isInfinity() ? !1 : !this.jmul(this.curve.n).isInfinity();
    }
    order() {
      const { h: r, n: x } = this.curve;
      let O = this.toJ(), L = new c(1);
      for (; !O.isInfinity(); ) {
        if (L.iaddn(1), L.cmp(r) > 0) {
          L = x.clone();
          break;
        }
        O = O.add(this);
      }
      return L;
    }
    mul(r) {
      return this.jmul(r);
    }
    muln(r) {
      return this.jmuln(r);
    }
    mulBlind(r, x) {
      return this.jmulBlind(r, x);
    }
    mulAdd(r, x, O) {
      return this.jmulAdd(r, x, O);
    }
    mulH() {
      return this.jmulH();
    }
    div(r) {
      return this.jdiv(r);
    }
    divn(r) {
      return this.jdivn(r);
    }
    divH() {
      return this.jdivH();
    }
    jmul(r) {
      return this._hasDoubles(r) ? this.curve._fixedNafMul(this, r) : this.curve.endo && this.type === d.AFFINE ? this.curve._endoWnafMulAdd([this], [r]) : this.curve._wnafMul(5, this, r);
    }
    jmuln(r) {
      return I((r | 0) === r), this.jmul(new c(r));
    }
    jmulBlind(r, x = null) {
      const [O, L, X] = this._blind(r, x), P = O.jmul(L);
      return X ? P.add(X) : P;
    }
    jmulAdd(r, x, O) {
      return this.curve.endo && this.type === d.AFFINE ? this.curve._endoWnafMulAdd([this, x], [r, O]) : this.curve._wnafMulAdd(5, [this, x], [r, O]);
    }
    jmulH() {
      const r = this.curve.h.word(0);
      if ((r & r - 1) === 0) {
        const x = this.curve.h.bitLength();
        return this.toJ().dblp(x - 1);
      }
      return this.jmul(this.curve.h);
    }
    jdiv(r) {
      return I(r instanceof c), I(!r.red), this.jmul(r.invert(this.curve.n));
    }
    jdivn(r) {
      return I(!this.curve.n.isZero()), this.curve.h.cmpn(r) === 0 ? this.jdivH() : this.jdiv(new c(r));
    }
    jdivH() {
      return this.curve.n.isZero() ? this.toJ() : this.curve.h.cmpn(1) === 0 ? this.toJ() : (this.curve.hi === null && (this.curve.hi = this.curve.h.invert(this.curve.n)), this.jmul(this.curve.hi));
    }
    toP() {
      return this.normalize();
    }
    toJ() {
      return this;
    }
    toX() {
      return this;
    }
    key() {
      if (this.isInfinity())
        return `${this.curve.uid}:oo`;
      this.normalize();
      const r = this.getX().toString(16), x = this.getY().toString(16);
      return `${this.curve.uid}:${r},${x}`;
    }
    encode(r) {
      throw new Error("Not implemented.");
    }
    static decode(r, x) {
      throw new Error("Not implemented.");
    }
    encodeX() {
      throw new Error("Not implemented.");
    }
    static decodeX(r, x) {
      throw new Error("Not implemented.");
    }
    static decodeEven(r, x) {
      throw new Error("Not implemented.");
    }
    static decodeSquare(r, x) {
      throw new Error("Not implemented.");
    }
    toJSON(r) {
      throw new Error("Not implemented.");
    }
    static fromJSON(r, x) {
      throw new Error("Not implemented.");
    }
    [e]() {
      return "<Point>";
    }
  }
  class u extends f {
    constructor(r) {
      super(a, "short", r), this.a = c.fromJSON(r.a).toRed(this.red), this.b = c.fromJSON(r.b).toRed(this.red), this.c = c.fromJSON(r.c || "0").toRed(this.red), this.ai = this.a.isZero() ? this.zero : this.a.redInvert(), this.zi = this.z.isZero() ? this.zero : this.z.redInvert(), this.zeroA = this.a.isZero(), this.threeA = this.a.eq(this.three.redNeg()), this.redN = this.n.toRed(this.red), this.pmodn = this.p.clone(), this.highOrder = this.n.cmp(this.p) >= 0, this.smallGap = !1, this._finalize(r);
    }
    _finalize(r) {
      return super._finalize(r), r.endo != null ? this.endo = j.fromJSON(this, r.endo) : this.endo = this._getEndomorphism(), this.n.isZero() || (this.pmodn = this.p.mod(this.n), this.smallGap = this.p.div(this.n).cmpn(1) <= 0), this;
    }
    static _isomorphism(r, x, O, L) {
      if (I(r instanceof c), I(x instanceof c), I(O instanceof c), I(L == null || typeof L == "boolean"), I(!r.isZero() || !x.isZero()), O.isZero())
        throw new Error("Invalid coefficient.");
      if (r.isZero()) {
        const me = O, ne = me.redDiv(x), W = U(ne);
        return I(W.redJacobi() === 1), [r.clone(), me.clone()];
      }
      if (x.isZero()) {
        const me = O, W = me.redDiv(r).redSqrt();
        if (W.redJacobi() !== 1 && W.redINeg(), W.redJacobi() !== 1)
          throw new Error("Invalid `a` coefficient.");
        return [me.clone(), x.clone()];
      }
      const X = O, P = X.redDiv(r), K = P.redSqrt();
      if (L != null ? K.redIsOdd() !== L && K.redINeg() : K.redJacobi() !== 1 && K.redINeg(), K.redJacobi() !== 1)
        throw new Error("Invalid `a` coefficient.");
      const re = P.redMul(K), ce = r.redMul(P), le = x.redMul(re);
      return I(ce.eq(X)), [ce, le];
    }
    _short(r, x) {
      return u._isomorphism(this.a, this.b, r, x);
    }
    _mont(r, x) {
      const [O, L] = this._findRS(x), X = L.redInvert(), P = O.redMuln(3).redMul(X);
      return r != null ? i._isomorphism(P, X, r) : [P, X];
    }
    _edwards(r, x) {
      const [O, L] = this._findRS(x), X = O.redMuln(3), P = L.redMuln(2), K = X.redAdd(P), re = X.redSub(P);
      return r != null ? E._isomorphism(K, re, r) : [K, re];
    }
    _findRS(r) {
      I(r == null || typeof r == "boolean"), I(this.h.word(0) >= 4), I(!this.n.isZero());
      const x = this.one.redNeg();
      let O;
      for (; ; ) {
        x.redIAdd(this.one);
        try {
          O = this.pointFromX(x.clone());
        } catch {
          continue;
        }
        if (O = O.mul(this.n), !O.isInfinity() && O.y.isZero())
          break;
      }
      const L = O.x, P = L.redSqr().redMuln(3).redIAdd(this.a).redSqrt();
      return r != null && P.redIsOdd() !== r && P.redINeg(), [L, P];
    }
    _scale0(r, x) {
      if (I(this.a.isZero() === r.isZero()), I(this.b.isZero() === x.isZero()), this.a.isZero()) {
        const re = this.b.redDiv(this.field(x)), ce = U(re), le = ce.redSqrt(), me = ce.redMul(le);
        return I(me.redSqr().eq(re)), I(!le.isZero()), [ce, me];
      }
      if (this.b.isZero()) {
        const re = this.a.redDiv(this.field(r)), ce = re.redSqrt();
        ce.redJacobi() !== 1 && ce.redINeg();
        const le = ce.redSqrt(), me = ce.redMul(le);
        return I(me.redMul(le).eq(re)), I(!le.isZero()), [ce, me];
      }
      const O = this.a.redDiv(this.field(r)), L = this.b.redDiv(this.field(x)), X = O.redSqrt();
      O.redMul(X).eq(L) || X.redINeg(), I(O.redMul(X).eq(L));
      const P = X.redSqrt(), K = X.redMul(P);
      return I(!P.isZero()), [X, K];
    }
    _scale1(r, x) {
      const O = this.g.x.redDiv(this.field(r)), L = this.g.y.redDiv(this.field(x)), X = O.redSqrt();
      return O.redMul(X).eq(L) || X.redINeg(), I(O.redMul(X).eq(L)), I(!X.isZero()), [O, L];
    }
    _scaleShort(r) {
      return I(r instanceof u), this.g.isInfinity() || r.g.isInfinity() ? this._scale0(r.a, r.b) : this._scale1(r.g.x, r.g.y);
    }
    _scaleMont(r) {
      if (I(r instanceof i), this.g.isInfinity() || r.g.isInfinity()) {
        const [P, K] = r._short();
        return this._scale0(P, K);
      }
      const { x, y: O } = r.g, L = x.redAdd(r.a3).redMul(r.bi), X = O.redMul(r.bi);
      return this._scale1(L, X);
    }
    _scaleEdwards(r) {
      if (I(r instanceof E), this.g.isInfinity() || r.g.isInfinity()) {
        const [Be, ke] = r._short();
        return this._scale0(Be, ke);
      }
      const { x, y: O, z: L } = r.g, X = r.a.redMuln(5), P = r.d.redMuln(5), K = r.d.redSub(r.a), re = P.redSub(r.a), ce = r.d.redSub(X), le = O.redAdd(L), me = O.redSub(L), ne = re.redMul(O).redIAdd(ce.redMul(L)), W = me.redMuln(12), te = K.redMul(le).redMul(L), pe = me.redMul(x).redIMuln(4), Ee = W.redMul(pe).redInvert(), Ae = ne.redMul(pe).redMul(Ee), Oe = te.redMul(W).redMul(Ee);
      return this._scale1(Ae, Oe);
    }
    _getEndomorphism(r = 0) {
      if (this.n.isZero() || this.g.isInfinity() || !this.zeroA || this.p.modrn(3) !== 1 || this.n.modrn(3) !== 1)
        return null;
      const [x, O] = this._getEndoRoots(this.p), L = [x, O][r & 1].toRed(this.red), [X, P] = this._getEndoRoots(this.n), K = this.point(this.g.x.redMul(L), this.g.y);
      let re;
      this.g.mul(X).eq(K) ? re = X : (I(this.g.mul(P).eq(K)), re = P);
      const ce = this._getEndoBasis(re), le = this._getEndoPrecomp(ce);
      return new j(L, re, ce, le);
    }
    _getEndoRoots(r) {
      const x = r === this.p ? this.red : c.mont(r), O = new c(2).toRed(x), L = new c(3).toRed(x), X = O.redInvert(), P = L.redNeg().redSqrt().redMul(X), K = P.redNeg(), re = P.redSub(X).fromRed(), ce = K.redSub(X).fromRed();
      return [re, ce].sort(c.cmp);
    }
    _getEndoBasis(r) {
      const [x, O, L, X, P, K] = this._egcdSqrt(r), re = L, ce = X.neg(), le = x.sqr().iadd(O.sqr()), me = P.sqr().iadd(K.sqr());
      let ne, W;
      return le.cmp(me) <= 0 ? (ne = x, W = O.neg()) : (ne = P, W = K.neg()), [
        new J(re, ce),
        new J(ne, W)
      ];
    }
    _egcdSqrt(r) {
      I(r instanceof c), I(!r.red), I(r.sign() > 0), I(this.n.sign() > 0);
      const x = this.n.ushrn(this.n.bitLength() >>> 1);
      let O = r, L = this.n.clone(), X = new c(1), P = new c(0), K = new c(0), re = new c(1), ce, le, me, ne, W = 0, te = 0, pe;
      for (; !O.isZero() && W < 2; ) {
        const Oe = L.quo(O), Be = L.sub(Oe.mul(O)), ke = K.sub(Oe.mul(X)), Ne = re.sub(Oe.mul(P));
        te === 0 && Be.cmp(x) < 0 && (ce = pe, le = X, me = Be, ne = ke, te = 1), pe = Be, L = O, O = Be, K = X, X = ke, re = P, P = Ne, W += te;
      }
      return I(te !== 0, "Could not find r < sqrt(n)."), [
        ce,
        le,
        me,
        ne,
        K,
        X
      ];
    }
    _getEndoPrecomp(r) {
      I(Array.isArray(r)), I(r.length === 2), I(r[0] instanceof J), I(r[1] instanceof J);
      const [x, O] = r, L = x.a.mul(O.b).isub(x.b.mul(O.a)), X = L.bitLength(), P = X >= 160;
      I(L.eq(this.n));
      let K = X + Math.ceil(X / 2) + 1, re, ce;
      for (P && (K -= K & 63); K > X && (re = O.b.ushln(K).divRound(L), ce = x.b.ushln(K).divRound(L), !(re.ucmp(L) < 0 && ce.ucmp(L) < 0)); )
        P ? K -= 64 : K -= 1;
      if (K <= X)
        throw new Error("Could not calculate g1 and g2.");
      return [K, re, ce];
    }
    _endoSplit(r) {
      I(r instanceof c), I(!r.red), I(!this.n.isZero());
      const [x, O] = this.endo.basis, L = O.b.mul(r).divRound(this.n), X = x.b.neg().mul(r).divRound(this.n), P = L.mul(x.a), K = X.mul(O.a), re = L.ineg().mul(x.b), ce = X.mul(O.b), le = r.sub(P).isub(K), me = re.isub(ce);
      return [le, me];
    }
    _endoBeta(r) {
      return I(r instanceof a), [r, r._getBeta()];
    }
    _endoWnafMulAdd(r, x) {
      I(Array.isArray(r)), I(Array.isArray(x)), I(r.length === x.length), I(this.endo != null);
      const O = r.length, L = new Array(O * 2), X = new Array(O * 2);
      for (let P = 0; P < O; P++) {
        const [K, re] = this._endoBeta(r[P]), [ce, le] = this._endoSplit(x[P]);
        L[P * 2 + 0] = K, X[P * 2 + 0] = ce, L[P * 2 + 1] = re, X[P * 2 + 1] = le;
      }
      return this._wnafMulAdd(5, L, X);
    }
    _sswu(r) {
      const { b: x, z: O, ai: L, zi: X, one: P } = this, K = O.redSqr(), re = x.redNeg().redMul(L), ce = x.redMul(X).redMul(L), le = r.redSqr(), me = le.redSqr(), ne = K.redMul(me).redIAdd(O.redMul(le)), W = ne.isZero() ? ne : ne.redInvert(), te = W.isZero() ? ce : re.redMul(P.redAdd(W)), pe = O.redMul(le).redMul(te), Ee = this.solveY2(te), Ae = this.solveY2(pe), Oe = Ee.redIsSquare() | 0, Be = [te, pe][Oe ^ 1], ke = [Ee, Ae][Oe ^ 1].redSqrt();
      return ke.redIsOdd() !== r.redIsOdd() && ke.redINeg(), this.point(Be, ke);
    }
    _sswui(r, x) {
      const { a: O, b: L, z: X } = this, { x: P, y: K } = r, re = x & 3, ce = O.redSqr().redMul(P.redSqr()), le = O.redMul(L).redMul(P).redIMuln(2), me = L.redSqr().redMuln(3), ne = O.redMul(P).redIAdd(L), W = ce.redISub(le).redISub(me).redSqrt(), te = ne.redSub(W).redINeg(), pe = ne.redAdd(W).redINeg(), Ee = ne.redMul(X).redIMuln(2), Ae = L.redMul(X).redIMuln(2), Oe = [te, pe][re & 1], Be = [Ee, Ae][re >>> 1], ke = Oe.redDivSqrt(Be);
      return ke.redIsOdd() !== K.redIsOdd() && ke.redINeg(), ke;
    }
    _svdwf(r) {
      const { c: x, z: O, zi: L, i2: X, i3: P } = this, K = this.solveY2(O), re = P.redMul(L.redSqr()), ce = r.redSqr(), le = ce.redSqr(), me = ce.redAdd(K), ne = ce.redMul(me), W = ne.isZero() ? ne : ne.redInvert(), te = le.redMul(W).redMul(x), pe = me.redSqr().redMul(me), Ee = x.redSub(O).redMul(X).redISub(te), Ae = te.redSub(x.redAdd(O).redMul(X)), Oe = O.redSub(pe.redMul(W).redMul(re)), Be = this.solveY2(Ee), ke = this.solveY2(Ae), Ne = this.solveY2(Oe), Ke = Be.redJacobi() | 1, Ce = ke.redJacobi() | 1, Ye = t((Ke - 1) * Ce, 3), vt = [Ee, Ae, Oe][Ye], Ve = [Be, ke, Ne][Ye];
      return [vt, Ve];
    }
    _svdw(r) {
      const [x, O] = this._svdwf(r), L = O.redSqrt();
      return L.redIsOdd() !== r.redIsOdd() && L.redINeg(), this.point(x, L);
    }
    _svdwi(r, x) {
      const { b: O, c: L, z: X, zero: P, two: K } = this, { x: re, y: ce } = r, le = x & 3, me = X.redSqr(), ne = me.redMul(X), W = me.redSqr(), te = ne.redAdd(O), pe = te.redMuln(2), Ee = re.redSqr(), Ae = re.redMuln(2).redIAdd(X), Oe = re.redMul(me), Be = L.redSub(Ae), ke = L.redAdd(Ae), Ne = Ee.redMul(me).redIAdd(W).redIMuln(9), Ke = re.redMul(ne).redIMuln(18), Ce = te.redMul(re.redSub(X)).redIMuln(12), vt = (le >= 2 ? Ne.redISub(Ke).redIAdd(Ce).redSqrt() : P).redMul(X), Ve = ne.redISub(Oe).redIMuln(3).redISub(pe), Xe = te.redMul(Be), qt = te.redMul(ke), Ge = Ve.redAdd(vt), Je = Ve.redSub(vt), Rt = K, We = [Xe, qt, Ge, Je][le], Ze = [ke, Be, Rt, Rt][le], Ft = We.redDivSqrt(Ze), [Qe] = this._svdwf(Ft);
      if (!Qe.eq(re))
        throw new Error("Invalid point.");
      return Ft.redIsOdd() !== ce.redIsOdd() && Ft.redINeg(), Ft;
    }
    isElliptic() {
      const { a: r, b: x } = this, L = r.redSqr().redMul(r);
      return !x.redSqr().redMuln(27).redIAdd(L.redMuln(4)).isZero();
    }
    jinv() {
      const { a: r, b: x } = this, L = r.redSqr().redMul(r), X = x.redSqr(), P = L.redMuln(4), K = P.redMuln(1728), re = X.redMuln(27).redIAdd(P);
      if (re.isZero())
        throw new Error("Curve is not elliptic.");
      return K.redDiv(re).fromRed();
    }
    point(r, x) {
      return new a(this, r, x);
    }
    jpoint(r, x, O) {
      return new s(this, r, x, O);
    }
    solveX(r) {
      if (I(r instanceof c), !this.a.isZero())
        throw new Error("Not implemented.");
      const O = r.redSqr().redSub(this.b);
      return B(O);
    }
    solveY2(r) {
      I(r instanceof c);
      const O = r.redSqr().redMul(r).redIAdd(this.b);
      return this.zeroA || (this.threeA ? O.redIAdd(r.redMuln(-3)) : O.redIAdd(this.a.redMul(r))), O;
    }
    validate(r) {
      if (I(r instanceof a), r.inf)
        return !0;
      const { x, y: O } = r, L = this.solveY2(x);
      return O.redSqr().eq(L);
    }
    pointFromX(r, x = null) {
      I(r instanceof c), I(x == null || typeof x == "boolean"), r.red || (r = r.toRed(this.red));
      const O = this.solveY(r);
      if (x != null) {
        if (this.h.cmpn(1) > 0 && O.isZero() && x)
          throw new Error("Invalid point.");
        O.redIsOdd() !== x && O.redINeg();
      }
      return this.point(r, O);
    }
    pointFromY(r, x = 0) {
      I(r instanceof c), I(x >>> 0 === x), r.red || (r = r.toRed(this.red));
      const O = this.solveX(r);
      if (x >= O.length)
        throw new Error("Invalid X coordinate index.");
      const L = O[x];
      return this.point(L, r);
    }
    isIsomorphic(r) {
      if (I(r instanceof f), !r.p.eq(this.p))
        return !1;
      let x, O;
      try {
        [x, O] = this._scale(r);
      } catch {
        return !1;
      }
      if (r.type === "short") {
        const L = this.field(r.a).redMul(x.redSqr()), X = this.field(r.b).redMul(O.redSqr());
        return this.a.eq(L) && this.b.eq(X);
      }
      if (r.type === "mont") {
        const { a3: L, bi: X } = r, P = this.field(L.redMul(X)).redMul(x);
        return this.solveY2(P).isZero();
      }
      if (r.type === "edwards") {
        const L = this.field(r.ad6).redMul(x);
        return this.solveY2(L).isZero();
      }
      return !1;
    }
    isIsogenous(r) {
      return I(r instanceof f), !1;
    }
    pointFromShort(r) {
      if (I(r instanceof a), this.isIsomorphic(r.curve)) {
        if (r.isInfinity())
          return this.point();
        const [x, O] = this._scale(r.curve), L = this.field(r.x), X = this.field(r.y), P = L.redMul(x), K = X.redMul(O);
        return this.point(P, K);
      }
      throw new Error("Not implemented.");
    }
    pointFromMont(r) {
      if (I(r instanceof p), this.isIsomorphic(r.curve)) {
        if (r.isInfinity())
          return this.point();
        const { a3: x, bi: O } = r.curve, [L, X] = this._scale(r.curve), P = r.x.redAdd(x).redMul(O), K = r.y.redMul(O);
        return this.point(
          this.field(P).redMul(L),
          this.field(K).redMul(X)
        );
      }
      throw new Error("Not implemented.");
    }
    pointFromEdwards(r) {
      if (I(r instanceof v), this.isIsomorphic(r.curve)) {
        const { a: x, d: O, ad6: L } = r.curve, [X, P] = this._scale(r.curve);
        if (r.isInfinity())
          return this.point();
        if (r.x.isZero()) {
          const Ne = this.field(L).redMul(X);
          return this.point(Ne, this.zero);
        }
        const { x: K, y: re, z: ce } = r, le = x.redMuln(5), me = O.redMuln(5), ne = O.redSub(x), W = me.redSub(x), te = O.redSub(le), pe = re.redAdd(ce), Ee = re.redSub(ce), Ae = W.redMul(re).redIAdd(te.redMul(ce)), Oe = Ee.redMuln(12), Be = ne.redMul(pe).redMul(ce), ke = Ee.redMul(K).redIMuln(4);
        return this.cpoint(
          this.field(Ae).redMul(X),
          this.field(Oe),
          this.field(Be).redMul(P),
          this.field(ke)
        );
      }
      throw new Error("Not implemented.");
    }
    pointFromUniform(r) {
      if (I(r instanceof c), this.z.isZero() || this.b.isZero())
        throw new Error("Not implemented.");
      if (!this.a.isZero())
        return this._sswu(r);
      if (!this.c.isZero())
        return this._svdw(r);
      throw new Error("Not implemented.");
    }
    pointToUniform(r, x) {
      if (I(r instanceof a), I(x >>> 0 === x), this.z.isZero() || this.b.isZero())
        throw new Error("Not implemented.");
      if (r.isInfinity())
        throw new Error("Invalid point.");
      const O = (x >>> 4 & 15) % this.torsion.length, L = r.add(this.torsion[O]);
      return se(() => {
        if (!this.a.isZero())
          return this._sswui(L, x);
        if (!this.c.isZero())
          return this._svdwi(L, x);
        throw new Error("Not implemented.");
      });
    }
    mulAll(r, x) {
      return super.mulAll(r, x).toP();
    }
    affinizeAll(r) {
      const x = this.normalizeAll(r);
      for (let O = 0; O < x.length; O++)
        x[O] = x[O].toP();
      return x;
    }
    decodePoint(r) {
      return a.decode(this, r);
    }
    encodeX(r) {
      return I(r instanceof n), r.encodeX();
    }
    decodeEven(r) {
      return a.decodeEven(this, r);
    }
    decodeSquare(r) {
      return a.decodeSquare(this, r);
    }
    toShort(r, x, O = null) {
      const [L, X] = this._short(r, x), P = new u({
        red: this.red,
        prime: this.prime,
        p: this.p,
        a: L,
        b: X,
        n: this.n,
        h: this.h
      });
      if (O != null) {
        const [, K] = P._scale(this);
        K.redIsOdd() !== O && K.redINeg();
      }
      this.g.isInfinity() || (P.g = P.pointFromShort(this.g));
      for (let K = 0; K < this.h.word(0); K++)
        P.torsion[K] = P.pointFromShort(this.torsion[K]);
      return P;
    }
    toMont(r, x, O = null) {
      const [L, X] = this._mont(r, x), P = new i({
        red: this.red,
        prime: this.prime,
        p: this.p,
        a: L,
        b: X,
        n: this.n,
        h: this.h
      });
      if (O != null) {
        const [, K] = this._scale(P);
        K.redIsOdd() !== O && K.redINeg();
      }
      this.g.isInfinity() || (P.g = P.pointFromShort(this.g));
      for (let K = 0; K < this.h.word(0); K++)
        P.torsion[K] = P.pointFromShort(this.torsion[K]);
      return P;
    }
    toEdwards(r, x, O = null) {
      const [L, X] = this._edwards(r, x), P = new E({
        red: this.red,
        prime: this.prime,
        p: this.p,
        a: L,
        d: X,
        n: this.n,
        h: this.h
      });
      if (O != null) {
        const [, K] = this._scale(P);
        K.redIsOdd() !== O && K.redINeg();
      }
      if (this.g.isInfinity() || (P.g = P.pointFromShort(this.g), P.g.normalize()), P.isComplete())
        for (let K = 0; K < this.h.word(0); K++)
          P.torsion[K] = P.pointFromShort(this.torsion[K]), P.torsion[K].normalize();
      return P;
    }
    pointFromJSON(r) {
      return a.fromJSON(this, r);
    }
    toJSON(r) {
      const x = super.toJSON(r);
      return x.a = this.a.fromRed().toJSON(), x.b = this.b.fromRed().toJSON(), this.c.isZero() || (x.c = this.c.fromRed().toJSON()), x;
    }
  }
  class a extends n {
    constructor(r, x, O) {
      I(r instanceof u), super(r, d.AFFINE), this.x = this.curve.zero, this.y = this.curve.zero, this.inf = !0, x != null && this._init(x, O);
    }
    _init(r, x) {
      I(r instanceof c), I(x instanceof c), this.x = r, this.y = x, this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1;
    }
    _getBeta() {
      if (!this.curve.endo)
        return null;
      if (this.pre && this.pre.beta)
        return this.pre.beta;
      const r = this.x.redMul(this.curve.endo.beta), x = this.curve.point(r, this.y);
      return this.pre && (x.pre = this.pre.map((O) => {
        const L = O.x.redMul(this.curve.endo.beta);
        return this.curve.point(L, O.y);
      }), this.pre.beta = x), x;
    }
    _getJNAF(r) {
      if (I(r instanceof a), this.inf || r.inf)
        return super._getJNAF(r);
      const x = [
        this,
        // 1
        null,
        // 3
        null,
        // 5
        r
        // 7
      ];
      return this.y.eq(r.y) ? (x[1] = this.add(r), x[2] = this.toJ().sub(r)) : this.y.eq(r.y.redNeg()) ? (x[1] = this.toJ().add(r), x[2] = this.sub(r)) : (x[1] = this.toJ().add(r), x[2] = this.toJ().sub(r)), x;
    }
    clone() {
      return this.inf ? this.curve.point() : this.curve.point(this.x, this.y);
    }
    scale(r) {
      return this.toJ().scale(r);
    }
    neg() {
      return this.inf ? this : this.curve.point(this.x, this.y.redNeg());
    }
    add(r) {
      if (I(r instanceof a), this.inf)
        return r;
      if (r.inf)
        return this;
      if (this.x.eq(r.x))
        return this.y.eq(r.y) ? this.dbl() : this.curve.point();
      if (this.y.eq(r.y)) {
        const K = this.x.redNeg().redISub(r.x), re = this.y.redNeg();
        return this.curve.point(K, re);
      }
      const x = this.x.redSub(r.x), L = this.y.redSub(r.y).redDiv(x), X = L.redSqr().redISub(this.x).redISub(r.x), P = L.redMul(this.x.redSub(X)).redISub(this.y);
      return this.curve.point(X, P);
    }
    dbl() {
      if (this.inf)
        return this;
      if (this.y.isZero())
        return this.curve.point();
      const x = this.x.redSqr().redIMuln(3).redIAdd(this.curve.a), O = this.y.redMuln(2), L = x.redDiv(O), X = L.redSqr().redISub(this.x).redISub(this.x), P = L.redMul(this.x.redSub(X)).redISub(this.y);
      return this.curve.point(X, P);
    }
    dblp(r) {
      return this.toJ().dblp(r).toP();
    }
    getX() {
      if (this.inf)
        throw new Error("Invalid point.");
      return this.x.fromRed();
    }
    getY() {
      if (this.inf)
        throw new Error("Invalid point.");
      return this.y.fromRed();
    }
    eq(r) {
      return I(r instanceof a), this === r ? !0 : this.inf ? r.inf : r.inf ? !1 : this.x.eq(r.x) && this.y.eq(r.y);
    }
    cmp(r) {
      return I(r instanceof a), this.inf && !r.inf ? -1 : !this.inf && r.inf ? 1 : this.inf && r.inf ? 0 : this.order().cmp(r.order()) || this.getX().cmp(r.getX()) || this.getY().cmp(r.getY());
    }
    isInfinity() {
      return this.inf;
    }
    isOrder2() {
      return this.inf ? !1 : this.y.isZero();
    }
    isOdd() {
      return this.inf ? !1 : this.y.redIsOdd();
    }
    isEven() {
      return this.inf ? !1 : this.y.redIsEven();
    }
    isSquare() {
      return this.inf ? !1 : this.y.redJacobi() !== -1;
    }
    eqX(r) {
      return I(r instanceof c), I(!r.red), this.inf ? !1 : this.getX().eq(r);
    }
    eqR(r) {
      return I(r instanceof c), I(!r.red), I(!this.curve.n.isZero()), this.inf ? !1 : this.getX().imod(this.curve.n).eq(r);
    }
    mul(r) {
      return super.mul(r).toP();
    }
    muln(r) {
      return super.muln(r).toP();
    }
    mulBlind(r, x) {
      return super.mulBlind(r, x).toP();
    }
    mulAdd(r, x, O) {
      return super.mulAdd(r, x, O).toP();
    }
    mulH() {
      return super.mulH().toP();
    }
    div(r) {
      return super.div(r).toP();
    }
    divn(r) {
      return super.divn(r).toP();
    }
    divH() {
      return super.divH().toP();
    }
    toP() {
      return this;
    }
    toJ() {
      return this.inf ? this.curve.jpoint() : this.curve.jpoint(this.x, this.y, this.curve.one);
    }
    encode(r) {
      r == null && (r = !0), I(typeof r == "boolean");
      const { fieldSize: x } = this.curve;
      if (this.inf)
        throw new Error("Invalid point.");
      if (r) {
        const P = k.alloc(1 + x), K = this.curve.encodeField(this.getX());
        return P[0] = 2 | this.y.redIsOdd(), K.copy(P, 1), P;
      }
      const O = k.alloc(1 + x * 2), L = this.curve.encodeField(this.getX()), X = this.curve.encodeField(this.getY());
      return O[0] = 4, L.copy(O, 1), X.copy(O, 1 + x), O;
    }
    static decode(r, x) {
      I(r instanceof u), I(k.isBuffer(x));
      const O = r.fieldSize;
      if (x.length < 1 + O)
        throw new Error("Not a point.");
      const L = x[0];
      switch (L) {
        case 2:
        case 3: {
          if (x.length !== 1 + O)
            throw new Error("Invalid point size for compressed.");
          const X = r.decodeField(x.slice(1, 1 + O));
          if (X.cmp(r.p) >= 0)
            throw new Error("Invalid point.");
          const P = r.pointFromX(X, L === 3);
          return I(!P.isInfinity()), P;
        }
        case 4:
        case 6:
        case 7: {
          if (x.length !== 1 + O * 2)
            throw new Error("Invalid point size for uncompressed.");
          const X = r.decodeField(x.slice(1, 1 + O)), P = r.decodeField(x.slice(1 + O, 1 + 2 * O));
          if (X.cmp(r.p) >= 0 || P.cmp(r.p) >= 0)
            throw new Error("Invalid point.");
          if (L !== 4 && L !== (6 | P.isOdd()))
            throw new Error("Invalid hybrid encoding.");
          const K = r.point(X, P);
          if (!K.validate())
            throw new Error("Invalid point.");
          return I(!K.isInfinity()), K;
        }
        default:
          throw new Error("Unknown point format.");
      }
    }
    encodeX() {
      return this.curve.encodeField(this.getX());
    }
    static decodeEven(r, x) {
      I(r instanceof u);
      const O = r.decodeField(x);
      if (O.cmp(r.p) >= 0)
        throw new Error("Invalid point.");
      return r.pointFromX(O, !1);
    }
    static decodeSquare(r, x) {
      I(r instanceof u);
      const O = r.decodeField(x);
      if (O.cmp(r.p) >= 0)
        throw new Error("Invalid point.");
      return r.pointFromX(O);
    }
    toJSON(r) {
      if (this.inf)
        return [];
      const x = this.getX().toJSON(), O = this.getY().toJSON();
      return r === !0 && this.pre ? [x, O, this.pre.toJSON()] : [x, O];
    }
    toPretty() {
      if (this.inf)
        return [];
      const r = this.curve.fieldSize * 2, x = M(this.getX(), r), O = M(this.getY(), r);
      return [x, O];
    }
    static fromJSON(r, x) {
      if (I(r instanceof u), I(Array.isArray(x)), I(x.length === 0 || x.length === 2 || x.length === 3), x.length === 0)
        return r.point();
      const O = c.fromJSON(x[0]), L = c.fromJSON(x[1]), X = r.point(O, L);
      return x.length > 2 && x[2] != null && (X.pre = b.fromJSON(X, x[2])), X;
    }
    [e]() {
      return this.inf ? "<ShortPoint: Infinity>" : "<ShortPoint: x=" + this.x.fromRed().toString(16, 2) + " y=" + this.y.fromRed().toString(16, 2) + ">";
    }
  }
  class s extends n {
    constructor(r, x, O, L) {
      I(r instanceof u), super(r, d.JACOBIAN), this.x = this.curve.one, this.y = this.curve.one, this.z = this.curve.zero, this.zOne = !1, x != null && this._init(x, O, L);
    }
    _init(r, x, O) {
      I(r instanceof c), I(x instanceof c), I(O == null || O instanceof c), this.x = r, this.y = x, this.z = O || this.curve.one, this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z.eq(this.curve.one);
    }
    clone() {
      return this.curve.jpoint(this.x, this.y, this.z);
    }
    validate() {
      const { a: r, b: x } = this.curve;
      if (this.isInfinity())
        return !0;
      if (this.zOne)
        return this.curve.validate(this.toP());
      const O = this.y.redSqr(), L = this.x.redSqr().redMul(this.x), X = this.z.redSqr(), P = X.redSqr(), K = P.redMul(X), re = L.redIAdd(x.redMul(K));
      return this.curve.zeroA || (this.curve.threeA ? re.redIAdd(P.redIMuln(-3).redMul(this.x)) : re.redIAdd(r.redMul(P).redMul(this.x))), O.eq(re);
    }
    normalize() {
      if (this.zOne)
        return this;
      if (this.isInfinity())
        return this;
      const r = this.z.redInvert(), x = r.redSqr();
      return this.x = this.x.redMul(x), this.y = this.y.redMul(x).redMul(r), this.z = this.curve.one, this.zOne = !0, this;
    }
    scale(r) {
      if (I(r instanceof c), this.isInfinity())
        return this.curve.jpoint();
      const x = r.redSqr(), O = this.x.redMul(x), L = this.y.redMul(x).redMul(r), X = this.z.redMul(r);
      return this.curve.jpoint(O, L, X);
    }
    neg() {
      return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
    }
    add(r) {
      return I(r instanceof n), r.type === d.AFFINE ? this._mixedAdd(r) : this._add(r);
    }
    _add(r) {
      return I(r instanceof s), this.isInfinity() ? r : r.isInfinity() ? this : this.zOne ? r._addJA(this) : r.zOne ? this._addJA(r) : this._addJJ(r);
    }
    _mixedAdd(r) {
      return I(r instanceof a), this.isInfinity() ? r.toJ() : r.isInfinity() ? this : this._addJA(r);
    }
    _addJJ(r) {
      const x = this.z.redSqr(), O = r.z.redSqr(), L = this.x.redMul(O), X = r.x.redMul(x), P = this.y.redMul(r.z).redMul(O), K = r.y.redMul(this.z).redMul(x), re = X.redISub(L), ce = K.redISub(P);
      if (re.isZero())
        return ce.isZero() ? this.dbl() : this.curve.jpoint();
      const le = re.redSqr(), me = re.redMul(le), ne = L.redMul(le), W = ce.redSqr().redISub(me).redISub(ne).redISub(ne), te = ce.redMul(ne.redISub(W)).redISub(P.redMul(me)), pe = this.z.redMul(r.z).redMul(re);
      return this.curve.jpoint(W, te, pe);
    }
    _addJA(r) {
      const x = this.z.redSqr(), O = r.x.redMul(x), L = r.y.redMul(this.z).redMul(x), X = O.redISub(this.x), P = L.redISub(this.y).redIMuln(2);
      if (X.isZero())
        return P.isZero() ? this.dbl() : this.curve.jpoint();
      const K = X.redMuln(2).redSqr(), re = X.redMul(K), ce = this.x.redMul(K), le = P.redSqr().redISub(re).redISub(ce).redISub(ce), me = P.redMul(ce.redISub(le)).redISub(this.y.redMul(re).redIMuln(2)), ne = this.z.redMul(X).redIMuln(2);
      return this.curve.jpoint(le, me, ne);
    }
    dbl() {
      return this.isInfinity() ? this : this.y.isZero() ? this.curve.jpoint() : this.curve.zeroA ? this._dbl0() : this.curve.threeA ? this._dbl3() : this._dblJ();
    }
    _dblJ() {
      const r = this.x.redSqr(), x = this.y.redSqr(), O = this.z.redSqr(), L = this.x.redMul(x).redIMuln(4), X = r.redIMuln(3).redIAdd(this.curve.a.redMul(O.redSqr())), P = X.redSqr().redISub(L).redISub(L), K = P, re = X.redMul(L.redISub(P)).redISub(x.redSqr().redIMuln(8)), ce = this.y.redMul(this.z).redIMuln(2);
      return this.curve.jpoint(K, re, ce);
    }
    _dbl0() {
      const r = this.x.redSqr(), x = this.y.redSqr(), O = x.redSqr(), X = x.redIAdd(this.x).redSqr().redISub(r).redISub(O).redIMuln(2), P = r.redIMuln(3), re = P.redSqr().redISub(X).redISub(X), ce = P.redMul(X.redISub(re)).redISub(O.redIMuln(8)), le = this.y.redMul(this.z).redIMuln(2);
      return this.curve.jpoint(re, ce, le);
    }
    _dbl3() {
      const r = this.z.redSqr(), x = this.y.redSqr(), O = this.x.redMul(x), L = this.x.redSub(r), X = this.x.redAdd(r), P = L.redMul(X).redIMuln(3), K = O.redIMuln(4), re = K.redMuln(2), ce = x.redSqr().redIMuln(8), le = P.redSqr().redISub(re), me = this.y.redAdd(this.z).redSqr().redISub(x).redISub(r), ne = P.redMul(K.redISub(le)).redISub(ce);
      return this.curve.jpoint(le, ne, me);
    }
    getX() {
      if (this.isInfinity())
        throw new Error("Invalid point.");
      return this.normalize(), this.x.fromRed();
    }
    getY() {
      if (this.isInfinity())
        throw new Error("Invalid point.");
      return this.normalize(), this.y.fromRed();
    }
    eq(r) {
      if (I(r instanceof s), this === r)
        return !0;
      if (this.isInfinity())
        return r.isInfinity();
      if (r.isInfinity())
        return !1;
      if (this.z.eq(r.z))
        return this.x.eq(r.x) && this.y.eq(r.y);
      const x = this.z.redSqr(), O = r.z.redSqr(), L = this.x.redMul(O), X = r.x.redMul(x);
      if (!L.eq(X))
        return !1;
      const P = x.redMul(this.z), K = O.redMul(r.z), re = this.y.redMul(K), ce = r.y.redMul(P);
      return re.eq(ce);
    }
    cmp(r) {
      I(r instanceof s);
      const x = this.isInfinity(), O = r.isInfinity();
      return x && !O ? -1 : !x && O ? 1 : x && O ? 0 : this.order().cmp(r.order()) || this.getX().cmp(r.getX()) || this.getY().cmp(r.getY());
    }
    isInfinity() {
      return this.z.isZero();
    }
    isOrder2() {
      return this.isInfinity() ? !1 : this.y.isZero();
    }
    isOdd() {
      return this.isInfinity() ? !1 : (this.normalize(), this.y.redIsOdd());
    }
    isEven() {
      return this.isInfinity() ? !1 : (this.normalize(), this.y.redIsEven());
    }
    isSquare() {
      return this.isInfinity() ? !1 : this.y.redMul(this.z).redJacobi() !== -1;
    }
    eqX(r) {
      if (I(r instanceof c), I(!r.red), this.isInfinity())
        return !1;
      const x = this.z.redSqr(), O = r.toRed(this.curve.red).redMul(x);
      return this.x.eq(O);
    }
    eqR(r) {
      if (I(r instanceof c), I(!r.red), !this.curve.smallGap)
        return this.toP().eqR(r);
      if (this.isInfinity() || r.cmp(this.curve.p) >= 0)
        return !1;
      const x = this.z.redSqr(), O = r.toRed(this.curve.red).redMul(x);
      if (this.x.eq(O))
        return !0;
      if (this.curve.highOrder || r.cmp(this.curve.pmodn) >= 0)
        return !1;
      const L = this.curve.redN.redMul(x);
      return O.redIAdd(L), this.x.eq(O);
    }
    toP() {
      return this.isInfinity() ? this.curve.point() : (this.normalize(), this.curve.point(this.x, this.y));
    }
    toJ() {
      return this;
    }
    encode(r) {
      return this.toP().encode(r);
    }
    static decode(r, x) {
      return a.decode(r, x).toJ();
    }
    encodeX() {
      return this.toP().encodeX();
    }
    static decodeEven(r, x) {
      return a.decodeEven(r, x).toJ();
    }
    static decodeSquare(r, x) {
      return a.decodeSquare(r, x).toJ();
    }
    toJSON(r) {
      return this.toP().toJSON(r);
    }
    toPretty() {
      return this.toP().toPretty();
    }
    static fromJSON(r, x) {
      return a.fromJSON(r, x).toJ();
    }
    [e]() {
      return this.isInfinity() ? "<JPoint: Infinity>" : "<JPoint: x=" + this.x.fromRed().toString(16, 2) + " y=" + this.y.fromRed().toString(16, 2) + " z=" + this.z.fromRed().toString(16, 2) + ">";
    }
  }
  class i extends f {
    constructor(r) {
      super(p, "mont", r), this.a = c.fromJSON(r.a).toRed(this.red), this.b = c.fromJSON(r.b).toRed(this.red), this.bi = this.b.redInvert(), this.a2 = this.a.redAdd(this.two), this.a24 = this.a2.redMul(this.i4), this.a3 = this.a.redMul(this.i3), this.a0 = this.a.redMul(this.bi), this.b0 = this.bi.redSqr(), this._finalize(r);
    }
    static _isomorphism(r, x, O) {
      I(r instanceof c), I(x instanceof c), I(O instanceof c);
      const L = r.clone(), X = O.clone();
      if (x.redDiv(O).redJacobi() !== 1)
        throw new Error("Invalid `b` coefficient.");
      return [L, X];
    }
    _short(r, x) {
      const { a: O, b: L, three: X } = this, P = O.redSqr(), K = P.redMul(O), re = L.redSqr(), ce = re.redMul(L), le = X.redSub(P), me = re.redMuln(3), ne = K.redMuln(2).redISub(O.redMuln(9)), W = ce.redMuln(27), te = le.redDiv(me), pe = ne.redDiv(W);
      return r != null ? u._isomorphism(te, pe, r, x) : [te, pe];
    }
    _mont(r) {
      return i._isomorphism(this.a, this.b, r);
    }
    _edwards(r, x = !1) {
      I(typeof x == "boolean");
      const { two: O, bi: L } = this, X = this.a.redAdd(O).redMul(L), P = this.a.redSub(O).redMul(L);
      return x && X.swap(P), r != null ? E._isomorphism(X, P, r) : [X, P];
    }
    _scaleShort(r) {
      I(r instanceof u);
      const [x, O] = r._scale(this);
      return [
        this.field(x.redInvert()),
        this.field(O.redInvert())
      ];
    }
    _scaleMont(r) {
      return I(r instanceof i), this.g.isInfinity() || r.g.isInfinity() ? this.field(r.b).redDivSqrt(this.b) : this.g.y.redDiv(this.field(r.g.y));
    }
    _scaleEdwards(r, x) {
      I(r instanceof E);
      const O = r._scale(this, x);
      return this.field(O);
    }
    _solveY0(r) {
      I(r instanceof c);
      const x = this.a0, O = this.b0, L = r.redSqr();
      return L.redMul(r).redIAdd(x.redMul(L)).redIAdd(O.redMul(r));
    }
    _elligator2(r) {
      const x = this.a0.redNeg(), O = this.one.redAdd(this.z.redMul(r.redSqr()));
      O.isZero() && O.inject(this.one);
      const L = x.redMul(O.redInvert()), X = L.redNeg().redISub(this.a0), P = this._solveY0(L), K = this._solveY0(X), re = P.redIsSquare() | 0, ce = [L, X][re ^ 1], le = [P, K][re ^ 1].redSqrt();
      le.redIsOdd() !== r.redIsOdd() && le.redINeg();
      const me = this.b.redMul(ce), ne = this.b.redMul(le);
      return this.point(me, ne);
    }
    _invert2(r, x) {
      const { x: O, y: L } = r, X = x & 1, P = O.redMul(this.bi), K = L.redMul(this.bi), re = P.redAdd(this.a0), ce = P, le = [re, ce][X].redINeg(), me = [ce, re][X].redMul(this.z), ne = le.redDivSqrt(me);
      return ne.redIsOdd() !== K.redIsOdd() && ne.redINeg(), ne;
    }
    isElliptic() {
      const r = this.a.redSqr();
      return !this.b.redMul(r.redSub(this.four)).isZero();
    }
    jinv() {
      const { a: r, three: x, four: O } = this, L = r.redSqr(), P = L.redSub(x).redPown(3).redIMuln(256), K = L.redSub(O);
      if (K.isZero())
        throw new Error("Curve is not elliptic.");
      return P.redDiv(K).fromRed();
    }
    point(r, x) {
      return new p(this, r, x);
    }
    jpoint(r, x, O) {
      return I(r == null && x == null && O == null), this.point();
    }
    xpoint(r, x) {
      return new m(this, r, x);
    }
    solveY2(r) {
      I(r instanceof c);
      const x = r.redSqr();
      return x.redMul(r).redIAdd(this.a.redMul(x)).redIAdd(r).redMul(this.bi);
    }
    validate(r) {
      if (I(r instanceof p), r.isInfinity())
        return !0;
      const { x, y: O } = r, L = this.solveY2(x);
      return O.redSqr().eq(L);
    }
    pointFromX(r, x = null) {
      I(r instanceof c), I(x == null || typeof x == "boolean"), r.red || (r = r.toRed(this.red));
      const O = this.solveY(r);
      if (x != null) {
        if (O.isZero() && x)
          throw new Error("Invalid point.");
        O.redIsOdd() !== x && O.redINeg();
      }
      return this.point(r, O);
    }
    isIsomorphic(r, x) {
      if (I(r instanceof f), !r.p.eq(this.p))
        return !1;
      if (r.type === "mont") {
        const O = this.field(r.a), L = this.field(r.b);
        return !this.a.eq(O) || this.b.isZero() ? !1 : L.redDiv(this.b).redJacobi() === 1;
      }
      return r.isIsomorphic(this, x);
    }
    isIsogenous(r) {
      return I(r instanceof f), r.type === "mont" ? !1 : r.isIsogenous(this);
    }
    pointFromShort(r) {
      if (I(r instanceof a), this.isIsomorphic(r.curve)) {
        if (r.isInfinity())
          return this.point();
        const { a3: x, b: O } = this, [L, X] = this._scale(r.curve), P = this.field(r.x).redMul(L), K = this.field(r.y).redMul(X), re = O.redMul(P).redISub(x), ce = O.redMul(K);
        return this.point(re, ce);
      }
      throw new Error("Not implemented.");
    }
    pointFromMont(r) {
      if (I(r instanceof p), this.isIsomorphic(r.curve)) {
        if (r.isInfinity())
          return this.point();
        const x = this._scale(r.curve), O = this.field(r.x), L = this.field(r.y), X = O, P = x.redMul(L);
        return this.point(X, P);
      }
      throw new Error("Not implemented.");
    }
    pointFromEdwards(r) {
      I(r instanceof v), I(r.curve.p.eq(this.p));
      const x = this.field(r.x), O = this.field(r.y), L = this.field(r.z);
      if (this.isIsogenous(r.curve)) {
        if (r.isInfinity())
          return this.point();
        if (r.x.isZero())
          return this.point(this.zero, this.zero);
        const X = L.redSqr().redIMuln(2), P = O.redSqr(), K = x.redSqr(), re = X.redISub(K).redISub(P).redMul(O), ce = K.redMul(x);
        return this.cpoint(P, K, re, ce);
      }
      if (this.isIsomorphic(r.curve, !0)) {
        if (r.isInfinity())
          return this.point();
        if (r.x.isZero())
          return this.point(this.zero, this.zero);
        const X = this._scale(r.curve, !0), P = O.redAdd(L), K = O.redSub(L), re = X.redMul(L).redMul(P), ce = x.redMul(K);
        return this.cpoint(P, K, re, ce);
      }
      if (this.isIsomorphic(r.curve, !1)) {
        if (r.isInfinity())
          return this.point();
        if (r.x.isZero())
          return this.point(this.zero, this.zero);
        const X = this._scale(r.curve, !1), P = L.redAdd(O), K = L.redSub(O), re = X.redMul(L).redMul(P), ce = x.redMul(K);
        return this.cpoint(P, K, re, ce);
      }
      throw new Error("Not implemented.");
    }
    pointFromUniform(r) {
      if (I(r instanceof c), this.z.isZero() || this.a.isZero())
        throw new Error("Not implemented.");
      return this._elligator2(r);
    }
    pointToUniform(r, x) {
      if (I(r instanceof p), I(x >>> 0 === x), this.z.isZero() || this.a.isZero())
        throw new Error("Not implemented.");
      if (r.isInfinity())
        throw new Error("Invalid point.");
      const O = (x >>> 4 & 15) % this.torsion.length, L = r.add(this.torsion[O]);
      return se(() => this._invert2(L, x));
    }
    decodePoint(r, x) {
      return p.decode(this, r, x);
    }
    encodeX(r) {
      return I(r instanceof m), r.encode();
    }
    decodeX(r) {
      return m.decode(this, r);
    }
    toShort(r, x, O = null) {
      const [L, X] = this._short(r, x), P = new u({
        red: this.red,
        prime: this.prime,
        p: this.p,
        a: L,
        b: X,
        n: this.n,
        h: this.h
      });
      if (O != null) {
        const [, K] = P._scale(this);
        K.redIsOdd() !== O && K.redINeg();
      }
      this.g.isInfinity() || (P.g = P.pointFromMont(this.g));
      for (let K = 0; K < this.h.word(0); K++)
        P.torsion[K] = P.pointFromMont(this.torsion[K]);
      return P;
    }
    toMont(r, x = null) {
      const [O, L] = this._mont(r), X = new i({
        red: this.red,
        prime: this.prime,
        p: this.p,
        a: O,
        b: L,
        n: this.n,
        h: this.h,
        z: this.z
      });
      if (x != null) {
        const P = X._scale(this);
        P.redIsOdd() !== x && P.redINeg();
      }
      this.g.isInfinity() || (X.g = X.pointFromMont(this.g));
      for (let P = 0; P < this.h.word(0); P++)
        X.torsion[P] = X.pointFromMont(this.torsion[P]);
      return X;
    }
    toEdwards(r, x, O = null) {
      const [L, X] = this._edwards(r, x), P = new E({
        red: this.red,
        prime: this.prime,
        p: this.p,
        a: L,
        d: X,
        n: this.n,
        h: this.h,
        z: this.z
      });
      if (O != null) {
        const K = P._scale(this, x);
        K.redIsOdd() !== O && K.redINeg();
      }
      if (this.g.isInfinity() || (P.g = P.pointFromMont(this.g), P.g.normalize()), P.isComplete())
        for (let K = 0; K < this.h.word(0); K++)
          P.torsion[K] = P.pointFromMont(this.torsion[K]), P.torsion[K].normalize();
      return P;
    }
    pointFromJSON(r) {
      return p.fromJSON(this, r);
    }
    toJSON(r) {
      const x = super.toJSON(r);
      return x.a = this.a.fromRed().toJSON(), x.b = this.b.fromRed().toJSON(), x;
    }
  }
  class p extends n {
    constructor(r, x, O) {
      I(r instanceof i), super(r, d.AFFINE), this.x = this.curve.zero, this.y = this.curve.zero, this.inf = !0, x != null && this._init(x, O);
    }
    _init(r, x) {
      I(r instanceof c), I(x instanceof c), this.x = r, this.y = x, this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1;
    }
    clone() {
      return this.inf ? this.curve.point() : this.curve.point(this.x, this.y);
    }
    scale(r) {
      return this.clone();
    }
    randomize(r) {
      return this.clone();
    }
    neg() {
      return this.inf ? this : this.curve.point(this.x, this.y.redNeg());
    }
    add(r) {
      if (I(r instanceof p), this.inf)
        return r;
      if (r.inf)
        return this;
      if (this.x.eq(r.x))
        return this.y.eq(r.y) ? this.dbl() : this.curve.point();
      const x = r.x.redSub(this.x), L = r.y.redSub(this.y).redDiv(x), P = this.curve.b.redMul(L.redSqr()).redISub(this.curve.a).redISub(this.x).redISub(r.x), K = L.redMul(this.x.redSub(P)).redISub(this.y);
      return this.curve.point(P, K);
    }
    dbl() {
      if (this.inf)
        return this;
      if (this.y.isZero())
        return this.curve.point();
      const r = this.x.redSqr().redIMuln(3), x = this.curve.a.redMul(this.x).redIMuln(2), O = r.redIAdd(x).redIAdd(this.curve.one), L = this.curve.b.redMul(this.y).redIMuln(2), X = O.redDiv(L), K = this.curve.b.redMul(X.redSqr()).redISub(this.curve.a).redISub(this.x).redISub(this.x), re = X.redMul(this.x.redSub(K)).redISub(this.y);
      return this.curve.point(K, re);
    }
    getX() {
      if (this.inf)
        throw new Error("Invalid point.");
      return this.x.fromRed();
    }
    getY() {
      if (this.inf)
        throw new Error("Invalid point.");
      return this.y.fromRed();
    }
    eq(r) {
      return I(r instanceof p), this === r ? !0 : this.inf ? r.inf : r.inf ? !1 : this.x.eq(r.x) && this.y.eq(r.y);
    }
    cmp(r) {
      return I(r instanceof p), this.inf && !r.inf ? -1 : !this.inf && r.inf ? 1 : this.inf && r.inf ? 0 : this.order().cmp(r.order()) || this.getX().cmp(r.getX()) || this.getY().cmp(r.getY());
    }
    isInfinity() {
      return this.inf;
    }
    isOrder2() {
      return this.inf ? !1 : this.y.isZero();
    }
    isOdd() {
      return this.inf ? !1 : this.y.redIsOdd();
    }
    isEven() {
      return this.inf ? !1 : this.y.redIsEven();
    }
    toP() {
      return this;
    }
    toJ() {
      return this;
    }
    toX() {
      return this.inf ? this.curve.xpoint() : this.curve.xpoint(this.x, this.curve.one);
    }
    encode() {
      return this.toX().encode();
    }
    static decode(r, x, O) {
      return I(r instanceof i), r.decodeX(x).toP(O);
    }
    toJSON(r) {
      if (this.inf)
        return [];
      const x = this.getX().toJSON(), O = this.getY().toJSON();
      return [x, O];
    }
    toPretty() {
      if (this.inf)
        return [];
      const r = this.curve.fieldSize * 2, x = M(this.getX(), r), O = M(this.getY(), r);
      return [x, O];
    }
    static fromJSON(r, x) {
      if (I(r instanceof i), I(Array.isArray(x)), I(x.length === 0 || x.length === 2 || x.length === 3), x.length === 0)
        return r.point();
      const O = c.fromJSON(x[0]), L = c.fromJSON(x[1]);
      return r.point(O, L);
    }
    [e]() {
      return this.inf ? "<MontPoint: Infinity>" : "<MontPoint: x=" + this.x.fromRed().toString(16, 2) + " y=" + this.y.fromRed().toString(16, 2) + ">";
    }
  }
  class m extends n {
    constructor(r, x, O) {
      I(r instanceof i), super(r, d.PROJECTIVE), this.x = this.curve.one, this.z = this.curve.zero, x != null && this._init(x, O);
    }
    _init(r, x) {
      I(r instanceof c), I(x == null || x instanceof c), this.x = r, this.z = x || this.curve.one, this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red));
    }
    clone() {
      return this.curve.xpoint(this.x, this.z);
    }
    precompute(r, x) {
      return this;
    }
    validate() {
      if (this.isInfinity())
        return !0;
      const { x: r, z: x } = this, O = r.redSqr(), L = O.redMul(r), X = x.redSqr(), P = this.curve.a.redMul(O).redMul(x);
      return L.redIAdd(P).redIAdd(r.redMul(X)).redMul(this.curve.bi).redMul(x).redJacobi() !== -1;
    }
    normalize() {
      return this.isInfinity() ? this : this.z.eq(this.curve.one) ? this : (this.x = this.x.redDiv(this.z), this.z = this.curve.one, this);
    }
    scale(r) {
      if (I(r instanceof c), this.isInfinity())
        return this.curve.xpoint();
      const x = this.x.redMul(r), O = this.z.redMul(r);
      return this.curve.xpoint(x, O);
    }
    neg() {
      return this;
    }
    dbl() {
      const x = this.x.redAdd(this.z).redSqr(), L = this.x.redSub(this.z).redSqr(), X = x.redSub(L), P = x.redMul(L), K = X.redMul(L.redIAdd(this.curve.a24.redMul(X)));
      return this.curve.xpoint(P, K);
    }
    diffAddDbl(r, x) {
      I(r instanceof m), I(x instanceof m);
      const O = r.x.redAdd(r.z), L = O.redSqr(), X = r.x.redSub(r.z), P = X.redSqr(), K = L.redSub(P), re = x.x.redAdd(x.z), le = x.x.redSub(x.z).redMul(O), me = re.redMul(X), ne = this.z.redMul(le.redAdd(me).redSqr()), W = this.x.redMul(le.redISub(me).redSqr()), te = L.redMul(P), pe = K.redMul(P.redIAdd(this.curve.a24.redMul(K)));
      return [
        this.curve.xpoint(te, pe),
        this.curve.xpoint(ne, W)
      ];
    }
    getX() {
      if (this.isInfinity())
        throw new Error("Invalid point.");
      return this.normalize(), this.x.fromRed();
    }
    getY(r) {
      return this.toP(r).getY();
    }
    eq(r) {
      if (I(r instanceof m), this === r)
        return !0;
      if (this.isInfinity())
        return r.isInfinity();
      if (r.isInfinity())
        return !1;
      if (this.z.eq(r.z))
        return this.x.eq(r.x);
      const x = this.x.redMul(r.z), O = r.x.redMul(this.z);
      return x.eq(O);
    }
    cmp(r) {
      I(r instanceof m);
      const x = this.isInfinity(), O = r.isInfinity();
      return x && !O ? -1 : !x && O ? 1 : x && O ? 0 : this.order().cmp(r.order()) || this.getX().cmp(r.getX());
    }
    isInfinity() {
      return this.z.isZero();
    }
    isOrder2() {
      return this.isInfinity() ? !1 : this.x.isZero();
    }
    isOdd() {
      return !1;
    }
    isEven() {
      return !1;
    }
    hasTorsion() {
      return this.isInfinity() ? !1 : this.x.isZero() ? !0 : super.hasTorsion();
    }
    order() {
      try {
        return this.toP().order();
      } catch {
        return new c(1);
      }
    }
    jmul(r) {
      I(r instanceof c), I(!r.red);
      const x = r.bitLength();
      let O = this.curve.xpoint(), L = this;
      for (let X = x - 1; X >= 0; X--)
        r.bit(X) === 0 ? [O, L] = this.diffAddDbl(O, L) : [L, O] = this.diffAddDbl(L, O);
      return O;
    }
    jmulBlind(r, x) {
      return x ? this.randomize(x).jmul(r) : this.jmul(r);
    }
    jmulAdd(r, x, O) {
      throw new Error("Not implemented.");
    }
    toP(r = null) {
      return I(r == null || typeof r == "boolean"), this.isInfinity() ? this.curve.point() : (this.normalize(), this.curve.pointFromX(this.x, r));
    }
    toJ() {
      return this;
    }
    toX() {
      return this;
    }
    key() {
      if (this.isInfinity())
        return `${this.curve.uid}:oo`;
      this.normalize();
      const r = this.getX().toString(16);
      return `${this.curve.uid}:${r}`;
    }
    encode() {
      return this.curve.encodeField(this.getX());
    }
    static decode(r, x) {
      I(r instanceof i);
      const O = r.decodeField(x);
      O.iumaskn(r.fieldBits);
      const L = r.xpoint(O, r.one);
      return I(!L.isInfinity()), L;
    }
    toJSON(r) {
      return this.toP().toJSON(r);
    }
    toPretty() {
      return this.toP().toPretty();
    }
    static fromJSON(r, x) {
      return p.fromJSON(r, x).toX();
    }
    [e]() {
      return this.isInfinity() ? "<XPoint: Infinity>" : "<XPoint: x=" + this.x.fromRed().toString(16, 2) + " z=" + this.z.fromRed().toString(16, 2) + ">";
    }
  }
  class E extends f {
    constructor(r) {
      super(v, "edwards", r), this.a = c.fromJSON(r.a).toRed(this.red), this.d = c.fromJSON(r.d).toRed(this.red), this.s = c.fromJSON(r.s || "0").toRed(this.red), this.si = this.s.isZero() ? this.zero : this.s.redInvert(), this.k = this.d.redMuln(2), this.smi = -this.d.redNeg().word(0), this.ad6 = this.a.redAdd(this.d).redMul(this.i6), this.twisted = !this.a.eq(this.one), this.oneA = this.a.eq(this.one), this.mOneA = this.a.eq(this.one.redNeg()), this.smallD = this.prime != null && this.d.redNeg().length === 1, this.alt = null, this._finalize(r);
    }
    static _isomorphism(r, x, O) {
      I(r instanceof c), I(x instanceof c), I(O instanceof c);
      const L = O.clone(), X = O.redMul(x).redDiv(r);
      if (r.redDiv(O).redJacobi() !== 1)
        throw new Error("Invalid `a` coefficient.");
      return [L, X];
    }
    _short(r, x) {
      const { a: O, d: L } = this, X = O.redSqr(), P = X.redMul(O), K = L.redSqr(), re = K.redMul(L), ce = O.redMul(L).redIMuln(14), le = X.redMul(L), me = O.redMul(K), ne = le.redIAdd(me).redIMuln(33), W = X.redAdd(ce).redIAdd(K).redDivn(-48), te = ne.redISub(P).redISub(re).redDivn(864);
      return r != null ? u._isomorphism(W, te, r, x) : [W, te];
    }
    _mont(r, x = !1) {
      I(typeof x == "boolean");
      let O, L;
      x ? (O = this.d.redAdd(this.a), L = this.d.redSub(this.a)) : (O = this.a.redAdd(this.d), L = this.a.redSub(this.d));
      const X = L.redInvert(), P = O.redMuln(2).redMul(X), K = X.redMuln(4);
      return r != null ? i._isomorphism(P, K, r) : [P, K];
    }
    _edwards(r) {
      return E._isomorphism(this.a, this.d, r);
    }
    _scaleShort(r) {
      I(r instanceof u);
      const [x, O] = r._scale(this);
      return [
        this.field(x.redInvert()),
        this.field(O.redInvert())
      ];
    }
    _scaleMont(r, x = !1) {
      if (I(r instanceof i), I(typeof x == "boolean"), this.g.isInfinity() || r.g.isInfinity()) {
        const [L] = r._edwards(null, x);
        return this.field(L).redDivSqrt(this.a);
      }
      const O = r.g.x.redDiv(r.g.y);
      return this.g.x.redDiv(this.field(O));
    }
    _scaleEdwards(r) {
      return I(r instanceof E), this.g.isInfinity() || r.g.isInfinity() ? this.field(r.a).redDivSqrt(this.a) : this.g.x.redDiv(this.field(r.g.x));
    }
    _mulA(r) {
      return I(r instanceof c), this.oneA ? r.clone() : this.mOneA ? r.redNeg() : this.a.redMul(r);
    }
    _mulD(r) {
      return I(r instanceof c), this.smallD ? r.redMuln(this.smi) : this.d.redMul(r);
    }
    _elligator1(r) {
      const { s: x, si: O, i2: L, one: X, two: P } = this, K = O.redSqr().redIMuln(2), re = x.redSqr().redMul(L), ce = re.redSqr(), le = K.redAdd(re), me = le.redSqr().redISub(P), ne = K.redSub(X), W = X.redSub(r), te = X.redAdd(r), pe = te.isZero() ? te : W.redDiv(te), Ee = pe.redSqr(), Ae = Ee.redMul(pe), Be = Ae.redMul(Ee).redAdd(me.redMul(Ae)).redIAdd(pe), ke = this.field(Be.redJacobi()), Ne = this.field(Ee.redAdd(ce).redJacobi()), Ke = ke.redMul(Ne), Ce = ke.redMul(pe), Ye = ke.redMul(Be).redSqrt().redMul(Ke), vt = X.redAdd(Ce), Ve = le.redMul(Ce), Xe = vt.redSqr(), qt = ne.redMul(x).redMul(Ce).redMul(vt), Ge = pe.isZero() ? this.one : Ye, Je = Ve.redSub(Xe), Rt = Ve.redAdd(Xe);
      return this.cpoint(qt, Ge, Je, Rt);
    }
    _invert1(r, x) {
      const { s: O, si: L, i2: X, one: P } = this, { x: K, y: re, z: ce } = r, le = x & 1, me = L.redSqr().redIMuln(2), ne = O.redSqr().redMul(X), W = ne.redSqr(), te = me.redAdd(ne), pe = me.redSub(P), Ee = re.redSub(ce), Ae = re.redAdd(ce).redIMuln(2), Oe = Ae.isZero() ? Ae : Ee.redDiv(Ae), Be = P.redAdd(Oe.redMul(te)), Ke = Be.redSqr().redISub(P).redSqrt().redSub(Be), Ce = P.redAdd(Ke), vt = pe.redMul(O).redMul(Ke).redMul(Ce).redMul(K.redMul(ce)), Ve = Ke.redSqr().redIAdd(W), qt = this.field(vt.redMul(Ve).redJacobi()).redMul(Ke), Ge = P.redSub(qt), Je = P.redAdd(qt), Rt = Je.isZero() ? Je : Ge.redDiv(Je);
      return Rt.redIsOdd() !== !!le && Rt.redINeg(), Rt;
    }
    _alt() {
      return this.alt || (this.alt = this.toMont()), this.alt;
    }
    isElliptic() {
      const r = this.a.redMul(this.d), x = this.a.redSub(this.d);
      return !r.redMul(x).isZero();
    }
    jinv() {
      const { a: r, d: x } = this, O = r.redMul(x), L = r.redSub(x).redPown(4), X = r.redSqr(), P = x.redSqr(), re = X.redAdd(O.redMuln(14)).redIAdd(P).redPown(3).redIMuln(16), ce = O.redMul(L);
      if (ce.isZero())
        throw new Error("Curve is not elliptic.");
      return re.redDiv(ce).fromRed();
    }
    isComplete() {
      return this.a.redJacobi() === 1 && this.d.redJacobi() === -1;
    }
    point(r, x, O, L) {
      return new v(this, r, x, O, L);
    }
    jpoint(r, x, O) {
      return I(r == null && x == null && O == null), this.point();
    }
    cpoint(r, x, O, L) {
      I(r instanceof c), I(x instanceof c), I(O instanceof c), I(L instanceof c);
      const X = r.redMul(L), P = O.redMul(x), K = x.redMul(L), re = r.redMul(O);
      return this.point(X, P, K, re);
    }
    solveX2(r) {
      I(r instanceof c);
      const x = r.redSqr(), O = this._mulD(x).redISub(this.a);
      return x.redISub(this.one).redDiv(O);
    }
    solveX(r) {
      const x = r.redSqr(), O = this._mulD(x).redISub(this.a);
      return x.redISub(this.one).redDivSqrt(O);
    }
    solveY2(r) {
      I(r instanceof c);
      const x = r.redSqr(), O = this._mulA(x).redISub(this.one), L = this._mulD(x).redISub(this.one);
      return O.redDiv(L);
    }
    solveY(r) {
      const x = r.redSqr(), O = this._mulA(x).redISub(this.one), L = this._mulD(x).redISub(this.one);
      return O.redDivSqrt(L);
    }
    validate(r) {
      if (I(r instanceof v), r.zOne) {
        const me = r.x.redSqr(), ne = r.y.redSqr(), W = this._mulD(me).redMul(ne), te = this._mulA(me).redIAdd(ne), pe = this.one.redAdd(W), Ee = r.t, Ae = r.x.redMul(r.y);
        return te.eq(pe) && Ee.eq(Ae);
      }
      const x = r.x.redSqr(), O = r.y.redSqr(), L = r.z.redSqr(), X = L.redSqr(), P = this._mulD(x).redMul(O), K = this._mulA(x).redIAdd(O).redMul(L), re = X.redIAdd(P), ce = r.t.redMul(r.z), le = r.x.redMul(r.y);
      return K.eq(re) && ce.eq(le);
    }
    pointFromX(r, x = null) {
      I(r instanceof c), I(x == null || typeof x == "boolean"), r.red || (r = r.toRed(this.red));
      const O = this.solveY(r);
      if (x != null) {
        if (O.isZero() && x)
          throw new Error("Invalid point.");
        O.redIsOdd() !== x && O.redINeg();
      }
      return this.point(r, O);
    }
    pointFromY(r, x = null) {
      I(r instanceof c), I(x == null || typeof x == "boolean"), r.red || (r = r.toRed(this.red));
      const O = this.solveX(r);
      if (x != null) {
        if (O.isZero() && x)
          throw new Error("Invalid point.");
        O.redIsOdd() !== x && O.redINeg();
      }
      return this.point(O, r);
    }
    isIsomorphic(r, x = !1) {
      if (I(r instanceof f), I(typeof x == "boolean"), !r.p.eq(this.p))
        return !1;
      if (r.type === "short")
        return r.isIsomorphic(this);
      if (r.type === "mont") {
        const O = this.field(r.a);
        let L, X;
        return x ? (L = this.d.redAdd(this.a), X = this.d.redSub(this.a)) : (L = this.a.redAdd(this.d), X = this.a.redSub(this.d)), O.redMul(X).eq(L.redIMuln(2));
      }
      if (r.type === "edwards") {
        const O = this.field(r.a), L = this.field(r.d);
        return this.a.redMul(L).eq(O.redMul(this.d));
      }
      return !1;
    }
    isIsogenous(r) {
      if (I(r instanceof f), !r.p.eq(this.p))
        return !1;
      if (r.type === "mont") {
        if (!this.a.eq(this.one))
          return !1;
        const x = this.field(r.a), O = this.field(r.b), L = this.two.redSub(this.d.redMuln(4));
        return x.eq(L) && O.eq(this.one);
      }
      if (r.type === "edwards") {
        const x = this.field(r.a), O = this.field(r.d);
        return x.eq(this.a.redNeg()) && O.eq(this.d.redSub(this.a));
      }
      return !1;
    }
    pointFromShort(r) {
      if (I(r instanceof a), this.isIsomorphic(r.curve)) {
        if (r.isInfinity())
          return this.point();
        if (r.y.isZero())
          return this.point(this.zero, this.one.redNeg());
        const { a: x, d: O } = this, [L, X] = this._scale(r.curve), P = x.redMuln(5), K = O.redMuln(5), re = this.field(r.x).redMul(L), ce = this.field(r.y).redMul(X), le = re.redMuln(6), me = re.redMuln(12), ne = le.redSub(x).redISub(O), W = ce.redMuln(6), te = me.redSub(P).redIAdd(O), pe = me.redAdd(x).redISub(K);
        return this.cpoint(ne, W, te, pe);
      }
      throw new Error("Not implemented.");
    }
    pointFromMont(r) {
      I(r instanceof p), I(r.curve.p.eq(this.p));
      const x = this.field(r.x), O = this.field(r.y);
      if (this.isIsogenous(r.curve)) {
        if (r.isInfinity())
          return this.point();
        if (r.x.isZero())
          return this.point();
        const L = x.redSqr(), X = L.redMul(x), P = X.redMul(x), K = P.redMul(x), re = O.redSqr(), ce = O.redMuln(4), le = L.redSub(this.one), me = L.redMuln(2), ne = re.redMuln(4), W = X.redIMuln(2), te = x.redMul(re).redIMuln(4), pe = L.redMul(re).redIMuln(2), Ee = re.redIMuln(2), Ae = ce.redMul(le), Oe = P.redISub(me).redIAdd(ne).redIAdd(this.one), Be = K.redSub(W).redISub(te).redIAdd(x).redINeg(), ke = K.redISub(pe).redISub(W).redISub(Ee).redIAdd(x);
        return this.cpoint(Ae, Oe, Be, ke).divn(4);
      }
      if (this.isIsomorphic(r.curve, !0)) {
        if (r.isInfinity())
          return this.point();
        if (r.x.isZero())
          return this.point(this.zero, this.one.redNeg());
        const X = this._scale(r.curve, !0).redMul(x), P = O, K = x.redAdd(this.one), re = x.redSub(this.one);
        return this.cpoint(X, P, K, re);
      }
      if (this.isIsomorphic(r.curve, !1)) {
        if (r.isInfinity())
          return this.point();
        if (r.x.isZero())
          return this.point(this.zero, this.one.redNeg());
        const X = this._scale(r.curve, !1).redMul(x), P = O, K = x.redSub(this.one), re = x.redAdd(this.one);
        return this.cpoint(X, P, K, re);
      }
      throw new Error("Not implemented.");
    }
    pointFromEdwards(r) {
      I(r instanceof v), I(r.curve.p.eq(this.p));
      const x = this.field(r.curve.a), O = this.field(r.x), L = this.field(r.y), X = this.field(r.z), P = this.field(r.t);
      if (this.isIsogenous(r.curve)) {
        const K = O.redMul(L), re = O.redSqr(), ce = L.redSqr(), le = X.redSqr(), me = x.redMul(re), ne = K.redIMuln(2), W = ce.redSub(me), te = ce.redAdd(me), pe = le.redIMuln(2).redISub(te), Ee = this.cpoint(ne, W, te, pe);
        return this.twisted ? Ee : Ee.divn(4);
      }
      if (this.isIsomorphic(r.curve)) {
        const K = this._scale(r.curve), re = K.redMul(O), ce = L, le = X, me = K.redMul(P);
        return this.point(re, ce, le, me);
      }
      throw new Error("Not implemented.");
    }
    pointFromUniform(r, x = null) {
      I(r instanceof c), I(r.red === this.red), I(x == null || x instanceof i), x || (x = this._alt());
      const O = x.field(r), L = x.pointFromUniform(O);
      return this.pointFromMont(L);
    }
    pointToUniform(r, x, O = null) {
      I(r instanceof v), I(x >>> 0 === x), I(O == null || O instanceof i), O || (O = this._alt());
      const L = (x >> 4 & 15) % this.torsion.length, X = r.add(this.torsion[L]), P = O.pointFromEdwards(X), K = O.pointToUniform(P, x & 15);
      return this.field(K);
    }
    pointFromHash(r, x, O = null) {
      I(O == null || O instanceof i), O || (O = this._alt());
      const L = O.pointFromHash(r, x);
      return this.pointFromMont(L);
    }
    pointToHash(r, x, O, L = null) {
      I(r instanceof v), I(x >>> 0 === x), I(L == null || L instanceof i), L || (L = this._alt());
      const X = x % this.torsion.length, P = r.add(this.torsion[X]), K = L.pointFromEdwards(P);
      return L.pointToHash(K, 0, O);
    }
    decodePoint(r) {
      return v.decode(this, r);
    }
    toShort(r, x, O = null) {
      const [L, X] = this._short(r, x), P = new u({
        red: this.red,
        prime: this.prime,
        p: this.p,
        a: L,
        b: X,
        n: this.n,
        h: this.h
      });
      if (O != null) {
        const [, K] = P._scale(this);
        K.redIsOdd() !== O && K.redINeg();
      }
      this.g.isInfinity() || (P.g = P.pointFromEdwards(this.g));
      for (let K = 0; K < this.h.word(0); K++)
        P.torsion[K] = P.pointFromEdwards(this.torsion[K]);
      return P;
    }
    toMont(r, x, O = null) {
      const [L, X] = this._mont(r, x), P = new i({
        red: this.red,
        prime: this.prime,
        p: this.p,
        a: L,
        b: X,
        n: this.n,
        h: this.h,
        z: this.z
      });
      if (O != null) {
        const K = this._scale(P, x);
        K.redIsOdd() !== O && K.redINeg();
      }
      this.g.isInfinity() || (P.g = P.pointFromEdwards(this.g));
      for (let K = 0; K < this.h.word(0); K++)
        P.torsion[K] = P.pointFromEdwards(this.torsion[K]);
      return P;
    }
    toEdwards(r, x = null) {
      const [O, L] = this._edwards(r), X = new E({
        red: this.red,
        prime: this.prime,
        p: this.p,
        a: O,
        d: L,
        n: this.n,
        h: this.h,
        z: this.z
      });
      if (x != null) {
        const P = X._scale(this);
        P.redIsOdd() !== x && P.redINeg();
      }
      if (this.g.isInfinity() || (X.g = X.pointFromEdwards(this.g), X.g.normalize()), X.isComplete())
        for (let P = 0; P < this.h.word(0); P++)
          X.torsion[P] = X.pointFromEdwards(this.torsion[P]), X.torsion[P].normalize();
      return X;
    }
    pointFromJSON(r) {
      return v.fromJSON(this, r);
    }
    toJSON(r) {
      const x = super.toJSON(r);
      return x.a = this.a.fromRed().toJSON(), x.d = this.d.fromRed().toJSON(), this.s.isZero() || (x.s = this.s.fromRed().toJSON()), x;
    }
  }
  class v extends n {
    constructor(r, x, O, L, X) {
      I(r instanceof E), super(r, d.EXTENDED), this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = !0, x != null && this._init(x, O, L, X);
    }
    _init(r, x, O, L) {
      I(r instanceof c), I(x instanceof c), I(O == null || O instanceof c), I(L == null || L instanceof c), this.x = r, this.y = x, this.z = O || this.curve.one, this.t = L || null, this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z.eq(this.curve.one), this._check(), this.t || (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redDiv(this.z)));
    }
    _check() {
      if (this.z.isZero())
        throw new Error("Invalid point.");
    }
    clone() {
      return this.curve.point(this.x, this.y, this.z, this.t);
    }
    normalize() {
      if (this.zOne)
        return this;
      const r = this.z.redInvert();
      return this.x = this.x.redMul(r), this.y = this.y.redMul(r), this.t = this.t.redMul(r), this.z = this.curve.one, this.zOne = !0, this;
    }
    scale(r) {
      I(r instanceof c);
      const x = this.x.redMul(r), O = this.y.redMul(r), L = this.z.redMul(r), X = this.t.redMul(r);
      return this.curve.point(x, O, L, X);
    }
    neg() {
      const r = this.x.redNeg(), x = this.y, O = this.z, L = this.t.redNeg();
      return this.curve.point(r, x, O, L);
    }
    add(r) {
      return I(r instanceof v), this.isInfinity() ? r : r.isInfinity() ? this : this.zOne ? r._add(this) : this._add(r);
    }
    _add(r) {
      return this.curve.mOneA ? this._addM1(r) : this._addA(r);
    }
    _addM1(r) {
      const x = this.y.redSub(this.x).redMul(r.y.redSub(r.x)), O = this.y.redAdd(this.x).redMul(r.y.redAdd(r.x)), L = this.t.redMul(this.curve.k).redMul(r.t), X = r.zOne ? this.z.redAdd(this.z) : this.z.redMul(r.z).redIMuln(2), P = O.redSub(x), K = X.redSub(L), re = X.redIAdd(L), ce = O.redIAdd(x), le = P.redMul(K), me = re.redMul(ce), ne = P.redMul(ce), W = K.redMul(re);
      return this.curve.point(le, me, W, ne);
    }
    _addA(r) {
      const x = this.x.redMul(r.x), O = this.y.redMul(r.y), L = this.curve._mulD(this.t).redMul(r.t), X = r.zOne ? this.z.clone() : this.z.redMul(r.z), K = this.x.redAdd(this.y).redMul(r.x.redAdd(r.y)).redISub(x).redISub(O), re = X.redSub(L), ce = X.redIAdd(L), le = O.redISub(this.curve._mulA(x)), me = K.redMul(re), ne = ce.redMul(le), W = K.redMul(le), te = re.redMul(ce);
      return this.curve.point(me, ne, te, W);
    }
    dbl() {
      return this.isInfinity() ? this : this._dbl();
    }
    _dbl() {
      const r = this.x.redSqr(), x = this.y.redSqr(), O = this.zOne ? this.curve.two : this.z.redSqr().redIMuln(2), L = this.curve._mulA(r), X = this.x.redAdd(this.y).redSqr().redISub(r).redISub(x), P = L.redAdd(x), K = P.redSub(O), re = L.redISub(x), ce = X.redMul(K), le = P.redMul(re), me = X.redMul(re), ne = K.redMul(P);
      return this.curve.point(ce, le, ne, me);
    }
    getX() {
      return this.normalize(), this.x.fromRed();
    }
    getY() {
      return this.normalize(), this.y.fromRed();
    }
    eq(r) {
      if (I(r instanceof v), I(!this.z.isZero()), I(!r.z.isZero()), this === r)
        return !0;
      if (this.z.eq(r.z))
        return this.x.eq(r.x) && this.y.eq(r.y);
      const x = this.x.redMul(r.z), O = r.x.redMul(this.z);
      if (!x.eq(O))
        return !1;
      const L = this.y.redMul(r.z), X = r.y.redMul(this.z);
      return L.eq(X);
    }
    cmp(r) {
      return I(r instanceof v), this.order().cmp(r.order()) || this.getY().cmp(r.getY()) || this.getX().cmp(r.getX());
    }
    isInfinity() {
      return I(!this.z.isZero()), this.x.isZero() ? this.y.eq(this.z) : !1;
    }
    isOrder2() {
      return this.isInfinity() ? !1 : this.x.isZero();
    }
    isOdd() {
      return this.normalize(), this.x.redIsOdd();
    }
    isEven() {
      return this.normalize(), this.x.redIsEven();
    }
    toP() {
      return this.normalize();
    }
    toJ() {
      return this;
    }
    encode() {
      const r = this.getY();
      return r.setn(this.curve.signBit, this.x.redIsOdd()), this.curve.encodeAdjusted(r);
    }
    static decode(r, x) {
      I(r instanceof E);
      const O = r.decodeAdjusted(x), L = O.testn(r.signBit) !== 0;
      if (O.setn(r.signBit, 0), O.cmp(r.p) >= 0)
        throw new Error("Invalid point.");
      return r.pointFromY(O, L);
    }
    toJSON(r) {
      if (this.isInfinity())
        return [];
      const x = this.getX().toJSON(), O = this.getY().toJSON();
      return r === !0 && this.pre ? [x, O, this.pre.toJSON()] : [x, O];
    }
    toPretty() {
      const r = this.curve.fieldSize * 2, x = M(this.getX(), r), O = M(this.getY(), r);
      return [x, O];
    }
    static fromJSON(r, x) {
      if (I(r instanceof E), I(Array.isArray(x)), I(x.length === 0 || x.length === 2 || x.length === 3), x.length === 0)
        return r.point();
      const O = c.fromJSON(x[0]), L = c.fromJSON(x[1]), X = r.point(O, L);
      return x.length > 2 && x[2] != null && (X.pre = b.fromJSON(X, x[2])), X;
    }
    [e]() {
      return this.isInfinity() ? "<EdwardsPoint: Infinity>" : "<EdwardsPoint: x=" + this.x.fromRed().toString(16, 2) + " y=" + this.y.fromRed().toString(16, 2) + " z=" + this.z.fromRed().toString(16, 2) + ">";
    }
  }
  class b {
    constructor() {
      this.naf = null, this.windows = null, this.doubles = null, this.blinding = null, this.beta = null;
    }
    map(r) {
      I(typeof r == "function");
      const x = new this.constructor();
      return this.naf && (x.naf = this.naf.map(r)), this.doubles && (x.doubles = this.doubles.map(r)), x;
    }
    toJSON() {
      return {
        naf: this.naf ? this.naf.toJSON() : null,
        windows: this.windows ? this.windows.toJSON() : null,
        doubles: this.doubles ? this.doubles.toJSON() : null,
        blinding: this.blinding ? this.blinding.toJSON() : void 0
      };
    }
    fromJSON(r, x) {
      return I(r instanceof n), I(x && typeof x == "object"), x.naf != null && (this.naf = h.fromJSON(r, x.naf)), x.windows != null && (this.windows = o.fromJSON(r, x.windows)), x.doubles != null && (this.doubles = S.fromJSON(r, x.doubles)), x.blinding != null && (this.blinding = H.fromJSON(r, x.blinding)), this;
    }
    static fromJSON(r, x) {
      return new this().fromJSON(r, x);
    }
  }
  class h {
    constructor(r, x) {
      this.width = r, this.points = x;
    }
    map(r) {
      I(typeof r == "function");
      const { width: x } = this, O = [];
      for (const L of this.points)
        O.push(r(L));
      return new this.constructor(x, O);
    }
    toJSON() {
      return {
        width: this.width,
        points: this.points.slice(1).map((r) => r.toJSON())
      };
    }
    static fromJSON(r, x) {
      I(r instanceof n), I(x && typeof x == "object"), I(x.width >>> 0 === x.width), I(Array.isArray(x.points));
      const { curve: O } = r, { width: L } = x, X = [r];
      for (const P of x.points)
        X.push(O.pointFromJSON(P));
      return new this(L, X);
    }
  }
  class o {
    constructor(r, x, O) {
      this.width = r, this.bits = x, this.points = O;
    }
    toJSON() {
      return {
        width: this.width,
        bits: this.bits,
        points: this.points.slice(1).map((r) => r.toJSON())
      };
    }
    static fromJSON(r, x) {
      I(r instanceof n), I(x && typeof x == "object"), I(x.width >>> 0 === x.width), I(x.bits >>> 0 === x.bits), I(Array.isArray(x.points));
      const { curve: O } = r, { width: L, bits: X } = x, P = [r];
      for (const K of x.points)
        P.push(O.pointFromJSON(K));
      return new this(L, X, P);
    }
  }
  class S {
    constructor(r, x) {
      this.step = r, this.points = x;
    }
    map(r) {
      I(typeof r == "function");
      const { step: x } = this, O = [];
      for (const L of this.points)
        O.push(r(L));
      return new this.constructor(x, O);
    }
    toJSON() {
      return {
        step: this.step,
        points: this.points.slice(1).map((r) => r.toJSON())
      };
    }
    static fromJSON(r, x) {
      I(r instanceof n), I(x && typeof x == "object"), I(x.step >>> 0 === x.step), I(Array.isArray(x.points));
      const { curve: O } = r, { step: L } = x, X = [r];
      for (const P of x.points)
        X.push(O.pointFromJSON(P));
      return new this(L, X);
    }
  }
  class H {
    constructor(r, x) {
      this.blind = r, this.unblind = x;
    }
    toJSON() {
      return {
        blind: this.blind.toJSON(),
        unblind: this.unblind.toJSON()
      };
    }
    static fromJSON(r, x) {
      I(r instanceof n), I(x && typeof x == "object");
      const { curve: O } = r, L = c.fromJSON(x.blind), X = O.pointFromJSON(x.unblind);
      return new this(L, X);
    }
  }
  class j {
    constructor(r, x, O, L) {
      this.beta = r, this.lambda = x, this.basis = O, this.pre = L;
    }
    toJSON() {
      return {
        beta: this.beta.fromRed().toJSON(),
        lambda: this.lambda.toJSON(),
        basis: [
          this.basis[0].toJSON(),
          this.basis[1].toJSON()
        ],
        pre: [
          this.pre[0],
          this.pre[1].toJSON(),
          this.pre[2].toJSON()
        ]
      };
    }
    static fromJSON(r, x) {
      I(r instanceof f), I(x && typeof x == "object"), I(Array.isArray(x.basis)), I(Array.isArray(x.pre)), I(x.basis.length === 2), I(x.pre.length === 3), I(x.pre[0] >>> 0 === x.pre[0]);
      const O = c.fromJSON(x.beta).toRed(r.red), L = c.fromJSON(x.lambda), X = [
        J.fromJSON(x.basis[0]),
        J.fromJSON(x.basis[1])
      ], P = [
        x.pre[0],
        c.fromJSON(x.pre[1]),
        c.fromJSON(x.pre[2])
      ];
      return new this(O, L, X, P);
    }
  }
  class J {
    constructor(r, x) {
      this.a = r, this.b = x;
    }
    toJSON() {
      return {
        a: this.a.toJSON(),
        b: this.b.toJSON()
      };
    }
    static fromJSON(r) {
      I(r && typeof r == "object");
      const x = c.fromJSON(r.a), O = c.fromJSON(r.b);
      return new this(x, O);
    }
  }
  class N extends u {
    constructor(r) {
      super({
        id: "P192",
        ossl: "prime192v1",
        type: "short",
        endian: "be",
        hash: "SHA256",
        prime: "p192",
        // 2^192 - 2^64 - 1 (= 3 mod 4)
        p: [
          "ffffffff ffffffff ffffffff fffffffe",
          "ffffffff ffffffff"
        ],
        // -3 mod p
        a: [
          "ffffffff ffffffff ffffffff fffffffe",
          "ffffffff fffffffc"
        ],
        b: [
          "64210519 e59c80e7 0fa7e9ab 72243049",
          "feb8deec c146b9b1"
        ],
        n: [
          "ffffffff ffffffff ffffffff 99def836",
          "146bc9b1 b4d22831"
        ],
        h: "1",
        // Icart
        z: "-5",
        g: [
          [
            "188da80e b03090f6 7cbf20eb 43a18800",
            "f4ff0afd 82ff1012"
          ],
          [
            "07192b95 ffc8da78 631011ed 6b24cdd5",
            "73f977a1 1e794811"
          ],
          r
        ]
      });
    }
  }
  class z extends u {
    constructor(r) {
      super({
        id: "P224",
        ossl: "secp224r1",
        type: "short",
        endian: "be",
        hash: "SHA256",
        prime: "p224",
        // 2^224 - 2^96 + 1 (1 mod 16)
        p: [
          "ffffffff ffffffff ffffffff ffffffff",
          "00000000 00000000 00000001"
        ],
        // -3 mod p
        a: [
          "ffffffff ffffffff ffffffff fffffffe",
          "ffffffff ffffffff fffffffe"
        ],
        b: [
          "b4050a85 0c04b3ab f5413256 5044b0b7",
          "d7bfd8ba 270b3943 2355ffb4"
        ],
        n: [
          "ffffffff ffffffff ffffffff ffff16a2",
          "e0b8f03e 13dd2945 5c5c2a3d"
        ],
        h: "1",
        // SSWU
        z: "1f",
        g: [
          [
            "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3",
            "56c21122 343280d6 115c1d21"
          ],
          [
            "bd376388 b5f723fb 4c22dfe6 cd4375a0",
            "5a074764 44d58199 85007e34"
          ],
          r
        ]
      });
    }
  }
  class A extends u {
    constructor(r) {
      super({
        id: "P256",
        ossl: "prime256v1",
        type: "short",
        endian: "be",
        hash: "SHA256",
        prime: null,
        // 2^256 - 2^224 + 2^192 + 2^96 - 1 (= 3 mod 4)
        p: [
          "ffffffff 00000001 00000000 00000000",
          "00000000 ffffffff ffffffff ffffffff"
        ],
        // -3 mod p
        a: [
          "ffffffff 00000001 00000000 00000000",
          "00000000 ffffffff ffffffff fffffffc"
        ],
        b: [
          "5ac635d8 aa3a93e7 b3ebbd55 769886bc",
          "651d06b0 cc53b0f6 3bce3c3e 27d2604b"
        ],
        n: [
          "ffffffff 00000000 ffffffff ffffffff",
          "bce6faad a7179e84 f3b9cac2 fc632551"
        ],
        h: "1",
        // SSWU
        z: "-a",
        g: [
          [
            "6b17d1f2 e12c4247 f8bce6e5 63a440f2",
            "77037d81 2deb33a0 f4a13945 d898c296"
          ],
          [
            "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16",
            "2bce3357 6b315ece cbb64068 37bf51f5"
          ],
          r
        ]
      });
    }
  }
  class q extends u {
    constructor(r) {
      super({
        id: "P384",
        ossl: "secp384r1",
        type: "short",
        endian: "be",
        hash: "SHA384",
        prime: null,
        // 2^384 - 2^128 - 2^96 + 2^32 - 1 (= 3 mod 4)
        p: [
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff ffffffff fffffffe",
          "ffffffff 00000000 00000000 ffffffff"
        ],
        // -3 mod p
        a: [
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff ffffffff fffffffe",
          "ffffffff 00000000 00000000 fffffffc"
        ],
        b: [
          "b3312fa7 e23ee7e4 988e056b e3f82d19",
          "181d9c6e fe814112 0314088f 5013875a",
          "c656398d 8a2ed19d 2a85c8ed d3ec2aef"
        ],
        n: [
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff c7634d81 f4372ddf",
          "581a0db2 48b0a77a ecec196a ccc52973"
        ],
        h: "1",
        // Icart
        z: "-c",
        g: [
          [
            "aa87ca22 be8b0537 8eb1c71e f320ad74",
            "6e1d3b62 8ba79b98 59f741e0 82542a38",
            "5502f25d bf55296c 3a545e38 72760ab7"
          ],
          [
            "3617de4a 96262c6f 5d9e98bf 9292dc29",
            "f8f41dbd 289a147c e9da3113 b5f0b8c0",
            "0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
          ],
          r
        ]
      });
    }
  }
  class _ extends u {
    constructor(r) {
      super({
        id: "P521",
        ossl: "secp521r1",
        type: "short",
        endian: "be",
        hash: "SHA512",
        prime: "p521",
        // 2^521 - 1 (= 3 mod 4)
        p: [
          "000001ff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff"
        ],
        // -3 mod p
        a: [
          "000001ff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff ffffffff ffffffff",
          "fffffffc"
        ],
        b: [
          "00000051 953eb961 8e1c9a1f 929a21a0",
          "b68540ee a2da725b 99b315f3 b8b48991",
          "8ef109e1 56193951 ec7e937b 1652c0bd",
          "3bb1bf07 3573df88 3d2c34f1 ef451fd4",
          "6b503f00"
        ],
        n: [
          "000001ff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff ffffffff ffffffff",
          "fffffffa 51868783 bf2f966b 7fcc0148",
          "f709a5d0 3bb5c9b8 899c47ae bb6fb71e",
          "91386409"
        ],
        h: "1",
        // SSWU
        z: "-4",
        g: [
          [
            "000000c6 858e06b7 0404e9cd 9e3ecb66",
            "2395b442 9c648139 053fb521 f828af60",
            "6b4d3dba a14b5e77 efe75928 fe1dc127",
            "a2ffa8de 3348b3c1 856a429b f97e7e31",
            "c2e5bd66"
          ],
          [
            "00000118 39296a78 9a3bc004 5c8a5fb4",
            "2c7d1bd9 98f54449 579b4468 17afbd17",
            "273e662c 97ee7299 5ef42640 c550b901",
            "3fad0761 353c7086 a272c240 88be9476",
            "9fd16650"
          ],
          r
        ]
      });
    }
  }
  class F extends u {
    constructor(r) {
      super({
        id: "SECP256K1",
        ossl: "secp256k1",
        type: "short",
        endian: "be",
        hash: "SHA256",
        prime: "k256",
        // 2^256 - 2^32 - 977 (= 3 mod 4)
        p: [
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff fffffffe fffffc2f"
        ],
        a: "0",
        b: "7",
        n: [
          "ffffffff ffffffff ffffffff fffffffe",
          "baaedce6 af48a03b bfd25e8c d0364141"
        ],
        h: "1",
        // SVDW
        z: "1",
        // sqrt(-3)
        c: [
          "0a2d2ba9 3507f1df 233770c2 a797962c",
          "c61f6d15 da14ecd4 7d8d27ae 1cd5f852"
        ],
        g: [
          [
            "79be667e f9dcbbac 55a06295 ce870b07",
            "029bfcdb 2dce28d9 59f2815b 16f81798"
          ],
          [
            "483ada77 26a3c465 5da4fbfc 0e1108a8",
            "fd17b448 a6855419 9c47d08f fb10d4b8"
          ],
          r
        ],
        // Precomputed endomorphism.
        endo: {
          beta: [
            "7ae96a2b 657c0710 6e64479e ac3434e9",
            "9cf04975 12f58995 c1396c28 719501ee"
          ],
          lambda: [
            "5363ad4c c05c30e0 a5261c02 8812645a",
            "122e22ea 20816678 df02967c 1b23bd72"
          ],
          basis: [
            {
              a: "3086d221a7d46bcde86c90e49284eb15",
              b: "-e4437ed6010e88286f547fa90abfe4c3"
            },
            {
              a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
              b: "3086d221a7d46bcde86c90e49284eb15"
            }
          ],
          pre: [
            384,
            [
              "3086d221 a7d46bcd e86c90e4 9284eb15",
              "3daa8a14 71e8ca7f e893209a 45dbb031"
            ],
            [
              "-",
              "e4437ed6 010e8828 6f547fa9 0abfe4c4",
              "221208ac 9df506c6 1571b4ae 8ac47f71"
            ]
          ]
        }
      });
    }
  }
  class R extends u {
    constructor(r) {
      super({
        id: "BRAINPOOLP256",
        ossl: "brainpoolP256r1",
        type: "short",
        endian: "be",
        hash: "SHA256",
        prime: null,
        // (= 3 mod 4)
        p: [
          "a9fb57db a1eea9bc 3e660a90 9d838d72",
          "6e3bf623 d5262028 2013481d 1f6e5377"
        ],
        a: [
          "7d5a0975 fc2c3057 eef67530 417affe7",
          "fb8055c1 26dc5c6c e94a4b44 f330b5d9"
        ],
        b: [
          "26dc5c6c e94a4b44 f330b5d9 bbd77cbf",
          "95841629 5cf7e1ce 6bccdc18 ff8c07b6"
        ],
        n: [
          "a9fb57db a1eea9bc 3e660a90 9d838d71",
          "8c397aa3 b561a6f7 901e0e82 974856a7"
        ],
        h: "1",
        // Icart
        z: "-2",
        g: [
          [
            "8bd2aeb9 cb7e57cb 2c4b482f fc81b7af",
            "b9de27e1 e3bd23c2 3a4453bd 9ace3262"
          ],
          [
            "547ef835 c3dac4fd 97f8461a 14611dc9",
            "c2774513 2ded8e54 5c1d54c7 2f046997"
          ],
          r
        ]
      });
    }
  }
  class V extends u {
    constructor(r) {
      super({
        id: "BRAINPOOLP384",
        ossl: "brainpoolP384r1",
        type: "short",
        endian: "be",
        hash: "SHA384",
        prime: null,
        // (= 3 mod 4)
        p: [
          "8cb91e82 a3386d28 0f5d6f7e 50e641df",
          "152f7109 ed5456b4 12b1da19 7fb71123",
          "acd3a729 901d1a71 87470013 3107ec53"
        ],
        a: [
          "7bc382c6 3d8c150c 3c72080a ce05afa0",
          "c2bea28e 4fb22787 139165ef ba91f90f",
          "8aa5814a 503ad4eb 04a8c7dd 22ce2826"
        ],
        b: [
          "04a8c7dd 22ce2826 8b39b554 16f0447c",
          "2fb77de1 07dcd2a6 2e880ea5 3eeb62d5",
          "7cb43902 95dbc994 3ab78696 fa504c11"
        ],
        n: [
          "8cb91e82 a3386d28 0f5d6f7e 50e641df",
          "152f7109 ed5456b3 1f166e6c ac0425a7",
          "cf3ab6af 6b7fc310 3b883202 e9046565"
        ],
        h: "1",
        // SSWU
        z: "-5",
        g: [
          [
            "1d1c64f0 68cf45ff a2a63a81 b7c13f6b",
            "8847a3e7 7ef14fe3 db7fcafe 0cbd10e8",
            "e826e034 36d646aa ef87b2e2 47d4af1e"
          ],
          [
            "8abe1d75 20f9c2a4 5cb1eb8e 95cfd552",
            "62b70b29 feec5864 e19c054f f9912928",
            "0e464621 77918111 42820341 263c5315"
          ],
          r
        ]
      });
    }
  }
  class fe extends u {
    constructor(r) {
      super({
        id: "BRAINPOOLP512",
        ossl: "brainpoolP512r1",
        type: "short",
        endian: "be",
        hash: "SHA512",
        prime: null,
        // (= 3 mod 4)
        p: [
          "aadd9db8 dbe9c48b 3fd4e6ae 33c9fc07",
          "cb308db3 b3c9d20e d6639cca 70330871",
          "7d4d9b00 9bc66842 aecda12a e6a380e6",
          "2881ff2f 2d82c685 28aa6056 583a48f3"
        ],
        a: [
          "7830a331 8b603b89 e2327145 ac234cc5",
          "94cbdd8d 3df91610 a83441ca ea9863bc",
          "2ded5d5a a8253aa1 0a2ef1c9 8b9ac8b5",
          "7f1117a7 2bf2c7b9 e7c1ac4d 77fc94ca"
        ],
        b: [
          "3df91610 a83441ca ea9863bc 2ded5d5a",
          "a8253aa1 0a2ef1c9 8b9ac8b5 7f1117a7",
          "2bf2c7b9 e7c1ac4d 77fc94ca dc083e67",
          "984050b7 5ebae5dd 2809bd63 8016f723"
        ],
        n: [
          "aadd9db8 dbe9c48b 3fd4e6ae 33c9fc07",
          "cb308db3 b3c9d20e d6639cca 70330870",
          "553e5c41 4ca92619 41866119 7fac1047",
          "1db1d381 085ddadd b5879682 9ca90069"
        ],
        h: "1",
        // Icart
        z: "7",
        g: [
          [
            "81aee4bd d82ed964 5a21322e 9c4c6a93",
            "85ed9f70 b5d916c1 b43b62ee f4d0098e",
            "ff3b1f78 e2d0d48d 50d1687b 93b97d5f",
            "7c6d5047 406a5e68 8b352209 bcb9f822"
          ],
          [
            "7dde385d 566332ec c0eabfa9 cf7822fd",
            "f209f700 24a57b1a a000c55b 881f8111",
            "b2dcde49 4a5f485e 5bca4bd8 8a2763ae",
            "d1ca2b2f a8f05406 78cd1e0f 3ad80892"
          ],
          r
        ]
      });
    }
  }
  class ue extends i {
    constructor() {
      super({
        id: "X25519",
        ossl: "X25519",
        type: "mont",
        endian: "le",
        hash: "SHA512",
        prime: "p25519",
        // 2^255 - 19 (= 5 mod 8)
        p: [
          "7fffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff ffffffff ffffffed"
        ],
        // 486662
        a: "76d06",
        b: "1",
        n: [
          "10000000 00000000 00000000 00000000",
          "14def9de a2f79cd6 5812631a 5cf5d3ed"
        ],
        h: "8",
        // Elligator 2
        z: "2",
        g: [
          [
            "00000000 00000000 00000000 00000000",
            "00000000 00000000 00000000 00000009"
          ],
          // See: https://www.rfc-editor.org/errata/eid4730
          [
            "5f51e65e 475f794b 1fe122d3 88b72eb3",
            "6dc2b281 92839e4d d6163a5d 81312c14"
          ]
        ],
        torsion: [
          [],
          [
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000"
            ],
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000"
            ]
          ],
          [
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000001"
            ],
            [
              "6be4f497 f9a9c2af c21fa77a d7f4a6ef",
              "635a11c7 284a9363 e9a248ef 9c884415"
            ]
          ],
          [
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000001"
            ],
            [
              "141b0b68 06563d50 3de05885 280b5910",
              "9ca5ee38 d7b56c9c 165db710 6377bbd8"
            ]
          ],
          [
            [
              "57119fd0 dd4e22d8 868e1c58 c45c4404",
              "5bef839c 55b1d0b1 248c50a3 bc959c5f"
            ],
            [
              "68c59389 3d458e64 31c6ca00 45fb5015",
              "20a44346 8eaa68dd 0f103842 048065b7"
            ]
          ],
          [
            [
              "57119fd0 dd4e22d8 868e1c58 c45c4404",
              "5bef839c 55b1d0b1 248c50a3 bc959c5f"
            ],
            [
              "173a6c76 c2ba719b ce3935ff ba04afea",
              "df5bbcb9 71559722 f0efc7bd fb7f9a36"
            ]
          ],
          [
            [
              "00b8495f 16056286 fdb1329c eb8d09da",
              "6ac49ff1 fae35616 aeb8413b 7c7aebe0"
            ],
            [
              "3931c129 569e83a5 29482c14 e628b457",
              "933bfc29 ed801b4d 68871483 92507b1a"
            ]
          ],
          [
            [
              "00b8495f 16056286 fdb1329c eb8d09da",
              "6ac49ff1 fae35616 aeb8413b 7c7aebe0"
            ],
            [
              "46ce3ed6 a9617c5a d6b7d3eb 19d74ba8",
              "6cc403d6 127fe4b2 9778eb7c 6daf84d3"
            ]
          ]
        ]
      });
    }
  }
  class ae extends i {
    constructor() {
      super({
        id: "X448",
        ossl: "X448",
        type: "mont",
        endian: "le",
        hash: "SHAKE256",
        prime: "p448",
        // 2^448 - 2^224 - 1 (= 3 mod 4)
        p: [
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff fffffffe ffffffff",
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff"
        ],
        // 156326
        a: "262a6",
        b: "1",
        n: [
          "3fffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff ffffffff 7cca23e9",
          "c44edb49 aed63690 216cc272 8dc58f55",
          "2378c292 ab5844f3"
        ],
        h: "4",
        // Elligator 2
        z: "-1",
        g: [
          [
            "00000000 00000000 00000000 00000000",
            "00000000 00000000 00000000 00000000",
            "00000000 00000000 00000000 00000000",
            "00000000 00000005"
          ],
          [
            "7d235d12 95f5b1f6 6c98ab6e 58326fce",
            "cbae5d34 f55545d0 60f75dc2 8df3f6ed",
            "b8027e23 46430d21 1312c4b1 50677af7",
            "6fd7223d 457b5b1a"
          ]
        ],
        torsion: [
          [],
          [
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000"
            ],
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000"
            ]
          ],
          [
            [
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff ffffffff fffffffe ffffffff",
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff fffffffe"
            ],
            [
              "ba4d3a08 29b6112f 8812e51b a0bb2abe",
              "bc1cb08e b48e5569 36ba50fd d2e7d68a",
              "f8cb3216 0522425b 3f990812 abbe635a",
              "d37a21e1 7551b193"
            ]
          ],
          [
            [
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff ffffffff fffffffe ffffffff",
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff fffffffe"
            ],
            [
              "45b2c5f7 d649eed0 77ed1ae4 5f44d541",
              "43e34f71 4b71aa96 c945af01 2d182975",
              "0734cde9 faddbda4 c066f7ed 54419ca5",
              "2c85de1e 8aae4e6c"
            ]
          ]
        ]
      });
    }
  }
  class D extends i {
    constructor() {
      super({
        id: "MONT448",
        ossl: null,
        type: "mont",
        endian: "le",
        hash: "SHAKE256",
        prime: "p448",
        // 2^448 - 2^224 - 1 (= 3 mod 4)
        p: [
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff fffffffe ffffffff",
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff"
        ],
        // -78160 / -39082 mod p
        a: [
          "b2cf97d2 d43459a9 31ed36b1 fc4e3cb5",
          "5d93f8d2 22746997 60ccffc6 49961ed6",
          "c5b05fca c24864ed 6fb59697 931b78da",
          "84ddecd8 ca2b5cfb"
        ],
        b: "1",
        n: [
          "3fffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff ffffffff 7cca23e9",
          "c44edb49 aed63690 216cc272 8dc58f55",
          "2378c292 ab5844f3"
        ],
        h: "4",
        // Elligator 2
        z: "-1",
        g: [
          [
            "ac0d24cc c6c75cb0 eb71f81e 7a6edf51",
            "48e88aee 009a2a24 e795687e c28e125a",
            "3e6730a6 0d46367b aa7fe99d 152128dc",
            "41321bc7 7817f059"
          ],
          [
            "5a4437f6 80c0d0db 9b061276 d5d0ffcc",
            "e786ff33 b6a53d30 98746425 82e66f09",
            "4433dae7 7244a6e2 6b11e905 7228f483",
            "556c41a5 913f55fe"
          ]
        ],
        torsion: [
          [],
          [
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000"
            ],
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000"
            ]
          ],
          [
            [
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff ffffffff fffffffe ffffffff",
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff fffffffe"
            ],
            [
              "bec92fd0 6da2acf2 b4e261e8 7cef0d34",
              "22e75c18 3c589857 b71924e5 73c2f9ce",
              "e18da5f2 466e2f39 3c2eedf0 f105a60a",
              "b40c717d 4f1e1fd7"
            ]
          ],
          [
            [
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff ffffffff fffffffe ffffffff",
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff fffffffe"
            ],
            [
              "4136d02f 925d530d 4b1d9e17 8310f2cb",
              "dd18a3e7 c3a767a8 48e6db19 8c3d0631",
              "1e725a0d b991d0c6 c3d1120f 0efa59f5",
              "4bf38e82 b0e1e028"
            ]
          ]
        ]
      });
    }
  }
  class Q extends E {
    constructor(r) {
      super({
        id: "ED25519",
        ossl: "ED25519",
        type: "edwards",
        endian: "le",
        hash: "SHA512",
        prefix: "SigEd25519 no Ed25519 collisions",
        context: !1,
        prime: "p25519",
        // 2^255 - 19 (= 5 mod 8)
        p: [
          "7fffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff ffffffff ffffffed"
        ],
        a: "-1",
        // -121665 / 121666 mod p
        d: [
          "52036cee 2b6ffe73 8cc74079 7779e898",
          "00700a4d 4141d8ab 75eb4dca 135978a3"
        ],
        n: [
          "10000000 00000000 00000000 00000000",
          "14def9de a2f79cd6 5812631a 5cf5d3ed"
        ],
        h: "8",
        // Elligator 2
        z: "2",
        g: [
          [
            "216936d3 cd6e53fe c0a4e231 fdd6dc5c",
            "692cc760 9525a7b2 c9562d60 8f25d51a"
          ],
          // 4/5
          [
            "66666666 66666666 66666666 66666666",
            "66666666 66666666 66666666 66666658"
          ],
          r
        ],
        torsion: [
          [
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000"
            ],
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000001"
            ]
          ],
          [
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000"
            ],
            [
              "7fffffff ffffffff ffffffff ffffffff",
              "ffffffff ffffffff ffffffff ffffffec"
            ]
          ],
          [
            [
              "2b832480 4fc1df0b 2b4d0099 3dfbd7a7",
              "2f431806 ad2fe478 c4ee1b27 4a0ea0b0"
            ],
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000"
            ]
          ],
          [
            [
              "547cdb7f b03e20f4 d4b2ff66 c2042858",
              "d0bce7f9 52d01b87 3b11e4d8 b5f15f3d"
            ],
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000"
            ]
          ],
          [
            [
              "1fd5b9a0 06394a28 e9339932 38de4abb",
              "5c193c70 13e5e238 dea14646 c545d14a"
            ],
            [
              "05fc536d 880238b1 3933c6d3 05acdfd5",
              "f098eff2 89f4c345 b027b2c2 8f95e826"
            ]
          ],
          [
            [
              "602a465f f9c6b5d7 16cc66cd c721b544",
              "a3e6c38f ec1a1dc7 215eb9b9 3aba2ea3"
            ],
            [
              "05fc536d 880238b1 3933c6d3 05acdfd5",
              "f098eff2 89f4c345 b027b2c2 8f95e826"
            ]
          ],
          [
            [
              "1fd5b9a0 06394a28 e9339932 38de4abb",
              "5c193c70 13e5e238 dea14646 c545d14a"
            ],
            [
              "7a03ac92 77fdc74e c6cc392c fa53202a",
              "0f67100d 760b3cba 4fd84d3d 706a17c7"
            ]
          ],
          [
            [
              "602a465f f9c6b5d7 16cc66cd c721b544",
              "a3e6c38f ec1a1dc7 215eb9b9 3aba2ea3"
            ],
            [
              "7a03ac92 77fdc74e c6cc392c fa53202a",
              "0f67100d 760b3cba 4fd84d3d 706a17c7"
            ]
          ]
        ]
      });
    }
  }
  class Z extends E {
    constructor(r) {
      super({
        id: "ISO448",
        ossl: null,
        type: "edwards",
        endian: "le",
        hash: "SHAKE256",
        prefix: "SigEd448",
        context: !0,
        prime: "p448",
        // 2^448 - 2^224 - 1 (= 3 mod 4)
        p: [
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff fffffffe ffffffff",
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff"
        ],
        a: "1",
        // 39082 / 39081 mod p
        d: [
          "d78b4bdc 7f0daf19 f24f38c2 9373a2cc",
          "ad461572 42a50f37 809b1da3 412a12e7",
          "9ccc9c81 264cfe9a d0809970 58fb61c4",
          "243cc32d baa156b9"
        ],
        n: [
          "3fffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff ffffffff 7cca23e9",
          "c44edb49 aed63690 216cc272 8dc58f55",
          "2378c292 ab5844f3"
        ],
        h: "4",
        // Elligator 2
        z: "-1",
        g: [
          [
            "79a70b2b 70400553 ae7c9df4 16c792c6",
            "1128751a c9296924 0c25a07d 728bdc93",
            "e21f7787 ed697224 9de732f3 8496cd11",
            "69871309 3e9c04fc"
          ],
          // Note: the RFC has this wrong.
          [
            "7fffffff ffffffff ffffffff ffffffff",
            "ffffffff ffffffff ffffffff 80000000",
            "00000000 00000000 00000000 00000000",
            "00000000 00000001"
          ],
          r
        ],
        torsion: [
          [
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000"
            ],
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000001"
            ]
          ],
          [
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000"
            ],
            [
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff ffffffff fffffffe ffffffff",
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff fffffffe"
            ]
          ],
          [
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000001"
            ],
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000"
            ]
          ],
          [
            [
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff ffffffff fffffffe ffffffff",
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff fffffffe"
            ],
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000"
            ]
          ]
        ]
      });
    }
  }
  class oe extends E {
    constructor(r) {
      super({
        id: "ED448",
        ossl: "ED448",
        type: "edwards",
        endian: "le",
        hash: "SHAKE256",
        prefix: "SigEd448",
        context: !0,
        prime: "p448",
        // 2^448 - 2^224 - 1 (= 3 mod 4)
        p: [
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff fffffffe ffffffff",
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff"
        ],
        a: "1",
        // -39081 mod p
        d: [
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff fffffffe ffffffff",
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffff6756"
        ],
        n: [
          "3fffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff ffffffff 7cca23e9",
          "c44edb49 aed63690 216cc272 8dc58f55",
          "2378c292 ab5844f3"
        ],
        h: "4",
        // Elligator 2
        z: "-1",
        g: [
          [
            "4f1970c6 6bed0ded 221d15a6 22bf36da",
            "9e146570 470f1767 ea6de324 a3d3a464",
            "12ae1af7 2ab66511 433b80e1 8b00938e",
            "2626a82b c70cc05e"
          ],
          [
            "693f4671 6eb6bc24 88762037 56c9c762",
            "4bea7373 6ca39840 87789c1e 05a0c2d7",
            "3ad3ff1c e67c39c4 fdbd132c 4ed7c8ad",
            "9808795b f230fa14"
          ],
          r
        ],
        torsion: [
          [
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000"
            ],
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000001"
            ]
          ],
          [
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000"
            ],
            [
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff ffffffff fffffffe ffffffff",
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff fffffffe"
            ]
          ],
          [
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000001"
            ],
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000"
            ]
          ],
          [
            [
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff ffffffff fffffffe ffffffff",
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff fffffffe"
            ],
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000"
            ]
          ]
        ]
      });
    }
  }
  const y = {
    __proto__: null,
    P192: N,
    P224: z,
    P256: A,
    P384: q,
    P521: _,
    SECP256K1: F,
    BRAINPOOLP256: R,
    BRAINPOOLP384: V,
    BRAINPOOLP512: fe,
    X25519: ue,
    X448: ae,
    MONT448: D,
    ED25519: Q,
    ISO448: Z,
    ED448: oe
  }, Y = {
    __proto__: null,
    P192: null,
    P224: null,
    P256: null,
    P384: null,
    P521: null,
    SECP256K1: null,
    BRAINPOOLP256: null,
    BRAINPOOLP384: null,
    BRAINPOOLP512: null,
    X25519: null,
    X448: null,
    MONT448: null,
    ED25519: null,
    ISO448: null,
    ED448: null
  };
  function he($, ...r) {
    I(typeof $ == "string");
    const x = $.toUpperCase();
    let O = Y[x];
    if (!O) {
      const L = y[x];
      if (!L)
        throw new Error(`Curve not found: "${$}".`);
      O = new L(...r), Y[x] = O;
    }
    return O;
  }
  function be($, r) {
    I(typeof $ == "string"), I(typeof r == "function");
    const x = $.toUpperCase();
    if (y[x])
      throw new Error(`Curve already registered: "${$}".`);
    y[x] = r, Y[x] = null;
  }
  function xe($, r, x) {
    I($ instanceof c), I(!$.red), I(r >>> 0 === r), I(x >>> 0 === x);
    const O = new Array(x), L = $.bitLength() + 1, X = $.sign() | 1;
    I(L <= x);
    for (let ce = 0; ce < x; ce++)
      O[ce] = 0;
    let P = 0, K = 0, re;
    for (; P < L; ) {
      if ($.bit(P) === K) {
        P += 1;
        continue;
      }
      re = $.bits(P, r) + K, K = re >> r - 1 & 1, re -= K << r, O[P] = X * re, P += r;
    }
    return I(K === 0), O;
  }
  function Ie($, r, x, O) {
    I(O >>> 0 === O);
    const L = xe($, r, x), X = Math.ceil(L.length / O), P = new Array(X);
    let K = 0;
    for (let re = 0; re < L.length; re += O) {
      let ce = 0;
      for (let le = re + O - 1; le >= re; le--)
        ce = (ce << 1) + L[le];
      P[K++] = ce;
    }
    return I(K === X), P;
  }
  function ve($, r, x) {
    I($ instanceof c), I(r instanceof c), I(!$.red), I(!r.red), I(x >>> 0 === x);
    const O = [new Array(x), new Array(x)], L = Math.max($.bitLength(), r.bitLength()) + 1, X = $.sign() | 1, P = r.sign() | 1;
    I(L <= x);
    let K = 0, re = 0;
    for (let ce = 0; ce < L; ce++) {
      const le = $.bits(ce, 3), me = r.bits(ce, 3);
      let ne = (le & 3) + K & 3, W = (me & 3) + re & 3, te = 0, pe = 0;
      if (ne === 3 && (ne = -1), W === 3 && (W = -1), ne & 1) {
        const Ee = (le & 7) + K & 7;
        (Ee === 3 || Ee === 5) && W === 2 ? te = -ne : te = ne;
      }
      if (W & 1) {
        const Ee = (me & 7) + re & 7;
        (Ee === 3 || Ee === 5) && ne === 2 ? pe = -W : pe = W;
      }
      O[0][ce] = te * X, O[1][ce] = pe * P, 2 * K === 1 + te && (K = 1 - K), 2 * re === 1 + pe && (re = 1 - re);
    }
    for (let ce = L; ce < x; ce++)
      O[0][ce] = 0, O[1][ce] = 0;
    return O;
  }
  function C($, r, x) {
    const O = ve($, r, x), L = new Array(x);
    for (let X = 0; X < x; X++) {
      const P = O[0][X], K = O[1][X];
      L[X] = w[(P + 1) * 3 + (K + 1)];
    }
    return L;
  }
  function I($, r) {
    if (!$) {
      const x = new Error(r || "Assertion failed");
      throw Error.captureStackTrace && Error.captureStackTrace(x, I), x;
    }
  }
  function se($) {
    I(typeof $ == "function");
    try {
      return $();
    } catch (r) {
      throw r.message === "X is not a square mod P." || r.message === "Not invertible." ? new Error("Invalid point.") : r;
    }
  }
  function t($, r) {
    let x = $ % r;
    return x < 0 && (x += r), x;
  }
  function l($) {
    I($ instanceof c), I($.red);
    const r = $.red.m;
    if (r.cmpn(3) <= 0)
      return $.clone();
    if (r.modrn(3) === 2) {
      const O = r.ushln(1).isubn(1).idivn(3);
      return $.redPow(O);
    }
    const x = r.modrn(9);
    if (x === 4) {
      const O = r.ushln(1).iaddn(1).idivn(9), L = $.redPow(O);
      if (!L.redSqr().redMul(L).eq($))
        throw new Error("X is not a cube mod P.");
      return L;
    }
    if (x === 7) {
      const O = r.addn(2).idivn(9), L = $.redPow(O);
      if (!L.redSqr().redMul(L).eq($))
        throw new Error("X is not a cube mod P.");
      return L;
    }
    throw new Error("Not implemented.");
  }
  function B($) {
    const r = l($);
    if ($.red.m.modrn(3) === 1) {
      const x = new c(2).toRed($.red), O = new c(3).toRed($.red), L = x.redInvert(), X = O.redNeg().redSqrt().redMul(L), P = X.redNeg(), K = X.redSub(L), re = P.redSub(L), ce = r.redMul(K), le = r.redMul(re);
      return [r, ce, le];
    }
    return [r];
  }
  function U($) {
    for (const r of B($))
      if (r.redJacobi() >= 0)
        return r;
    throw new Error("X^(1/3) is not a square mod P.");
  }
  function G($) {
    return c.randomBits($, 32).toNumber();
  }
  function T($, r) {
    const x = /* @__PURE__ */ new WeakMap();
    return function(L, X) {
      const P = X & 1, K = x.get(L);
      if (K && K[P] !== null)
        return K[P];
      const re = $.call(r, L, X);
      return x.has(L) || x.set(L, [null, null]), x.get(L)[P] = re, re;
    };
  }
  function M($, r) {
    I($ instanceof c), I(r >>> 0 === r), r & 7 && (r += 8 - (r & 7));
    const x = $.toString(16, r), O = [], L = [];
    I((x.length & 7) === 0);
    for (let X = 0; X < x.length; X += 8)
      O.push(x.slice(X, X + 8));
    for (let X = 0; X < O.length; X += 4)
      L.push(O.slice(X, X + 4).join(" "));
    return L;
  }
  return er.Curve = f, er.Point = n, er.ShortCurve = u, er.ShortPoint = a, er.JPoint = s, er.MontCurve = i, er.MontPoint = p, er.XPoint = m, er.EdwardsCurve = E, er.EdwardsPoint = v, er.curves = y, er.curve = he, er.register = be, er;
}
var qc, z5;
function es() {
  if (z5) return qc;
  z5 = 1;
  const e = Mt(), c = Hr(), d = pi(), w = Yb(), g = Jg(), f = Jb(), n = Gg();
  class u {
    constructor(s, i, p, m) {
      e(typeof s == "string"), e(i), e(p), this.id = s, this.type = "ecdsa", this.hash = i, this.xof = p, this.native = 0, this._pre = m || null, this._curve = null, this._schnorr = null;
    }
    get curve() {
      return this._curve || (this._curve = n.curve(this.id, this._pre), this._curve.precompute(d), this._pre = null), this._curve;
    }
    get schnorr() {
      return this._schnorr || (this._schnorr = new g(this.curve, this.xof)), this._schnorr;
    }
    get size() {
      return this.curve.fieldSize;
    }
    get bits() {
      return this.curve.fieldBits;
    }
    privateKeyGenerate() {
      const s = this.curve.randomScalar(d);
      return this.curve.encodeScalar(s);
    }
    privateKeyVerify(s) {
      e(k.isBuffer(s));
      let i;
      try {
        i = this.curve.decodeScalar(s);
      } catch {
        return !1;
      }
      return !i.isZero() && i.cmp(this.curve.n) < 0;
    }
    privateKeyExport(s) {
      const i = this.publicKeyCreate(s, !1), { x: p, y: m } = this.publicKeyExport(i);
      return {
        d: k.from(s),
        x: p,
        y: m
      };
    }
    privateKeyImport(s) {
      e(s && typeof s == "object");
      const i = c.decode(s.d, this.curve.endian);
      if (i.isZero() || i.cmp(this.curve.n) >= 0)
        throw new Error("Invalid private key.");
      return this.curve.encodeScalar(i);
    }
    privateKeyTweakAdd(s, i) {
      const p = this.curve.decodeScalar(i);
      if (p.cmp(this.curve.n) >= 0)
        throw new Error("Invalid scalar.");
      const m = this.curve.decodeScalar(s);
      if (m.isZero() || m.cmp(this.curve.n) >= 0)
        throw new Error("Invalid private key.");
      const E = m.add(p).imod(this.curve.n);
      if (E.isZero())
        throw new Error("Invalid private key.");
      return this.curve.encodeScalar(E);
    }
    privateKeyTweakMul(s, i) {
      const p = this.curve.decodeScalar(i);
      if (p.isZero() || p.cmp(this.curve.n) >= 0)
        throw new Error("Invalid scalar.");
      const m = this.curve.decodeScalar(s);
      if (m.isZero() || m.cmp(this.curve.n) >= 0)
        throw new Error("Invalid private key.");
      const E = m.mul(p).imod(this.curve.n);
      if (E.isZero())
        throw new Error("Invalid private key.");
      return this.curve.encodeScalar(E);
    }
    privateKeyNegate(s) {
      const i = this.curve.decodeScalar(s);
      if (i.isZero() || i.cmp(this.curve.n) >= 0)
        throw new Error("Invalid private key.");
      const p = i.neg().imod(this.curve.n);
      return this.curve.encodeScalar(p);
    }
    privateKeyInvert(s) {
      const i = this.curve.decodeScalar(s);
      if (i.isZero() || i.cmp(this.curve.n) >= 0)
        throw new Error("Invalid private key.");
      const p = i.invert(this.curve.n);
      return this.curve.encodeScalar(p);
    }
    publicKeyCreate(s, i) {
      const p = this.curve.decodeScalar(s);
      if (p.isZero() || p.cmp(this.curve.n) >= 0)
        throw new Error("Invalid private key.");
      return this.curve.g.mulBlind(p).encode(i);
    }
    publicKeyConvert(s, i) {
      return this.curve.decodePoint(s).encode(i);
    }
    publicKeyFromUniform(s, i) {
      const p = this.curve.decodeUniform(s);
      return this.curve.pointFromUniform(p).encode(i);
    }
    publicKeyToUniform(s, i = d.randomInt()) {
      const p = this.curve.decodePoint(s), m = this.curve.pointToUniform(p, i);
      return this.curve.encodeUniform(m, i >>> 8);
    }
    publicKeyFromHash(s, i) {
      return this.curve.pointFromHash(s).encode(i);
    }
    publicKeyToHash(s) {
      const i = this.curve.decodePoint(s);
      return this.curve.pointToHash(i, 0, d);
    }
    publicKeyVerify(s) {
      e(k.isBuffer(s));
      try {
        this.curve.decodePoint(s);
      } catch {
        return !1;
      }
      return !0;
    }
    publicKeyExport(s) {
      const { x: i, y: p } = this.curve.decodePoint(s);
      return {
        x: this.curve.encodeField(i.fromRed()),
        y: this.curve.encodeField(p.fromRed())
      };
    }
    publicKeyImport(s, i) {
      e(s && typeof s == "object");
      const p = c.decode(s.x, this.curve.endian);
      if (p.cmp(this.curve.p) >= 0)
        throw new Error("Invalid point.");
      if (s.y != null) {
        const E = c.decode(s.y, this.curve.endian);
        if (E.cmp(this.curve.p) >= 0)
          throw new Error("Invalid point.");
        const v = this.curve.point(p, E);
        if (!v.validate())
          throw new Error("Invalid point.");
        return v.encode(i);
      }
      return this.curve.pointFromX(p, s.sign).encode(i);
    }
    publicKeyTweakAdd(s, i, p) {
      const m = this.curve.decodeScalar(i);
      if (m.cmp(this.curve.n) >= 0)
        throw new Error("Invalid scalar.");
      const E = this.curve.decodePoint(s);
      return this.curve.g.jmul(m).add(E).encode(p);
    }
    publicKeyTweakMul(s, i, p) {
      const m = this.curve.decodeScalar(i);
      if (m.isZero() || m.cmp(this.curve.n) >= 0)
        throw new Error("Invalid scalar.");
      return this.curve.decodePoint(s).mul(m).encode(p);
    }
    publicKeyCombine(s, i) {
      e(Array.isArray(s));
      let p = this.curve.jpoint();
      for (const m of s) {
        const E = this.curve.decodePoint(m);
        p = p.add(E);
      }
      return p.encode(i);
    }
    publicKeyNegate(s, i) {
      return this.curve.decodePoint(s).neg().encode(i);
    }
    signatureNormalize(s) {
      const [i, p] = this._decodeCompact(s);
      return p.cmp(this.curve.nh) > 0 && p.ineg().imod(this.curve.n), this._encodeCompact(i, p);
    }
    signatureNormalizeDER(s) {
      const [i, p] = this._decodeDER(s, !1);
      return p.cmp(this.curve.nh) > 0 && p.ineg().imod(this.curve.n), this._encodeDER(i, p);
    }
    signatureExport(s) {
      const [i, p] = this._decodeCompact(s);
      return this._encodeDER(i, p);
    }
    signatureImport(s) {
      const [i, p] = this._decodeDER(s, !1);
      return this._encodeCompact(i, p);
    }
    isLowS(s) {
      e(k.isBuffer(s));
      let i;
      try {
        [, i] = this._decodeCompact(s);
      } catch {
        return !1;
      }
      return i.cmp(this.curve.nh) <= 0;
    }
    isLowDER(s) {
      e(k.isBuffer(s));
      let i;
      try {
        [, i] = this._decodeDER(s, !1);
      } catch {
        return !1;
      }
      return i.cmp(this.curve.nh) <= 0;
    }
    sign(s, i) {
      const [p, m] = this._sign(s, i);
      return this._encodeCompact(p, m);
    }
    signRecoverable(s, i) {
      const [p, m, E] = this._sign(s, i);
      return [this._encodeCompact(p, m), E];
    }
    signDER(s, i) {
      const [p, m] = this._sign(s, i);
      return this._encodeDER(p, m);
    }
    signRecoverableDER(s, i) {
      const [p, m, E] = this._sign(s, i);
      return [this._encodeDER(p, m), E];
    }
    _sign(s, i) {
      const { n: p, nh: m } = this.curve, E = this.curve.g, v = this.curve.decodeScalar(i);
      if (v.isZero() || v.cmp(p) >= 0)
        throw new Error("Invalid private key.");
      const b = this._reduce(s), h = this.curve.encodeScalar(b), o = new f(this.hash, i, h);
      for (; ; ) {
        const S = o.generate(this.curve.scalarSize), H = this._truncate(S);
        if (H.isZero() || H.cmp(p) >= 0)
          continue;
        const j = E.mulBlind(H);
        if (j.isInfinity())
          continue;
        const J = j.getX(), N = J.mod(p);
        if (N.isZero())
          continue;
        const z = this.curve.randomScalar(d), A = H.mul(z).fermat(p), q = v.mul(z).imod(p), _ = b.mul(z).imod(p), R = N.mul(q).iadd(_).imod(p).mul(A).imod(p);
        if (R.isZero())
          continue;
        let V = j.isOdd() | !J.eq(N) << 1;
        return R.cmp(m) > 0 && (R.ineg().imod(p), V ^= 1), [N, R, V];
      }
    }
    verify(s, i, p) {
      e(k.isBuffer(s)), e(k.isBuffer(i)), e(k.isBuffer(p));
      let m, E;
      try {
        [m, E] = this._decodeCompact(i);
      } catch {
        return !1;
      }
      try {
        return this._verify(s, m, E, p);
      } catch {
        return !1;
      }
    }
    verifyDER(s, i, p) {
      e(k.isBuffer(s)), e(k.isBuffer(i)), e(k.isBuffer(p));
      let m, E;
      try {
        [m, E] = this._decodeDER(i, !1);
      } catch {
        return !1;
      }
      try {
        return this._verify(s, m, E, p);
      } catch {
        return !1;
      }
    }
    _verify(s, i, p, m) {
      const { n: E } = this.curve, v = this.curve.g, b = this._reduce(s), h = this.curve.decodePoint(m);
      if (i.isZero() || i.cmp(E) >= 0 || p.isZero() || p.cmp(E) >= 0)
        return !1;
      const o = p.invert(E), S = b.mul(o).imod(E), H = i.mul(o).imod(E);
      return v.jmulAdd(S, h, H).eqR(i);
    }
    recover(s, i, p, m) {
      e(k.isBuffer(s)), e(k.isBuffer(i)), e(p >>> 0 === p), e((p & 3) === p, "The recovery param is more than two bits.");
      let E, v;
      try {
        [E, v] = this._decodeCompact(i);
      } catch {
        return null;
      }
      let b;
      try {
        b = this._recover(s, E, v, p);
      } catch {
        return null;
      }
      return b.encode(m);
    }
    recoverDER(s, i, p, m) {
      e(k.isBuffer(s)), e(k.isBuffer(i)), e(p >>> 0 === p), e((p & 3) === p, "The recovery param is more than two bits.");
      let E, v;
      try {
        [E, v] = this._decodeDER(i, !1);
      } catch {
        return null;
      }
      let b;
      try {
        b = this._recover(s, E, v, p);
      } catch {
        return null;
      }
      return b.encode(m);
    }
    _recover(s, i, p, m) {
      const { n: E, pmodn: v } = this.curve, b = this.curve.g, h = this._reduce(s);
      if (i.isZero() || i.cmp(E) >= 0)
        throw new Error("Invalid R value.");
      if (p.isZero() || p.cmp(E) >= 0)
        throw new Error("Invalid S value.");
      const o = (m & 1) !== 0, S = m >>> 1;
      let H = i;
      if (S) {
        if (this.curve.highOrder)
          throw new Error("Invalid high bit.");
        if (H.cmp(v) >= 0)
          throw new Error("Invalid R value.");
        H = H.add(E);
      }
      const j = this.curve.pointFromX(H, o), J = i.invert(E), N = h.mul(J).ineg().imod(E), z = p.mul(J).imod(E), A = b.mulAdd(N, j, z);
      if (A.isInfinity())
        throw new Error("Invalid point.");
      return A;
    }
    derive(s, i, p) {
      const m = this.curve.decodePoint(s), E = this.curve.decodeScalar(i);
      if (E.isZero() || E.cmp(this.curve.n) >= 0)
        throw new Error("Invalid private key.");
      if (this.curve.h.cmpn(1) > 0 && m.isSmall())
        throw new Error("Invalid point.");
      return m.mulBlind(E, d).encode(p);
    }
    /*
     * Schnorr
     */
    schnorrSign(s, i) {
      return this.schnorr.sign(s, i);
    }
    schnorrVerify(s, i, p) {
      return this.schnorr.verify(s, i, p);
    }
    schnorrVerifyBatch(s) {
      return this.schnorr.verifyBatch(s);
    }
    /*
     * Helpers
     */
    _encodeCompact(s, i) {
      return k.concat([
        this.curve.encodeScalar(s),
        this.curve.encodeScalar(i)
      ]);
    }
    _decodeCompact(s) {
      e(k.isBuffer(s));
      const { n: i } = this.curve, p = this.curve.scalarSize;
      if (s.length !== p * 2)
        throw new Error("Invalid signature size.");
      const m = s.slice(0, p), E = s.slice(p, p * 2), v = this.curve.decodeScalar(m), b = this.curve.decodeScalar(E);
      if (v.cmp(i) >= 0 || b.cmp(i) >= 0)
        throw new Error("Invalid signature.");
      return [v, b];
    }
    _encodeDER(s, i) {
      const p = w.sizeInt(s) + w.sizeInt(i), m = k.alloc(w.sizeSeq(p));
      let E = 0;
      return E = w.writeSeq(m, E, p), E = w.writeInt(m, E, s), E = w.writeInt(m, E, i), e(E === m.length), m;
    }
    _decodeDER(s, i) {
      e(k.isBuffer(s)), e(typeof i == "boolean");
      const { n: p } = this.curve;
      let m = 0, E, v;
      if (m = w.readSeq(s, m, i), [E, m] = w.readInt(s, m, i), [v, m] = w.readInt(s, m, i), i && m !== s.length)
        throw new Error("Trailing bytes.");
      if (E.cmp(p) >= 0 || v.cmp(p) >= 0)
        throw new Error("Invalid signature.");
      return [E, v];
    }
    _truncate(s) {
      e(k.isBuffer(s));
      const i = this.curve.n.bitLength(), p = i + 7 >>> 3;
      s.length > p && (s = s.slice(0, p));
      const m = c.decode(s, this.curve.endian), E = s.length * 8 - i;
      return E > 0 && m.iushrn(E), m;
    }
    _reduce(s) {
      return this._truncate(s).imod(this.curve.n);
    }
  }
  return qc = u, qc;
}
const Wg = /* @__PURE__ */ JSON.parse('{"width":9,"points":[["f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9","388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"],["2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4","d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"],["5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc","6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"],["acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe","cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"],["774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb","d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"],["f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8","0ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"],["d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e","581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"],["defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34","4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"],["2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c","85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"],["352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5","321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"],["2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f","02de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"],["9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714","73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"],["daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729","a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"],["c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db","2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"],["6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4","e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"],["1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5","b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"],["605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479","02972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"],["62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d","80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"],["80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f","1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"],["7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb","0d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"],["d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9","eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"],["049370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963","758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"],["77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74","958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"],["f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530","e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"],["463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b","5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"],["f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247","cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"],["caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1","cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"],["2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120","4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"],["7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435","091b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"],["754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18","0673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"],["e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8","59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"],["186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb","3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"],["df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f","55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"],["5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143","efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"],["290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba","e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"],["af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45","f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"],["766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a","744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"],["59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e","c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"],["f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8","e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"],["7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c","30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"],["948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519","e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"],["7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab","100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"],["3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca","ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"],["d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf","8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"],["1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610","68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"],["733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4","f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"],["15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c","d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"],["a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940","edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"],["e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980","0a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"],["311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3","66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"],["34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf","09414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"],["f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63","4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"],["d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448","fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"],["32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf","5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"],["7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5","8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"],["ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6","8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"],["16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5","5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"],["eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99","f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"],["078c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51","f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"],["494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5","42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"],["a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5","204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"],["c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997","04f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"],["841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881","073867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"],["5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5","39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"],["36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66","d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"],["0336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726","ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"],["8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede","6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"],["1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94","060660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"],["85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31","3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"],["29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51","0b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"],["a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252","ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"],["04e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5","cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"],["d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b","6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"],["ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4","322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"],["af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f","6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"],["e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889","2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"],["591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246","b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"],["11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984","998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"],["3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a","b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"],["cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030","bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"],["c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197","6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"],["0c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593","c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"],["a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef","021ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"],["347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38","60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"],["da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a","49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"],["c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111","5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"],["4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502","7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"],["3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea","be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"],["cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26","8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"],["b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986","39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"],["d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e","62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"],["48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4","25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"],["dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda","ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"],["6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859","cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"],["e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f","f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"],["eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c","6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"],["13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942","fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"],["ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a","1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"],["b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80","5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"],["ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d","438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"],["8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1","cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"],["52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63","0c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"],["e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352","6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"],["7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193","ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"],["5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00","09731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"],["32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58","ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"],["e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7","d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"],["8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8","c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"],["4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e","67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"],["3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d","0cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"],["674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b","299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"],["d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f","f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"],["30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6","462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"],["be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297","62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"],["93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a","7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"],["b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c","ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"],["d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52","4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"],["d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb","bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"],["463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065","bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"],["7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917","603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"],["74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9","cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"],["30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3","553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"],["9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57","0712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"],["176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66","ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"],["75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8","9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"],["809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721","9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"],["1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180","4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"]]}'), Zg = { step: 4, points: [["e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a", "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"], ["8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508", "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"], ["175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739", "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"], ["363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640", "04e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"], ["8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c", "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"], ["723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda", "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"], ["eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa", "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"], ["100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0", "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"], ["e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d", "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"], ["feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d", "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"], ["da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1", "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"], ["53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0", "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"], ["8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047", "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"], ["385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862", "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"], ["06f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7", "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"], ["3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd", "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"], ["85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83", "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"], ["0948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a", "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"], ["6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8", "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"], ["e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d", "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"], ["e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725", "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"], ["213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754", "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"], ["4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c", "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"], ["fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6", "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"], ["76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39", "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"], ["c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891", "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"], ["d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b", "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"], ["b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03", "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"], ["e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d", "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"], ["a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070", "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"], ["90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4", "0e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"], ["8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da", "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"], ["e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11", "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"], ["8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e", "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"], ["e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41", "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"], ["b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef", "067c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"], ["d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8", "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"], ["324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d", "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"], ["4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96", "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"], ["9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd", "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"], ["6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5", "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"], ["a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266", "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"], ["7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71", "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"], ["0928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac", "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"], ["85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751", "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"], ["ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e", "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"], ["827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241", "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"], ["eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3", "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"], ["e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f", "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"], ["1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19", "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"], ["146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be", "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"], ["fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9", "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"], ["da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2", "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"], ["a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13", "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"], ["174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c", "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"], ["959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba", "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"], ["d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151", "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"], ["64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073", "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"], ["8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458", "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"], ["13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b", "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"], ["bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366", "0d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"], ["8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa", "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"], ["08ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0", "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"], ["dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787", "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"], ["f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e", "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"]] }, Qg = {
  naf: Wg,
  doubles: Zg
};
/*!
 * secp256k1.js - secp256k1 for bcrypto
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var zc, T5;
function Rr() {
  if (T5) return zc;
  T5 = 1;
  const e = es(), c = wr(), d = Qg;
  return zc = new e("SECP256K1", c, c, d), zc;
}
var C5;
function ex() {
  return C5 || (C5 = 1, function(e) {
    const c = $e(), d = At(), w = hr(), g = Rr(), f = e;
    f.MAGIC_STRING = `eCash Signed Message:
`, f.magicHash = (n, u = f.MAGIC_STRING) => {
      c(typeof u == "string", "prefix must be a string."), c(typeof n == "string", "message must be a string");
      const a = d.write();
      return a.writeVarString(u), a.writeVarString(n, "utf8"), w.digest(a.render());
    }, f.sign = (n, u, a) => {
      c(u.getPrivateKey(), "Cannot sign without private key.");
      const s = f.magicHash(n, a), i = u.getPublicKey().readInt8(0) !== 4, [
        p,
        m
      ] = g.signRecoverable(s, u.getPrivateKey()), E = d.write();
      return E.writeI8(m + 27 + (i ? 4 : 0)), E.writeBytes(p), E.render();
    }, f.recover = (n, u, a) => {
      c(typeof n == "string", "msg must be a string"), c(k.isBuffer(u), "sig must be a buffer");
      const s = f.magicHash(n, a);
      c.strictEqual(u.length, 65, "Invalid signature length");
      const i = u.readUInt8(0) - 27;
      c(i < 8, "Invalid signature parameter");
      const p = !!(i & 4), m = i & 3;
      return g.recover(s, u.slice(1), m, p);
    }, f.verify = (n, u, a, s) => {
      const i = f.recover(n, u);
      return c(k.isBuffer(a), "publicKey must be a buffer"), k.compare(a, i) !== 0 ? !1 : g.verify(
        f.magicHash(n, s),
        u.slice(1),
        a
      );
    };
  }(uc)), uc;
}
/*!
 * utils/index.js - utils for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var D5;
function Kt() {
  if (D5) return Si;
  D5 = 1, Si.binary = so(), Si.fixed = kb(), Si.util = Zt(), Si.message = ex();
  const { inspect: { custom: e } } = Mi();
  return Si.inspectSymbol = e || "inspect", Si;
}
var Tc, U5;
function Lr() {
  if (U5) return Tc;
  U5 = 1;
  const e = $e(), c = At(), { base58: d, cashaddr: w } = cn(), g = o8(), f = Hi(), n = hr(), u = yr(), a = Ht(), { inspectSymbol: s } = Kt(), i = k.alloc(20, 0);
  class p {
    /**
     * Create an address.
     * @constructor
     * @param {Object?} options
     */
    constructor(v, b) {
      this.type = p.types.PUBKEYHASH, this.hash = i, v && this.fromOptions(v, b);
    }
    /**
     * Inject properties from options object.
     * @private
     * @param {Object} options
     */
    fromOptions(v, b) {
      if (typeof v == "string")
        return this.fromString(v, b);
      e(v);
      const { hash: h, type: o } = v;
      return this.fromHash(h, o);
    }
    /**
     * Insantiate address from options.
     * @param {Object} options
     * @returns {Address}
     */
    static fromOptions(v, b) {
      return new this().fromOptions(v, b);
    }
    /**
     * Get the address hash.
     * @param {String?} enc - Can be `"hex"` or `null`.
     * @returns {Hash|Buffer}
     */
    getHash(v) {
      return v === "hex" ? this.hash.toString("hex") : this.hash;
    }
    /**
     * Test whether the address is null.
     * @returns {Boolean}
     */
    isNull() {
      if (this.hash.length === 20)
        return this.hash.equals(i);
      if (this.hash.length === 32)
        return this.hash.equals(a.ZERO_HASH);
      for (let v = 0; v < this.hash.length; v++)
        if (this.hash[v] !== 0)
          return !1;
      return !0;
    }
    /**
     * Test equality against another address.
     * @param {Address} addr
     * @returns {Boolean}
     */
    equals(v) {
      return e(v instanceof p), this.type === v.type && this.hash.equals(v.hash);
    }
    /**
     * Get the address type as a string.
     * @returns {String}
     */
    getType() {
      return p.typesByVal[this.type].toLowerCase();
    }
    /**
     * Get a network address prefix for the address.
     * @param {Network?} network
     * @returns {Number}
     */
    getPrefix(v) {
      v = u.get(v);
      const b = v.addressPrefix;
      switch (this.type) {
        case p.types.PUBKEYHASH:
          return b.pubkeyhash;
        case p.types.SCRIPTHASH:
          return b.scripthash;
      }
      return -1;
    }
    /**
     * Calculate size of serialized address.
     * @returns {Number}
     */
    getSize() {
      return 5 + this.hash.length;
    }
    /**
     * Compile the address object to its raw serialization.
     * @param {{NetworkType|Network)?} network
     * @returns {Buffer}
     * @throws Error on bad hash/prefix.
     */
    toRaw(v) {
      const b = this.getSize(), h = c.write(b), o = this.getPrefix(v);
      return e(o !== -1, "Not a valid address prefix."), h.writeU8(o), h.writeBytes(this.hash), h.writeChecksum(n.digest), h.render();
    }
    /**
     * Compile the address object to a base58 address.
     * @param {{NetworkType|Network)?} network
     * @returns {AddressString}
     * @throws Error on bad hash/prefix.
     */
    toBase58(v) {
      return d.encode(this.toRaw(v));
    }
    /**
     * Compile the address object to a cashaddr address.
     * @param {{NetworkType|Network)?} network
     * @returns {String}
     * @throws Error on bad hash/prefix.
     */
    toCashAddr(v) {
      const b = this.type, h = this.hash;
      v = u.get(v);
      const o = v.addressPrefix.cashaddr;
      return w.encode(o, b, h);
    }
    /**
     * Inject properties from string.
     * @private
     * @param {String} addr
     * @param {(Network|NetworkType)?} network
     * @returns {Address}
     */
    fromString(v, b) {
      if (e(typeof v == "string"), e(v.length > 0), e(v.length <= 100), m(v))
        return this.fromBase58(v, b);
      try {
        return this.fromCashAddr(v, b);
      } catch {
        return this.fromBase58(v, b);
      }
    }
    /**
     * Instantiate address from string.
     * @param {String} addr
     * @param {(Network|NetworkType)?} network
     * @returns {Address}
     */
    static fromString(v, b) {
      return new this().fromString(v, b);
    }
    /**
     * Return cashaddr by default
     * @param {(Network|NetworkType)?} network
     * @returns {AddressString}
     */
    toString(v) {
      return this.toCashAddr(v);
    }
    /**
     * Inspect the Address.
     * @returns {Object}
     */
    [s]() {
      return `<Address: type=${this.getType()} str=${this.toString()}>`;
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     * @throws Parse error
     */
    fromRaw(v, b) {
      const h = c.read(v, !0), o = h.readU8();
      b = u.fromAddress(o, b);
      const S = p.getType(o, b);
      if (v.length !== 25)
        throw new Error("Address is too long.");
      const H = h.readBytes(h.left() - 4);
      return h.verifyChecksum(n.digest), this.fromHash(H, S);
    }
    /**
     * Create an address object from a serialized address.
     * @param {Buffer} data
     * @returns {Address}
     * @throws Parse error.
     */
    static fromRaw(v, b) {
      return new this().fromRaw(v, b);
    }
    /**
     * Inject properties from base58 address.
     * @private
     * @param {AddressString} data
     * @param {Network?} network
     * @throws Parse error
     */
    fromBase58(v, b) {
      if (e(typeof v == "string"), v.length > 55)
        throw new Error("Address is too long.");
      return this.fromRaw(d.decode(v), b);
    }
    /**
     * Create an address object from a base58 address.
     * @param {AddressString} data
     * @param {Network?} network
     * @returns {Address}
     * @throws Parse error.
     */
    static fromBase58(v, b) {
      return new this().fromBase58(v, b);
    }
    /**
     * Inject properties from cashaddr address.
     * @private
     * @param {String} data
     * @param {Network?} network
     * @throws Parse error
     */
    fromCashAddr(v, b) {
      e(typeof v == "string"), b = u.get(b), b.addressPrefix.cashaddr;
      const h = g.decode(v);
      return h.type = h.type === "P2PKH" ? "PUBKEYHASH" : "SCRIPTHASH", u.fromCashAddr(h.prefix, b), this.fromHash(k.from(h.hash), h.type);
    }
    /**
     * Create an address object from a cashaddr address.
     * @param {String} data
     * @param {Network?} network
     * @returns {Address}
     * @throws Parse error.
     */
    static fromCashAddr(v, b) {
      return new this().fromCashAddr(v, b);
    }
    /**
     * Inject properties from output script.
     * @private
     * @param {Script} script
     */
    fromScript(v) {
      const b = v.getPubkey();
      if (b)
        return this.hash = f.digest(b), this.type = p.types.PUBKEYHASH, this;
      const h = v.getPubkeyhash();
      if (h)
        return this.hash = h, this.type = p.types.PUBKEYHASH, this;
      const o = v.getScripthash();
      return o ? (this.hash = o, this.type = p.types.SCRIPTHASH, this) : v.isMultisig() ? (this.hash = v.hash160(), this.type = p.types.SCRIPTHASH, this) : null;
    }
    /**
     * Inject properties from input script.
     * @private
     * @param {Script} script
     */
    fromInputScript(v) {
      const [, b] = v.getPubkeyhashInput();
      if (b)
        return this.hash = f.digest(b), this.type = p.types.PUBKEYHASH, this;
      const h = v.getScripthashInput();
      return h ? (this.hash = f.digest(h), this.type = p.types.SCRIPTHASH, this) : null;
    }
    /**
     * Create an Address from an input script.
     * Attempt to extract address
     * properties from an input script.
     * @param {Script}
     * @returns {Address|null}
     */
    static fromInputScript(v) {
      return new this().fromInputScript(v);
    }
    /**
     * Create an Address from an output script.
     * Parse an output script and extract address
     * properties. Converts pubkey and multisig
     * scripts to pubkeyhash and scripthash addresses.
     * @param {Script}
     * @returns {Address|null}
     */
    static fromScript(v) {
      return new this().fromScript(v);
    }
    /**
     * Inject properties from a hash.
     * @private
     * @param {Buffer|Hash} hash
     * @param {AddressPrefix} type
     * @throws on bad hash size
     */
    fromHash(v, b) {
      return typeof b == "string" && (b = p.types[b.toUpperCase()], e(b != null, "Not a valid address type.")), b == null && (b = p.types.PUBKEYHASH), e(k.isBuffer(v)), e(b >>> 0 === b), e(
        b >= p.types.PUBKEYHASH && b <= p.types.SCRIPTHASH,
        "Not a valid address type."
      ), e(v.length === 20, "Hash is the wrong size."), this.hash = v, this.type = b, this;
    }
    /**
     * Create a naked address from hash/type.
     * @param {Hash} hash
     * @param {AddressPrefix} type
     * @returns {Address}
     * @throws on bad hash size
     */
    static fromHash(v, b) {
      return new this().fromHash(v, b);
    }
    /**
     * Inject properties from pubkeyhash.
     * @private
     * @param {Buffer} hash
     * @returns {Address}
     */
    fromPubkeyhash(v) {
      const b = p.types.PUBKEYHASH;
      return e(v.length === 20, "P2PKH must be 20 bytes."), this.fromHash(v, b, -1);
    }
    /**
     * Instantiate address from pubkeyhash.
     * @param {Buffer} hash
     * @returns {Address}
     */
    static fromPubkeyhash(v) {
      return new this().fromPubkeyhash(v);
    }
    /**
     * Inject properties from scripthash.
     * @private
     * @param {Buffer} hash
     * @returns {Address}
     */
    fromScripthash(v) {
      const b = p.types.SCRIPTHASH;
      return e(v && v.length === 20, "P2SH must be 20 bytes."), this.fromHash(v, b, -1);
    }
    /**
     * Instantiate address from scripthash.
     * @param {Buffer} hash
     * @returns {Address}
     */
    static fromScripthash(v) {
      return new this().fromScripthash(v);
    }
    /**
     * Test whether the address is pubkeyhash.
     * @returns {Boolean}
     */
    isPubkeyhash() {
      return this.type === p.types.PUBKEYHASH;
    }
    /**
     * Test whether the address is scripthash.
     * @returns {Boolean}
     */
    isScripthash() {
      return this.type === p.types.SCRIPTHASH;
    }
    /**
     * Get the hash of a base58 address or address-related object.
     * @param {Address|Hash} data
     * @param {String?} enc - Can be `"hex"` or `null`.
     * @returns {Hash}
     */
    static getHash(v, b) {
      if (!v)
        throw new Error("Object is not an address.");
      let h;
      if (k.isBuffer(v)) {
        if (v.length !== 20)
          throw new Error("Object is not an address.");
        h = v;
      } else if (v instanceof p)
        h = v.hash;
      else
        throw new Error("Object is not an address.");
      return b === "hex" ? h.toString("hex") : h;
    }
    /**
     * Get an address type for a specified network address prefix.
     * @param {Number} prefix
     * @param {Network} network
     * @returns {AddressType}
     */
    static getType(v, b) {
      const h = b.addressPrefix;
      switch (v) {
        case h.pubkeyhash:
          return p.types.PUBKEYHASH;
        case h.scripthash:
          return p.types.SCRIPTHASH;
        default:
          throw new Error("Unknown address prefix.");
      }
    }
  }
  p.types = {
    PUBKEYHASH: 0,
    SCRIPTHASH: 1
  }, p.typesByVal = [
    "PUBKEYHASH",
    "SCRIPTHASH"
  ];
  function m(E) {
    let v = !1, b = !1;
    for (let h = 0; h < E.length; h++) {
      const o = E.charCodeAt(h);
      if (!(o >= 48 && o <= 57) && o !== 58 && (o & 32 ? (e(o >= 97 && o <= 122), v = !0) : (e(o >= 65 && o <= 90), b = !0), v && b))
        return !0;
    }
    return !1;
  }
  return Tc = p, Tc;
}
var Cc, F5;
function Gb() {
  if (F5) return Cc;
  F5 = 1;
  const e = $e(), c = Lr(), d = bi();
  class w {
    /**
     * Create a bitcoin URI.
     * @alias module:btc.URI
     * @constructor
     * @param {Object|String} options
     */
    constructor(s) {
      this.address = new c(), this.amount = -1, this.label = null, this.message = null, this.request = null, s && this.fromOptions(s);
    }
    /**
     * Inject properties from options object.
     * @private
     * @param {Object|String} options
     * @returns {URI}
     */
    fromOptions(s) {
      return typeof s == "string" ? this.fromString(s) : (s.address && this.address.fromOptions(s.address), s.amount != null && (e(
        Number.isSafeInteger(s.amount) && s.amount >= 0,
        "Amount must be a uint64."
      ), this.amount = s.amount), s.label && (e(typeof s.label == "string", "Label must be a string."), this.label = s.label), s.message && (e(typeof s.message == "string", "Message must be a string."), this.message = s.message), s.request && (e(typeof s.request == "string", "Request must be a string."), this.request = s.request), this);
    }
    /**
     * Instantiate URI from options.
     * @param {Object|String} options
     * @returns {URI}
     */
    static fromOptions(s) {
      return new this().fromOptions(s);
    }
    /**
     * Parse and inject properties from string.
     * @private
     * @param {String} str
     * @param {Network?} network
     * @returns {URI}
     */
    fromString(s, i) {
      e(typeof s == "string"), e(s.length > 8, "Not a bitcoin URI.");
      const p = s.substring(0, 8);
      e(p === "bitcoin:", "Not a bitcoin URI."), s = s.substring(8);
      const m = s.indexOf("?");
      let E, v;
      if (m === -1 ? E = s : (E = s.substring(0, m), v = s.substring(m + 1)), this.address.fromString(E, i), !v)
        return this;
      const b = f(v);
      return b.amount && (e(b.amount.length > 0, "Value is empty."), e(b.amount[0] !== "-", "Value is negative."), this.amount = d.value(b.amount)), b.label && (this.label = b.label), b.message && (this.message = b.message), b.r && (this.request = b.r), this;
    }
    /**
     * Instantiate uri from string.
     * @param {String} str
     * @param {Network?} network
     * @returns {URI}
     */
    static fromString(s, i) {
      return new this().fromString(s, i);
    }
    /**
     * Serialize uri to a string.
     * @returns {String}
     */
    toString() {
      let s = "bitcoin:";
      s += this.address.toString();
      const i = [];
      return this.amount !== -1 && i.push(`amount=${d.btc(this.amount)}`), this.label && i.push(`label=${u(this.label)}`), this.message && i.push(`message=${u(this.message)}`), this.request && i.push(`r=${u(this.request)}`), i.length > 0 && (s += "?" + i.join("&")), s;
    }
    /**
     * Inspect bitcoin uri.
     * @returns {String}
     */
    inspect() {
      return `<URI: ${this.toString()}>`;
    }
  }
  class g {
    constructor() {
      this.amount = null, this.label = null, this.message = null, this.r = null;
    }
  }
  function f(a) {
    const s = a.split("&"), i = new g();
    let p = 0;
    for (const m of s) {
      const E = m.indexOf("=");
      let v, b;
      if (E === -1 ? (v = m, b = "") : (v = m.substring(0, E), b = m.substring(E + 1)), v.length === 0) {
        e(b.length === 0, "Empty key in querystring.");
        continue;
      }
      switch (e(p < 4, "Too many keys in querystring."), v) {
        case "amount":
          e(i.amount == null, "Duplicate key in querystring (amount)."), i.amount = n(b);
          break;
        case "label":
          e(i.label == null, "Duplicate key in querystring (label)."), i.label = n(b);
          break;
        case "message":
          e(i.message == null, "Duplicate key in querystring (message)."), i.message = n(b);
          break;
        case "r":
          e(i.r == null, "Duplicate key in querystring (r)."), i.r = n(b);
          break;
        default:
          e(!1, `Unknown querystring key: ${b}.`);
          break;
      }
      p += 1;
    }
    return i;
  }
  function n(a) {
    try {
      a = decodeURIComponent(a), a = a.replace(/\+/g, " ");
    } catch {
      throw new Error("Malformed URI.");
    }
    if (a.indexOf("\0") !== -1)
      throw new Error("Malformed URI.");
    return a;
  }
  function u(a) {
    return a = encodeURIComponent(a), a = a.replace(/%20/g, "+"), a;
  }
  return Cc = w, Cc;
}
/*!
 * btc/index.js - high-level btc objects for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var H5;
function tx() {
  return H5 || (H5 = 1, gs.Amount = bi(), gs.URI = Gb()), gs;
}
var Yi = {}, Dc, L5;
function Wb() {
  if (L5) return Dc;
  L5 = 1;
  const e = Mt(), c = ni(), d = -1, w = k.alloc(8, 0), g = k.alloc(64, 0);
  g[0] = 128;
  const f = new Uint32Array([
    1518500249,
    1859775393,
    2400959708,
    3395469782
  ]);
  class n {
    constructor() {
      this.state = new Uint32Array(5), this.msg = new Uint32Array(80), this.block = k.alloc(64), this.size = d;
    }
    init() {
      return this.state[0] = 1732584193, this.state[1] = 4023233417, this.state[2] = 2562383102, this.state[3] = 271733878, this.state[4] = 3285377520, this.size = 0, this;
    }
    update(b) {
      return e(k.isBuffer(b)), this._update(b, b.length), this;
    }
    final() {
      return this._final(k.alloc(20));
    }
    _update(b, h) {
      e(this.size !== d, "Context is not initialized.");
      let o = this.size & 63, S = 0;
      if (this.size += h, o > 0) {
        let H = 64 - o;
        if (H > h && (H = h), b.copy(this.block, o, S, S + H), o += H, h -= H, S += H, o < 64)
          return;
        this._transform(this.block, 0);
      }
      for (; h >= 64; )
        this._transform(b, S), S += 64, h -= 64;
      h > 0 && b.copy(this.block, 0, S, S + h);
    }
    _final(b) {
      e(this.size !== d, "Context is not initialized.");
      const h = this.size & 63, o = this.size * 8;
      E(w, o * (1 / 4294967296) >>> 0, 0), E(w, o >>> 0, 4), this._update(g, 1 + (119 - h & 63)), this._update(w, 8);
      for (let S = 0; S < 5; S++)
        E(b, this.state[S], S * 4), this.state[S] = 0;
      for (let S = 0; S < 80; S++)
        this.msg[S] = 0;
      for (let S = 0; S < 64; S++)
        this.block[S] = 0;
      return this.size = d, b;
    }
    _transform(b, h) {
      const o = this.msg;
      let S = this.state[0], H = this.state[1], j = this.state[2], J = this.state[3], N = this.state[4], z = 0;
      for (; z < 16; z++)
        o[z] = m(b, h + z * 4);
      for (; z < 80; z++)
        o[z] = u(o[z - 3] ^ o[z - 8] ^ o[z - 14] ^ o[z - 16], 1);
      for (z = 0; z < 80; z++) {
        const A = z / 20 | 0, q = u(S, 5) + a(A, H, j, J) + N + o[z] + f[A];
        N = J, J = j, j = u(H, 30), H = S, S = q >>> 0;
      }
      this.state[0] += S, this.state[1] += H, this.state[2] += j, this.state[3] += J, this.state[4] += N;
    }
    static hash() {
      return new n();
    }
    static hmac() {
      return new c(n, 64);
    }
    static digest(b) {
      return n.ctx.init().update(b).final();
    }
    static root(b, h) {
      return e(k.isBuffer(b) && b.length === 20), e(k.isBuffer(h) && h.length === 20), n.ctx.init().update(b).update(h).final();
    }
    static multi(b, h, o) {
      const { ctx: S } = n;
      return S.init(), S.update(b), S.update(h), o && S.update(o), S.final();
    }
    static mac(b, h) {
      return n.hmac().init(h).update(b).final();
    }
  }
  n.native = 0, n.id = "SHA1", n.size = 20, n.bits = 160, n.blockSize = 64, n.zero = k.alloc(20, 0), n.ctx = new n();
  function u(v, b) {
    return v << b | v >>> 32 - b;
  }
  function a(v, b, h, o) {
    return v === 0 ? s(b, h, o) : v === 1 || v === 3 ? p(b, h, o) : v === 2 ? i(b, h, o) : 0;
  }
  function s(v, b, h) {
    return v & b ^ ~v & h;
  }
  function i(v, b, h) {
    return v & b ^ v & h ^ b & h;
  }
  function p(v, b, h) {
    return v ^ b ^ h;
  }
  function m(v, b) {
    return v[b++] * 16777216 + v[b++] * 65536 + v[b++] * 256 + v[b];
  }
  function E(v, b, h) {
    return v[h++] = b >>> 24, v[h++] = b >>> 16, v[h++] = b >>> 8, v[h++] = b, h;
  }
  return Dc = n, Dc;
}
var Uc = {};
/*!
 * policy.js - bitcoin constants for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var K5;
function mi() {
  return K5 || (K5 = 1, function(e) {
    const c = $e(), d = Ht();
    e.MAX_TX_VERSION = d.MAX_TX_VERSION, e.MAX_TX_SIZE = d.MAX_TX_SIZE / 10, e.MAX_TX_SIGOPS = d.MAX_TX_SIGOPS / 5, e.BYTES_PER_SIGOP = 20, e.MIN_RELAY = 1e3, e.BARE_MULTISIG = !0, e.FREE_THRESHOLD = d.COIN * 144 / 250, e.MAX_P2SH_SIGOPS = 15, e.MAX_OP_RETURN_BYTES = 223, e.MAX_OP_RETURN = 220, e.MAX_P2WSH_STACK = 100, e.MAX_P2WSH_PUSH = 80, e.MAX_P2WSH_SIZE = 3600, e.MEMPOOL_MAX_ANCESTORS = 50, e.MEMPOOL_MAX_SIZE = 100 * 1e6, e.MEMPOOL_EXPIRY_TIME = 4320 * 60, e.MEMPOOL_MAX_ORPHANS = 100, e.MIN_BLOCK_SIZE = 0, e.MAX_BLOCK_SIZE = d.MAX_FORK_BLOCK_SIZE, e.BLOCK_PRIORITY_SIZE = 0, e.BLOCK_PRIORITY_THRESHOLD = e.FREE_THRESHOLD, e.getMinFee = function(g, f) {
      if (f == null && (f = e.MIN_RELAY), c(g >= 0), c(f >= 0), g === 0)
        return 0;
      let n = Math.floor(f * g / 1e3);
      return n === 0 && f > 0 && (n = f), n;
    }, e.getRoundFee = function(g, f) {
      if (f == null && (f = e.MIN_RELAY), c(g >= 0), c(f >= 0), g === 0)
        return 0;
      let n = f * Math.ceil(g / 1e3);
      return n === 0 && f > 0 && (n = f), n;
    }, e.getRate = function(g, f) {
      return c(g >= 0), c(f >= 0), g === 0 ? 0 : Math.floor(f * 1e3 / g);
    };
  }(Uc)), Uc;
}
/*!
 * scripterror.js - script error for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var Fc, V5;
function ho() {
  if (V5) return Fc;
  V5 = 1;
  class e extends Error {
    /**
     * Create an error.
     * @constructor
     * @param {String} code - Error code.
     * @param {Opcode} op - Opcode.
     * @param {Number?} ip - Instruction pointer.
     */
    constructor(d, w, g) {
      super(), this.type = "ScriptError", this.code = d, this.message = d, this.op = -1, this.ip = -1, typeof w == "string" ? this.message = w : w && (this.message = `${d} (op=${w.toSymbol()}, ip=${g})`, this.op = w.value, this.ip = g), Error.captureStackTrace && Error.captureStackTrace(this, e);
    }
  }
  return Fc = e, Fc;
}
var Hc, $5;
function Li() {
  if ($5) return Hc;
  $5 = 1;
  const e = $e(), { I64: c } = Ah(), d = ho(), w = k.alloc(0);
  class g extends c {
    /**
     * Create a script number.
     * @constructor
     * @param {(Number|String|Buffer|Object)?} num
     * @param {(String|Number)?} base
     */
    constructor(n, u) {
      super(n, u);
    }
    /**
     * Cast to int32.
     * @returns {Number}
     */
    getInt() {
      return this.lt(c.INT32_MIN) ? c.LONG_MIN : this.gt(c.INT32_MAX) ? c.LONG_MAX : this.toInt();
    }
    /**
     * Serialize script number.
     * @returns {Buffer}
     */
    toRaw() {
      let n = this;
      if (n.isZero())
        return w;
      let u = !1;
      n.isNeg() && (n = n.neg(), u = !0);
      const a = n.byteLength();
      let s = 0;
      n.testn(a * 8 - 1) && (s = 1);
      const i = k.allocUnsafe(a + s);
      switch (a) {
        case 8:
          i[7] = n.hi >>> 24 & 255;
        case 7:
          i[6] = n.hi >> 16 & 255;
        case 6:
          i[5] = n.hi >> 8 & 255;
        case 5:
          i[4] = n.hi & 255;
        case 4:
          i[3] = n.lo >>> 24 & 255;
        case 3:
          i[2] = n.lo >> 16 & 255;
        case 2:
          i[1] = n.lo >> 8 & 255;
        case 1:
          i[0] = n.lo & 255;
      }
      return i[a - 1] & 128 ? (e(s === 1), e(i.length === a + s), i[a] = u ? 128 : 0) : u ? (e(s === 0), e(i.length === a), i[a - 1] |= 128) : (e(s === 0), e(i.length === a)), i;
    }
    /**
     * Instantiate script number from serialized data.
     * @private
     * @param {Buffer} data
     * @returns {ScriptNum}
     */
    fromRaw(n) {
      if (e(k.isBuffer(n)), n.length === 0)
        return this;
      switch (n.length) {
        case 8:
          this.hi |= n[7] << 24;
        case 7:
          this.hi |= n[6] << 16;
        case 6:
          this.hi |= n[5] << 8;
        case 5:
          this.hi |= n[4];
        case 4:
          this.lo |= n[3] << 24;
        case 3:
          this.lo |= n[2] << 16;
        case 2:
          this.lo |= n[1] << 8;
        case 1:
          this.lo |= n[0];
          break;
        default:
          for (let u = 0; u < n.length; u++)
            this.orb(u, n[u]);
          break;
      }
      return n[n.length - 1] & 128 && (this.setn(n.length * 8 - 1, 0), this.ineg()), this;
    }
    /**
     * Serialize script number.
     * @returns {Buffer}
     */
    encode() {
      return this.toRaw();
    }
    /**
     * Decode and verify script number.
     * @private
     * @param {Buffer} data
     * @param {Boolean?} minimal - Require minimal encoding.
     * @param {Number?} limit - Size limit.
     * @returns {ScriptNum}
     */
    decode(n, u, a) {
      if (e(k.isBuffer(n)), a != null && n.length > a)
        throw new d("UNKNOWN_ERROR", "Script number overflow.");
      if (u && !g.isMinimal(n))
        throw new d("UNKNOWN_ERROR", "Non-minimal script number.");
      return this.fromRaw(n);
    }
    /**
     * Inspect script number.
     * @returns {String}
     */
    inspect() {
      return `<ScriptNum: ${this.toString(10)}>`;
    }
    /**
     * Test wether a serialized script
     * number is in its most minimal form.
     * @param {Buffer} data
     * @returns {Boolean}
     */
    static isMinimal(n) {
      return e(k.isBuffer(n)), n.length === 0 ? !0 : !((n[n.length - 1] & 127) === 0 && (n.length === 1 || (n[n.length - 2] & 128) === 0));
    }
    /**
     * Encode serialized script number in its most minimal form.
     * @param {Buffer} data
     * @returns {Buffer} minimal encoded data
     */
    static toMinimal(n) {
      if (e(k.isBuffer(n)), this.isMinimal(n))
        return n;
      const u = n[n.length - 1];
      for (let a = n.length - 1; a > 0; a--)
        if (n[a - 1] !== 0)
          return n[a - 1] & 128 ? n[a++] = u : n[a - 1] |= u, n = n.slice(0, a), n;
      return n = k.alloc(0), n;
    }
    /**
     * Decode and verify script number.
     * @param {Buffer} data
     * @param {Boolean?} minimal - Require minimal encoding.
     * @param {Number?} limit - Size limit.
     * @returns {ScriptNum}
     */
    static decode(n, u, a) {
      return new this().decode(n, u, a);
    }
    /**
     * Test whether object is a script number.
     * @param {Object} obj
     * @returns {Boolean}
     */
    static isScriptNum(n) {
      return n instanceof g;
    }
  }
  return Hc = g, Hc;
}
var Lc = {}, j5;
function ts() {
  return j5 || (j5 = 1, function(e) {
    const c = $e(), d = Rr(), w = Li();
    e.opcodes = {
      // Push
      OP_0: 0,
      OP_PUSHDATA1: 76,
      OP_PUSHDATA2: 77,
      OP_PUSHDATA4: 78,
      OP_1NEGATE: 79,
      OP_RESERVED: 80,
      OP_1: 81,
      OP_2: 82,
      OP_3: 83,
      OP_4: 84,
      OP_5: 85,
      OP_6: 86,
      OP_7: 87,
      OP_8: 88,
      OP_9: 89,
      OP_10: 90,
      OP_11: 91,
      OP_12: 92,
      OP_13: 93,
      OP_14: 94,
      OP_15: 95,
      OP_16: 96,
      // Control
      OP_NOP: 97,
      OP_VER: 98,
      OP_IF: 99,
      OP_NOTIF: 100,
      OP_VERIF: 101,
      OP_VERNOTIF: 102,
      OP_ELSE: 103,
      OP_ENDIF: 104,
      OP_VERIFY: 105,
      OP_RETURN: 106,
      // Stack
      OP_TOALTSTACK: 107,
      OP_FROMALTSTACK: 108,
      OP_2DROP: 109,
      OP_2DUP: 110,
      OP_3DUP: 111,
      OP_2OVER: 112,
      OP_2ROT: 113,
      OP_2SWAP: 114,
      OP_IFDUP: 115,
      OP_DEPTH: 116,
      OP_DROP: 117,
      OP_DUP: 118,
      OP_NIP: 119,
      OP_OVER: 120,
      OP_PICK: 121,
      OP_ROLL: 122,
      OP_ROT: 123,
      OP_SWAP: 124,
      OP_TUCK: 125,
      // Splice
      OP_CAT: 126,
      OP_SPLIT: 127,
      OP_NUM2BIN: 128,
      OP_BIN2NUM: 129,
      OP_SIZE: 130,
      // Bit
      OP_INVERT: 131,
      OP_AND: 132,
      OP_OR: 133,
      OP_XOR: 134,
      OP_EQUAL: 135,
      OP_EQUALVERIFY: 136,
      OP_RESERVED1: 137,
      OP_RESERVED2: 138,
      // Numeric
      OP_1ADD: 139,
      OP_1SUB: 140,
      OP_2MUL: 141,
      OP_2DIV: 142,
      OP_NEGATE: 143,
      OP_ABS: 144,
      OP_NOT: 145,
      OP_0NOTEQUAL: 146,
      OP_ADD: 147,
      OP_SUB: 148,
      OP_MUL: 149,
      OP_DIV: 150,
      OP_MOD: 151,
      OP_LSHIFT: 152,
      OP_RSHIFT: 153,
      OP_BOOLAND: 154,
      OP_BOOLOR: 155,
      OP_NUMEQUAL: 156,
      OP_NUMEQUALVERIFY: 157,
      OP_NUMNOTEQUAL: 158,
      OP_LESSTHAN: 159,
      OP_GREATERTHAN: 160,
      OP_LESSTHANOREQUAL: 161,
      OP_GREATERTHANOREQUAL: 162,
      OP_MIN: 163,
      OP_MAX: 164,
      OP_WITHIN: 165,
      // Crypto
      OP_RIPEMD160: 166,
      OP_SHA1: 167,
      OP_SHA256: 168,
      OP_HASH160: 169,
      OP_HASH256: 170,
      OP_CODESEPARATOR: 171,
      OP_CHECKSIG: 172,
      OP_CHECKSIGVERIFY: 173,
      OP_CHECKMULTISIG: 174,
      OP_CHECKMULTISIGVERIFY: 175,
      // Expansion
      OP_NOP1: 176,
      OP_CHECKLOCKTIMEVERIFY: 177,
      OP_CHECKSEQUENCEVERIFY: 178,
      OP_NOP4: 179,
      OP_NOP5: 180,
      OP_NOP6: 181,
      OP_NOP7: 182,
      OP_NOP8: 183,
      OP_NOP9: 184,
      OP_NOP10: 185,
      // More Crypto
      OP_CHECKDATASIG: 186,
      OP_CHECKDATASIGVERIFY: 187,
      // additional byte-string operations
      OP_REVERSEBYTES: 188,
      // Custom
      OP_INVALIDOPCODE: 255
    }, e.opcodesByVal = {
      // Push
      0: "OP_0",
      76: "OP_PUSHDATA1",
      77: "OP_PUSHDATA2",
      78: "OP_PUSHDATA4",
      79: "OP_1NEGATE",
      80: "OP_RESERVED",
      81: "OP_1",
      82: "OP_2",
      83: "OP_3",
      84: "OP_4",
      85: "OP_5",
      86: "OP_6",
      87: "OP_7",
      88: "OP_8",
      89: "OP_9",
      90: "OP_10",
      91: "OP_11",
      92: "OP_12",
      93: "OP_13",
      94: "OP_14",
      95: "OP_15",
      96: "OP_16",
      // Control
      97: "OP_NOP",
      98: "OP_VER",
      99: "OP_IF",
      100: "OP_NOTIF",
      101: "OP_VERIF",
      102: "OP_VERNOTIF",
      103: "OP_ELSE",
      104: "OP_ENDIF",
      105: "OP_VERIFY",
      106: "OP_RETURN",
      // Stack
      107: "OP_TOALTSTACK",
      108: "OP_FROMALTSTACK",
      109: "OP_2DROP",
      110: "OP_2DUP",
      111: "OP_3DUP",
      112: "OP_2OVER",
      113: "OP_2ROT",
      114: "OP_2SWAP",
      115: "OP_IFDUP",
      116: "OP_DEPTH",
      117: "OP_DROP",
      118: "OP_DUP",
      119: "OP_NIP",
      120: "OP_OVER",
      121: "OP_PICK",
      122: "OP_ROLL",
      123: "OP_ROT",
      124: "OP_SWAP",
      125: "OP_TUCK",
      // Splice
      126: "OP_CAT",
      127: "OP_SPLIT",
      128: "OP_NUM2BIN",
      129: "OP_BIN2NUM",
      130: "OP_SIZE",
      // Bit
      131: "OP_INVERT",
      132: "OP_AND",
      133: "OP_OR",
      134: "OP_XOR",
      135: "OP_EQUAL",
      136: "OP_EQUALVERIFY",
      137: "OP_RESERVED1",
      138: "OP_RESERVED2",
      // Numeric
      139: "OP_1ADD",
      140: "OP_1SUB",
      141: "OP_2MUL",
      142: "OP_2DIV",
      143: "OP_NEGATE",
      144: "OP_ABS",
      145: "OP_NOT",
      146: "OP_0NOTEQUAL",
      147: "OP_ADD",
      148: "OP_SUB",
      149: "OP_MUL",
      150: "OP_DIV",
      151: "OP_MOD",
      152: "OP_LSHIFT",
      153: "OP_RSHIFT",
      154: "OP_BOOLAND",
      155: "OP_BOOLOR",
      156: "OP_NUMEQUAL",
      157: "OP_NUMEQUALVERIFY",
      158: "OP_NUMNOTEQUAL",
      159: "OP_LESSTHAN",
      160: "OP_GREATERTHAN",
      161: "OP_LESSTHANOREQUAL",
      162: "OP_GREATERTHANOREQUAL",
      163: "OP_MIN",
      164: "OP_MAX",
      165: "OP_WITHIN",
      // Crypto
      166: "OP_RIPEMD160",
      167: "OP_SHA1",
      168: "OP_SHA256",
      169: "OP_HASH160",
      170: "OP_HASH256",
      171: "OP_CODESEPARATOR",
      172: "OP_CHECKSIG",
      173: "OP_CHECKSIGVERIFY",
      174: "OP_CHECKMULTISIG",
      175: "OP_CHECKMULTISIGVERIFY",
      // Expansion
      176: "OP_NOP1",
      177: "OP_CHECKLOCKTIMEVERIFY",
      178: "OP_CHECKSEQUENCEVERIFY",
      179: "OP_NOP4",
      180: "OP_NOP5",
      181: "OP_NOP6",
      182: "OP_NOP7",
      183: "OP_NOP8",
      184: "OP_NOP9",
      185: "OP_NOP10",
      // More Crypto
      186: "OP_CHECKDATASIG",
      187: "OP_CHECKDATASIGVERIFY",
      // Additional byte-string operation
      188: "OP_REVERSEBYTES",
      // Custom
      255: "OP_INVALIDOPCODE"
    }, e.small = [
      k.from([129]),
      k.from([]),
      k.from([1]),
      k.from([2]),
      k.from([3]),
      k.from([4]),
      k.from([5]),
      k.from([6]),
      k.from([7]),
      k.from([8]),
      k.from([9]),
      k.from([10]),
      k.from([11]),
      k.from([12]),
      k.from([13]),
      k.from([14]),
      k.from([15]),
      k.from([16])
    ], e.flags = {
      VERIFY_NONE: 0,
      VERIFY_P2SH: 1,
      VERIFY_STRICTENC: 2,
      VERIFY_DERSIG: 4,
      VERIFY_LOW_S: 8,
      VERIFY_SIGPUSHONLY: 32,
      VERIFY_MINIMALDATA: 64,
      VERIFY_DISCOURAGE_UPGRADABLE_NOPS: 128,
      VERIFY_CLEANSTACK: 256,
      VERIFY_CHECKLOCKTIMEVERIFY: 512,
      VERIFY_CHECKSEQUENCEVERIFY: 1024,
      VERIFY_MINIMALIF: 8192,
      VERIFY_NULLFAIL: 16384,
      VERIFY_COMPRESSED_PUBKEYTYPE: 32768,
      VERIFY_SIGHASH_FORKID: 65536,
      VERIFY_REPLAY_PROTECTION: 1 << 17,
      VERIFY_CHECKDATASIG: 1 << 18,
      VERIFY_SCHNORR: 1 << 19,
      VERIFY_DISALLOW_SEGWIT_RECOVERY: 1 << 20,
      VERIFY_SCHNORR_MULTISIG: 1 << 21,
      VERIFY_INPUT_SIGCHECKS: 1 << 22,
      VERIFY_REVERSEBYTES: 1 << 23,
      VERIFY_ZERO_SIGOPS: 1 << 30,
      REPORT_SIGCHECKS: 1 << 31
    }, e.flags.MANDATORY_VERIFY_FLAGS = e.flags.VERIFY_P2SH, e.flags.STANDARD_VERIFY_FLAGS = 0 | e.flags.MANDATORY_VERIFY_FLAGS | e.flags.VERIFY_DERSIG | e.flags.VERIFY_STRICTENC | e.flags.VERIFY_MINIMALDATA | e.flags.VERIFY_SIGPUSHONLY | e.flags.VERIFY_DISCOURAGE_UPGRADABLE_NOPS | e.flags.VERIFY_CLEANSTACK | e.flags.VERIFY_MINIMALIF | e.flags.VERIFY_NULLFAIL | e.flags.VERIFY_CHECKLOCKTIMEVERIFY | e.flags.VERIFY_CHECKSEQUENCEVERIFY | e.flags.VERIFY_LOW_S | e.flags.VERIFY_SIGHASH_FORKID | e.flags.VERIFY_CHECKDATASIG | e.flags.VERIFY_DISALLOW_SEGWIT_RECOVERY | e.flags.VERIFY_SCHNORR_MULTISIG, e.flags.ONLY_STANDARD_VERIFY_FLAGS = e.flags.STANDARD_VERIFY_FLAGS & ~e.flags.MANDATORY_VERIFY_FLAGS, e.hashType = {
      /*
       * Sign all outputs.
       */
      ALL: 1,
      /*
       * Do not sign outputs (zero sequences).
       */
      NONE: 2,
      /*
       * Sign output at the same index (zero sequences).
       */
      SINGLE: 3,
      /*
       * Sighash fork ID.
       */
      SIGHASH_FORKID: 64,
      /*
       * Sign only the current input (mask).
       */
      ANYONECANPAY: 128
    }, e.hashTypeByVal = {
      1: "ALL",
      2: "NONE",
      3: "SINGLE",
      128: "ANYONECANPAY"
    }, e.types = {
      NONSTANDARD: 0,
      PUBKEY: 1,
      PUBKEYHASH: 2,
      SCRIPTHASH: 3,
      MULTISIG: 4,
      NULLDATA: 5
    }, e.typesByVal = {
      0: "NONSTANDARD",
      1: "PUBKEY",
      2: "PUBKEYHASH",
      3: "SCRIPTHASH",
      4: "MULTISIG",
      5: "NULLDATA"
    }, e.isHashType = function(f) {
      if (c(k.isBuffer(f)), f.length === 0)
        return !1;
      const n = f[f.length - 1] & ~(e.hashType.ANYONECANPAY | e.hashType.SIGHASH_FORKID);
      return !(n < e.hashType.ALL || n > e.hashType.SINGLE);
    }, e.countBits = function(f) {
      return f = f - (f >> 1 & 1431655765), f = (f & 858993459) + (f >> 2 & 858993459), (f + (f >> 4) & 252645135) * 16843009 >> 24;
    }, e.isSchnorr = function(f) {
      return c(k.isBuffer(f)), f.length === 64;
    }, e.isLowDER = function(f) {
      return e.isDERSignatureEncoding(f) ? d.isLowDER(f) : !1;
    }, e.isKeyEncoding = function(f) {
      if (c(k.isBuffer(f)), f.length < 33)
        return !1;
      if (f[0] === 4) {
        if (f.length !== 65)
          return !1;
      } else if (f[0] === 2 || f[0] === 3) {
        if (f.length !== 33)
          return !1;
      } else
        return !1;
      return !0;
    }, e.isCompressedEncoding = function(f) {
      return c(k.isBuffer(f)), !(f.length !== 33 || f[0] !== 2 && f[0] !== 3);
    }, e.isDERSignatureEncoding = function(f) {
      if (c(k.isBuffer(f)), f.length < 8 || f.length > 72 || f[0] !== 48 || f[1] !== f.length - 2)
        return !1;
      const n = f[3];
      if (5 + n >= f.length)
        return !1;
      const u = f[5 + n];
      return !(n + u + 6 !== f.length || f[2] !== 2 || n === 0 || f[4] & 128 || n > 1 && f[4] === 0 && !(f[5] & 128) || f[n + 4] !== 2 || u === 0 || f[n + 6] & 128 || u > 1 && f[n + 6] === 0 && !(f[n + 7] & 128));
    }, e.toASM = function(f, n) {
      if (f.length <= 4)
        return w.decode(f).toString(10);
      if (n && e.isDERSignatureEncoding(f.slice(0, -1))) {
        const u = f[f.length - 1];
        let a = e.hashTypeByVal[u & 31] || "";
        return a && (u & e.hashType.ANYONECANPAY && (a += "|ANYONECANPAY"), a = `[${a}]`), f.slice(0, -1).toString("hex") + a;
      }
      return f.toString("hex");
    }, e.hashTypeWithForkValue = function(f, n) {
      return n << 8 | f & 255;
    }, e.getHashTypeForkValue = function(f) {
      return f >>> 8;
    };
  }(Lc)), Lc;
}
var Kc, Y5;
function pl() {
  if (Y5) return Kc;
  Y5 = 1;
  const e = $e(), c = At(), d = Li(), w = ts(), g = w.opcodes, f = [];
  let n = null;
  class u {
    /**
     * Create an opcode.
     * Note: this should not be called directly.
     * @constructor
     * @param {Number} value - Opcode.
     * @param {Buffer?} data - Pushdata buffer.
     */
    constructor(i, p) {
      this.value = i || 0, this.data = p || null;
    }
    /**
     * Test whether a pushdata abides by minimaldata.
     * @returns {Boolean}
     */
    isMinimal() {
      return e(0 <= this.value && this.value <= g.OP_PUSHDATA4), this.data ? this.data.length === 1 && (this.data[0] === 129 || this.data[0] >= 1 && this.data[0] <= 16) ? !1 : this.data.length <= 75 ? this.value === this.data.length : this.data.length <= 255 ? this.value === g.OP_PUSHDATA1 : this.data.length <= 65535 ? this.value === g.OP_PUSHDATA2 : !0 : !0;
    }
    /**
     * Test whether opcode is a disabled opcode.
     * @param {Number?} flags - Script standard flags.
     * @returns {Boolean}
     */
    isDisabled(i) {
      switch (this.value) {
        case g.OP_INVERT:
        case g.OP_2MUL:
        case g.OP_2DIV:
        case g.OP_MUL:
        case g.OP_LSHIFT:
        case g.OP_RSHIFT:
          return !0;
      }
      return !1;
    }
    /**
     * Test whether opcode is a branch (if/else/endif).
     * @returns {Boolean}
     */
    isBranch() {
      return this.value >= g.OP_IF && this.value <= g.OP_ENDIF;
    }
    /**
     * Test opcode equality.
     * @param {Opcode} op
     * @returns {Boolean}
     */
    equals(i) {
      return e(u.isOpcode(i)), this.value !== i.value ? !1 : this.data ? (e(i.data), this.data.equals(i.data)) : (e(!i.data), !0);
    }
    /**
     * Convert Opcode to opcode value.
     * @returns {Number}
     */
    toOp() {
      return this.value;
    }
    /**
     * Covert opcode to data push.
     * @returns {Buffer|null}
     */
    toData() {
      return this.data;
    }
    /**
     * Covert opcode to data length.
     * @returns {Number}
     */
    toLength() {
      return this.data ? this.data.length : -1;
    }
    /**
     * Covert and _cast_ opcode to data push.
     * @returns {Buffer|null}
     */
    toPush() {
      return this.value === g.OP_0 ? w.small[1] : this.value === g.OP_1NEGATE ? w.small[0] : this.value >= g.OP_1 && this.value <= g.OP_16 ? w.small[this.value - 80 + 1] : this.toData();
    }
    /**
     * Get string for opcode.
     * @param {String?} enc
     * @returns {Buffer|null}
     */
    toString(i) {
      const p = this.toPush();
      return p ? p.toString(i || "utf8") : null;
    }
    /**
     * Convert opcode to small integer.
     * @returns {Number}
     */
    toSmall() {
      return this.value === g.OP_0 ? 0 : this.value >= g.OP_1 && this.value <= g.OP_16 ? this.value - 80 : -1;
    }
    /**
     * Convert opcode to script number.
     * @param {Boolean?} minimal
     * @param {Number?} limit
     * @returns {ScriptNum|null}
     */
    toNum(i, p) {
      return this.value === g.OP_0 ? d.fromInt(0) : this.value === g.OP_1NEGATE ? d.fromInt(-1) : this.value >= g.OP_1 && this.value <= g.OP_16 ? d.fromInt(this.value - 80) : this.data ? d.decode(this.data, i, p) : null;
    }
    /**
     * Convert opcode to integer.
     * @param {Boolean?} minimal
     * @param {Number?} limit
     * @returns {Number}
     */
    toInt(i, p) {
      const m = this.toNum(i, p);
      return m ? m.getInt() : -1;
    }
    /**
     * Convert opcode to boolean.
     * @returns {Boolean}
     */
    toBool() {
      const i = this.toSmall();
      return i === -1 ? !1 : i === 1;
    }
    /**
     * Convert opcode to its symbolic representation.
     * @returns {String}
     */
    toSymbol() {
      if (this.value === -1)
        return "OP_INVALIDOPCODE";
      const i = w.opcodesByVal[this.value];
      return i || `0x${a(this.value)}`;
    }
    /**
     * Calculate opcode size.
     * @returns {Number}
     */
    getSize() {
      if (!this.data)
        return 1;
      switch (this.value) {
        case g.OP_PUSHDATA1:
          return 2 + this.data.length;
        case g.OP_PUSHDATA2:
          return 3 + this.data.length;
        case g.OP_PUSHDATA4:
          return 5 + this.data.length;
        default:
          return 1 + this.data.length;
      }
    }
    /**
     * Encode the opcode to a buffer writer.
     * @param {BufferWriter} bw
     */
    toWriter(i) {
      if (this.value === -1)
        throw new Error("Cannot reserialize a parse error.");
      if (!this.data)
        return i.writeU8(this.value), i;
      switch (this.value) {
        case g.OP_PUSHDATA1:
          i.writeU8(this.value), i.writeU8(this.data.length), i.writeBytes(this.data);
          break;
        case g.OP_PUSHDATA2:
          i.writeU8(this.value), i.writeU16(this.data.length), i.writeBytes(this.data);
          break;
        case g.OP_PUSHDATA4:
          i.writeU8(this.value), i.writeU32(this.data.length), i.writeBytes(this.data);
          break;
        default:
          e(this.value === this.data.length), i.writeU8(this.value), i.writeBytes(this.data);
          break;
      }
      return i;
    }
    /**
     * Encode the opcode.
     * @returns {Buffer}
     */
    toRaw() {
      const i = this.getSize();
      return this.toWriter(c.write(i)).render();
    }
    /**
     * Convert the opcode to a bitcoind test string.
     * @returns {String} Human-readable script code.
     */
    toFormat() {
      if (this.value === -1)
        return "0x01";
      if (this.data) {
        if (this.data.length <= 4) {
          const b = this.toNum();
          if (this.equals(u.fromNum(b)))
            return b.toString(10);
        }
        const m = w.opcodesByVal[this.value], E = this.data.toString("hex");
        if (!m)
          return `0x${a(this.value)} 0x${E}`;
        let v = this.data.length.toString(16);
        for (; v.length % 2 !== 0; )
          v = "0" + v;
        return `${m} 0x${v} 0x${E}`;
      }
      const i = w.opcodesByVal[this.value];
      return i || `0x${a(this.value)}`;
    }
    /**
     * Format the opcode as bitcoind asm.
     * @param {Boolean?} decode - Attempt to decode hash types.
     * @returns {String} Human-readable script.
     */
    toASM(i) {
      return this.value === -1 ? "[error]" : this.data ? w.toASM(this.data, i) : w.opcodesByVal[this.value] || "OP_UNKNOWN";
    }
    /**
     * Instantiate an opcode from a number opcode.
     * @param {Number} op
     * @returns {Opcode}
     */
    static fromOp(i) {
      e(typeof i == "number");
      const p = f[i];
      return e(p, "Bad opcode."), p;
    }
    /**
     * Instantiate a pushdata opcode from
     * a buffer (will encode minimaldata).
     * @param {Buffer} data
     * @returns {Opcode}
     */
    static fromData(i) {
      if (e(k.isBuffer(i)), i.length === 1) {
        if (i[0] === 129)
          return this.fromOp(g.OP_1NEGATE);
        if (i[0] >= 1 && i[0] <= 16)
          return this.fromOp(i[0] + 80);
      }
      return this.fromPush(i);
    }
    /**
     * Instantiate a pushdata opcode from a
     * buffer (this differs from fromData in
     * that it will _always_ be a pushdata op).
     * @param {Buffer} data
     * @returns {Opcode}
     */
    static fromPush(i) {
      if (e(k.isBuffer(i)), i.length === 0)
        return this.fromOp(g.OP_0);
      if (i.length <= 75)
        return new this(i.length, i);
      if (i.length <= 255)
        return new this(g.OP_PUSHDATA1, i);
      if (i.length <= 65535)
        return new this(g.OP_PUSHDATA2, i);
      if (i.length <= 4294967295)
        return new this(g.OP_PUSHDATA4, i);
      throw new Error("Pushdata size too large.");
    }
    /**
     * Instantiate a pushdata opcode from a string.
     * @param {String} str
     * @param {String} [enc=utf8]
     * @returns {Opcode}
     */
    static fromString(i, p) {
      e(typeof i == "string");
      const m = k.from(i, p || "utf8");
      return this.fromData(m);
    }
    /**
     * Instantiate an opcode from a small number.
     * @param {Number} num
     * @returns {Opcode}
     */
    static fromSmall(i) {
      return e((i & 255) === i && i >= 0 && i <= 16), this.fromOp(i === 0 ? 0 : i + 80);
    }
    /**
     * Instantiate an opcode from a ScriptNum.
     * @param {ScriptNumber} num
     * @returns {Opcode}
     */
    static fromNum(i) {
      return e(d.isScriptNum(i)), this.fromData(i.encode());
    }
    /**
     * Instantiate an opcode from a Number.
     * @param {Number} num
     * @returns {Opcode}
     */
    static fromInt(i) {
      return e(Number.isSafeInteger(i)), i === 0 ? this.fromOp(g.OP_0) : i === -1 ? this.fromOp(g.OP_1NEGATE) : i >= 1 && i <= 16 ? this.fromOp(i + 80) : this.fromNum(d.fromNumber(i));
    }
    /**
     * Instantiate an opcode from a Number.
     * @param {Boolean} value
     * @returns {Opcode}
     */
    static fromBool(i) {
      return e(typeof i == "boolean"), this.fromSmall(i ? 1 : 0);
    }
    /**
     * Instantiate a pushdata opcode from symbolic name.
     * @example
     *   Opcode.fromSymbol('checksequenceverify')
     * @param {String} name
     * @returns {Opcode}
     */
    static fromSymbol(i) {
      e(typeof i == "string"), e(i.length > 0), i.charCodeAt(0) & 32 && (i = i.toUpperCase()), /^OP_/.test(i) || (i = `OP_${i}`);
      const p = w.opcodes[i];
      if (p != null)
        return this.fromOp(p);
      e(/^OP_0X/.test(i), "Unknown opcode."), e(i.length === 7, "Unknown opcode.");
      const m = parseInt(i.substring(5), 16);
      return e((m & 255) === m, "Unknown opcode."), this.fromOp(m);
    }
    /**
     * Instantiate opcode from buffer reader.
     * @param {BufferReader} br
     * @returns {Opcode}
     */
    static fromReader(i) {
      const p = i.readU8(), m = f[p];
      if (m)
        return m;
      switch (p) {
        case g.OP_PUSHDATA1: {
          if (i.left() < 1)
            return n;
          const E = i.readU8();
          if (i.left() < E)
            return i.seek(i.left()), n;
          const v = i.readBytes(E);
          return new this(p, v);
        }
        case g.OP_PUSHDATA2: {
          if (i.left() < 2)
            return i.seek(i.left()), n;
          const E = i.readU16();
          if (i.left() < E)
            return i.seek(i.left()), n;
          const v = i.readBytes(E);
          return new this(p, v);
        }
        case g.OP_PUSHDATA4: {
          if (i.left() < 4)
            return i.seek(i.left()), n;
          const E = i.readU32();
          if (i.left() < E)
            return i.seek(i.left()), n;
          const v = i.readBytes(E);
          return new this(p, v);
        }
        default: {
          if (i.left() < p)
            return i.seek(i.left()), n;
          const E = i.readBytes(p);
          return new this(p, E);
        }
      }
    }
    /**
     * Instantiate opcode from serialized data.
     * @param {Buffer} data
     * @returns {Opcode}
     */
    static fromRaw(i) {
      return this.fromReader(c.read(i));
    }
    /**
     * Test whether an object an Opcode.
     * @param {Object} obj
     * @returns {Boolean}
     */
    static isOpcode(i) {
      return i instanceof u;
    }
  }
  function a(s) {
    return s <= 15 ? "0" + s.toString(16) : s.toString(16);
  }
  n = Object.freeze(new u(-1));
  for (let s = 0; s <= 255; s++) {
    if (s >= 1 && s <= 78) {
      f.push(null);
      continue;
    }
    const i = new u(s);
    f.push(Object.freeze(i));
  }
  return Kc = u, Kc;
}
var Vc, X5;
function lo() {
  if (X5) return Vc;
  X5 = 1;
  const e = $e(), c = ts(), d = Li();
  class w {
    /**
     * Create a stack.
     * @constructor
     * @param {Buffer[]?} items - Stack items.
     */
    constructor(f) {
      this.items = f || [];
    }
    /**
     * Get length.
     * @returns {Number}
     */
    get length() {
      return this.items.length;
    }
    /**
     * Set length.
     * @param {Number} value
     */
    set length(f) {
      this.items.length = f;
    }
    /**
     * Instantiate a value-only iterator.
     * @returns {StackIterator}
     */
    [Symbol.iterator]() {
      return this.items[Symbol.iterator]();
    }
    /**
     * Instantiate a value-only iterator.
     * @returns {StackIterator}
     */
    values() {
      return this.items.values();
    }
    /**
     * Instantiate a key and value iterator.
     * @returns {StackIterator}
     */
    entries() {
      return this.items.entries();
    }
    /**
     * Inspect the stack.
     * @returns {String} Human-readable stack.
     */
    inspect() {
      return `<Stack: ${this.toString()}>`;
    }
    /**
     * Convert the stack to a string.
     * @returns {String} Human-readable stack.
     */
    toString() {
      const f = [];
      for (const n of this.items)
        f.push(n.toString("hex"));
      return f.join(" ");
    }
    /**
     * Format the stack as bitcoind asm.
     * @param {Boolean?} decode - Attempt to decode hash types.
     * @returns {String} Human-readable script.
     */
    toASM(f) {
      const n = [];
      for (const u of this.items)
        n.push(c.toASM(u, f));
      return n.join(" ");
    }
    /**
     * Clone the stack.
     * @returns {Stack} Cloned stack.
     */
    clone() {
      return new this.constructor(this.items.slice());
    }
    /**
     * Clear the stack.
     * @returns {Stack}
     */
    clear() {
      return this.items.length = 0, this;
    }
    /**
     * Get a stack item by index.
     * @param {Number} index
     * @returns {Buffer|null}
     */
    get(f) {
      return f < 0 && (f += this.items.length), f < 0 || f >= this.items.length ? null : this.items[f];
    }
    /**
     * Pop a stack item.
     * @see Array#pop
     * @returns {Buffer|null}
     */
    pop() {
      return this.items.pop() || null;
    }
    /**
     * Shift a stack item.
     * @see Array#shift
     * @returns {Buffer|null}
     */
    shift() {
      return this.items.shift() || null;
    }
    /**
     * Remove an item.
     * @param {Number} index
     * @returns {Buffer}
     */
    remove(f) {
      if (f < 0 && (f += this.items.length), f < 0 || f >= this.items.length)
        return null;
      const n = this.items.splice(f, 1);
      return n.length === 0 ? null : n[0];
    }
    /**
     * Set stack item at index.
     * @param {Number} index
     * @param {Buffer} value
     * @returns {Buffer}
     */
    set(f, n) {
      return f < 0 && (f += this.items.length), e(k.isBuffer(n)), e(f >= 0 && f <= this.items.length), this.items[f] = n, this;
    }
    /**
     * Push item onto stack.
     * @see Array#push
     * @param {Buffer} item
     * @returns {Number} Stack size.
     */
    push(f) {
      return e(k.isBuffer(f)), this.items.push(f), this;
    }
    /**
     * Unshift item from stack.
     * @see Array#unshift
     * @param {Buffer} item
     * @returns {Number}
     */
    unshift(f) {
      return e(k.isBuffer(f)), this.items.unshift(f), this;
    }
    /**
     * Insert an item.
     * @param {Number} index
     * @param {Buffer} item
     * @returns {Buffer}
     */
    insert(f, n) {
      return f < 0 && (f += this.items.length), e(k.isBuffer(n)), e(f >= 0 && f <= this.items.length), this.items.splice(f, 0, n), this;
    }
    /**
     * Erase stack items.
     * @param {Number} start
     * @param {Number} end
     * @returns {Buffer[]}
     */
    erase(f, n) {
      f < 0 && (f = this.items.length + f), n < 0 && (n = this.items.length + n), this.items.splice(f, n - f);
    }
    /**
     * Swap stack values.
     * @param {Number} i1 - Index 1.
     * @param {Number} i2 - Index 2.
     */
    swap(f, n) {
      f < 0 && (f = this.items.length + f), n < 0 && (n = this.items.length + n);
      const u = this.items[f], a = this.items[n];
      this.items[f] = a, this.items[n] = u;
    }
    /*
     * Data
     */
    getData(f) {
      return this.get(f);
    }
    popData() {
      return this.pop();
    }
    shiftData() {
      return this.shift();
    }
    removeData(f) {
      return this.remove(f);
    }
    setData(f, n) {
      return this.set(f, n);
    }
    pushData(f) {
      return this.push(f);
    }
    unshiftData(f) {
      return this.unshift(f);
    }
    insertData(f, n) {
      return this.insert(f, n);
    }
    /*
     * Length
     */
    getLength(f) {
      const n = this.get(f);
      return n ? n.length : -1;
    }
    /*
     * String
     */
    getString(f, n) {
      const u = this.get(f);
      return u ? w.toString(u, n) : null;
    }
    popString(f) {
      const n = this.pop();
      return n ? w.toString(n, f) : null;
    }
    shiftString(f) {
      const n = this.shift();
      return n ? w.toString(n, f) : null;
    }
    removeString(f, n) {
      const u = this.remove(f);
      return u ? w.toString(u, n) : null;
    }
    setString(f, n, u) {
      return this.set(f, w.fromString(n, u));
    }
    pushString(f, n) {
      return this.push(w.fromString(f, n));
    }
    unshiftString(f, n) {
      return this.unshift(w.fromString(f, n));
    }
    insertString(f, n, u) {
      return this.insert(f, w.fromString(n, u));
    }
    /*
     * Num
     */
    getNum(f, n, u) {
      const a = this.get(f);
      return a ? w.toNum(a, n, u) : null;
    }
    popNum(f, n) {
      const u = this.pop();
      return u ? w.toNum(u, f, n) : null;
    }
    shiftNum(f, n) {
      const u = this.shift();
      return u ? w.toNum(u, f, n) : null;
    }
    removeNum(f, n, u) {
      const a = this.remove(f);
      return a ? w.toNum(a, n, u) : null;
    }
    setNum(f, n) {
      return this.set(f, w.fromNum(n));
    }
    pushNum(f) {
      return this.push(w.fromNum(f));
    }
    unshiftNum(f) {
      return this.unshift(w.fromNum(f));
    }
    insertNum(f, n) {
      return this.insert(f, w.fromNum(n));
    }
    /*
     * Int
     */
    getInt(f, n, u) {
      const a = this.get(f);
      return a ? w.toInt(a, n, u) : -1;
    }
    popInt(f, n) {
      const u = this.pop();
      return u ? w.toInt(u, f, n) : -1;
    }
    shiftInt(f, n) {
      const u = this.shift();
      return u ? w.toInt(u, f, n) : -1;
    }
    removeInt(f, n, u) {
      const a = this.remove(f);
      return a ? w.toInt(a, n, u) : -1;
    }
    setInt(f, n) {
      return this.set(f, w.fromInt(n));
    }
    pushInt(f) {
      return this.push(w.fromInt(f));
    }
    unshiftInt(f) {
      return this.unshift(w.fromInt(f));
    }
    insertInt(f, n) {
      return this.insert(f, w.fromInt(n));
    }
    /*
     * Bool
     */
    getBool(f) {
      const n = this.get(f);
      return n ? w.toBool(n) : !1;
    }
    popBool() {
      const f = this.pop();
      return f ? w.toBool(f) : !1;
    }
    shiftBool() {
      const f = this.shift();
      return f ? w.toBool(f) : !1;
    }
    removeBool(f) {
      const n = this.remove(f);
      return n ? w.toBool(n) : !1;
    }
    setBool(f, n) {
      return this.set(f, w.fromBool(n));
    }
    pushBool(f) {
      return this.push(w.fromBool(f));
    }
    unshiftBool(f) {
      return this.unshift(w.fromBool(f));
    }
    insertBool(f, n) {
      return this.insert(f, w.fromBool(n));
    }
    /**
     * Test an object to see if it is a Stack.
     * @param {Object} obj
     * @returns {Boolean}
     */
    static isStack(f) {
      return f instanceof w;
    }
    /*
     * Encoding
     */
    static toString(f, n) {
      return e(k.isBuffer(f)), f.toString(n || "utf8");
    }
    static fromString(f, n) {
      return e(typeof f == "string"), k.from(f, n || "utf8");
    }
    static toNum(f, n, u) {
      return d.decode(f, n, u);
    }
    static fromNum(f) {
      return e(d.isScriptNum(f)), f.encode();
    }
    static toInt(f, n, u) {
      return w.toNum(f, n, u).getInt();
    }
    static fromInt(f) {
      if (e(typeof f == "number"), f >= -1 && f <= 16)
        return c.small[f + 1];
      const n = d.fromNumber(f);
      return w.fromNum(n);
    }
    static toBool(f) {
      e(k.isBuffer(f));
      for (let n = 0; n < f.length; n++)
        if (f[n] !== 0)
          return !(n === f.length - 1 && f[n] === 128);
      return !1;
    }
    static fromBool(f) {
      return e(typeof f == "boolean"), w.fromInt(f ? 1 : 0);
    }
  }
  return Vc = w, Vc;
}
var $c, J5;
function Zb() {
  if (J5) return $c;
  J5 = 1, $e();
  class e {
    constructor(d) {
      this.sigchecks = d || 0, this.init();
    }
    init() {
      return this.sigchecks;
    }
  }
  return $c = e, $c;
}
var jc, G5;
function Pr() {
  if (G5) return jc;
  G5 = 1;
  const e = $e(), c = At(), d = sl(), w = Wb(), g = wr(), f = Hi(), n = hr(), u = Rr(), a = Ht(), s = mi(), i = pl(), p = lo(), m = ho(), E = Li(), v = ts(), b = Lr(), h = Zb(), o = v.opcodes, S = v.types, H = v.countBits, { encoding: j } = c, J = k.alloc(0), N = new h();
  class z {
    /**
     * Create a script.
     * @constructor
     * @param {Buffer|Array|Object} code
     */
    constructor(y) {
      this.raw = J, this.code = [], y && this.fromOptions(y);
    }
    /**
     * Get length.
     * @returns {Number}
     */
    get length() {
      return this.code.length;
    }
    /**
     * Set length.
     * @param {Number} value
     */
    set length(y) {
      this.code.length = y;
    }
    /**
     * Inject properties from options object.
     * @private
     * @param {Object} options
     */
    fromOptions(y) {
      if (e(y, "Script data is required."), k.isBuffer(y))
        return this.fromRaw(y);
      if (Array.isArray(y))
        return this.fromArray(y);
      if (y.raw) {
        if (!y.code)
          return this.fromRaw(y.raw);
        e(k.isBuffer(y.raw), "Raw must be a Buffer."), this.raw = y.raw;
      }
      if (y.code) {
        if (!y.raw)
          return this.fromArray(y.code);
        e(Array.isArray(y.code), "Code must be an array."), this.code = y.code;
      }
      return this;
    }
    /**
     * Insantiate script from options object.
     * @param {Object} options
     * @returns {Script}
     */
    static fromOptions(y) {
      return new this().fromOptions(y);
    }
    /**
     * Instantiate a value-only iterator.
     * @returns {ScriptIterator}
     */
    values() {
      return this.code.values();
    }
    /**
     * Instantiate a key and value iterator.
     * @returns {ScriptIterator}
     */
    entries() {
      return this.code.entries();
    }
    /**
     * Instantiate a value-only iterator.
     * @returns {ScriptIterator}
     */
    [Symbol.iterator]() {
      return this.code[Symbol.iterator]();
    }
    /**
     * Convert the script to an array of
     * Buffers (pushdatas) and Numbers
     * (opcodes).
     * @returns {Array}
     */
    toArray() {
      return this.code.slice();
    }
    /**
     * Inject properties from an array of
     * of buffers and numbers.
     * @private
     * @param {Array} code
     * @returns {Script}
     */
    fromArray(y) {
      e(Array.isArray(y)), this.clear();
      for (const Y of y)
        this.push(Y);
      return this.compile();
    }
    /**
     * Instantiate script from an array
     * of buffers and numbers.
     * @param {Array} code
     * @returns {Script}
     */
    static fromArray(y) {
      return new this().fromArray(y);
    }
    /**
     * Convert script to stack items.
     * @returns {Buffer[]}
     */
    toItems() {
      const y = [];
      for (const Y of this.code) {
        const he = Y.toPush();
        if (!he)
          throw new Error("Non-push opcode in script.");
        y.push(he);
      }
      return y;
    }
    /**
     * Inject data from stack items.
     * @private
     * @param {Buffer[]} items
     * @returns {Script}
     */
    fromItems(y) {
      e(Array.isArray(y)), this.clear();
      for (const Y of y)
        this.pushData(Y);
      return this.compile();
    }
    /**
     * Instantiate script from stack items.
     * @param {Buffer[]} items
     * @returns {Script}
     */
    static fromItems(y) {
      return new this().fromItems(y);
    }
    /**
     * Convert script to stack.
     * @returns {Stack}
     */
    toStack() {
      return new p(this.toItems());
    }
    /**
     * Inject data from stack.
     * @private
     * @param {Stack} stack
     * @returns {Script}
     */
    fromStack(y) {
      return this.fromItems(y.items);
    }
    /**
     * Instantiate script from stack.
     * @param {Stack} stack
     * @returns {Script}
     */
    static fromStack(y) {
      return new this().fromStack(y);
    }
    /**
     * Clone the script.
     * @returns {Script} Cloned script.
     */
    clone() {
      return new this.constructor().inject(this);
    }
    /**
     * Inject properties from script.
     * Used for cloning.
     * @private
     * @param {Script} script
     * @returns {Script}
     */
    inject(y) {
      return this.raw = y.raw, this.code = y.code.slice(), this;
    }
    /**
     * Test equality against script.
     * @param {Script} script
     * @returns {Boolean}
     */
    equals(y) {
      return e(z.isScript(y)), this.raw.equals(y.raw);
    }
    /**
     * Compare against another script.
     * @param {Script} script
     * @returns {Number}
     */
    compare(y) {
      return e(z.isScript(y)), this.raw.compare(y.raw);
    }
    /**
     * Clear the script.
     * @returns {Script}
     */
    clear() {
      return this.raw = J, this.code.length = 0, this;
    }
    /**
     * Inspect the script.
     * @returns {String} Human-readable script code.
     */
    inspect() {
      return `<Script: ${this.toString()}>`;
    }
    /**
     * Convert the script to a bitcoind test string.
     * @returns {String} Human-readable script code.
     */
    toString() {
      const y = [];
      for (const Y of this.code)
        y.push(Y.toFormat());
      return y.join(" ");
    }
    /**
     * Format the script as bitcoind asm.
     * @param {Boolean?} decode - Attempt to decode hash types.
     * @returns {String} Human-readable script.
     */
    toASM(y) {
      this.isNulldata() && (y = !1);
      const Y = [];
      for (const he of this.code)
        Y.push(he.toASM(y));
      return Y.join(" ");
    }
    /**
     * Re-encode the script internally. Useful if you
     * changed something manually in the `code` array.
     * @returns {Script}
     */
    compile() {
      if (this.code.length === 0)
        return this.clear();
      let y = 0;
      for (const he of this.code)
        y += he.getSize();
      const Y = c.write(y);
      for (const he of this.code)
        he.toWriter(Y);
      return this.raw = Y.render(), this;
    }
    /**
     * Write the script to a buffer writer.
     * @param {BufferWriter} bw
     */
    toWriter(y) {
      return y.writeVarBytes(this.raw), y;
    }
    /**
     * Encode the script to a Buffer. See {@link Script#encode}.
     * @param {String} enc - Encoding, either `'hex'` or `null`.
     * @returns {Buffer|String} Serialized script.
     */
    toRaw() {
      return this.raw;
    }
    /**
     * Convert script to a hex string.
     * @returns {String}
     */
    toJSON() {
      return this.toRaw().toString("hex");
    }
    /**
     * Inject properties from json object.
     * @private
     * @param {String} json
     */
    fromJSON(y) {
      return e(typeof y == "string", "Code must be a string."), this.fromRaw(k.from(y, "hex"));
    }
    /**
     * Instantiate script from a hex string.
     * @params {String} json
     * @returns {Script}
     */
    static fromJSON(y) {
      return new this().fromJSON(y);
    }
    /**
     * Get the script's "subscript" starting at a separator.
     * @param {Number} index - The last separator to sign/verify beyond.
     * @returns {Script} Subscript.
     */
    getSubscript(y) {
      if (y === 0)
        return this.clone();
      const Y = new z();
      for (let he = y; he < this.code.length; he++) {
        const be = this.code[he];
        if (be.value === -1)
          break;
        Y.code.push(be);
      }
      return Y.compile();
    }
    /**
     * Get the script's "subscript" starting at a separator.
     * Remove all OP_CODESEPARATORs if present. This bizarre
     * behavior is necessary for signing and verification when
     * code separators are present.
     * @returns {Script} Subscript.
     */
    removeSeparators() {
      let y = !1;
      for (const he of this.code) {
        if (he.value === -1)
          break;
        if (he.value === o.OP_CODESEPARATOR) {
          y = !0;
          break;
        }
      }
      if (!y)
        return this;
      const Y = new z();
      for (const he of this.code) {
        if (he.value === -1)
          break;
        he.value !== o.OP_CODESEPARATOR && Y.code.push(he);
      }
      return Y.compile();
    }
    /**
     * Get the value of the checkBits while calculated as little endian.
     * @param {Buffer} abkam - Stack depth of the dummy element.
     * @param {Number?} nKeysCount - Stack depth of the top pubkeys.
     * @returns {Number}
     */
    bitcalculator(y, Y) {
      let he = 0;
      const be = (Y + 7) / 8;
      for (let xe = 0; xe < be; xe++)
        he |= y[xe] << 8 * xe;
      return he;
    }
    /**
     * Execute and interpret the script.
     * @param {Stack} stack - Script execution stack.
     * @param {Number?} flags - Script standard flags.
     * @param {TX?} tx - Transaction being verified.
     * @param {Number?} index - Index of input being verified.
     * @param {Amount?} value - Previous output value.
     * @param {Number?} sigchecks
     * @throws {ScriptError} Will be thrown on VERIFY failures.
     */
    execute(y, Y, he, be, xe, Ie) {
      if (Y == null && (Y = z.flags.STANDARD_VERIFY_FLAGS), this.getSize() > a.MAX_SCRIPT_SIZE)
        throw new m("SCRIPT_SIZE");
      const ve = [], C = [];
      let I = 0, se = 0, t = 0, l, B = !1;
      Y & z.flags.VERIFY_MINIMALDATA && (B = !0);
      for (let U = 0; U < this.code.length; U++) {
        const G = this.code[U];
        if (G.value === -1)
          throw new m("BAD_OPCODE", G, U);
        if (G.data && G.data.length > a.MAX_SCRIPT_PUSH)
          throw new m("PUSH_SIZE", G, U);
        if (G.value > o.OP_16 && ++se > a.MAX_SCRIPT_OPS)
          throw new m("OP_COUNT", G, U);
        if (G.isDisabled(Y))
          throw new m("DISABLED_OPCODE", G, U);
        if (t && !G.isBranch()) {
          if (y.length + C.length > a.MAX_SCRIPT_STACK)
            throw new m("STACK_SIZE", G, U);
          continue;
        }
        if (G.data && 0 <= G.value <= o.OP_PUSHDATA4) {
          if (B && !G.isMinimal())
            throw new m("MINIMALDATA", G, U);
          if (y.push(G.data), y.length + C.length > a.MAX_SCRIPT_STACK)
            throw new m("STACK_SIZE", G, U);
          continue;
        }
        switch (G.value) {
          case o.OP_0: {
            y.pushInt(0);
            break;
          }
          case o.OP_1NEGATE: {
            y.pushInt(-1);
            break;
          }
          case o.OP_1:
          case o.OP_2:
          case o.OP_3:
          case o.OP_4:
          case o.OP_5:
          case o.OP_6:
          case o.OP_7:
          case o.OP_8:
          case o.OP_9:
          case o.OP_10:
          case o.OP_11:
          case o.OP_12:
          case o.OP_13:
          case o.OP_14:
          case o.OP_15:
          case o.OP_16: {
            y.pushInt(G.value - 80);
            break;
          }
          case o.OP_NOP:
            break;
          case o.OP_CHECKLOCKTIMEVERIFY: {
            if (!(Y & z.flags.VERIFY_CHECKLOCKTIMEVERIFY)) {
              if (Y & z.flags.VERIFY_DISCOURAGE_UPGRADABLE_NOPS)
                throw new m("DISCOURAGE_UPGRADABLE_NOPS", G, U);
              break;
            }
            if (!he)
              throw new m("UNKNOWN_ERROR", "No TX passed in.");
            if (y.length === 0)
              throw new m("INVALID_STACK_OPERATION", G, U);
            const T = y.getNum(-1, B, 5);
            if (T.isNeg())
              throw new m("NEGATIVE_LOCKTIME", G, U);
            const M = T.toDouble();
            if (!he.verifyLocktime(be, M))
              throw new m("UNSATISFIED_LOCKTIME", G, U);
            break;
          }
          case o.OP_CHECKSEQUENCEVERIFY: {
            if (!(Y & z.flags.VERIFY_CHECKSEQUENCEVERIFY)) {
              if (Y & z.flags.VERIFY_DISCOURAGE_UPGRADABLE_NOPS)
                throw new m("DISCOURAGE_UPGRADABLE_NOPS", G, U);
              break;
            }
            if (!he)
              throw new m("UNKNOWN_ERROR", "No TX passed in.");
            if (y.length === 0)
              throw new m("INVALID_STACK_OPERATION", G, U);
            const T = y.getNum(-1, B, 5);
            if (T.isNeg())
              throw new m("NEGATIVE_LOCKTIME", G, U);
            const M = T.toDouble();
            if (!he.verifySequence(be, M))
              throw new m("UNSATISFIED_LOCKTIME", G, U);
            break;
          }
          case o.OP_NOP1:
          case o.OP_NOP4:
          case o.OP_NOP5:
          case o.OP_NOP6:
          case o.OP_NOP7:
          case o.OP_NOP8:
          case o.OP_NOP9:
          case o.OP_NOP10: {
            if (Y & z.flags.VERIFY_DISCOURAGE_UPGRADABLE_NOPS)
              throw new m("DISCOURAGE_UPGRADABLE_NOPS", G, U);
            break;
          }
          case o.OP_IF:
          case o.OP_NOTIF: {
            let T = !1;
            if (!t) {
              if (y.length < 1)
                throw new m("UNBALANCED_CONDITIONAL", G, U);
              if (Y & z.flags.VERIFY_MINIMALIF) {
                const M = y.get(-1);
                if (M.length > 1)
                  throw new m("MINIMALIF");
                if (M.length === 1 && M[0] !== 1)
                  throw new m("MINIMALIF");
              }
              T = y.getBool(-1), G.value === o.OP_NOTIF && (T = !T), y.pop();
            }
            ve.push(T), T || (t += 1);
            break;
          }
          case o.OP_ELSE: {
            if (ve.length === 0)
              throw new m("UNBALANCED_CONDITIONAL", G, U);
            ve[ve.length - 1] = !ve[ve.length - 1], ve[ve.length - 1] ? t -= 1 : t += 1;
            break;
          }
          case o.OP_ENDIF: {
            if (ve.length === 0)
              throw new m("UNBALANCED_CONDITIONAL", G, U);
            ve.pop() || (t -= 1);
            break;
          }
          case o.OP_VERIFY: {
            if (y.length === 0)
              throw new m("INVALID_STACK_OPERATION", G, U);
            if (!y.getBool(-1))
              throw new m("VERIFY", G, U);
            y.pop();
            break;
          }
          case o.OP_RETURN:
            throw new m("OP_RETURN", G, U);
          case o.OP_TOALTSTACK: {
            if (y.length === 0)
              throw new m("INVALID_STACK_OPERATION", G, U);
            C.push(y.pop());
            break;
          }
          case o.OP_FROMALTSTACK: {
            if (C.length === 0)
              throw new m("INVALID_ALTSTACK_OPERATION", G, U);
            y.push(C.pop());
            break;
          }
          case o.OP_2DROP: {
            if (y.length < 2)
              throw new m("INVALID_STACK_OPERATION", G, U);
            y.pop(), y.pop();
            break;
          }
          case o.OP_2DUP: {
            if (y.length < 2)
              throw new m("INVALID_STACK_OPERATION", G, U);
            const T = y.get(-2), M = y.get(-1);
            y.push(T), y.push(M);
            break;
          }
          case o.OP_3DUP: {
            if (y.length < 3)
              throw new m("INVALID_STACK_OPERATION", G, U);
            const T = y.get(-3), M = y.get(-2), $ = y.get(-1);
            y.push(T), y.push(M), y.push($);
            break;
          }
          case o.OP_2OVER: {
            if (y.length < 4)
              throw new m("INVALID_STACK_OPERATION", G, U);
            const T = y.get(-4), M = y.get(-3);
            y.push(T), y.push(M);
            break;
          }
          case o.OP_2ROT: {
            if (y.length < 6)
              throw new m("INVALID_STACK_OPERATION", G, U);
            const T = y.get(-6), M = y.get(-5);
            y.erase(-6, -4), y.push(T), y.push(M);
            break;
          }
          case o.OP_2SWAP: {
            if (y.length < 4)
              throw new m("INVALID_STACK_OPERATION", G, U);
            y.swap(-4, -2), y.swap(-3, -1);
            break;
          }
          case o.OP_IFDUP: {
            if (y.length === 0)
              throw new m("INVALID_STACK_OPERATION", G, U);
            if (y.getBool(-1)) {
              const T = y.get(-1);
              y.push(T);
            }
            break;
          }
          case o.OP_DEPTH: {
            y.pushInt(y.length);
            break;
          }
          case o.OP_DROP: {
            if (y.length === 0)
              throw new m("INVALID_STACK_OPERATION", G, U);
            y.pop();
            break;
          }
          case o.OP_DUP: {
            if (y.length === 0)
              throw new m("INVALID_STACK_OPERATION", G, U);
            y.push(y.get(-1));
            break;
          }
          case o.OP_NIP: {
            if (y.length < 2)
              throw new m("INVALID_STACK_OPERATION", G, U);
            y.remove(-2);
            break;
          }
          case o.OP_OVER: {
            if (y.length < 2)
              throw new m("INVALID_STACK_OPERATION", G, U);
            y.push(y.get(-2));
            break;
          }
          case o.OP_PICK:
          case o.OP_ROLL: {
            if (y.length < 2)
              throw new m("INVALID_STACK_OPERATION", G, U);
            const T = y.getInt(-1, B, 4);
            if (y.pop(), T < 0 || T >= y.length)
              throw new m("INVALID_STACK_OPERATION", G, U);
            const M = y.get(-T - 1);
            G.value === o.OP_ROLL && y.remove(-T - 1), y.push(M);
            break;
          }
          case o.OP_ROT: {
            if (y.length < 3)
              throw new m("INVALID_STACK_OPERATION", G, U);
            y.swap(-3, -2), y.swap(-2, -1);
            break;
          }
          case o.OP_SWAP: {
            if (y.length < 2)
              throw new m("INVALID_STACK_OPERATION", G, U);
            y.swap(-2, -1);
            break;
          }
          case o.OP_TUCK: {
            if (y.length < 2)
              throw new m("INVALID_STACK_OPERATION", G, U);
            y.insert(-2, y.get(-1));
            break;
          }
          case o.OP_SIZE: {
            if (y.length < 1)
              throw new m("INVALID_STACK_OPERATION", G, U);
            y.pushInt(y.get(-1).length);
            break;
          }
          case o.OP_EQUAL:
          case o.OP_EQUALVERIFY: {
            if (y.length < 2)
              throw new m("INVALID_STACK_OPERATION", G, U);
            const T = y.get(-2), M = y.get(-1), $ = T.equals(M);
            if (y.pop(), y.pop(), y.pushBool($), G.value === o.OP_EQUALVERIFY) {
              if (!$)
                throw new m("EQUALVERIFY", G, U);
              y.pop();
            }
            break;
          }
          case o.OP_1ADD:
          case o.OP_1SUB:
          case o.OP_NEGATE:
          case o.OP_ABS:
          case o.OP_NOT:
          case o.OP_0NOTEQUAL: {
            if (y.length < 1)
              throw new m("INVALID_STACK_OPERATION", G, U);
            let T = y.getNum(-1, B, 4), M;
            switch (G.value) {
              case o.OP_1ADD:
                T.iaddn(1);
                break;
              case o.OP_1SUB:
                T.isubn(1);
                break;
              case o.OP_NEGATE:
                T.ineg();
                break;
              case o.OP_ABS:
                T.iabs();
                break;
              case o.OP_NOT:
                M = T.isZero(), T = E.fromBool(M);
                break;
              case o.OP_0NOTEQUAL:
                M = !T.isZero(), T = E.fromBool(M);
                break;
              default:
                e(!1, "Fatal script error.");
                break;
            }
            y.pop(), y.pushNum(T);
            break;
          }
          case o.OP_ADD:
          case o.OP_SUB:
          case o.OP_DIV:
          case o.OP_MOD:
          case o.OP_BOOLAND:
          case o.OP_BOOLOR:
          case o.OP_NUMEQUAL:
          case o.OP_NUMEQUALVERIFY:
          case o.OP_NUMNOTEQUAL:
          case o.OP_LESSTHAN:
          case o.OP_GREATERTHAN:
          case o.OP_LESSTHANOREQUAL:
          case o.OP_GREATERTHANOREQUAL:
          case o.OP_MIN:
          case o.OP_MAX: {
            if (y.length < 2)
              throw new m("INVALID_STACK_OPERATION", G, U);
            const T = y.getNum(-2, B, 4), M = y.getNum(-1, B, 4);
            let $, r;
            switch (G.value) {
              case o.OP_ADD:
                $ = T.iadd(M);
                break;
              case o.OP_SUB:
                $ = T.isub(M);
                break;
              case o.OP_DIV:
                if (M.isZero())
                  throw new m("DIV_BY_ZERO", G, U);
                $ = T.div(M);
                break;
              case o.OP_MOD:
                if (M.isZero())
                  throw new m("MOD_BY_ZERO", G, U);
                $ = T.mod(M);
                break;
              case o.OP_BOOLAND:
                r = T.toBool() && M.toBool(), $ = E.fromBool(r);
                break;
              case o.OP_BOOLOR:
                r = T.toBool() || M.toBool(), $ = E.fromBool(r);
                break;
              case o.OP_NUMEQUAL:
                r = T.eq(M), $ = E.fromBool(r);
                break;
              case o.OP_NUMEQUALVERIFY:
                r = T.eq(M), $ = E.fromBool(r);
                break;
              case o.OP_NUMNOTEQUAL:
                r = !T.eq(M), $ = E.fromBool(r);
                break;
              case o.OP_LESSTHAN:
                r = T.lt(M), $ = E.fromBool(r);
                break;
              case o.OP_GREATERTHAN:
                r = T.gt(M), $ = E.fromBool(r);
                break;
              case o.OP_LESSTHANOREQUAL:
                r = T.lte(M), $ = E.fromBool(r);
                break;
              case o.OP_GREATERTHANOREQUAL:
                r = T.gte(M), $ = E.fromBool(r);
                break;
              case o.OP_MIN:
                $ = E.min(T, M);
                break;
              case o.OP_MAX:
                $ = E.max(T, M);
                break;
              default:
                e(!1, "Fatal script error.");
                break;
            }
            if (y.pop(), y.pop(), y.pushNum($), G.value === o.OP_NUMEQUALVERIFY) {
              if (!y.getBool(-1))
                throw new m("NUMEQUALVERIFY", G, U);
              y.pop();
            }
            break;
          }
          case o.OP_WITHIN: {
            if (y.length < 3)
              throw new m("INVALID_STACK_OPERATION", G, U);
            const T = y.getNum(-3, B, 4), M = y.getNum(-2, B, 4), $ = y.getNum(-1, B, 4), r = M.lte(T) && T.lt($);
            y.pop(), y.pop(), y.pop(), y.pushBool(r);
            break;
          }
          case o.OP_RIPEMD160: {
            if (y.length === 0)
              throw new m("INVALID_STACK_OPERATION", G, U);
            y.push(d.digest(y.pop()));
            break;
          }
          case o.OP_SHA1: {
            if (y.length === 0)
              throw new m("INVALID_STACK_OPERATION", G, U);
            y.push(w.digest(y.pop()));
            break;
          }
          case o.OP_SHA256: {
            if (y.length === 0)
              throw new m("INVALID_STACK_OPERATION", G, U);
            y.push(g.digest(y.pop()));
            break;
          }
          case o.OP_HASH160: {
            if (y.length === 0)
              throw new m("INVALID_STACK_OPERATION", G, U);
            y.push(f.digest(y.pop()));
            break;
          }
          case o.OP_HASH256: {
            if (y.length === 0)
              throw new m("INVALID_STACK_OPERATION", G, U);
            y.push(n.digest(y.pop()));
            break;
          }
          case o.OP_CODESEPARATOR: {
            I = U + 1;
            break;
          }
          case o.OP_CHECKSIG:
          case o.OP_CHECKSIGVERIFY: {
            if (!he)
              throw new m("UNKNOWN_ERROR", "No TX passed in.");
            if (y.length < 2)
              throw new m("INVALID_STACK_OPERATION", G, U);
            const T = y.get(-2), M = y.get(-1), $ = this.getSubscript(I);
            (!(Y & z.flags.VERIFY_SIGHASH_FORKID) || !(T[T.length - 1] & z.hashType.SIGHASH_FORKID)) && $.findAndDelete(T), R(T, Y), q(M, Y);
            let r = !1;
            if (T.length > 0) {
              const x = T[T.length - 1], O = he.signatureHash(
                be,
                $,
                xe,
                x,
                Y
              );
              r = Q(O, T.slice(0, -1), M, Y), N.sigchecks += 1, N.sigchecks;
            }
            if (!r && Y & z.flags.VERIFY_NULLFAIL && T.length !== 0)
              throw new m("NULLFAIL", G, U);
            if (y.pop(), y.pop(), y.pushBool(r), G.value === o.OP_CHECKSIGVERIFY) {
              if (!r)
                throw new m("CHECKSIGVERIFY", G, U);
              y.pop();
            }
            break;
          }
          case o.OP_CHECKDATASIG:
          case o.OP_CHECKDATASIGVERIFY: {
            if (y.length < 3)
              throw new m("INVALID_STACK_OPERATION", G, U);
            const T = y.get(-3), M = y.get(-2), $ = y.get(-1);
            ue(T, Y), q($, Y);
            let r = !1;
            if (T.length > 0) {
              const x = g.digest(M);
              r = Q(x, T, $, Y), N.sigchecks += 1, N.sigchecks;
            }
            if (!r && Y & z.flags.VERIFY_NULLFAIL && T.length !== 0)
              throw new m("NULLFAIL", G, U);
            if (y.pop(), y.pop(), y.pop(), y.pushBool(r), G.value === o.OP_CHECKDATASIGVERIFY) {
              if (!r)
                throw new m("CHECKDATASIGVERIFY", G, U);
              y.pop();
            }
            break;
          }
          case o.OP_CHECKMULTISIG:
          case o.OP_CHECKMULTISIGVERIFY: {
            if (!he)
              throw new m("UNKNOWN_ERROR", "No TX passed in.");
            let T = 1, M = 0, $, r;
            if (y.length < T)
              throw new m("INVALID_STACK_OPERATION", G, U);
            let x = y.getInt(-T, B, 4), O = x + 2, L, X;
            if (x < 0 || x > a.MAX_MULTISIG_PUBKEYS)
              throw new m("PUBKEY_COUNT", G, U);
            if (se += x, se > a.MAX_SCRIPT_OPS)
              throw new m("OP_COUNT", G, U);
            if (T += 1, $ = T, M = $ + x, L = T, T += x, y.length < M)
              throw new m("INVALID_STACK_OPERATION", G, U);
            let P = y.getInt(-M, B, 4);
            if (P < 0 || P > x)
              throw new m("SIG_COUNT", G, U);
            r = M + 1;
            const K = r + P;
            if (y.length < K)
              throw new m("INVALID_STACK_OPERATION", G, U);
            T += 1, X = T, T += P;
            const re = this.getSubscript(I);
            let ce = !0;
            if (Y & z.flags.VERIFY_SCHNORR_MULTISIG && y.get(-K).length !== 0) {
              if (e(a.MAX_MULTISIG_PUBKEYS < 32), x > 32)
                throw new m("INVALID_BITFIELD_SIZE", G, U);
              const le = Math.floor((x + 7) / 8), me = y.get(-K);
              if (me.length !== le)
                throw new m("BITFIELD_SIZE", G, U);
              l = this.bitcalculator(me, x);
              const ne = (1 << x) - 1, W = H(l);
              if ((l & ne) !== l)
                throw new m("BIT_RANGE", G, U);
              if (W !== P)
                throw new m("INVALID_BIT_COUNT", G, U);
              const te = $ + x - 1, pe = r + P - 1;
              let Ee = 0;
              for (let Ae = 0; Ae < P; Ae++, Ee++) {
                if (l >> Ee === 0)
                  throw new m("INVALID_BIT_RANGE", G, U);
                for (; (l >> Ee & 1) === 0; )
                  Ee++;
                if (Ee >= x)
                  throw new m("PUBKEY_COUNT", G, U);
                const Oe = y.get(-pe + Ae), Be = y.get(-te + Ee);
                if (Oe) {
                  if (V(Oe, Y), q(Be, Y), Oe.length > 0) {
                    const ke = Oe[Oe.length - 1], Ne = he.signatureHash(
                      be,
                      re,
                      xe,
                      ke,
                      Y
                    );
                    ce = Q(Ne, Oe.slice(0, -1), Be, Y), N.sigchecks += 1, N.sigchecks;
                  }
                  for (; T > 1; ) {
                    if (!ce && Y & z.flags.VERIFY_NULLFAIL && O === 0 && y.get(-1).length !== 0)
                      throw new m("NULLFAIL", G, U);
                    O > 0 && (O -= 1), y.pop(), T -= 1;
                  }
                }
              }
              if (l >> Ee !== 0)
                throw new m("INVALID_BIT_COUNT", G, U);
              y.pop(), y.pushBool(ce);
            } else {
              for (let le = 0; le < P; le++) {
                const me = y.get(-r - le);
                (!(Y & z.flags.VERIFY_SIGHASH_FORKID) || !(me[me.length - 1] & z.hashType.SIGHASH_FORKID)) && re.findAndDelete(me, Y);
              }
              for (; ce && P > 0; ) {
                const le = y.get(-X), me = y.get(-L);
                if (fe(le, Y), q(me, Y), le.length > 0) {
                  const ne = le[le.length - 1], W = he.signatureHash(
                    be,
                    re,
                    xe,
                    ne,
                    Y
                  );
                  Z(W, le, me) && (X += 1, P -= 1);
                }
                L += 1, x -= 1, P > x && (ce = !1);
              }
              for (; T > 1; ) {
                if (!ce && Y & z.flags.VERIFY_NULLFAIL && O === 0 && y.get(-1).length !== 0)
                  throw new m("NULLFAIL", G, U);
                O > 0 && (O -= 1), y.pop(), T -= 1;
              }
              if (y.length < 1)
                throw new m("INVALID_STACK_OPERATION", G, U);
              if (y.pop(), y.pushBool(ce), G.value === o.OP_CHECKMULTISIGVERIFY) {
                if (!ce)
                  throw new m("CHECKMULTISIGVERIFY", G, U);
                y.pop();
              }
            }
            break;
          }
          //
          // Byte string operations
          //
          case o.OP_CAT: {
            if (y.length < 2)
              throw new m("INVALID_STACK_OPERATION", G, U);
            const T = y.get(-2), M = y.get(-1);
            if (T.length + M.length > a.MAX_SCRIPT_PUSH)
              throw new m("PUSH_SIZE", G, U);
            y.pop(), y.pop(), y.push(k.concat([T, M]));
            break;
          }
          case o.OP_SPLIT: {
            if (y.length < 2)
              throw new m("INVALID_STACK_OPERATION", G, U);
            const T = y.get(-2), M = y.getInt(-1, B, 4);
            if (M < 0 || M > T.length)
              throw new m("INVALID_SPLIT_RANGE", G, U);
            const $ = T.slice(0, M), r = T.slice(M);
            y.set(-2, $), y.set(-1, r);
            break;
          }
          case o.OP_REVERSEBYTES: {
            if (y.length < 1)
              throw new m("INVALID_STACK_OPERATION", G, U);
            y.get(-1).reverse();
            break;
          }
          //
          // Bitwise logic
          //
          case o.OP_AND:
          case o.OP_OR:
          case o.OP_XOR: {
            if (y.length < 2)
              throw new m("INVALID_STACK_OPERATION", G, U);
            const T = y.get(-2), M = y.get(-1);
            if (T.length !== M.length)
              throw new m("INVALID_OPERAND_SIZE", G, U);
            const $ = k.alloc(T.length);
            switch (G.value) {
              case o.OP_AND:
                for (let r = 0; r < T.length; r++)
                  $[r] = T[r] & M[r];
                break;
              case o.OP_OR:
                for (let r = 0; r < T.length; r++)
                  $[r] = T[r] | M[r];
                break;
              case o.OP_XOR:
                for (let r = 0; r < T.length; r++)
                  $[r] = T[r] ^ M[r];
                break;
            }
            y.pop(), y.pop(), y.push($);
            break;
          }
          //
          // Conversion operations
          //
          case o.OP_NUM2BIN: {
            if (y.length < 2)
              throw new m("INVALID_STACK_OPERATION", G, U);
            const T = y.getInt(-1, B, 4);
            if (T < 0 || T > a.MAX_SCRIPT_PUSH)
              throw new m("PUSH_SIZE", G, U);
            y.pop();
            const M = y.get(-1), $ = E.toMinimal(k.from(M));
            if ($.length > T)
              throw new m("IMPOSSIBLE_ENCODING", G, U);
            if ($.length === T) {
              y.pop(), y.push($);
              break;
            }
            const r = k.alloc(T);
            $.copy(r);
            let x = 0;
            $.length > 0 && (x = $[$.length - 1] & 128, r[$.length - 1] &= 127), r[T - 1] = x, y.pop(), y.push(r);
            break;
          }
          case o.OP_BIN2NUM: {
            if (y.length < 1)
              throw new m("INVALID_STACK_OPERATION", G, U);
            const T = y.get(-1), M = E.toMinimal(k.from(T));
            if (y.pop(), y.push(M), !E.isMinimal(M) || M.length > 4)
              throw new m("INVALID_NUMBER_RANGE", G, U);
            break;
          }
          default:
            throw new m("BAD_OPCODE", G, U);
        }
      }
      if (y.length + C.length > a.MAX_SCRIPT_STACK)
        throw new m("STACK_SIZE");
      if (ve.length !== 0)
        throw new m("UNBALANCED_CONDITIONAL");
    }
    /**
     * Remove all matched data elements from
     * a script's code (used to remove signatures
     * before verification). Note that this
     * compares and removes data on the _byte level_.
     * It also reserializes the data to a single
     * script with minimaldata encoding beforehand.
     * A signature will _not_ be removed if it is
     * not minimaldata.
     * @see https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2014-November/006878.html
     * @see https://test.webbtc.com/tx/19aa42fee0fa57c45d3b16488198b27caaacc4ff5794510d0c17f173f05587ff
     * @param {Buffer} data - Data element to match against.
     * @returns {Number} Total.
     */
    findAndDelete(y) {
      const Y = i.fromPush(y);
      if (this.raw.length < Y.getSize())
        return 0;
      let he = !1;
      for (const Ie of this.code) {
        if (Ie.value === -1)
          break;
        if (Ie.equals(Y)) {
          he = !0;
          break;
        }
      }
      if (!he)
        return 0;
      const be = [];
      let xe = 0;
      for (const Ie of this.code) {
        if (Ie.value === -1)
          break;
        if (Ie.equals(Y)) {
          xe += 1;
          continue;
        }
        be.push(Ie);
      }
      return this.code = be, this.compile(), xe;
    }
    /**
     * Find a data element in a script.
     * @param {Buffer} data - Data element to match against.
     * @returns {Number} Index (`-1` if not present).
     */
    indexOf(y) {
      for (let Y = 0; Y < this.code.length; Y++) {
        const he = this.code[Y];
        if (he.value === -1)
          break;
        if (he.data && he.data.equals(y))
          return Y;
      }
      return -1;
    }
    /**
     * Test a script to see if it is likely
     * to be script code (no weird opcodes).
     * @param {Number?} flags - Script standard flags.
     * @returns {Boolean}
     */
    isCode(y) {
      y == null && (y = z.flags.STANDARD_VERIFY_FLAGS);
      for (const Y of this.code) {
        if (Y.value === -1 || Y.isDisabled(y))
          return !1;
        switch (Y.value) {
          case o.OP_RESERVED:
          case o.OP_NOP:
          case o.OP_VER:
          case o.OP_VERIF:
          case o.OP_VERNOTIF:
          case o.OP_RESERVED1:
          case o.OP_RESERVED2:
          case o.OP_NOP1:
            return !1;
        }
        if (Y.value > o.OP_CHECKSEQUENCEVERIFY)
          return !1;
      }
      return !0;
    }
    /**
     * Inject properties from a pay-to-pubkey script.
     * @private
     * @param {Buffer} key
     */
    fromPubkey(y) {
      return e(k.isBuffer(y) && (y.length === 33 || y.length === 65)), this.raw = k.allocUnsafe(1 + y.length + 1), this.raw[0] = y.length, y.copy(this.raw, 1), this.raw[1 + y.length] = o.OP_CHECKSIG, y = this.raw.slice(1, 1 + y.length), this.code.length = 0, this.code.push(i.fromPush(y)), this.code.push(i.fromOp(o.OP_CHECKSIG)), this;
    }
    /**
     * Create a pay-to-pubkey script.
     * @param {Buffer} key
     * @returns {Script}
     */
    static fromPubkey(y) {
      return new this().fromPubkey(y);
    }
    /**
     * Inject properties from a pay-to-pubkeyhash script.
     * @private
     * @param {Buffer} hash
     */
    fromPubkeyhash(y) {
      return e(k.isBuffer(y) && y.length === 20), this.raw = k.allocUnsafe(25), this.raw[0] = o.OP_DUP, this.raw[1] = o.OP_HASH160, this.raw[2] = 20, y.copy(this.raw, 3), this.raw[23] = o.OP_EQUALVERIFY, this.raw[24] = o.OP_CHECKSIG, y = this.raw.slice(3, 23), this.code.length = 0, this.code.push(i.fromOp(o.OP_DUP)), this.code.push(i.fromOp(o.OP_HASH160)), this.code.push(i.fromPush(y)), this.code.push(i.fromOp(o.OP_EQUALVERIFY)), this.code.push(i.fromOp(o.OP_CHECKSIG)), this;
    }
    /**
     * Create a pay-to-pubkeyhash script.
     * @param {Buffer} hash
     * @returns {Script}
     */
    static fromPubkeyhash(y) {
      return new this().fromPubkeyhash(y);
    }
    /**
     * Inject properties from pay-to-multisig script.
     * @private
     * @param {Number} m
     * @param {Number} n
     * @param {Buffer[]} keys
     */
    fromMultisig(y, Y, he) {
      e((y & 255) === y && (Y & 255) === Y), e(Array.isArray(he)), e(he.length === Y, "`n` keys are required for multisig."), e(y >= 1 && y <= Y), e(Y >= 1 && Y <= 15), this.clear(), this.pushSmall(y);
      for (const be of A(he))
        this.pushData(be);
      return this.pushSmall(Y), this.pushOp(o.OP_CHECKMULTISIG), this.compile();
    }
    /**
     * Create a pay-to-multisig script.
     * @param {Number} m
     * @param {Number} n
     * @param {Buffer[]} keys
     * @returns {Script}
     */
    static fromMultisig(y, Y, he) {
      return new this().fromMultisig(y, Y, he);
    }
    /**
     * Inject properties from a pay-to-scripthash script.
     * @private
     * @param {Buffer} hash
     */
    fromScripthash(y) {
      return e(k.isBuffer(y) && y.length === 20), this.raw = k.allocUnsafe(23), this.raw[0] = o.OP_HASH160, this.raw[1] = 20, y.copy(this.raw, 2), this.raw[22] = o.OP_EQUAL, y = this.raw.slice(2, 22), this.code.length = 0, this.code.push(i.fromOp(o.OP_HASH160)), this.code.push(i.fromPush(y)), this.code.push(i.fromOp(o.OP_EQUAL)), this;
    }
    /**
     * Create a pay-to-scripthash script.
     * @param {Buffer} hash
     * @returns {Script}
     */
    static fromScripthash(y) {
      return new this().fromScripthash(y);
    }
    /**
     * Inject properties from a nulldata/opreturn script.
     * @private
     * @param {Buffer} flags
     */
    fromNulldata(y) {
      return e(k.isBuffer(y)), e(y.length <= s.MAX_OP_RETURN, "Nulldata too large."), this.clear(), this.pushOp(o.OP_RETURN), this.pushData(y), this.compile();
    }
    /**
     * Create a nulldata/opreturn script.
     * @param {Buffer} flags
     * @returns {Script}
     */
    static fromNulldata(y) {
      return new this().fromNulldata(y);
    }
    /**
     * Inject properties from an address.
     * @private
     * @param {Address|AddressString} address
     */
    fromAddress(y) {
      if (typeof y == "string" && (y = b.fromString(y)), e(y instanceof b, "Not an address."), y.isPubkeyhash())
        return this.fromPubkeyhash(y.hash);
      if (y.isScripthash())
        return this.fromScripthash(y.hash);
      throw new Error("Unknown address type.");
    }
    /**
     * Create an output script from an address.
     * @param {Address|AddressString} address
     * @returns {Script}
     */
    static fromAddress(y) {
      return new this().fromAddress(y);
    }
    /**
     * Grab and deserialize the redeem script.
     * @returns {Script|null} Redeem script.
     */
    getRedeem() {
      let y = null;
      for (const Y of this.code) {
        if (Y.value === -1 || Y.value > o.OP_16)
          return null;
        y = Y.data;
      }
      return y ? z.fromRaw(y) : null;
    }
    /**
     * Get the standard script type.
     * @returns {ScriptType}
     */
    getType() {
      return this.isPubkey() ? S.PUBKEY : this.isPubkeyhash() ? S.PUBKEYHASH : this.isScripthash() ? S.SCRIPTHASH : this.isMultisig() ? S.MULTISIG : this.isNulldata() ? S.NULLDATA : S.NONSTANDARD;
    }
    /**
     * Test whether a script is of an unknown/non-standard type.
     * @returns {Boolean}
     */
    isUnknown() {
      return this.getType() === S.NONSTANDARD;
    }
    /**
     * Test whether the script is standard by policy standards.
     * @returns {Boolean}
     */
    isStandard() {
      const [y, Y] = this.getMultisig();
      return y !== -1 ? !(Y < 1 || Y > 3 || y < 1 || y > Y) : this.isNulldata() ? this.raw.length <= s.MAX_OP_RETURN_BYTES : this.getType() !== S.NONSTANDARD;
    }
    /**
     * Calculate the size of the script
     * excluding the varint size bytes.
     * @returns {Number}
     */
    getSize() {
      return this.raw.length;
    }
    /**
     * Calculate the size of the script
     * including the varint size bytes.
     * @returns {Number}
     */
    getVarSize() {
      return j.sizeVarBytes(this.raw);
    }
    /**
     * "Guess" the address of the input script.
     * This method is not 100% reliable.
     * @returns {Address|null}
     */
    getInputAddress() {
      return b.fromInputScript(this);
    }
    /**
     * Get the address of the script if present. Note that
     * pubkey and multisig scripts will be treated as though
     * they are pubkeyhash and scripthashes respectively.
     * @returns {Address|null}
     */
    getAddress() {
      return b.fromScript(this);
    }
    /**
     * Get the hash160 of the raw script.
     * @param {String?} enc
     * @returns {Hash}
     */
    hash160(y) {
      let Y = f.digest(this.toRaw());
      return y === "hex" && (Y = Y.toString("hex")), Y;
    }
    /**
     * Get the sha256 of the raw script.
     * @param {String?} enc
     * @returns {Hash}
     */
    sha256(y) {
      let Y = g.digest(this.toRaw());
      return y === "hex" && (Y = Y.toString("hex")), Y;
    }
    /**
     * Test whether the output script is pay-to-pubkey.
     * @param {Boolean} [minimal=false] - Minimaldata only.
     * @returns {Boolean}
     */
    isPubkey(y) {
      if (y)
        return this.raw.length >= 35 && (this.raw[0] === 33 || this.raw[0] === 65) && this.raw[0] + 2 === this.raw.length && this.raw[this.raw.length - 1] === o.OP_CHECKSIG;
      if (this.code.length !== 2)
        return !1;
      const Y = this.getLength(0);
      return (Y === 33 || Y === 65) && this.getOp(1) === o.OP_CHECKSIG;
    }
    /**
     * Get P2PK key if present.
     * @param {Boolean} [minimal=false] - Minimaldata only.
     * @returns {Buffer|null}
     */
    getPubkey(y) {
      return this.isPubkey(y) ? y ? this.raw.slice(1, 1 + this.raw[0]) : this.getData(0) : null;
    }
    /**
     * Test whether the output script is pay-to-pubkeyhash.
     * @param {Boolean} [minimal=false] - Minimaldata only.
     * @returns {Boolean}
     */
    isPubkeyhash(y) {
      return y || this.raw.length === 25 ? this.raw.length === 25 && this.raw[0] === o.OP_DUP && this.raw[1] === o.OP_HASH160 && this.raw[2] === 20 && this.raw[23] === o.OP_EQUALVERIFY && this.raw[24] === o.OP_CHECKSIG : this.code.length !== 5 ? !1 : this.getOp(0) === o.OP_DUP && this.getOp(1) === o.OP_HASH160 && this.getLength(2) === 20 && this.getOp(3) === o.OP_EQUALVERIFY && this.getOp(4) === o.OP_CHECKSIG;
    }
    /**
     * Get P2PKH hash if present.
     * @param {Boolean} [minimal=false] - Minimaldata only.
     * @returns {Buffer|null}
     */
    getPubkeyhash(y) {
      return this.isPubkeyhash(y) ? y ? this.raw.slice(3, 23) : this.getData(2) : null;
    }
    /**
       * Test whether the output script is pay-to-multisig.
       * @param {Boolean} [minimal=true] - Minimaldata only.
       * @returns {Boolean}
       */
    isMultisig(y) {
      if (this.code.length < 4 || this.code.length > 19 || this.getOp(-1) !== o.OP_CHECKMULTISIG)
        return !1;
      const Y = this.getSmall(0);
      if (Y < 1)
        return !1;
      const he = this.getSmall(-2);
      if (he < 1 || Y > he || this.code.length !== he + 3)
        return !1;
      for (let be = 1; be < he + 1; be++) {
        const xe = this.code[be], Ie = xe.toLength();
        if (Ie !== 33 && Ie !== 65 || y && !xe.isMinimal())
          return !1;
      }
      return !0;
    }
    /**
     * Get multisig m and n values if present.
     * @param {Boolean} [minimal=false] - Minimaldata only.
     * @returns {Array} [m, n]
     */
    getMultisig(y) {
      return this.isMultisig(y) ? [this.getSmall(0), this.getSmall(-2)] : [-1, -1];
    }
    /**
     * Test whether the output script is pay-to-scripthash. Note that
     * bitcoin itself requires scripthashes to be in strict minimaldata
     * encoding. Using `OP_HASH160 OP_PUSHDATA1 [hash] OP_EQUAL` will
     * _not_ be recognized as a scripthash.
     * @returns {Boolean}
     */
    isScripthash() {
      return this.raw.length === 23 && this.raw[0] === o.OP_HASH160 && this.raw[1] === 20 && this.raw[22] === o.OP_EQUAL;
    }
    /**
     * Get P2SH hash if present.
     * @returns {Buffer|null}
     */
    getScripthash() {
      return this.isScripthash() ? this.getData(1) : null;
    }
    /**
     * Test whether the output script is nulldata/opreturn.
     * @param {Boolean} [minimal=false] - Minimaldata only.
     * @returns {Boolean}
     */
    isNulldata(y) {
      if (this.code.length === 0 || this.getOp(0) !== o.OP_RETURN)
        return !1;
      if (this.code.length === 1)
        return !0;
      if (y && this.raw.length > s.MAX_OP_RETURN_BYTES)
        return !1;
      for (let Y = 1; Y < this.code.length; Y++) {
        const he = this.code[Y];
        if (he.value === -1 || he.value > o.OP_16 || y && !he.isMinimal())
          return !1;
      }
      return !0;
    }
    /**
     * Get OP_RETURN data if present.
     * @param {Boolean} [minimal=false] - Minimaldata only.
     * @returns {Buffer|null}
     */
    getNulldata(y) {
      if (!this.isNulldata(y))
        return null;
      for (let Y = 1; Y < this.code.length; Y++) {
        const be = this.code[Y].toPush();
        if (be)
          return be;
      }
      return J;
    }
    /**
     * Test whether the output script is a witness program.
     * Note that this will return true even for malformed
     * witness v0 programs.
     * @returns {Boolean}
     */
    isProgram() {
      return !(this.raw.length < 4 || this.raw.length > 42 || this.raw[0] !== o.OP_0 && (this.raw[0] < o.OP_1 || this.raw[0] > o.OP_16) || this.raw[1] + 2 !== this.raw.length);
    }
    /**
     * Test whether the output script is unspendable.
     * @returns {Boolean}
     */
    isUnspendable() {
      return this.raw.length > a.MAX_SCRIPT_SIZE ? !0 : this.raw.length > 0 && this.raw[0] === o.OP_RETURN;
    }
    /**
     * "Guess" the type of the input script.
     * This method is not 100% reliable.
     * @returns {ScriptType}
     */
    getInputType() {
      return this.isPubkeyInput() ? S.PUBKEY : this.isPubkeyhashInput() ? S.PUBKEYHASH : this.isScripthashInput() ? S.SCRIPTHASH : this.isMultisigInput() ? S.MULTISIG : S.NONSTANDARD;
    }
    /**
     * "Guess" whether the input script is an unknown/non-standard type.
     * This method is not 100% reliable.
     * @returns {Boolean}
     */
    isUnknownInput() {
      return this.getInputType() === S.NONSTANDARD;
    }
    /**
     * "Guess" whether the input script is pay-to-pubkey.
     * This method is not 100% reliable.
     * @returns {Boolean}
     */
    isPubkeyInput() {
      if (this.code.length !== 1)
        return !1;
      const y = this.getLength(0);
      return y >= 9 && y <= 73;
    }
    /**
     * Get P2PK signature if present.
     * @returns {Buffer|null}
     */
    getPubkeyInput() {
      return this.isPubkeyInput() ? this.getData(0) : null;
    }
    /**
     * "Guess" whether the input script is pay-to-pubkeyhash.
     * This method is not 100% reliable.
     * @returns {Boolean}
     */
    isPubkeyhashInput() {
      if (this.code.length !== 2)
        return !1;
      const y = this.getLength(0), Y = this.getLength(1);
      return y >= 9 && y <= 73 && (Y === 33 || Y === 65);
    }
    /**
     * Get P2PKH signature and key if present.
     * @returns {Array} [sig, key]
     */
    getPubkeyhashInput() {
      return this.isPubkeyhashInput() ? [this.getData(0), this.getData(1)] : [null, null];
    }
    /**
     * "Guess" whether the input script is pay-to-multisig.
     * This method is not 100% reliable.
     * @returns {Boolean}
     */
    isMultisigInput() {
      if (this.code.length < 2 || this.getOp(0) !== o.OP_0 || this.getOp(1) > o.OP_PUSHDATA4 || this.isScripthashInput())
        return !1;
      for (let y = 1; y < this.code.length; y++) {
        const Y = this.getLength(y);
        if (Y < 9 || Y > 73)
          return !1;
      }
      return !0;
    }
    /**
     * Get multisig signatures if present.
     * @returns {Buffer[]|null}
     */
    getMultisigInput() {
      if (!this.isMultisigInput())
        return null;
      const y = [];
      for (let Y = 1; Y < this.code.length; Y++)
        y.push(this.getData(Y));
      return y;
    }
    /**
     * "Guess" whether the input script is pay-to-scripthash.
     * This method is not 100% reliable.
     * @returns {Boolean}
     */
    isScripthashInput() {
      if (this.code.length < 1)
        return !1;
      const y = this.getData(-1);
      if (!y || y.length === 0 || v.isDERSignatureEncoding(y.slice(0, -1)) || v.isKeyEncoding(y))
        return !1;
      const Y = z.fromRaw(y);
      return !(!Y.isCode() || Y.isUnspendable() || !this.isPushOnly());
    }
    /**
     * Get P2SH redeem script if present.
     * @returns {Buffer|null}
     */
    getScripthashInput() {
      return this.isScripthashInput() ? this.getData(-1) : null;
    }
    /**
     * Get coinbase height.
     * @returns {Number} `-1` if not present.
     */
    getCoinbaseHeight() {
      return z.getCoinbaseHeight(this.raw);
    }
    /**
     * Get coinbase height.
     * @param {Buffer} raw - Raw script.
     * @returns {Number} `-1` if not present.
     */
    static getCoinbaseHeight(y) {
      if (y.length === 0)
        return -1;
      if (y[0] >= o.OP_1 && y[0] <= o.OP_16)
        return y[0] - 80;
      if (y[0] > 6)
        return -1;
      const Y = i.fromRaw(y), he = Y.toNum();
      return he ? he.isNeg() || !Y.equals(i.fromNum(he)) ? -1 : he.toDouble() : 1;
    }
    /**
     * Test the script against a bloom filter.
     * @param {Bloom} filter
     * @returns {Boolean}
     */
    test(y) {
      for (const Y of this.code) {
        if (Y.value === -1)
          break;
        if (!(!Y.data || Y.data.length === 0) && y.test(Y.data))
          return !0;
      }
      return !1;
    }
    /**
     * Test the script to see if it contains only push ops.
     * Push ops are: OP_1NEGATE, OP_0-OP_16 and all PUSHDATAs.
     * @returns {Boolean}
     */
    isPushOnly() {
      for (const y of this.code)
        if (y.value === -1 || y.value > o.OP_16)
          return !1;
      return !0;
    }
    /**
     * Count the sigops in the script.
     * @param {Boolean} accurate - Whether to enable accurate counting. This will
     * take into account the `n` value for OP_CHECKMULTISIG(VERIFY).
     * @returns {Number} sigop count
     */
    getSigops(y, Y) {
      if (Y & z.flags.VERIFY_ZERO_SIGOPS)
        return 0;
      let he = 0, be = -1;
      for (const xe of this.code) {
        if (xe.value === -1)
          break;
        switch (xe.value) {
          case o.OP_CHECKSIG:
          case o.OP_CHECKSIGVERIFY:
            he += 1;
            break;
          case o.OP_CHECKSDATAIG:
          case o.OP_CHECKDATASIGVERIFY:
            Y & z.flags.VERIFY_CHECKDATASIG && (he += 1);
            break;
          case o.OP_CHECKMULTISIG:
          case o.OP_CHECKMULTISIGVERIFY:
            y && be >= o.OP_1 && be <= o.OP_16 ? he += be - 80 : he += a.MAX_MULTISIG_PUBKEYS;
            break;
        }
        be = xe.value;
      }
      return he;
    }
    /**
     * Count the sigops in the script, taking into account redeem scripts.
     * @param {Script} input - Input script, needed for access to redeem script.
     * @param {VerifyFlags} flags
     * @returns {Number} sigop count
     */
    getScripthashSigops(y, Y) {
      if (!this.isScripthash())
        return this.getSigops(!0, Y);
      const he = y.getRedeem();
      return he ? he.getSigops(!0, Y) : 0;
    }
    /*
     * Mutation
     */
    get(y) {
      return y < 0 && (y += this.code.length), y < 0 || y >= this.code.length ? null : this.code[y];
    }
    pop() {
      return this.code.pop() || null;
    }
    shift() {
      return this.code.shift() || null;
    }
    remove(y) {
      if (y < 0 && (y += this.code.length), y < 0 || y >= this.code.length)
        return null;
      const Y = this.code.splice(y, 1);
      return Y.length === 0 ? null : Y[0];
    }
    set(y, Y) {
      return y < 0 && (y += this.code.length), e(i.isOpcode(Y)), e(y >= 0 && y <= this.code.length), this.code[y] = Y, this;
    }
    push(y) {
      return e(i.isOpcode(y)), this.code.push(y), this;
    }
    unshift(y) {
      return e(i.isOpcode(y)), this.code.unshift(y), this;
    }
    insert(y, Y) {
      return y < 0 && (y += this.code.length), e(i.isOpcode(Y)), e(y >= 0 && y <= this.code.length), this.code.splice(y, 0, Y), this;
    }
    /*
     * Op
     */
    getOp(y) {
      const Y = this.get(y);
      return Y ? Y.value : -1;
    }
    popOp() {
      const y = this.pop();
      return y ? y.value : -1;
    }
    shiftOp() {
      const y = this.shift();
      return y ? y.value : -1;
    }
    removeOp(y) {
      const Y = this.remove(y);
      return Y ? Y.value : -1;
    }
    setOp(y, Y) {
      return this.set(y, i.fromOp(Y));
    }
    pushOp(y) {
      return this.push(i.fromOp(y));
    }
    unshiftOp(y) {
      return this.unshift(i.fromOp(y));
    }
    insertOp(y, Y) {
      return this.insert(y, i.fromOp(Y));
    }
    /*
     * Data
     */
    getData(y) {
      const Y = this.get(y);
      return Y ? Y.data : null;
    }
    popData() {
      const y = this.pop();
      return y ? y.data : null;
    }
    shiftData() {
      const y = this.shift();
      return y ? y.data : null;
    }
    removeData(y) {
      const Y = this.remove(y);
      return Y ? Y.data : null;
    }
    setData(y, Y) {
      return this.set(y, i.fromData(Y));
    }
    pushData(y) {
      return this.push(i.fromData(y));
    }
    unshiftData(y) {
      return this.unshift(i.fromData(y));
    }
    insertData(y, Y) {
      return this.insert(y, i.fromData(Y));
    }
    /*
     * Length
     */
    getLength(y) {
      const Y = this.get(y);
      return Y ? Y.toLength() : -1;
    }
    /*
     * Push
     */
    getPush(y) {
      const Y = this.get(y);
      return Y ? Y.toPush() : null;
    }
    popPush() {
      const y = this.pop();
      return y ? y.toPush() : null;
    }
    shiftPush() {
      const y = this.shift();
      return y ? y.toPush() : null;
    }
    removePush(y) {
      const Y = this.remove(y);
      return Y ? Y.toPush() : null;
    }
    setPush(y, Y) {
      return this.set(y, i.fromPush(Y));
    }
    pushPush(y) {
      return this.push(i.fromPush(y));
    }
    unshiftPush(y) {
      return this.unshift(i.fromPush(y));
    }
    insertPush(y, Y) {
      return this.insert(y, i.fromPush(Y));
    }
    /*
     * String
     */
    getString(y, Y) {
      const he = this.get(y);
      return he ? he.toString(Y) : null;
    }
    popString(y) {
      const Y = this.pop();
      return Y ? Y.toString(y) : null;
    }
    shiftString(y) {
      const Y = this.shift();
      return Y ? Y.toString(y) : null;
    }
    removeString(y, Y) {
      const he = this.remove(y);
      return he ? he.toString(Y) : null;
    }
    setString(y, Y, he) {
      return this.set(y, i.fromString(Y, he));
    }
    pushString(y, Y) {
      return this.push(i.fromString(y, Y));
    }
    unshiftString(y, Y) {
      return this.unshift(i.fromString(y, Y));
    }
    insertString(y, Y, he) {
      return this.insert(y, i.fromString(Y, he));
    }
    /*
     * Small
     */
    getSmall(y) {
      const Y = this.get(y);
      return Y ? Y.toSmall() : -1;
    }
    popSmall() {
      const y = this.pop();
      return y ? y.toSmall() : -1;
    }
    shiftSmall() {
      const y = this.shift();
      return y ? y.toSmall() : -1;
    }
    removeSmall(y) {
      const Y = this.remove(y);
      return Y ? Y.toSmall() : -1;
    }
    setSmall(y, Y) {
      return this.set(y, i.fromSmall(Y));
    }
    pushSmall(y) {
      return this.push(i.fromSmall(y));
    }
    unshiftSmall(y) {
      return this.unshift(i.fromSmall(y));
    }
    insertSmall(y, Y) {
      return this.insert(y, i.fromSmall(Y));
    }
    /*
     * Num
     */
    getNum(y, Y, he) {
      const be = this.get(y);
      return be ? be.toNum(Y, he) : null;
    }
    popNum(y, Y) {
      const he = this.pop();
      return he ? he.toNum(y, Y) : null;
    }
    shiftNum(y, Y) {
      const he = this.shift();
      return he ? he.toNum(y, Y) : null;
    }
    removeNum(y, Y, he) {
      const be = this.remove(y);
      return be ? be.toNum(Y, he) : null;
    }
    setNum(y, Y) {
      return this.set(y, i.fromNum(Y));
    }
    pushNum(y) {
      return this.push(i.fromNum(y));
    }
    unshiftNum(y) {
      return this.unshift(i.fromNum(y));
    }
    insertNum(y, Y) {
      return this.insert(y, i.fromNum(Y));
    }
    /*
     * Int
     */
    getInt(y, Y, he) {
      const be = this.get(y);
      return be ? be.toInt(Y, he) : -1;
    }
    popInt(y, Y) {
      const he = this.pop();
      return he ? he.toInt(y, Y) : -1;
    }
    shiftInt(y, Y) {
      const he = this.shift();
      return he ? he.toInt(y, Y) : -1;
    }
    removeInt(y, Y, he) {
      const be = this.remove(y);
      return be ? be.toInt(Y, he) : -1;
    }
    setInt(y, Y) {
      return this.set(y, i.fromInt(Y));
    }
    pushInt(y) {
      return this.push(i.fromInt(y));
    }
    unshiftInt(y) {
      return this.unshift(i.fromInt(y));
    }
    insertInt(y, Y) {
      return this.insert(y, i.fromInt(Y));
    }
    /*
     * Bool
     */
    getBool(y) {
      const Y = this.get(y);
      return Y ? Y.toBool() : !1;
    }
    popBool() {
      const y = this.pop();
      return y ? y.toBool() : !1;
    }
    shiftBool() {
      const y = this.shift();
      return y ? y.toBool() : !1;
    }
    removeBool(y) {
      const Y = this.remove(y);
      return Y ? Y.toBool() : !1;
    }
    setBool(y, Y) {
      return this.set(y, i.fromBool(Y));
    }
    pushBool(y) {
      return this.push(i.fromBool(y));
    }
    unshiftBool(y) {
      return this.unshift(i.fromBool(y));
    }
    insertBool(y, Y) {
      return this.insert(y, i.fromBool(Y));
    }
    /*
     * Symbol
     */
    getSym(y) {
      const Y = this.get(y);
      return Y ? Y.toSymbol() : null;
    }
    popSym() {
      const y = this.pop();
      return y ? y.toSymbol() : null;
    }
    shiftSym() {
      const y = this.shift();
      return y ? y.toSymbol() : null;
    }
    removeSym(y) {
      const Y = this.remove(y);
      return Y ? Y.toSymbol() : null;
    }
    setSym(y, Y) {
      return this.set(y, i.fromSymbol(Y));
    }
    pushSym(y) {
      return this.push(i.fromSymbol(y));
    }
    unshiftSym(y) {
      return this.unshift(i.fromSymbol(y));
    }
    insertSym(y, Y) {
      return this.insert(y, i.fromSymbol(Y));
    }
    /**
     * Inject properties from bitcoind test string.
     * @private
     * @param {String} items - Script string.
     * @throws Parse error.
     */
    fromString(y) {
      if (e(typeof y == "string"), y = y.trim(), y.length === 0)
        return this;
      const Y = y.split(/\s+/), he = c.write();
      for (const be of Y) {
        let xe = be;
        xe.charCodeAt(0) & 32 && (xe = xe.toUpperCase()), /^OP_/.test(xe) || (xe = `OP_${xe}`);
        const Ie = o[xe];
        if (Ie == null) {
          if (be[0] === "'") {
            e(be[be.length - 1] === "'", "Invalid string.");
            const I = be.slice(1, -1), se = i.fromString(I);
            he.writeBytes(se.toRaw());
            continue;
          }
          if (/^-?\d+$/.test(be)) {
            const I = E.fromString(be, 10), se = i.fromNum(I);
            he.writeBytes(se.toRaw());
            continue;
          }
          e(be.indexOf("0x") === 0, "Unknown opcode.");
          const ve = be.substring(2), C = k.from(ve, "hex");
          e(C.length === ve.length / 2, "Invalid hex string."), he.writeBytes(C);
          continue;
        }
        he.writeU8(Ie);
      }
      return this.fromRaw(he.render());
    }
    /**
     * Parse a bitcoind test script
     * string into a script object.
     * @param {String} items - Script string.
     * @returns {Script}
     * @throws Parse error.
     */
    static fromString(y) {
      return new this().fromString(y);
    }
    /**
     * Verify an input and output script, and a witness if present.
     * @param {Script} input
     * @param {Null} witness
     * @param {Script} output
     * @param {TX} tx
     * @param {Number} index
     * @param {Amount} value
     * @param {VerifyFlags} flags
     * @param {Number?} sigchecks
     * @throws {ScriptError}
     */
    static verify(y, Y, he, be, xe, Ie, ve, C) {
      if (ve == null && (ve = z.flags.STANDARD_VERIFY_FLAGS), ve & z.flags.VERIFY_SIGPUSHONLY && !y.isPushOnly())
        throw new m("SIG_PUSHONLY");
      ve & z.flags.VERIFY_SIGHASH_FORKID && (ve |= z.flags.VERIFY_STRICTENC);
      let I = new p();
      y.execute(I, ve, be, xe, Ie, N.sigchecks);
      let se;
      if (ve & z.flags.VERIFY_P2SH && (se = I.clone()), he.execute(I, ve, be, xe, Ie, N.sigchecks), I.length === 0 || !I.getBool(-1))
        throw new m("EVAL_FALSE");
      if (ve & z.flags.VERIFY_P2SH && he.isScripthash()) {
        if (!y.isPushOnly())
          throw new m("SIG_PUSHONLY");
        if (I = se, I.length === 0)
          throw new m("EVAL_FALSE");
        const t = I.pop(), l = z.fromRaw(t);
        if ((ve & z.flags.VERIFY_DISALLOW_SEGWIT_RECOVERY) === 0 && I.length === 0 && l.isProgram()) {
          ve & z.flags.REPORT_SIGCHECKS || (N.sigchecks = 0);
          return;
        }
        if (l.execute(I, ve, be, xe, Ie, 0, N.sigchecks), I.length === 0 || !I.getBool(-1))
          throw new m("EVAL_FALSE");
      }
      if (ve & z.flags.VERIFY_CLEANSTACK && (e((ve & z.flags.VERIFY_P2SH) !== 0), I.length !== 1))
        throw new m("CLEANSTACK");
      if (ve & z.flags.VERIFY_INPUT_SIGCHECKS && y.getSize() < N.sigchecks * 43 - 60)
        throw new m("INPUT_SIGCHECKS");
      ve & z.flags.REPORT_SIGCHECKS || (N.sigchecks = 0);
    }
    /**
     * Inject properties from buffer reader.
     * @private
     * @param {BufferReader} br
     */
    fromReader(y) {
      return this.fromRaw(y.readVarBytes());
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer}
     */
    fromRaw(y) {
      const Y = c.read(y);
      for (this.raw = y; Y.left(); )
        this.code.push(i.fromReader(Y));
      return this;
    }
    /**
     * Create a script from buffer reader.
     * @param {BufferReader} br
     * @param {String?} enc - Either `"hex"` or `null`.
     * @returns {Script}
     */
    static fromReader(y) {
      return new this().fromReader(y);
    }
    /**
     * Create a script from a serialized buffer.
     * @param {Buffer|String} data - Serialized script.
     * @param {String?} enc - Either `"hex"` or `null`.
     * @returns {Script}
     */
    static fromRaw(y, Y) {
      return typeof y == "string" && (y = k.from(y, Y)), new this().fromRaw(y);
    }
    /**
     * Test whether an object a Script.
     * @param {Object} obj
     * @returns {Boolean}
     */
    static isScript(y) {
      return y instanceof z;
    }
  }
  z.opcodes = v.opcodes, z.opcodesByVal = v.opcodesByVal, z.flags = v.flags, z.hashType = v.hashType, z.hashTypeByVal = v.hashTypeByVal, z.types = v.types, z.typesByVal = v.typesByVal;
  function A(oe) {
    return oe.slice().sort((y, Y) => y.compare(Y));
  }
  function q(oe, y) {
    if (e(k.isBuffer(oe)), e(typeof y == "number"), y & z.flags.VERIFY_STRICTENC && !v.isKeyEncoding(oe))
      throw new m("PUBKEYTYPE");
    if (y & z.flags.VERIFY_COMPRESSED_PUBKEYTYPE && !v.isCompressedEncoding(oe))
      throw new m("NONCOMPRESSED_PUBKEY");
    return !0;
  }
  function _(oe, y) {
    if (e(k.isBuffer(oe)), e(typeof y == "number"), v.isSchnorr(oe))
      throw new m("SIG_BADLENGTH");
    if ((y & z.flags.VERIFY_DERSIG || y & z.flags.VERIFY_LOW_S || y & z.flags.VERIFY_STRICTENC) && !v.isDERSignatureEncoding(oe))
      throw new m("SIG_DER");
    if (y & z.flags.VERIFY_LOW_S && !v.isLowDER(oe))
      throw new m("SIG_HIGH_S");
    return !0;
  }
  function F(oe, y) {
    if (e(k.isBuffer(oe)), e(typeof y == "number"), y & z.flags.VERIFY_STRICTENC) {
      if (!v.isHashType(oe))
        throw new m("SIG_HASHTYPE");
      const Y = oe[oe.length - 1] & z.hashType.SIGHASH_FORKID, he = y & z.flags.VERIFY_SIGHASH_FORKID;
      if (!he && Y)
        throw new m("ILLEGAL_FORKID");
      if (he && !Y)
        throw new m("MUST_USE_FORKID");
    }
    return !0;
  }
  function R(oe, y) {
    return e(k.isBuffer(oe)), e(typeof y == "number"), oe.length === 0 ? !0 : (ae(oe.slice(0, -1), y), F(oe, y));
  }
  function V(oe, y) {
    return e(k.isBuffer(oe)), e(typeof y == "number"), oe.length === 0 ? !0 : D(oe.slice(0, -1), y) ? F(oe, y) : _(oe.slice(0, -1), y);
  }
  function fe(oe, y) {
    return e(k.isBuffer(oe)), e(typeof y == "number"), oe.length === 0 ? !0 : (_(oe.slice(0, -1), y), F(oe, y));
  }
  function ue(oe, y) {
    return e(k.isBuffer(oe)), e(typeof y == "number"), oe.length === 0 ? !0 : ae(oe.slice(0, oe.length), y);
  }
  function ae(oe, y) {
    return e(k.isBuffer(oe)), e(typeof y == "number"), v.isSchnorr(oe) ? !0 : _(oe, y);
  }
  function D(oe, y) {
    if (e(k.isBuffer(oe)), e(typeof y == "number"), v.isSchnorr(oe))
      return !0;
    throw new m("SIG_NONSCHNORR");
  }
  function Q(oe, y, Y, he) {
    e(k.isBuffer(oe)), e(k.isBuffer(y)), e(k.isBuffer(Y)), e(typeof he == "number");
    let be = !1;
    return y.length === 64 ? be = u.schnorrVerify(oe, y, Y, he) : be = u.verifyDER(oe, y, Y, he), be;
  }
  function Z(oe, y, Y) {
    return u.verifyDER(oe, y.slice(0, -1), Y);
  }
  return jc = z, jc;
}
var Yc, W5;
function bo() {
  if (W5) return Yc;
  W5 = 1;
  const e = $e(), c = At(), { U64: d } = Ah();
  Ht();
  const w = Pr();
  Li();
  const g = {
    GENESIS: 0,
    MINT: 1,
    SEND: 2,
    BATON: 3,
    BURN: 4
  };
  class f {
    /**
     * Create a record of SLP data for a given coin.
     * @param {Buffer?} hash the output hash of the coin
     * @param {Number?} vout the output index of the coin
     * @param {Buffer?} tokenId 32 byte txid
     * @param {Buffer?} tokenIndex 4 byte unsigned integer (index of tx hash in db)
     * @param {Buffer} value big endian value of token base units
     * @param {String} type GENESIS | MINT | SEND | BURN | BATON
     * @param {Number?} version token type
     * @constructor
     */
    constructor(s = {}) {
      this.hash = s.hash, this.vout = s.vout, this.tokenId = s.tokenId, this.tokenIndex = s.tokenIndex, this.value = s.value, this.type = s.type, this.version = s.version;
    }
    /**
     * Get the value as 64 bit big-endian buffer
     * @private
     * @returns {Buffer}
     */
    getValueUInt64BE() {
      e(this.value.length <= 8, "value buffer must be 8 bytes or less");
      const s = k.alloc(8 - this.value.length);
      return k.concat([s, this.value]);
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     */
    fromDbData(s) {
      const i = c.read(s);
      this.tokenIndex = i.readBytes(4);
      const p = i.readVarBytes(), m = k.alloc(8 - p.length);
      this.value = k.concat([m, p]), this.type = Object.keys(g)[i.readU8()];
      try {
        this.version = i.readU8();
      } catch (E) {
        if (E.code === "ERR_ENCODING")
          this.version = 1;
        else throw E;
      }
      return e(this.version >= 1 && this.version <= 2), e(Object.keys(g).includes(this.type)), this;
    }
    /**
     * Instantiate SLP record from serialized data.
     * @param {Buffer} data
     * @returns {SlpCoinRecord}
     */
    static fromDbData(s) {
      return new this().fromDbData(s);
    }
    /**
     * Serialize the SLP record.
     * @returns {Buffer}
     */
    toDbData() {
      e(this.tokenIndex, "Missing tokenIndex"), e(this.tokenIndex.length == 4, "tokenId must be a sha256 hash"), e(this.value.byteLength, "Token amount must be a buffer"), e(Object.keys(g).includes(this.type), "Type must be GENESIS | MINT | SEND | BATON | BURN");
      for (let i = 0; i < this.value.length; i++)
        if (this.value[i] != 0) {
          this.value = this.value.slice(i);
          break;
        }
      const s = c.write();
      return s.writeBytes(this.tokenIndex), s.writeVarBytes(this.value), s.writeU8(g[this.type]), s.writeU8(this.version || 1), s.render();
    }
    /**
     * Convert object to JSON.
     * @returns {Object}
     */
    getJSON() {
      return e(this.tokenId, "tokenId must be defined"), {
        hash: this.hash ? k.from(this.hash).reverse().toString("hex") : void 0,
        vout: this.vout,
        tokenId: this.tokenId.toString("hex"),
        value: d.fromBE(this.value).toString(10),
        type: this.type,
        version: this.version || 1
      };
    }
    /**
     * Convert from JSON to Object.
     * @param {Object} json
     * @returns {SlpCoinRecord}
     */
    fromJSON(s) {
      return this.hash = k.from(s.hash, "hex").reverse(), this.vout = s.vout, this.tokenId = k.from(s.tokenId, "hex"), this.value = d.fromString(s.value).toBE(k), this.type = s.type, this.version = s.version || 1, this;
    }
    /**
     * Convert from JSON to Object.
     * @param {Object} json
     * @returns {TokenRecord}
     */
    static fromJSON(s) {
      return new this().fromJSON(s);
    }
  }
  class n {
    /**
     * Create a token record.
     * @constructor
     * @param {Buffer?} tokenId
     * @param {Buffer?} tokenIndex
     * @param {String?} ticker
     * @param {String?} name
     * @param {String?} uri
     * @param {String?} hash
     * @param {Number} decimals
     * @param {Number?} version
     * @param {Buffer?} vaultScriptHash
     */
    constructor(s = {}) {
      this.tokenId = s.tokenId, this.tokenIndex = s.tokenIndex, this.ticker = s.ticker || "", this.name = s.name || "", this.uri = s.uri || "", this.hash = s.hash || "", this.decimals = s.decimals, this.version = s.version, this.version === 2 && (this.vaultScriptHash = s.vaultScriptHash);
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     */
    fromDbData(s) {
      const i = c.read(s);
      this.tokenId = i.readHash(), this.ticker = i.readVarString("utf8"), this.name = i.readVarString("utf8"), this.uri = i.readVarString("utf8"), this.hash = i.readVarString("hex"), this.decimals = i.readU8();
      try {
        this.version = i.readU8();
      } catch (p) {
        if (p.code === "ERR_ENCODING")
          this.version = 1;
        else throw p;
      }
      return this.version === 2 && (this.vaultScriptHash = i.readBytes(20)), e(this.version >= 1 && this.version <= 2), this;
    }
    /**
     * Instantiate token record from serialized data.
     * @param {Buffer} data
     * @returns {TokenRecord}
     */
    static fromDbData(s) {
      return new this().fromDbData(s);
    }
    /**
     * Serialize the token record.
     * @returns {Buffer}
     */
    toDbData() {
      const s = c.write(), i = c.encoding;
      return s.writeHash(this.tokenId), s.writeVarString(this.ticker, "utf8"), this.ticker.length === 0 && (s.offset += i.sizeVarint(0)), s.writeVarString(this.name, "utf8"), this.name.length === 0 && (s.offset += i.sizeVarint(0)), s.writeVarString(this.uri, "utf8"), this.uri.length === 0 && (s.offset += i.sizeVarint(0)), s.writeVarString(this.hash, "hex"), this.hash.length === 0 && (s.offset += i.sizeVarint(0)), s.writeU8(this.decimals), s.writeU8(this.version || 1), this.version === 2 && s.writeBytes(this.vaultScriptHash), s.render();
    }
    /**
     * Convert object to JSON.
     * @returns {Object}
     */
    getJSON() {
      e(this.tokenId, "tokenId must be defined");
      const s = {
        tokenId: this.tokenId.toString("hex"),
        ticker: this.ticker,
        name: this.name,
        uri: this.uri,
        hash: this.hash,
        decimals: this.decimals,
        version: this.version || 1
      };
      return s.version === 2 && this.vaultScriptHash && (s.vaultScriptHash = this.vaultScriptHash.toString("hex")), s;
    }
    /**
     * Convert from JSON to Object.
     * @param {Object} json
     * @returns {SlpCoinRecord}
     */
    fromJSON(s) {
      return this.tokenId = k.from(s.tokenId, "hex"), this.ticker = s.ticker, this.name = s.name, this.uri = s.uri, this.hash = s.hash, this.decimals = s.decimals, this.version = s.version, s.version === 2 && s.vaultScriptHash && (this.vaultScriptHash = k.from(s.vaultScriptHash, "hex")), this;
    }
    /**
     * Convert from JSON to Object.
     * @param {Object} json
     * @returns {TokenRecord}
     */
    static fromJSON(s) {
      return new this().fromJSON(s);
    }
  }
  class u extends w {
    /**
     * Create an SLP script.
     * @constructor
     * @param {Buffer|Array|Object} code
     */
    constructor(s) {
      super(s), this.valid = null;
    }
    /**
     * Is SLP script is of valid construction?
     * Use this as opposed to calling property this.isValid
     * @private
     * @returns {Boolean}
     */
    isValidSlp() {
      return this.valid === null && (this.valid = this.verifySlp()), this.valid;
    }
    /**
     * Test whether SLP script is of valid construction
     * (Does not test if transaction is valid SLP transaction)
     * @private
     * @param {Script?} script
     * @returns {Boolean}
     */
    verifySlp(s) {
      if (s == null && (s = this), s.getSym(0) != "OP_RETURN" || s.getString(1, "hex") != "534c5000")
        return !1;
      const i = s.getString(2, "hex");
      if (i != "01" && i != "02")
        return !1;
      switch (s.getType()) {
        case "GENESIS": {
          if (s.code.length != 11 || !s.getData(7) || s.getData(7).length != 0 && s.getData(7).length != 32 || !s.getData(8) || s.getData(8).length != 1 || s.getInt(8) > 9)
            return !1;
          if (i == "01") {
            if (!s.getData(9) || s.getData(9).length > 1 || s.getData(9).length == 1 && s.getInt(9) < 2)
              return !1;
          } else if (i == "02" && (!s.getData(9) || s.getData(9).length != 20))
            return !1;
          if (s.getData(10).length != 8)
            return !1;
          break;
        }
        case "MINT": {
          if (i == "01" && s.code.length != 7 || i == "02" && s.code.length < 6 || s.getData(4).length != 32)
            return !1;
          if (i == "01") {
            if (!s.getData(5) || s.getData(5).length > 1 || s.getData(5).length == 1 && s.getInt(5) < 2 || s.getData(6).length != 8)
              return !1;
          } else if (i == "02") {
            const m = s.code.slice(5);
            for (let E = 0; E < m.length; E++)
              if (m[E].data.length != 8)
                return !1;
          }
          break;
        }
        case "SEND": {
          if (s.code.length < 6 || s.getData(4).length != 32)
            return !1;
          const m = s.code.slice(5);
          for (let E = 0; E < m.length; E++)
            if (m[E].data.length != 8)
              return !1;
          break;
        }
        case "BURN": {
          if (s.code.length != 6 || s.getData(4).length != 32 || s.getData(5).length != 8)
            return !1;
          break;
        }
        default:
          return !1;
      }
      return !0;
    }
    /**
     * Test whether script is of valid construction
     * (Does not test if transaction is valid SLP transaction)
     * @param {Script?} script
     * @returns {Boolean}
     */
    static verifySlp(s) {
      return new this().verifySlp(s);
    }
    /**
     * Inject properties from a script
     * @private
     * @param {Script} code
     * @returns {SLP}
     */
    fromScript(s) {
      return this.inject(s), this;
    }
    /**
     * Inject properties from a script
     * @param {Script} code
     * @returns {SLP}
     */
    static fromScript(s) {
      return new this().fromScript(s);
    }
    /**
     * Get token ID for this script
     * @private
     * @returns {Hash}
     */
    getTokenId() {
      e(this.verifySlp(), "This is not a valid SLP script");
      const s = this.getType();
      return e(s != "GENESIS", "Cannot derive the tokenID from GENESIS script"), this.getData(4);
    }
    /**
     * Get records for a this script
     * @private
     * @param {Buffer?} txId The txid of the transaction containing this script
     * @returns {(SlpCoinRecord | TokenRecord)[]}
     */
    getRecords(s) {
      e(this.isValidSlp(), "Must be a valid SLP Script");
      const i = this.getType();
      switch (e(Object.keys(g).includes(i) && i != "BATON", "Type must be GENESIS | MINT | SEND | BURN"), e(s.byteLength, "tokenId must be a buffer"), e(s.length == 32, "tokenId must be a sha256 hash"), i) {
        case "GENESIS":
          return this.getGenesisRecords(s);
        case "MINT":
          return this.getMintRecords(s);
        case "SEND":
          return this.getSendRecords(s);
        case "BURN":
          return this.getBurnRecords(s);
        default:
          return null;
      }
    }
    /**
     * Get records for a GENESIS script
     * @private
     * @param {Buffer} tokenId The tokenId of the transaction containing this script
     * @returns {(SlpCoinRecord | TokenRecord)[]}
     */
    getGenesisRecords(s) {
      e(s.byteLength, "tokenId must be a buffer"), e(s.byteLength == 32, "tokenId must be a sha256 hash");
      const i = this.getType();
      e(i == "GENESIS", "This is not a GENESIS transaction");
      const p = this.getInt(2), m = [];
      if (m.push(this.constructor.TokenRecord({
        tokenId: s,
        version: p,
        ticker: this.getString(4, "utf-8"),
        name: this.getString(5, "utf-8"),
        uri: this.getString(6, "utf-8"),
        hash: this.getString(7, "hex"),
        decimals: this.getInt(8),
        vaultScriptHash: p === 2 ? this.getData(9) : void 0
      })), m.push(this.constructor.SlpCoinRecord({
        hash: k.from(s).reverse(),
        vout: 1,
        tokenId: s,
        value: this.getData(10),
        type: i,
        version: this.getInt(2)
      })), p === 1 && this.getInt(9) >= 2) {
        const E = k.alloc(1);
        E.writeInt8(1), m.push(this.constructor.SlpCoinRecord({
          hash: k.from(s).reverse(),
          vout: this.getInt(9),
          tokenId: s,
          value: E,
          type: "BATON",
          version: this.getInt(2)
        }));
      }
      return m;
    }
    /**
     * Get records for a MINT script
     * @private
     * @param {Buffer} txId The txHash of the transaction containing this script
     * @returns {SlpCoinRecord[]}
     */
    getMintRecords(s) {
      e(s.byteLength, "txId must be a buffer"), e(s.byteLength == 32, "txId must be a sha256 hash");
      const i = this.getType();
      e(i == "MINT", "This is not a MINT transaction");
      const p = this.getInt(2), m = [];
      if (p === 1) {
        if (m.push(this.constructor.SlpCoinRecord({
          hash: k.from(s).reverse(),
          vout: 1,
          tokenId: this.getData(4),
          value: this.getData(6),
          type: i,
          version: p
        })), this.getInt(5) >= 2) {
          const E = d.fromInt(1).toBE(k);
          m.push(this.constructor.SlpCoinRecord({
            hash: k.from(s).reverse(),
            vout: this.getInt(5),
            tokenId: this.getData(4),
            value: E,
            type: "BATON",
            version: p
          }));
        }
      } else if (p === 2) {
        const E = this.code.slice(5);
        for (let v = 0; v < E.length; v++) {
          const b = E[v].toData(), h = v + 1;
          m.push(this.constructor.SlpCoinRecord({
            hash: k.from(s).reverse(),
            vout: h,
            tokenId: this.getData(4),
            value: b,
            type: i,
            version: this.getInt(2)
          }));
        }
      }
      return m;
    }
    /**
     * Get records for a SEND script
     * @private
     * @param {Buffer} txId The txHash of the transaction containing this script
     * @param {Boolean} nonStandardOuts OP_RETURN is located at an index other than 0
     * @returns {SlpCoinRecord[]}
     */
    getSendRecords(s, i = !1) {
      e(s.byteLength, "txId must be a buffer"), e(s.byteLength == 32, "txId must be a sha256 hash");
      const p = this.getType();
      e(p == "SEND", "This is not a SEND transaction");
      const m = [], E = this.code.slice(5);
      for (let v = 0; v < E.length; v++) {
        const b = E[v].toData(), h = i ? v : v + 1;
        m.push(this.constructor.SlpCoinRecord({
          hash: k.from(s).reverse(),
          vout: h,
          tokenId: this.getData(4),
          value: b,
          type: p,
          version: this.getInt(2)
        }));
      }
      return m;
    }
    getBurnRecords(s, i = !1) {
      e(s.byteLength, "txId must be a buffer"), e(s.byteLength == 32, "txId must be a sha256 hash");
      const p = this.getType();
      e(p == "BURN", "This is not a BURN transaction");
      const m = [], E = this.code[5].toData();
      return m.push(this.constructor.SlpCoinRecord({
        hash: k.from(s).reverse(),
        vout: 0,
        tokenId: this.getData(4),
        value: E,
        type: p,
        version: this.getInt(2)
      })), m;
    }
    /**
     * Re-encode the script internally. Useful if you
     * changed something manually in the `code` array.
     * @returns {Script}
     */
    compile() {
      super.compile(), this.valid = null, this.isValidSlp();
    }
    /**
     * Inspect the script.
     * @returns {String} Human-readable script code.
     */
    inspect() {
      return `<SLP: ${this.toString()}>`;
    }
    getType() {
      return this.getString(3);
    }
    /**
     * Create a new TokenRecord
     * @param {Buffer?} tokenId
     * @param {Buffer?} tokenIndex
     * @param {String?} ticker
     * @param {String?} name
     * @param {String?} uri
     * @param {String?} hash
     * @param {Number} decimals
     * @param {Number?} version
     * @returns {TokenRecord}
     */
    static TokenRecord(s = {}) {
      return new n(s);
    }
    /**
     * Create a new SlpCoinRecord
     * @param {Buffer?} hash the output hash of the coin
     * @param {Number?} vout the output index of the coin
     * @param {Buffer?} tokenId 32 byte txid
     * @param {Buffer?} tokenIndex 4 byte unsigned integer (index of tx hash in db)
     * @param {Number} value
     * @param {String} type GENESIS | MINT | SEND | BATON
     * @param {Number?} version
     * @returns {SlpCoinRecord}
     */
    static SlpCoinRecord(s = {}) {
      return new f(s);
    }
  }
  return Yc = u, Yc;
}
var Xc, Z5;
function gi() {
  if (Z5) return Xc;
  Z5 = 1;
  const e = $e(), c = At(), d = bi(), w = yr(), g = Lr(), f = Pr(), n = bo(), u = mi(), { inspectSymbol: a } = Kt();
  class s {
    /**
     * Create an output.
     * @constructor
     * @param {Object?} options
     */
    constructor(p) {
      this.value = 0, this.script = new f(), p && this.fromOptions(p);
    }
    /**
     * Inject properties from options object.
     * @private
     * @param {Object} options
     */
    fromOptions(p) {
      return e(p, "Output data is required."), p.value && (e(
        Number.isSafeInteger(p.value) && p.value >= 0,
        "Value must be a uint64."
      ), this.value = p.value), p.script && this.script.fromOptions(p.script), p.address && this.script.fromAddress(p.address), p.slp && p.slp.constructor === n.SlpCoinRecord().constructor && (this.slp = p.slp), this;
    }
    /**
     * Instantiate output from options object.
     * @param {Object} options
     * @returns {Output}
     */
    static fromOptions(p) {
      return new this().fromOptions(p);
    }
    /**
     * Inject properties from script/value pair.
     * @private
     * @param {Script|Address} script
     * @param {Amount} value
     * @returns {Output}
     */
    fromScript(p, m) {
      return typeof p == "string" && (p = g.fromString(p)), p instanceof g && (p = f.fromAddress(p)), e(p instanceof f, "Script must be a Script."), e(
        Number.isSafeInteger(m) && m >= 0,
        "Value must be a uint64."
      ), this.script = p, this.value = m, this;
    }
    /**
     * Instantiate output from script/value pair.
     * @param {Script|Address} script
     * @param {Amount} value
     * @returns {Output}
     */
    static fromScript(p, m) {
      return new this().fromScript(p, m);
    }
    /**
     * Clone the output.
     * @returns {Output}
     */
    clone() {
      const p = new this.constructor();
      return p.value = this.value, p.script.inject(this.script), p;
    }
    /**
     * Test equality against another output.
     * @param {Output} output
     * @returns {Boolean}
     */
    equals(p) {
      return e(s.isOutput(p)), this.value === p.value && this.script.equals(p.script);
    }
    /**
     * Compare against another output (BIP69).
     * @param {Output} output
     * @returns {Number}
     */
    compare(p) {
      e(s.isOutput(p));
      const m = this.value - p.value;
      return m !== 0 ? m : this.script.compare(p.script);
    }
    /**
     * Get the script type as a string.
     * @returns {ScriptType} type
     */
    getType() {
      return f.typesByVal[this.script.getType()].toLowerCase();
    }
    /**
     * Get the address.
     * @returns {Address} address
     */
    getAddress() {
      return this.script.getAddress();
    }
    /**
     * Get the address hash.
     * @param {String?} enc
     * @returns {Hash} hash
     */
    getHash(p) {
      const m = this.getAddress();
      return m ? m.getHash(p) : null;
    }
    /**
     * Convert the input to a more user-friendly object.
     * @returns {Object}
     */
    [a]() {
      const p = {
        type: this.getType(),
        value: d.btc(this.value),
        script: this.script,
        address: this.getAddress()
      };
      return this.slp ? {
        ...p,
        slp: this.slp
      } : p;
    }
    /**
     * Convert the output to an object suitable
     * for JSON serialization.
     * @returns {Object}
     */
    toJSON() {
      return this.getJSON();
    }
    /**
     * Convert the output to an object suitable
     * for JSON serialization.
     * @param {Network} network
     * @returns {Object}
     */
    getJSON(p) {
      let m = this.getAddress();
      p = w.get(p), m && (m = m.toString(p));
      const E = {
        value: this.value,
        script: this.script.toJSON(),
        address: m
      };
      return this.slp ? {
        ...E,
        slp: this.slp.getJSON()
      } : E;
    }
    /**
     * Calculate the dust threshold for this
     * output, based on serialize size and rate.
     * @param {Rate?} rate
     * @returns {Amount}
     */
    getDustThreshold(p) {
      if (this.script.isUnspendable())
        return 0;
      let m = this.getSize();
      return m += 148, 3 * u.getMinFee(m, p);
    }
    /**
     * Calculate size of serialized output.
     * @returns {Number}
     */
    getSize() {
      return 8 + this.script.getVarSize();
    }
    /**
     * Test whether the output should be considered dust.
     * @param {Rate?} rate
     * @returns {Boolean}
     */
    isDust(p) {
      return this.value < this.getDustThreshold(p);
    }
    /**
     * Inject properties from a JSON object.
     * @private
     * @param {Object} json
     */
    fromJSON(p) {
      return e(p, "Output data is required."), e(
        Number.isSafeInteger(p.value) && p.value >= 0,
        "Value must be a uint64."
      ), this.value = p.value, this.script.fromJSON(p.script), p.slp && (this.slp = n.SlpCoinRecord().fromJSON(p.slp)), this;
    }
    /**
     * Instantiate an Output from a jsonified output object.
     * @param {Object} json - The jsonified output object.
     * @returns {Output}
     */
    static fromJSON(p) {
      return new this().fromJSON(p);
    }
    /**
     * Write the output to a buffer writer.
     * @param {BufferWriter} bw
     */
    toWriter(p) {
      return p.writeI64(this.value), p.writeVarBytes(this.script.toRaw()), p;
    }
    /**
     * Serialize the output.
     * @param {String?} enc - Encoding, can be `'hex'` or null.
     * @returns {Buffer|String}
     */
    toRaw() {
      const p = this.getSize();
      return this.toWriter(c.write(p)).render();
    }
    /**
     * Inject properties from buffer reader.
     * @private
     * @param {BufferReader} br
     */
    fromReader(p) {
      return this.value = p.readI64(), this.script.fromRaw(p.readVarBytes()), this;
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     */
    fromRaw(p) {
      return this.fromReader(c.read(p));
    }
    /**
     * Instantiate an output from a buffer reader.
     * @param {BufferReader} br
     * @returns {Output}
     */
    static fromReader(p) {
      return new this().fromReader(p);
    }
    /**
     * Instantiate an output from a serialized Buffer.
     * @param {Buffer} data
     * @param {String?} enc - Encoding, can be `'hex'` or null.
     * @returns {Output}
     */
    static fromRaw(p, m) {
      return typeof p == "string" && (p = k.from(p, m)), new this().fromRaw(p);
    }
    /**
     * Test an object to see if it is an Output.
     * @param {Object} obj
     * @returns {Boolean}
     */
    static isOutput(p) {
      return p instanceof s;
    }
  }
  return Xc = s, Xc;
}
var Jc, Q5;
function xi() {
  if (Q5) return Jc;
  Q5 = 1;
  const e = $e(), c = At(), d = Zt(), w = Ht(), { inspectSymbol: g } = Kt();
  class f {
    /**
     * Create an outpoint.
     * @constructor
     * @param {Hash?} hash
     * @param {Number?} index
     */
    constructor(a, s) {
      this.hash = w.ZERO_HASH, this.index = 4294967295, a != null && (e(k.isBuffer(a)), e(s >>> 0 === s, "Index must be a uint32."), this.hash = a, this.index = s);
    }
    /**
     * Inject properties from options object.
     * @private
     * @param {Object} options
     */
    fromOptions(a) {
      return e(a, "Outpoint data is required."), e(k.isBuffer(a.hash)), e(a.index >>> 0 === a.index, "Index must be a uint32."), this.hash = a.hash, this.index = a.index, this;
    }
    /**
     * Instantate outpoint from options object.
     * @param {Object} options
     * @returns {Outpoint}
     */
    static fromOptions(a) {
      return new this().fromOptions(a);
    }
    /**
     * Clone the outpoint.
     * @returns {Outpoint}
     */
    clone() {
      const a = new this.constructor();
      return a.hash = this.hash, a.index = this.index, a;
    }
    /**
     * Test equality against another outpoint.
     * @param {Outpoint} prevout
     * @returns {Boolean}
     */
    equals(a) {
      return e(f.isOutpoint(a)), this.hash.equals(a.hash) && this.index === a.index;
    }
    /**
     * Compare against another outpoint (BIP69).
     * @param {Outpoint} prevout
     * @returns {Number}
     */
    compare(a) {
      e(f.isOutpoint(a));
      const s = n(this.txid(), a.txid());
      return s !== 0 ? s : this.index - a.index;
    }
    /**
     * Test whether the outpoint is null (hash of zeroes
     * with max-u32 index). Used to detect coinbases.
     * @returns {Boolean}
     */
    isNull() {
      return this.index === 4294967295 && this.hash.equals(w.ZERO_HASH);
    }
    /**
     * Get little-endian hash.
     * @returns {Hash}
     */
    rhash() {
      return d.revHex(this.hash);
    }
    /**
     * Get little-endian hash.
     * @returns {Hash}
     */
    txid() {
      return this.rhash();
    }
    /**
     * Serialize outpoint to a key
     * suitable for a hash table.
     * @returns {String}
     */
    toKey() {
      return this.toRaw();
    }
    /**
     * Inject properties from hash table key.
     * @private
     * @param {String} key
     * @returns {Outpoint}
     */
    fromKey(a) {
      return this.hash = a.slice(0, 32), this.index = c.readU32(a, 32), this;
    }
    /**
     * Instantiate outpoint from hash table key.
     * @param {String} key
     * @returns {Outpoint}
     */
    static fromKey(a) {
      return new this().fromKey(a);
    }
    /**
     * Write outpoint to a buffer writer.
     * @param {BufferWriter} bw
     */
    toWriter(a) {
      return a.writeHash(this.hash), a.writeU32(this.index), a;
    }
    /**
     * Calculate size of outpoint.
     * @returns {Number}
     */
    getSize() {
      return 36;
    }
    /**
     * Serialize outpoint.
     * @returns {Buffer}
     */
    toRaw() {
      return this.toWriter(c.write(36)).render();
    }
    /**
     * Inject properties from buffer reader.
     * @private
     * @param {BufferReader} br
     */
    fromReader(a) {
      return this.hash = a.readHash(), this.index = a.readU32(), this;
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     */
    fromRaw(a) {
      return this.fromReader(c.read(a));
    }
    /**
     * Instantiate outpoint from a buffer reader.
     * @param {BufferReader} br
     * @returns {Outpoint}
     */
    static fromReader(a) {
      return new this().fromReader(a);
    }
    /**
     * Instantiate outpoint from serialized data.
     * @param {Buffer} data
     * @returns {Outpoint}
     */
    static fromRaw(a) {
      return new this().fromRaw(a);
    }
    /**
     * Inject properties from json object.
     * @private
     * @params {Object} json
     */
    fromJSON(a) {
      return e(a, "Outpoint data is required."), e(typeof a.hash == "string", "Hash must be a string."), e(a.index >>> 0 === a.index, "Index must be a uint32."), this.hash = d.fromRev(a.hash), this.index = a.index, this;
    }
    /**
     * Convert the outpoint to an object suitable
     * for JSON serialization. Note that the hash
     * will be reversed to abide by bitcoind's legacy
     * of little-endian uint256s.
     * @returns {Object}
     */
    toJSON() {
      return {
        hash: d.revHex(this.hash),
        index: this.index
      };
    }
    /**
     * Instantiate outpoint from json object.
     * @param {Object} json
     * @returns {Outpoint}
     */
    static fromJSON(a) {
      return new this().fromJSON(a);
    }
    /**
     * Inject properties from tx.
     * @private
     * @param {TX} tx
     * @param {Number} index
     */
    fromTX(a, s) {
      return e(a), e(typeof s == "number"), e(s >= 0), this.hash = a.hash(), this.index = s, this;
    }
    /**
     * Instantiate outpoint from tx.
     * @param {TX} tx
     * @param {Number} index
     * @returns {Outpoint}
     */
    static fromTX(a, s) {
      return new this().fromTX(a, s);
    }
    /**
     * Serialize outpoint to a key
     * suitable for a hash table.
     * @param {Hash} hash
     * @param {Number} index
     * @returns {String}
     */
    static toKey(a, s) {
      return new f(a, s).toKey();
    }
    /**
     * Convert the outpoint to a user-friendly string.
     * @returns {String}
     */
    [g]() {
      return `<Outpoint: ${this.rhash()}/${this.index}>`;
    }
    /**
     * Test an object to see if it is an outpoint.
     * @param {Object} obj
     * @returns {Boolean}
     */
    static isOutpoint(a) {
      return a instanceof f;
    }
  }
  function n(u, a) {
    const s = Math.min(u.length, a.length);
    for (let i = 0; i < s; i++) {
      if (u[i] < a[i])
        return -1;
      if (u[i] > a[i])
        return 1;
    }
    return u.length < a.length ? -1 : u.length > a.length ? 1 : 0;
  }
  return Jc = f, Jc;
}
var Gc, e4;
function rs() {
  if (e4) return Gc;
  e4 = 1;
  const e = $e(), c = At(), d = Zt(), w = bi(), g = gi(), f = yr(), n = Ht(), u = xi(), a = bo(), { inspectSymbol: s } = Kt();
  class i extends g {
    /**
     * Create a coin.
     * @constructor
     * @param {Object} options
     */
    constructor(m) {
      super(), this.version = 1, this.height = -1, this.coinbase = !1, this.hash = n.ZERO_HASH, this.index = 0, m && this.fromOptions(m);
    }
    /**
     * Inject options into coin.
     * @private
     * @param {Object} options
     */
    fromOptions(m) {
      return e(m, "Coin data is required."), m.version != null && (e(
        m.version >>> 0 === m.version,
        "Version must be a uint32."
      ), this.version = m.version), m.height != null && (m.height !== -1 ? (e(
        m.height >>> 0 === m.height,
        "Height must be a uint32."
      ), this.height = m.height) : this.height = -1), m.value != null && (e(
        Number.isSafeInteger(m.value) && m.value >= 0,
        "Value must be a uint64."
      ), this.value = m.value), m.script && this.script.fromOptions(m.script), m.coinbase != null && (e(
        typeof m.coinbase == "boolean",
        "Coinbase must be a boolean."
      ), this.coinbase = m.coinbase), m.hash != null && (e(k.isBuffer(m.hash)), this.hash = m.hash), m.index != null && (e(
        m.index >>> 0 === m.index,
        "Index must be a uint32."
      ), this.index = m.index), this;
    }
    /**
     * Instantiate Coin from options object.
     * @private
     * @param {Object} options
     */
    static fromOptions(m) {
      return new this().fromOptions(m);
    }
    /**
     * Clone the coin.
     * @private
     * @returns {Coin}
     */
    clone() {
      e(!1, "Coins are not cloneable.");
    }
    /**
     * Calculate number of confirmations since coin was created.
     * @param {Number?} height - Current chain height. Network
     * height is used if not passed in.
     * @return {Number}
     */
    getDepth(m) {
      return e(typeof m == "number", "Must pass a height."), this.height === -1 || m === -1 || m < this.height ? 0 : m - this.height + 1;
    }
    /**
     * Serialize coin to a key
     * suitable for a hash table.
     * @returns {String}
     */
    toKey() {
      return u.toKey(this.hash, this.index);
    }
    /**
     * Inject properties from hash table key.
     * @private
     * @param {String} key
     * @returns {Coin}
     */
    fromKey(m) {
      const { hash: E, index: v } = u.fromKey(m);
      return this.hash = E, this.index = v, this;
    }
    /**
     * Instantiate coin from hash table key.
     * @param {String} key
     * @returns {Coin}
     */
    static fromKey(m) {
      return new this().fromKey(m);
    }
    /**
     * Get little-endian hash.
     * @returns {Hash}
     */
    rhash() {
      return d.revHex(this.hash);
    }
    /**
     * Get little-endian hash.
     * @returns {Hash}
     */
    txid() {
      return this.rhash();
    }
    /**
     * Convert the coin to a more user-friendly object.
     * @returns {Object}
     */
    [s]() {
      const m = {
        type: this.getType(),
        version: this.version,
        height: this.height,
        value: w.btc(this.value),
        script: this.script,
        coinbase: this.coinbase,
        hash: this.hash ? d.revHex(this.hash) : null,
        index: this.index,
        address: this.getAddress()
      };
      return this.slp ? {
        ...m,
        slp: this.slp
      } : m;
    }
    /**
     * Convert the coin to an object suitable
     * for JSON serialization.
     * @returns {Object}
     */
    toJSON() {
      return this.getJSON();
    }
    /**
     * Convert the coin to an object suitable
     * for JSON serialization. Note that the hash
     * will be reversed to abide by bitcoind's legacy
     * of little-endian uint256s.
     * @param {Network} network
     * @param {Boolean} minimal
     * @returns {Object}
     */
    getJSON(m, E) {
      let v = this.getAddress();
      m = f.get(m), v && (v = v.toString(m));
      const b = {
        version: this.version,
        height: this.height,
        value: this.value,
        script: this.script.toJSON(),
        address: v,
        coinbase: this.coinbase,
        hash: E ? void 0 : this.rhash(),
        index: E ? void 0 : this.index
      };
      return this.slp ? {
        ...b,
        slp: this.slp.getJSON()
      } : b;
    }
    /**
     * Inject JSON properties into coin.
     * @private
     * @param {Object} json
     */
    fromJSON(m) {
      return e(m, "Coin data required."), e(m.version >>> 0 === m.version, "Version must be a uint32."), e(
        m.height === -1 || m.height >>> 0 === m.height,
        "Height must be a uint32."
      ), e(
        Number.isSafeInteger(m.value) && m.value >= 0,
        "Value must be a uint64."
      ), e(typeof m.coinbase == "boolean", "Coinbase must be a boolean."), this.version = m.version, this.height = m.height, this.value = m.value, this.script.fromJSON(m.script), this.coinbase = m.coinbase, m.hash != null && (e(typeof m.hash == "string", "Hash must be a string."), e(m.hash.length === 64, "Hash must be a string."), e(m.index >>> 0 === m.index, "Index must be a uint32."), this.hash = d.fromRev(m.hash), this.index = m.index), m.slp && (m.slp.hash = m.hash, this.slp = a.SlpCoinRecord().fromJSON(m.slp)), this;
    }
    /**
     * Instantiate an Coin from a jsonified coin object.
     * @param {Object} json - The jsonified coin object.
     * @returns {Coin}
     */
    static fromJSON(m) {
      return new this().fromJSON(m);
    }
    /**
     * Calculate size of coin.
     * @returns {Number}
     */
    getSize() {
      return 17 + this.script.getVarSize();
    }
    /**
     * Write the coin to a buffer writer.
     * @param {BufferWriter} bw
     */
    toWriter(m) {
      let E = this.height;
      return E === -1 && (E = 2147483647), m.writeU32(this.version), m.writeU32(E), m.writeI64(this.value), m.writeVarBytes(this.script.toRaw()), m.writeU8(this.coinbase ? 1 : 0), m;
    }
    /**
     * Serialize the coin.
     * @returns {Buffer|String}
     */
    toRaw() {
      const m = this.getSize();
      return this.toWriter(c.write(m)).render();
    }
    /**
     * Inject properties from serialized buffer writer.
     * @private
     * @param {BufferReader} br
     */
    fromReader(m) {
      return this.version = m.readU32(), this.height = m.readU32(), this.value = m.readI64(), this.script.fromRaw(m.readVarBytes()), this.coinbase = m.readU8() === 1, this.height === 2147483647 && (this.height = -1), this;
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     */
    fromRaw(m) {
      return this.fromReader(c.read(m));
    }
    /**
     * Instantiate a coin from a buffer reader.
     * @param {BufferReader} br
     * @returns {Coin}
     */
    static fromReader(m) {
      return new this().fromReader(m);
    }
    /**
     * Instantiate a coin from a serialized Buffer.
     * @param {Buffer} data
     * @param {String?} enc - Encoding, can be `'hex'` or null.
     * @returns {Coin}
     */
    static fromRaw(m, E) {
      return typeof m == "string" && (m = k.from(m, E)), new this().fromRaw(m);
    }
    /**
     * Inject properties from TX.
     * @param {TX} tx
     * @param {Number} index
     */
    fromTX(m, E, v) {
      return e(typeof E == "number"), e(typeof v == "number"), e(E >= 0 && E < m.outputs.length), this.version = m.version, this.height = v, this.value = m.outputs[E].value, this.script = m.outputs[E].script, this.coinbase = m.isCoinbase(), this.hash = m.hash(), this.index = E, this;
    }
    /**
     * Instantiate a coin from a TX
     * @param {TX} tx
     * @param {Number} index - Output index.
     * @returns {Coin}
     */
    static fromTX(m, E, v) {
      return new this().fromTX(m, E, v);
    }
    /**
     * Test an object to see if it is a Coin.
     * @param {Object} obj
     * @returns {Boolean}
     */
    static isCoin(m) {
      return m instanceof i;
    }
  }
  return Gc = i, Gc;
}
var Nn = {}, t4;
function Qb() {
  if (t4) return Nn;
  t4 = 1;
  const e = $e(), { encoding: c } = At(), d = Rr(), w = Ht(), g = 6, f = k.alloc(0);
  function n(b, h) {
    const o = b.getPubkeyhash(!0);
    if (o)
      return h.writeU8(0), h.writeBytes(o), h;
    const S = b.getScripthash();
    if (S)
      return h.writeU8(1), h.writeBytes(S), h;
    const H = b.getPubkey(!0);
    if (H && m(H)) {
      const j = E(H);
      return h.writeBytes(j), h;
    }
    return h.writeVarint(b.raw.length + g), h.writeBytes(b.raw), h;
  }
  function u(b, h) {
    switch (h.readU8()) {
      case 0: {
        const o = h.readBytes(20, !0);
        b.fromPubkeyhash(o);
        break;
      }
      case 1: {
        const o = h.readBytes(20, !0);
        b.fromScripthash(o);
        break;
      }
      case 2:
      case 3:
      case 4:
      case 5: {
        h.offset -= 1;
        const o = h.readBytes(33, !0), S = v(o);
        b.fromPubkey(S);
        break;
      }
      default: {
        h.offset -= 1;
        const o = h.readVarint() - g;
        if (o > w.MAX_SCRIPT_SIZE)
          b.fromNulldata(f), h.seek(o);
        else {
          const S = h.readBytes(o);
          b.fromRaw(S);
        }
        break;
      }
    }
    return b;
  }
  function a(b) {
    if (b.isPubkeyhash(!0) || b.isScripthash())
      return 21;
    const h = b.getPubkey(!0);
    if (h && m(h))
      return 33;
    let o = 0;
    return o += c.sizeVarint(b.raw.length + g), o += b.raw.length, o;
  }
  function s(b, h) {
    return h.writeVarint(b.value), n(b.script, h), h;
  }
  function i(b, h) {
    return b.value = h.readVarint(), u(b.script, h), b;
  }
  function p(b) {
    let h = 0;
    return h += c.sizeVarint(b.value), h += a(b.script), h;
  }
  function m(b) {
    if (b.length === 0)
      return !1;
    switch (b[0]) {
      case 2:
      case 3:
        return b.length === 33;
      case 4:
        return b.length !== 65 ? !1 : d.publicKeyVerify(b);
      default:
        return !1;
    }
  }
  function E(b) {
    let h;
    switch (b[0]) {
      case 2:
      case 3:
        h = b;
        break;
      case 4:
        h = d.publicKeyConvert(b, !0), h[0] = 4 | b[64] & 1;
        break;
      default:
        throw new Error("Bad point format.");
    }
    return e(h.length === 33), h;
  }
  function v(b) {
    const h = b[0];
    switch (e(b.length === 33), h) {
      case 2:
      case 3:
        return b;
      case 4:
        b[0] = 2;
        break;
      case 5:
        b[0] = 3;
        break;
      default:
        throw new Error("Bad point format.");
    }
    const o = d.publicKeyConvert(b, !1);
    return b[0] = h, o;
  }
  return Nn.pack = s, Nn.unpack = i, Nn.size = p, Nn;
}
/*!
 * coinentry.js - coin entry object for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var Wc, r4;
function po() {
  if (r4) return Wc;
  r4 = 1;
  const e = $e(), c = At(), d = rs(), w = gi(), g = Qb(), { encoding: f } = c, n = 1, u = (1 << 32 - n >>> 0) - 1;
  class a {
    /**
     * Create a coin entry.
     * @constructor
     */
    constructor() {
      this.version = 1, this.height = -1, this.coinbase = !1, this.output = new w(), this.spent = !1, this.raw = null;
    }
    /**
     * Convert coin entry to an output.
     * @returns {Output}
     */
    toOutput() {
      return this.output;
    }
    /**
     * Convert coin entry to a coin.
     * @param {Outpoint} prevout
     * @returns {Coin}
     */
    toCoin(i) {
      const p = new d();
      return p.version = this.version, p.height = this.height, p.coinbase = this.coinbase, p.script = this.output.script, p.value = this.output.value, p.hash = i.hash, p.index = i.index, p;
    }
    /**
     * Inject properties from TX.
     * @param {TX} tx
     * @param {Number} index
     */
    fromOutput(i) {
      return this.output = i, this;
    }
    /**
     * Instantiate a coin from a TX
     * @param {TX} tx
     * @param {Number} index - Output index.
     * @returns {CoinEntry}
     */
    static fromOutput(i) {
      return new this().fromOutput(i);
    }
    /**
     * Inject properties from TX.
     * @param {TX} tx
     * @param {Number} index
     */
    fromCoin(i) {
      return this.version = i.version, this.height = i.height, this.coinbase = i.coinbase, this.output.script = i.script, this.output.value = i.value, this;
    }
    /**
     * Instantiate a coin from a TX
     * @param {TX} tx
     * @param {Number} index - Output index.
     * @returns {CoinEntry}
     */
    static fromCoin(i) {
      return new this().fromCoin(i);
    }
    /**
     * Inject properties from TX.
     * @param {TX} tx
     * @param {Number} index
     */
    fromTX(i, p, m) {
      return e(typeof p == "number"), e(typeof m == "number"), e(p >= 0 && p < i.outputs.length), this.version = i.version, this.height = m, this.coinbase = i.isCoinbase(), this.output = i.outputs[p], this;
    }
    /**
     * Instantiate a coin from a TX
     * @param {TX} tx
     * @param {Number} index - Output index.
     * @returns {CoinEntry}
     */
    static fromTX(i, p, m) {
      return new this().fromTX(i, p, m);
    }
    /**
     * Calculate size of coin.
     * @returns {Number}
     */
    getSize() {
      if (this.raw)
        return this.raw.length;
      let i = 0;
      return i += f.sizeVarint(this.version), i += 4, i += g.size(this.output), i;
    }
    /**
     * Write the coin to a buffer writer.
     * @param {BufferWriter} bw
     */
    toWriter(i) {
      if (this.raw)
        return i.writeBytes(this.raw), i;
      let p = this.height, m = 0;
      return this.coinbase && (m |= 1), p === -1 && (p = u), m |= p << n, i.writeVarint(this.version), i.writeU32(m), g.pack(this.output, i), i;
    }
    /**
     * Serialize the coin.
     * @returns {Buffer}
     */
    toRaw() {
      if (this.raw)
        return this.raw;
      const i = this.getSize(), p = c.write(i);
      return this.toWriter(p), this.raw = p.render(), this.raw;
    }
    /**
     * Inject properties from serialized buffer writer.
     * @private
     * @param {BufferReader} br
     */
    fromReader(i) {
      const p = i.readVarint(), m = i.readU32();
      let E = m >>> n;
      return E === u && (E = -1), this.version = p, this.coinbase = (m & 1) !== 0, this.height = E, g.unpack(this.output, i), this;
    }
    /**
     * Instantiate a coin from a serialized Buffer.
     * @param {Buffer} data
     * @returns {CoinEntry}
     */
    static fromReader(i) {
      return new this().fromReader(i);
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     */
    fromRaw(i) {
      return this.fromReader(c.read(i)), this.raw = i, this;
    }
    /**
     * Instantiate a coin from a serialized Buffer.
     * @param {Buffer} data
     * @returns {CoinEntry}
     */
    static fromRaw(i) {
      return new this().fromRaw(i);
    }
  }
  return Wc = a, Wc;
}
/*!
 * coins.js - coins object for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var Zc, i4;
function ml() {
  if (i4) return Zc;
  i4 = 1;
  const e = $e(), c = po();
  class d {
    /**
     * Create coins.
     * @constructor
     */
    constructor() {
      this.outputs = /* @__PURE__ */ new Map();
    }
    /**
     * Add a single entry to the collection.
     * @param {Number} index
     * @param {CoinEntry} coin
     * @returns {CoinEntry}
     */
    add(g, f) {
      return e(g >>> 0 === g), e(f), this.outputs.set(g, f), f;
    }
    /**
     * Add a single output to the collection.
     * @param {Number} index
     * @param {Output} output
     * @returns {CoinEntry}
     */
    addOutput(g, f) {
      return this.add(g, c.fromOutput(f));
    }
    /**
     * Add an output to the collection by output index.
     * @param {TX} tx
     * @param {Number} index
     * @param {Number} height
     * @returns {CoinEntry}
     */
    addIndex(g, f, n) {
      return this.add(f, c.fromTX(g, f, n));
    }
    /**
     * Add a single coin to the collection.
     * @param {Coin} coin
     * @returns {CoinEntry}
     */
    addCoin(g) {
      return this.add(g.index, c.fromCoin(g));
    }
    /**
     * Test whether the collection has a coin.
     * @param {Number} index
     * @returns {Boolean}
     */
    has(g) {
      return this.outputs.has(g);
    }
    /**
     * Test whether the collection has an unspent coin.
     * @param {Number} index
     * @returns {Boolean}
     */
    isUnspent(g) {
      const f = this.outputs.get(g);
      return !(!f || f.spent);
    }
    /**
     * Get a coin entry.
     * @param {Number} index
     * @returns {CoinEntry|null}
     */
    get(g) {
      return this.outputs.get(g) || null;
    }
    /**
     * Get an output.
     * @param {Number} index
     * @returns {Output|null}
     */
    getOutput(g) {
      const f = this.outputs.get(g);
      return f ? f.output : null;
    }
    /**
     * Get a coin.
     * @param {Outpoint} prevout
     * @returns {Coin|null}
     */
    getCoin(g) {
      const f = this.outputs.get(g.index);
      return f ? f.toCoin(g) : null;
    }
    /**
     * Spend a coin entry and return it.
     * @param {Number} index
     * @returns {CoinEntry|null}
     */
    spend(g) {
      const f = this.get(g);
      return !f || f.spent ? null : (f.spent = !0, f);
    }
    /**
     * Remove a coin entry and return it.
     * @param {Number} index
     * @returns {CoinEntry|null}
     */
    remove(g) {
      const f = this.get(g);
      return f ? (this.outputs.delete(g), f) : null;
    }
    /**
     * Test whether the coins are fully spent.
     * @returns {Boolean}
     */
    isEmpty() {
      return this.outputs.size === 0;
    }
    /**
     * Inject properties from tx.
     * @private
     * @param {TX} tx
     * @param {Number} height
     * @returns {Coins}
     */
    fromTX(g, f) {
      e(typeof f == "number");
      for (let n = 0; n < g.outputs.length; n++) {
        if (g.outputs[n].script.isUnspendable())
          continue;
        const a = c.fromTX(g, n, f);
        this.outputs.set(n, a);
      }
      return this;
    }
    /**
     * Instantiate a coins object from a transaction.
     * @param {TX} tx
     * @param {Number} height
     * @returns {Coins}
     */
    static fromTX(g, f) {
      return new this().fromTX(g, f);
    }
  }
  return Zc = d, Zc;
}
/*!
 * undocoins.js - undocoins object for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var Qc, n4;
function e7() {
  if (n4) return Qc;
  n4 = 1;
  const e = $e(), c = At(), d = po();
  class w {
    /**
     * Create undo coins.
     * @constructor
     */
    constructor() {
      this.items = [];
    }
    /**
     * Push coin entry onto undo coin array.
     * @param {CoinEntry}
     * @returns {Number}
     */
    push(f) {
      return this.items.push(f);
    }
    /**
     * Calculate undo coins size.
     * @returns {Number}
     */
    getSize() {
      let f = 0;
      f += 4;
      for (const n of this.items)
        f += n.getSize();
      return f;
    }
    /**
     * Serialize all undo coins.
     * @returns {Buffer}
     */
    toRaw() {
      const f = this.getSize(), n = c.write(f);
      n.writeU32(this.items.length);
      for (const u of this.items)
        u.toWriter(n);
      return n.render();
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     * @returns {UndoCoins}
     */
    fromRaw(f) {
      const n = c.read(f), u = n.readU32();
      for (let a = 0; a < u; a++)
        this.items.push(d.fromReader(n));
      return this;
    }
    /**
     * Instantiate undo coins from serialized data.
     * @param {Buffer} data
     * @returns {UndoCoins}
     */
    static fromRaw(f) {
      return new this().fromRaw(f);
    }
    /**
     * Test whether the undo coins have any members.
     * @returns {Boolean}
     */
    isEmpty() {
      return this.items.length === 0;
    }
    /**
     * Render the undo coins.
     * @returns {Buffer}
     */
    commit() {
      const f = this.toRaw();
      return this.items.length = 0, f;
    }
    /**
     * Re-apply undo coins to a view, effectively unspending them.
     * @param {CoinView} view
     * @param {Outpoint} prevout
     */
    apply(f, n) {
      const u = this.items.pop();
      e(u), f.addEntry(n, u);
    }
  }
  return Qc = w, Qc;
}
/*!
 * coinview.js - coin viewpoint object for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var eu, s4;
function mo() {
  if (s4) return eu;
  s4 = 1;
  const { BufferMap: e } = Dr(), c = ml(), d = e7(), w = po();
  class g {
    /**
     * Create a coin view.
     * @constructor
     */
    constructor() {
      this.map = new e(), this.undo = new d();
    }
    /**
     * Get coins.
     * @param {Hash} hash
     * @returns {Coins} coins
     */
    get(n) {
      return this.map.get(n);
    }
    /**
     * Test whether the view has an entry.
     * @param {Hash} hash
     * @returns {Boolean}
     */
    has(n) {
      return this.map.has(n);
    }
    /**
     * Add coins to the collection.
     * @param {Hash} hash
     * @param {Coins} coins
     * @returns {Coins}
     */
    add(n, u) {
      return this.map.set(n, u), u;
    }
    /**
     * Ensure existence of coins object in the collection.
     * @param {Hash} hash
     * @returns {Coins}
     */
    ensure(n) {
      const u = this.map.get(n);
      return u || this.add(n, new c());
    }
    /**
     * Remove coins from the collection.
     * @param {Coins} coins
     * @returns {Coins|null}
     */
    remove(n) {
      const u = this.map.get(n);
      return u ? (this.map.delete(n), u) : null;
    }
    /**
     * Add a tx to the collection.
     * @param {TX} tx
     * @param {Number} height
     * @returns {Coins}
     */
    addTX(n, u) {
      const a = n.hash(), s = c.fromTX(n, u);
      return this.add(a, s);
    }
    /**
     * Remove a tx from the collection.
     * @param {TX} tx
     * @param {Number} height
     * @returns {Coins}
     */
    removeTX(n, u) {
      const a = n.hash(), s = c.fromTX(n, u);
      for (const i of s.outputs.values())
        i.spent = !0;
      return this.add(a, s);
    }
    /**
     * Add an entry to the collection.
     * @param {Outpoint} prevout
     * @param {CoinEntry} coin
     * @returns {CoinEntry|null}
     */
    addEntry(n, u) {
      const { hash: a, index: s } = n;
      return this.ensure(a).add(s, u);
    }
    /**
     * Add a coin to the collection.
     * @param {Coin} coin
     * @returns {CoinEntry|null}
     */
    addCoin(n) {
      return this.ensure(n.hash).addCoin(n);
    }
    /**
     * Add an output to the collection.
     * @param {Outpoint} prevout
     * @param {Output} output
     * @returns {CoinEntry|null}
     */
    addOutput(n, u) {
      const { hash: a, index: s } = n;
      return this.ensure(a).addOutput(s, u);
    }
    /**
     * Add an output to the collection by output index.
     * @param {TX} tx
     * @param {Number} index
     * @param {Number} height
     * @returns {CoinEntry|null}
     */
    addIndex(n, u, a) {
      const s = n.hash();
      return this.ensure(s).addIndex(n, u, a);
    }
    /**
     * Spend an output.
     * @param {Outpoint} prevout
     * @returns {CoinEntry|null}
     */
    spendEntry(n) {
      const { hash: u, index: a } = n, s = this.get(u);
      if (!s)
        return null;
      const i = s.spend(a);
      return i ? (this.undo.push(i), i) : null;
    }
    /**
     * Remove an output.
     * @param {Outpoint} prevout
     * @returns {CoinEntry|null}
     */
    removeEntry(n) {
      const { hash: u, index: a } = n, s = this.get(u);
      return s ? s.remove(a) : null;
    }
    /**
     * Test whether the view has an entry by prevout.
     * @param {Outpoint} prevout
     * @returns {Boolean}
     */
    hasEntry(n) {
      const { hash: u, index: a } = n, s = this.get(u);
      return s ? s.has(a) : !1;
    }
    /**
     * Get a single entry by prevout.
     * @param {Outpoint} prevout
     * @returns {CoinEntry|null}
     */
    getEntry(n) {
      const { hash: u, index: a } = n, s = this.get(u);
      return s ? s.get(a) : null;
    }
    /**
     * Test whether an entry has been spent by prevout.
     * @param {Outpoint} prevout
     * @returns {Boolean}
     */
    isUnspent(n) {
      const { hash: u, index: a } = n, s = this.get(u);
      return s ? s.isUnspent(a) : !1;
    }
    /**
     * Get a single coin by prevout.
     * @param {Outpoint} prevout
     * @returns {Coin|null}
     */
    getCoin(n) {
      const u = this.get(n.hash);
      return u ? u.getCoin(n) : null;
    }
    /**
     * Get a single output by prevout.
     * @param {Outpoint} prevout
     * @returns {Output|null}
     */
    getOutput(n) {
      const { hash: u, index: a } = n, s = this.get(u);
      return s ? s.getOutput(a) : null;
    }
    /**
     * Get coins height by prevout.
     * @param {Outpoint} prevout
     * @returns {Number}
     */
    getHeight(n) {
      const u = this.getEntry(n);
      return u ? u.height : -1;
    }
    /**
     * Get coins coinbase flag by prevout.
     * @param {Outpoint} prevout
     * @returns {Boolean}
     */
    isCoinbase(n) {
      const u = this.getEntry(n);
      return u ? u.coinbase : !1;
    }
    /**
     * Test whether the view has an entry by input.
     * @param {Input} input
     * @returns {Boolean}
     */
    hasEntryFor(n) {
      return this.hasEntry(n.prevout);
    }
    /**
     * Get a single entry by input.
     * @param {Input} input
     * @returns {CoinEntry|null}
     */
    getEntryFor(n) {
      return this.getEntry(n.prevout);
    }
    /**
     * Test whether an entry has been spent by input.
     * @param {Input} input
     * @returns {Boolean}
     */
    isUnspentFor(n) {
      return this.isUnspent(n.prevout);
    }
    /**
     * Get a single coin by input.
     * @param {Input} input
     * @returns {Coin|null}
     */
    getCoinFor(n) {
      return this.getCoin(n.prevout);
    }
    /**
     * Get a single output by input.
     * @param {Input} input
     * @returns {Output|null}
     */
    getOutputFor(n) {
      return this.getOutput(n.prevout);
    }
    /**
     * Get coins height by input.
     * @param {Input} input
     * @returns {Number}
     */
    getHeightFor(n) {
      return this.getHeight(n.prevout);
    }
    /**
     * Get coins coinbase flag by input.
     * @param {Input} input
     * @returns {Boolean}
     */
    isCoinbaseFor(n) {
      return this.isCoinbase(n.prevout);
    }
    /**
     * Retrieve coins from database.
     * @method
     * @param {ChainDB} db
     * @param {Outpoint} prevout
     * @returns {Promise} - Returns {@link CoinEntry}.
     */
    async readCoin(n, u) {
      const a = this.getEntry(u);
      if (a)
        return a;
      const s = await n.readCoin(u);
      return s ? this.addEntry(u, s) : null;
    }
    /**
     * Read all input coins into unspent map.
     * @method
     * @param {ChainDB} db
     * @param {TX} tx
     * @returns {Promise} - Returns {Boolean}.
     */
    async readInputs(n, u) {
      let a = !0;
      for (const { prevout: s } of u.inputs)
        await this.readCoin(n, s) || (a = !1);
      return a;
    }
    /**
     * Spend coins for transaction.
     * @method
     * @param {ChainDB} db
     * @param {TX} tx
     * @returns {Promise} - Returns {Boolean}.
     */
    async spendInputs(n, u) {
      let a = 0;
      for (; a < u.inputs.length; ) {
        const s = Math.min(a + 4, u.inputs.length), i = [];
        for (; a < s; a++) {
          const { prevout: m } = u.inputs[a];
          i.push(this.readCoin(n, m));
        }
        const p = await Promise.all(i);
        for (const m of p) {
          if (!m || m.spent)
            return !1;
          m.spent = !0, this.undo.push(m);
        }
      }
      return !0;
    }
    /**
     * Calculate serialization size.
     * @returns {Number}
     */
    getSize(n) {
      let u = 0;
      u += n.inputs.length;
      for (const { prevout: a } of n.inputs) {
        const s = this.getEntry(a);
        s && (u += s.getSize());
      }
      return u;
    }
    /**
     * Write coin data to buffer writer
     * as it pertains to a transaction.
     * @param {BufferWriter} bw
     * @param {TX} tx
     */
    toWriter(n, u) {
      for (const { prevout: a } of u.inputs) {
        const s = this.getEntry(a);
        if (!s) {
          n.writeU8(0);
          continue;
        }
        n.writeU8(1), s.toWriter(n);
      }
      return n;
    }
    /**
     * Read serialized view data from a buffer
     * reader as it pertains to a transaction.
     * @private
     * @param {BufferReader} br
     * @param {TX} tx
     */
    fromReader(n, u) {
      for (const { prevout: a } of u.inputs) {
        if (n.readU8() === 0)
          continue;
        const s = w.fromReader(n);
        this.addEntry(a, s);
      }
      return this;
    }
    /**
     * Read serialized view data from a buffer
     * reader as it pertains to a transaction.
     * @param {BufferReader} br
     * @param {TX} tx
     * @returns {CoinView}
     */
    static fromReader(n, u) {
      return new this().fromReader(n, u);
    }
  }
  return eu = g, eu;
}
/*!
 * coins/index.js - utxo management for bcoin
 * Copyright (c) 2016-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var o4;
function rx() {
  return o4 || (o4 = 1, Yi.Coins = ml(), Yi.CoinView = mo(), Yi.compress = Qb(), Yi.UndoCoins = e7()), Yi;
}
var tu = {}, ru = {}, a4;
function go() {
  return a4 || (a4 = 1, function(e) {
    const c = $e(), d = c8(), w = e;
    w.HARDENED = 2147483648, w.MIN_ENTROPY = 128, w.MAX_ENTROPY = 512, w.cache = new d(500), w.parsePath = function(f, n) {
      c(typeof f == "string"), c(typeof n == "boolean"), c(f.length >= 1), c(f.length <= 3062);
      const u = f.split("/"), a = u[0];
      if (a !== "m" && a !== "M" && a !== "m'" && a !== "M'")
        throw new Error("Invalid path root.");
      const s = [];
      for (let i = 1; i < u.length; i++) {
        let p = u[i];
        const m = p[p.length - 1] === "'";
        if (m && (p = p.slice(0, -1)), p.length > 10)
          throw new Error("Path index too large.");
        if (!/^\d+$/.test(p))
          throw new Error("Path index is non-numeric.");
        let E = parseInt(p, 10);
        if (E >>> 0 !== E)
          throw new Error("Path index out of range.");
        if (m && (E |= w.HARDENED, E >>>= 0), !n && E & w.HARDENED)
          throw new Error("Path index cannot be hardened.");
        s.push(E);
      }
      return s;
    }, w.isMaster = function(f) {
      return f.depth === 0 && f.childIndex === 0 && f.parentFingerPrint === 0;
    }, w.isAccount = function(f, n) {
      if (n != null) {
        const u = (w.HARDENED | n) >>> 0;
        if (f.childIndex !== u)
          return !1;
      }
      return f.depth === 3 && (f.childIndex & w.HARDENED) !== 0;
    }, w.ZERO_KEY = k.alloc(33, 0);
  }(ru)), ru;
}
var iu, f4;
function mn() {
  if (f4) return iu;
  f4 = 1;
  const e = Mt(), c = pi();
  function d(w) {
    e(k.isBuffer(w)), c.randomFill(w, 0, w.length);
  }
  return d.native = 0, iu = d, iu;
}
var qn = {}, c4;
function xo() {
  if (c4) return qn;
  c4 = 1;
  const e = Mt(), d = (Lt.crypto || Lt.msCrypto || {}).subtle || {};
  function w(n, u, a, s, i) {
    typeof u == "string" && (u = k.from(u, "utf8")), typeof a == "string" && (a = k.from(a, "utf8")), a == null && (a = k.alloc(0)), e(n && typeof n.id == "string"), e(k.isBuffer(u)), e(k.isBuffer(a)), e(s >>> 0 === s), e(i >>> 0 === i);
    const p = n.size, m = Math.ceil(i / p), E = k.alloc(m * p), v = k.alloc(a.length + 4);
    a.copy(v, 0), u.length > n.blockSize && (u = n.digest(u), e(u.length <= n.blockSize));
    for (let b = 0; b < m; b++) {
      const h = b + 1;
      v[a.length + 0] = h >>> 24, v[a.length + 1] = h >>> 16, v[a.length + 2] = h >>> 8, v[a.length + 3] = h;
      const o = n.mac(v, u);
      let S = o;
      for (let H = 1; H < s; H++) {
        S = n.mac(S, u);
        for (let j = 0; j < p; j++)
          o[j] ^= S[j];
      }
      o.copy(E, b * p);
    }
    return E.slice(0, i);
  }
  async function g(n, u, a, s, i) {
    typeof u == "string" && (u = k.from(u, "utf8")), typeof a == "string" && (a = k.from(a, "utf8")), a == null && (a = k.alloc(0)), e(n && typeof n.id == "string"), e(k.isBuffer(u)), e(k.isBuffer(a)), e(s >>> 0 === s), e(i >>> 0 === i);
    const p = f(n);
    if (!d.importKey || !d.deriveBits || !p)
      return w(n, u, a, s, i);
    const m = { name: "PBKDF2" }, E = ["deriveBits"], v = {
      name: "PBKDF2",
      salt: a,
      iterations: s,
      hash: p
    }, b = await d.importKey("raw", u, m, !1, E), h = await d.deriveBits(v, b, i * 8);
    return k.from(h);
  }
  function f(n) {
    switch (n.id) {
      case "SHA1":
        return "SHA-1";
      case "SHA256":
        return "SHA-256";
      case "SHA384":
        return "SHA-384";
      case "SHA512":
        return "SHA-512";
      default:
        return null;
    }
  }
  return qn.native = 0, qn.derive = w, qn.deriveAsync = g, qn;
}
var nu, u4;
function gn() {
  if (u4) return nu;
  u4 = 1;
  const e = Mt(), c = ni(), d = -1, w = k.alloc(16, 0), g = k.alloc(128, 0);
  g[0] = 128;
  const f = new Uint32Array([
    1116352408,
    3609767458,
    1899447441,
    602891725,
    3049323471,
    3964484399,
    3921009573,
    2173295548,
    961987163,
    4081628472,
    1508970993,
    3053834265,
    2453635748,
    2937671579,
    2870763221,
    3664609560,
    3624381080,
    2734883394,
    310598401,
    1164996542,
    607225278,
    1323610764,
    1426881987,
    3590304994,
    1925078388,
    4068182383,
    2162078206,
    991336113,
    2614888103,
    633803317,
    3248222580,
    3479774868,
    3835390401,
    2666613458,
    4022224774,
    944711139,
    264347078,
    2341262773,
    604807628,
    2007800933,
    770255983,
    1495990901,
    1249150122,
    1856431235,
    1555081692,
    3175218132,
    1996064986,
    2198950837,
    2554220882,
    3999719339,
    2821834349,
    766784016,
    2952996808,
    2566594879,
    3210313671,
    3203337956,
    3336571891,
    1034457026,
    3584528711,
    2466948901,
    113926993,
    3758326383,
    338241895,
    168717936,
    666307205,
    1188179964,
    773529912,
    1546045734,
    1294757372,
    1522805485,
    1396182291,
    2643833823,
    1695183700,
    2343527390,
    1986661051,
    1014477480,
    2177026350,
    1206759142,
    2456956037,
    344077627,
    2730485921,
    1290863460,
    2820302411,
    3158454273,
    3259730800,
    3505952657,
    3345764771,
    106217008,
    3516065817,
    3606008344,
    3600352804,
    1432725776,
    4094571909,
    1467031594,
    275423344,
    851169720,
    430227734,
    3100823752,
    506948616,
    1363258195,
    659060556,
    3750685593,
    883997877,
    3785050280,
    958139571,
    3318307427,
    1322822218,
    3812723403,
    1537002063,
    2003034995,
    1747873779,
    3602036899,
    1955562222,
    1575990012,
    2024104815,
    1125592928,
    2227730452,
    2716904306,
    2361852424,
    442776044,
    2428436474,
    593698344,
    2756734187,
    3733110249,
    3204031479,
    2999351573,
    3329325298,
    3815920427,
    3391569614,
    3928383900,
    3515267271,
    566280711,
    3940187606,
    3454069534,
    4118630271,
    4000239992,
    116418474,
    1914138554,
    174292421,
    2731055270,
    289380356,
    3203993006,
    460393269,
    320620315,
    685471733,
    587496836,
    852142971,
    1086792851,
    1017036298,
    365543100,
    1126000580,
    2618297676,
    1288033470,
    3409855158,
    1501505948,
    4234509866,
    1607167915,
    987167468,
    1816402316,
    1246189591
  ]);
  class n {
    constructor() {
      this.state = new Uint32Array(16), this.msg = new Uint32Array(160), this.block = k.alloc(128), this.size = d;
    }
    init() {
      return this.state[0] = 1779033703, this.state[1] = 4089235720, this.state[2] = 3144134277, this.state[3] = 2227873595, this.state[4] = 1013904242, this.state[5] = 4271175723, this.state[6] = 2773480762, this.state[7] = 1595750129, this.state[8] = 1359893119, this.state[9] = 2917565137, this.state[10] = 2600822924, this.state[11] = 725511199, this.state[12] = 528734635, this.state[13] = 4215389547, this.state[14] = 1541459225, this.state[15] = 327033209, this.size = 0, this;
    }
    update(D) {
      return e(k.isBuffer(D)), this._update(D, D.length), this;
    }
    final() {
      return this._final(k.alloc(64));
    }
    _update(D, Q) {
      e(this.size !== d, "Context is not initialized.");
      let Z = this.size & 127, oe = 0;
      if (this.size += Q, Z > 0) {
        let y = 128 - Z;
        if (y > Q && (y = Q), D.copy(this.block, Z, oe, oe + y), Z += y, Q -= y, oe += y, Z < 128)
          return;
        this._transform(this.block, 0);
      }
      for (; Q >= 128; )
        this._transform(D, oe), oe += 128, Q -= 128;
      Q > 0 && D.copy(this.block, 0, oe, oe + Q);
    }
    /**
     * Finalize SHA512 context.
     * @private
     * @param {Buffer} out
     * @returns {Buffer}
     */
    _final(D) {
      e(this.size !== d, "Context is not initialized.");
      const Q = this.size & 127, Z = this.size * 8;
      ue(w, Z * (1 / 4294967296) >>> 0, 8), ue(w, Z >>> 0, 12), this._update(g, 1 + (239 - Q & 127)), this._update(w, 16);
      for (let oe = 0; oe < 16; oe++)
        ue(D, this.state[oe], oe * 4), this.state[oe] = 0;
      for (let oe = 0; oe < 160; oe++)
        this.msg[oe] = 0;
      for (let oe = 0; oe < 128; oe++)
        this.block[oe] = 0;
      return this.size = d, D;
    }
    _prepare(D, Q) {
      const Z = this.msg;
      let oe = 0;
      for (; oe < 32; oe++)
        Z[oe] = fe(D, Q + oe * 4);
      for (; oe < 160; oe += 2) {
        const y = R(Z[oe - 4], Z[oe - 3]), Y = V(Z[oe - 4], Z[oe - 3]), he = Z[oe - 14], be = Z[oe - 13], xe = _(Z[oe - 30], Z[oe - 29]), Ie = F(Z[oe - 30], Z[oe - 29]), ve = Z[oe - 32], C = Z[oe - 31];
        Z[oe + 0] = i(
          y,
          Y,
          he,
          be,
          xe,
          Ie,
          ve,
          C
        ), Z[oe + 1] = p(
          y,
          Y,
          he,
          be,
          xe,
          Ie,
          ve,
          C
        );
      }
    }
    _transform(D, Q) {
      const Z = this.msg;
      this._prepare(D, Q);
      let oe = this.state[0], y = this.state[1], Y = this.state[2], he = this.state[3], be = this.state[4], xe = this.state[5], Ie = this.state[6], ve = this.state[7], C = this.state[8], I = this.state[9], se = this.state[10], t = this.state[11], l = this.state[12], B = this.state[13], U = this.state[14], G = this.state[15];
      for (let T = 0; T < Z.length; T += 2) {
        let M = U, $ = G, r = A(C, I), x = q(C, I);
        const O = S(C, I, se, t, l), L = H(C, I, se, t, l, B), X = f[T + 0], P = f[T + 1], K = Z[T + 0], re = Z[T + 1], ce = m(
          M,
          $,
          r,
          x,
          O,
          L,
          X,
          P,
          K,
          re
        ), le = E(
          M,
          $,
          r,
          x,
          O,
          L,
          X,
          P,
          K,
          re
        );
        M = N(oe, y), $ = z(oe, y), r = j(oe, y, Y, he, be), x = J(oe, y, Y, he, be, xe);
        const me = a(M, $, r, x), ne = s(M, $, r, x);
        U = l, G = B, l = se, B = t, se = C, t = I, C = a(Ie, ve, ce, le), I = s(ve, ve, ce, le), Ie = be, ve = xe, be = Y, xe = he, Y = oe, he = y, oe = a(ce, le, me, ne), y = s(ce, le, me, ne);
      }
      u(this.state, 0, oe, y), u(this.state, 2, Y, he), u(this.state, 4, be, xe), u(this.state, 6, Ie, ve), u(this.state, 8, C, I), u(this.state, 10, se, t), u(this.state, 12, l, B), u(this.state, 14, U, G);
    }
    static hash() {
      return new n();
    }
    static hmac() {
      return new c(n, 128);
    }
    static digest(D) {
      return n.ctx.init().update(D).final();
    }
    static root(D, Q) {
      return e(k.isBuffer(D) && D.length === 64), e(k.isBuffer(Q) && Q.length === 64), n.ctx.init().update(D).update(Q).final();
    }
    static multi(D, Q, Z) {
      const { ctx: oe } = n;
      return oe.init(), oe.update(D), oe.update(Q), Z && oe.update(Z), oe.final();
    }
    static mac(D, Q) {
      return n.hmac().init(Q).update(D).final();
    }
  }
  n.native = 0, n.id = "SHA512", n.size = 64, n.bits = 512, n.blockSize = 128, n.zero = k.alloc(64, 0), n.ctx = new n();
  function u(ae, D, Q, Z) {
    const oe = ae[D + 0], y = ae[D + 1], Y = Z + y >>> 0, he = (Y < Z) + Q + oe;
    ae[D + 0] = he >>> 0, ae[D + 1] = Y;
  }
  function a(ae, D, Q, Z) {
    return (D + Z >>> 0 < D) + ae + Q >>> 0;
  }
  function s(ae, D, Q, Z) {
    return D + Z >>> 0;
  }
  function i(ae, D, Q, Z, oe, y, Y, he) {
    let be = 0, xe = D;
    return xe = xe + Z >>> 0, be += xe < D, xe = xe + y >>> 0, be += xe < y, xe = xe + he >>> 0, be += xe < he, ae + Q + oe + Y + be >>> 0;
  }
  function p(ae, D, Q, Z, oe, y, Y, he) {
    return D + Z + y + he >>> 0;
  }
  function m(ae, D, Q, Z, oe, y, Y, he, be, xe) {
    let Ie = 0, ve = D;
    return ve = ve + Z >>> 0, Ie += ve < D, ve = ve + y >>> 0, Ie += ve < y, ve = ve + he >>> 0, Ie += ve < he, ve = ve + xe >>> 0, Ie += ve < xe, ae + Q + oe + Y + be + Ie >>> 0;
  }
  function E(ae, D, Q, Z, oe, y, Y, he, be, xe) {
    return D + Z + y + he + xe >>> 0;
  }
  function v(ae, D, Q) {
    return (D << 32 - Q | ae >>> Q) >>> 0;
  }
  function b(ae, D, Q) {
    return (ae << 32 - Q | D >>> Q) >>> 0;
  }
  function h(ae, D, Q) {
    return ae >>> Q;
  }
  function o(ae, D, Q) {
    return (ae << 32 - Q | D >>> Q) >>> 0;
  }
  function S(ae, D, Q, Z, oe, y) {
    return (ae & Q ^ ~ae & oe) >>> 0;
  }
  function H(ae, D, Q, Z, oe, y) {
    return (D & Z ^ ~D & y) >>> 0;
  }
  function j(ae, D, Q, Z, oe, y) {
    return (ae & Q ^ ae & oe ^ Q & oe) >>> 0;
  }
  function J(ae, D, Q, Z, oe, y) {
    return (D & Z ^ D & y ^ Z & y) >>> 0;
  }
  function N(ae, D) {
    const Q = v(ae, D, 28), Z = v(D, ae, 2), oe = v(D, ae, 7);
    return (Q ^ Z ^ oe) >>> 0;
  }
  function z(ae, D) {
    const Q = b(ae, D, 28), Z = b(D, ae, 2), oe = b(D, ae, 7);
    return (Q ^ Z ^ oe) >>> 0;
  }
  function A(ae, D) {
    const Q = v(ae, D, 14), Z = v(ae, D, 18), oe = v(D, ae, 9);
    return (Q ^ Z ^ oe) >>> 0;
  }
  function q(ae, D) {
    const Q = b(ae, D, 14), Z = b(ae, D, 18), oe = b(D, ae, 9);
    return (Q ^ Z ^ oe) >>> 0;
  }
  function _(ae, D) {
    const Q = v(ae, D, 1), Z = v(ae, D, 8), oe = h(ae, D, 7);
    return (Q ^ Z ^ oe) >>> 0;
  }
  function F(ae, D) {
    const Q = b(ae, D, 1), Z = b(ae, D, 8), oe = o(ae, D, 7);
    return (Q ^ Z ^ oe) >>> 0;
  }
  function R(ae, D) {
    const Q = v(ae, D, 19), Z = v(D, ae, 29), oe = h(ae, D, 6);
    return (Q ^ Z ^ oe) >>> 0;
  }
  function V(ae, D) {
    const Q = b(ae, D, 19), Z = b(D, ae, 29), oe = o(ae, D, 6);
    return (Q ^ Z ^ oe) >>> 0;
  }
  function fe(ae, D) {
    return ae[D++] * 16777216 + ae[D++] * 65536 + ae[D++] * 256 + ae[D];
  }
  function ue(ae, D, Q) {
    return ae[Q++] = D >>> 24, ae[Q++] = D >>> 16, ae[Q++] = D >>> 8, ae[Q++] = D, Q;
  }
  return nu = n, nu;
}
var su = {}, ci = {}, ou, h4;
function ix() {
  return h4 || (h4 = 1, ou = [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ]), ou;
}
var au, l4;
function nx() {
  return l4 || (l4 = 1, au = [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ]), au;
}
var fu, d4;
function sx() {
  return d4 || (d4 = 1, fu = [
    "abandon",
    "ability",
    "able",
    "about",
    "above",
    "absent",
    "absorb",
    "abstract",
    "absurd",
    "abuse",
    "access",
    "accident",
    "account",
    "accuse",
    "achieve",
    "acid",
    "acoustic",
    "acquire",
    "across",
    "act",
    "action",
    "actor",
    "actress",
    "actual",
    "adapt",
    "add",
    "addict",
    "address",
    "adjust",
    "admit",
    "adult",
    "advance",
    "advice",
    "aerobic",
    "affair",
    "afford",
    "afraid",
    "again",
    "age",
    "agent",
    "agree",
    "ahead",
    "aim",
    "air",
    "airport",
    "aisle",
    "alarm",
    "album",
    "alcohol",
    "alert",
    "alien",
    "all",
    "alley",
    "allow",
    "almost",
    "alone",
    "alpha",
    "already",
    "also",
    "alter",
    "always",
    "amateur",
    "amazing",
    "among",
    "amount",
    "amused",
    "analyst",
    "anchor",
    "ancient",
    "anger",
    "angle",
    "angry",
    "animal",
    "ankle",
    "announce",
    "annual",
    "another",
    "answer",
    "antenna",
    "antique",
    "anxiety",
    "any",
    "apart",
    "apology",
    "appear",
    "apple",
    "approve",
    "april",
    "arch",
    "arctic",
    "area",
    "arena",
    "argue",
    "arm",
    "armed",
    "armor",
    "army",
    "around",
    "arrange",
    "arrest",
    "arrive",
    "arrow",
    "art",
    "artefact",
    "artist",
    "artwork",
    "ask",
    "aspect",
    "assault",
    "asset",
    "assist",
    "assume",
    "asthma",
    "athlete",
    "atom",
    "attack",
    "attend",
    "attitude",
    "attract",
    "auction",
    "audit",
    "august",
    "aunt",
    "author",
    "auto",
    "autumn",
    "average",
    "avocado",
    "avoid",
    "awake",
    "aware",
    "away",
    "awesome",
    "awful",
    "awkward",
    "axis",
    "baby",
    "bachelor",
    "bacon",
    "badge",
    "bag",
    "balance",
    "balcony",
    "ball",
    "bamboo",
    "banana",
    "banner",
    "bar",
    "barely",
    "bargain",
    "barrel",
    "base",
    "basic",
    "basket",
    "battle",
    "beach",
    "bean",
    "beauty",
    "because",
    "become",
    "beef",
    "before",
    "begin",
    "behave",
    "behind",
    "believe",
    "below",
    "belt",
    "bench",
    "benefit",
    "best",
    "betray",
    "better",
    "between",
    "beyond",
    "bicycle",
    "bid",
    "bike",
    "bind",
    "biology",
    "bird",
    "birth",
    "bitter",
    "black",
    "blade",
    "blame",
    "blanket",
    "blast",
    "bleak",
    "bless",
    "blind",
    "blood",
    "blossom",
    "blouse",
    "blue",
    "blur",
    "blush",
    "board",
    "boat",
    "body",
    "boil",
    "bomb",
    "bone",
    "bonus",
    "book",
    "boost",
    "border",
    "boring",
    "borrow",
    "boss",
    "bottom",
    "bounce",
    "box",
    "boy",
    "bracket",
    "brain",
    "brand",
    "brass",
    "brave",
    "bread",
    "breeze",
    "brick",
    "bridge",
    "brief",
    "bright",
    "bring",
    "brisk",
    "broccoli",
    "broken",
    "bronze",
    "broom",
    "brother",
    "brown",
    "brush",
    "bubble",
    "buddy",
    "budget",
    "buffalo",
    "build",
    "bulb",
    "bulk",
    "bullet",
    "bundle",
    "bunker",
    "burden",
    "burger",
    "burst",
    "bus",
    "business",
    "busy",
    "butter",
    "buyer",
    "buzz",
    "cabbage",
    "cabin",
    "cable",
    "cactus",
    "cage",
    "cake",
    "call",
    "calm",
    "camera",
    "camp",
    "can",
    "canal",
    "cancel",
    "candy",
    "cannon",
    "canoe",
    "canvas",
    "canyon",
    "capable",
    "capital",
    "captain",
    "car",
    "carbon",
    "card",
    "cargo",
    "carpet",
    "carry",
    "cart",
    "case",
    "cash",
    "casino",
    "castle",
    "casual",
    "cat",
    "catalog",
    "catch",
    "category",
    "cattle",
    "caught",
    "cause",
    "caution",
    "cave",
    "ceiling",
    "celery",
    "cement",
    "census",
    "century",
    "cereal",
    "certain",
    "chair",
    "chalk",
    "champion",
    "change",
    "chaos",
    "chapter",
    "charge",
    "chase",
    "chat",
    "cheap",
    "check",
    "cheese",
    "chef",
    "cherry",
    "chest",
    "chicken",
    "chief",
    "child",
    "chimney",
    "choice",
    "choose",
    "chronic",
    "chuckle",
    "chunk",
    "churn",
    "cigar",
    "cinnamon",
    "circle",
    "citizen",
    "city",
    "civil",
    "claim",
    "clap",
    "clarify",
    "claw",
    "clay",
    "clean",
    "clerk",
    "clever",
    "click",
    "client",
    "cliff",
    "climb",
    "clinic",
    "clip",
    "clock",
    "clog",
    "close",
    "cloth",
    "cloud",
    "clown",
    "club",
    "clump",
    "cluster",
    "clutch",
    "coach",
    "coast",
    "coconut",
    "code",
    "coffee",
    "coil",
    "coin",
    "collect",
    "color",
    "column",
    "combine",
    "come",
    "comfort",
    "comic",
    "common",
    "company",
    "concert",
    "conduct",
    "confirm",
    "congress",
    "connect",
    "consider",
    "control",
    "convince",
    "cook",
    "cool",
    "copper",
    "copy",
    "coral",
    "core",
    "corn",
    "correct",
    "cost",
    "cotton",
    "couch",
    "country",
    "couple",
    "course",
    "cousin",
    "cover",
    "coyote",
    "crack",
    "cradle",
    "craft",
    "cram",
    "crane",
    "crash",
    "crater",
    "crawl",
    "crazy",
    "cream",
    "credit",
    "creek",
    "crew",
    "cricket",
    "crime",
    "crisp",
    "critic",
    "crop",
    "cross",
    "crouch",
    "crowd",
    "crucial",
    "cruel",
    "cruise",
    "crumble",
    "crunch",
    "crush",
    "cry",
    "crystal",
    "cube",
    "culture",
    "cup",
    "cupboard",
    "curious",
    "current",
    "curtain",
    "curve",
    "cushion",
    "custom",
    "cute",
    "cycle",
    "dad",
    "damage",
    "damp",
    "dance",
    "danger",
    "daring",
    "dash",
    "daughter",
    "dawn",
    "day",
    "deal",
    "debate",
    "debris",
    "decade",
    "december",
    "decide",
    "decline",
    "decorate",
    "decrease",
    "deer",
    "defense",
    "define",
    "defy",
    "degree",
    "delay",
    "deliver",
    "demand",
    "demise",
    "denial",
    "dentist",
    "deny",
    "depart",
    "depend",
    "deposit",
    "depth",
    "deputy",
    "derive",
    "describe",
    "desert",
    "design",
    "desk",
    "despair",
    "destroy",
    "detail",
    "detect",
    "develop",
    "device",
    "devote",
    "diagram",
    "dial",
    "diamond",
    "diary",
    "dice",
    "diesel",
    "diet",
    "differ",
    "digital",
    "dignity",
    "dilemma",
    "dinner",
    "dinosaur",
    "direct",
    "dirt",
    "disagree",
    "discover",
    "disease",
    "dish",
    "dismiss",
    "disorder",
    "display",
    "distance",
    "divert",
    "divide",
    "divorce",
    "dizzy",
    "doctor",
    "document",
    "dog",
    "doll",
    "dolphin",
    "domain",
    "donate",
    "donkey",
    "donor",
    "door",
    "dose",
    "double",
    "dove",
    "draft",
    "dragon",
    "drama",
    "drastic",
    "draw",
    "dream",
    "dress",
    "drift",
    "drill",
    "drink",
    "drip",
    "drive",
    "drop",
    "drum",
    "dry",
    "duck",
    "dumb",
    "dune",
    "during",
    "dust",
    "dutch",
    "duty",
    "dwarf",
    "dynamic",
    "eager",
    "eagle",
    "early",
    "earn",
    "earth",
    "easily",
    "east",
    "easy",
    "echo",
    "ecology",
    "economy",
    "edge",
    "edit",
    "educate",
    "effort",
    "egg",
    "eight",
    "either",
    "elbow",
    "elder",
    "electric",
    "elegant",
    "element",
    "elephant",
    "elevator",
    "elite",
    "else",
    "embark",
    "embody",
    "embrace",
    "emerge",
    "emotion",
    "employ",
    "empower",
    "empty",
    "enable",
    "enact",
    "end",
    "endless",
    "endorse",
    "enemy",
    "energy",
    "enforce",
    "engage",
    "engine",
    "enhance",
    "enjoy",
    "enlist",
    "enough",
    "enrich",
    "enroll",
    "ensure",
    "enter",
    "entire",
    "entry",
    "envelope",
    "episode",
    "equal",
    "equip",
    "era",
    "erase",
    "erode",
    "erosion",
    "error",
    "erupt",
    "escape",
    "essay",
    "essence",
    "estate",
    "eternal",
    "ethics",
    "evidence",
    "evil",
    "evoke",
    "evolve",
    "exact",
    "example",
    "excess",
    "exchange",
    "excite",
    "exclude",
    "excuse",
    "execute",
    "exercise",
    "exhaust",
    "exhibit",
    "exile",
    "exist",
    "exit",
    "exotic",
    "expand",
    "expect",
    "expire",
    "explain",
    "expose",
    "express",
    "extend",
    "extra",
    "eye",
    "eyebrow",
    "fabric",
    "face",
    "faculty",
    "fade",
    "faint",
    "faith",
    "fall",
    "false",
    "fame",
    "family",
    "famous",
    "fan",
    "fancy",
    "fantasy",
    "farm",
    "fashion",
    "fat",
    "fatal",
    "father",
    "fatigue",
    "fault",
    "favorite",
    "feature",
    "february",
    "federal",
    "fee",
    "feed",
    "feel",
    "female",
    "fence",
    "festival",
    "fetch",
    "fever",
    "few",
    "fiber",
    "fiction",
    "field",
    "figure",
    "file",
    "film",
    "filter",
    "final",
    "find",
    "fine",
    "finger",
    "finish",
    "fire",
    "firm",
    "first",
    "fiscal",
    "fish",
    "fit",
    "fitness",
    "fix",
    "flag",
    "flame",
    "flash",
    "flat",
    "flavor",
    "flee",
    "flight",
    "flip",
    "float",
    "flock",
    "floor",
    "flower",
    "fluid",
    "flush",
    "fly",
    "foam",
    "focus",
    "fog",
    "foil",
    "fold",
    "follow",
    "food",
    "foot",
    "force",
    "forest",
    "forget",
    "fork",
    "fortune",
    "forum",
    "forward",
    "fossil",
    "foster",
    "found",
    "fox",
    "fragile",
    "frame",
    "frequent",
    "fresh",
    "friend",
    "fringe",
    "frog",
    "front",
    "frost",
    "frown",
    "frozen",
    "fruit",
    "fuel",
    "fun",
    "funny",
    "furnace",
    "fury",
    "future",
    "gadget",
    "gain",
    "galaxy",
    "gallery",
    "game",
    "gap",
    "garage",
    "garbage",
    "garden",
    "garlic",
    "garment",
    "gas",
    "gasp",
    "gate",
    "gather",
    "gauge",
    "gaze",
    "general",
    "genius",
    "genre",
    "gentle",
    "genuine",
    "gesture",
    "ghost",
    "giant",
    "gift",
    "giggle",
    "ginger",
    "giraffe",
    "girl",
    "give",
    "glad",
    "glance",
    "glare",
    "glass",
    "glide",
    "glimpse",
    "globe",
    "gloom",
    "glory",
    "glove",
    "glow",
    "glue",
    "goat",
    "goddess",
    "gold",
    "good",
    "goose",
    "gorilla",
    "gospel",
    "gossip",
    "govern",
    "gown",
    "grab",
    "grace",
    "grain",
    "grant",
    "grape",
    "grass",
    "gravity",
    "great",
    "green",
    "grid",
    "grief",
    "grit",
    "grocery",
    "group",
    "grow",
    "grunt",
    "guard",
    "guess",
    "guide",
    "guilt",
    "guitar",
    "gun",
    "gym",
    "habit",
    "hair",
    "half",
    "hammer",
    "hamster",
    "hand",
    "happy",
    "harbor",
    "hard",
    "harsh",
    "harvest",
    "hat",
    "have",
    "hawk",
    "hazard",
    "head",
    "health",
    "heart",
    "heavy",
    "hedgehog",
    "height",
    "hello",
    "helmet",
    "help",
    "hen",
    "hero",
    "hidden",
    "high",
    "hill",
    "hint",
    "hip",
    "hire",
    "history",
    "hobby",
    "hockey",
    "hold",
    "hole",
    "holiday",
    "hollow",
    "home",
    "honey",
    "hood",
    "hope",
    "horn",
    "horror",
    "horse",
    "hospital",
    "host",
    "hotel",
    "hour",
    "hover",
    "hub",
    "huge",
    "human",
    "humble",
    "humor",
    "hundred",
    "hungry",
    "hunt",
    "hurdle",
    "hurry",
    "hurt",
    "husband",
    "hybrid",
    "ice",
    "icon",
    "idea",
    "identify",
    "idle",
    "ignore",
    "ill",
    "illegal",
    "illness",
    "image",
    "imitate",
    "immense",
    "immune",
    "impact",
    "impose",
    "improve",
    "impulse",
    "inch",
    "include",
    "income",
    "increase",
    "index",
    "indicate",
    "indoor",
    "industry",
    "infant",
    "inflict",
    "inform",
    "inhale",
    "inherit",
    "initial",
    "inject",
    "injury",
    "inmate",
    "inner",
    "innocent",
    "input",
    "inquiry",
    "insane",
    "insect",
    "inside",
    "inspire",
    "install",
    "intact",
    "interest",
    "into",
    "invest",
    "invite",
    "involve",
    "iron",
    "island",
    "isolate",
    "issue",
    "item",
    "ivory",
    "jacket",
    "jaguar",
    "jar",
    "jazz",
    "jealous",
    "jeans",
    "jelly",
    "jewel",
    "job",
    "join",
    "joke",
    "journey",
    "joy",
    "judge",
    "juice",
    "jump",
    "jungle",
    "junior",
    "junk",
    "just",
    "kangaroo",
    "keen",
    "keep",
    "ketchup",
    "key",
    "kick",
    "kid",
    "kidney",
    "kind",
    "kingdom",
    "kiss",
    "kit",
    "kitchen",
    "kite",
    "kitten",
    "kiwi",
    "knee",
    "knife",
    "knock",
    "know",
    "lab",
    "label",
    "labor",
    "ladder",
    "lady",
    "lake",
    "lamp",
    "language",
    "laptop",
    "large",
    "later",
    "latin",
    "laugh",
    "laundry",
    "lava",
    "law",
    "lawn",
    "lawsuit",
    "layer",
    "lazy",
    "leader",
    "leaf",
    "learn",
    "leave",
    "lecture",
    "left",
    "leg",
    "legal",
    "legend",
    "leisure",
    "lemon",
    "lend",
    "length",
    "lens",
    "leopard",
    "lesson",
    "letter",
    "level",
    "liar",
    "liberty",
    "library",
    "license",
    "life",
    "lift",
    "light",
    "like",
    "limb",
    "limit",
    "link",
    "lion",
    "liquid",
    "list",
    "little",
    "live",
    "lizard",
    "load",
    "loan",
    "lobster",
    "local",
    "lock",
    "logic",
    "lonely",
    "long",
    "loop",
    "lottery",
    "loud",
    "lounge",
    "love",
    "loyal",
    "lucky",
    "luggage",
    "lumber",
    "lunar",
    "lunch",
    "luxury",
    "lyrics",
    "machine",
    "mad",
    "magic",
    "magnet",
    "maid",
    "mail",
    "main",
    "major",
    "make",
    "mammal",
    "man",
    "manage",
    "mandate",
    "mango",
    "mansion",
    "manual",
    "maple",
    "marble",
    "march",
    "margin",
    "marine",
    "market",
    "marriage",
    "mask",
    "mass",
    "master",
    "match",
    "material",
    "math",
    "matrix",
    "matter",
    "maximum",
    "maze",
    "meadow",
    "mean",
    "measure",
    "meat",
    "mechanic",
    "medal",
    "media",
    "melody",
    "melt",
    "member",
    "memory",
    "mention",
    "menu",
    "mercy",
    "merge",
    "merit",
    "merry",
    "mesh",
    "message",
    "metal",
    "method",
    "middle",
    "midnight",
    "milk",
    "million",
    "mimic",
    "mind",
    "minimum",
    "minor",
    "minute",
    "miracle",
    "mirror",
    "misery",
    "miss",
    "mistake",
    "mix",
    "mixed",
    "mixture",
    "mobile",
    "model",
    "modify",
    "mom",
    "moment",
    "monitor",
    "monkey",
    "monster",
    "month",
    "moon",
    "moral",
    "more",
    "morning",
    "mosquito",
    "mother",
    "motion",
    "motor",
    "mountain",
    "mouse",
    "move",
    "movie",
    "much",
    "muffin",
    "mule",
    "multiply",
    "muscle",
    "museum",
    "mushroom",
    "music",
    "must",
    "mutual",
    "myself",
    "mystery",
    "myth",
    "naive",
    "name",
    "napkin",
    "narrow",
    "nasty",
    "nation",
    "nature",
    "near",
    "neck",
    "need",
    "negative",
    "neglect",
    "neither",
    "nephew",
    "nerve",
    "nest",
    "net",
    "network",
    "neutral",
    "never",
    "news",
    "next",
    "nice",
    "night",
    "noble",
    "noise",
    "nominee",
    "noodle",
    "normal",
    "north",
    "nose",
    "notable",
    "note",
    "nothing",
    "notice",
    "novel",
    "now",
    "nuclear",
    "number",
    "nurse",
    "nut",
    "oak",
    "obey",
    "object",
    "oblige",
    "obscure",
    "observe",
    "obtain",
    "obvious",
    "occur",
    "ocean",
    "october",
    "odor",
    "off",
    "offer",
    "office",
    "often",
    "oil",
    "okay",
    "old",
    "olive",
    "olympic",
    "omit",
    "once",
    "one",
    "onion",
    "online",
    "only",
    "open",
    "opera",
    "opinion",
    "oppose",
    "option",
    "orange",
    "orbit",
    "orchard",
    "order",
    "ordinary",
    "organ",
    "orient",
    "original",
    "orphan",
    "ostrich",
    "other",
    "outdoor",
    "outer",
    "output",
    "outside",
    "oval",
    "oven",
    "over",
    "own",
    "owner",
    "oxygen",
    "oyster",
    "ozone",
    "pact",
    "paddle",
    "page",
    "pair",
    "palace",
    "palm",
    "panda",
    "panel",
    "panic",
    "panther",
    "paper",
    "parade",
    "parent",
    "park",
    "parrot",
    "party",
    "pass",
    "patch",
    "path",
    "patient",
    "patrol",
    "pattern",
    "pause",
    "pave",
    "payment",
    "peace",
    "peanut",
    "pear",
    "peasant",
    "pelican",
    "pen",
    "penalty",
    "pencil",
    "people",
    "pepper",
    "perfect",
    "permit",
    "person",
    "pet",
    "phone",
    "photo",
    "phrase",
    "physical",
    "piano",
    "picnic",
    "picture",
    "piece",
    "pig",
    "pigeon",
    "pill",
    "pilot",
    "pink",
    "pioneer",
    "pipe",
    "pistol",
    "pitch",
    "pizza",
    "place",
    "planet",
    "plastic",
    "plate",
    "play",
    "please",
    "pledge",
    "pluck",
    "plug",
    "plunge",
    "poem",
    "poet",
    "point",
    "polar",
    "pole",
    "police",
    "pond",
    "pony",
    "pool",
    "popular",
    "portion",
    "position",
    "possible",
    "post",
    "potato",
    "pottery",
    "poverty",
    "powder",
    "power",
    "practice",
    "praise",
    "predict",
    "prefer",
    "prepare",
    "present",
    "pretty",
    "prevent",
    "price",
    "pride",
    "primary",
    "print",
    "priority",
    "prison",
    "private",
    "prize",
    "problem",
    "process",
    "produce",
    "profit",
    "program",
    "project",
    "promote",
    "proof",
    "property",
    "prosper",
    "protect",
    "proud",
    "provide",
    "public",
    "pudding",
    "pull",
    "pulp",
    "pulse",
    "pumpkin",
    "punch",
    "pupil",
    "puppy",
    "purchase",
    "purity",
    "purpose",
    "purse",
    "push",
    "put",
    "puzzle",
    "pyramid",
    "quality",
    "quantum",
    "quarter",
    "question",
    "quick",
    "quit",
    "quiz",
    "quote",
    "rabbit",
    "raccoon",
    "race",
    "rack",
    "radar",
    "radio",
    "rail",
    "rain",
    "raise",
    "rally",
    "ramp",
    "ranch",
    "random",
    "range",
    "rapid",
    "rare",
    "rate",
    "rather",
    "raven",
    "raw",
    "razor",
    "ready",
    "real",
    "reason",
    "rebel",
    "rebuild",
    "recall",
    "receive",
    "recipe",
    "record",
    "recycle",
    "reduce",
    "reflect",
    "reform",
    "refuse",
    "region",
    "regret",
    "regular",
    "reject",
    "relax",
    "release",
    "relief",
    "rely",
    "remain",
    "remember",
    "remind",
    "remove",
    "render",
    "renew",
    "rent",
    "reopen",
    "repair",
    "repeat",
    "replace",
    "report",
    "require",
    "rescue",
    "resemble",
    "resist",
    "resource",
    "response",
    "result",
    "retire",
    "retreat",
    "return",
    "reunion",
    "reveal",
    "review",
    "reward",
    "rhythm",
    "rib",
    "ribbon",
    "rice",
    "rich",
    "ride",
    "ridge",
    "rifle",
    "right",
    "rigid",
    "ring",
    "riot",
    "ripple",
    "risk",
    "ritual",
    "rival",
    "river",
    "road",
    "roast",
    "robot",
    "robust",
    "rocket",
    "romance",
    "roof",
    "rookie",
    "room",
    "rose",
    "rotate",
    "rough",
    "round",
    "route",
    "royal",
    "rubber",
    "rude",
    "rug",
    "rule",
    "run",
    "runway",
    "rural",
    "sad",
    "saddle",
    "sadness",
    "safe",
    "sail",
    "salad",
    "salmon",
    "salon",
    "salt",
    "salute",
    "same",
    "sample",
    "sand",
    "satisfy",
    "satoshi",
    "sauce",
    "sausage",
    "save",
    "say",
    "scale",
    "scan",
    "scare",
    "scatter",
    "scene",
    "scheme",
    "school",
    "science",
    "scissors",
    "scorpion",
    "scout",
    "scrap",
    "screen",
    "script",
    "scrub",
    "sea",
    "search",
    "season",
    "seat",
    "second",
    "secret",
    "section",
    "security",
    "seed",
    "seek",
    "segment",
    "select",
    "sell",
    "seminar",
    "senior",
    "sense",
    "sentence",
    "series",
    "service",
    "session",
    "settle",
    "setup",
    "seven",
    "shadow",
    "shaft",
    "shallow",
    "share",
    "shed",
    "shell",
    "sheriff",
    "shield",
    "shift",
    "shine",
    "ship",
    "shiver",
    "shock",
    "shoe",
    "shoot",
    "shop",
    "short",
    "shoulder",
    "shove",
    "shrimp",
    "shrug",
    "shuffle",
    "shy",
    "sibling",
    "sick",
    "side",
    "siege",
    "sight",
    "sign",
    "silent",
    "silk",
    "silly",
    "silver",
    "similar",
    "simple",
    "since",
    "sing",
    "siren",
    "sister",
    "situate",
    "six",
    "size",
    "skate",
    "sketch",
    "ski",
    "skill",
    "skin",
    "skirt",
    "skull",
    "slab",
    "slam",
    "sleep",
    "slender",
    "slice",
    "slide",
    "slight",
    "slim",
    "slogan",
    "slot",
    "slow",
    "slush",
    "small",
    "smart",
    "smile",
    "smoke",
    "smooth",
    "snack",
    "snake",
    "snap",
    "sniff",
    "snow",
    "soap",
    "soccer",
    "social",
    "sock",
    "soda",
    "soft",
    "solar",
    "soldier",
    "solid",
    "solution",
    "solve",
    "someone",
    "song",
    "soon",
    "sorry",
    "sort",
    "soul",
    "sound",
    "soup",
    "source",
    "south",
    "space",
    "spare",
    "spatial",
    "spawn",
    "speak",
    "special",
    "speed",
    "spell",
    "spend",
    "sphere",
    "spice",
    "spider",
    "spike",
    "spin",
    "spirit",
    "split",
    "spoil",
    "sponsor",
    "spoon",
    "sport",
    "spot",
    "spray",
    "spread",
    "spring",
    "spy",
    "square",
    "squeeze",
    "squirrel",
    "stable",
    "stadium",
    "staff",
    "stage",
    "stairs",
    "stamp",
    "stand",
    "start",
    "state",
    "stay",
    "steak",
    "steel",
    "stem",
    "step",
    "stereo",
    "stick",
    "still",
    "sting",
    "stock",
    "stomach",
    "stone",
    "stool",
    "story",
    "stove",
    "strategy",
    "street",
    "strike",
    "strong",
    "struggle",
    "student",
    "stuff",
    "stumble",
    "style",
    "subject",
    "submit",
    "subway",
    "success",
    "such",
    "sudden",
    "suffer",
    "sugar",
    "suggest",
    "suit",
    "summer",
    "sun",
    "sunny",
    "sunset",
    "super",
    "supply",
    "supreme",
    "sure",
    "surface",
    "surge",
    "surprise",
    "surround",
    "survey",
    "suspect",
    "sustain",
    "swallow",
    "swamp",
    "swap",
    "swarm",
    "swear",
    "sweet",
    "swift",
    "swim",
    "swing",
    "switch",
    "sword",
    "symbol",
    "symptom",
    "syrup",
    "system",
    "table",
    "tackle",
    "tag",
    "tail",
    "talent",
    "talk",
    "tank",
    "tape",
    "target",
    "task",
    "taste",
    "tattoo",
    "taxi",
    "teach",
    "team",
    "tell",
    "ten",
    "tenant",
    "tennis",
    "tent",
    "term",
    "test",
    "text",
    "thank",
    "that",
    "theme",
    "then",
    "theory",
    "there",
    "they",
    "thing",
    "this",
    "thought",
    "three",
    "thrive",
    "throw",
    "thumb",
    "thunder",
    "ticket",
    "tide",
    "tiger",
    "tilt",
    "timber",
    "time",
    "tiny",
    "tip",
    "tired",
    "tissue",
    "title",
    "toast",
    "tobacco",
    "today",
    "toddler",
    "toe",
    "together",
    "toilet",
    "token",
    "tomato",
    "tomorrow",
    "tone",
    "tongue",
    "tonight",
    "tool",
    "tooth",
    "top",
    "topic",
    "topple",
    "torch",
    "tornado",
    "tortoise",
    "toss",
    "total",
    "tourist",
    "toward",
    "tower",
    "town",
    "toy",
    "track",
    "trade",
    "traffic",
    "tragic",
    "train",
    "transfer",
    "trap",
    "trash",
    "travel",
    "tray",
    "treat",
    "tree",
    "trend",
    "trial",
    "tribe",
    "trick",
    "trigger",
    "trim",
    "trip",
    "trophy",
    "trouble",
    "truck",
    "true",
    "truly",
    "trumpet",
    "trust",
    "truth",
    "try",
    "tube",
    "tuition",
    "tumble",
    "tuna",
    "tunnel",
    "turkey",
    "turn",
    "turtle",
    "twelve",
    "twenty",
    "twice",
    "twin",
    "twist",
    "two",
    "type",
    "typical",
    "ugly",
    "umbrella",
    "unable",
    "unaware",
    "uncle",
    "uncover",
    "under",
    "undo",
    "unfair",
    "unfold",
    "unhappy",
    "uniform",
    "unique",
    "unit",
    "universe",
    "unknown",
    "unlock",
    "until",
    "unusual",
    "unveil",
    "update",
    "upgrade",
    "uphold",
    "upon",
    "upper",
    "upset",
    "urban",
    "urge",
    "usage",
    "use",
    "used",
    "useful",
    "useless",
    "usual",
    "utility",
    "vacant",
    "vacuum",
    "vague",
    "valid",
    "valley",
    "valve",
    "van",
    "vanish",
    "vapor",
    "various",
    "vast",
    "vault",
    "vehicle",
    "velvet",
    "vendor",
    "venture",
    "venue",
    "verb",
    "verify",
    "version",
    "very",
    "vessel",
    "veteran",
    "viable",
    "vibrant",
    "vicious",
    "victory",
    "video",
    "view",
    "village",
    "vintage",
    "violin",
    "virtual",
    "virus",
    "visa",
    "visit",
    "visual",
    "vital",
    "vivid",
    "vocal",
    "voice",
    "void",
    "volcano",
    "volume",
    "vote",
    "voyage",
    "wage",
    "wagon",
    "wait",
    "walk",
    "wall",
    "walnut",
    "want",
    "warfare",
    "warm",
    "warrior",
    "wash",
    "wasp",
    "waste",
    "water",
    "wave",
    "way",
    "wealth",
    "weapon",
    "wear",
    "weasel",
    "weather",
    "web",
    "wedding",
    "weekend",
    "weird",
    "welcome",
    "west",
    "wet",
    "whale",
    "what",
    "wheat",
    "wheel",
    "when",
    "where",
    "whip",
    "whisper",
    "wide",
    "width",
    "wife",
    "wild",
    "will",
    "win",
    "window",
    "wine",
    "wing",
    "wink",
    "winner",
    "winter",
    "wire",
    "wisdom",
    "wise",
    "wish",
    "witness",
    "wolf",
    "woman",
    "wonder",
    "wood",
    "wool",
    "word",
    "work",
    "world",
    "worry",
    "worth",
    "wrap",
    "wreck",
    "wrestle",
    "wrist",
    "write",
    "wrong",
    "yard",
    "year",
    "yellow",
    "you",
    "young",
    "youth",
    "zebra",
    "zero",
    "zone",
    "zoo"
  ]), fu;
}
var cu, b4;
function ox() {
  return b4 || (b4 = 1, cu = [
    "abaisser",
    "abandon",
    "abdiquer",
    "abeille",
    "abolir",
    "aborder",
    "aboutir",
    "aboyer",
    "abrasif",
    "abreuver",
    "abriter",
    "abroger",
    "abrupt",
    "absence",
    "absolu",
    "absurde",
    "abusif",
    "abyssal",
    "academie",
    "acajou",
    "acarien",
    "accabler",
    "accepter",
    "acclamer",
    "accolade",
    "accroche",
    "accuser",
    "acerbe",
    "achat",
    "acheter",
    "aciduler",
    "acier",
    "acompte",
    "acquerir",
    "acronyme",
    "acteur",
    "actif",
    "actuel",
    "adepte",
    "adequat",
    "adhesif",
    "adjectif",
    "adjuger",
    "admettre",
    "admirer",
    "adopter",
    "adorer",
    "adoucir",
    "adresse",
    "adroit",
    "adulte",
    "adverbe",
    "aerer",
    "aeronef",
    "affaire",
    "affecter",
    "affiche",
    "affreux",
    "affubler",
    "agacer",
    "agencer",
    "agile",
    "agiter",
    "agrafer",
    "agreable",
    "agrume",
    "aider",
    "aiguille",
    "ailier",
    "aimable",
    "aisance",
    "ajouter",
    "ajuster",
    "alarmer",
    "alchimie",
    "alerte",
    "algebre",
    "algue",
    "aliener",
    "aliment",
    "alleger",
    "alliage",
    "allouer",
    "allumer",
    "alourdir",
    "alpaga",
    "altesse",
    "alveole",
    "amateur",
    "ambigu",
    "ambre",
    "amenager",
    "amertume",
    "amidon",
    "amiral",
    "amorcer",
    "amour",
    "amovible",
    "amphibie",
    "ampleur",
    "amusant",
    "analyse",
    "anaphore",
    "anarchie",
    "anatomie",
    "ancien",
    "aneantir",
    "angle",
    "angoisse",
    "anguleux",
    "animal",
    "annexer",
    "annonce",
    "annuel",
    "anodin",
    "anomalie",
    "anonyme",
    "anormal",
    "antenne",
    "antidote",
    "anxieux",
    "apaiser",
    "aperitif",
    "aplanir",
    "apologie",
    "appareil",
    "appeler",
    "apporter",
    "appuyer",
    "aquarium",
    "aqueduc",
    "arbitre",
    "arbuste",
    "ardeur",
    "ardoise",
    "argent",
    "arlequin",
    "armature",
    "armement",
    "armoire",
    "armure",
    "arpenter",
    "arracher",
    "arriver",
    "arroser",
    "arsenic",
    "arteriel",
    "article",
    "aspect",
    "asphalte",
    "aspirer",
    "assaut",
    "asservir",
    "assiette",
    "associer",
    "assurer",
    "asticot",
    "astre",
    "astuce",
    "atelier",
    "atome",
    "atrium",
    "atroce",
    "attaque",
    "attentif",
    "attirer",
    "attraper",
    "aubaine",
    "auberge",
    "audace",
    "audible",
    "augurer",
    "aurore",
    "automne",
    "autruche",
    "avaler",
    "avancer",
    "avarice",
    "avenir",
    "averse",
    "aveugle",
    "aviateur",
    "avide",
    "avion",
    "aviser",
    "avoine",
    "avouer",
    "avril",
    "axial",
    "axiome",
    "badge",
    "bafouer",
    "bagage",
    "baguette",
    "baignade",
    "balancer",
    "balcon",
    "baleine",
    "balisage",
    "bambin",
    "bancaire",
    "bandage",
    "banlieue",
    "banniere",
    "banquier",
    "barbier",
    "baril",
    "baron",
    "barque",
    "barrage",
    "bassin",
    "bastion",
    "bataille",
    "bateau",
    "batterie",
    "baudrier",
    "bavarder",
    "belette",
    "belier",
    "belote",
    "benefice",
    "berceau",
    "berger",
    "berline",
    "bermuda",
    "besace",
    "besogne",
    "betail",
    "beurre",
    "biberon",
    "bicycle",
    "bidule",
    "bijou",
    "bilan",
    "bilingue",
    "billard",
    "binaire",
    "biologie",
    "biopsie",
    "biotype",
    "biscuit",
    "bison",
    "bistouri",
    "bitume",
    "bizarre",
    "blafard",
    "blague",
    "blanchir",
    "blessant",
    "blinder",
    "blond",
    "bloquer",
    "blouson",
    "bobard",
    "bobine",
    "boire",
    "boiser",
    "bolide",
    "bonbon",
    "bondir",
    "bonheur",
    "bonifier",
    "bonus",
    "bordure",
    "borne",
    "botte",
    "boucle",
    "boueux",
    "bougie",
    "boulon",
    "bouquin",
    "bourse",
    "boussole",
    "boutique",
    "boxeur",
    "branche",
    "brasier",
    "brave",
    "brebis",
    "breche",
    "breuvage",
    "bricoler",
    "brigade",
    "brillant",
    "brioche",
    "brique",
    "brochure",
    "broder",
    "bronzer",
    "brousse",
    "broyeur",
    "brume",
    "brusque",
    "brutal",
    "bruyant",
    "buffle",
    "buisson",
    "bulletin",
    "bureau",
    "burin",
    "bustier",
    "butiner",
    "butoir",
    "buvable",
    "buvette",
    "cabanon",
    "cabine",
    "cachette",
    "cadeau",
    "cadre",
    "cafeine",
    "caillou",
    "caisson",
    "calculer",
    "calepin",
    "calibre",
    "calmer",
    "calomnie",
    "calvaire",
    "camarade",
    "camera",
    "camion",
    "campagne",
    "canal",
    "caneton",
    "canon",
    "cantine",
    "canular",
    "capable",
    "caporal",
    "caprice",
    "capsule",
    "capter",
    "capuche",
    "carabine",
    "carbone",
    "caresser",
    "caribou",
    "carnage",
    "carotte",
    "carreau",
    "carton",
    "cascade",
    "casier",
    "casque",
    "cassure",
    "causer",
    "caution",
    "cavalier",
    "caverne",
    "caviar",
    "cedille",
    "ceinture",
    "celeste",
    "cellule",
    "cendrier",
    "censurer",
    "central",
    "cercle",
    "cerebral",
    "cerise",
    "cerner",
    "cerveau",
    "cesser",
    "chagrin",
    "chaise",
    "chaleur",
    "chambre",
    "chance",
    "chapitre",
    "charbon",
    "chasseur",
    "chaton",
    "chausson",
    "chavirer",
    "chemise",
    "chenille",
    "chequier",
    "chercher",
    "cheval",
    "chien",
    "chiffre",
    "chignon",
    "chimere",
    "chiot",
    "chlorure",
    "chocolat",
    "choisir",
    "chose",
    "chouette",
    "chrome",
    "chute",
    "cigare",
    "cigogne",
    "cimenter",
    "cinema",
    "cintrer",
    "circuler",
    "cirer",
    "cirque",
    "citerne",
    "citoyen",
    "citron",
    "civil",
    "clairon",
    "clameur",
    "claquer",
    "classe",
    "clavier",
    "client",
    "cligner",
    "climat",
    "clivage",
    "cloche",
    "clonage",
    "cloporte",
    "cobalt",
    "cobra",
    "cocasse",
    "cocotier",
    "coder",
    "codifier",
    "coffre",
    "cogner",
    "cohesion",
    "coiffer",
    "coincer",
    "colere",
    "colibri",
    "colline",
    "colmater",
    "colonel",
    "combat",
    "comedie",
    "commande",
    "compact",
    "concert",
    "conduire",
    "confier",
    "congeler",
    "connoter",
    "consonne",
    "contact",
    "convexe",
    "copain",
    "copie",
    "corail",
    "corbeau",
    "cordage",
    "corniche",
    "corpus",
    "correct",
    "cortege",
    "cosmique",
    "costume",
    "coton",
    "coude",
    "coupure",
    "courage",
    "couteau",
    "couvrir",
    "coyote",
    "crabe",
    "crainte",
    "cravate",
    "crayon",
    "creature",
    "crediter",
    "cremeux",
    "creuser",
    "crevette",
    "cribler",
    "crier",
    "cristal",
    "critere",
    "croire",
    "croquer",
    "crotale",
    "crucial",
    "cruel",
    "crypter",
    "cubique",
    "cueillir",
    "cuillere",
    "cuisine",
    "cuivre",
    "culminer",
    "cultiver",
    "cumuler",
    "cupide",
    "curatif",
    "curseur",
    "cyanure",
    "cycle",
    "cylindre",
    "cynique",
    "daigner",
    "damier",
    "danger",
    "danseur",
    "dauphin",
    "debattre",
    "debiter",
    "deborder",
    "debrider",
    "debutant",
    "decaler",
    "decembre",
    "dechirer",
    "decider",
    "declarer",
    "decorer",
    "decrire",
    "decupler",
    "dedale",
    "deductif",
    "deesse",
    "defensif",
    "defiler",
    "defrayer",
    "degager",
    "degivrer",
    "deglutir",
    "degrafer",
    "dejeuner",
    "delice",
    "deloger",
    "demander",
    "demeurer",
    "demolir",
    "denicher",
    "denouer",
    "dentelle",
    "denuder",
    "depart",
    "depenser",
    "dephaser",
    "deplacer",
    "deposer",
    "deranger",
    "derober",
    "desastre",
    "descente",
    "desert",
    "designer",
    "desobeir",
    "dessiner",
    "destrier",
    "detacher",
    "detester",
    "detourer",
    "detresse",
    "devancer",
    "devenir",
    "deviner",
    "devoir",
    "diable",
    "dialogue",
    "diamant",
    "dicter",
    "differer",
    "digerer",
    "digital",
    "digne",
    "diluer",
    "dimanche",
    "diminuer",
    "dioxyde",
    "directif",
    "diriger",
    "discuter",
    "disposer",
    "dissiper",
    "distance",
    "divertir",
    "diviser",
    "docile",
    "docteur",
    "dogme",
    "doigt",
    "domaine",
    "domicile",
    "dompter",
    "donateur",
    "donjon",
    "donner",
    "dopamine",
    "dortoir",
    "dorure",
    "dosage",
    "doseur",
    "dossier",
    "dotation",
    "douanier",
    "double",
    "douceur",
    "douter",
    "doyen",
    "dragon",
    "draper",
    "dresser",
    "dribbler",
    "droiture",
    "duperie",
    "duplexe",
    "durable",
    "durcir",
    "dynastie",
    "eblouir",
    "ecarter",
    "echarpe",
    "echelle",
    "eclairer",
    "eclipse",
    "eclore",
    "ecluse",
    "ecole",
    "economie",
    "ecorce",
    "ecouter",
    "ecraser",
    "ecremer",
    "ecrivain",
    "ecrou",
    "ecume",
    "ecureuil",
    "edifier",
    "eduquer",
    "effacer",
    "effectif",
    "effigie",
    "effort",
    "effrayer",
    "effusion",
    "egaliser",
    "egarer",
    "ejecter",
    "elaborer",
    "elargir",
    "electron",
    "elegant",
    "elephant",
    "eleve",
    "eligible",
    "elitisme",
    "eloge",
    "elucider",
    "eluder",
    "emballer",
    "embellir",
    "embryon",
    "emeraude",
    "emission",
    "emmener",
    "emotion",
    "emouvoir",
    "empereur",
    "employer",
    "emporter",
    "emprise",
    "emulsion",
    "encadrer",
    "enchere",
    "enclave",
    "encoche",
    "endiguer",
    "endosser",
    "endroit",
    "enduire",
    "energie",
    "enfance",
    "enfermer",
    "enfouir",
    "engager",
    "engin",
    "englober",
    "enigme",
    "enjamber",
    "enjeu",
    "enlever",
    "ennemi",
    "ennuyeux",
    "enrichir",
    "enrobage",
    "enseigne",
    "entasser",
    "entendre",
    "entier",
    "entourer",
    "entraver",
    "enumerer",
    "envahir",
    "enviable",
    "envoyer",
    "enzyme",
    "eolien",
    "epaissir",
    "epargne",
    "epatant",
    "epaule",
    "epicerie",
    "epidemie",
    "epier",
    "epilogue",
    "epine",
    "episode",
    "epitaphe",
    "epoque",
    "epreuve",
    "eprouver",
    "epuisant",
    "equerre",
    "equipe",
    "eriger",
    "erosion",
    "erreur",
    "eruption",
    "escalier",
    "espadon",
    "espece",
    "espiegle",
    "espoir",
    "esprit",
    "esquiver",
    "essayer",
    "essence",
    "essieu",
    "essorer",
    "estime",
    "estomac",
    "estrade",
    "etagere",
    "etaler",
    "etanche",
    "etatique",
    "eteindre",
    "etendoir",
    "eternel",
    "ethanol",
    "ethique",
    "ethnie",
    "etirer",
    "etoffer",
    "etoile",
    "etonnant",
    "etourdir",
    "etrange",
    "etroit",
    "etude",
    "euphorie",
    "evaluer",
    "evasion",
    "eventail",
    "evidence",
    "eviter",
    "evolutif",
    "evoquer",
    "exact",
    "exagerer",
    "exaucer",
    "exceller",
    "excitant",
    "exclusif",
    "excuse",
    "executer",
    "exemple",
    "exercer",
    "exhaler",
    "exhorter",
    "exigence",
    "exiler",
    "exister",
    "exotique",
    "expedier",
    "explorer",
    "exposer",
    "exprimer",
    "exquis",
    "extensif",
    "extraire",
    "exulter",
    "fable",
    "fabuleux",
    "facette",
    "facile",
    "facture",
    "faiblir",
    "falaise",
    "fameux",
    "famille",
    "farceur",
    "farfelu",
    "farine",
    "farouche",
    "fasciner",
    "fatal",
    "fatigue",
    "faucon",
    "fautif",
    "faveur",
    "favori",
    "febrile",
    "feconder",
    "federer",
    "felin",
    "femme",
    "femur",
    "fendoir",
    "feodal",
    "fermer",
    "feroce",
    "ferveur",
    "festival",
    "feuille",
    "feutre",
    "fevrier",
    "fiasco",
    "ficeler",
    "fictif",
    "fidele",
    "figure",
    "filature",
    "filetage",
    "filiere",
    "filleul",
    "filmer",
    "filou",
    "filtrer",
    "financer",
    "finir",
    "fiole",
    "firme",
    "fissure",
    "fixer",
    "flairer",
    "flamme",
    "flasque",
    "flatteur",
    "fleau",
    "fleche",
    "fleur",
    "flexion",
    "flocon",
    "flore",
    "fluctuer",
    "fluide",
    "fluvial",
    "folie",
    "fonderie",
    "fongible",
    "fontaine",
    "forcer",
    "forgeron",
    "formuler",
    "fortune",
    "fossile",
    "foudre",
    "fougere",
    "fouiller",
    "foulure",
    "fourmi",
    "fragile",
    "fraise",
    "franchir",
    "frapper",
    "frayeur",
    "fregate",
    "freiner",
    "frelon",
    "fremir",
    "frenesie",
    "frere",
    "friable",
    "friction",
    "frisson",
    "frivole",
    "froid",
    "fromage",
    "frontal",
    "frotter",
    "fruit",
    "fugitif",
    "fuite",
    "fureur",
    "furieux",
    "furtif",
    "fusion",
    "futur",
    "gagner",
    "galaxie",
    "galerie",
    "gambader",
    "garantir",
    "gardien",
    "garnir",
    "garrigue",
    "gazelle",
    "gazon",
    "geant",
    "gelatine",
    "gelule",
    "gendarme",
    "general",
    "genie",
    "genou",
    "gentil",
    "geologie",
    "geometre",
    "geranium",
    "germe",
    "gestuel",
    "geyser",
    "gibier",
    "gicler",
    "girafe",
    "givre",
    "glace",
    "glaive",
    "glisser",
    "globe",
    "gloire",
    "glorieux",
    "golfeur",
    "gomme",
    "gonfler",
    "gorge",
    "gorille",
    "goudron",
    "gouffre",
    "goulot",
    "goupille",
    "gourmand",
    "goutte",
    "graduel",
    "graffiti",
    "graine",
    "grand",
    "grappin",
    "gratuit",
    "gravir",
    "grenat",
    "griffure",
    "griller",
    "grimper",
    "grogner",
    "gronder",
    "grotte",
    "groupe",
    "gruger",
    "grutier",
    "gruyere",
    "guepard",
    "guerrier",
    "guide",
    "guimauve",
    "guitare",
    "gustatif",
    "gymnaste",
    "gyrostat",
    "habitude",
    "hachoir",
    "halte",
    "hameau",
    "hangar",
    "hanneton",
    "haricot",
    "harmonie",
    "harpon",
    "hasard",
    "helium",
    "hematome",
    "herbe",
    "herisson",
    "hermine",
    "heron",
    "hesiter",
    "heureux",
    "hiberner",
    "hibou",
    "hilarant",
    "histoire",
    "hiver",
    "homard",
    "hommage",
    "homogene",
    "honneur",
    "honorer",
    "honteux",
    "horde",
    "horizon",
    "horloge",
    "hormone",
    "horrible",
    "houleux",
    "housse",
    "hublot",
    "huileux",
    "humain",
    "humble",
    "humide",
    "humour",
    "hurler",
    "hydromel",
    "hygiene",
    "hymne",
    "hypnose",
    "idylle",
    "ignorer",
    "iguane",
    "illicite",
    "illusion",
    "image",
    "imbiber",
    "imiter",
    "immense",
    "immobile",
    "immuable",
    "impact",
    "imperial",
    "implorer",
    "imposer",
    "imprimer",
    "imputer",
    "incarner",
    "incendie",
    "incident",
    "incliner",
    "incolore",
    "indexer",
    "indice",
    "inductif",
    "inedit",
    "ineptie",
    "inexact",
    "infini",
    "infliger",
    "informer",
    "infusion",
    "ingerer",
    "inhaler",
    "inhiber",
    "injecter",
    "injure",
    "innocent",
    "inoculer",
    "inonder",
    "inscrire",
    "insecte",
    "insigne",
    "insolite",
    "inspirer",
    "instinct",
    "insulter",
    "intact",
    "intense",
    "intime",
    "intrigue",
    "intuitif",
    "inutile",
    "invasion",
    "inventer",
    "inviter",
    "invoquer",
    "ironique",
    "irradier",
    "irreel",
    "irriter",
    "isoler",
    "ivoire",
    "ivresse",
    "jaguar",
    "jaillir",
    "jambe",
    "janvier",
    "jardin",
    "jauger",
    "jaune",
    "javelot",
    "jetable",
    "jeton",
    "jeudi",
    "jeunesse",
    "joindre",
    "joncher",
    "jongler",
    "joueur",
    "jouissif",
    "journal",
    "jovial",
    "joyau",
    "joyeux",
    "jubiler",
    "jugement",
    "junior",
    "jupon",
    "juriste",
    "justice",
    "juteux",
    "juvenile",
    "kayak",
    "kimono",
    "kiosque",
    "label",
    "labial",
    "labourer",
    "lacerer",
    "lactose",
    "lagune",
    "laine",
    "laisser",
    "laitier",
    "lambeau",
    "lamelle",
    "lampe",
    "lanceur",
    "langage",
    "lanterne",
    "lapin",
    "largeur",
    "larme",
    "laurier",
    "lavabo",
    "lavoir",
    "lecture",
    "legal",
    "leger",
    "legume",
    "lessive",
    "lettre",
    "levier",
    "lexique",
    "lezard",
    "liasse",
    "liberer",
    "libre",
    "licence",
    "licorne",
    "liege",
    "lievre",
    "ligature",
    "ligoter",
    "ligue",
    "limer",
    "limite",
    "limonade",
    "limpide",
    "lineaire",
    "lingot",
    "lionceau",
    "liquide",
    "lisiere",
    "lister",
    "lithium",
    "litige",
    "littoral",
    "livreur",
    "logique",
    "lointain",
    "loisir",
    "lombric",
    "loterie",
    "louer",
    "lourd",
    "loutre",
    "louve",
    "loyal",
    "lubie",
    "lucide",
    "lucratif",
    "lueur",
    "lugubre",
    "luisant",
    "lumiere",
    "lunaire",
    "lundi",
    "luron",
    "lutter",
    "luxueux",
    "machine",
    "magasin",
    "magenta",
    "magique",
    "maigre",
    "maillon",
    "maintien",
    "mairie",
    "maison",
    "majorer",
    "malaxer",
    "malefice",
    "malheur",
    "malice",
    "mallette",
    "mammouth",
    "mandater",
    "maniable",
    "manquant",
    "manteau",
    "manuel",
    "marathon",
    "marbre",
    "marchand",
    "mardi",
    "maritime",
    "marqueur",
    "marron",
    "marteler",
    "mascotte",
    "massif",
    "materiel",
    "matiere",
    "matraque",
    "maudire",
    "maussade",
    "mauve",
    "maximal",
    "mechant",
    "meconnu",
    "medaille",
    "medecin",
    "mediter",
    "meduse",
    "meilleur",
    "melange",
    "melodie",
    "membre",
    "memoire",
    "menacer",
    "mener",
    "menhir",
    "mensonge",
    "mentor",
    "mercredi",
    "merite",
    "merle",
    "messager",
    "mesure",
    "metal",
    "meteore",
    "methode",
    "metier",
    "meuble",
    "miauler",
    "microbe",
    "miette",
    "mignon",
    "migrer",
    "milieu",
    "million",
    "mimique",
    "mince",
    "mineral",
    "minimal",
    "minorer",
    "minute",
    "miracle",
    "miroiter",
    "missile",
    "mixte",
    "mobile",
    "moderne",
    "moelleux",
    "mondial",
    "moniteur",
    "monnaie",
    "monotone",
    "monstre",
    "montagne",
    "monument",
    "moqueur",
    "morceau",
    "morsure",
    "mortier",
    "moteur",
    "motif",
    "mouche",
    "moufle",
    "moulin",
    "mousson",
    "mouton",
    "mouvant",
    "multiple",
    "munition",
    "muraille",
    "murene",
    "murmure",
    "muscle",
    "museum",
    "musicien",
    "mutation",
    "muter",
    "mutuel",
    "myriade",
    "myrtille",
    "mystere",
    "mythique",
    "nageur",
    "nappe",
    "narquois",
    "narrer",
    "natation",
    "nation",
    "nature",
    "naufrage",
    "nautique",
    "navire",
    "nebuleux",
    "nectar",
    "nefaste",
    "negation",
    "negliger",
    "negocier",
    "neige",
    "nerveux",
    "nettoyer",
    "neurone",
    "neutron",
    "neveu",
    "niche",
    "nickel",
    "nitrate",
    "niveau",
    "noble",
    "nocif",
    "nocturne",
    "noirceur",
    "noisette",
    "nomade",
    "nombreux",
    "nommer",
    "normatif",
    "notable",
    "notifier",
    "notoire",
    "nourrir",
    "nouveau",
    "novateur",
    "novembre",
    "novice",
    "nuage",
    "nuancer",
    "nuire",
    "nuisible",
    "numero",
    "nuptial",
    "nuque",
    "nutritif",
    "obeir",
    "objectif",
    "obliger",
    "obscur",
    "observer",
    "obstacle",
    "obtenir",
    "obturer",
    "occasion",
    "occuper",
    "ocean",
    "octobre",
    "octroyer",
    "octupler",
    "oculaire",
    "odeur",
    "odorant",
    "offenser",
    "officier",
    "offrir",
    "ogive",
    "oiseau",
    "oisillon",
    "olfactif",
    "olivier",
    "ombrage",
    "omettre",
    "onctueux",
    "onduler",
    "onereux",
    "onirique",
    "opale",
    "opaque",
    "operer",
    "opinion",
    "opportun",
    "opprimer",
    "opter",
    "optique",
    "orageux",
    "orange",
    "orbite",
    "ordonner",
    "oreille",
    "organe",
    "orgueil",
    "orifice",
    "ornement",
    "orque",
    "ortie",
    "osciller",
    "osmose",
    "ossature",
    "otarie",
    "ouragan",
    "ourson",
    "outil",
    "outrager",
    "ouvrage",
    "ovation",
    "oxyde",
    "oxygene",
    "ozone",
    "paisible",
    "palace",
    "palmares",
    "palourde",
    "palper",
    "panache",
    "panda",
    "pangolin",
    "paniquer",
    "panneau",
    "panorama",
    "pantalon",
    "papaye",
    "papier",
    "papoter",
    "papyrus",
    "paradoxe",
    "parcelle",
    "paresse",
    "parfumer",
    "parler",
    "parole",
    "parrain",
    "parsemer",
    "partager",
    "parure",
    "parvenir",
    "passion",
    "pasteque",
    "paternel",
    "patience",
    "patron",
    "pavillon",
    "pavoiser",
    "payer",
    "paysage",
    "peigne",
    "peintre",
    "pelage",
    "pelican",
    "pelle",
    "pelouse",
    "peluche",
    "pendule",
    "penetrer",
    "penible",
    "pensif",
    "penurie",
    "pepite",
    "peplum",
    "perdrix",
    "perforer",
    "periode",
    "permuter",
    "perplexe",
    "persil",
    "perte",
    "peser",
    "petale",
    "petit",
    "petrir",
    "peuple",
    "pharaon",
    "phobie",
    "phoque",
    "photon",
    "phrase",
    "physique",
    "piano",
    "pictural",
    "piece",
    "pierre",
    "pieuvre",
    "pilote",
    "pinceau",
    "pipette",
    "piquer",
    "pirogue",
    "piscine",
    "piston",
    "pivoter",
    "pixel",
    "pizza",
    "placard",
    "plafond",
    "plaisir",
    "planer",
    "plaque",
    "plastron",
    "plateau",
    "pleurer",
    "plexus",
    "pliage",
    "plomb",
    "plonger",
    "pluie",
    "plumage",
    "pochette",
    "poesie",
    "poete",
    "pointe",
    "poirier",
    "poisson",
    "poivre",
    "polaire",
    "policier",
    "pollen",
    "polygone",
    "pommade",
    "pompier",
    "ponctuel",
    "ponderer",
    "poney",
    "portique",
    "position",
    "posseder",
    "posture",
    "potager",
    "poteau",
    "potion",
    "pouce",
    "poulain",
    "poumon",
    "pourpre",
    "poussin",
    "pouvoir",
    "prairie",
    "pratique",
    "precieux",
    "predire",
    "prefixe",
    "prelude",
    "prenom",
    "presence",
    "pretexte",
    "prevoir",
    "primitif",
    "prince",
    "prison",
    "priver",
    "probleme",
    "proceder",
    "prodige",
    "profond",
    "progres",
    "proie",
    "projeter",
    "prologue",
    "promener",
    "propre",
    "prospere",
    "proteger",
    "prouesse",
    "proverbe",
    "prudence",
    "pruneau",
    "psychose",
    "public",
    "puceron",
    "puiser",
    "pulpe",
    "pulsar",
    "punaise",
    "punitif",
    "pupitre",
    "purifier",
    "puzzle",
    "pyramide",
    "quasar",
    "querelle",
    "question",
    "quietude",
    "quitter",
    "quotient",
    "racine",
    "raconter",
    "radieux",
    "ragondin",
    "raideur",
    "raisin",
    "ralentir",
    "rallonge",
    "ramasser",
    "rapide",
    "rasage",
    "ratisser",
    "ravager",
    "ravin",
    "rayonner",
    "reactif",
    "reagir",
    "realiser",
    "reanimer",
    "recevoir",
    "reciter",
    "reclamer",
    "recolter",
    "recruter",
    "reculer",
    "recycler",
    "rediger",
    "redouter",
    "refaire",
    "reflexe",
    "reformer",
    "refrain",
    "refuge",
    "regalien",
    "region",
    "reglage",
    "regulier",
    "reiterer",
    "rejeter",
    "rejouer",
    "relatif",
    "relever",
    "relief",
    "remarque",
    "remede",
    "remise",
    "remonter",
    "remplir",
    "remuer",
    "renard",
    "renfort",
    "renifler",
    "renoncer",
    "rentrer",
    "renvoi",
    "replier",
    "reporter",
    "reprise",
    "reptile",
    "requin",
    "reserve",
    "resineux",
    "resoudre",
    "respect",
    "rester",
    "resultat",
    "retablir",
    "retenir",
    "reticule",
    "retomber",
    "retracer",
    "reunion",
    "reussir",
    "revanche",
    "revivre",
    "revolte",
    "revulsif",
    "richesse",
    "rideau",
    "rieur",
    "rigide",
    "rigoler",
    "rincer",
    "riposter",
    "risible",
    "risque",
    "rituel",
    "rival",
    "riviere",
    "rocheux",
    "romance",
    "rompre",
    "ronce",
    "rondin",
    "roseau",
    "rosier",
    "rotatif",
    "rotor",
    "rotule",
    "rouge",
    "rouille",
    "rouleau",
    "routine",
    "royaume",
    "ruban",
    "rubis",
    "ruche",
    "ruelle",
    "rugueux",
    "ruiner",
    "ruisseau",
    "ruser",
    "rustique",
    "rythme",
    "sabler",
    "saboter",
    "sabre",
    "sacoche",
    "safari",
    "sagesse",
    "saisir",
    "salade",
    "salive",
    "salon",
    "saluer",
    "samedi",
    "sanction",
    "sanglier",
    "sarcasme",
    "sardine",
    "saturer",
    "saugrenu",
    "saumon",
    "sauter",
    "sauvage",
    "savant",
    "savonner",
    "scalpel",
    "scandale",
    "scelerat",
    "scenario",
    "sceptre",
    "schema",
    "science",
    "scinder",
    "score",
    "scrutin",
    "sculpter",
    "seance",
    "secable",
    "secher",
    "secouer",
    "secreter",
    "sedatif",
    "seduire",
    "seigneur",
    "sejour",
    "selectif",
    "semaine",
    "sembler",
    "semence",
    "seminal",
    "senateur",
    "sensible",
    "sentence",
    "separer",
    "sequence",
    "serein",
    "sergent",
    "serieux",
    "serrure",
    "serum",
    "service",
    "sesame",
    "sevir",
    "sevrage",
    "sextuple",
    "sideral",
    "siecle",
    "sieger",
    "siffler",
    "sigle",
    "signal",
    "silence",
    "silicium",
    "simple",
    "sincere",
    "sinistre",
    "siphon",
    "sirop",
    "sismique",
    "situer",
    "skier",
    "social",
    "socle",
    "sodium",
    "soigneux",
    "soldat",
    "soleil",
    "solitude",
    "soluble",
    "sombre",
    "sommeil",
    "somnoler",
    "sonde",
    "songeur",
    "sonnette",
    "sonore",
    "sorcier",
    "sortir",
    "sosie",
    "sottise",
    "soucieux",
    "soudure",
    "souffle",
    "soulever",
    "soupape",
    "source",
    "soutirer",
    "souvenir",
    "spacieux",
    "spatial",
    "special",
    "sphere",
    "spiral",
    "stable",
    "station",
    "sternum",
    "stimulus",
    "stipuler",
    "strict",
    "studieux",
    "stupeur",
    "styliste",
    "sublime",
    "substrat",
    "subtil",
    "subvenir",
    "succes",
    "sucre",
    "suffixe",
    "suggerer",
    "suiveur",
    "sulfate",
    "superbe",
    "supplier",
    "surface",
    "suricate",
    "surmener",
    "surprise",
    "sursaut",
    "survie",
    "suspect",
    "syllabe",
    "symbole",
    "symetrie",
    "synapse",
    "syntaxe",
    "systeme",
    "tabac",
    "tablier",
    "tactile",
    "tailler",
    "talent",
    "talisman",
    "talonner",
    "tambour",
    "tamiser",
    "tangible",
    "tapis",
    "taquiner",
    "tarder",
    "tarif",
    "tartine",
    "tasse",
    "tatami",
    "tatouage",
    "taupe",
    "taureau",
    "taxer",
    "temoin",
    "temporel",
    "tenaille",
    "tendre",
    "teneur",
    "tenir",
    "tension",
    "terminer",
    "terne",
    "terrible",
    "tetine",
    "texte",
    "theme",
    "theorie",
    "therapie",
    "thorax",
    "tibia",
    "tiede",
    "timide",
    "tirelire",
    "tiroir",
    "tissu",
    "titane",
    "titre",
    "tituber",
    "toboggan",
    "tolerant",
    "tomate",
    "tonique",
    "tonneau",
    "toponyme",
    "torche",
    "tordre",
    "tornade",
    "torpille",
    "torrent",
    "torse",
    "tortue",
    "totem",
    "toucher",
    "tournage",
    "tousser",
    "toxine",
    "traction",
    "trafic",
    "tragique",
    "trahir",
    "train",
    "trancher",
    "travail",
    "trefle",
    "tremper",
    "tresor",
    "treuil",
    "triage",
    "tribunal",
    "tricoter",
    "trilogie",
    "triomphe",
    "tripler",
    "triturer",
    "trivial",
    "trombone",
    "tronc",
    "tropical",
    "troupeau",
    "tuile",
    "tulipe",
    "tumulte",
    "tunnel",
    "turbine",
    "tuteur",
    "tutoyer",
    "tuyau",
    "tympan",
    "typhon",
    "typique",
    "tyran",
    "ubuesque",
    "ultime",
    "ultrason",
    "unanime",
    "unifier",
    "union",
    "unique",
    "unitaire",
    "univers",
    "uranium",
    "urbain",
    "urticant",
    "usage",
    "usine",
    "usuel",
    "usure",
    "utile",
    "utopie",
    "vacarme",
    "vaccin",
    "vagabond",
    "vague",
    "vaillant",
    "vaincre",
    "vaisseau",
    "valable",
    "valise",
    "vallon",
    "valve",
    "vampire",
    "vanille",
    "vapeur",
    "varier",
    "vaseux",
    "vassal",
    "vaste",
    "vecteur",
    "vedette",
    "vegetal",
    "vehicule",
    "veinard",
    "veloce",
    "vendredi",
    "venerer",
    "venger",
    "venimeux",
    "ventouse",
    "verdure",
    "verin",
    "vernir",
    "verrou",
    "verser",
    "vertu",
    "veston",
    "veteran",
    "vetuste",
    "vexant",
    "vexer",
    "viaduc",
    "viande",
    "victoire",
    "vidange",
    "video",
    "vignette",
    "vigueur",
    "vilain",
    "village",
    "vinaigre",
    "violon",
    "vipere",
    "virement",
    "virtuose",
    "virus",
    "visage",
    "viseur",
    "vision",
    "visqueux",
    "visuel",
    "vital",
    "vitesse",
    "viticole",
    "vitrine",
    "vivace",
    "vivipare",
    "vocation",
    "voguer",
    "voile",
    "voisin",
    "voiture",
    "volaille",
    "volcan",
    "voltiger",
    "volume",
    "vorace",
    "vortex",
    "voter",
    "vouloir",
    "voyage",
    "voyelle",
    "wagon",
    "xenon",
    "yacht",
    "zebre",
    "zenith",
    "zeste",
    "zoologie"
  ]), cu;
}
var uu, p4;
function ax() {
  return p4 || (p4 = 1, uu = [
    "abaco",
    "abbaglio",
    "abbinato",
    "abete",
    "abisso",
    "abolire",
    "abrasivo",
    "abrogato",
    "accadere",
    "accenno",
    "accusato",
    "acetone",
    "achille",
    "acido",
    "acqua",
    "acre",
    "acrilico",
    "acrobata",
    "acuto",
    "adagio",
    "addebito",
    "addome",
    "adeguato",
    "aderire",
    "adipe",
    "adottare",
    "adulare",
    "affabile",
    "affetto",
    "affisso",
    "affranto",
    "aforisma",
    "afoso",
    "africano",
    "agave",
    "agente",
    "agevole",
    "aggancio",
    "agire",
    "agitare",
    "agonismo",
    "agricolo",
    "agrumeto",
    "aguzzo",
    "alabarda",
    "alato",
    "albatro",
    "alberato",
    "albo",
    "albume",
    "alce",
    "alcolico",
    "alettone",
    "alfa",
    "algebra",
    "aliante",
    "alibi",
    "alimento",
    "allagato",
    "allegro",
    "allievo",
    "allodola",
    "allusivo",
    "almeno",
    "alogeno",
    "alpaca",
    "alpestre",
    "altalena",
    "alterno",
    "alticcio",
    "altrove",
    "alunno",
    "alveolo",
    "alzare",
    "amalgama",
    "amanita",
    "amarena",
    "ambito",
    "ambrato",
    "ameba",
    "america",
    "ametista",
    "amico",
    "ammasso",
    "ammenda",
    "ammirare",
    "ammonito",
    "amore",
    "ampio",
    "ampliare",
    "amuleto",
    "anacardo",
    "anagrafe",
    "analista",
    "anarchia",
    "anatra",
    "anca",
    "ancella",
    "ancora",
    "andare",
    "andrea",
    "anello",
    "angelo",
    "angolare",
    "angusto",
    "anima",
    "annegare",
    "annidato",
    "anno",
    "annuncio",
    "anonimo",
    "anticipo",
    "anzi",
    "apatico",
    "apertura",
    "apode",
    "apparire",
    "appetito",
    "appoggio",
    "approdo",
    "appunto",
    "aprile",
    "arabica",
    "arachide",
    "aragosta",
    "araldica",
    "arancio",
    "aratura",
    "arazzo",
    "arbitro",
    "archivio",
    "ardito",
    "arenile",
    "argento",
    "argine",
    "arguto",
    "aria",
    "armonia",
    "arnese",
    "arredato",
    "arringa",
    "arrosto",
    "arsenico",
    "arso",
    "artefice",
    "arzillo",
    "asciutto",
    "ascolto",
    "asepsi",
    "asettico",
    "asfalto",
    "asino",
    "asola",
    "aspirato",
    "aspro",
    "assaggio",
    "asse",
    "assoluto",
    "assurdo",
    "asta",
    "astenuto",
    "astice",
    "astratto",
    "atavico",
    "ateismo",
    "atomico",
    "atono",
    "attesa",
    "attivare",
    "attorno",
    "attrito",
    "attuale",
    "ausilio",
    "austria",
    "autista",
    "autonomo",
    "autunno",
    "avanzato",
    "avere",
    "avvenire",
    "avviso",
    "avvolgere",
    "azione",
    "azoto",
    "azzimo",
    "azzurro",
    "babele",
    "baccano",
    "bacino",
    "baco",
    "badessa",
    "badilata",
    "bagnato",
    "baita",
    "balcone",
    "baldo",
    "balena",
    "ballata",
    "balzano",
    "bambino",
    "bandire",
    "baraonda",
    "barbaro",
    "barca",
    "baritono",
    "barlume",
    "barocco",
    "basilico",
    "basso",
    "batosta",
    "battuto",
    "baule",
    "bava",
    "bavosa",
    "becco",
    "beffa",
    "belgio",
    "belva",
    "benda",
    "benevole",
    "benigno",
    "benzina",
    "bere",
    "berlina",
    "beta",
    "bibita",
    "bici",
    "bidone",
    "bifido",
    "biga",
    "bilancia",
    "bimbo",
    "binocolo",
    "biologo",
    "bipede",
    "bipolare",
    "birbante",
    "birra",
    "biscotto",
    "bisesto",
    "bisnonno",
    "bisonte",
    "bisturi",
    "bizzarro",
    "blando",
    "blatta",
    "bollito",
    "bonifico",
    "bordo",
    "bosco",
    "botanico",
    "bottino",
    "bozzolo",
    "braccio",
    "bradipo",
    "brama",
    "branca",
    "bravura",
    "bretella",
    "brevetto",
    "brezza",
    "briglia",
    "brillante",
    "brindare",
    "broccolo",
    "brodo",
    "bronzina",
    "brullo",
    "bruno",
    "bubbone",
    "buca",
    "budino",
    "buffone",
    "buio",
    "bulbo",
    "buono",
    "burlone",
    "burrasca",
    "bussola",
    "busta",
    "cadetto",
    "caduco",
    "calamaro",
    "calcolo",
    "calesse",
    "calibro",
    "calmo",
    "caloria",
    "cambusa",
    "camerata",
    "camicia",
    "cammino",
    "camola",
    "campale",
    "canapa",
    "candela",
    "cane",
    "canino",
    "canotto",
    "cantina",
    "capace",
    "capello",
    "capitolo",
    "capogiro",
    "cappero",
    "capra",
    "capsula",
    "carapace",
    "carcassa",
    "cardo",
    "carisma",
    "carovana",
    "carretto",
    "cartolina",
    "casaccio",
    "cascata",
    "caserma",
    "caso",
    "cassone",
    "castello",
    "casuale",
    "catasta",
    "catena",
    "catrame",
    "cauto",
    "cavillo",
    "cedibile",
    "cedrata",
    "cefalo",
    "celebre",
    "cellulare",
    "cena",
    "cenone",
    "centesimo",
    "ceramica",
    "cercare",
    "certo",
    "cerume",
    "cervello",
    "cesoia",
    "cespo",
    "ceto",
    "chela",
    "chiaro",
    "chicca",
    "chiedere",
    "chimera",
    "china",
    "chirurgo",
    "chitarra",
    "ciao",
    "ciclismo",
    "cifrare",
    "cigno",
    "cilindro",
    "ciottolo",
    "circa",
    "cirrosi",
    "citrico",
    "cittadino",
    "ciuffo",
    "civetta",
    "civile",
    "classico",
    "clinica",
    "cloro",
    "cocco",
    "codardo",
    "codice",
    "coerente",
    "cognome",
    "collare",
    "colmato",
    "colore",
    "colposo",
    "coltivato",
    "colza",
    "coma",
    "cometa",
    "commando",
    "comodo",
    "computer",
    "comune",
    "conciso",
    "condurre",
    "conferma",
    "congelare",
    "coniuge",
    "connesso",
    "conoscere",
    "consumo",
    "continuo",
    "convegno",
    "coperto",
    "copione",
    "coppia",
    "copricapo",
    "corazza",
    "cordata",
    "coricato",
    "cornice",
    "corolla",
    "corpo",
    "corredo",
    "corsia",
    "cortese",
    "cosmico",
    "costante",
    "cottura",
    "covato",
    "cratere",
    "cravatta",
    "creato",
    "credere",
    "cremoso",
    "crescita",
    "creta",
    "criceto",
    "crinale",
    "crisi",
    "critico",
    "croce",
    "cronaca",
    "crostata",
    "cruciale",
    "crusca",
    "cucire",
    "cuculo",
    "cugino",
    "cullato",
    "cupola",
    "curatore",
    "cursore",
    "curvo",
    "cuscino",
    "custode",
    "dado",
    "daino",
    "dalmata",
    "damerino",
    "daniela",
    "dannoso",
    "danzare",
    "datato",
    "davanti",
    "davvero",
    "debutto",
    "decennio",
    "deciso",
    "declino",
    "decollo",
    "decreto",
    "dedicato",
    "definito",
    "deforme",
    "degno",
    "delegare",
    "delfino",
    "delirio",
    "delta",
    "demenza",
    "denotato",
    "dentro",
    "deposito",
    "derapata",
    "derivare",
    "deroga",
    "descritto",
    "deserto",
    "desiderio",
    "desumere",
    "detersivo",
    "devoto",
    "diametro",
    "dicembre",
    "diedro",
    "difeso",
    "diffuso",
    "digerire",
    "digitale",
    "diluvio",
    "dinamico",
    "dinnanzi",
    "dipinto",
    "diploma",
    "dipolo",
    "diradare",
    "dire",
    "dirotto",
    "dirupo",
    "disagio",
    "discreto",
    "disfare",
    "disgelo",
    "disposto",
    "distanza",
    "disumano",
    "dito",
    "divano",
    "divelto",
    "dividere",
    "divorato",
    "doblone",
    "docente",
    "doganale",
    "dogma",
    "dolce",
    "domato",
    "domenica",
    "dominare",
    "dondolo",
    "dono",
    "dormire",
    "dote",
    "dottore",
    "dovuto",
    "dozzina",
    "drago",
    "druido",
    "dubbio",
    "dubitare",
    "ducale",
    "duna",
    "duomo",
    "duplice",
    "duraturo",
    "ebano",
    "eccesso",
    "ecco",
    "eclissi",
    "economia",
    "edera",
    "edicola",
    "edile",
    "editoria",
    "educare",
    "egemonia",
    "egli",
    "egoismo",
    "egregio",
    "elaborato",
    "elargire",
    "elegante",
    "elencato",
    "eletto",
    "elevare",
    "elfico",
    "elica",
    "elmo",
    "elsa",
    "eluso",
    "emanato",
    "emblema",
    "emesso",
    "emiro",
    "emotivo",
    "emozione",
    "empirico",
    "emulo",
    "endemico",
    "enduro",
    "energia",
    "enfasi",
    "enoteca",
    "entrare",
    "enzima",
    "epatite",
    "epilogo",
    "episodio",
    "epocale",
    "eppure",
    "equatore",
    "erario",
    "erba",
    "erboso",
    "erede",
    "eremita",
    "erigere",
    "ermetico",
    "eroe",
    "erosivo",
    "errante",
    "esagono",
    "esame",
    "esanime",
    "esaudire",
    "esca",
    "esempio",
    "esercito",
    "esibito",
    "esigente",
    "esistere",
    "esito",
    "esofago",
    "esortato",
    "esoso",
    "espanso",
    "espresso",
    "essenza",
    "esso",
    "esteso",
    "estimare",
    "estonia",
    "estroso",
    "esultare",
    "etilico",
    "etnico",
    "etrusco",
    "etto",
    "euclideo",
    "europa",
    "evaso",
    "evidenza",
    "evitato",
    "evoluto",
    "evviva",
    "fabbrica",
    "faccenda",
    "fachiro",
    "falco",
    "famiglia",
    "fanale",
    "fanfara",
    "fango",
    "fantasma",
    "fare",
    "farfalla",
    "farinoso",
    "farmaco",
    "fascia",
    "fastoso",
    "fasullo",
    "faticare",
    "fato",
    "favoloso",
    "febbre",
    "fecola",
    "fede",
    "fegato",
    "felpa",
    "feltro",
    "femmina",
    "fendere",
    "fenomeno",
    "fermento",
    "ferro",
    "fertile",
    "fessura",
    "festivo",
    "fetta",
    "feudo",
    "fiaba",
    "fiducia",
    "fifa",
    "figurato",
    "filo",
    "finanza",
    "finestra",
    "finire",
    "fiore",
    "fiscale",
    "fisico",
    "fiume",
    "flacone",
    "flamenco",
    "flebo",
    "flemma",
    "florido",
    "fluente",
    "fluoro",
    "fobico",
    "focaccia",
    "focoso",
    "foderato",
    "foglio",
    "folata",
    "folclore",
    "folgore",
    "fondente",
    "fonetico",
    "fonia",
    "fontana",
    "forbito",
    "forchetta",
    "foresta",
    "formica",
    "fornaio",
    "foro",
    "fortezza",
    "forzare",
    "fosfato",
    "fosso",
    "fracasso",
    "frana",
    "frassino",
    "fratello",
    "freccetta",
    "frenata",
    "fresco",
    "frigo",
    "frollino",
    "fronde",
    "frugale",
    "frutta",
    "fucilata",
    "fucsia",
    "fuggente",
    "fulmine",
    "fulvo",
    "fumante",
    "fumetto",
    "fumoso",
    "fune",
    "funzione",
    "fuoco",
    "furbo",
    "furgone",
    "furore",
    "fuso",
    "futile",
    "gabbiano",
    "gaffe",
    "galateo",
    "gallina",
    "galoppo",
    "gambero",
    "gamma",
    "garanzia",
    "garbo",
    "garofano",
    "garzone",
    "gasdotto",
    "gasolio",
    "gastrico",
    "gatto",
    "gaudio",
    "gazebo",
    "gazzella",
    "geco",
    "gelatina",
    "gelso",
    "gemello",
    "gemmato",
    "gene",
    "genitore",
    "gennaio",
    "genotipo",
    "gergo",
    "ghepardo",
    "ghiaccio",
    "ghisa",
    "giallo",
    "gilda",
    "ginepro",
    "giocare",
    "gioiello",
    "giorno",
    "giove",
    "girato",
    "girone",
    "gittata",
    "giudizio",
    "giurato",
    "giusto",
    "globulo",
    "glutine",
    "gnomo",
    "gobba",
    "golf",
    "gomito",
    "gommone",
    "gonfio",
    "gonna",
    "governo",
    "gracile",
    "grado",
    "grafico",
    "grammo",
    "grande",
    "grattare",
    "gravoso",
    "grazia",
    "greca",
    "gregge",
    "grifone",
    "grigio",
    "grinza",
    "grotta",
    "gruppo",
    "guadagno",
    "guaio",
    "guanto",
    "guardare",
    "gufo",
    "guidare",
    "ibernato",
    "icona",
    "identico",
    "idillio",
    "idolo",
    "idra",
    "idrico",
    "idrogeno",
    "igiene",
    "ignaro",
    "ignorato",
    "ilare",
    "illeso",
    "illogico",
    "illudere",
    "imballo",
    "imbevuto",
    "imbocco",
    "imbuto",
    "immane",
    "immerso",
    "immolato",
    "impacco",
    "impeto",
    "impiego",
    "importo",
    "impronta",
    "inalare",
    "inarcare",
    "inattivo",
    "incanto",
    "incendio",
    "inchino",
    "incisivo",
    "incluso",
    "incontro",
    "incrocio",
    "incubo",
    "indagine",
    "india",
    "indole",
    "inedito",
    "infatti",
    "infilare",
    "inflitto",
    "ingaggio",
    "ingegno",
    "inglese",
    "ingordo",
    "ingrosso",
    "innesco",
    "inodore",
    "inoltrare",
    "inondato",
    "insano",
    "insetto",
    "insieme",
    "insonnia",
    "insulina",
    "intasato",
    "intero",
    "intonaco",
    "intuito",
    "inumidire",
    "invalido",
    "invece",
    "invito",
    "iperbole",
    "ipnotico",
    "ipotesi",
    "ippica",
    "iride",
    "irlanda",
    "ironico",
    "irrigato",
    "irrorare",
    "isolato",
    "isotopo",
    "isterico",
    "istituto",
    "istrice",
    "italia",
    "iterare",
    "labbro",
    "labirinto",
    "lacca",
    "lacerato",
    "lacrima",
    "lacuna",
    "laddove",
    "lago",
    "lampo",
    "lancetta",
    "lanterna",
    "lardoso",
    "larga",
    "laringe",
    "lastra",
    "latenza",
    "latino",
    "lattuga",
    "lavagna",
    "lavoro",
    "legale",
    "leggero",
    "lembo",
    "lentezza",
    "lenza",
    "leone",
    "lepre",
    "lesivo",
    "lessato",
    "lesto",
    "letterale",
    "leva",
    "levigato",
    "libero",
    "lido",
    "lievito",
    "lilla",
    "limatura",
    "limitare",
    "limpido",
    "lineare",
    "lingua",
    "liquido",
    "lira",
    "lirica",
    "lisca",
    "lite",
    "litigio",
    "livrea",
    "locanda",
    "lode",
    "logica",
    "lombare",
    "londra",
    "longevo",
    "loquace",
    "lorenzo",
    "loto",
    "lotteria",
    "luce",
    "lucidato",
    "lumaca",
    "luminoso",
    "lungo",
    "lupo",
    "luppolo",
    "lusinga",
    "lusso",
    "lutto",
    "macabro",
    "macchina",
    "macero",
    "macinato",
    "madama",
    "magico",
    "maglia",
    "magnete",
    "magro",
    "maiolica",
    "malafede",
    "malgrado",
    "malinteso",
    "malsano",
    "malto",
    "malumore",
    "mana",
    "mancia",
    "mandorla",
    "mangiare",
    "manifesto",
    "mannaro",
    "manovra",
    "mansarda",
    "mantide",
    "manubrio",
    "mappa",
    "maratona",
    "marcire",
    "maretta",
    "marmo",
    "marsupio",
    "maschera",
    "massaia",
    "mastino",
    "materasso",
    "matricola",
    "mattone",
    "maturo",
    "mazurca",
    "meandro",
    "meccanico",
    "mecenate",
    "medesimo",
    "meditare",
    "mega",
    "melassa",
    "melis",
    "melodia",
    "meninge",
    "meno",
    "mensola",
    "mercurio",
    "merenda",
    "merlo",
    "meschino",
    "mese",
    "messere",
    "mestolo",
    "metallo",
    "metodo",
    "mettere",
    "miagolare",
    "mica",
    "micelio",
    "michele",
    "microbo",
    "midollo",
    "miele",
    "migliore",
    "milano",
    "milite",
    "mimosa",
    "minerale",
    "mini",
    "minore",
    "mirino",
    "mirtillo",
    "miscela",
    "missiva",
    "misto",
    "misurare",
    "mitezza",
    "mitigare",
    "mitra",
    "mittente",
    "mnemonico",
    "modello",
    "modifica",
    "modulo",
    "mogano",
    "mogio",
    "mole",
    "molosso",
    "monastero",
    "monco",
    "mondina",
    "monetario",
    "monile",
    "monotono",
    "monsone",
    "montato",
    "monviso",
    "mora",
    "mordere",
    "morsicato",
    "mostro",
    "motivato",
    "motosega",
    "motto",
    "movenza",
    "movimento",
    "mozzo",
    "mucca",
    "mucosa",
    "muffa",
    "mughetto",
    "mugnaio",
    "mulatto",
    "mulinello",
    "multiplo",
    "mummia",
    "munto",
    "muovere",
    "murale",
    "musa",
    "muscolo",
    "musica",
    "mutevole",
    "muto",
    "nababbo",
    "nafta",
    "nanometro",
    "narciso",
    "narice",
    "narrato",
    "nascere",
    "nastrare",
    "naturale",
    "nautica",
    "naviglio",
    "nebulosa",
    "necrosi",
    "negativo",
    "negozio",
    "nemmeno",
    "neofita",
    "neretto",
    "nervo",
    "nessuno",
    "nettuno",
    "neutrale",
    "neve",
    "nevrotico",
    "nicchia",
    "ninfa",
    "nitido",
    "nobile",
    "nocivo",
    "nodo",
    "nome",
    "nomina",
    "nordico",
    "normale",
    "norvegese",
    "nostrano",
    "notare",
    "notizia",
    "notturno",
    "novella",
    "nucleo",
    "nulla",
    "numero",
    "nuovo",
    "nutrire",
    "nuvola",
    "nuziale",
    "oasi",
    "obbedire",
    "obbligo",
    "obelisco",
    "oblio",
    "obolo",
    "obsoleto",
    "occasione",
    "occhio",
    "occidente",
    "occorrere",
    "occultare",
    "ocra",
    "oculato",
    "odierno",
    "odorare",
    "offerta",
    "offrire",
    "offuscato",
    "oggetto",
    "oggi",
    "ognuno",
    "olandese",
    "olfatto",
    "oliato",
    "oliva",
    "ologramma",
    "oltre",
    "omaggio",
    "ombelico",
    "ombra",
    "omega",
    "omissione",
    "ondoso",
    "onere",
    "onice",
    "onnivoro",
    "onorevole",
    "onta",
    "operato",
    "opinione",
    "opposto",
    "oracolo",
    "orafo",
    "ordine",
    "orecchino",
    "orefice",
    "orfano",
    "organico",
    "origine",
    "orizzonte",
    "orma",
    "ormeggio",
    "ornativo",
    "orologio",
    "orrendo",
    "orribile",
    "ortensia",
    "ortica",
    "orzata",
    "orzo",
    "osare",
    "oscurare",
    "osmosi",
    "ospedale",
    "ospite",
    "ossa",
    "ossidare",
    "ostacolo",
    "oste",
    "otite",
    "otre",
    "ottagono",
    "ottimo",
    "ottobre",
    "ovale",
    "ovest",
    "ovino",
    "oviparo",
    "ovocito",
    "ovunque",
    "ovviare",
    "ozio",
    "pacchetto",
    "pace",
    "pacifico",
    "padella",
    "padrone",
    "paese",
    "paga",
    "pagina",
    "palazzina",
    "palesare",
    "pallido",
    "palo",
    "palude",
    "pandoro",
    "pannello",
    "paolo",
    "paonazzo",
    "paprica",
    "parabola",
    "parcella",
    "parere",
    "pargolo",
    "pari",
    "parlato",
    "parola",
    "partire",
    "parvenza",
    "parziale",
    "passivo",
    "pasticca",
    "patacca",
    "patologia",
    "pattume",
    "pavone",
    "peccato",
    "pedalare",
    "pedonale",
    "peggio",
    "peloso",
    "penare",
    "pendice",
    "penisola",
    "pennuto",
    "penombra",
    "pensare",
    "pentola",
    "pepe",
    "pepita",
    "perbene",
    "percorso",
    "perdonato",
    "perforare",
    "pergamena",
    "periodo",
    "permesso",
    "perno",
    "perplesso",
    "persuaso",
    "pertugio",
    "pervaso",
    "pesatore",
    "pesista",
    "peso",
    "pestifero",
    "petalo",
    "pettine",
    "petulante",
    "pezzo",
    "piacere",
    "pianta",
    "piattino",
    "piccino",
    "picozza",
    "piega",
    "pietra",
    "piffero",
    "pigiama",
    "pigolio",
    "pigro",
    "pila",
    "pilifero",
    "pillola",
    "pilota",
    "pimpante",
    "pineta",
    "pinna",
    "pinolo",
    "pioggia",
    "piombo",
    "piramide",
    "piretico",
    "pirite",
    "pirolisi",
    "pitone",
    "pizzico",
    "placebo",
    "planare",
    "plasma",
    "platano",
    "plenario",
    "pochezza",
    "poderoso",
    "podismo",
    "poesia",
    "poggiare",
    "polenta",
    "poligono",
    "pollice",
    "polmonite",
    "polpetta",
    "polso",
    "poltrona",
    "polvere",
    "pomice",
    "pomodoro",
    "ponte",
    "popoloso",
    "porfido",
    "poroso",
    "porpora",
    "porre",
    "portata",
    "posa",
    "positivo",
    "possesso",
    "postulato",
    "potassio",
    "potere",
    "pranzo",
    "prassi",
    "pratica",
    "precluso",
    "predica",
    "prefisso",
    "pregiato",
    "prelievo",
    "premere",
    "prenotare",
    "preparato",
    "presenza",
    "pretesto",
    "prevalso",
    "prima",
    "principe",
    "privato",
    "problema",
    "procura",
    "produrre",
    "profumo",
    "progetto",
    "prolunga",
    "promessa",
    "pronome",
    "proposta",
    "proroga",
    "proteso",
    "prova",
    "prudente",
    "prugna",
    "prurito",
    "psiche",
    "pubblico",
    "pudica",
    "pugilato",
    "pugno",
    "pulce",
    "pulito",
    "pulsante",
    "puntare",
    "pupazzo",
    "pupilla",
    "puro",
    "quadro",
    "qualcosa",
    "quasi",
    "querela",
    "quota",
    "raccolto",
    "raddoppio",
    "radicale",
    "radunato",
    "raffica",
    "ragazzo",
    "ragione",
    "ragno",
    "ramarro",
    "ramingo",
    "ramo",
    "randagio",
    "rantolare",
    "rapato",
    "rapina",
    "rappreso",
    "rasatura",
    "raschiato",
    "rasente",
    "rassegna",
    "rastrello",
    "rata",
    "ravveduto",
    "reale",
    "recepire",
    "recinto",
    "recluta",
    "recondito",
    "recupero",
    "reddito",
    "redimere",
    "regalato",
    "registro",
    "regola",
    "regresso",
    "relazione",
    "remare",
    "remoto",
    "renna",
    "replica",
    "reprimere",
    "reputare",
    "resa",
    "residente",
    "responso",
    "restauro",
    "rete",
    "retina",
    "retorica",
    "rettifica",
    "revocato",
    "riassunto",
    "ribadire",
    "ribelle",
    "ribrezzo",
    "ricarica",
    "ricco",
    "ricevere",
    "riciclato",
    "ricordo",
    "ricreduto",
    "ridicolo",
    "ridurre",
    "rifasare",
    "riflesso",
    "riforma",
    "rifugio",
    "rigare",
    "rigettato",
    "righello",
    "rilassato",
    "rilevato",
    "rimanere",
    "rimbalzo",
    "rimedio",
    "rimorchio",
    "rinascita",
    "rincaro",
    "rinforzo",
    "rinnovo",
    "rinomato",
    "rinsavito",
    "rintocco",
    "rinuncia",
    "rinvenire",
    "riparato",
    "ripetuto",
    "ripieno",
    "riportare",
    "ripresa",
    "ripulire",
    "risata",
    "rischio",
    "riserva",
    "risibile",
    "riso",
    "rispetto",
    "ristoro",
    "risultato",
    "risvolto",
    "ritardo",
    "ritegno",
    "ritmico",
    "ritrovo",
    "riunione",
    "riva",
    "riverso",
    "rivincita",
    "rivolto",
    "rizoma",
    "roba",
    "robotico",
    "robusto",
    "roccia",
    "roco",
    "rodaggio",
    "rodere",
    "roditore",
    "rogito",
    "rollio",
    "romantico",
    "rompere",
    "ronzio",
    "rosolare",
    "rospo",
    "rotante",
    "rotondo",
    "rotula",
    "rovescio",
    "rubizzo",
    "rubrica",
    "ruga",
    "rullino",
    "rumine",
    "rumoroso",
    "ruolo",
    "rupe",
    "russare",
    "rustico",
    "sabato",
    "sabbiare",
    "sabotato",
    "sagoma",
    "salasso",
    "saldatura",
    "salgemma",
    "salivare",
    "salmone",
    "salone",
    "saltare",
    "saluto",
    "salvo",
    "sapere",
    "sapido",
    "saporito",
    "saraceno",
    "sarcasmo",
    "sarto",
    "sassoso",
    "satellite",
    "satira",
    "satollo",
    "saturno",
    "savana",
    "savio",
    "saziato",
    "sbadiglio",
    "sbalzo",
    "sbancato",
    "sbarra",
    "sbattere",
    "sbavare",
    "sbendare",
    "sbirciare",
    "sbloccato",
    "sbocciato",
    "sbrinare",
    "sbruffone",
    "sbuffare",
    "scabroso",
    "scadenza",
    "scala",
    "scambiare",
    "scandalo",
    "scapola",
    "scarso",
    "scatenare",
    "scavato",
    "scelto",
    "scenico",
    "scettro",
    "scheda",
    "schiena",
    "sciarpa",
    "scienza",
    "scindere",
    "scippo",
    "sciroppo",
    "scivolo",
    "sclerare",
    "scodella",
    "scolpito",
    "scomparto",
    "sconforto",
    "scoprire",
    "scorta",
    "scossone",
    "scozzese",
    "scriba",
    "scrollare",
    "scrutinio",
    "scuderia",
    "scultore",
    "scuola",
    "scuro",
    "scusare",
    "sdebitare",
    "sdoganare",
    "seccatura",
    "secondo",
    "sedano",
    "seggiola",
    "segnalato",
    "segregato",
    "seguito",
    "selciato",
    "selettivo",
    "sella",
    "selvaggio",
    "semaforo",
    "sembrare",
    "seme",
    "seminato",
    "sempre",
    "senso",
    "sentire",
    "sepolto",
    "sequenza",
    "serata",
    "serbato",
    "sereno",
    "serio",
    "serpente",
    "serraglio",
    "servire",
    "sestina",
    "setola",
    "settimana",
    "sfacelo",
    "sfaldare",
    "sfamato",
    "sfarzoso",
    "sfaticato",
    "sfera",
    "sfida",
    "sfilato",
    "sfinge",
    "sfocato",
    "sfoderare",
    "sfogo",
    "sfoltire",
    "sforzato",
    "sfratto",
    "sfruttato",
    "sfuggito",
    "sfumare",
    "sfuso",
    "sgabello",
    "sgarbato",
    "sgonfiare",
    "sgorbio",
    "sgrassato",
    "sguardo",
    "sibilo",
    "siccome",
    "sierra",
    "sigla",
    "signore",
    "silenzio",
    "sillaba",
    "simbolo",
    "simpatico",
    "simulato",
    "sinfonia",
    "singolo",
    "sinistro",
    "sino",
    "sintesi",
    "sinusoide",
    "sipario",
    "sisma",
    "sistole",
    "situato",
    "slitta",
    "slogatura",
    "sloveno",
    "smarrito",
    "smemorato",
    "smentito",
    "smeraldo",
    "smilzo",
    "smontare",
    "smottato",
    "smussato",
    "snellire",
    "snervato",
    "snodo",
    "sobbalzo",
    "sobrio",
    "soccorso",
    "sociale",
    "sodale",
    "soffitto",
    "sogno",
    "soldato",
    "solenne",
    "solido",
    "sollazzo",
    "solo",
    "solubile",
    "solvente",
    "somatico",
    "somma",
    "sonda",
    "sonetto",
    "sonnifero",
    "sopire",
    "soppeso",
    "sopra",
    "sorgere",
    "sorpasso",
    "sorriso",
    "sorso",
    "sorteggio",
    "sorvolato",
    "sospiro",
    "sosta",
    "sottile",
    "spada",
    "spalla",
    "spargere",
    "spatola",
    "spavento",
    "spazzola",
    "specie",
    "spedire",
    "spegnere",
    "spelatura",
    "speranza",
    "spessore",
    "spettrale",
    "spezzato",
    "spia",
    "spigoloso",
    "spillato",
    "spinoso",
    "spirale",
    "splendido",
    "sportivo",
    "sposo",
    "spranga",
    "sprecare",
    "spronato",
    "spruzzo",
    "spuntino",
    "squillo",
    "sradicare",
    "srotolato",
    "stabile",
    "stacco",
    "staffa",
    "stagnare",
    "stampato",
    "stantio",
    "starnuto",
    "stasera",
    "statuto",
    "stelo",
    "steppa",
    "sterzo",
    "stiletto",
    "stima",
    "stirpe",
    "stivale",
    "stizzoso",
    "stonato",
    "storico",
    "strappo",
    "stregato",
    "stridulo",
    "strozzare",
    "strutto",
    "stuccare",
    "stufo",
    "stupendo",
    "subentro",
    "succoso",
    "sudore",
    "suggerito",
    "sugo",
    "sultano",
    "suonare",
    "superbo",
    "supporto",
    "surgelato",
    "surrogato",
    "sussurro",
    "sutura",
    "svagare",
    "svedese",
    "sveglio",
    "svelare",
    "svenuto",
    "svezia",
    "sviluppo",
    "svista",
    "svizzera",
    "svolta",
    "svuotare",
    "tabacco",
    "tabulato",
    "tacciare",
    "taciturno",
    "tale",
    "talismano",
    "tampone",
    "tannino",
    "tara",
    "tardivo",
    "targato",
    "tariffa",
    "tarpare",
    "tartaruga",
    "tasto",
    "tattico",
    "taverna",
    "tavolata",
    "tazza",
    "teca",
    "tecnico",
    "telefono",
    "temerario",
    "tempo",
    "temuto",
    "tendone",
    "tenero",
    "tensione",
    "tentacolo",
    "teorema",
    "terme",
    "terrazzo",
    "terzetto",
    "tesi",
    "tesserato",
    "testato",
    "tetro",
    "tettoia",
    "tifare",
    "tigella",
    "timbro",
    "tinto",
    "tipico",
    "tipografo",
    "tiraggio",
    "tiro",
    "titanio",
    "titolo",
    "titubante",
    "tizio",
    "tizzone",
    "toccare",
    "tollerare",
    "tolto",
    "tombola",
    "tomo",
    "tonfo",
    "tonsilla",
    "topazio",
    "topologia",
    "toppa",
    "torba",
    "tornare",
    "torrone",
    "tortora",
    "toscano",
    "tossire",
    "tostatura",
    "totano",
    "trabocco",
    "trachea",
    "trafila",
    "tragedia",
    "tralcio",
    "tramonto",
    "transito",
    "trapano",
    "trarre",
    "trasloco",
    "trattato",
    "trave",
    "treccia",
    "tremolio",
    "trespolo",
    "tributo",
    "tricheco",
    "trifoglio",
    "trillo",
    "trincea",
    "trio",
    "tristezza",
    "triturato",
    "trivella",
    "tromba",
    "trono",
    "troppo",
    "trottola",
    "trovare",
    "truccato",
    "tubatura",
    "tuffato",
    "tulipano",
    "tumulto",
    "tunisia",
    "turbare",
    "turchino",
    "tuta",
    "tutela",
    "ubicato",
    "uccello",
    "uccisore",
    "udire",
    "uditivo",
    "uffa",
    "ufficio",
    "uguale",
    "ulisse",
    "ultimato",
    "umano",
    "umile",
    "umorismo",
    "uncinetto",
    "ungere",
    "ungherese",
    "unicorno",
    "unificato",
    "unisono",
    "unitario",
    "unte",
    "uovo",
    "upupa",
    "uragano",
    "urgenza",
    "urlo",
    "usanza",
    "usato",
    "uscito",
    "usignolo",
    "usuraio",
    "utensile",
    "utilizzo",
    "utopia",
    "vacante",
    "vaccinato",
    "vagabondo",
    "vagliato",
    "valanga",
    "valgo",
    "valico",
    "valletta",
    "valoroso",
    "valutare",
    "valvola",
    "vampata",
    "vangare",
    "vanitoso",
    "vano",
    "vantaggio",
    "vanvera",
    "vapore",
    "varano",
    "varcato",
    "variante",
    "vasca",
    "vedetta",
    "vedova",
    "veduto",
    "vegetale",
    "veicolo",
    "velcro",
    "velina",
    "velluto",
    "veloce",
    "venato",
    "vendemmia",
    "vento",
    "verace",
    "verbale",
    "vergogna",
    "verifica",
    "vero",
    "verruca",
    "verticale",
    "vescica",
    "vessillo",
    "vestale",
    "veterano",
    "vetrina",
    "vetusto",
    "viandante",
    "vibrante",
    "vicenda",
    "vichingo",
    "vicinanza",
    "vidimare",
    "vigilia",
    "vigneto",
    "vigore",
    "vile",
    "villano",
    "vimini",
    "vincitore",
    "viola",
    "vipera",
    "virgola",
    "virologo",
    "virulento",
    "viscoso",
    "visione",
    "vispo",
    "vissuto",
    "visura",
    "vita",
    "vitello",
    "vittima",
    "vivanda",
    "vivido",
    "viziare",
    "voce",
    "voga",
    "volatile",
    "volere",
    "volpe",
    "voragine",
    "vulcano",
    "zampogna",
    "zanna",
    "zappato",
    "zattera",
    "zavorra",
    "zefiro",
    "zelante",
    "zelo",
    "zenzero",
    "zerbino",
    "zibetto",
    "zinco",
    "zircone",
    "zitto",
    "zolla",
    "zotico",
    "zucchero",
    "zufolo",
    "zulu",
    "zuppa"
  ]), uu;
}
var hu, m4;
function fx() {
  return m4 || (m4 = 1, hu = [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ]), hu;
}
var lu, g4;
function cx() {
  return g4 || (g4 = 1, lu = [
    "abaco",
    "abdomen",
    "abeja",
    "abierto",
    "abogado",
    "abono",
    "aborto",
    "abrazo",
    "abrir",
    "abuelo",
    "abuso",
    "acabar",
    "academia",
    "acceso",
    "accion",
    "aceite",
    "acelga",
    "acento",
    "aceptar",
    "acido",
    "aclarar",
    "acne",
    "acoger",
    "acoso",
    "activo",
    "acto",
    "actriz",
    "actuar",
    "acudir",
    "acuerdo",
    "acusar",
    "adicto",
    "admitir",
    "adoptar",
    "adorno",
    "aduana",
    "adulto",
    "aereo",
    "afectar",
    "aficion",
    "afinar",
    "afirmar",
    "agil",
    "agitar",
    "agonia",
    "agosto",
    "agotar",
    "agregar",
    "agrio",
    "agua",
    "agudo",
    "aguila",
    "aguja",
    "ahogo",
    "ahorro",
    "aire",
    "aislar",
    "ajedrez",
    "ajeno",
    "ajuste",
    "alacran",
    "alambre",
    "alarma",
    "alba",
    "album",
    "alcalde",
    "aldea",
    "alegre",
    "alejar",
    "alerta",
    "aleta",
    "alfiler",
    "alga",
    "algodon",
    "aliado",
    "aliento",
    "alivio",
    "alma",
    "almeja",
    "almibar",
    "altar",
    "alteza",
    "altivo",
    "alto",
    "altura",
    "alumno",
    "alzar",
    "amable",
    "amante",
    "amapola",
    "amargo",
    "amasar",
    "ambar",
    "ambito",
    "ameno",
    "amigo",
    "amistad",
    "amor",
    "amparo",
    "amplio",
    "ancho",
    "anciano",
    "ancla",
    "andar",
    "anden",
    "anemia",
    "angulo",
    "anillo",
    "animo",
    "anis",
    "anotar",
    "antena",
    "antiguo",
    "antojo",
    "anual",
    "anular",
    "anuncio",
    "anadir",
    "anejo",
    "ano",
    "apagar",
    "aparato",
    "apetito",
    "apio",
    "aplicar",
    "apodo",
    "aporte",
    "apoyo",
    "aprender",
    "aprobar",
    "apuesta",
    "apuro",
    "arado",
    "arana",
    "arar",
    "arbitro",
    "arbol",
    "arbusto",
    "archivo",
    "arco",
    "arder",
    "ardilla",
    "arduo",
    "area",
    "arido",
    "aries",
    "armonia",
    "arnes",
    "aroma",
    "arpa",
    "arpon",
    "arreglo",
    "arroz",
    "arruga",
    "arte",
    "artista",
    "asa",
    "asado",
    "asalto",
    "ascenso",
    "asegurar",
    "aseo",
    "asesor",
    "asiento",
    "asilo",
    "asistir",
    "asno",
    "asombro",
    "aspero",
    "astilla",
    "astro",
    "astuto",
    "asumir",
    "asunto",
    "atajo",
    "ataque",
    "atar",
    "atento",
    "ateo",
    "atico",
    "atleta",
    "atomo",
    "atraer",
    "atroz",
    "atun",
    "audaz",
    "audio",
    "auge",
    "aula",
    "aumento",
    "ausente",
    "autor",
    "aval",
    "avance",
    "avaro",
    "ave",
    "avellana",
    "avena",
    "avestruz",
    "avion",
    "aviso",
    "ayer",
    "ayuda",
    "ayuno",
    "azafran",
    "azar",
    "azote",
    "azucar",
    "azufre",
    "azul",
    "baba",
    "babor",
    "bache",
    "bahia",
    "baile",
    "bajar",
    "balanza",
    "balcon",
    "balde",
    "bambu",
    "banco",
    "banda",
    "bano",
    "barba",
    "barco",
    "barniz",
    "barro",
    "bascula",
    "baston",
    "basura",
    "batalla",
    "bateria",
    "batir",
    "batuta",
    "baul",
    "bazar",
    "bebe",
    "bebida",
    "bello",
    "besar",
    "beso",
    "bestia",
    "bicho",
    "bien",
    "bingo",
    "blanco",
    "bloque",
    "blusa",
    "boa",
    "bobina",
    "bobo",
    "boca",
    "bocina",
    "boda",
    "bodega",
    "boina",
    "bola",
    "bolero",
    "bolsa",
    "bomba",
    "bondad",
    "bonito",
    "bono",
    "bonsai",
    "borde",
    "borrar",
    "bosque",
    "bote",
    "botin",
    "boveda",
    "bozal",
    "bravo",
    "brazo",
    "brecha",
    "breve",
    "brillo",
    "brinco",
    "brisa",
    "broca",
    "broma",
    "bronce",
    "brote",
    "bruja",
    "brusco",
    "bruto",
    "buceo",
    "bucle",
    "bueno",
    "buey",
    "bufanda",
    "bufon",
    "buho",
    "buitre",
    "bulto",
    "burbuja",
    "burla",
    "burro",
    "buscar",
    "butaca",
    "buzon",
    "caballo",
    "cabeza",
    "cabina",
    "cabra",
    "cacao",
    "cadaver",
    "cadena",
    "caer",
    "cafe",
    "caida",
    "caiman",
    "caja",
    "cajon",
    "cal",
    "calamar",
    "calcio",
    "caldo",
    "calidad",
    "calle",
    "calma",
    "calor",
    "calvo",
    "cama",
    "cambio",
    "camello",
    "camino",
    "campo",
    "cancer",
    "candil",
    "canela",
    "canguro",
    "canica",
    "canto",
    "cana",
    "canon",
    "caoba",
    "caos",
    "capaz",
    "capitan",
    "capote",
    "captar",
    "capucha",
    "cara",
    "carbon",
    "carcel",
    "careta",
    "carga",
    "carino",
    "carne",
    "carpeta",
    "carro",
    "carta",
    "casa",
    "casco",
    "casero",
    "caspa",
    "castor",
    "catorce",
    "catre",
    "caudal",
    "causa",
    "cazo",
    "cebolla",
    "ceder",
    "cedro",
    "celda",
    "celebre",
    "celoso",
    "celula",
    "cemento",
    "ceniza",
    "centro",
    "cerca",
    "cerdo",
    "cereza",
    "cero",
    "cerrar",
    "certeza",
    "cesped",
    "cetro",
    "chacal",
    "chaleco",
    "champu",
    "chancla",
    "chapa",
    "charla",
    "chico",
    "chiste",
    "chivo",
    "choque",
    "choza",
    "chuleta",
    "chupar",
    "ciclon",
    "ciego",
    "cielo",
    "cien",
    "cierto",
    "cifra",
    "cigarro",
    "cima",
    "cinco",
    "cine",
    "cinta",
    "cipres",
    "circo",
    "ciruela",
    "cisne",
    "cita",
    "ciudad",
    "clamor",
    "clan",
    "claro",
    "clase",
    "clave",
    "cliente",
    "clima",
    "clinica",
    "cobre",
    "coccion",
    "cochino",
    "cocina",
    "coco",
    "codigo",
    "codo",
    "cofre",
    "coger",
    "cohete",
    "cojin",
    "cojo",
    "cola",
    "colcha",
    "colegio",
    "colgar",
    "colina",
    "collar",
    "colmo",
    "columna",
    "combate",
    "comer",
    "comida",
    "comodo",
    "compra",
    "conde",
    "conejo",
    "conga",
    "conocer",
    "consejo",
    "contar",
    "copa",
    "copia",
    "corazon",
    "corbata",
    "corcho",
    "cordon",
    "corona",
    "correr",
    "coser",
    "cosmos",
    "costa",
    "craneo",
    "crater",
    "crear",
    "crecer",
    "creido",
    "crema",
    "cria",
    "crimen",
    "cripta",
    "crisis",
    "cromo",
    "cronica",
    "croqueta",
    "crudo",
    "cruz",
    "cuadro",
    "cuarto",
    "cuatro",
    "cubo",
    "cubrir",
    "cuchara",
    "cuello",
    "cuento",
    "cuerda",
    "cuesta",
    "cueva",
    "cuidar",
    "culebra",
    "culpa",
    "culto",
    "cumbre",
    "cumplir",
    "cuna",
    "cuneta",
    "cuota",
    "cupon",
    "cupula",
    "curar",
    "curioso",
    "curso",
    "curva",
    "cutis",
    "dama",
    "danza",
    "dar",
    "dardo",
    "datil",
    "deber",
    "debil",
    "decada",
    "decir",
    "dedo",
    "defensa",
    "definir",
    "dejar",
    "delfin",
    "delgado",
    "delito",
    "demora",
    "denso",
    "dental",
    "deporte",
    "derecho",
    "derrota",
    "desayuno",
    "deseo",
    "desfile",
    "desnudo",
    "destino",
    "desvio",
    "detalle",
    "detener",
    "deuda",
    "dia",
    "diablo",
    "diadema",
    "diamante",
    "diana",
    "diario",
    "dibujo",
    "dictar",
    "diente",
    "dieta",
    "diez",
    "dificil",
    "digno",
    "dilema",
    "diluir",
    "dinero",
    "directo",
    "dirigir",
    "disco",
    "diseno",
    "disfraz",
    "diva",
    "divino",
    "doble",
    "doce",
    "dolor",
    "domingo",
    "don",
    "donar",
    "dorado",
    "dormir",
    "dorso",
    "dos",
    "dosis",
    "dragon",
    "droga",
    "ducha",
    "duda",
    "duelo",
    "dueno",
    "dulce",
    "duo",
    "duque",
    "durar",
    "dureza",
    "duro",
    "ebano",
    "ebrio",
    "echar",
    "eco",
    "ecuador",
    "edad",
    "edicion",
    "edificio",
    "editor",
    "educar",
    "efecto",
    "eficaz",
    "eje",
    "ejemplo",
    "elefante",
    "elegir",
    "elemento",
    "elevar",
    "elipse",
    "elite",
    "elixir",
    "elogio",
    "eludir",
    "embudo",
    "emitir",
    "emocion",
    "empate",
    "empeno",
    "empleo",
    "empresa",
    "enano",
    "encargo",
    "enchufe",
    "encia",
    "enemigo",
    "enero",
    "enfado",
    "enfermo",
    "engano",
    "enigma",
    "enlace",
    "enorme",
    "enredo",
    "ensayo",
    "ensenar",
    "entero",
    "entrar",
    "envase",
    "envio",
    "epoca",
    "equipo",
    "erizo",
    "escala",
    "escena",
    "escolar",
    "escribir",
    "escudo",
    "esencia",
    "esfera",
    "esfuerzo",
    "espada",
    "espejo",
    "espia",
    "esposa",
    "espuma",
    "esqui",
    "estar",
    "este",
    "estilo",
    "estufa",
    "etapa",
    "eterno",
    "etica",
    "etnia",
    "evadir",
    "evaluar",
    "evento",
    "evitar",
    "exacto",
    "examen",
    "exceso",
    "excusa",
    "exento",
    "exigir",
    "exilio",
    "existir",
    "exito",
    "experto",
    "explicar",
    "exponer",
    "extremo",
    "fabrica",
    "fabula",
    "fachada",
    "facil",
    "factor",
    "faena",
    "faja",
    "falda",
    "fallo",
    "falso",
    "faltar",
    "fama",
    "familia",
    "famoso",
    "faraon",
    "farmacia",
    "farol",
    "farsa",
    "fase",
    "fatiga",
    "fauna",
    "favor",
    "fax",
    "febrero",
    "fecha",
    "feliz",
    "feo",
    "feria",
    "feroz",
    "fertil",
    "fervor",
    "festin",
    "fiable",
    "fianza",
    "fiar",
    "fibra",
    "ficcion",
    "ficha",
    "fideo",
    "fiebre",
    "fiel",
    "fiera",
    "fiesta",
    "figura",
    "fijar",
    "fijo",
    "fila",
    "filete",
    "filial",
    "filtro",
    "fin",
    "finca",
    "fingir",
    "finito",
    "firma",
    "flaco",
    "flauta",
    "flecha",
    "flor",
    "flota",
    "fluir",
    "flujo",
    "fluor",
    "fobia",
    "foca",
    "fogata",
    "fogon",
    "folio",
    "folleto",
    "fondo",
    "forma",
    "forro",
    "fortuna",
    "forzar",
    "fosa",
    "foto",
    "fracaso",
    "fragil",
    "franja",
    "frase",
    "fraude",
    "freir",
    "freno",
    "fresa",
    "frio",
    "frito",
    "fruta",
    "fuego",
    "fuente",
    "fuerza",
    "fuga",
    "fumar",
    "funcion",
    "funda",
    "furgon",
    "furia",
    "fusil",
    "futbol",
    "futuro",
    "gacela",
    "gafas",
    "gaita",
    "gajo",
    "gala",
    "galeria",
    "gallo",
    "gamba",
    "ganar",
    "gancho",
    "ganga",
    "ganso",
    "garaje",
    "garza",
    "gasolina",
    "gastar",
    "gato",
    "gavilan",
    "gemelo",
    "gemir",
    "gen",
    "genero",
    "genio",
    "gente",
    "geranio",
    "gerente",
    "germen",
    "gesto",
    "gigante",
    "gimnasio",
    "girar",
    "giro",
    "glaciar",
    "globo",
    "gloria",
    "gol",
    "golfo",
    "goloso",
    "golpe",
    "goma",
    "gordo",
    "gorila",
    "gorra",
    "gota",
    "goteo",
    "gozar",
    "grada",
    "grafico",
    "grano",
    "grasa",
    "gratis",
    "grave",
    "grieta",
    "grillo",
    "gripe",
    "gris",
    "grito",
    "grosor",
    "grua",
    "grueso",
    "grumo",
    "grupo",
    "guante",
    "guapo",
    "guardia",
    "guerra",
    "guia",
    "guino",
    "guion",
    "guiso",
    "guitarra",
    "gusano",
    "gustar",
    "haber",
    "habil",
    "hablar",
    "hacer",
    "hacha",
    "hada",
    "hallar",
    "hamaca",
    "harina",
    "haz",
    "hazana",
    "hebilla",
    "hebra",
    "hecho",
    "helado",
    "helio",
    "hembra",
    "herir",
    "hermano",
    "heroe",
    "hervir",
    "hielo",
    "hierro",
    "higado",
    "higiene",
    "hijo",
    "himno",
    "historia",
    "hocico",
    "hogar",
    "hoguera",
    "hoja",
    "hombre",
    "hongo",
    "honor",
    "honra",
    "hora",
    "hormiga",
    "horno",
    "hostil",
    "hoyo",
    "hueco",
    "huelga",
    "huerta",
    "hueso",
    "huevo",
    "huida",
    "huir",
    "humano",
    "humedo",
    "humilde",
    "humo",
    "hundir",
    "huracan",
    "hurto",
    "icono",
    "ideal",
    "idioma",
    "idolo",
    "iglesia",
    "iglu",
    "igual",
    "ilegal",
    "ilusion",
    "imagen",
    "iman",
    "imitar",
    "impar",
    "imperio",
    "imponer",
    "impulso",
    "incapaz",
    "indice",
    "inerte",
    "infiel",
    "informe",
    "ingenio",
    "inicio",
    "inmenso",
    "inmune",
    "innato",
    "insecto",
    "instante",
    "interes",
    "intimo",
    "intuir",
    "inutil",
    "invierno",
    "ira",
    "iris",
    "ironia",
    "isla",
    "islote",
    "jabali",
    "jabon",
    "jamon",
    "jarabe",
    "jardin",
    "jarra",
    "jaula",
    "jazmin",
    "jefe",
    "jeringa",
    "jinete",
    "jornada",
    "joroba",
    "joven",
    "joya",
    "juerga",
    "jueves",
    "juez",
    "jugador",
    "jugo",
    "juguete",
    "juicio",
    "junco",
    "jungla",
    "junio",
    "juntar",
    "jupiter",
    "jurar",
    "justo",
    "juvenil",
    "juzgar",
    "kilo",
    "koala",
    "labio",
    "lacio",
    "lacra",
    "lado",
    "ladron",
    "lagarto",
    "lagrima",
    "laguna",
    "laico",
    "lamer",
    "lamina",
    "lampara",
    "lana",
    "lancha",
    "langosta",
    "lanza",
    "lapiz",
    "largo",
    "larva",
    "lastima",
    "lata",
    "latex",
    "latir",
    "laurel",
    "lavar",
    "lazo",
    "leal",
    "leccion",
    "leche",
    "lector",
    "leer",
    "legion",
    "legumbre",
    "lejano",
    "lengua",
    "lento",
    "lena",
    "leon",
    "leopardo",
    "lesion",
    "letal",
    "letra",
    "leve",
    "leyenda",
    "libertad",
    "libro",
    "licor",
    "lider",
    "lidiar",
    "lienzo",
    "liga",
    "ligero",
    "lima",
    "limite",
    "limon",
    "limpio",
    "lince",
    "lindo",
    "linea",
    "lingote",
    "lino",
    "linterna",
    "liquido",
    "liso",
    "lista",
    "litera",
    "litio",
    "litro",
    "llaga",
    "llama",
    "llanto",
    "llave",
    "llegar",
    "llenar",
    "llevar",
    "llorar",
    "llover",
    "lluvia",
    "lobo",
    "locion",
    "loco",
    "locura",
    "logica",
    "logro",
    "lombriz",
    "lomo",
    "lonja",
    "lote",
    "lucha",
    "lucir",
    "lugar",
    "lujo",
    "luna",
    "lunes",
    "lupa",
    "lustro",
    "luto",
    "luz",
    "maceta",
    "macho",
    "madera",
    "madre",
    "maduro",
    "maestro",
    "mafia",
    "magia",
    "mago",
    "maiz",
    "maldad",
    "maleta",
    "malla",
    "malo",
    "mama",
    "mambo",
    "mamut",
    "manco",
    "mando",
    "manejar",
    "manga",
    "maniqui",
    "manjar",
    "mano",
    "manso",
    "manta",
    "manana",
    "mapa",
    "maquina",
    "mar",
    "marco",
    "marea",
    "marfil",
    "margen",
    "marido",
    "marmol",
    "marron",
    "martes",
    "marzo",
    "masa",
    "mascara",
    "masivo",
    "matar",
    "materia",
    "matiz",
    "matriz",
    "maximo",
    "mayor",
    "mazorca",
    "mecha",
    "medalla",
    "medio",
    "medula",
    "mejilla",
    "mejor",
    "melena",
    "melon",
    "memoria",
    "menor",
    "mensaje",
    "mente",
    "menu",
    "mercado",
    "merengue",
    "merito",
    "mes",
    "meson",
    "meta",
    "meter",
    "metodo",
    "metro",
    "mezcla",
    "miedo",
    "miel",
    "miembro",
    "miga",
    "mil",
    "milagro",
    "militar",
    "millon",
    "mimo",
    "mina",
    "minero",
    "minimo",
    "minuto",
    "miope",
    "mirar",
    "misa",
    "miseria",
    "misil",
    "mismo",
    "mitad",
    "mito",
    "mochila",
    "mocion",
    "moda",
    "modelo",
    "moho",
    "mojar",
    "molde",
    "moler",
    "molino",
    "momento",
    "momia",
    "monarca",
    "moneda",
    "monja",
    "monto",
    "mono",
    "morada",
    "morder",
    "moreno",
    "morir",
    "morro",
    "morsa",
    "mortal",
    "mosca",
    "mostrar",
    "motivo",
    "mover",
    "movil",
    "mozo",
    "mucho",
    "mudar",
    "mueble",
    "muela",
    "muerte",
    "muestra",
    "mugre",
    "mujer",
    "mula",
    "muleta",
    "multa",
    "mundo",
    "muneca",
    "mural",
    "muro",
    "musculo",
    "museo",
    "musgo",
    "musica",
    "muslo",
    "nacar",
    "nacion",
    "nadar",
    "naipe",
    "naranja",
    "nariz",
    "narrar",
    "nasal",
    "natal",
    "nativo",
    "natural",
    "nausea",
    "naval",
    "nave",
    "navidad",
    "necio",
    "nectar",
    "negar",
    "negocio",
    "negro",
    "neon",
    "nervio",
    "neto",
    "neutro",
    "nevar",
    "nevera",
    "nicho",
    "nido",
    "niebla",
    "nieto",
    "ninez",
    "nino",
    "nitido",
    "nivel",
    "nobleza",
    "noche",
    "nomina",
    "noria",
    "norma",
    "norte",
    "nota",
    "noticia",
    "novato",
    "novela",
    "novio",
    "nube",
    "nuca",
    "nucleo",
    "nudillo",
    "nudo",
    "nuera",
    "nueve",
    "nuez",
    "nulo",
    "numero",
    "nutria",
    "oasis",
    "obeso",
    "obispo",
    "objeto",
    "obra",
    "obrero",
    "observar",
    "obtener",
    "obvio",
    "oca",
    "ocaso",
    "oceano",
    "ochenta",
    "ocho",
    "ocio",
    "ocre",
    "octavo",
    "octubre",
    "oculto",
    "ocupar",
    "ocurrir",
    "odiar",
    "odio",
    "odisea",
    "oeste",
    "ofensa",
    "oferta",
    "oficio",
    "ofrecer",
    "ogro",
    "oido",
    "oir",
    "ojo",
    "ola",
    "oleada",
    "olfato",
    "olivo",
    "olla",
    "olmo",
    "olor",
    "olvido",
    "ombligo",
    "onda",
    "onza",
    "opaco",
    "opcion",
    "opera",
    "opinar",
    "oponer",
    "optar",
    "optica",
    "opuesto",
    "oracion",
    "orador",
    "oral",
    "orbita",
    "orca",
    "orden",
    "oreja",
    "organo",
    "orgia",
    "orgullo",
    "oriente",
    "origen",
    "orilla",
    "oro",
    "orquesta",
    "oruga",
    "osadia",
    "oscuro",
    "osezno",
    "oso",
    "ostra",
    "otono",
    "otro",
    "oveja",
    "ovulo",
    "oxido",
    "oxigeno",
    "oyente",
    "ozono",
    "pacto",
    "padre",
    "paella",
    "pagina",
    "pago",
    "pais",
    "pajaro",
    "palabra",
    "palco",
    "paleta",
    "palido",
    "palma",
    "paloma",
    "palpar",
    "pan",
    "panal",
    "panico",
    "pantera",
    "panuelo",
    "papa",
    "papel",
    "papilla",
    "paquete",
    "parar",
    "parcela",
    "pared",
    "parir",
    "paro",
    "parpado",
    "parque",
    "parrafo",
    "parte",
    "pasar",
    "paseo",
    "pasion",
    "paso",
    "pasta",
    "pata",
    "patio",
    "patria",
    "pausa",
    "pauta",
    "pavo",
    "payaso",
    "peaton",
    "pecado",
    "pecera",
    "pecho",
    "pedal",
    "pedir",
    "pegar",
    "peine",
    "pelar",
    "peldano",
    "pelea",
    "peligro",
    "pellejo",
    "pelo",
    "peluca",
    "pena",
    "pensar",
    "penon",
    "peon",
    "peor",
    "pepino",
    "pequeno",
    "pera",
    "percha",
    "perder",
    "pereza",
    "perfil",
    "perico",
    "perla",
    "permiso",
    "perro",
    "persona",
    "pesa",
    "pesca",
    "pesimo",
    "pestana",
    "petalo",
    "petroleo",
    "pez",
    "pezuna",
    "picar",
    "pichon",
    "pie",
    "piedra",
    "pierna",
    "pieza",
    "pijama",
    "pilar",
    "piloto",
    "pimienta",
    "pino",
    "pintor",
    "pinza",
    "pina",
    "piojo",
    "pipa",
    "pirata",
    "pisar",
    "piscina",
    "piso",
    "pista",
    "piton",
    "pizca",
    "placa",
    "plan",
    "plata",
    "playa",
    "plaza",
    "pleito",
    "pleno",
    "plomo",
    "pluma",
    "plural",
    "pobre",
    "poco",
    "poder",
    "podio",
    "poema",
    "poesia",
    "poeta",
    "polen",
    "policia",
    "pollo",
    "polvo",
    "pomada",
    "pomelo",
    "pomo",
    "pompa",
    "poner",
    "porcion",
    "portal",
    "posada",
    "poseer",
    "posible",
    "poste",
    "potencia",
    "potro",
    "pozo",
    "prado",
    "precoz",
    "pregunta",
    "premio",
    "prensa",
    "preso",
    "previo",
    "primo",
    "principe",
    "prision",
    "privar",
    "proa",
    "probar",
    "proceso",
    "producto",
    "proeza",
    "profesor",
    "programa",
    "prole",
    "promesa",
    "pronto",
    "propio",
    "proximo",
    "prueba",
    "publico",
    "puchero",
    "pudor",
    "pueblo",
    "puerta",
    "puesto",
    "pulga",
    "pulir",
    "pulmon",
    "pulpo",
    "pulso",
    "puma",
    "punto",
    "punal",
    "puno",
    "pupa",
    "pupila",
    "pure",
    "quedar",
    "queja",
    "quemar",
    "querer",
    "queso",
    "quieto",
    "quimica",
    "quince",
    "quitar",
    "rabano",
    "rabia",
    "rabo",
    "racion",
    "radical",
    "raiz",
    "rama",
    "rampa",
    "rancho",
    "rango",
    "rapaz",
    "rapido",
    "rapto",
    "rasgo",
    "raspa",
    "rato",
    "rayo",
    "raza",
    "razon",
    "reaccion",
    "realidad",
    "rebano",
    "rebote",
    "recaer",
    "receta",
    "rechazo",
    "recoger",
    "recreo",
    "recto",
    "recurso",
    "red",
    "redondo",
    "reducir",
    "reflejo",
    "reforma",
    "refran",
    "refugio",
    "regalo",
    "regir",
    "regla",
    "regreso",
    "rehen",
    "reino",
    "reir",
    "reja",
    "relato",
    "relevo",
    "relieve",
    "relleno",
    "reloj",
    "remar",
    "remedio",
    "remo",
    "rencor",
    "rendir",
    "renta",
    "reparto",
    "repetir",
    "reposo",
    "reptil",
    "res",
    "rescate",
    "resina",
    "respeto",
    "resto",
    "resumen",
    "retiro",
    "retorno",
    "retrato",
    "reunir",
    "reves",
    "revista",
    "rey",
    "rezar",
    "rico",
    "riego",
    "rienda",
    "riesgo",
    "rifa",
    "rigido",
    "rigor",
    "rincon",
    "rinon",
    "rio",
    "riqueza",
    "risa",
    "ritmo",
    "rito",
    "rizo",
    "roble",
    "roce",
    "rociar",
    "rodar",
    "rodeo",
    "rodilla",
    "roer",
    "rojizo",
    "rojo",
    "romero",
    "romper",
    "ron",
    "ronco",
    "ronda",
    "ropa",
    "ropero",
    "rosa",
    "rosca",
    "rostro",
    "rotar",
    "rubi",
    "rubor",
    "rudo",
    "rueda",
    "rugir",
    "ruido",
    "ruina",
    "ruleta",
    "rulo",
    "rumbo",
    "rumor",
    "ruptura",
    "ruta",
    "rutina",
    "sabado",
    "saber",
    "sabio",
    "sable",
    "sacar",
    "sagaz",
    "sagrado",
    "sala",
    "saldo",
    "salero",
    "salir",
    "salmon",
    "salon",
    "salsa",
    "salto",
    "salud",
    "salvar",
    "samba",
    "sancion",
    "sandia",
    "sanear",
    "sangre",
    "sanidad",
    "sano",
    "santo",
    "sapo",
    "saque",
    "sardina",
    "sarten",
    "sastre",
    "satan",
    "sauna",
    "saxofon",
    "seccion",
    "seco",
    "secreto",
    "secta",
    "sed",
    "seguir",
    "seis",
    "sello",
    "selva",
    "semana",
    "semilla",
    "senda",
    "sensor",
    "senal",
    "senor",
    "separar",
    "sepia",
    "sequia",
    "ser",
    "serie",
    "sermon",
    "servir",
    "sesenta",
    "sesion",
    "seta",
    "setenta",
    "severo",
    "sexo",
    "sexto",
    "sidra",
    "siesta",
    "siete",
    "siglo",
    "signo",
    "silaba",
    "silbar",
    "silencio",
    "silla",
    "simbolo",
    "simio",
    "sirena",
    "sistema",
    "sitio",
    "situar",
    "sobre",
    "socio",
    "sodio",
    "sol",
    "solapa",
    "soldado",
    "soledad",
    "solido",
    "soltar",
    "solucion",
    "sombra",
    "sondeo",
    "sonido",
    "sonoro",
    "sonrisa",
    "sopa",
    "soplar",
    "soporte",
    "sordo",
    "sorpresa",
    "sorteo",
    "sosten",
    "sotano",
    "suave",
    "subir",
    "suceso",
    "sudor",
    "suegra",
    "suelo",
    "sueno",
    "suerte",
    "sufrir",
    "sujeto",
    "sultan",
    "sumar",
    "superar",
    "suplir",
    "suponer",
    "supremo",
    "sur",
    "surco",
    "sureno",
    "surgir",
    "susto",
    "sutil",
    "tabaco",
    "tabique",
    "tabla",
    "tabu",
    "taco",
    "tacto",
    "tajo",
    "talar",
    "talco",
    "talento",
    "talla",
    "talon",
    "tamano",
    "tambor",
    "tango",
    "tanque",
    "tapa",
    "tapete",
    "tapia",
    "tapon",
    "taquilla",
    "tarde",
    "tarea",
    "tarifa",
    "tarjeta",
    "tarot",
    "tarro",
    "tarta",
    "tatuaje",
    "tauro",
    "taza",
    "tazon",
    "teatro",
    "techo",
    "tecla",
    "tecnica",
    "tejado",
    "tejer",
    "tejido",
    "tela",
    "telefono",
    "tema",
    "temor",
    "templo",
    "tenaz",
    "tender",
    "tener",
    "tenis",
    "tenso",
    "teoria",
    "terapia",
    "terco",
    "termino",
    "ternura",
    "terror",
    "tesis",
    "tesoro",
    "testigo",
    "tetera",
    "texto",
    "tez",
    "tibio",
    "tiburon",
    "tiempo",
    "tienda",
    "tierra",
    "tieso",
    "tigre",
    "tijera",
    "tilde",
    "timbre",
    "timido",
    "timo",
    "tinta",
    "tio",
    "tipico",
    "tipo",
    "tira",
    "tiron",
    "titan",
    "titere",
    "titulo",
    "tiza",
    "toalla",
    "tobillo",
    "tocar",
    "tocino",
    "todo",
    "toga",
    "toldo",
    "tomar",
    "tono",
    "tonto",
    "topar",
    "tope",
    "toque",
    "torax",
    "torero",
    "tormenta",
    "torneo",
    "toro",
    "torpedo",
    "torre",
    "torso",
    "tortuga",
    "tos",
    "tosco",
    "toser",
    "toxico",
    "trabajo",
    "tractor",
    "traer",
    "trafico",
    "trago",
    "traje",
    "tramo",
    "trance",
    "trato",
    "trauma",
    "trazar",
    "trebol",
    "tregua",
    "treinta",
    "tren",
    "trepar",
    "tres",
    "tribu",
    "trigo",
    "tripa",
    "triste",
    "triunfo",
    "trofeo",
    "trompa",
    "tronco",
    "tropa",
    "trote",
    "trozo",
    "truco",
    "trueno",
    "trufa",
    "tuberia",
    "tubo",
    "tuerto",
    "tumba",
    "tumor",
    "tunel",
    "tunica",
    "turbina",
    "turismo",
    "turno",
    "tutor",
    "ubicar",
    "ulcera",
    "umbral",
    "unidad",
    "unir",
    "universo",
    "uno",
    "untar",
    "una",
    "urbano",
    "urbe",
    "urgente",
    "urna",
    "usar",
    "usuario",
    "util",
    "utopia",
    "uva",
    "vaca",
    "vacio",
    "vacuna",
    "vagar",
    "vago",
    "vaina",
    "vajilla",
    "vale",
    "valido",
    "valle",
    "valor",
    "valvula",
    "vampiro",
    "vara",
    "variar",
    "varon",
    "vaso",
    "vecino",
    "vector",
    "vehiculo",
    "veinte",
    "vejez",
    "vela",
    "velero",
    "veloz",
    "vena",
    "vencer",
    "venda",
    "veneno",
    "vengar",
    "venir",
    "venta",
    "venus",
    "ver",
    "verano",
    "verbo",
    "verde",
    "vereda",
    "verja",
    "verso",
    "verter",
    "via",
    "viaje",
    "vibrar",
    "vicio",
    "victima",
    "vida",
    "video",
    "vidrio",
    "viejo",
    "viernes",
    "vigor",
    "vil",
    "villa",
    "vinagre",
    "vino",
    "vinedo",
    "violin",
    "viral",
    "virgo",
    "virtud",
    "visor",
    "vispera",
    "vista",
    "vitamina",
    "viudo",
    "vivaz",
    "vivero",
    "vivir",
    "vivo",
    "volcan",
    "volumen",
    "volver",
    "voraz",
    "votar",
    "voto",
    "voz",
    "vuelo",
    "vulgar",
    "yacer",
    "yate",
    "yegua",
    "yema",
    "yerno",
    "yeso",
    "yodo",
    "yoga",
    "yogur",
    "zafiro",
    "zanja",
    "zapato",
    "zarza",
    "zona",
    "zorro",
    "zumo",
    "zurdo"
  ]), lu;
}
/*!
 * index.js - wordlists for bcoin
 * Copyright (c) 2015-2016, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var x4;
function ux() {
  return x4 || (x4 = 1, ci.chinese = {
    simplified: ix(),
    traditional: nx()
  }, ci.english = sx(), ci.french = ox(), ci.italian = ax(), ci.japanese = fx(), ci.spanish = cx()), ci;
}
/*!
 * wordlist.js - wordlists for bcoin
 * Copyright (c) 2015-2016, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var w4;
function t7() {
  if (w4) return su;
  w4 = 1;
  const e = ux();
  return su.get = function(d) {
    switch (d) {
      case "simplified chinese":
        return e.chinese.simplified;
      case "traditional chinese":
        return e.chinese.traditional;
      case "english":
        return e.english;
      case "french":
        return e.french;
      case "italian":
        return e.italian;
      case "japanese":
        return e.japanese;
      case "spanish":
        return e.spanish;
      default:
        throw new Error(`Unknown language: ${d}.`);
    }
  }, su;
}
var Xi = {};
const hx = {
  0: { 60: [null, null, { 824: 8814 }], 61: [null, null, { 824: 8800 }], 62: [null, null, { 824: 8815 }], 65: [null, null, { 768: 192, 769: 193, 770: 194, 771: 195, 772: 256, 774: 258, 775: 550, 776: 196, 777: 7842, 778: 197, 780: 461, 783: 512, 785: 514, 803: 7840, 805: 7680, 808: 260 }], 66: [null, null, { 775: 7682, 803: 7684, 817: 7686 }], 67: [null, null, { 769: 262, 770: 264, 775: 266, 780: 268, 807: 199 }], 68: [null, null, { 775: 7690, 780: 270, 803: 7692, 807: 7696, 813: 7698, 817: 7694 }], 69: [null, null, { 768: 200, 769: 201, 770: 202, 771: 7868, 772: 274, 774: 276, 775: 278, 776: 203, 777: 7866, 780: 282, 783: 516, 785: 518, 803: 7864, 807: 552, 808: 280, 813: 7704, 816: 7706 }], 70: [null, null, { 775: 7710 }], 71: [null, null, { 769: 500, 770: 284, 772: 7712, 774: 286, 775: 288, 780: 486, 807: 290 }], 72: [null, null, { 770: 292, 775: 7714, 776: 7718, 780: 542, 803: 7716, 807: 7720, 814: 7722 }], 73: [null, null, { 768: 204, 769: 205, 770: 206, 771: 296, 772: 298, 774: 300, 775: 304, 776: 207, 777: 7880, 780: 463, 783: 520, 785: 522, 803: 7882, 808: 302, 816: 7724 }], 74: [null, null, { 770: 308 }], 75: [null, null, { 769: 7728, 780: 488, 803: 7730, 807: 310, 817: 7732 }], 76: [null, null, { 769: 313, 780: 317, 803: 7734, 807: 315, 813: 7740, 817: 7738 }], 77: [null, null, { 769: 7742, 775: 7744, 803: 7746 }], 78: [null, null, { 768: 504, 769: 323, 771: 209, 775: 7748, 780: 327, 803: 7750, 807: 325, 813: 7754, 817: 7752 }], 79: [null, null, { 768: 210, 769: 211, 770: 212, 771: 213, 772: 332, 774: 334, 775: 558, 776: 214, 777: 7886, 779: 336, 780: 465, 783: 524, 785: 526, 795: 416, 803: 7884, 808: 490 }], 80: [null, null, { 769: 7764, 775: 7766 }], 82: [null, null, { 769: 340, 775: 7768, 780: 344, 783: 528, 785: 530, 803: 7770, 807: 342, 817: 7774 }], 83: [null, null, { 769: 346, 770: 348, 775: 7776, 780: 352, 803: 7778, 806: 536, 807: 350 }], 84: [null, null, { 775: 7786, 780: 356, 803: 7788, 806: 538, 807: 354, 813: 7792, 817: 7790 }], 85: [null, null, { 768: 217, 769: 218, 770: 219, 771: 360, 772: 362, 774: 364, 776: 220, 777: 7910, 778: 366, 779: 368, 780: 467, 783: 532, 785: 534, 795: 431, 803: 7908, 804: 7794, 808: 370, 813: 7798, 816: 7796 }], 86: [null, null, { 771: 7804, 803: 7806 }], 87: [null, null, { 768: 7808, 769: 7810, 770: 372, 775: 7814, 776: 7812, 803: 7816 }], 88: [null, null, { 775: 7818, 776: 7820 }], 89: [null, null, { 768: 7922, 769: 221, 770: 374, 771: 7928, 772: 562, 775: 7822, 776: 376, 777: 7926, 803: 7924 }], 90: [null, null, { 769: 377, 770: 7824, 775: 379, 780: 381, 803: 7826, 817: 7828 }], 97: [null, null, { 768: 224, 769: 225, 770: 226, 771: 227, 772: 257, 774: 259, 775: 551, 776: 228, 777: 7843, 778: 229, 780: 462, 783: 513, 785: 515, 803: 7841, 805: 7681, 808: 261 }], 98: [null, null, { 775: 7683, 803: 7685, 817: 7687 }], 99: [null, null, { 769: 263, 770: 265, 775: 267, 780: 269, 807: 231 }], 100: [null, null, { 775: 7691, 780: 271, 803: 7693, 807: 7697, 813: 7699, 817: 7695 }], 101: [null, null, { 768: 232, 769: 233, 770: 234, 771: 7869, 772: 275, 774: 277, 775: 279, 776: 235, 777: 7867, 780: 283, 783: 517, 785: 519, 803: 7865, 807: 553, 808: 281, 813: 7705, 816: 7707 }], 102: [null, null, { 775: 7711 }], 103: [null, null, { 769: 501, 770: 285, 772: 7713, 774: 287, 775: 289, 780: 487, 807: 291 }], 104: [null, null, { 770: 293, 775: 7715, 776: 7719, 780: 543, 803: 7717, 807: 7721, 814: 7723, 817: 7830 }], 105: [null, null, { 768: 236, 769: 237, 770: 238, 771: 297, 772: 299, 774: 301, 776: 239, 777: 7881, 780: 464, 783: 521, 785: 523, 803: 7883, 808: 303, 816: 7725 }], 106: [null, null, { 770: 309, 780: 496 }], 107: [null, null, { 769: 7729, 780: 489, 803: 7731, 807: 311, 817: 7733 }], 108: [null, null, { 769: 314, 780: 318, 803: 7735, 807: 316, 813: 7741, 817: 7739 }], 109: [null, null, { 769: 7743, 775: 7745, 803: 7747 }], 110: [null, null, { 768: 505, 769: 324, 771: 241, 775: 7749, 780: 328, 803: 7751, 807: 326, 813: 7755, 817: 7753 }], 111: [null, null, { 768: 242, 769: 243, 770: 244, 771: 245, 772: 333, 774: 335, 775: 559, 776: 246, 777: 7887, 779: 337, 780: 466, 783: 525, 785: 527, 795: 417, 803: 7885, 808: 491 }], 112: [null, null, { 769: 7765, 775: 7767 }], 114: [null, null, { 769: 341, 775: 7769, 780: 345, 783: 529, 785: 531, 803: 7771, 807: 343, 817: 7775 }], 115: [null, null, { 769: 347, 770: 349, 775: 7777, 780: 353, 803: 7779, 806: 537, 807: 351 }], 116: [null, null, { 775: 7787, 776: 7831, 780: 357, 803: 7789, 806: 539, 807: 355, 813: 7793, 817: 7791 }], 117: [null, null, { 768: 249, 769: 250, 770: 251, 771: 361, 772: 363, 774: 365, 776: 252, 777: 7911, 778: 367, 779: 369, 780: 468, 783: 533, 785: 535, 795: 432, 803: 7909, 804: 7795, 808: 371, 813: 7799, 816: 7797 }], 118: [null, null, { 771: 7805, 803: 7807 }], 119: [null, null, { 768: 7809, 769: 7811, 770: 373, 775: 7815, 776: 7813, 778: 7832, 803: 7817 }], 120: [null, null, { 775: 7819, 776: 7821 }], 121: [null, null, { 768: 7923, 769: 253, 770: 375, 771: 7929, 772: 563, 775: 7823, 776: 255, 777: 7927, 778: 7833, 803: 7925 }], 122: [null, null, { 769: 378, 770: 7825, 775: 380, 780: 382, 803: 7827, 817: 7829 }], 160: [[32], 256], 168: [[32, 776], 256, { 768: 8173, 769: 901, 834: 8129 }], 170: [[97], 256], 175: [[32, 772], 256], 178: [[50], 256], 179: [[51], 256], 180: [[32, 769], 256], 181: [[956], 256], 184: [[32, 807], 256], 185: [[49], 256], 186: [[111], 256], 188: [[49, 8260, 52], 256], 189: [[49, 8260, 50], 256], 190: [[51, 8260, 52], 256], 192: [[65, 768]], 193: [[65, 769]], 194: [[65, 770], null, { 768: 7846, 769: 7844, 771: 7850, 777: 7848 }], 195: [[65, 771]], 196: [[65, 776], null, { 772: 478 }], 197: [[65, 778], null, { 769: 506 }], 198: [null, null, { 769: 508, 772: 482 }], 199: [[67, 807], null, { 769: 7688 }], 200: [[69, 768]], 201: [[69, 769]], 202: [[69, 770], null, { 768: 7872, 769: 7870, 771: 7876, 777: 7874 }], 203: [[69, 776]], 204: [[73, 768]], 205: [[73, 769]], 206: [[73, 770]], 207: [[73, 776], null, { 769: 7726 }], 209: [[78, 771]], 210: [[79, 768]], 211: [[79, 769]], 212: [[79, 770], null, { 768: 7890, 769: 7888, 771: 7894, 777: 7892 }], 213: [[79, 771], null, { 769: 7756, 772: 556, 776: 7758 }], 214: [[79, 776], null, { 772: 554 }], 216: [null, null, { 769: 510 }], 217: [[85, 768]], 218: [[85, 769]], 219: [[85, 770]], 220: [[85, 776], null, { 768: 475, 769: 471, 772: 469, 780: 473 }], 221: [[89, 769]], 224: [[97, 768]], 225: [[97, 769]], 226: [[97, 770], null, { 768: 7847, 769: 7845, 771: 7851, 777: 7849 }], 227: [[97, 771]], 228: [[97, 776], null, { 772: 479 }], 229: [[97, 778], null, { 769: 507 }], 230: [null, null, { 769: 509, 772: 483 }], 231: [[99, 807], null, { 769: 7689 }], 232: [[101, 768]], 233: [[101, 769]], 234: [[101, 770], null, { 768: 7873, 769: 7871, 771: 7877, 777: 7875 }], 235: [[101, 776]], 236: [[105, 768]], 237: [[105, 769]], 238: [[105, 770]], 239: [[105, 776], null, { 769: 7727 }], 241: [[110, 771]], 242: [[111, 768]], 243: [[111, 769]], 244: [[111, 770], null, { 768: 7891, 769: 7889, 771: 7895, 777: 7893 }], 245: [[111, 771], null, { 769: 7757, 772: 557, 776: 7759 }], 246: [[111, 776], null, { 772: 555 }], 248: [null, null, { 769: 511 }], 249: [[117, 768]], 250: [[117, 769]], 251: [[117, 770]], 252: [[117, 776], null, { 768: 476, 769: 472, 772: 470, 780: 474 }], 253: [[121, 769]], 255: [[121, 776]] },
  256: { 256: [[65, 772]], 257: [[97, 772]], 258: [[65, 774], null, { 768: 7856, 769: 7854, 771: 7860, 777: 7858 }], 259: [[97, 774], null, { 768: 7857, 769: 7855, 771: 7861, 777: 7859 }], 260: [[65, 808]], 261: [[97, 808]], 262: [[67, 769]], 263: [[99, 769]], 264: [[67, 770]], 265: [[99, 770]], 266: [[67, 775]], 267: [[99, 775]], 268: [[67, 780]], 269: [[99, 780]], 270: [[68, 780]], 271: [[100, 780]], 274: [[69, 772], null, { 768: 7700, 769: 7702 }], 275: [[101, 772], null, { 768: 7701, 769: 7703 }], 276: [[69, 774]], 277: [[101, 774]], 278: [[69, 775]], 279: [[101, 775]], 280: [[69, 808]], 281: [[101, 808]], 282: [[69, 780]], 283: [[101, 780]], 284: [[71, 770]], 285: [[103, 770]], 286: [[71, 774]], 287: [[103, 774]], 288: [[71, 775]], 289: [[103, 775]], 290: [[71, 807]], 291: [[103, 807]], 292: [[72, 770]], 293: [[104, 770]], 296: [[73, 771]], 297: [[105, 771]], 298: [[73, 772]], 299: [[105, 772]], 300: [[73, 774]], 301: [[105, 774]], 302: [[73, 808]], 303: [[105, 808]], 304: [[73, 775]], 306: [[73, 74], 256], 307: [[105, 106], 256], 308: [[74, 770]], 309: [[106, 770]], 310: [[75, 807]], 311: [[107, 807]], 313: [[76, 769]], 314: [[108, 769]], 315: [[76, 807]], 316: [[108, 807]], 317: [[76, 780]], 318: [[108, 780]], 319: [[76, 183], 256], 320: [[108, 183], 256], 323: [[78, 769]], 324: [[110, 769]], 325: [[78, 807]], 326: [[110, 807]], 327: [[78, 780]], 328: [[110, 780]], 329: [[700, 110], 256], 332: [[79, 772], null, { 768: 7760, 769: 7762 }], 333: [[111, 772], null, { 768: 7761, 769: 7763 }], 334: [[79, 774]], 335: [[111, 774]], 336: [[79, 779]], 337: [[111, 779]], 340: [[82, 769]], 341: [[114, 769]], 342: [[82, 807]], 343: [[114, 807]], 344: [[82, 780]], 345: [[114, 780]], 346: [[83, 769], null, { 775: 7780 }], 347: [[115, 769], null, { 775: 7781 }], 348: [[83, 770]], 349: [[115, 770]], 350: [[83, 807]], 351: [[115, 807]], 352: [[83, 780], null, { 775: 7782 }], 353: [[115, 780], null, { 775: 7783 }], 354: [[84, 807]], 355: [[116, 807]], 356: [[84, 780]], 357: [[116, 780]], 360: [[85, 771], null, { 769: 7800 }], 361: [[117, 771], null, { 769: 7801 }], 362: [[85, 772], null, { 776: 7802 }], 363: [[117, 772], null, { 776: 7803 }], 364: [[85, 774]], 365: [[117, 774]], 366: [[85, 778]], 367: [[117, 778]], 368: [[85, 779]], 369: [[117, 779]], 370: [[85, 808]], 371: [[117, 808]], 372: [[87, 770]], 373: [[119, 770]], 374: [[89, 770]], 375: [[121, 770]], 376: [[89, 776]], 377: [[90, 769]], 378: [[122, 769]], 379: [[90, 775]], 380: [[122, 775]], 381: [[90, 780]], 382: [[122, 780]], 383: [[115], 256, { 775: 7835 }], 416: [[79, 795], null, { 768: 7900, 769: 7898, 771: 7904, 777: 7902, 803: 7906 }], 417: [[111, 795], null, { 768: 7901, 769: 7899, 771: 7905, 777: 7903, 803: 7907 }], 431: [[85, 795], null, { 768: 7914, 769: 7912, 771: 7918, 777: 7916, 803: 7920 }], 432: [[117, 795], null, { 768: 7915, 769: 7913, 771: 7919, 777: 7917, 803: 7921 }], 439: [null, null, { 780: 494 }], 452: [[68, 381], 256], 453: [[68, 382], 256], 454: [[100, 382], 256], 455: [[76, 74], 256], 456: [[76, 106], 256], 457: [[108, 106], 256], 458: [[78, 74], 256], 459: [[78, 106], 256], 460: [[110, 106], 256], 461: [[65, 780]], 462: [[97, 780]], 463: [[73, 780]], 464: [[105, 780]], 465: [[79, 780]], 466: [[111, 780]], 467: [[85, 780]], 468: [[117, 780]], 469: [[220, 772]], 470: [[252, 772]], 471: [[220, 769]], 472: [[252, 769]], 473: [[220, 780]], 474: [[252, 780]], 475: [[220, 768]], 476: [[252, 768]], 478: [[196, 772]], 479: [[228, 772]], 480: [[550, 772]], 481: [[551, 772]], 482: [[198, 772]], 483: [[230, 772]], 486: [[71, 780]], 487: [[103, 780]], 488: [[75, 780]], 489: [[107, 780]], 490: [[79, 808], null, { 772: 492 }], 491: [[111, 808], null, { 772: 493 }], 492: [[490, 772]], 493: [[491, 772]], 494: [[439, 780]], 495: [[658, 780]], 496: [[106, 780]], 497: [[68, 90], 256], 498: [[68, 122], 256], 499: [[100, 122], 256], 500: [[71, 769]], 501: [[103, 769]], 504: [[78, 768]], 505: [[110, 768]], 506: [[197, 769]], 507: [[229, 769]], 508: [[198, 769]], 509: [[230, 769]], 510: [[216, 769]], 511: [[248, 769]], 66045: [null, 220] },
  512: { 512: [[65, 783]], 513: [[97, 783]], 514: [[65, 785]], 515: [[97, 785]], 516: [[69, 783]], 517: [[101, 783]], 518: [[69, 785]], 519: [[101, 785]], 520: [[73, 783]], 521: [[105, 783]], 522: [[73, 785]], 523: [[105, 785]], 524: [[79, 783]], 525: [[111, 783]], 526: [[79, 785]], 527: [[111, 785]], 528: [[82, 783]], 529: [[114, 783]], 530: [[82, 785]], 531: [[114, 785]], 532: [[85, 783]], 533: [[117, 783]], 534: [[85, 785]], 535: [[117, 785]], 536: [[83, 806]], 537: [[115, 806]], 538: [[84, 806]], 539: [[116, 806]], 542: [[72, 780]], 543: [[104, 780]], 550: [[65, 775], null, { 772: 480 }], 551: [[97, 775], null, { 772: 481 }], 552: [[69, 807], null, { 774: 7708 }], 553: [[101, 807], null, { 774: 7709 }], 554: [[214, 772]], 555: [[246, 772]], 556: [[213, 772]], 557: [[245, 772]], 558: [[79, 775], null, { 772: 560 }], 559: [[111, 775], null, { 772: 561 }], 560: [[558, 772]], 561: [[559, 772]], 562: [[89, 772]], 563: [[121, 772]], 658: [null, null, { 780: 495 }], 688: [[104], 256], 689: [[614], 256], 690: [[106], 256], 691: [[114], 256], 692: [[633], 256], 693: [[635], 256], 694: [[641], 256], 695: [[119], 256], 696: [[121], 256], 728: [[32, 774], 256], 729: [[32, 775], 256], 730: [[32, 778], 256], 731: [[32, 808], 256], 732: [[32, 771], 256], 733: [[32, 779], 256], 736: [[611], 256], 737: [[108], 256], 738: [[115], 256], 739: [[120], 256], 740: [[661], 256], 66272: [null, 220] },
  768: { 768: [null, 230], 769: [null, 230], 770: [null, 230], 771: [null, 230], 772: [null, 230], 773: [null, 230], 774: [null, 230], 775: [null, 230], 776: [null, 230, { 769: 836 }], 777: [null, 230], 778: [null, 230], 779: [null, 230], 780: [null, 230], 781: [null, 230], 782: [null, 230], 783: [null, 230], 784: [null, 230], 785: [null, 230], 786: [null, 230], 787: [null, 230], 788: [null, 230], 789: [null, 232], 790: [null, 220], 791: [null, 220], 792: [null, 220], 793: [null, 220], 794: [null, 232], 795: [null, 216], 796: [null, 220], 797: [null, 220], 798: [null, 220], 799: [null, 220], 800: [null, 220], 801: [null, 202], 802: [null, 202], 803: [null, 220], 804: [null, 220], 805: [null, 220], 806: [null, 220], 807: [null, 202], 808: [null, 202], 809: [null, 220], 810: [null, 220], 811: [null, 220], 812: [null, 220], 813: [null, 220], 814: [null, 220], 815: [null, 220], 816: [null, 220], 817: [null, 220], 818: [null, 220], 819: [null, 220], 820: [null, 1], 821: [null, 1], 822: [null, 1], 823: [null, 1], 824: [null, 1], 825: [null, 220], 826: [null, 220], 827: [null, 220], 828: [null, 220], 829: [null, 230], 830: [null, 230], 831: [null, 230], 832: [[768], 230], 833: [[769], 230], 834: [null, 230], 835: [[787], 230], 836: [[776, 769], 230], 837: [null, 240], 838: [null, 230], 839: [null, 220], 840: [null, 220], 841: [null, 220], 842: [null, 230], 843: [null, 230], 844: [null, 230], 845: [null, 220], 846: [null, 220], 848: [null, 230], 849: [null, 230], 850: [null, 230], 851: [null, 220], 852: [null, 220], 853: [null, 220], 854: [null, 220], 855: [null, 230], 856: [null, 232], 857: [null, 220], 858: [null, 220], 859: [null, 230], 860: [null, 233], 861: [null, 234], 862: [null, 234], 863: [null, 233], 864: [null, 234], 865: [null, 234], 866: [null, 233], 867: [null, 230], 868: [null, 230], 869: [null, 230], 870: [null, 230], 871: [null, 230], 872: [null, 230], 873: [null, 230], 874: [null, 230], 875: [null, 230], 876: [null, 230], 877: [null, 230], 878: [null, 230], 879: [null, 230], 884: [[697]], 890: [[32, 837], 256], 894: [[59]], 900: [[32, 769], 256], 901: [[168, 769]], 902: [[913, 769]], 903: [[183]], 904: [[917, 769]], 905: [[919, 769]], 906: [[921, 769]], 908: [[927, 769]], 910: [[933, 769]], 911: [[937, 769]], 912: [[970, 769]], 913: [null, null, { 768: 8122, 769: 902, 772: 8121, 774: 8120, 787: 7944, 788: 7945, 837: 8124 }], 917: [null, null, { 768: 8136, 769: 904, 787: 7960, 788: 7961 }], 919: [null, null, { 768: 8138, 769: 905, 787: 7976, 788: 7977, 837: 8140 }], 921: [null, null, { 768: 8154, 769: 906, 772: 8153, 774: 8152, 776: 938, 787: 7992, 788: 7993 }], 927: [null, null, { 768: 8184, 769: 908, 787: 8008, 788: 8009 }], 929: [null, null, { 788: 8172 }], 933: [null, null, { 768: 8170, 769: 910, 772: 8169, 774: 8168, 776: 939, 788: 8025 }], 937: [null, null, { 768: 8186, 769: 911, 787: 8040, 788: 8041, 837: 8188 }], 938: [[921, 776]], 939: [[933, 776]], 940: [[945, 769], null, { 837: 8116 }], 941: [[949, 769]], 942: [[951, 769], null, { 837: 8132 }], 943: [[953, 769]], 944: [[971, 769]], 945: [null, null, { 768: 8048, 769: 940, 772: 8113, 774: 8112, 787: 7936, 788: 7937, 834: 8118, 837: 8115 }], 949: [null, null, { 768: 8050, 769: 941, 787: 7952, 788: 7953 }], 951: [null, null, { 768: 8052, 769: 942, 787: 7968, 788: 7969, 834: 8134, 837: 8131 }], 953: [null, null, { 768: 8054, 769: 943, 772: 8145, 774: 8144, 776: 970, 787: 7984, 788: 7985, 834: 8150 }], 959: [null, null, { 768: 8056, 769: 972, 787: 8e3, 788: 8001 }], 961: [null, null, { 787: 8164, 788: 8165 }], 965: [null, null, { 768: 8058, 769: 973, 772: 8161, 774: 8160, 776: 971, 787: 8016, 788: 8017, 834: 8166 }], 969: [null, null, { 768: 8060, 769: 974, 787: 8032, 788: 8033, 834: 8182, 837: 8179 }], 970: [[953, 776], null, { 768: 8146, 769: 912, 834: 8151 }], 971: [[965, 776], null, { 768: 8162, 769: 944, 834: 8167 }], 972: [[959, 769]], 973: [[965, 769]], 974: [[969, 769], null, { 837: 8180 }], 976: [[946], 256], 977: [[952], 256], 978: [[933], 256, { 769: 979, 776: 980 }], 979: [[978, 769]], 980: [[978, 776]], 981: [[966], 256], 982: [[960], 256], 1008: [[954], 256], 1009: [[961], 256], 1010: [[962], 256], 1012: [[920], 256], 1013: [[949], 256], 1017: [[931], 256], 66422: [null, 230], 66423: [null, 230], 66424: [null, 230], 66425: [null, 230], 66426: [null, 230] },
  1024: { 1024: [[1045, 768]], 1025: [[1045, 776]], 1027: [[1043, 769]], 1030: [null, null, { 776: 1031 }], 1031: [[1030, 776]], 1036: [[1050, 769]], 1037: [[1048, 768]], 1038: [[1059, 774]], 1040: [null, null, { 774: 1232, 776: 1234 }], 1043: [null, null, { 769: 1027 }], 1045: [null, null, { 768: 1024, 774: 1238, 776: 1025 }], 1046: [null, null, { 774: 1217, 776: 1244 }], 1047: [null, null, { 776: 1246 }], 1048: [null, null, { 768: 1037, 772: 1250, 774: 1049, 776: 1252 }], 1049: [[1048, 774]], 1050: [null, null, { 769: 1036 }], 1054: [null, null, { 776: 1254 }], 1059: [null, null, { 772: 1262, 774: 1038, 776: 1264, 779: 1266 }], 1063: [null, null, { 776: 1268 }], 1067: [null, null, { 776: 1272 }], 1069: [null, null, { 776: 1260 }], 1072: [null, null, { 774: 1233, 776: 1235 }], 1075: [null, null, { 769: 1107 }], 1077: [null, null, { 768: 1104, 774: 1239, 776: 1105 }], 1078: [null, null, { 774: 1218, 776: 1245 }], 1079: [null, null, { 776: 1247 }], 1080: [null, null, { 768: 1117, 772: 1251, 774: 1081, 776: 1253 }], 1081: [[1080, 774]], 1082: [null, null, { 769: 1116 }], 1086: [null, null, { 776: 1255 }], 1091: [null, null, { 772: 1263, 774: 1118, 776: 1265, 779: 1267 }], 1095: [null, null, { 776: 1269 }], 1099: [null, null, { 776: 1273 }], 1101: [null, null, { 776: 1261 }], 1104: [[1077, 768]], 1105: [[1077, 776]], 1107: [[1075, 769]], 1110: [null, null, { 776: 1111 }], 1111: [[1110, 776]], 1116: [[1082, 769]], 1117: [[1080, 768]], 1118: [[1091, 774]], 1140: [null, null, { 783: 1142 }], 1141: [null, null, { 783: 1143 }], 1142: [[1140, 783]], 1143: [[1141, 783]], 1155: [null, 230], 1156: [null, 230], 1157: [null, 230], 1158: [null, 230], 1159: [null, 230], 1217: [[1046, 774]], 1218: [[1078, 774]], 1232: [[1040, 774]], 1233: [[1072, 774]], 1234: [[1040, 776]], 1235: [[1072, 776]], 1238: [[1045, 774]], 1239: [[1077, 774]], 1240: [null, null, { 776: 1242 }], 1241: [null, null, { 776: 1243 }], 1242: [[1240, 776]], 1243: [[1241, 776]], 1244: [[1046, 776]], 1245: [[1078, 776]], 1246: [[1047, 776]], 1247: [[1079, 776]], 1250: [[1048, 772]], 1251: [[1080, 772]], 1252: [[1048, 776]], 1253: [[1080, 776]], 1254: [[1054, 776]], 1255: [[1086, 776]], 1256: [null, null, { 776: 1258 }], 1257: [null, null, { 776: 1259 }], 1258: [[1256, 776]], 1259: [[1257, 776]], 1260: [[1069, 776]], 1261: [[1101, 776]], 1262: [[1059, 772]], 1263: [[1091, 772]], 1264: [[1059, 776]], 1265: [[1091, 776]], 1266: [[1059, 779]], 1267: [[1091, 779]], 1268: [[1063, 776]], 1269: [[1095, 776]], 1272: [[1067, 776]], 1273: [[1099, 776]] },
  1280: { 1415: [[1381, 1410], 256], 1425: [null, 220], 1426: [null, 230], 1427: [null, 230], 1428: [null, 230], 1429: [null, 230], 1430: [null, 220], 1431: [null, 230], 1432: [null, 230], 1433: [null, 230], 1434: [null, 222], 1435: [null, 220], 1436: [null, 230], 1437: [null, 230], 1438: [null, 230], 1439: [null, 230], 1440: [null, 230], 1441: [null, 230], 1442: [null, 220], 1443: [null, 220], 1444: [null, 220], 1445: [null, 220], 1446: [null, 220], 1447: [null, 220], 1448: [null, 230], 1449: [null, 230], 1450: [null, 220], 1451: [null, 230], 1452: [null, 230], 1453: [null, 222], 1454: [null, 228], 1455: [null, 230], 1456: [null, 10], 1457: [null, 11], 1458: [null, 12], 1459: [null, 13], 1460: [null, 14], 1461: [null, 15], 1462: [null, 16], 1463: [null, 17], 1464: [null, 18], 1465: [null, 19], 1466: [null, 19], 1467: [null, 20], 1468: [null, 21], 1469: [null, 22], 1471: [null, 23], 1473: [null, 24], 1474: [null, 25], 1476: [null, 230], 1477: [null, 220], 1479: [null, 18] },
  1536: { 1552: [null, 230], 1553: [null, 230], 1554: [null, 230], 1555: [null, 230], 1556: [null, 230], 1557: [null, 230], 1558: [null, 230], 1559: [null, 230], 1560: [null, 30], 1561: [null, 31], 1562: [null, 32], 1570: [[1575, 1619]], 1571: [[1575, 1620]], 1572: [[1608, 1620]], 1573: [[1575, 1621]], 1574: [[1610, 1620]], 1575: [null, null, { 1619: 1570, 1620: 1571, 1621: 1573 }], 1608: [null, null, { 1620: 1572 }], 1610: [null, null, { 1620: 1574 }], 1611: [null, 27], 1612: [null, 28], 1613: [null, 29], 1614: [null, 30], 1615: [null, 31], 1616: [null, 32], 1617: [null, 33], 1618: [null, 34], 1619: [null, 230], 1620: [null, 230], 1621: [null, 220], 1622: [null, 220], 1623: [null, 230], 1624: [null, 230], 1625: [null, 230], 1626: [null, 230], 1627: [null, 230], 1628: [null, 220], 1629: [null, 230], 1630: [null, 230], 1631: [null, 220], 1648: [null, 35], 1653: [[1575, 1652], 256], 1654: [[1608, 1652], 256], 1655: [[1735, 1652], 256], 1656: [[1610, 1652], 256], 1728: [[1749, 1620]], 1729: [null, null, { 1620: 1730 }], 1730: [[1729, 1620]], 1746: [null, null, { 1620: 1747 }], 1747: [[1746, 1620]], 1749: [null, null, { 1620: 1728 }], 1750: [null, 230], 1751: [null, 230], 1752: [null, 230], 1753: [null, 230], 1754: [null, 230], 1755: [null, 230], 1756: [null, 230], 1759: [null, 230], 1760: [null, 230], 1761: [null, 230], 1762: [null, 230], 1763: [null, 220], 1764: [null, 230], 1767: [null, 230], 1768: [null, 230], 1770: [null, 220], 1771: [null, 230], 1772: [null, 230], 1773: [null, 220] },
  1792: { 1809: [null, 36], 1840: [null, 230], 1841: [null, 220], 1842: [null, 230], 1843: [null, 230], 1844: [null, 220], 1845: [null, 230], 1846: [null, 230], 1847: [null, 220], 1848: [null, 220], 1849: [null, 220], 1850: [null, 230], 1851: [null, 220], 1852: [null, 220], 1853: [null, 230], 1854: [null, 220], 1855: [null, 230], 1856: [null, 230], 1857: [null, 230], 1858: [null, 220], 1859: [null, 230], 1860: [null, 220], 1861: [null, 230], 1862: [null, 220], 1863: [null, 230], 1864: [null, 220], 1865: [null, 230], 1866: [null, 230], 2027: [null, 230], 2028: [null, 230], 2029: [null, 230], 2030: [null, 230], 2031: [null, 230], 2032: [null, 230], 2033: [null, 230], 2034: [null, 220], 2035: [null, 230] },
  2048: { 2070: [null, 230], 2071: [null, 230], 2072: [null, 230], 2073: [null, 230], 2075: [null, 230], 2076: [null, 230], 2077: [null, 230], 2078: [null, 230], 2079: [null, 230], 2080: [null, 230], 2081: [null, 230], 2082: [null, 230], 2083: [null, 230], 2085: [null, 230], 2086: [null, 230], 2087: [null, 230], 2089: [null, 230], 2090: [null, 230], 2091: [null, 230], 2092: [null, 230], 2093: [null, 230], 2137: [null, 220], 2138: [null, 220], 2139: [null, 220], 2276: [null, 230], 2277: [null, 230], 2278: [null, 220], 2279: [null, 230], 2280: [null, 230], 2281: [null, 220], 2282: [null, 230], 2283: [null, 230], 2284: [null, 230], 2285: [null, 220], 2286: [null, 220], 2287: [null, 220], 2288: [null, 27], 2289: [null, 28], 2290: [null, 29], 2291: [null, 230], 2292: [null, 230], 2293: [null, 230], 2294: [null, 220], 2295: [null, 230], 2296: [null, 230], 2297: [null, 220], 2298: [null, 220], 2299: [null, 230], 2300: [null, 230], 2301: [null, 230], 2302: [null, 230], 2303: [null, 230] },
  2304: { 2344: [null, null, { 2364: 2345 }], 2345: [[2344, 2364]], 2352: [null, null, { 2364: 2353 }], 2353: [[2352, 2364]], 2355: [null, null, { 2364: 2356 }], 2356: [[2355, 2364]], 2364: [null, 7], 2381: [null, 9], 2385: [null, 230], 2386: [null, 220], 2387: [null, 230], 2388: [null, 230], 2392: [[2325, 2364], 512], 2393: [[2326, 2364], 512], 2394: [[2327, 2364], 512], 2395: [[2332, 2364], 512], 2396: [[2337, 2364], 512], 2397: [[2338, 2364], 512], 2398: [[2347, 2364], 512], 2399: [[2351, 2364], 512], 2492: [null, 7], 2503: [null, null, { 2494: 2507, 2519: 2508 }], 2507: [[2503, 2494]], 2508: [[2503, 2519]], 2509: [null, 9], 2524: [[2465, 2492], 512], 2525: [[2466, 2492], 512], 2527: [[2479, 2492], 512] },
  2560: { 2611: [[2610, 2620], 512], 2614: [[2616, 2620], 512], 2620: [null, 7], 2637: [null, 9], 2649: [[2582, 2620], 512], 2650: [[2583, 2620], 512], 2651: [[2588, 2620], 512], 2654: [[2603, 2620], 512], 2748: [null, 7], 2765: [null, 9], 68109: [null, 220], 68111: [null, 230], 68152: [null, 230], 68153: [null, 1], 68154: [null, 220], 68159: [null, 9], 68325: [null, 230], 68326: [null, 220] },
  2816: { 2876: [null, 7], 2887: [null, null, { 2878: 2891, 2902: 2888, 2903: 2892 }], 2888: [[2887, 2902]], 2891: [[2887, 2878]], 2892: [[2887, 2903]], 2893: [null, 9], 2908: [[2849, 2876], 512], 2909: [[2850, 2876], 512], 2962: [null, null, { 3031: 2964 }], 2964: [[2962, 3031]], 3014: [null, null, { 3006: 3018, 3031: 3020 }], 3015: [null, null, { 3006: 3019 }], 3018: [[3014, 3006]], 3019: [[3015, 3006]], 3020: [[3014, 3031]], 3021: [null, 9] },
  3072: { 3142: [null, null, { 3158: 3144 }], 3144: [[3142, 3158]], 3149: [null, 9], 3157: [null, 84], 3158: [null, 91], 3260: [null, 7], 3263: [null, null, { 3285: 3264 }], 3264: [[3263, 3285]], 3270: [null, null, { 3266: 3274, 3285: 3271, 3286: 3272 }], 3271: [[3270, 3285]], 3272: [[3270, 3286]], 3274: [[3270, 3266], null, { 3285: 3275 }], 3275: [[3274, 3285]], 3277: [null, 9] },
  3328: { 3398: [null, null, { 3390: 3402, 3415: 3404 }], 3399: [null, null, { 3390: 3403 }], 3402: [[3398, 3390]], 3403: [[3399, 3390]], 3404: [[3398, 3415]], 3405: [null, 9], 3530: [null, 9], 3545: [null, null, { 3530: 3546, 3535: 3548, 3551: 3550 }], 3546: [[3545, 3530]], 3548: [[3545, 3535], null, { 3530: 3549 }], 3549: [[3548, 3530]], 3550: [[3545, 3551]] },
  3584: { 3635: [[3661, 3634], 256], 3640: [null, 103], 3641: [null, 103], 3642: [null, 9], 3656: [null, 107], 3657: [null, 107], 3658: [null, 107], 3659: [null, 107], 3763: [[3789, 3762], 256], 3768: [null, 118], 3769: [null, 118], 3784: [null, 122], 3785: [null, 122], 3786: [null, 122], 3787: [null, 122], 3804: [[3755, 3737], 256], 3805: [[3755, 3745], 256] },
  3840: { 3852: [[3851], 256], 3864: [null, 220], 3865: [null, 220], 3893: [null, 220], 3895: [null, 220], 3897: [null, 216], 3907: [[3906, 4023], 512], 3917: [[3916, 4023], 512], 3922: [[3921, 4023], 512], 3927: [[3926, 4023], 512], 3932: [[3931, 4023], 512], 3945: [[3904, 4021], 512], 3953: [null, 129], 3954: [null, 130], 3955: [[3953, 3954], 512], 3956: [null, 132], 3957: [[3953, 3956], 512], 3958: [[4018, 3968], 512], 3959: [[4018, 3969], 256], 3960: [[4019, 3968], 512], 3961: [[4019, 3969], 256], 3962: [null, 130], 3963: [null, 130], 3964: [null, 130], 3965: [null, 130], 3968: [null, 130], 3969: [[3953, 3968], 512], 3970: [null, 230], 3971: [null, 230], 3972: [null, 9], 3974: [null, 230], 3975: [null, 230], 3987: [[3986, 4023], 512], 3997: [[3996, 4023], 512], 4002: [[4001, 4023], 512], 4007: [[4006, 4023], 512], 4012: [[4011, 4023], 512], 4025: [[3984, 4021], 512], 4038: [null, 220] },
  4096: { 4133: [null, null, { 4142: 4134 }], 4134: [[4133, 4142]], 4151: [null, 7], 4153: [null, 9], 4154: [null, 9], 4237: [null, 220], 4348: [[4316], 256], 69702: [null, 9], 69759: [null, 9], 69785: [null, null, { 69818: 69786 }], 69786: [[69785, 69818]], 69787: [null, null, { 69818: 69788 }], 69788: [[69787, 69818]], 69797: [null, null, { 69818: 69803 }], 69803: [[69797, 69818]], 69817: [null, 9], 69818: [null, 7] },
  4352: { 69888: [null, 230], 69889: [null, 230], 69890: [null, 230], 69934: [[69937, 69927]], 69935: [[69938, 69927]], 69937: [null, null, { 69927: 69934 }], 69938: [null, null, { 69927: 69935 }], 69939: [null, 9], 69940: [null, 9], 70003: [null, 7], 70080: [null, 9] },
  4608: { 70197: [null, 9], 70198: [null, 7], 70377: [null, 7], 70378: [null, 9] },
  4864: { 4957: [null, 230], 4958: [null, 230], 4959: [null, 230], 70460: [null, 7], 70471: [null, null, { 70462: 70475, 70487: 70476 }], 70475: [[70471, 70462]], 70476: [[70471, 70487]], 70477: [null, 9], 70502: [null, 230], 70503: [null, 230], 70504: [null, 230], 70505: [null, 230], 70506: [null, 230], 70507: [null, 230], 70508: [null, 230], 70512: [null, 230], 70513: [null, 230], 70514: [null, 230], 70515: [null, 230], 70516: [null, 230] },
  5120: { 70841: [null, null, { 70832: 70844, 70842: 70843, 70845: 70846 }], 70843: [[70841, 70842]], 70844: [[70841, 70832]], 70846: [[70841, 70845]], 70850: [null, 9], 70851: [null, 7] },
  5376: { 71096: [null, null, { 71087: 71098 }], 71097: [null, null, { 71087: 71099 }], 71098: [[71096, 71087]], 71099: [[71097, 71087]], 71103: [null, 9], 71104: [null, 7] },
  5632: { 71231: [null, 9], 71350: [null, 9], 71351: [null, 7] },
  5888: { 5908: [null, 9], 5940: [null, 9], 6098: [null, 9], 6109: [null, 230] },
  6144: { 6313: [null, 228] },
  6400: { 6457: [null, 222], 6458: [null, 230], 6459: [null, 220] },
  6656: { 6679: [null, 230], 6680: [null, 220], 6752: [null, 9], 6773: [null, 230], 6774: [null, 230], 6775: [null, 230], 6776: [null, 230], 6777: [null, 230], 6778: [null, 230], 6779: [null, 230], 6780: [null, 230], 6783: [null, 220], 6832: [null, 230], 6833: [null, 230], 6834: [null, 230], 6835: [null, 230], 6836: [null, 230], 6837: [null, 220], 6838: [null, 220], 6839: [null, 220], 6840: [null, 220], 6841: [null, 220], 6842: [null, 220], 6843: [null, 230], 6844: [null, 230], 6845: [null, 220] },
  6912: { 6917: [null, null, { 6965: 6918 }], 6918: [[6917, 6965]], 6919: [null, null, { 6965: 6920 }], 6920: [[6919, 6965]], 6921: [null, null, { 6965: 6922 }], 6922: [[6921, 6965]], 6923: [null, null, { 6965: 6924 }], 6924: [[6923, 6965]], 6925: [null, null, { 6965: 6926 }], 6926: [[6925, 6965]], 6929: [null, null, { 6965: 6930 }], 6930: [[6929, 6965]], 6964: [null, 7], 6970: [null, null, { 6965: 6971 }], 6971: [[6970, 6965]], 6972: [null, null, { 6965: 6973 }], 6973: [[6972, 6965]], 6974: [null, null, { 6965: 6976 }], 6975: [null, null, { 6965: 6977 }], 6976: [[6974, 6965]], 6977: [[6975, 6965]], 6978: [null, null, { 6965: 6979 }], 6979: [[6978, 6965]], 6980: [null, 9], 7019: [null, 230], 7020: [null, 220], 7021: [null, 230], 7022: [null, 230], 7023: [null, 230], 7024: [null, 230], 7025: [null, 230], 7026: [null, 230], 7027: [null, 230], 7082: [null, 9], 7083: [null, 9], 7142: [null, 7], 7154: [null, 9], 7155: [null, 9] },
  7168: { 7223: [null, 7], 7376: [null, 230], 7377: [null, 230], 7378: [null, 230], 7380: [null, 1], 7381: [null, 220], 7382: [null, 220], 7383: [null, 220], 7384: [null, 220], 7385: [null, 220], 7386: [null, 230], 7387: [null, 230], 7388: [null, 220], 7389: [null, 220], 7390: [null, 220], 7391: [null, 220], 7392: [null, 230], 7394: [null, 1], 7395: [null, 1], 7396: [null, 1], 7397: [null, 1], 7398: [null, 1], 7399: [null, 1], 7400: [null, 1], 7405: [null, 220], 7412: [null, 230], 7416: [null, 230], 7417: [null, 230] },
  7424: { 7468: [[65], 256], 7469: [[198], 256], 7470: [[66], 256], 7472: [[68], 256], 7473: [[69], 256], 7474: [[398], 256], 7475: [[71], 256], 7476: [[72], 256], 7477: [[73], 256], 7478: [[74], 256], 7479: [[75], 256], 7480: [[76], 256], 7481: [[77], 256], 7482: [[78], 256], 7484: [[79], 256], 7485: [[546], 256], 7486: [[80], 256], 7487: [[82], 256], 7488: [[84], 256], 7489: [[85], 256], 7490: [[87], 256], 7491: [[97], 256], 7492: [[592], 256], 7493: [[593], 256], 7494: [[7426], 256], 7495: [[98], 256], 7496: [[100], 256], 7497: [[101], 256], 7498: [[601], 256], 7499: [[603], 256], 7500: [[604], 256], 7501: [[103], 256], 7503: [[107], 256], 7504: [[109], 256], 7505: [[331], 256], 7506: [[111], 256], 7507: [[596], 256], 7508: [[7446], 256], 7509: [[7447], 256], 7510: [[112], 256], 7511: [[116], 256], 7512: [[117], 256], 7513: [[7453], 256], 7514: [[623], 256], 7515: [[118], 256], 7516: [[7461], 256], 7517: [[946], 256], 7518: [[947], 256], 7519: [[948], 256], 7520: [[966], 256], 7521: [[967], 256], 7522: [[105], 256], 7523: [[114], 256], 7524: [[117], 256], 7525: [[118], 256], 7526: [[946], 256], 7527: [[947], 256], 7528: [[961], 256], 7529: [[966], 256], 7530: [[967], 256], 7544: [[1085], 256], 7579: [[594], 256], 7580: [[99], 256], 7581: [[597], 256], 7582: [[240], 256], 7583: [[604], 256], 7584: [[102], 256], 7585: [[607], 256], 7586: [[609], 256], 7587: [[613], 256], 7588: [[616], 256], 7589: [[617], 256], 7590: [[618], 256], 7591: [[7547], 256], 7592: [[669], 256], 7593: [[621], 256], 7594: [[7557], 256], 7595: [[671], 256], 7596: [[625], 256], 7597: [[624], 256], 7598: [[626], 256], 7599: [[627], 256], 7600: [[628], 256], 7601: [[629], 256], 7602: [[632], 256], 7603: [[642], 256], 7604: [[643], 256], 7605: [[427], 256], 7606: [[649], 256], 7607: [[650], 256], 7608: [[7452], 256], 7609: [[651], 256], 7610: [[652], 256], 7611: [[122], 256], 7612: [[656], 256], 7613: [[657], 256], 7614: [[658], 256], 7615: [[952], 256], 7616: [null, 230], 7617: [null, 230], 7618: [null, 220], 7619: [null, 230], 7620: [null, 230], 7621: [null, 230], 7622: [null, 230], 7623: [null, 230], 7624: [null, 230], 7625: [null, 230], 7626: [null, 220], 7627: [null, 230], 7628: [null, 230], 7629: [null, 234], 7630: [null, 214], 7631: [null, 220], 7632: [null, 202], 7633: [null, 230], 7634: [null, 230], 7635: [null, 230], 7636: [null, 230], 7637: [null, 230], 7638: [null, 230], 7639: [null, 230], 7640: [null, 230], 7641: [null, 230], 7642: [null, 230], 7643: [null, 230], 7644: [null, 230], 7645: [null, 230], 7646: [null, 230], 7647: [null, 230], 7648: [null, 230], 7649: [null, 230], 7650: [null, 230], 7651: [null, 230], 7652: [null, 230], 7653: [null, 230], 7654: [null, 230], 7655: [null, 230], 7656: [null, 230], 7657: [null, 230], 7658: [null, 230], 7659: [null, 230], 7660: [null, 230], 7661: [null, 230], 7662: [null, 230], 7663: [null, 230], 7664: [null, 230], 7665: [null, 230], 7666: [null, 230], 7667: [null, 230], 7668: [null, 230], 7669: [null, 230], 7676: [null, 233], 7677: [null, 220], 7678: [null, 230], 7679: [null, 220] },
  7680: { 7680: [[65, 805]], 7681: [[97, 805]], 7682: [[66, 775]], 7683: [[98, 775]], 7684: [[66, 803]], 7685: [[98, 803]], 7686: [[66, 817]], 7687: [[98, 817]], 7688: [[199, 769]], 7689: [[231, 769]], 7690: [[68, 775]], 7691: [[100, 775]], 7692: [[68, 803]], 7693: [[100, 803]], 7694: [[68, 817]], 7695: [[100, 817]], 7696: [[68, 807]], 7697: [[100, 807]], 7698: [[68, 813]], 7699: [[100, 813]], 7700: [[274, 768]], 7701: [[275, 768]], 7702: [[274, 769]], 7703: [[275, 769]], 7704: [[69, 813]], 7705: [[101, 813]], 7706: [[69, 816]], 7707: [[101, 816]], 7708: [[552, 774]], 7709: [[553, 774]], 7710: [[70, 775]], 7711: [[102, 775]], 7712: [[71, 772]], 7713: [[103, 772]], 7714: [[72, 775]], 7715: [[104, 775]], 7716: [[72, 803]], 7717: [[104, 803]], 7718: [[72, 776]], 7719: [[104, 776]], 7720: [[72, 807]], 7721: [[104, 807]], 7722: [[72, 814]], 7723: [[104, 814]], 7724: [[73, 816]], 7725: [[105, 816]], 7726: [[207, 769]], 7727: [[239, 769]], 7728: [[75, 769]], 7729: [[107, 769]], 7730: [[75, 803]], 7731: [[107, 803]], 7732: [[75, 817]], 7733: [[107, 817]], 7734: [[76, 803], null, { 772: 7736 }], 7735: [[108, 803], null, { 772: 7737 }], 7736: [[7734, 772]], 7737: [[7735, 772]], 7738: [[76, 817]], 7739: [[108, 817]], 7740: [[76, 813]], 7741: [[108, 813]], 7742: [[77, 769]], 7743: [[109, 769]], 7744: [[77, 775]], 7745: [[109, 775]], 7746: [[77, 803]], 7747: [[109, 803]], 7748: [[78, 775]], 7749: [[110, 775]], 7750: [[78, 803]], 7751: [[110, 803]], 7752: [[78, 817]], 7753: [[110, 817]], 7754: [[78, 813]], 7755: [[110, 813]], 7756: [[213, 769]], 7757: [[245, 769]], 7758: [[213, 776]], 7759: [[245, 776]], 7760: [[332, 768]], 7761: [[333, 768]], 7762: [[332, 769]], 7763: [[333, 769]], 7764: [[80, 769]], 7765: [[112, 769]], 7766: [[80, 775]], 7767: [[112, 775]], 7768: [[82, 775]], 7769: [[114, 775]], 7770: [[82, 803], null, { 772: 7772 }], 7771: [[114, 803], null, { 772: 7773 }], 7772: [[7770, 772]], 7773: [[7771, 772]], 7774: [[82, 817]], 7775: [[114, 817]], 7776: [[83, 775]], 7777: [[115, 775]], 7778: [[83, 803], null, { 775: 7784 }], 7779: [[115, 803], null, { 775: 7785 }], 7780: [[346, 775]], 7781: [[347, 775]], 7782: [[352, 775]], 7783: [[353, 775]], 7784: [[7778, 775]], 7785: [[7779, 775]], 7786: [[84, 775]], 7787: [[116, 775]], 7788: [[84, 803]], 7789: [[116, 803]], 7790: [[84, 817]], 7791: [[116, 817]], 7792: [[84, 813]], 7793: [[116, 813]], 7794: [[85, 804]], 7795: [[117, 804]], 7796: [[85, 816]], 7797: [[117, 816]], 7798: [[85, 813]], 7799: [[117, 813]], 7800: [[360, 769]], 7801: [[361, 769]], 7802: [[362, 776]], 7803: [[363, 776]], 7804: [[86, 771]], 7805: [[118, 771]], 7806: [[86, 803]], 7807: [[118, 803]], 7808: [[87, 768]], 7809: [[119, 768]], 7810: [[87, 769]], 7811: [[119, 769]], 7812: [[87, 776]], 7813: [[119, 776]], 7814: [[87, 775]], 7815: [[119, 775]], 7816: [[87, 803]], 7817: [[119, 803]], 7818: [[88, 775]], 7819: [[120, 775]], 7820: [[88, 776]], 7821: [[120, 776]], 7822: [[89, 775]], 7823: [[121, 775]], 7824: [[90, 770]], 7825: [[122, 770]], 7826: [[90, 803]], 7827: [[122, 803]], 7828: [[90, 817]], 7829: [[122, 817]], 7830: [[104, 817]], 7831: [[116, 776]], 7832: [[119, 778]], 7833: [[121, 778]], 7834: [[97, 702], 256], 7835: [[383, 775]], 7840: [[65, 803], null, { 770: 7852, 774: 7862 }], 7841: [[97, 803], null, { 770: 7853, 774: 7863 }], 7842: [[65, 777]], 7843: [[97, 777]], 7844: [[194, 769]], 7845: [[226, 769]], 7846: [[194, 768]], 7847: [[226, 768]], 7848: [[194, 777]], 7849: [[226, 777]], 7850: [[194, 771]], 7851: [[226, 771]], 7852: [[7840, 770]], 7853: [[7841, 770]], 7854: [[258, 769]], 7855: [[259, 769]], 7856: [[258, 768]], 7857: [[259, 768]], 7858: [[258, 777]], 7859: [[259, 777]], 7860: [[258, 771]], 7861: [[259, 771]], 7862: [[7840, 774]], 7863: [[7841, 774]], 7864: [[69, 803], null, { 770: 7878 }], 7865: [[101, 803], null, { 770: 7879 }], 7866: [[69, 777]], 7867: [[101, 777]], 7868: [[69, 771]], 7869: [[101, 771]], 7870: [[202, 769]], 7871: [[234, 769]], 7872: [[202, 768]], 7873: [[234, 768]], 7874: [[202, 777]], 7875: [[234, 777]], 7876: [[202, 771]], 7877: [[234, 771]], 7878: [[7864, 770]], 7879: [[7865, 770]], 7880: [[73, 777]], 7881: [[105, 777]], 7882: [[73, 803]], 7883: [[105, 803]], 7884: [[79, 803], null, { 770: 7896 }], 7885: [[111, 803], null, { 770: 7897 }], 7886: [[79, 777]], 7887: [[111, 777]], 7888: [[212, 769]], 7889: [[244, 769]], 7890: [[212, 768]], 7891: [[244, 768]], 7892: [[212, 777]], 7893: [[244, 777]], 7894: [[212, 771]], 7895: [[244, 771]], 7896: [[7884, 770]], 7897: [[7885, 770]], 7898: [[416, 769]], 7899: [[417, 769]], 7900: [[416, 768]], 7901: [[417, 768]], 7902: [[416, 777]], 7903: [[417, 777]], 7904: [[416, 771]], 7905: [[417, 771]], 7906: [[416, 803]], 7907: [[417, 803]], 7908: [[85, 803]], 7909: [[117, 803]], 7910: [[85, 777]], 7911: [[117, 777]], 7912: [[431, 769]], 7913: [[432, 769]], 7914: [[431, 768]], 7915: [[432, 768]], 7916: [[431, 777]], 7917: [[432, 777]], 7918: [[431, 771]], 7919: [[432, 771]], 7920: [[431, 803]], 7921: [[432, 803]], 7922: [[89, 768]], 7923: [[121, 768]], 7924: [[89, 803]], 7925: [[121, 803]], 7926: [[89, 777]], 7927: [[121, 777]], 7928: [[89, 771]], 7929: [[121, 771]] },
  7936: { 7936: [[945, 787], null, { 768: 7938, 769: 7940, 834: 7942, 837: 8064 }], 7937: [[945, 788], null, { 768: 7939, 769: 7941, 834: 7943, 837: 8065 }], 7938: [[7936, 768], null, { 837: 8066 }], 7939: [[7937, 768], null, { 837: 8067 }], 7940: [[7936, 769], null, { 837: 8068 }], 7941: [[7937, 769], null, { 837: 8069 }], 7942: [[7936, 834], null, { 837: 8070 }], 7943: [[7937, 834], null, { 837: 8071 }], 7944: [[913, 787], null, { 768: 7946, 769: 7948, 834: 7950, 837: 8072 }], 7945: [[913, 788], null, { 768: 7947, 769: 7949, 834: 7951, 837: 8073 }], 7946: [[7944, 768], null, { 837: 8074 }], 7947: [[7945, 768], null, { 837: 8075 }], 7948: [[7944, 769], null, { 837: 8076 }], 7949: [[7945, 769], null, { 837: 8077 }], 7950: [[7944, 834], null, { 837: 8078 }], 7951: [[7945, 834], null, { 837: 8079 }], 7952: [[949, 787], null, { 768: 7954, 769: 7956 }], 7953: [[949, 788], null, { 768: 7955, 769: 7957 }], 7954: [[7952, 768]], 7955: [[7953, 768]], 7956: [[7952, 769]], 7957: [[7953, 769]], 7960: [[917, 787], null, { 768: 7962, 769: 7964 }], 7961: [[917, 788], null, { 768: 7963, 769: 7965 }], 7962: [[7960, 768]], 7963: [[7961, 768]], 7964: [[7960, 769]], 7965: [[7961, 769]], 7968: [[951, 787], null, { 768: 7970, 769: 7972, 834: 7974, 837: 8080 }], 7969: [[951, 788], null, { 768: 7971, 769: 7973, 834: 7975, 837: 8081 }], 7970: [[7968, 768], null, { 837: 8082 }], 7971: [[7969, 768], null, { 837: 8083 }], 7972: [[7968, 769], null, { 837: 8084 }], 7973: [[7969, 769], null, { 837: 8085 }], 7974: [[7968, 834], null, { 837: 8086 }], 7975: [[7969, 834], null, { 837: 8087 }], 7976: [[919, 787], null, { 768: 7978, 769: 7980, 834: 7982, 837: 8088 }], 7977: [[919, 788], null, { 768: 7979, 769: 7981, 834: 7983, 837: 8089 }], 7978: [[7976, 768], null, { 837: 8090 }], 7979: [[7977, 768], null, { 837: 8091 }], 7980: [[7976, 769], null, { 837: 8092 }], 7981: [[7977, 769], null, { 837: 8093 }], 7982: [[7976, 834], null, { 837: 8094 }], 7983: [[7977, 834], null, { 837: 8095 }], 7984: [[953, 787], null, { 768: 7986, 769: 7988, 834: 7990 }], 7985: [[953, 788], null, { 768: 7987, 769: 7989, 834: 7991 }], 7986: [[7984, 768]], 7987: [[7985, 768]], 7988: [[7984, 769]], 7989: [[7985, 769]], 7990: [[7984, 834]], 7991: [[7985, 834]], 7992: [[921, 787], null, { 768: 7994, 769: 7996, 834: 7998 }], 7993: [[921, 788], null, { 768: 7995, 769: 7997, 834: 7999 }], 7994: [[7992, 768]], 7995: [[7993, 768]], 7996: [[7992, 769]], 7997: [[7993, 769]], 7998: [[7992, 834]], 7999: [[7993, 834]], 8e3: [[959, 787], null, { 768: 8002, 769: 8004 }], 8001: [[959, 788], null, { 768: 8003, 769: 8005 }], 8002: [[8e3, 768]], 8003: [[8001, 768]], 8004: [[8e3, 769]], 8005: [[8001, 769]], 8008: [[927, 787], null, { 768: 8010, 769: 8012 }], 8009: [[927, 788], null, { 768: 8011, 769: 8013 }], 8010: [[8008, 768]], 8011: [[8009, 768]], 8012: [[8008, 769]], 8013: [[8009, 769]], 8016: [[965, 787], null, { 768: 8018, 769: 8020, 834: 8022 }], 8017: [[965, 788], null, { 768: 8019, 769: 8021, 834: 8023 }], 8018: [[8016, 768]], 8019: [[8017, 768]], 8020: [[8016, 769]], 8021: [[8017, 769]], 8022: [[8016, 834]], 8023: [[8017, 834]], 8025: [[933, 788], null, { 768: 8027, 769: 8029, 834: 8031 }], 8027: [[8025, 768]], 8029: [[8025, 769]], 8031: [[8025, 834]], 8032: [[969, 787], null, { 768: 8034, 769: 8036, 834: 8038, 837: 8096 }], 8033: [[969, 788], null, { 768: 8035, 769: 8037, 834: 8039, 837: 8097 }], 8034: [[8032, 768], null, { 837: 8098 }], 8035: [[8033, 768], null, { 837: 8099 }], 8036: [[8032, 769], null, { 837: 8100 }], 8037: [[8033, 769], null, { 837: 8101 }], 8038: [[8032, 834], null, { 837: 8102 }], 8039: [[8033, 834], null, { 837: 8103 }], 8040: [[937, 787], null, { 768: 8042, 769: 8044, 834: 8046, 837: 8104 }], 8041: [[937, 788], null, { 768: 8043, 769: 8045, 834: 8047, 837: 8105 }], 8042: [[8040, 768], null, { 837: 8106 }], 8043: [[8041, 768], null, { 837: 8107 }], 8044: [[8040, 769], null, { 837: 8108 }], 8045: [[8041, 769], null, { 837: 8109 }], 8046: [[8040, 834], null, { 837: 8110 }], 8047: [[8041, 834], null, { 837: 8111 }], 8048: [[945, 768], null, { 837: 8114 }], 8049: [[940]], 8050: [[949, 768]], 8051: [[941]], 8052: [[951, 768], null, { 837: 8130 }], 8053: [[942]], 8054: [[953, 768]], 8055: [[943]], 8056: [[959, 768]], 8057: [[972]], 8058: [[965, 768]], 8059: [[973]], 8060: [[969, 768], null, { 837: 8178 }], 8061: [[974]], 8064: [[7936, 837]], 8065: [[7937, 837]], 8066: [[7938, 837]], 8067: [[7939, 837]], 8068: [[7940, 837]], 8069: [[7941, 837]], 8070: [[7942, 837]], 8071: [[7943, 837]], 8072: [[7944, 837]], 8073: [[7945, 837]], 8074: [[7946, 837]], 8075: [[7947, 837]], 8076: [[7948, 837]], 8077: [[7949, 837]], 8078: [[7950, 837]], 8079: [[7951, 837]], 8080: [[7968, 837]], 8081: [[7969, 837]], 8082: [[7970, 837]], 8083: [[7971, 837]], 8084: [[7972, 837]], 8085: [[7973, 837]], 8086: [[7974, 837]], 8087: [[7975, 837]], 8088: [[7976, 837]], 8089: [[7977, 837]], 8090: [[7978, 837]], 8091: [[7979, 837]], 8092: [[7980, 837]], 8093: [[7981, 837]], 8094: [[7982, 837]], 8095: [[7983, 837]], 8096: [[8032, 837]], 8097: [[8033, 837]], 8098: [[8034, 837]], 8099: [[8035, 837]], 8100: [[8036, 837]], 8101: [[8037, 837]], 8102: [[8038, 837]], 8103: [[8039, 837]], 8104: [[8040, 837]], 8105: [[8041, 837]], 8106: [[8042, 837]], 8107: [[8043, 837]], 8108: [[8044, 837]], 8109: [[8045, 837]], 8110: [[8046, 837]], 8111: [[8047, 837]], 8112: [[945, 774]], 8113: [[945, 772]], 8114: [[8048, 837]], 8115: [[945, 837]], 8116: [[940, 837]], 8118: [[945, 834], null, { 837: 8119 }], 8119: [[8118, 837]], 8120: [[913, 774]], 8121: [[913, 772]], 8122: [[913, 768]], 8123: [[902]], 8124: [[913, 837]], 8125: [[32, 787], 256], 8126: [[953]], 8127: [[32, 787], 256, { 768: 8141, 769: 8142, 834: 8143 }], 8128: [[32, 834], 256], 8129: [[168, 834]], 8130: [[8052, 837]], 8131: [[951, 837]], 8132: [[942, 837]], 8134: [[951, 834], null, { 837: 8135 }], 8135: [[8134, 837]], 8136: [[917, 768]], 8137: [[904]], 8138: [[919, 768]], 8139: [[905]], 8140: [[919, 837]], 8141: [[8127, 768]], 8142: [[8127, 769]], 8143: [[8127, 834]], 8144: [[953, 774]], 8145: [[953, 772]], 8146: [[970, 768]], 8147: [[912]], 8150: [[953, 834]], 8151: [[970, 834]], 8152: [[921, 774]], 8153: [[921, 772]], 8154: [[921, 768]], 8155: [[906]], 8157: [[8190, 768]], 8158: [[8190, 769]], 8159: [[8190, 834]], 8160: [[965, 774]], 8161: [[965, 772]], 8162: [[971, 768]], 8163: [[944]], 8164: [[961, 787]], 8165: [[961, 788]], 8166: [[965, 834]], 8167: [[971, 834]], 8168: [[933, 774]], 8169: [[933, 772]], 8170: [[933, 768]], 8171: [[910]], 8172: [[929, 788]], 8173: [[168, 768]], 8174: [[901]], 8175: [[96]], 8178: [[8060, 837]], 8179: [[969, 837]], 8180: [[974, 837]], 8182: [[969, 834], null, { 837: 8183 }], 8183: [[8182, 837]], 8184: [[927, 768]], 8185: [[908]], 8186: [[937, 768]], 8187: [[911]], 8188: [[937, 837]], 8189: [[180]], 8190: [[32, 788], 256, { 768: 8157, 769: 8158, 834: 8159 }] },
  8192: { 8192: [[8194]], 8193: [[8195]], 8194: [[32], 256], 8195: [[32], 256], 8196: [[32], 256], 8197: [[32], 256], 8198: [[32], 256], 8199: [[32], 256], 8200: [[32], 256], 8201: [[32], 256], 8202: [[32], 256], 8209: [[8208], 256], 8215: [[32, 819], 256], 8228: [[46], 256], 8229: [[46, 46], 256], 8230: [[46, 46, 46], 256], 8239: [[32], 256], 8243: [[8242, 8242], 256], 8244: [[8242, 8242, 8242], 256], 8246: [[8245, 8245], 256], 8247: [[8245, 8245, 8245], 256], 8252: [[33, 33], 256], 8254: [[32, 773], 256], 8263: [[63, 63], 256], 8264: [[63, 33], 256], 8265: [[33, 63], 256], 8279: [[8242, 8242, 8242, 8242], 256], 8287: [[32], 256], 8304: [[48], 256], 8305: [[105], 256], 8308: [[52], 256], 8309: [[53], 256], 8310: [[54], 256], 8311: [[55], 256], 8312: [[56], 256], 8313: [[57], 256], 8314: [[43], 256], 8315: [[8722], 256], 8316: [[61], 256], 8317: [[40], 256], 8318: [[41], 256], 8319: [[110], 256], 8320: [[48], 256], 8321: [[49], 256], 8322: [[50], 256], 8323: [[51], 256], 8324: [[52], 256], 8325: [[53], 256], 8326: [[54], 256], 8327: [[55], 256], 8328: [[56], 256], 8329: [[57], 256], 8330: [[43], 256], 8331: [[8722], 256], 8332: [[61], 256], 8333: [[40], 256], 8334: [[41], 256], 8336: [[97], 256], 8337: [[101], 256], 8338: [[111], 256], 8339: [[120], 256], 8340: [[601], 256], 8341: [[104], 256], 8342: [[107], 256], 8343: [[108], 256], 8344: [[109], 256], 8345: [[110], 256], 8346: [[112], 256], 8347: [[115], 256], 8348: [[116], 256], 8360: [[82, 115], 256], 8400: [null, 230], 8401: [null, 230], 8402: [null, 1], 8403: [null, 1], 8404: [null, 230], 8405: [null, 230], 8406: [null, 230], 8407: [null, 230], 8408: [null, 1], 8409: [null, 1], 8410: [null, 1], 8411: [null, 230], 8412: [null, 230], 8417: [null, 230], 8421: [null, 1], 8422: [null, 1], 8423: [null, 230], 8424: [null, 220], 8425: [null, 230], 8426: [null, 1], 8427: [null, 1], 8428: [null, 220], 8429: [null, 220], 8430: [null, 220], 8431: [null, 220], 8432: [null, 230] },
  8448: { 8448: [[97, 47, 99], 256], 8449: [[97, 47, 115], 256], 8450: [[67], 256], 8451: [[176, 67], 256], 8453: [[99, 47, 111], 256], 8454: [[99, 47, 117], 256], 8455: [[400], 256], 8457: [[176, 70], 256], 8458: [[103], 256], 8459: [[72], 256], 8460: [[72], 256], 8461: [[72], 256], 8462: [[104], 256], 8463: [[295], 256], 8464: [[73], 256], 8465: [[73], 256], 8466: [[76], 256], 8467: [[108], 256], 8469: [[78], 256], 8470: [[78, 111], 256], 8473: [[80], 256], 8474: [[81], 256], 8475: [[82], 256], 8476: [[82], 256], 8477: [[82], 256], 8480: [[83, 77], 256], 8481: [[84, 69, 76], 256], 8482: [[84, 77], 256], 8484: [[90], 256], 8486: [[937]], 8488: [[90], 256], 8490: [[75]], 8491: [[197]], 8492: [[66], 256], 8493: [[67], 256], 8495: [[101], 256], 8496: [[69], 256], 8497: [[70], 256], 8499: [[77], 256], 8500: [[111], 256], 8501: [[1488], 256], 8502: [[1489], 256], 8503: [[1490], 256], 8504: [[1491], 256], 8505: [[105], 256], 8507: [[70, 65, 88], 256], 8508: [[960], 256], 8509: [[947], 256], 8510: [[915], 256], 8511: [[928], 256], 8512: [[8721], 256], 8517: [[68], 256], 8518: [[100], 256], 8519: [[101], 256], 8520: [[105], 256], 8521: [[106], 256], 8528: [[49, 8260, 55], 256], 8529: [[49, 8260, 57], 256], 8530: [[49, 8260, 49, 48], 256], 8531: [[49, 8260, 51], 256], 8532: [[50, 8260, 51], 256], 8533: [[49, 8260, 53], 256], 8534: [[50, 8260, 53], 256], 8535: [[51, 8260, 53], 256], 8536: [[52, 8260, 53], 256], 8537: [[49, 8260, 54], 256], 8538: [[53, 8260, 54], 256], 8539: [[49, 8260, 56], 256], 8540: [[51, 8260, 56], 256], 8541: [[53, 8260, 56], 256], 8542: [[55, 8260, 56], 256], 8543: [[49, 8260], 256], 8544: [[73], 256], 8545: [[73, 73], 256], 8546: [[73, 73, 73], 256], 8547: [[73, 86], 256], 8548: [[86], 256], 8549: [[86, 73], 256], 8550: [[86, 73, 73], 256], 8551: [[86, 73, 73, 73], 256], 8552: [[73, 88], 256], 8553: [[88], 256], 8554: [[88, 73], 256], 8555: [[88, 73, 73], 256], 8556: [[76], 256], 8557: [[67], 256], 8558: [[68], 256], 8559: [[77], 256], 8560: [[105], 256], 8561: [[105, 105], 256], 8562: [[105, 105, 105], 256], 8563: [[105, 118], 256], 8564: [[118], 256], 8565: [[118, 105], 256], 8566: [[118, 105, 105], 256], 8567: [[118, 105, 105, 105], 256], 8568: [[105, 120], 256], 8569: [[120], 256], 8570: [[120, 105], 256], 8571: [[120, 105, 105], 256], 8572: [[108], 256], 8573: [[99], 256], 8574: [[100], 256], 8575: [[109], 256], 8585: [[48, 8260, 51], 256], 8592: [null, null, { 824: 8602 }], 8594: [null, null, { 824: 8603 }], 8596: [null, null, { 824: 8622 }], 8602: [[8592, 824]], 8603: [[8594, 824]], 8622: [[8596, 824]], 8653: [[8656, 824]], 8654: [[8660, 824]], 8655: [[8658, 824]], 8656: [null, null, { 824: 8653 }], 8658: [null, null, { 824: 8655 }], 8660: [null, null, { 824: 8654 }] },
  8704: { 8707: [null, null, { 824: 8708 }], 8708: [[8707, 824]], 8712: [null, null, { 824: 8713 }], 8713: [[8712, 824]], 8715: [null, null, { 824: 8716 }], 8716: [[8715, 824]], 8739: [null, null, { 824: 8740 }], 8740: [[8739, 824]], 8741: [null, null, { 824: 8742 }], 8742: [[8741, 824]], 8748: [[8747, 8747], 256], 8749: [[8747, 8747, 8747], 256], 8751: [[8750, 8750], 256], 8752: [[8750, 8750, 8750], 256], 8764: [null, null, { 824: 8769 }], 8769: [[8764, 824]], 8771: [null, null, { 824: 8772 }], 8772: [[8771, 824]], 8773: [null, null, { 824: 8775 }], 8775: [[8773, 824]], 8776: [null, null, { 824: 8777 }], 8777: [[8776, 824]], 8781: [null, null, { 824: 8813 }], 8800: [[61, 824]], 8801: [null, null, { 824: 8802 }], 8802: [[8801, 824]], 8804: [null, null, { 824: 8816 }], 8805: [null, null, { 824: 8817 }], 8813: [[8781, 824]], 8814: [[60, 824]], 8815: [[62, 824]], 8816: [[8804, 824]], 8817: [[8805, 824]], 8818: [null, null, { 824: 8820 }], 8819: [null, null, { 824: 8821 }], 8820: [[8818, 824]], 8821: [[8819, 824]], 8822: [null, null, { 824: 8824 }], 8823: [null, null, { 824: 8825 }], 8824: [[8822, 824]], 8825: [[8823, 824]], 8826: [null, null, { 824: 8832 }], 8827: [null, null, { 824: 8833 }], 8828: [null, null, { 824: 8928 }], 8829: [null, null, { 824: 8929 }], 8832: [[8826, 824]], 8833: [[8827, 824]], 8834: [null, null, { 824: 8836 }], 8835: [null, null, { 824: 8837 }], 8836: [[8834, 824]], 8837: [[8835, 824]], 8838: [null, null, { 824: 8840 }], 8839: [null, null, { 824: 8841 }], 8840: [[8838, 824]], 8841: [[8839, 824]], 8849: [null, null, { 824: 8930 }], 8850: [null, null, { 824: 8931 }], 8866: [null, null, { 824: 8876 }], 8872: [null, null, { 824: 8877 }], 8873: [null, null, { 824: 8878 }], 8875: [null, null, { 824: 8879 }], 8876: [[8866, 824]], 8877: [[8872, 824]], 8878: [[8873, 824]], 8879: [[8875, 824]], 8882: [null, null, { 824: 8938 }], 8883: [null, null, { 824: 8939 }], 8884: [null, null, { 824: 8940 }], 8885: [null, null, { 824: 8941 }], 8928: [[8828, 824]], 8929: [[8829, 824]], 8930: [[8849, 824]], 8931: [[8850, 824]], 8938: [[8882, 824]], 8939: [[8883, 824]], 8940: [[8884, 824]], 8941: [[8885, 824]] },
  8960: { 9001: [[12296]], 9002: [[12297]] },
  9216: { 9312: [[49], 256], 9313: [[50], 256], 9314: [[51], 256], 9315: [[52], 256], 9316: [[53], 256], 9317: [[54], 256], 9318: [[55], 256], 9319: [[56], 256], 9320: [[57], 256], 9321: [[49, 48], 256], 9322: [[49, 49], 256], 9323: [[49, 50], 256], 9324: [[49, 51], 256], 9325: [[49, 52], 256], 9326: [[49, 53], 256], 9327: [[49, 54], 256], 9328: [[49, 55], 256], 9329: [[49, 56], 256], 9330: [[49, 57], 256], 9331: [[50, 48], 256], 9332: [[40, 49, 41], 256], 9333: [[40, 50, 41], 256], 9334: [[40, 51, 41], 256], 9335: [[40, 52, 41], 256], 9336: [[40, 53, 41], 256], 9337: [[40, 54, 41], 256], 9338: [[40, 55, 41], 256], 9339: [[40, 56, 41], 256], 9340: [[40, 57, 41], 256], 9341: [[40, 49, 48, 41], 256], 9342: [[40, 49, 49, 41], 256], 9343: [[40, 49, 50, 41], 256], 9344: [[40, 49, 51, 41], 256], 9345: [[40, 49, 52, 41], 256], 9346: [[40, 49, 53, 41], 256], 9347: [[40, 49, 54, 41], 256], 9348: [[40, 49, 55, 41], 256], 9349: [[40, 49, 56, 41], 256], 9350: [[40, 49, 57, 41], 256], 9351: [[40, 50, 48, 41], 256], 9352: [[49, 46], 256], 9353: [[50, 46], 256], 9354: [[51, 46], 256], 9355: [[52, 46], 256], 9356: [[53, 46], 256], 9357: [[54, 46], 256], 9358: [[55, 46], 256], 9359: [[56, 46], 256], 9360: [[57, 46], 256], 9361: [[49, 48, 46], 256], 9362: [[49, 49, 46], 256], 9363: [[49, 50, 46], 256], 9364: [[49, 51, 46], 256], 9365: [[49, 52, 46], 256], 9366: [[49, 53, 46], 256], 9367: [[49, 54, 46], 256], 9368: [[49, 55, 46], 256], 9369: [[49, 56, 46], 256], 9370: [[49, 57, 46], 256], 9371: [[50, 48, 46], 256], 9372: [[40, 97, 41], 256], 9373: [[40, 98, 41], 256], 9374: [[40, 99, 41], 256], 9375: [[40, 100, 41], 256], 9376: [[40, 101, 41], 256], 9377: [[40, 102, 41], 256], 9378: [[40, 103, 41], 256], 9379: [[40, 104, 41], 256], 9380: [[40, 105, 41], 256], 9381: [[40, 106, 41], 256], 9382: [[40, 107, 41], 256], 9383: [[40, 108, 41], 256], 9384: [[40, 109, 41], 256], 9385: [[40, 110, 41], 256], 9386: [[40, 111, 41], 256], 9387: [[40, 112, 41], 256], 9388: [[40, 113, 41], 256], 9389: [[40, 114, 41], 256], 9390: [[40, 115, 41], 256], 9391: [[40, 116, 41], 256], 9392: [[40, 117, 41], 256], 9393: [[40, 118, 41], 256], 9394: [[40, 119, 41], 256], 9395: [[40, 120, 41], 256], 9396: [[40, 121, 41], 256], 9397: [[40, 122, 41], 256], 9398: [[65], 256], 9399: [[66], 256], 9400: [[67], 256], 9401: [[68], 256], 9402: [[69], 256], 9403: [[70], 256], 9404: [[71], 256], 9405: [[72], 256], 9406: [[73], 256], 9407: [[74], 256], 9408: [[75], 256], 9409: [[76], 256], 9410: [[77], 256], 9411: [[78], 256], 9412: [[79], 256], 9413: [[80], 256], 9414: [[81], 256], 9415: [[82], 256], 9416: [[83], 256], 9417: [[84], 256], 9418: [[85], 256], 9419: [[86], 256], 9420: [[87], 256], 9421: [[88], 256], 9422: [[89], 256], 9423: [[90], 256], 9424: [[97], 256], 9425: [[98], 256], 9426: [[99], 256], 9427: [[100], 256], 9428: [[101], 256], 9429: [[102], 256], 9430: [[103], 256], 9431: [[104], 256], 9432: [[105], 256], 9433: [[106], 256], 9434: [[107], 256], 9435: [[108], 256], 9436: [[109], 256], 9437: [[110], 256], 9438: [[111], 256], 9439: [[112], 256], 9440: [[113], 256], 9441: [[114], 256], 9442: [[115], 256], 9443: [[116], 256], 9444: [[117], 256], 9445: [[118], 256], 9446: [[119], 256], 9447: [[120], 256], 9448: [[121], 256], 9449: [[122], 256], 9450: [[48], 256] },
  10752: { 10764: [[8747, 8747, 8747, 8747], 256], 10868: [[58, 58, 61], 256], 10869: [[61, 61], 256], 10870: [[61, 61, 61], 256], 10972: [[10973, 824], 512] },
  11264: { 11388: [[106], 256], 11389: [[86], 256], 11503: [null, 230], 11504: [null, 230], 11505: [null, 230] },
  11520: { 11631: [[11617], 256], 11647: [null, 9], 11744: [null, 230], 11745: [null, 230], 11746: [null, 230], 11747: [null, 230], 11748: [null, 230], 11749: [null, 230], 11750: [null, 230], 11751: [null, 230], 11752: [null, 230], 11753: [null, 230], 11754: [null, 230], 11755: [null, 230], 11756: [null, 230], 11757: [null, 230], 11758: [null, 230], 11759: [null, 230], 11760: [null, 230], 11761: [null, 230], 11762: [null, 230], 11763: [null, 230], 11764: [null, 230], 11765: [null, 230], 11766: [null, 230], 11767: [null, 230], 11768: [null, 230], 11769: [null, 230], 11770: [null, 230], 11771: [null, 230], 11772: [null, 230], 11773: [null, 230], 11774: [null, 230], 11775: [null, 230] },
  11776: { 11935: [[27597], 256], 12019: [[40863], 256] },
  12032: { 12032: [[19968], 256], 12033: [[20008], 256], 12034: [[20022], 256], 12035: [[20031], 256], 12036: [[20057], 256], 12037: [[20101], 256], 12038: [[20108], 256], 12039: [[20128], 256], 12040: [[20154], 256], 12041: [[20799], 256], 12042: [[20837], 256], 12043: [[20843], 256], 12044: [[20866], 256], 12045: [[20886], 256], 12046: [[20907], 256], 12047: [[20960], 256], 12048: [[20981], 256], 12049: [[20992], 256], 12050: [[21147], 256], 12051: [[21241], 256], 12052: [[21269], 256], 12053: [[21274], 256], 12054: [[21304], 256], 12055: [[21313], 256], 12056: [[21340], 256], 12057: [[21353], 256], 12058: [[21378], 256], 12059: [[21430], 256], 12060: [[21448], 256], 12061: [[21475], 256], 12062: [[22231], 256], 12063: [[22303], 256], 12064: [[22763], 256], 12065: [[22786], 256], 12066: [[22794], 256], 12067: [[22805], 256], 12068: [[22823], 256], 12069: [[22899], 256], 12070: [[23376], 256], 12071: [[23424], 256], 12072: [[23544], 256], 12073: [[23567], 256], 12074: [[23586], 256], 12075: [[23608], 256], 12076: [[23662], 256], 12077: [[23665], 256], 12078: [[24027], 256], 12079: [[24037], 256], 12080: [[24049], 256], 12081: [[24062], 256], 12082: [[24178], 256], 12083: [[24186], 256], 12084: [[24191], 256], 12085: [[24308], 256], 12086: [[24318], 256], 12087: [[24331], 256], 12088: [[24339], 256], 12089: [[24400], 256], 12090: [[24417], 256], 12091: [[24435], 256], 12092: [[24515], 256], 12093: [[25096], 256], 12094: [[25142], 256], 12095: [[25163], 256], 12096: [[25903], 256], 12097: [[25908], 256], 12098: [[25991], 256], 12099: [[26007], 256], 12100: [[26020], 256], 12101: [[26041], 256], 12102: [[26080], 256], 12103: [[26085], 256], 12104: [[26352], 256], 12105: [[26376], 256], 12106: [[26408], 256], 12107: [[27424], 256], 12108: [[27490], 256], 12109: [[27513], 256], 12110: [[27571], 256], 12111: [[27595], 256], 12112: [[27604], 256], 12113: [[27611], 256], 12114: [[27663], 256], 12115: [[27668], 256], 12116: [[27700], 256], 12117: [[28779], 256], 12118: [[29226], 256], 12119: [[29238], 256], 12120: [[29243], 256], 12121: [[29247], 256], 12122: [[29255], 256], 12123: [[29273], 256], 12124: [[29275], 256], 12125: [[29356], 256], 12126: [[29572], 256], 12127: [[29577], 256], 12128: [[29916], 256], 12129: [[29926], 256], 12130: [[29976], 256], 12131: [[29983], 256], 12132: [[29992], 256], 12133: [[3e4], 256], 12134: [[30091], 256], 12135: [[30098], 256], 12136: [[30326], 256], 12137: [[30333], 256], 12138: [[30382], 256], 12139: [[30399], 256], 12140: [[30446], 256], 12141: [[30683], 256], 12142: [[30690], 256], 12143: [[30707], 256], 12144: [[31034], 256], 12145: [[31160], 256], 12146: [[31166], 256], 12147: [[31348], 256], 12148: [[31435], 256], 12149: [[31481], 256], 12150: [[31859], 256], 12151: [[31992], 256], 12152: [[32566], 256], 12153: [[32593], 256], 12154: [[32650], 256], 12155: [[32701], 256], 12156: [[32769], 256], 12157: [[32780], 256], 12158: [[32786], 256], 12159: [[32819], 256], 12160: [[32895], 256], 12161: [[32905], 256], 12162: [[33251], 256], 12163: [[33258], 256], 12164: [[33267], 256], 12165: [[33276], 256], 12166: [[33292], 256], 12167: [[33307], 256], 12168: [[33311], 256], 12169: [[33390], 256], 12170: [[33394], 256], 12171: [[33400], 256], 12172: [[34381], 256], 12173: [[34411], 256], 12174: [[34880], 256], 12175: [[34892], 256], 12176: [[34915], 256], 12177: [[35198], 256], 12178: [[35211], 256], 12179: [[35282], 256], 12180: [[35328], 256], 12181: [[35895], 256], 12182: [[35910], 256], 12183: [[35925], 256], 12184: [[35960], 256], 12185: [[35997], 256], 12186: [[36196], 256], 12187: [[36208], 256], 12188: [[36275], 256], 12189: [[36523], 256], 12190: [[36554], 256], 12191: [[36763], 256], 12192: [[36784], 256], 12193: [[36789], 256], 12194: [[37009], 256], 12195: [[37193], 256], 12196: [[37318], 256], 12197: [[37324], 256], 12198: [[37329], 256], 12199: [[38263], 256], 12200: [[38272], 256], 12201: [[38428], 256], 12202: [[38582], 256], 12203: [[38585], 256], 12204: [[38632], 256], 12205: [[38737], 256], 12206: [[38750], 256], 12207: [[38754], 256], 12208: [[38761], 256], 12209: [[38859], 256], 12210: [[38893], 256], 12211: [[38899], 256], 12212: [[38913], 256], 12213: [[39080], 256], 12214: [[39131], 256], 12215: [[39135], 256], 12216: [[39318], 256], 12217: [[39321], 256], 12218: [[39340], 256], 12219: [[39592], 256], 12220: [[39640], 256], 12221: [[39647], 256], 12222: [[39717], 256], 12223: [[39727], 256], 12224: [[39730], 256], 12225: [[39740], 256], 12226: [[39770], 256], 12227: [[40165], 256], 12228: [[40565], 256], 12229: [[40575], 256], 12230: [[40613], 256], 12231: [[40635], 256], 12232: [[40643], 256], 12233: [[40653], 256], 12234: [[40657], 256], 12235: [[40697], 256], 12236: [[40701], 256], 12237: [[40718], 256], 12238: [[40723], 256], 12239: [[40736], 256], 12240: [[40763], 256], 12241: [[40778], 256], 12242: [[40786], 256], 12243: [[40845], 256], 12244: [[40860], 256], 12245: [[40864], 256] },
  12288: { 12288: [[32], 256], 12330: [null, 218], 12331: [null, 228], 12332: [null, 232], 12333: [null, 222], 12334: [null, 224], 12335: [null, 224], 12342: [[12306], 256], 12344: [[21313], 256], 12345: [[21316], 256], 12346: [[21317], 256], 12358: [null, null, { 12441: 12436 }], 12363: [null, null, { 12441: 12364 }], 12364: [[12363, 12441]], 12365: [null, null, { 12441: 12366 }], 12366: [[12365, 12441]], 12367: [null, null, { 12441: 12368 }], 12368: [[12367, 12441]], 12369: [null, null, { 12441: 12370 }], 12370: [[12369, 12441]], 12371: [null, null, { 12441: 12372 }], 12372: [[12371, 12441]], 12373: [null, null, { 12441: 12374 }], 12374: [[12373, 12441]], 12375: [null, null, { 12441: 12376 }], 12376: [[12375, 12441]], 12377: [null, null, { 12441: 12378 }], 12378: [[12377, 12441]], 12379: [null, null, { 12441: 12380 }], 12380: [[12379, 12441]], 12381: [null, null, { 12441: 12382 }], 12382: [[12381, 12441]], 12383: [null, null, { 12441: 12384 }], 12384: [[12383, 12441]], 12385: [null, null, { 12441: 12386 }], 12386: [[12385, 12441]], 12388: [null, null, { 12441: 12389 }], 12389: [[12388, 12441]], 12390: [null, null, { 12441: 12391 }], 12391: [[12390, 12441]], 12392: [null, null, { 12441: 12393 }], 12393: [[12392, 12441]], 12399: [null, null, { 12441: 12400, 12442: 12401 }], 12400: [[12399, 12441]], 12401: [[12399, 12442]], 12402: [null, null, { 12441: 12403, 12442: 12404 }], 12403: [[12402, 12441]], 12404: [[12402, 12442]], 12405: [null, null, { 12441: 12406, 12442: 12407 }], 12406: [[12405, 12441]], 12407: [[12405, 12442]], 12408: [null, null, { 12441: 12409, 12442: 12410 }], 12409: [[12408, 12441]], 12410: [[12408, 12442]], 12411: [null, null, { 12441: 12412, 12442: 12413 }], 12412: [[12411, 12441]], 12413: [[12411, 12442]], 12436: [[12358, 12441]], 12441: [null, 8], 12442: [null, 8], 12443: [[32, 12441], 256], 12444: [[32, 12442], 256], 12445: [null, null, { 12441: 12446 }], 12446: [[12445, 12441]], 12447: [[12424, 12426], 256], 12454: [null, null, { 12441: 12532 }], 12459: [null, null, { 12441: 12460 }], 12460: [[12459, 12441]], 12461: [null, null, { 12441: 12462 }], 12462: [[12461, 12441]], 12463: [null, null, { 12441: 12464 }], 12464: [[12463, 12441]], 12465: [null, null, { 12441: 12466 }], 12466: [[12465, 12441]], 12467: [null, null, { 12441: 12468 }], 12468: [[12467, 12441]], 12469: [null, null, { 12441: 12470 }], 12470: [[12469, 12441]], 12471: [null, null, { 12441: 12472 }], 12472: [[12471, 12441]], 12473: [null, null, { 12441: 12474 }], 12474: [[12473, 12441]], 12475: [null, null, { 12441: 12476 }], 12476: [[12475, 12441]], 12477: [null, null, { 12441: 12478 }], 12478: [[12477, 12441]], 12479: [null, null, { 12441: 12480 }], 12480: [[12479, 12441]], 12481: [null, null, { 12441: 12482 }], 12482: [[12481, 12441]], 12484: [null, null, { 12441: 12485 }], 12485: [[12484, 12441]], 12486: [null, null, { 12441: 12487 }], 12487: [[12486, 12441]], 12488: [null, null, { 12441: 12489 }], 12489: [[12488, 12441]], 12495: [null, null, { 12441: 12496, 12442: 12497 }], 12496: [[12495, 12441]], 12497: [[12495, 12442]], 12498: [null, null, { 12441: 12499, 12442: 12500 }], 12499: [[12498, 12441]], 12500: [[12498, 12442]], 12501: [null, null, { 12441: 12502, 12442: 12503 }], 12502: [[12501, 12441]], 12503: [[12501, 12442]], 12504: [null, null, { 12441: 12505, 12442: 12506 }], 12505: [[12504, 12441]], 12506: [[12504, 12442]], 12507: [null, null, { 12441: 12508, 12442: 12509 }], 12508: [[12507, 12441]], 12509: [[12507, 12442]], 12527: [null, null, { 12441: 12535 }], 12528: [null, null, { 12441: 12536 }], 12529: [null, null, { 12441: 12537 }], 12530: [null, null, { 12441: 12538 }], 12532: [[12454, 12441]], 12535: [[12527, 12441]], 12536: [[12528, 12441]], 12537: [[12529, 12441]], 12538: [[12530, 12441]], 12541: [null, null, { 12441: 12542 }], 12542: [[12541, 12441]], 12543: [[12467, 12488], 256] },
  12544: { 12593: [[4352], 256], 12594: [[4353], 256], 12595: [[4522], 256], 12596: [[4354], 256], 12597: [[4524], 256], 12598: [[4525], 256], 12599: [[4355], 256], 12600: [[4356], 256], 12601: [[4357], 256], 12602: [[4528], 256], 12603: [[4529], 256], 12604: [[4530], 256], 12605: [[4531], 256], 12606: [[4532], 256], 12607: [[4533], 256], 12608: [[4378], 256], 12609: [[4358], 256], 12610: [[4359], 256], 12611: [[4360], 256], 12612: [[4385], 256], 12613: [[4361], 256], 12614: [[4362], 256], 12615: [[4363], 256], 12616: [[4364], 256], 12617: [[4365], 256], 12618: [[4366], 256], 12619: [[4367], 256], 12620: [[4368], 256], 12621: [[4369], 256], 12622: [[4370], 256], 12623: [[4449], 256], 12624: [[4450], 256], 12625: [[4451], 256], 12626: [[4452], 256], 12627: [[4453], 256], 12628: [[4454], 256], 12629: [[4455], 256], 12630: [[4456], 256], 12631: [[4457], 256], 12632: [[4458], 256], 12633: [[4459], 256], 12634: [[4460], 256], 12635: [[4461], 256], 12636: [[4462], 256], 12637: [[4463], 256], 12638: [[4464], 256], 12639: [[4465], 256], 12640: [[4466], 256], 12641: [[4467], 256], 12642: [[4468], 256], 12643: [[4469], 256], 12644: [[4448], 256], 12645: [[4372], 256], 12646: [[4373], 256], 12647: [[4551], 256], 12648: [[4552], 256], 12649: [[4556], 256], 12650: [[4558], 256], 12651: [[4563], 256], 12652: [[4567], 256], 12653: [[4569], 256], 12654: [[4380], 256], 12655: [[4573], 256], 12656: [[4575], 256], 12657: [[4381], 256], 12658: [[4382], 256], 12659: [[4384], 256], 12660: [[4386], 256], 12661: [[4387], 256], 12662: [[4391], 256], 12663: [[4393], 256], 12664: [[4395], 256], 12665: [[4396], 256], 12666: [[4397], 256], 12667: [[4398], 256], 12668: [[4399], 256], 12669: [[4402], 256], 12670: [[4406], 256], 12671: [[4416], 256], 12672: [[4423], 256], 12673: [[4428], 256], 12674: [[4593], 256], 12675: [[4594], 256], 12676: [[4439], 256], 12677: [[4440], 256], 12678: [[4441], 256], 12679: [[4484], 256], 12680: [[4485], 256], 12681: [[4488], 256], 12682: [[4497], 256], 12683: [[4498], 256], 12684: [[4500], 256], 12685: [[4510], 256], 12686: [[4513], 256], 12690: [[19968], 256], 12691: [[20108], 256], 12692: [[19977], 256], 12693: [[22235], 256], 12694: [[19978], 256], 12695: [[20013], 256], 12696: [[19979], 256], 12697: [[30002], 256], 12698: [[20057], 256], 12699: [[19993], 256], 12700: [[19969], 256], 12701: [[22825], 256], 12702: [[22320], 256], 12703: [[20154], 256] },
  12800: { 12800: [[40, 4352, 41], 256], 12801: [[40, 4354, 41], 256], 12802: [[40, 4355, 41], 256], 12803: [[40, 4357, 41], 256], 12804: [[40, 4358, 41], 256], 12805: [[40, 4359, 41], 256], 12806: [[40, 4361, 41], 256], 12807: [[40, 4363, 41], 256], 12808: [[40, 4364, 41], 256], 12809: [[40, 4366, 41], 256], 12810: [[40, 4367, 41], 256], 12811: [[40, 4368, 41], 256], 12812: [[40, 4369, 41], 256], 12813: [[40, 4370, 41], 256], 12814: [[40, 4352, 4449, 41], 256], 12815: [[40, 4354, 4449, 41], 256], 12816: [[40, 4355, 4449, 41], 256], 12817: [[40, 4357, 4449, 41], 256], 12818: [[40, 4358, 4449, 41], 256], 12819: [[40, 4359, 4449, 41], 256], 12820: [[40, 4361, 4449, 41], 256], 12821: [[40, 4363, 4449, 41], 256], 12822: [[40, 4364, 4449, 41], 256], 12823: [[40, 4366, 4449, 41], 256], 12824: [[40, 4367, 4449, 41], 256], 12825: [[40, 4368, 4449, 41], 256], 12826: [[40, 4369, 4449, 41], 256], 12827: [[40, 4370, 4449, 41], 256], 12828: [[40, 4364, 4462, 41], 256], 12829: [[40, 4363, 4457, 4364, 4453, 4523, 41], 256], 12830: [[40, 4363, 4457, 4370, 4462, 41], 256], 12832: [[40, 19968, 41], 256], 12833: [[40, 20108, 41], 256], 12834: [[40, 19977, 41], 256], 12835: [[40, 22235, 41], 256], 12836: [[40, 20116, 41], 256], 12837: [[40, 20845, 41], 256], 12838: [[40, 19971, 41], 256], 12839: [[40, 20843, 41], 256], 12840: [[40, 20061, 41], 256], 12841: [[40, 21313, 41], 256], 12842: [[40, 26376, 41], 256], 12843: [[40, 28779, 41], 256], 12844: [[40, 27700, 41], 256], 12845: [[40, 26408, 41], 256], 12846: [[40, 37329, 41], 256], 12847: [[40, 22303, 41], 256], 12848: [[40, 26085, 41], 256], 12849: [[40, 26666, 41], 256], 12850: [[40, 26377, 41], 256], 12851: [[40, 31038, 41], 256], 12852: [[40, 21517, 41], 256], 12853: [[40, 29305, 41], 256], 12854: [[40, 36001, 41], 256], 12855: [[40, 31069, 41], 256], 12856: [[40, 21172, 41], 256], 12857: [[40, 20195, 41], 256], 12858: [[40, 21628, 41], 256], 12859: [[40, 23398, 41], 256], 12860: [[40, 30435, 41], 256], 12861: [[40, 20225, 41], 256], 12862: [[40, 36039, 41], 256], 12863: [[40, 21332, 41], 256], 12864: [[40, 31085, 41], 256], 12865: [[40, 20241, 41], 256], 12866: [[40, 33258, 41], 256], 12867: [[40, 33267, 41], 256], 12868: [[21839], 256], 12869: [[24188], 256], 12870: [[25991], 256], 12871: [[31631], 256], 12880: [[80, 84, 69], 256], 12881: [[50, 49], 256], 12882: [[50, 50], 256], 12883: [[50, 51], 256], 12884: [[50, 52], 256], 12885: [[50, 53], 256], 12886: [[50, 54], 256], 12887: [[50, 55], 256], 12888: [[50, 56], 256], 12889: [[50, 57], 256], 12890: [[51, 48], 256], 12891: [[51, 49], 256], 12892: [[51, 50], 256], 12893: [[51, 51], 256], 12894: [[51, 52], 256], 12895: [[51, 53], 256], 12896: [[4352], 256], 12897: [[4354], 256], 12898: [[4355], 256], 12899: [[4357], 256], 12900: [[4358], 256], 12901: [[4359], 256], 12902: [[4361], 256], 12903: [[4363], 256], 12904: [[4364], 256], 12905: [[4366], 256], 12906: [[4367], 256], 12907: [[4368], 256], 12908: [[4369], 256], 12909: [[4370], 256], 12910: [[4352, 4449], 256], 12911: [[4354, 4449], 256], 12912: [[4355, 4449], 256], 12913: [[4357, 4449], 256], 12914: [[4358, 4449], 256], 12915: [[4359, 4449], 256], 12916: [[4361, 4449], 256], 12917: [[4363, 4449], 256], 12918: [[4364, 4449], 256], 12919: [[4366, 4449], 256], 12920: [[4367, 4449], 256], 12921: [[4368, 4449], 256], 12922: [[4369, 4449], 256], 12923: [[4370, 4449], 256], 12924: [[4366, 4449, 4535, 4352, 4457], 256], 12925: [[4364, 4462, 4363, 4468], 256], 12926: [[4363, 4462], 256], 12928: [[19968], 256], 12929: [[20108], 256], 12930: [[19977], 256], 12931: [[22235], 256], 12932: [[20116], 256], 12933: [[20845], 256], 12934: [[19971], 256], 12935: [[20843], 256], 12936: [[20061], 256], 12937: [[21313], 256], 12938: [[26376], 256], 12939: [[28779], 256], 12940: [[27700], 256], 12941: [[26408], 256], 12942: [[37329], 256], 12943: [[22303], 256], 12944: [[26085], 256], 12945: [[26666], 256], 12946: [[26377], 256], 12947: [[31038], 256], 12948: [[21517], 256], 12949: [[29305], 256], 12950: [[36001], 256], 12951: [[31069], 256], 12952: [[21172], 256], 12953: [[31192], 256], 12954: [[30007], 256], 12955: [[22899], 256], 12956: [[36969], 256], 12957: [[20778], 256], 12958: [[21360], 256], 12959: [[27880], 256], 12960: [[38917], 256], 12961: [[20241], 256], 12962: [[20889], 256], 12963: [[27491], 256], 12964: [[19978], 256], 12965: [[20013], 256], 12966: [[19979], 256], 12967: [[24038], 256], 12968: [[21491], 256], 12969: [[21307], 256], 12970: [[23447], 256], 12971: [[23398], 256], 12972: [[30435], 256], 12973: [[20225], 256], 12974: [[36039], 256], 12975: [[21332], 256], 12976: [[22812], 256], 12977: [[51, 54], 256], 12978: [[51, 55], 256], 12979: [[51, 56], 256], 12980: [[51, 57], 256], 12981: [[52, 48], 256], 12982: [[52, 49], 256], 12983: [[52, 50], 256], 12984: [[52, 51], 256], 12985: [[52, 52], 256], 12986: [[52, 53], 256], 12987: [[52, 54], 256], 12988: [[52, 55], 256], 12989: [[52, 56], 256], 12990: [[52, 57], 256], 12991: [[53, 48], 256], 12992: [[49, 26376], 256], 12993: [[50, 26376], 256], 12994: [[51, 26376], 256], 12995: [[52, 26376], 256], 12996: [[53, 26376], 256], 12997: [[54, 26376], 256], 12998: [[55, 26376], 256], 12999: [[56, 26376], 256], 13e3: [[57, 26376], 256], 13001: [[49, 48, 26376], 256], 13002: [[49, 49, 26376], 256], 13003: [[49, 50, 26376], 256], 13004: [[72, 103], 256], 13005: [[101, 114, 103], 256], 13006: [[101, 86], 256], 13007: [[76, 84, 68], 256], 13008: [[12450], 256], 13009: [[12452], 256], 13010: [[12454], 256], 13011: [[12456], 256], 13012: [[12458], 256], 13013: [[12459], 256], 13014: [[12461], 256], 13015: [[12463], 256], 13016: [[12465], 256], 13017: [[12467], 256], 13018: [[12469], 256], 13019: [[12471], 256], 13020: [[12473], 256], 13021: [[12475], 256], 13022: [[12477], 256], 13023: [[12479], 256], 13024: [[12481], 256], 13025: [[12484], 256], 13026: [[12486], 256], 13027: [[12488], 256], 13028: [[12490], 256], 13029: [[12491], 256], 13030: [[12492], 256], 13031: [[12493], 256], 13032: [[12494], 256], 13033: [[12495], 256], 13034: [[12498], 256], 13035: [[12501], 256], 13036: [[12504], 256], 13037: [[12507], 256], 13038: [[12510], 256], 13039: [[12511], 256], 13040: [[12512], 256], 13041: [[12513], 256], 13042: [[12514], 256], 13043: [[12516], 256], 13044: [[12518], 256], 13045: [[12520], 256], 13046: [[12521], 256], 13047: [[12522], 256], 13048: [[12523], 256], 13049: [[12524], 256], 13050: [[12525], 256], 13051: [[12527], 256], 13052: [[12528], 256], 13053: [[12529], 256], 13054: [[12530], 256] },
  13056: { 13056: [[12450, 12497, 12540, 12488], 256], 13057: [[12450, 12523, 12501, 12449], 256], 13058: [[12450, 12531, 12506, 12450], 256], 13059: [[12450, 12540, 12523], 256], 13060: [[12452, 12491, 12531, 12464], 256], 13061: [[12452, 12531, 12481], 256], 13062: [[12454, 12457, 12531], 256], 13063: [[12456, 12473, 12463, 12540, 12489], 256], 13064: [[12456, 12540, 12459, 12540], 256], 13065: [[12458, 12531, 12473], 256], 13066: [[12458, 12540, 12512], 256], 13067: [[12459, 12452, 12522], 256], 13068: [[12459, 12521, 12483, 12488], 256], 13069: [[12459, 12525, 12522, 12540], 256], 13070: [[12460, 12525, 12531], 256], 13071: [[12460, 12531, 12510], 256], 13072: [[12462, 12460], 256], 13073: [[12462, 12491, 12540], 256], 13074: [[12461, 12517, 12522, 12540], 256], 13075: [[12462, 12523, 12480, 12540], 256], 13076: [[12461, 12525], 256], 13077: [[12461, 12525, 12464, 12521, 12512], 256], 13078: [[12461, 12525, 12513, 12540, 12488, 12523], 256], 13079: [[12461, 12525, 12527, 12483, 12488], 256], 13080: [[12464, 12521, 12512], 256], 13081: [[12464, 12521, 12512, 12488, 12531], 256], 13082: [[12463, 12523, 12476, 12452, 12525], 256], 13083: [[12463, 12525, 12540, 12493], 256], 13084: [[12465, 12540, 12473], 256], 13085: [[12467, 12523, 12490], 256], 13086: [[12467, 12540, 12509], 256], 13087: [[12469, 12452, 12463, 12523], 256], 13088: [[12469, 12531, 12481, 12540, 12512], 256], 13089: [[12471, 12522, 12531, 12464], 256], 13090: [[12475, 12531, 12481], 256], 13091: [[12475, 12531, 12488], 256], 13092: [[12480, 12540, 12473], 256], 13093: [[12487, 12471], 256], 13094: [[12489, 12523], 256], 13095: [[12488, 12531], 256], 13096: [[12490, 12494], 256], 13097: [[12494, 12483, 12488], 256], 13098: [[12495, 12452, 12484], 256], 13099: [[12497, 12540, 12475, 12531, 12488], 256], 13100: [[12497, 12540, 12484], 256], 13101: [[12496, 12540, 12524, 12523], 256], 13102: [[12500, 12450, 12473, 12488, 12523], 256], 13103: [[12500, 12463, 12523], 256], 13104: [[12500, 12467], 256], 13105: [[12499, 12523], 256], 13106: [[12501, 12449, 12521, 12483, 12489], 256], 13107: [[12501, 12451, 12540, 12488], 256], 13108: [[12502, 12483, 12471, 12455, 12523], 256], 13109: [[12501, 12521, 12531], 256], 13110: [[12504, 12463, 12479, 12540, 12523], 256], 13111: [[12506, 12477], 256], 13112: [[12506, 12491, 12498], 256], 13113: [[12504, 12523, 12484], 256], 13114: [[12506, 12531, 12473], 256], 13115: [[12506, 12540, 12472], 256], 13116: [[12505, 12540, 12479], 256], 13117: [[12509, 12452, 12531, 12488], 256], 13118: [[12508, 12523, 12488], 256], 13119: [[12507, 12531], 256], 13120: [[12509, 12531, 12489], 256], 13121: [[12507, 12540, 12523], 256], 13122: [[12507, 12540, 12531], 256], 13123: [[12510, 12452, 12463, 12525], 256], 13124: [[12510, 12452, 12523], 256], 13125: [[12510, 12483, 12495], 256], 13126: [[12510, 12523, 12463], 256], 13127: [[12510, 12531, 12471, 12519, 12531], 256], 13128: [[12511, 12463, 12525, 12531], 256], 13129: [[12511, 12522], 256], 13130: [[12511, 12522, 12496, 12540, 12523], 256], 13131: [[12513, 12460], 256], 13132: [[12513, 12460, 12488, 12531], 256], 13133: [[12513, 12540, 12488, 12523], 256], 13134: [[12516, 12540, 12489], 256], 13135: [[12516, 12540, 12523], 256], 13136: [[12518, 12450, 12531], 256], 13137: [[12522, 12483, 12488, 12523], 256], 13138: [[12522, 12521], 256], 13139: [[12523, 12500, 12540], 256], 13140: [[12523, 12540, 12502, 12523], 256], 13141: [[12524, 12512], 256], 13142: [[12524, 12531, 12488, 12466, 12531], 256], 13143: [[12527, 12483, 12488], 256], 13144: [[48, 28857], 256], 13145: [[49, 28857], 256], 13146: [[50, 28857], 256], 13147: [[51, 28857], 256], 13148: [[52, 28857], 256], 13149: [[53, 28857], 256], 13150: [[54, 28857], 256], 13151: [[55, 28857], 256], 13152: [[56, 28857], 256], 13153: [[57, 28857], 256], 13154: [[49, 48, 28857], 256], 13155: [[49, 49, 28857], 256], 13156: [[49, 50, 28857], 256], 13157: [[49, 51, 28857], 256], 13158: [[49, 52, 28857], 256], 13159: [[49, 53, 28857], 256], 13160: [[49, 54, 28857], 256], 13161: [[49, 55, 28857], 256], 13162: [[49, 56, 28857], 256], 13163: [[49, 57, 28857], 256], 13164: [[50, 48, 28857], 256], 13165: [[50, 49, 28857], 256], 13166: [[50, 50, 28857], 256], 13167: [[50, 51, 28857], 256], 13168: [[50, 52, 28857], 256], 13169: [[104, 80, 97], 256], 13170: [[100, 97], 256], 13171: [[65, 85], 256], 13172: [[98, 97, 114], 256], 13173: [[111, 86], 256], 13174: [[112, 99], 256], 13175: [[100, 109], 256], 13176: [[100, 109, 178], 256], 13177: [[100, 109, 179], 256], 13178: [[73, 85], 256], 13179: [[24179, 25104], 256], 13180: [[26157, 21644], 256], 13181: [[22823, 27491], 256], 13182: [[26126, 27835], 256], 13183: [[26666, 24335, 20250, 31038], 256], 13184: [[112, 65], 256], 13185: [[110, 65], 256], 13186: [[956, 65], 256], 13187: [[109, 65], 256], 13188: [[107, 65], 256], 13189: [[75, 66], 256], 13190: [[77, 66], 256], 13191: [[71, 66], 256], 13192: [[99, 97, 108], 256], 13193: [[107, 99, 97, 108], 256], 13194: [[112, 70], 256], 13195: [[110, 70], 256], 13196: [[956, 70], 256], 13197: [[956, 103], 256], 13198: [[109, 103], 256], 13199: [[107, 103], 256], 13200: [[72, 122], 256], 13201: [[107, 72, 122], 256], 13202: [[77, 72, 122], 256], 13203: [[71, 72, 122], 256], 13204: [[84, 72, 122], 256], 13205: [[956, 8467], 256], 13206: [[109, 8467], 256], 13207: [[100, 8467], 256], 13208: [[107, 8467], 256], 13209: [[102, 109], 256], 13210: [[110, 109], 256], 13211: [[956, 109], 256], 13212: [[109, 109], 256], 13213: [[99, 109], 256], 13214: [[107, 109], 256], 13215: [[109, 109, 178], 256], 13216: [[99, 109, 178], 256], 13217: [[109, 178], 256], 13218: [[107, 109, 178], 256], 13219: [[109, 109, 179], 256], 13220: [[99, 109, 179], 256], 13221: [[109, 179], 256], 13222: [[107, 109, 179], 256], 13223: [[109, 8725, 115], 256], 13224: [[109, 8725, 115, 178], 256], 13225: [[80, 97], 256], 13226: [[107, 80, 97], 256], 13227: [[77, 80, 97], 256], 13228: [[71, 80, 97], 256], 13229: [[114, 97, 100], 256], 13230: [[114, 97, 100, 8725, 115], 256], 13231: [[114, 97, 100, 8725, 115, 178], 256], 13232: [[112, 115], 256], 13233: [[110, 115], 256], 13234: [[956, 115], 256], 13235: [[109, 115], 256], 13236: [[112, 86], 256], 13237: [[110, 86], 256], 13238: [[956, 86], 256], 13239: [[109, 86], 256], 13240: [[107, 86], 256], 13241: [[77, 86], 256], 13242: [[112, 87], 256], 13243: [[110, 87], 256], 13244: [[956, 87], 256], 13245: [[109, 87], 256], 13246: [[107, 87], 256], 13247: [[77, 87], 256], 13248: [[107, 937], 256], 13249: [[77, 937], 256], 13250: [[97, 46, 109, 46], 256], 13251: [[66, 113], 256], 13252: [[99, 99], 256], 13253: [[99, 100], 256], 13254: [[67, 8725, 107, 103], 256], 13255: [[67, 111, 46], 256], 13256: [[100, 66], 256], 13257: [[71, 121], 256], 13258: [[104, 97], 256], 13259: [[72, 80], 256], 13260: [[105, 110], 256], 13261: [[75, 75], 256], 13262: [[75, 77], 256], 13263: [[107, 116], 256], 13264: [[108, 109], 256], 13265: [[108, 110], 256], 13266: [[108, 111, 103], 256], 13267: [[108, 120], 256], 13268: [[109, 98], 256], 13269: [[109, 105, 108], 256], 13270: [[109, 111, 108], 256], 13271: [[80, 72], 256], 13272: [[112, 46, 109, 46], 256], 13273: [[80, 80, 77], 256], 13274: [[80, 82], 256], 13275: [[115, 114], 256], 13276: [[83, 118], 256], 13277: [[87, 98], 256], 13278: [[86, 8725, 109], 256], 13279: [[65, 8725, 109], 256], 13280: [[49, 26085], 256], 13281: [[50, 26085], 256], 13282: [[51, 26085], 256], 13283: [[52, 26085], 256], 13284: [[53, 26085], 256], 13285: [[54, 26085], 256], 13286: [[55, 26085], 256], 13287: [[56, 26085], 256], 13288: [[57, 26085], 256], 13289: [[49, 48, 26085], 256], 13290: [[49, 49, 26085], 256], 13291: [[49, 50, 26085], 256], 13292: [[49, 51, 26085], 256], 13293: [[49, 52, 26085], 256], 13294: [[49, 53, 26085], 256], 13295: [[49, 54, 26085], 256], 13296: [[49, 55, 26085], 256], 13297: [[49, 56, 26085], 256], 13298: [[49, 57, 26085], 256], 13299: [[50, 48, 26085], 256], 13300: [[50, 49, 26085], 256], 13301: [[50, 50, 26085], 256], 13302: [[50, 51, 26085], 256], 13303: [[50, 52, 26085], 256], 13304: [[50, 53, 26085], 256], 13305: [[50, 54, 26085], 256], 13306: [[50, 55, 26085], 256], 13307: [[50, 56, 26085], 256], 13308: [[50, 57, 26085], 256], 13309: [[51, 48, 26085], 256], 13310: [[51, 49, 26085], 256], 13311: [[103, 97, 108], 256] },
  27136: { 92912: [null, 1], 92913: [null, 1], 92914: [null, 1], 92915: [null, 1], 92916: [null, 1] },
  27392: { 92976: [null, 230], 92977: [null, 230], 92978: [null, 230], 92979: [null, 230], 92980: [null, 230], 92981: [null, 230], 92982: [null, 230] },
  42496: { 42607: [null, 230], 42612: [null, 230], 42613: [null, 230], 42614: [null, 230], 42615: [null, 230], 42616: [null, 230], 42617: [null, 230], 42618: [null, 230], 42619: [null, 230], 42620: [null, 230], 42621: [null, 230], 42652: [[1098], 256], 42653: [[1100], 256], 42655: [null, 230], 42736: [null, 230], 42737: [null, 230] },
  42752: { 42864: [[42863], 256], 43e3: [[294], 256], 43001: [[339], 256] },
  43008: { 43014: [null, 9], 43204: [null, 9], 43232: [null, 230], 43233: [null, 230], 43234: [null, 230], 43235: [null, 230], 43236: [null, 230], 43237: [null, 230], 43238: [null, 230], 43239: [null, 230], 43240: [null, 230], 43241: [null, 230], 43242: [null, 230], 43243: [null, 230], 43244: [null, 230], 43245: [null, 230], 43246: [null, 230], 43247: [null, 230], 43248: [null, 230], 43249: [null, 230] },
  43264: { 43307: [null, 220], 43308: [null, 220], 43309: [null, 220], 43347: [null, 9], 43443: [null, 7], 43456: [null, 9] },
  43520: { 43696: [null, 230], 43698: [null, 230], 43699: [null, 230], 43700: [null, 220], 43703: [null, 230], 43704: [null, 230], 43710: [null, 230], 43711: [null, 230], 43713: [null, 230], 43766: [null, 9] },
  43776: { 43868: [[42791], 256], 43869: [[43831], 256], 43870: [[619], 256], 43871: [[43858], 256], 44013: [null, 9] },
  48128: { 113822: [null, 1] },
  53504: { 119134: [[119127, 119141], 512], 119135: [[119128, 119141], 512], 119136: [[119135, 119150], 512], 119137: [[119135, 119151], 512], 119138: [[119135, 119152], 512], 119139: [[119135, 119153], 512], 119140: [[119135, 119154], 512], 119141: [null, 216], 119142: [null, 216], 119143: [null, 1], 119144: [null, 1], 119145: [null, 1], 119149: [null, 226], 119150: [null, 216], 119151: [null, 216], 119152: [null, 216], 119153: [null, 216], 119154: [null, 216], 119163: [null, 220], 119164: [null, 220], 119165: [null, 220], 119166: [null, 220], 119167: [null, 220], 119168: [null, 220], 119169: [null, 220], 119170: [null, 220], 119173: [null, 230], 119174: [null, 230], 119175: [null, 230], 119176: [null, 230], 119177: [null, 230], 119178: [null, 220], 119179: [null, 220], 119210: [null, 230], 119211: [null, 230], 119212: [null, 230], 119213: [null, 230], 119227: [[119225, 119141], 512], 119228: [[119226, 119141], 512], 119229: [[119227, 119150], 512], 119230: [[119228, 119150], 512], 119231: [[119227, 119151], 512], 119232: [[119228, 119151], 512] },
  53760: { 119362: [null, 230], 119363: [null, 230], 119364: [null, 230] },
  54272: { 119808: [[65], 256], 119809: [[66], 256], 119810: [[67], 256], 119811: [[68], 256], 119812: [[69], 256], 119813: [[70], 256], 119814: [[71], 256], 119815: [[72], 256], 119816: [[73], 256], 119817: [[74], 256], 119818: [[75], 256], 119819: [[76], 256], 119820: [[77], 256], 119821: [[78], 256], 119822: [[79], 256], 119823: [[80], 256], 119824: [[81], 256], 119825: [[82], 256], 119826: [[83], 256], 119827: [[84], 256], 119828: [[85], 256], 119829: [[86], 256], 119830: [[87], 256], 119831: [[88], 256], 119832: [[89], 256], 119833: [[90], 256], 119834: [[97], 256], 119835: [[98], 256], 119836: [[99], 256], 119837: [[100], 256], 119838: [[101], 256], 119839: [[102], 256], 119840: [[103], 256], 119841: [[104], 256], 119842: [[105], 256], 119843: [[106], 256], 119844: [[107], 256], 119845: [[108], 256], 119846: [[109], 256], 119847: [[110], 256], 119848: [[111], 256], 119849: [[112], 256], 119850: [[113], 256], 119851: [[114], 256], 119852: [[115], 256], 119853: [[116], 256], 119854: [[117], 256], 119855: [[118], 256], 119856: [[119], 256], 119857: [[120], 256], 119858: [[121], 256], 119859: [[122], 256], 119860: [[65], 256], 119861: [[66], 256], 119862: [[67], 256], 119863: [[68], 256], 119864: [[69], 256], 119865: [[70], 256], 119866: [[71], 256], 119867: [[72], 256], 119868: [[73], 256], 119869: [[74], 256], 119870: [[75], 256], 119871: [[76], 256], 119872: [[77], 256], 119873: [[78], 256], 119874: [[79], 256], 119875: [[80], 256], 119876: [[81], 256], 119877: [[82], 256], 119878: [[83], 256], 119879: [[84], 256], 119880: [[85], 256], 119881: [[86], 256], 119882: [[87], 256], 119883: [[88], 256], 119884: [[89], 256], 119885: [[90], 256], 119886: [[97], 256], 119887: [[98], 256], 119888: [[99], 256], 119889: [[100], 256], 119890: [[101], 256], 119891: [[102], 256], 119892: [[103], 256], 119894: [[105], 256], 119895: [[106], 256], 119896: [[107], 256], 119897: [[108], 256], 119898: [[109], 256], 119899: [[110], 256], 119900: [[111], 256], 119901: [[112], 256], 119902: [[113], 256], 119903: [[114], 256], 119904: [[115], 256], 119905: [[116], 256], 119906: [[117], 256], 119907: [[118], 256], 119908: [[119], 256], 119909: [[120], 256], 119910: [[121], 256], 119911: [[122], 256], 119912: [[65], 256], 119913: [[66], 256], 119914: [[67], 256], 119915: [[68], 256], 119916: [[69], 256], 119917: [[70], 256], 119918: [[71], 256], 119919: [[72], 256], 119920: [[73], 256], 119921: [[74], 256], 119922: [[75], 256], 119923: [[76], 256], 119924: [[77], 256], 119925: [[78], 256], 119926: [[79], 256], 119927: [[80], 256], 119928: [[81], 256], 119929: [[82], 256], 119930: [[83], 256], 119931: [[84], 256], 119932: [[85], 256], 119933: [[86], 256], 119934: [[87], 256], 119935: [[88], 256], 119936: [[89], 256], 119937: [[90], 256], 119938: [[97], 256], 119939: [[98], 256], 119940: [[99], 256], 119941: [[100], 256], 119942: [[101], 256], 119943: [[102], 256], 119944: [[103], 256], 119945: [[104], 256], 119946: [[105], 256], 119947: [[106], 256], 119948: [[107], 256], 119949: [[108], 256], 119950: [[109], 256], 119951: [[110], 256], 119952: [[111], 256], 119953: [[112], 256], 119954: [[113], 256], 119955: [[114], 256], 119956: [[115], 256], 119957: [[116], 256], 119958: [[117], 256], 119959: [[118], 256], 119960: [[119], 256], 119961: [[120], 256], 119962: [[121], 256], 119963: [[122], 256], 119964: [[65], 256], 119966: [[67], 256], 119967: [[68], 256], 119970: [[71], 256], 119973: [[74], 256], 119974: [[75], 256], 119977: [[78], 256], 119978: [[79], 256], 119979: [[80], 256], 119980: [[81], 256], 119982: [[83], 256], 119983: [[84], 256], 119984: [[85], 256], 119985: [[86], 256], 119986: [[87], 256], 119987: [[88], 256], 119988: [[89], 256], 119989: [[90], 256], 119990: [[97], 256], 119991: [[98], 256], 119992: [[99], 256], 119993: [[100], 256], 119995: [[102], 256], 119997: [[104], 256], 119998: [[105], 256], 119999: [[106], 256], 12e4: [[107], 256], 120001: [[108], 256], 120002: [[109], 256], 120003: [[110], 256], 120005: [[112], 256], 120006: [[113], 256], 120007: [[114], 256], 120008: [[115], 256], 120009: [[116], 256], 120010: [[117], 256], 120011: [[118], 256], 120012: [[119], 256], 120013: [[120], 256], 120014: [[121], 256], 120015: [[122], 256], 120016: [[65], 256], 120017: [[66], 256], 120018: [[67], 256], 120019: [[68], 256], 120020: [[69], 256], 120021: [[70], 256], 120022: [[71], 256], 120023: [[72], 256], 120024: [[73], 256], 120025: [[74], 256], 120026: [[75], 256], 120027: [[76], 256], 120028: [[77], 256], 120029: [[78], 256], 120030: [[79], 256], 120031: [[80], 256], 120032: [[81], 256], 120033: [[82], 256], 120034: [[83], 256], 120035: [[84], 256], 120036: [[85], 256], 120037: [[86], 256], 120038: [[87], 256], 120039: [[88], 256], 120040: [[89], 256], 120041: [[90], 256], 120042: [[97], 256], 120043: [[98], 256], 120044: [[99], 256], 120045: [[100], 256], 120046: [[101], 256], 120047: [[102], 256], 120048: [[103], 256], 120049: [[104], 256], 120050: [[105], 256], 120051: [[106], 256], 120052: [[107], 256], 120053: [[108], 256], 120054: [[109], 256], 120055: [[110], 256], 120056: [[111], 256], 120057: [[112], 256], 120058: [[113], 256], 120059: [[114], 256], 120060: [[115], 256], 120061: [[116], 256], 120062: [[117], 256], 120063: [[118], 256] },
  54528: { 120064: [[119], 256], 120065: [[120], 256], 120066: [[121], 256], 120067: [[122], 256], 120068: [[65], 256], 120069: [[66], 256], 120071: [[68], 256], 120072: [[69], 256], 120073: [[70], 256], 120074: [[71], 256], 120077: [[74], 256], 120078: [[75], 256], 120079: [[76], 256], 120080: [[77], 256], 120081: [[78], 256], 120082: [[79], 256], 120083: [[80], 256], 120084: [[81], 256], 120086: [[83], 256], 120087: [[84], 256], 120088: [[85], 256], 120089: [[86], 256], 120090: [[87], 256], 120091: [[88], 256], 120092: [[89], 256], 120094: [[97], 256], 120095: [[98], 256], 120096: [[99], 256], 120097: [[100], 256], 120098: [[101], 256], 120099: [[102], 256], 120100: [[103], 256], 120101: [[104], 256], 120102: [[105], 256], 120103: [[106], 256], 120104: [[107], 256], 120105: [[108], 256], 120106: [[109], 256], 120107: [[110], 256], 120108: [[111], 256], 120109: [[112], 256], 120110: [[113], 256], 120111: [[114], 256], 120112: [[115], 256], 120113: [[116], 256], 120114: [[117], 256], 120115: [[118], 256], 120116: [[119], 256], 120117: [[120], 256], 120118: [[121], 256], 120119: [[122], 256], 120120: [[65], 256], 120121: [[66], 256], 120123: [[68], 256], 120124: [[69], 256], 120125: [[70], 256], 120126: [[71], 256], 120128: [[73], 256], 120129: [[74], 256], 120130: [[75], 256], 120131: [[76], 256], 120132: [[77], 256], 120134: [[79], 256], 120138: [[83], 256], 120139: [[84], 256], 120140: [[85], 256], 120141: [[86], 256], 120142: [[87], 256], 120143: [[88], 256], 120144: [[89], 256], 120146: [[97], 256], 120147: [[98], 256], 120148: [[99], 256], 120149: [[100], 256], 120150: [[101], 256], 120151: [[102], 256], 120152: [[103], 256], 120153: [[104], 256], 120154: [[105], 256], 120155: [[106], 256], 120156: [[107], 256], 120157: [[108], 256], 120158: [[109], 256], 120159: [[110], 256], 120160: [[111], 256], 120161: [[112], 256], 120162: [[113], 256], 120163: [[114], 256], 120164: [[115], 256], 120165: [[116], 256], 120166: [[117], 256], 120167: [[118], 256], 120168: [[119], 256], 120169: [[120], 256], 120170: [[121], 256], 120171: [[122], 256], 120172: [[65], 256], 120173: [[66], 256], 120174: [[67], 256], 120175: [[68], 256], 120176: [[69], 256], 120177: [[70], 256], 120178: [[71], 256], 120179: [[72], 256], 120180: [[73], 256], 120181: [[74], 256], 120182: [[75], 256], 120183: [[76], 256], 120184: [[77], 256], 120185: [[78], 256], 120186: [[79], 256], 120187: [[80], 256], 120188: [[81], 256], 120189: [[82], 256], 120190: [[83], 256], 120191: [[84], 256], 120192: [[85], 256], 120193: [[86], 256], 120194: [[87], 256], 120195: [[88], 256], 120196: [[89], 256], 120197: [[90], 256], 120198: [[97], 256], 120199: [[98], 256], 120200: [[99], 256], 120201: [[100], 256], 120202: [[101], 256], 120203: [[102], 256], 120204: [[103], 256], 120205: [[104], 256], 120206: [[105], 256], 120207: [[106], 256], 120208: [[107], 256], 120209: [[108], 256], 120210: [[109], 256], 120211: [[110], 256], 120212: [[111], 256], 120213: [[112], 256], 120214: [[113], 256], 120215: [[114], 256], 120216: [[115], 256], 120217: [[116], 256], 120218: [[117], 256], 120219: [[118], 256], 120220: [[119], 256], 120221: [[120], 256], 120222: [[121], 256], 120223: [[122], 256], 120224: [[65], 256], 120225: [[66], 256], 120226: [[67], 256], 120227: [[68], 256], 120228: [[69], 256], 120229: [[70], 256], 120230: [[71], 256], 120231: [[72], 256], 120232: [[73], 256], 120233: [[74], 256], 120234: [[75], 256], 120235: [[76], 256], 120236: [[77], 256], 120237: [[78], 256], 120238: [[79], 256], 120239: [[80], 256], 120240: [[81], 256], 120241: [[82], 256], 120242: [[83], 256], 120243: [[84], 256], 120244: [[85], 256], 120245: [[86], 256], 120246: [[87], 256], 120247: [[88], 256], 120248: [[89], 256], 120249: [[90], 256], 120250: [[97], 256], 120251: [[98], 256], 120252: [[99], 256], 120253: [[100], 256], 120254: [[101], 256], 120255: [[102], 256], 120256: [[103], 256], 120257: [[104], 256], 120258: [[105], 256], 120259: [[106], 256], 120260: [[107], 256], 120261: [[108], 256], 120262: [[109], 256], 120263: [[110], 256], 120264: [[111], 256], 120265: [[112], 256], 120266: [[113], 256], 120267: [[114], 256], 120268: [[115], 256], 120269: [[116], 256], 120270: [[117], 256], 120271: [[118], 256], 120272: [[119], 256], 120273: [[120], 256], 120274: [[121], 256], 120275: [[122], 256], 120276: [[65], 256], 120277: [[66], 256], 120278: [[67], 256], 120279: [[68], 256], 120280: [[69], 256], 120281: [[70], 256], 120282: [[71], 256], 120283: [[72], 256], 120284: [[73], 256], 120285: [[74], 256], 120286: [[75], 256], 120287: [[76], 256], 120288: [[77], 256], 120289: [[78], 256], 120290: [[79], 256], 120291: [[80], 256], 120292: [[81], 256], 120293: [[82], 256], 120294: [[83], 256], 120295: [[84], 256], 120296: [[85], 256], 120297: [[86], 256], 120298: [[87], 256], 120299: [[88], 256], 120300: [[89], 256], 120301: [[90], 256], 120302: [[97], 256], 120303: [[98], 256], 120304: [[99], 256], 120305: [[100], 256], 120306: [[101], 256], 120307: [[102], 256], 120308: [[103], 256], 120309: [[104], 256], 120310: [[105], 256], 120311: [[106], 256], 120312: [[107], 256], 120313: [[108], 256], 120314: [[109], 256], 120315: [[110], 256], 120316: [[111], 256], 120317: [[112], 256], 120318: [[113], 256], 120319: [[114], 256] },
  54784: { 120320: [[115], 256], 120321: [[116], 256], 120322: [[117], 256], 120323: [[118], 256], 120324: [[119], 256], 120325: [[120], 256], 120326: [[121], 256], 120327: [[122], 256], 120328: [[65], 256], 120329: [[66], 256], 120330: [[67], 256], 120331: [[68], 256], 120332: [[69], 256], 120333: [[70], 256], 120334: [[71], 256], 120335: [[72], 256], 120336: [[73], 256], 120337: [[74], 256], 120338: [[75], 256], 120339: [[76], 256], 120340: [[77], 256], 120341: [[78], 256], 120342: [[79], 256], 120343: [[80], 256], 120344: [[81], 256], 120345: [[82], 256], 120346: [[83], 256], 120347: [[84], 256], 120348: [[85], 256], 120349: [[86], 256], 120350: [[87], 256], 120351: [[88], 256], 120352: [[89], 256], 120353: [[90], 256], 120354: [[97], 256], 120355: [[98], 256], 120356: [[99], 256], 120357: [[100], 256], 120358: [[101], 256], 120359: [[102], 256], 120360: [[103], 256], 120361: [[104], 256], 120362: [[105], 256], 120363: [[106], 256], 120364: [[107], 256], 120365: [[108], 256], 120366: [[109], 256], 120367: [[110], 256], 120368: [[111], 256], 120369: [[112], 256], 120370: [[113], 256], 120371: [[114], 256], 120372: [[115], 256], 120373: [[116], 256], 120374: [[117], 256], 120375: [[118], 256], 120376: [[119], 256], 120377: [[120], 256], 120378: [[121], 256], 120379: [[122], 256], 120380: [[65], 256], 120381: [[66], 256], 120382: [[67], 256], 120383: [[68], 256], 120384: [[69], 256], 120385: [[70], 256], 120386: [[71], 256], 120387: [[72], 256], 120388: [[73], 256], 120389: [[74], 256], 120390: [[75], 256], 120391: [[76], 256], 120392: [[77], 256], 120393: [[78], 256], 120394: [[79], 256], 120395: [[80], 256], 120396: [[81], 256], 120397: [[82], 256], 120398: [[83], 256], 120399: [[84], 256], 120400: [[85], 256], 120401: [[86], 256], 120402: [[87], 256], 120403: [[88], 256], 120404: [[89], 256], 120405: [[90], 256], 120406: [[97], 256], 120407: [[98], 256], 120408: [[99], 256], 120409: [[100], 256], 120410: [[101], 256], 120411: [[102], 256], 120412: [[103], 256], 120413: [[104], 256], 120414: [[105], 256], 120415: [[106], 256], 120416: [[107], 256], 120417: [[108], 256], 120418: [[109], 256], 120419: [[110], 256], 120420: [[111], 256], 120421: [[112], 256], 120422: [[113], 256], 120423: [[114], 256], 120424: [[115], 256], 120425: [[116], 256], 120426: [[117], 256], 120427: [[118], 256], 120428: [[119], 256], 120429: [[120], 256], 120430: [[121], 256], 120431: [[122], 256], 120432: [[65], 256], 120433: [[66], 256], 120434: [[67], 256], 120435: [[68], 256], 120436: [[69], 256], 120437: [[70], 256], 120438: [[71], 256], 120439: [[72], 256], 120440: [[73], 256], 120441: [[74], 256], 120442: [[75], 256], 120443: [[76], 256], 120444: [[77], 256], 120445: [[78], 256], 120446: [[79], 256], 120447: [[80], 256], 120448: [[81], 256], 120449: [[82], 256], 120450: [[83], 256], 120451: [[84], 256], 120452: [[85], 256], 120453: [[86], 256], 120454: [[87], 256], 120455: [[88], 256], 120456: [[89], 256], 120457: [[90], 256], 120458: [[97], 256], 120459: [[98], 256], 120460: [[99], 256], 120461: [[100], 256], 120462: [[101], 256], 120463: [[102], 256], 120464: [[103], 256], 120465: [[104], 256], 120466: [[105], 256], 120467: [[106], 256], 120468: [[107], 256], 120469: [[108], 256], 120470: [[109], 256], 120471: [[110], 256], 120472: [[111], 256], 120473: [[112], 256], 120474: [[113], 256], 120475: [[114], 256], 120476: [[115], 256], 120477: [[116], 256], 120478: [[117], 256], 120479: [[118], 256], 120480: [[119], 256], 120481: [[120], 256], 120482: [[121], 256], 120483: [[122], 256], 120484: [[305], 256], 120485: [[567], 256], 120488: [[913], 256], 120489: [[914], 256], 120490: [[915], 256], 120491: [[916], 256], 120492: [[917], 256], 120493: [[918], 256], 120494: [[919], 256], 120495: [[920], 256], 120496: [[921], 256], 120497: [[922], 256], 120498: [[923], 256], 120499: [[924], 256], 120500: [[925], 256], 120501: [[926], 256], 120502: [[927], 256], 120503: [[928], 256], 120504: [[929], 256], 120505: [[1012], 256], 120506: [[931], 256], 120507: [[932], 256], 120508: [[933], 256], 120509: [[934], 256], 120510: [[935], 256], 120511: [[936], 256], 120512: [[937], 256], 120513: [[8711], 256], 120514: [[945], 256], 120515: [[946], 256], 120516: [[947], 256], 120517: [[948], 256], 120518: [[949], 256], 120519: [[950], 256], 120520: [[951], 256], 120521: [[952], 256], 120522: [[953], 256], 120523: [[954], 256], 120524: [[955], 256], 120525: [[956], 256], 120526: [[957], 256], 120527: [[958], 256], 120528: [[959], 256], 120529: [[960], 256], 120530: [[961], 256], 120531: [[962], 256], 120532: [[963], 256], 120533: [[964], 256], 120534: [[965], 256], 120535: [[966], 256], 120536: [[967], 256], 120537: [[968], 256], 120538: [[969], 256], 120539: [[8706], 256], 120540: [[1013], 256], 120541: [[977], 256], 120542: [[1008], 256], 120543: [[981], 256], 120544: [[1009], 256], 120545: [[982], 256], 120546: [[913], 256], 120547: [[914], 256], 120548: [[915], 256], 120549: [[916], 256], 120550: [[917], 256], 120551: [[918], 256], 120552: [[919], 256], 120553: [[920], 256], 120554: [[921], 256], 120555: [[922], 256], 120556: [[923], 256], 120557: [[924], 256], 120558: [[925], 256], 120559: [[926], 256], 120560: [[927], 256], 120561: [[928], 256], 120562: [[929], 256], 120563: [[1012], 256], 120564: [[931], 256], 120565: [[932], 256], 120566: [[933], 256], 120567: [[934], 256], 120568: [[935], 256], 120569: [[936], 256], 120570: [[937], 256], 120571: [[8711], 256], 120572: [[945], 256], 120573: [[946], 256], 120574: [[947], 256], 120575: [[948], 256] },
  55040: { 120576: [[949], 256], 120577: [[950], 256], 120578: [[951], 256], 120579: [[952], 256], 120580: [[953], 256], 120581: [[954], 256], 120582: [[955], 256], 120583: [[956], 256], 120584: [[957], 256], 120585: [[958], 256], 120586: [[959], 256], 120587: [[960], 256], 120588: [[961], 256], 120589: [[962], 256], 120590: [[963], 256], 120591: [[964], 256], 120592: [[965], 256], 120593: [[966], 256], 120594: [[967], 256], 120595: [[968], 256], 120596: [[969], 256], 120597: [[8706], 256], 120598: [[1013], 256], 120599: [[977], 256], 120600: [[1008], 256], 120601: [[981], 256], 120602: [[1009], 256], 120603: [[982], 256], 120604: [[913], 256], 120605: [[914], 256], 120606: [[915], 256], 120607: [[916], 256], 120608: [[917], 256], 120609: [[918], 256], 120610: [[919], 256], 120611: [[920], 256], 120612: [[921], 256], 120613: [[922], 256], 120614: [[923], 256], 120615: [[924], 256], 120616: [[925], 256], 120617: [[926], 256], 120618: [[927], 256], 120619: [[928], 256], 120620: [[929], 256], 120621: [[1012], 256], 120622: [[931], 256], 120623: [[932], 256], 120624: [[933], 256], 120625: [[934], 256], 120626: [[935], 256], 120627: [[936], 256], 120628: [[937], 256], 120629: [[8711], 256], 120630: [[945], 256], 120631: [[946], 256], 120632: [[947], 256], 120633: [[948], 256], 120634: [[949], 256], 120635: [[950], 256], 120636: [[951], 256], 120637: [[952], 256], 120638: [[953], 256], 120639: [[954], 256], 120640: [[955], 256], 120641: [[956], 256], 120642: [[957], 256], 120643: [[958], 256], 120644: [[959], 256], 120645: [[960], 256], 120646: [[961], 256], 120647: [[962], 256], 120648: [[963], 256], 120649: [[964], 256], 120650: [[965], 256], 120651: [[966], 256], 120652: [[967], 256], 120653: [[968], 256], 120654: [[969], 256], 120655: [[8706], 256], 120656: [[1013], 256], 120657: [[977], 256], 120658: [[1008], 256], 120659: [[981], 256], 120660: [[1009], 256], 120661: [[982], 256], 120662: [[913], 256], 120663: [[914], 256], 120664: [[915], 256], 120665: [[916], 256], 120666: [[917], 256], 120667: [[918], 256], 120668: [[919], 256], 120669: [[920], 256], 120670: [[921], 256], 120671: [[922], 256], 120672: [[923], 256], 120673: [[924], 256], 120674: [[925], 256], 120675: [[926], 256], 120676: [[927], 256], 120677: [[928], 256], 120678: [[929], 256], 120679: [[1012], 256], 120680: [[931], 256], 120681: [[932], 256], 120682: [[933], 256], 120683: [[934], 256], 120684: [[935], 256], 120685: [[936], 256], 120686: [[937], 256], 120687: [[8711], 256], 120688: [[945], 256], 120689: [[946], 256], 120690: [[947], 256], 120691: [[948], 256], 120692: [[949], 256], 120693: [[950], 256], 120694: [[951], 256], 120695: [[952], 256], 120696: [[953], 256], 120697: [[954], 256], 120698: [[955], 256], 120699: [[956], 256], 120700: [[957], 256], 120701: [[958], 256], 120702: [[959], 256], 120703: [[960], 256], 120704: [[961], 256], 120705: [[962], 256], 120706: [[963], 256], 120707: [[964], 256], 120708: [[965], 256], 120709: [[966], 256], 120710: [[967], 256], 120711: [[968], 256], 120712: [[969], 256], 120713: [[8706], 256], 120714: [[1013], 256], 120715: [[977], 256], 120716: [[1008], 256], 120717: [[981], 256], 120718: [[1009], 256], 120719: [[982], 256], 120720: [[913], 256], 120721: [[914], 256], 120722: [[915], 256], 120723: [[916], 256], 120724: [[917], 256], 120725: [[918], 256], 120726: [[919], 256], 120727: [[920], 256], 120728: [[921], 256], 120729: [[922], 256], 120730: [[923], 256], 120731: [[924], 256], 120732: [[925], 256], 120733: [[926], 256], 120734: [[927], 256], 120735: [[928], 256], 120736: [[929], 256], 120737: [[1012], 256], 120738: [[931], 256], 120739: [[932], 256], 120740: [[933], 256], 120741: [[934], 256], 120742: [[935], 256], 120743: [[936], 256], 120744: [[937], 256], 120745: [[8711], 256], 120746: [[945], 256], 120747: [[946], 256], 120748: [[947], 256], 120749: [[948], 256], 120750: [[949], 256], 120751: [[950], 256], 120752: [[951], 256], 120753: [[952], 256], 120754: [[953], 256], 120755: [[954], 256], 120756: [[955], 256], 120757: [[956], 256], 120758: [[957], 256], 120759: [[958], 256], 120760: [[959], 256], 120761: [[960], 256], 120762: [[961], 256], 120763: [[962], 256], 120764: [[963], 256], 120765: [[964], 256], 120766: [[965], 256], 120767: [[966], 256], 120768: [[967], 256], 120769: [[968], 256], 120770: [[969], 256], 120771: [[8706], 256], 120772: [[1013], 256], 120773: [[977], 256], 120774: [[1008], 256], 120775: [[981], 256], 120776: [[1009], 256], 120777: [[982], 256], 120778: [[988], 256], 120779: [[989], 256], 120782: [[48], 256], 120783: [[49], 256], 120784: [[50], 256], 120785: [[51], 256], 120786: [[52], 256], 120787: [[53], 256], 120788: [[54], 256], 120789: [[55], 256], 120790: [[56], 256], 120791: [[57], 256], 120792: [[48], 256], 120793: [[49], 256], 120794: [[50], 256], 120795: [[51], 256], 120796: [[52], 256], 120797: [[53], 256], 120798: [[54], 256], 120799: [[55], 256], 120800: [[56], 256], 120801: [[57], 256], 120802: [[48], 256], 120803: [[49], 256], 120804: [[50], 256], 120805: [[51], 256], 120806: [[52], 256], 120807: [[53], 256], 120808: [[54], 256], 120809: [[55], 256], 120810: [[56], 256], 120811: [[57], 256], 120812: [[48], 256], 120813: [[49], 256], 120814: [[50], 256], 120815: [[51], 256], 120816: [[52], 256], 120817: [[53], 256], 120818: [[54], 256], 120819: [[55], 256], 120820: [[56], 256], 120821: [[57], 256], 120822: [[48], 256], 120823: [[49], 256], 120824: [[50], 256], 120825: [[51], 256], 120826: [[52], 256], 120827: [[53], 256], 120828: [[54], 256], 120829: [[55], 256], 120830: [[56], 256], 120831: [[57], 256] },
  59392: { 125136: [null, 220], 125137: [null, 220], 125138: [null, 220], 125139: [null, 220], 125140: [null, 220], 125141: [null, 220], 125142: [null, 220] },
  60928: { 126464: [[1575], 256], 126465: [[1576], 256], 126466: [[1580], 256], 126467: [[1583], 256], 126469: [[1608], 256], 126470: [[1586], 256], 126471: [[1581], 256], 126472: [[1591], 256], 126473: [[1610], 256], 126474: [[1603], 256], 126475: [[1604], 256], 126476: [[1605], 256], 126477: [[1606], 256], 126478: [[1587], 256], 126479: [[1593], 256], 126480: [[1601], 256], 126481: [[1589], 256], 126482: [[1602], 256], 126483: [[1585], 256], 126484: [[1588], 256], 126485: [[1578], 256], 126486: [[1579], 256], 126487: [[1582], 256], 126488: [[1584], 256], 126489: [[1590], 256], 126490: [[1592], 256], 126491: [[1594], 256], 126492: [[1646], 256], 126493: [[1722], 256], 126494: [[1697], 256], 126495: [[1647], 256], 126497: [[1576], 256], 126498: [[1580], 256], 126500: [[1607], 256], 126503: [[1581], 256], 126505: [[1610], 256], 126506: [[1603], 256], 126507: [[1604], 256], 126508: [[1605], 256], 126509: [[1606], 256], 126510: [[1587], 256], 126511: [[1593], 256], 126512: [[1601], 256], 126513: [[1589], 256], 126514: [[1602], 256], 126516: [[1588], 256], 126517: [[1578], 256], 126518: [[1579], 256], 126519: [[1582], 256], 126521: [[1590], 256], 126523: [[1594], 256], 126530: [[1580], 256], 126535: [[1581], 256], 126537: [[1610], 256], 126539: [[1604], 256], 126541: [[1606], 256], 126542: [[1587], 256], 126543: [[1593], 256], 126545: [[1589], 256], 126546: [[1602], 256], 126548: [[1588], 256], 126551: [[1582], 256], 126553: [[1590], 256], 126555: [[1594], 256], 126557: [[1722], 256], 126559: [[1647], 256], 126561: [[1576], 256], 126562: [[1580], 256], 126564: [[1607], 256], 126567: [[1581], 256], 126568: [[1591], 256], 126569: [[1610], 256], 126570: [[1603], 256], 126572: [[1605], 256], 126573: [[1606], 256], 126574: [[1587], 256], 126575: [[1593], 256], 126576: [[1601], 256], 126577: [[1589], 256], 126578: [[1602], 256], 126580: [[1588], 256], 126581: [[1578], 256], 126582: [[1579], 256], 126583: [[1582], 256], 126585: [[1590], 256], 126586: [[1592], 256], 126587: [[1594], 256], 126588: [[1646], 256], 126590: [[1697], 256], 126592: [[1575], 256], 126593: [[1576], 256], 126594: [[1580], 256], 126595: [[1583], 256], 126596: [[1607], 256], 126597: [[1608], 256], 126598: [[1586], 256], 126599: [[1581], 256], 126600: [[1591], 256], 126601: [[1610], 256], 126603: [[1604], 256], 126604: [[1605], 256], 126605: [[1606], 256], 126606: [[1587], 256], 126607: [[1593], 256], 126608: [[1601], 256], 126609: [[1589], 256], 126610: [[1602], 256], 126611: [[1585], 256], 126612: [[1588], 256], 126613: [[1578], 256], 126614: [[1579], 256], 126615: [[1582], 256], 126616: [[1584], 256], 126617: [[1590], 256], 126618: [[1592], 256], 126619: [[1594], 256], 126625: [[1576], 256], 126626: [[1580], 256], 126627: [[1583], 256], 126629: [[1608], 256], 126630: [[1586], 256], 126631: [[1581], 256], 126632: [[1591], 256], 126633: [[1610], 256], 126635: [[1604], 256], 126636: [[1605], 256], 126637: [[1606], 256], 126638: [[1587], 256], 126639: [[1593], 256], 126640: [[1601], 256], 126641: [[1589], 256], 126642: [[1602], 256], 126643: [[1585], 256], 126644: [[1588], 256], 126645: [[1578], 256], 126646: [[1579], 256], 126647: [[1582], 256], 126648: [[1584], 256], 126649: [[1590], 256], 126650: [[1592], 256], 126651: [[1594], 256] },
  61696: { 127232: [[48, 46], 256], 127233: [[48, 44], 256], 127234: [[49, 44], 256], 127235: [[50, 44], 256], 127236: [[51, 44], 256], 127237: [[52, 44], 256], 127238: [[53, 44], 256], 127239: [[54, 44], 256], 127240: [[55, 44], 256], 127241: [[56, 44], 256], 127242: [[57, 44], 256], 127248: [[40, 65, 41], 256], 127249: [[40, 66, 41], 256], 127250: [[40, 67, 41], 256], 127251: [[40, 68, 41], 256], 127252: [[40, 69, 41], 256], 127253: [[40, 70, 41], 256], 127254: [[40, 71, 41], 256], 127255: [[40, 72, 41], 256], 127256: [[40, 73, 41], 256], 127257: [[40, 74, 41], 256], 127258: [[40, 75, 41], 256], 127259: [[40, 76, 41], 256], 127260: [[40, 77, 41], 256], 127261: [[40, 78, 41], 256], 127262: [[40, 79, 41], 256], 127263: [[40, 80, 41], 256], 127264: [[40, 81, 41], 256], 127265: [[40, 82, 41], 256], 127266: [[40, 83, 41], 256], 127267: [[40, 84, 41], 256], 127268: [[40, 85, 41], 256], 127269: [[40, 86, 41], 256], 127270: [[40, 87, 41], 256], 127271: [[40, 88, 41], 256], 127272: [[40, 89, 41], 256], 127273: [[40, 90, 41], 256], 127274: [[12308, 83, 12309], 256], 127275: [[67], 256], 127276: [[82], 256], 127277: [[67, 68], 256], 127278: [[87, 90], 256], 127280: [[65], 256], 127281: [[66], 256], 127282: [[67], 256], 127283: [[68], 256], 127284: [[69], 256], 127285: [[70], 256], 127286: [[71], 256], 127287: [[72], 256], 127288: [[73], 256], 127289: [[74], 256], 127290: [[75], 256], 127291: [[76], 256], 127292: [[77], 256], 127293: [[78], 256], 127294: [[79], 256], 127295: [[80], 256], 127296: [[81], 256], 127297: [[82], 256], 127298: [[83], 256], 127299: [[84], 256], 127300: [[85], 256], 127301: [[86], 256], 127302: [[87], 256], 127303: [[88], 256], 127304: [[89], 256], 127305: [[90], 256], 127306: [[72, 86], 256], 127307: [[77, 86], 256], 127308: [[83, 68], 256], 127309: [[83, 83], 256], 127310: [[80, 80, 86], 256], 127311: [[87, 67], 256], 127338: [[77, 67], 256], 127339: [[77, 68], 256], 127376: [[68, 74], 256] },
  61952: { 127488: [[12411, 12363], 256], 127489: [[12467, 12467], 256], 127490: [[12469], 256], 127504: [[25163], 256], 127505: [[23383], 256], 127506: [[21452], 256], 127507: [[12487], 256], 127508: [[20108], 256], 127509: [[22810], 256], 127510: [[35299], 256], 127511: [[22825], 256], 127512: [[20132], 256], 127513: [[26144], 256], 127514: [[28961], 256], 127515: [[26009], 256], 127516: [[21069], 256], 127517: [[24460], 256], 127518: [[20877], 256], 127519: [[26032], 256], 127520: [[21021], 256], 127521: [[32066], 256], 127522: [[29983], 256], 127523: [[36009], 256], 127524: [[22768], 256], 127525: [[21561], 256], 127526: [[28436], 256], 127527: [[25237], 256], 127528: [[25429], 256], 127529: [[19968], 256], 127530: [[19977], 256], 127531: [[36938], 256], 127532: [[24038], 256], 127533: [[20013], 256], 127534: [[21491], 256], 127535: [[25351], 256], 127536: [[36208], 256], 127537: [[25171], 256], 127538: [[31105], 256], 127539: [[31354], 256], 127540: [[21512], 256], 127541: [[28288], 256], 127542: [[26377], 256], 127543: [[26376], 256], 127544: [[30003], 256], 127545: [[21106], 256], 127546: [[21942], 256], 127552: [[12308, 26412, 12309], 256], 127553: [[12308, 19977, 12309], 256], 127554: [[12308, 20108, 12309], 256], 127555: [[12308, 23433, 12309], 256], 127556: [[12308, 28857, 12309], 256], 127557: [[12308, 25171, 12309], 256], 127558: [[12308, 30423, 12309], 256], 127559: [[12308, 21213, 12309], 256], 127560: [[12308, 25943, 12309], 256], 127568: [[24471], 256], 127569: [[21487], 256] },
  63488: { 194560: [[20029]], 194561: [[20024]], 194562: [[20033]], 194563: [[131362]], 194564: [[20320]], 194565: [[20398]], 194566: [[20411]], 194567: [[20482]], 194568: [[20602]], 194569: [[20633]], 194570: [[20711]], 194571: [[20687]], 194572: [[13470]], 194573: [[132666]], 194574: [[20813]], 194575: [[20820]], 194576: [[20836]], 194577: [[20855]], 194578: [[132380]], 194579: [[13497]], 194580: [[20839]], 194581: [[20877]], 194582: [[132427]], 194583: [[20887]], 194584: [[20900]], 194585: [[20172]], 194586: [[20908]], 194587: [[20917]], 194588: [[168415]], 194589: [[20981]], 194590: [[20995]], 194591: [[13535]], 194592: [[21051]], 194593: [[21062]], 194594: [[21106]], 194595: [[21111]], 194596: [[13589]], 194597: [[21191]], 194598: [[21193]], 194599: [[21220]], 194600: [[21242]], 194601: [[21253]], 194602: [[21254]], 194603: [[21271]], 194604: [[21321]], 194605: [[21329]], 194606: [[21338]], 194607: [[21363]], 194608: [[21373]], 194609: [[21375]], 194610: [[21375]], 194611: [[21375]], 194612: [[133676]], 194613: [[28784]], 194614: [[21450]], 194615: [[21471]], 194616: [[133987]], 194617: [[21483]], 194618: [[21489]], 194619: [[21510]], 194620: [[21662]], 194621: [[21560]], 194622: [[21576]], 194623: [[21608]], 194624: [[21666]], 194625: [[21750]], 194626: [[21776]], 194627: [[21843]], 194628: [[21859]], 194629: [[21892]], 194630: [[21892]], 194631: [[21913]], 194632: [[21931]], 194633: [[21939]], 194634: [[21954]], 194635: [[22294]], 194636: [[22022]], 194637: [[22295]], 194638: [[22097]], 194639: [[22132]], 194640: [[20999]], 194641: [[22766]], 194642: [[22478]], 194643: [[22516]], 194644: [[22541]], 194645: [[22411]], 194646: [[22578]], 194647: [[22577]], 194648: [[22700]], 194649: [[136420]], 194650: [[22770]], 194651: [[22775]], 194652: [[22790]], 194653: [[22810]], 194654: [[22818]], 194655: [[22882]], 194656: [[136872]], 194657: [[136938]], 194658: [[23020]], 194659: [[23067]], 194660: [[23079]], 194661: [[23e3]], 194662: [[23142]], 194663: [[14062]], 194664: [[14076]], 194665: [[23304]], 194666: [[23358]], 194667: [[23358]], 194668: [[137672]], 194669: [[23491]], 194670: [[23512]], 194671: [[23527]], 194672: [[23539]], 194673: [[138008]], 194674: [[23551]], 194675: [[23558]], 194676: [[24403]], 194677: [[23586]], 194678: [[14209]], 194679: [[23648]], 194680: [[23662]], 194681: [[23744]], 194682: [[23693]], 194683: [[138724]], 194684: [[23875]], 194685: [[138726]], 194686: [[23918]], 194687: [[23915]], 194688: [[23932]], 194689: [[24033]], 194690: [[24034]], 194691: [[14383]], 194692: [[24061]], 194693: [[24104]], 194694: [[24125]], 194695: [[24169]], 194696: [[14434]], 194697: [[139651]], 194698: [[14460]], 194699: [[24240]], 194700: [[24243]], 194701: [[24246]], 194702: [[24266]], 194703: [[172946]], 194704: [[24318]], 194705: [[140081]], 194706: [[140081]], 194707: [[33281]], 194708: [[24354]], 194709: [[24354]], 194710: [[14535]], 194711: [[144056]], 194712: [[156122]], 194713: [[24418]], 194714: [[24427]], 194715: [[14563]], 194716: [[24474]], 194717: [[24525]], 194718: [[24535]], 194719: [[24569]], 194720: [[24705]], 194721: [[14650]], 194722: [[14620]], 194723: [[24724]], 194724: [[141012]], 194725: [[24775]], 194726: [[24904]], 194727: [[24908]], 194728: [[24910]], 194729: [[24908]], 194730: [[24954]], 194731: [[24974]], 194732: [[25010]], 194733: [[24996]], 194734: [[25007]], 194735: [[25054]], 194736: [[25074]], 194737: [[25078]], 194738: [[25104]], 194739: [[25115]], 194740: [[25181]], 194741: [[25265]], 194742: [[25300]], 194743: [[25424]], 194744: [[142092]], 194745: [[25405]], 194746: [[25340]], 194747: [[25448]], 194748: [[25475]], 194749: [[25572]], 194750: [[142321]], 194751: [[25634]], 194752: [[25541]], 194753: [[25513]], 194754: [[14894]], 194755: [[25705]], 194756: [[25726]], 194757: [[25757]], 194758: [[25719]], 194759: [[14956]], 194760: [[25935]], 194761: [[25964]], 194762: [[143370]], 194763: [[26083]], 194764: [[26360]], 194765: [[26185]], 194766: [[15129]], 194767: [[26257]], 194768: [[15112]], 194769: [[15076]], 194770: [[20882]], 194771: [[20885]], 194772: [[26368]], 194773: [[26268]], 194774: [[32941]], 194775: [[17369]], 194776: [[26391]], 194777: [[26395]], 194778: [[26401]], 194779: [[26462]], 194780: [[26451]], 194781: [[144323]], 194782: [[15177]], 194783: [[26618]], 194784: [[26501]], 194785: [[26706]], 194786: [[26757]], 194787: [[144493]], 194788: [[26766]], 194789: [[26655]], 194790: [[26900]], 194791: [[15261]], 194792: [[26946]], 194793: [[27043]], 194794: [[27114]], 194795: [[27304]], 194796: [[145059]], 194797: [[27355]], 194798: [[15384]], 194799: [[27425]], 194800: [[145575]], 194801: [[27476]], 194802: [[15438]], 194803: [[27506]], 194804: [[27551]], 194805: [[27578]], 194806: [[27579]], 194807: [[146061]], 194808: [[138507]], 194809: [[146170]], 194810: [[27726]], 194811: [[146620]], 194812: [[27839]], 194813: [[27853]], 194814: [[27751]], 194815: [[27926]] },
  63744: { 63744: [[35912]], 63745: [[26356]], 63746: [[36554]], 63747: [[36040]], 63748: [[28369]], 63749: [[20018]], 63750: [[21477]], 63751: [[40860]], 63752: [[40860]], 63753: [[22865]], 63754: [[37329]], 63755: [[21895]], 63756: [[22856]], 63757: [[25078]], 63758: [[30313]], 63759: [[32645]], 63760: [[34367]], 63761: [[34746]], 63762: [[35064]], 63763: [[37007]], 63764: [[27138]], 63765: [[27931]], 63766: [[28889]], 63767: [[29662]], 63768: [[33853]], 63769: [[37226]], 63770: [[39409]], 63771: [[20098]], 63772: [[21365]], 63773: [[27396]], 63774: [[29211]], 63775: [[34349]], 63776: [[40478]], 63777: [[23888]], 63778: [[28651]], 63779: [[34253]], 63780: [[35172]], 63781: [[25289]], 63782: [[33240]], 63783: [[34847]], 63784: [[24266]], 63785: [[26391]], 63786: [[28010]], 63787: [[29436]], 63788: [[37070]], 63789: [[20358]], 63790: [[20919]], 63791: [[21214]], 63792: [[25796]], 63793: [[27347]], 63794: [[29200]], 63795: [[30439]], 63796: [[32769]], 63797: [[34310]], 63798: [[34396]], 63799: [[36335]], 63800: [[38706]], 63801: [[39791]], 63802: [[40442]], 63803: [[30860]], 63804: [[31103]], 63805: [[32160]], 63806: [[33737]], 63807: [[37636]], 63808: [[40575]], 63809: [[35542]], 63810: [[22751]], 63811: [[24324]], 63812: [[31840]], 63813: [[32894]], 63814: [[29282]], 63815: [[30922]], 63816: [[36034]], 63817: [[38647]], 63818: [[22744]], 63819: [[23650]], 63820: [[27155]], 63821: [[28122]], 63822: [[28431]], 63823: [[32047]], 63824: [[32311]], 63825: [[38475]], 63826: [[21202]], 63827: [[32907]], 63828: [[20956]], 63829: [[20940]], 63830: [[31260]], 63831: [[32190]], 63832: [[33777]], 63833: [[38517]], 63834: [[35712]], 63835: [[25295]], 63836: [[27138]], 63837: [[35582]], 63838: [[20025]], 63839: [[23527]], 63840: [[24594]], 63841: [[29575]], 63842: [[30064]], 63843: [[21271]], 63844: [[30971]], 63845: [[20415]], 63846: [[24489]], 63847: [[19981]], 63848: [[27852]], 63849: [[25976]], 63850: [[32034]], 63851: [[21443]], 63852: [[22622]], 63853: [[30465]], 63854: [[33865]], 63855: [[35498]], 63856: [[27578]], 63857: [[36784]], 63858: [[27784]], 63859: [[25342]], 63860: [[33509]], 63861: [[25504]], 63862: [[30053]], 63863: [[20142]], 63864: [[20841]], 63865: [[20937]], 63866: [[26753]], 63867: [[31975]], 63868: [[33391]], 63869: [[35538]], 63870: [[37327]], 63871: [[21237]], 63872: [[21570]], 63873: [[22899]], 63874: [[24300]], 63875: [[26053]], 63876: [[28670]], 63877: [[31018]], 63878: [[38317]], 63879: [[39530]], 63880: [[40599]], 63881: [[40654]], 63882: [[21147]], 63883: [[26310]], 63884: [[27511]], 63885: [[36706]], 63886: [[24180]], 63887: [[24976]], 63888: [[25088]], 63889: [[25754]], 63890: [[28451]], 63891: [[29001]], 63892: [[29833]], 63893: [[31178]], 63894: [[32244]], 63895: [[32879]], 63896: [[36646]], 63897: [[34030]], 63898: [[36899]], 63899: [[37706]], 63900: [[21015]], 63901: [[21155]], 63902: [[21693]], 63903: [[28872]], 63904: [[35010]], 63905: [[35498]], 63906: [[24265]], 63907: [[24565]], 63908: [[25467]], 63909: [[27566]], 63910: [[31806]], 63911: [[29557]], 63912: [[20196]], 63913: [[22265]], 63914: [[23527]], 63915: [[23994]], 63916: [[24604]], 63917: [[29618]], 63918: [[29801]], 63919: [[32666]], 63920: [[32838]], 63921: [[37428]], 63922: [[38646]], 63923: [[38728]], 63924: [[38936]], 63925: [[20363]], 63926: [[31150]], 63927: [[37300]], 63928: [[38584]], 63929: [[24801]], 63930: [[20102]], 63931: [[20698]], 63932: [[23534]], 63933: [[23615]], 63934: [[26009]], 63935: [[27138]], 63936: [[29134]], 63937: [[30274]], 63938: [[34044]], 63939: [[36988]], 63940: [[40845]], 63941: [[26248]], 63942: [[38446]], 63943: [[21129]], 63944: [[26491]], 63945: [[26611]], 63946: [[27969]], 63947: [[28316]], 63948: [[29705]], 63949: [[30041]], 63950: [[30827]], 63951: [[32016]], 63952: [[39006]], 63953: [[20845]], 63954: [[25134]], 63955: [[38520]], 63956: [[20523]], 63957: [[23833]], 63958: [[28138]], 63959: [[36650]], 63960: [[24459]], 63961: [[24900]], 63962: [[26647]], 63963: [[29575]], 63964: [[38534]], 63965: [[21033]], 63966: [[21519]], 63967: [[23653]], 63968: [[26131]], 63969: [[26446]], 63970: [[26792]], 63971: [[27877]], 63972: [[29702]], 63973: [[30178]], 63974: [[32633]], 63975: [[35023]], 63976: [[35041]], 63977: [[37324]], 63978: [[38626]], 63979: [[21311]], 63980: [[28346]], 63981: [[21533]], 63982: [[29136]], 63983: [[29848]], 63984: [[34298]], 63985: [[38563]], 63986: [[40023]], 63987: [[40607]], 63988: [[26519]], 63989: [[28107]], 63990: [[33256]], 63991: [[31435]], 63992: [[31520]], 63993: [[31890]], 63994: [[29376]], 63995: [[28825]], 63996: [[35672]], 63997: [[20160]], 63998: [[33590]], 63999: [[21050]], 194816: [[27966]], 194817: [[28023]], 194818: [[27969]], 194819: [[28009]], 194820: [[28024]], 194821: [[28037]], 194822: [[146718]], 194823: [[27956]], 194824: [[28207]], 194825: [[28270]], 194826: [[15667]], 194827: [[28363]], 194828: [[28359]], 194829: [[147153]], 194830: [[28153]], 194831: [[28526]], 194832: [[147294]], 194833: [[147342]], 194834: [[28614]], 194835: [[28729]], 194836: [[28702]], 194837: [[28699]], 194838: [[15766]], 194839: [[28746]], 194840: [[28797]], 194841: [[28791]], 194842: [[28845]], 194843: [[132389]], 194844: [[28997]], 194845: [[148067]], 194846: [[29084]], 194847: [[148395]], 194848: [[29224]], 194849: [[29237]], 194850: [[29264]], 194851: [[149e3]], 194852: [[29312]], 194853: [[29333]], 194854: [[149301]], 194855: [[149524]], 194856: [[29562]], 194857: [[29579]], 194858: [[16044]], 194859: [[29605]], 194860: [[16056]], 194861: [[16056]], 194862: [[29767]], 194863: [[29788]], 194864: [[29809]], 194865: [[29829]], 194866: [[29898]], 194867: [[16155]], 194868: [[29988]], 194869: [[150582]], 194870: [[30014]], 194871: [[150674]], 194872: [[30064]], 194873: [[139679]], 194874: [[30224]], 194875: [[151457]], 194876: [[151480]], 194877: [[151620]], 194878: [[16380]], 194879: [[16392]], 194880: [[30452]], 194881: [[151795]], 194882: [[151794]], 194883: [[151833]], 194884: [[151859]], 194885: [[30494]], 194886: [[30495]], 194887: [[30495]], 194888: [[30538]], 194889: [[16441]], 194890: [[30603]], 194891: [[16454]], 194892: [[16534]], 194893: [[152605]], 194894: [[30798]], 194895: [[30860]], 194896: [[30924]], 194897: [[16611]], 194898: [[153126]], 194899: [[31062]], 194900: [[153242]], 194901: [[153285]], 194902: [[31119]], 194903: [[31211]], 194904: [[16687]], 194905: [[31296]], 194906: [[31306]], 194907: [[31311]], 194908: [[153980]], 194909: [[154279]], 194910: [[154279]], 194911: [[31470]], 194912: [[16898]], 194913: [[154539]], 194914: [[31686]], 194915: [[31689]], 194916: [[16935]], 194917: [[154752]], 194918: [[31954]], 194919: [[17056]], 194920: [[31976]], 194921: [[31971]], 194922: [[32e3]], 194923: [[155526]], 194924: [[32099]], 194925: [[17153]], 194926: [[32199]], 194927: [[32258]], 194928: [[32325]], 194929: [[17204]], 194930: [[156200]], 194931: [[156231]], 194932: [[17241]], 194933: [[156377]], 194934: [[32634]], 194935: [[156478]], 194936: [[32661]], 194937: [[32762]], 194938: [[32773]], 194939: [[156890]], 194940: [[156963]], 194941: [[32864]], 194942: [[157096]], 194943: [[32880]], 194944: [[144223]], 194945: [[17365]], 194946: [[32946]], 194947: [[33027]], 194948: [[17419]], 194949: [[33086]], 194950: [[23221]], 194951: [[157607]], 194952: [[157621]], 194953: [[144275]], 194954: [[144284]], 194955: [[33281]], 194956: [[33284]], 194957: [[36766]], 194958: [[17515]], 194959: [[33425]], 194960: [[33419]], 194961: [[33437]], 194962: [[21171]], 194963: [[33457]], 194964: [[33459]], 194965: [[33469]], 194966: [[33510]], 194967: [[158524]], 194968: [[33509]], 194969: [[33565]], 194970: [[33635]], 194971: [[33709]], 194972: [[33571]], 194973: [[33725]], 194974: [[33767]], 194975: [[33879]], 194976: [[33619]], 194977: [[33738]], 194978: [[33740]], 194979: [[33756]], 194980: [[158774]], 194981: [[159083]], 194982: [[158933]], 194983: [[17707]], 194984: [[34033]], 194985: [[34035]], 194986: [[34070]], 194987: [[160714]], 194988: [[34148]], 194989: [[159532]], 194990: [[17757]], 194991: [[17761]], 194992: [[159665]], 194993: [[159954]], 194994: [[17771]], 194995: [[34384]], 194996: [[34396]], 194997: [[34407]], 194998: [[34409]], 194999: [[34473]], 195e3: [[34440]], 195001: [[34574]], 195002: [[34530]], 195003: [[34681]], 195004: [[34600]], 195005: [[34667]], 195006: [[34694]], 195007: [[17879]], 195008: [[34785]], 195009: [[34817]], 195010: [[17913]], 195011: [[34912]], 195012: [[34915]], 195013: [[161383]], 195014: [[35031]], 195015: [[35038]], 195016: [[17973]], 195017: [[35066]], 195018: [[13499]], 195019: [[161966]], 195020: [[162150]], 195021: [[18110]], 195022: [[18119]], 195023: [[35488]], 195024: [[35565]], 195025: [[35722]], 195026: [[35925]], 195027: [[162984]], 195028: [[36011]], 195029: [[36033]], 195030: [[36123]], 195031: [[36215]], 195032: [[163631]], 195033: [[133124]], 195034: [[36299]], 195035: [[36284]], 195036: [[36336]], 195037: [[133342]], 195038: [[36564]], 195039: [[36664]], 195040: [[165330]], 195041: [[165357]], 195042: [[37012]], 195043: [[37105]], 195044: [[37137]], 195045: [[165678]], 195046: [[37147]], 195047: [[37432]], 195048: [[37591]], 195049: [[37592]], 195050: [[37500]], 195051: [[37881]], 195052: [[37909]], 195053: [[166906]], 195054: [[38283]], 195055: [[18837]], 195056: [[38327]], 195057: [[167287]], 195058: [[18918]], 195059: [[38595]], 195060: [[23986]], 195061: [[38691]], 195062: [[168261]], 195063: [[168474]], 195064: [[19054]], 195065: [[19062]], 195066: [[38880]], 195067: [[168970]], 195068: [[19122]], 195069: [[169110]], 195070: [[38923]], 195071: [[38923]] },
  64e3: { 64e3: [[20999]], 64001: [[24230]], 64002: [[25299]], 64003: [[31958]], 64004: [[23429]], 64005: [[27934]], 64006: [[26292]], 64007: [[36667]], 64008: [[34892]], 64009: [[38477]], 64010: [[35211]], 64011: [[24275]], 64012: [[20800]], 64013: [[21952]], 64016: [[22618]], 64018: [[26228]], 64021: [[20958]], 64022: [[29482]], 64023: [[30410]], 64024: [[31036]], 64025: [[31070]], 64026: [[31077]], 64027: [[31119]], 64028: [[38742]], 64029: [[31934]], 64030: [[32701]], 64032: [[34322]], 64034: [[35576]], 64037: [[36920]], 64038: [[37117]], 64042: [[39151]], 64043: [[39164]], 64044: [[39208]], 64045: [[40372]], 64046: [[37086]], 64047: [[38583]], 64048: [[20398]], 64049: [[20711]], 64050: [[20813]], 64051: [[21193]], 64052: [[21220]], 64053: [[21329]], 64054: [[21917]], 64055: [[22022]], 64056: [[22120]], 64057: [[22592]], 64058: [[22696]], 64059: [[23652]], 64060: [[23662]], 64061: [[24724]], 64062: [[24936]], 64063: [[24974]], 64064: [[25074]], 64065: [[25935]], 64066: [[26082]], 64067: [[26257]], 64068: [[26757]], 64069: [[28023]], 64070: [[28186]], 64071: [[28450]], 64072: [[29038]], 64073: [[29227]], 64074: [[29730]], 64075: [[30865]], 64076: [[31038]], 64077: [[31049]], 64078: [[31048]], 64079: [[31056]], 64080: [[31062]], 64081: [[31069]], 64082: [[31117]], 64083: [[31118]], 64084: [[31296]], 64085: [[31361]], 64086: [[31680]], 64087: [[32244]], 64088: [[32265]], 64089: [[32321]], 64090: [[32626]], 64091: [[32773]], 64092: [[33261]], 64093: [[33401]], 64094: [[33401]], 64095: [[33879]], 64096: [[35088]], 64097: [[35222]], 64098: [[35585]], 64099: [[35641]], 64100: [[36051]], 64101: [[36104]], 64102: [[36790]], 64103: [[36920]], 64104: [[38627]], 64105: [[38911]], 64106: [[38971]], 64107: [[24693]], 64108: [[148206]], 64109: [[33304]], 64112: [[20006]], 64113: [[20917]], 64114: [[20840]], 64115: [[20352]], 64116: [[20805]], 64117: [[20864]], 64118: [[21191]], 64119: [[21242]], 64120: [[21917]], 64121: [[21845]], 64122: [[21913]], 64123: [[21986]], 64124: [[22618]], 64125: [[22707]], 64126: [[22852]], 64127: [[22868]], 64128: [[23138]], 64129: [[23336]], 64130: [[24274]], 64131: [[24281]], 64132: [[24425]], 64133: [[24493]], 64134: [[24792]], 64135: [[24910]], 64136: [[24840]], 64137: [[24974]], 64138: [[24928]], 64139: [[25074]], 64140: [[25140]], 64141: [[25540]], 64142: [[25628]], 64143: [[25682]], 64144: [[25942]], 64145: [[26228]], 64146: [[26391]], 64147: [[26395]], 64148: [[26454]], 64149: [[27513]], 64150: [[27578]], 64151: [[27969]], 64152: [[28379]], 64153: [[28363]], 64154: [[28450]], 64155: [[28702]], 64156: [[29038]], 64157: [[30631]], 64158: [[29237]], 64159: [[29359]], 64160: [[29482]], 64161: [[29809]], 64162: [[29958]], 64163: [[30011]], 64164: [[30237]], 64165: [[30239]], 64166: [[30410]], 64167: [[30427]], 64168: [[30452]], 64169: [[30538]], 64170: [[30528]], 64171: [[30924]], 64172: [[31409]], 64173: [[31680]], 64174: [[31867]], 64175: [[32091]], 64176: [[32244]], 64177: [[32574]], 64178: [[32773]], 64179: [[33618]], 64180: [[33775]], 64181: [[34681]], 64182: [[35137]], 64183: [[35206]], 64184: [[35222]], 64185: [[35519]], 64186: [[35576]], 64187: [[35531]], 64188: [[35585]], 64189: [[35582]], 64190: [[35565]], 64191: [[35641]], 64192: [[35722]], 64193: [[36104]], 64194: [[36664]], 64195: [[36978]], 64196: [[37273]], 64197: [[37494]], 64198: [[38524]], 64199: [[38627]], 64200: [[38742]], 64201: [[38875]], 64202: [[38911]], 64203: [[38923]], 64204: [[38971]], 64205: [[39698]], 64206: [[40860]], 64207: [[141386]], 64208: [[141380]], 64209: [[144341]], 64210: [[15261]], 64211: [[16408]], 64212: [[16441]], 64213: [[152137]], 64214: [[154832]], 64215: [[163539]], 64216: [[40771]], 64217: [[40846]], 195072: [[38953]], 195073: [[169398]], 195074: [[39138]], 195075: [[19251]], 195076: [[39209]], 195077: [[39335]], 195078: [[39362]], 195079: [[39422]], 195080: [[19406]], 195081: [[170800]], 195082: [[39698]], 195083: [[4e4]], 195084: [[40189]], 195085: [[19662]], 195086: [[19693]], 195087: [[40295]], 195088: [[172238]], 195089: [[19704]], 195090: [[172293]], 195091: [[172558]], 195092: [[172689]], 195093: [[40635]], 195094: [[19798]], 195095: [[40697]], 195096: [[40702]], 195097: [[40709]], 195098: [[40719]], 195099: [[40726]], 195100: [[40763]], 195101: [[173568]] },
  64256: { 64256: [[102, 102], 256], 64257: [[102, 105], 256], 64258: [[102, 108], 256], 64259: [[102, 102, 105], 256], 64260: [[102, 102, 108], 256], 64261: [[383, 116], 256], 64262: [[115, 116], 256], 64275: [[1396, 1398], 256], 64276: [[1396, 1381], 256], 64277: [[1396, 1387], 256], 64278: [[1406, 1398], 256], 64279: [[1396, 1389], 256], 64285: [[1497, 1460], 512], 64286: [null, 26], 64287: [[1522, 1463], 512], 64288: [[1506], 256], 64289: [[1488], 256], 64290: [[1491], 256], 64291: [[1492], 256], 64292: [[1499], 256], 64293: [[1500], 256], 64294: [[1501], 256], 64295: [[1512], 256], 64296: [[1514], 256], 64297: [[43], 256], 64298: [[1513, 1473], 512], 64299: [[1513, 1474], 512], 64300: [[64329, 1473], 512], 64301: [[64329, 1474], 512], 64302: [[1488, 1463], 512], 64303: [[1488, 1464], 512], 64304: [[1488, 1468], 512], 64305: [[1489, 1468], 512], 64306: [[1490, 1468], 512], 64307: [[1491, 1468], 512], 64308: [[1492, 1468], 512], 64309: [[1493, 1468], 512], 64310: [[1494, 1468], 512], 64312: [[1496, 1468], 512], 64313: [[1497, 1468], 512], 64314: [[1498, 1468], 512], 64315: [[1499, 1468], 512], 64316: [[1500, 1468], 512], 64318: [[1502, 1468], 512], 64320: [[1504, 1468], 512], 64321: [[1505, 1468], 512], 64323: [[1507, 1468], 512], 64324: [[1508, 1468], 512], 64326: [[1510, 1468], 512], 64327: [[1511, 1468], 512], 64328: [[1512, 1468], 512], 64329: [[1513, 1468], 512], 64330: [[1514, 1468], 512], 64331: [[1493, 1465], 512], 64332: [[1489, 1471], 512], 64333: [[1499, 1471], 512], 64334: [[1508, 1471], 512], 64335: [[1488, 1500], 256], 64336: [[1649], 256], 64337: [[1649], 256], 64338: [[1659], 256], 64339: [[1659], 256], 64340: [[1659], 256], 64341: [[1659], 256], 64342: [[1662], 256], 64343: [[1662], 256], 64344: [[1662], 256], 64345: [[1662], 256], 64346: [[1664], 256], 64347: [[1664], 256], 64348: [[1664], 256], 64349: [[1664], 256], 64350: [[1658], 256], 64351: [[1658], 256], 64352: [[1658], 256], 64353: [[1658], 256], 64354: [[1663], 256], 64355: [[1663], 256], 64356: [[1663], 256], 64357: [[1663], 256], 64358: [[1657], 256], 64359: [[1657], 256], 64360: [[1657], 256], 64361: [[1657], 256], 64362: [[1700], 256], 64363: [[1700], 256], 64364: [[1700], 256], 64365: [[1700], 256], 64366: [[1702], 256], 64367: [[1702], 256], 64368: [[1702], 256], 64369: [[1702], 256], 64370: [[1668], 256], 64371: [[1668], 256], 64372: [[1668], 256], 64373: [[1668], 256], 64374: [[1667], 256], 64375: [[1667], 256], 64376: [[1667], 256], 64377: [[1667], 256], 64378: [[1670], 256], 64379: [[1670], 256], 64380: [[1670], 256], 64381: [[1670], 256], 64382: [[1671], 256], 64383: [[1671], 256], 64384: [[1671], 256], 64385: [[1671], 256], 64386: [[1677], 256], 64387: [[1677], 256], 64388: [[1676], 256], 64389: [[1676], 256], 64390: [[1678], 256], 64391: [[1678], 256], 64392: [[1672], 256], 64393: [[1672], 256], 64394: [[1688], 256], 64395: [[1688], 256], 64396: [[1681], 256], 64397: [[1681], 256], 64398: [[1705], 256], 64399: [[1705], 256], 64400: [[1705], 256], 64401: [[1705], 256], 64402: [[1711], 256], 64403: [[1711], 256], 64404: [[1711], 256], 64405: [[1711], 256], 64406: [[1715], 256], 64407: [[1715], 256], 64408: [[1715], 256], 64409: [[1715], 256], 64410: [[1713], 256], 64411: [[1713], 256], 64412: [[1713], 256], 64413: [[1713], 256], 64414: [[1722], 256], 64415: [[1722], 256], 64416: [[1723], 256], 64417: [[1723], 256], 64418: [[1723], 256], 64419: [[1723], 256], 64420: [[1728], 256], 64421: [[1728], 256], 64422: [[1729], 256], 64423: [[1729], 256], 64424: [[1729], 256], 64425: [[1729], 256], 64426: [[1726], 256], 64427: [[1726], 256], 64428: [[1726], 256], 64429: [[1726], 256], 64430: [[1746], 256], 64431: [[1746], 256], 64432: [[1747], 256], 64433: [[1747], 256], 64467: [[1709], 256], 64468: [[1709], 256], 64469: [[1709], 256], 64470: [[1709], 256], 64471: [[1735], 256], 64472: [[1735], 256], 64473: [[1734], 256], 64474: [[1734], 256], 64475: [[1736], 256], 64476: [[1736], 256], 64477: [[1655], 256], 64478: [[1739], 256], 64479: [[1739], 256], 64480: [[1733], 256], 64481: [[1733], 256], 64482: [[1737], 256], 64483: [[1737], 256], 64484: [[1744], 256], 64485: [[1744], 256], 64486: [[1744], 256], 64487: [[1744], 256], 64488: [[1609], 256], 64489: [[1609], 256], 64490: [[1574, 1575], 256], 64491: [[1574, 1575], 256], 64492: [[1574, 1749], 256], 64493: [[1574, 1749], 256], 64494: [[1574, 1608], 256], 64495: [[1574, 1608], 256], 64496: [[1574, 1735], 256], 64497: [[1574, 1735], 256], 64498: [[1574, 1734], 256], 64499: [[1574, 1734], 256], 64500: [[1574, 1736], 256], 64501: [[1574, 1736], 256], 64502: [[1574, 1744], 256], 64503: [[1574, 1744], 256], 64504: [[1574, 1744], 256], 64505: [[1574, 1609], 256], 64506: [[1574, 1609], 256], 64507: [[1574, 1609], 256], 64508: [[1740], 256], 64509: [[1740], 256], 64510: [[1740], 256], 64511: [[1740], 256] },
  64512: { 64512: [[1574, 1580], 256], 64513: [[1574, 1581], 256], 64514: [[1574, 1605], 256], 64515: [[1574, 1609], 256], 64516: [[1574, 1610], 256], 64517: [[1576, 1580], 256], 64518: [[1576, 1581], 256], 64519: [[1576, 1582], 256], 64520: [[1576, 1605], 256], 64521: [[1576, 1609], 256], 64522: [[1576, 1610], 256], 64523: [[1578, 1580], 256], 64524: [[1578, 1581], 256], 64525: [[1578, 1582], 256], 64526: [[1578, 1605], 256], 64527: [[1578, 1609], 256], 64528: [[1578, 1610], 256], 64529: [[1579, 1580], 256], 64530: [[1579, 1605], 256], 64531: [[1579, 1609], 256], 64532: [[1579, 1610], 256], 64533: [[1580, 1581], 256], 64534: [[1580, 1605], 256], 64535: [[1581, 1580], 256], 64536: [[1581, 1605], 256], 64537: [[1582, 1580], 256], 64538: [[1582, 1581], 256], 64539: [[1582, 1605], 256], 64540: [[1587, 1580], 256], 64541: [[1587, 1581], 256], 64542: [[1587, 1582], 256], 64543: [[1587, 1605], 256], 64544: [[1589, 1581], 256], 64545: [[1589, 1605], 256], 64546: [[1590, 1580], 256], 64547: [[1590, 1581], 256], 64548: [[1590, 1582], 256], 64549: [[1590, 1605], 256], 64550: [[1591, 1581], 256], 64551: [[1591, 1605], 256], 64552: [[1592, 1605], 256], 64553: [[1593, 1580], 256], 64554: [[1593, 1605], 256], 64555: [[1594, 1580], 256], 64556: [[1594, 1605], 256], 64557: [[1601, 1580], 256], 64558: [[1601, 1581], 256], 64559: [[1601, 1582], 256], 64560: [[1601, 1605], 256], 64561: [[1601, 1609], 256], 64562: [[1601, 1610], 256], 64563: [[1602, 1581], 256], 64564: [[1602, 1605], 256], 64565: [[1602, 1609], 256], 64566: [[1602, 1610], 256], 64567: [[1603, 1575], 256], 64568: [[1603, 1580], 256], 64569: [[1603, 1581], 256], 64570: [[1603, 1582], 256], 64571: [[1603, 1604], 256], 64572: [[1603, 1605], 256], 64573: [[1603, 1609], 256], 64574: [[1603, 1610], 256], 64575: [[1604, 1580], 256], 64576: [[1604, 1581], 256], 64577: [[1604, 1582], 256], 64578: [[1604, 1605], 256], 64579: [[1604, 1609], 256], 64580: [[1604, 1610], 256], 64581: [[1605, 1580], 256], 64582: [[1605, 1581], 256], 64583: [[1605, 1582], 256], 64584: [[1605, 1605], 256], 64585: [[1605, 1609], 256], 64586: [[1605, 1610], 256], 64587: [[1606, 1580], 256], 64588: [[1606, 1581], 256], 64589: [[1606, 1582], 256], 64590: [[1606, 1605], 256], 64591: [[1606, 1609], 256], 64592: [[1606, 1610], 256], 64593: [[1607, 1580], 256], 64594: [[1607, 1605], 256], 64595: [[1607, 1609], 256], 64596: [[1607, 1610], 256], 64597: [[1610, 1580], 256], 64598: [[1610, 1581], 256], 64599: [[1610, 1582], 256], 64600: [[1610, 1605], 256], 64601: [[1610, 1609], 256], 64602: [[1610, 1610], 256], 64603: [[1584, 1648], 256], 64604: [[1585, 1648], 256], 64605: [[1609, 1648], 256], 64606: [[32, 1612, 1617], 256], 64607: [[32, 1613, 1617], 256], 64608: [[32, 1614, 1617], 256], 64609: [[32, 1615, 1617], 256], 64610: [[32, 1616, 1617], 256], 64611: [[32, 1617, 1648], 256], 64612: [[1574, 1585], 256], 64613: [[1574, 1586], 256], 64614: [[1574, 1605], 256], 64615: [[1574, 1606], 256], 64616: [[1574, 1609], 256], 64617: [[1574, 1610], 256], 64618: [[1576, 1585], 256], 64619: [[1576, 1586], 256], 64620: [[1576, 1605], 256], 64621: [[1576, 1606], 256], 64622: [[1576, 1609], 256], 64623: [[1576, 1610], 256], 64624: [[1578, 1585], 256], 64625: [[1578, 1586], 256], 64626: [[1578, 1605], 256], 64627: [[1578, 1606], 256], 64628: [[1578, 1609], 256], 64629: [[1578, 1610], 256], 64630: [[1579, 1585], 256], 64631: [[1579, 1586], 256], 64632: [[1579, 1605], 256], 64633: [[1579, 1606], 256], 64634: [[1579, 1609], 256], 64635: [[1579, 1610], 256], 64636: [[1601, 1609], 256], 64637: [[1601, 1610], 256], 64638: [[1602, 1609], 256], 64639: [[1602, 1610], 256], 64640: [[1603, 1575], 256], 64641: [[1603, 1604], 256], 64642: [[1603, 1605], 256], 64643: [[1603, 1609], 256], 64644: [[1603, 1610], 256], 64645: [[1604, 1605], 256], 64646: [[1604, 1609], 256], 64647: [[1604, 1610], 256], 64648: [[1605, 1575], 256], 64649: [[1605, 1605], 256], 64650: [[1606, 1585], 256], 64651: [[1606, 1586], 256], 64652: [[1606, 1605], 256], 64653: [[1606, 1606], 256], 64654: [[1606, 1609], 256], 64655: [[1606, 1610], 256], 64656: [[1609, 1648], 256], 64657: [[1610, 1585], 256], 64658: [[1610, 1586], 256], 64659: [[1610, 1605], 256], 64660: [[1610, 1606], 256], 64661: [[1610, 1609], 256], 64662: [[1610, 1610], 256], 64663: [[1574, 1580], 256], 64664: [[1574, 1581], 256], 64665: [[1574, 1582], 256], 64666: [[1574, 1605], 256], 64667: [[1574, 1607], 256], 64668: [[1576, 1580], 256], 64669: [[1576, 1581], 256], 64670: [[1576, 1582], 256], 64671: [[1576, 1605], 256], 64672: [[1576, 1607], 256], 64673: [[1578, 1580], 256], 64674: [[1578, 1581], 256], 64675: [[1578, 1582], 256], 64676: [[1578, 1605], 256], 64677: [[1578, 1607], 256], 64678: [[1579, 1605], 256], 64679: [[1580, 1581], 256], 64680: [[1580, 1605], 256], 64681: [[1581, 1580], 256], 64682: [[1581, 1605], 256], 64683: [[1582, 1580], 256], 64684: [[1582, 1605], 256], 64685: [[1587, 1580], 256], 64686: [[1587, 1581], 256], 64687: [[1587, 1582], 256], 64688: [[1587, 1605], 256], 64689: [[1589, 1581], 256], 64690: [[1589, 1582], 256], 64691: [[1589, 1605], 256], 64692: [[1590, 1580], 256], 64693: [[1590, 1581], 256], 64694: [[1590, 1582], 256], 64695: [[1590, 1605], 256], 64696: [[1591, 1581], 256], 64697: [[1592, 1605], 256], 64698: [[1593, 1580], 256], 64699: [[1593, 1605], 256], 64700: [[1594, 1580], 256], 64701: [[1594, 1605], 256], 64702: [[1601, 1580], 256], 64703: [[1601, 1581], 256], 64704: [[1601, 1582], 256], 64705: [[1601, 1605], 256], 64706: [[1602, 1581], 256], 64707: [[1602, 1605], 256], 64708: [[1603, 1580], 256], 64709: [[1603, 1581], 256], 64710: [[1603, 1582], 256], 64711: [[1603, 1604], 256], 64712: [[1603, 1605], 256], 64713: [[1604, 1580], 256], 64714: [[1604, 1581], 256], 64715: [[1604, 1582], 256], 64716: [[1604, 1605], 256], 64717: [[1604, 1607], 256], 64718: [[1605, 1580], 256], 64719: [[1605, 1581], 256], 64720: [[1605, 1582], 256], 64721: [[1605, 1605], 256], 64722: [[1606, 1580], 256], 64723: [[1606, 1581], 256], 64724: [[1606, 1582], 256], 64725: [[1606, 1605], 256], 64726: [[1606, 1607], 256], 64727: [[1607, 1580], 256], 64728: [[1607, 1605], 256], 64729: [[1607, 1648], 256], 64730: [[1610, 1580], 256], 64731: [[1610, 1581], 256], 64732: [[1610, 1582], 256], 64733: [[1610, 1605], 256], 64734: [[1610, 1607], 256], 64735: [[1574, 1605], 256], 64736: [[1574, 1607], 256], 64737: [[1576, 1605], 256], 64738: [[1576, 1607], 256], 64739: [[1578, 1605], 256], 64740: [[1578, 1607], 256], 64741: [[1579, 1605], 256], 64742: [[1579, 1607], 256], 64743: [[1587, 1605], 256], 64744: [[1587, 1607], 256], 64745: [[1588, 1605], 256], 64746: [[1588, 1607], 256], 64747: [[1603, 1604], 256], 64748: [[1603, 1605], 256], 64749: [[1604, 1605], 256], 64750: [[1606, 1605], 256], 64751: [[1606, 1607], 256], 64752: [[1610, 1605], 256], 64753: [[1610, 1607], 256], 64754: [[1600, 1614, 1617], 256], 64755: [[1600, 1615, 1617], 256], 64756: [[1600, 1616, 1617], 256], 64757: [[1591, 1609], 256], 64758: [[1591, 1610], 256], 64759: [[1593, 1609], 256], 64760: [[1593, 1610], 256], 64761: [[1594, 1609], 256], 64762: [[1594, 1610], 256], 64763: [[1587, 1609], 256], 64764: [[1587, 1610], 256], 64765: [[1588, 1609], 256], 64766: [[1588, 1610], 256], 64767: [[1581, 1609], 256] },
  64768: { 64768: [[1581, 1610], 256], 64769: [[1580, 1609], 256], 64770: [[1580, 1610], 256], 64771: [[1582, 1609], 256], 64772: [[1582, 1610], 256], 64773: [[1589, 1609], 256], 64774: [[1589, 1610], 256], 64775: [[1590, 1609], 256], 64776: [[1590, 1610], 256], 64777: [[1588, 1580], 256], 64778: [[1588, 1581], 256], 64779: [[1588, 1582], 256], 64780: [[1588, 1605], 256], 64781: [[1588, 1585], 256], 64782: [[1587, 1585], 256], 64783: [[1589, 1585], 256], 64784: [[1590, 1585], 256], 64785: [[1591, 1609], 256], 64786: [[1591, 1610], 256], 64787: [[1593, 1609], 256], 64788: [[1593, 1610], 256], 64789: [[1594, 1609], 256], 64790: [[1594, 1610], 256], 64791: [[1587, 1609], 256], 64792: [[1587, 1610], 256], 64793: [[1588, 1609], 256], 64794: [[1588, 1610], 256], 64795: [[1581, 1609], 256], 64796: [[1581, 1610], 256], 64797: [[1580, 1609], 256], 64798: [[1580, 1610], 256], 64799: [[1582, 1609], 256], 64800: [[1582, 1610], 256], 64801: [[1589, 1609], 256], 64802: [[1589, 1610], 256], 64803: [[1590, 1609], 256], 64804: [[1590, 1610], 256], 64805: [[1588, 1580], 256], 64806: [[1588, 1581], 256], 64807: [[1588, 1582], 256], 64808: [[1588, 1605], 256], 64809: [[1588, 1585], 256], 64810: [[1587, 1585], 256], 64811: [[1589, 1585], 256], 64812: [[1590, 1585], 256], 64813: [[1588, 1580], 256], 64814: [[1588, 1581], 256], 64815: [[1588, 1582], 256], 64816: [[1588, 1605], 256], 64817: [[1587, 1607], 256], 64818: [[1588, 1607], 256], 64819: [[1591, 1605], 256], 64820: [[1587, 1580], 256], 64821: [[1587, 1581], 256], 64822: [[1587, 1582], 256], 64823: [[1588, 1580], 256], 64824: [[1588, 1581], 256], 64825: [[1588, 1582], 256], 64826: [[1591, 1605], 256], 64827: [[1592, 1605], 256], 64828: [[1575, 1611], 256], 64829: [[1575, 1611], 256], 64848: [[1578, 1580, 1605], 256], 64849: [[1578, 1581, 1580], 256], 64850: [[1578, 1581, 1580], 256], 64851: [[1578, 1581, 1605], 256], 64852: [[1578, 1582, 1605], 256], 64853: [[1578, 1605, 1580], 256], 64854: [[1578, 1605, 1581], 256], 64855: [[1578, 1605, 1582], 256], 64856: [[1580, 1605, 1581], 256], 64857: [[1580, 1605, 1581], 256], 64858: [[1581, 1605, 1610], 256], 64859: [[1581, 1605, 1609], 256], 64860: [[1587, 1581, 1580], 256], 64861: [[1587, 1580, 1581], 256], 64862: [[1587, 1580, 1609], 256], 64863: [[1587, 1605, 1581], 256], 64864: [[1587, 1605, 1581], 256], 64865: [[1587, 1605, 1580], 256], 64866: [[1587, 1605, 1605], 256], 64867: [[1587, 1605, 1605], 256], 64868: [[1589, 1581, 1581], 256], 64869: [[1589, 1581, 1581], 256], 64870: [[1589, 1605, 1605], 256], 64871: [[1588, 1581, 1605], 256], 64872: [[1588, 1581, 1605], 256], 64873: [[1588, 1580, 1610], 256], 64874: [[1588, 1605, 1582], 256], 64875: [[1588, 1605, 1582], 256], 64876: [[1588, 1605, 1605], 256], 64877: [[1588, 1605, 1605], 256], 64878: [[1590, 1581, 1609], 256], 64879: [[1590, 1582, 1605], 256], 64880: [[1590, 1582, 1605], 256], 64881: [[1591, 1605, 1581], 256], 64882: [[1591, 1605, 1581], 256], 64883: [[1591, 1605, 1605], 256], 64884: [[1591, 1605, 1610], 256], 64885: [[1593, 1580, 1605], 256], 64886: [[1593, 1605, 1605], 256], 64887: [[1593, 1605, 1605], 256], 64888: [[1593, 1605, 1609], 256], 64889: [[1594, 1605, 1605], 256], 64890: [[1594, 1605, 1610], 256], 64891: [[1594, 1605, 1609], 256], 64892: [[1601, 1582, 1605], 256], 64893: [[1601, 1582, 1605], 256], 64894: [[1602, 1605, 1581], 256], 64895: [[1602, 1605, 1605], 256], 64896: [[1604, 1581, 1605], 256], 64897: [[1604, 1581, 1610], 256], 64898: [[1604, 1581, 1609], 256], 64899: [[1604, 1580, 1580], 256], 64900: [[1604, 1580, 1580], 256], 64901: [[1604, 1582, 1605], 256], 64902: [[1604, 1582, 1605], 256], 64903: [[1604, 1605, 1581], 256], 64904: [[1604, 1605, 1581], 256], 64905: [[1605, 1581, 1580], 256], 64906: [[1605, 1581, 1605], 256], 64907: [[1605, 1581, 1610], 256], 64908: [[1605, 1580, 1581], 256], 64909: [[1605, 1580, 1605], 256], 64910: [[1605, 1582, 1580], 256], 64911: [[1605, 1582, 1605], 256], 64914: [[1605, 1580, 1582], 256], 64915: [[1607, 1605, 1580], 256], 64916: [[1607, 1605, 1605], 256], 64917: [[1606, 1581, 1605], 256], 64918: [[1606, 1581, 1609], 256], 64919: [[1606, 1580, 1605], 256], 64920: [[1606, 1580, 1605], 256], 64921: [[1606, 1580, 1609], 256], 64922: [[1606, 1605, 1610], 256], 64923: [[1606, 1605, 1609], 256], 64924: [[1610, 1605, 1605], 256], 64925: [[1610, 1605, 1605], 256], 64926: [[1576, 1582, 1610], 256], 64927: [[1578, 1580, 1610], 256], 64928: [[1578, 1580, 1609], 256], 64929: [[1578, 1582, 1610], 256], 64930: [[1578, 1582, 1609], 256], 64931: [[1578, 1605, 1610], 256], 64932: [[1578, 1605, 1609], 256], 64933: [[1580, 1605, 1610], 256], 64934: [[1580, 1581, 1609], 256], 64935: [[1580, 1605, 1609], 256], 64936: [[1587, 1582, 1609], 256], 64937: [[1589, 1581, 1610], 256], 64938: [[1588, 1581, 1610], 256], 64939: [[1590, 1581, 1610], 256], 64940: [[1604, 1580, 1610], 256], 64941: [[1604, 1605, 1610], 256], 64942: [[1610, 1581, 1610], 256], 64943: [[1610, 1580, 1610], 256], 64944: [[1610, 1605, 1610], 256], 64945: [[1605, 1605, 1610], 256], 64946: [[1602, 1605, 1610], 256], 64947: [[1606, 1581, 1610], 256], 64948: [[1602, 1605, 1581], 256], 64949: [[1604, 1581, 1605], 256], 64950: [[1593, 1605, 1610], 256], 64951: [[1603, 1605, 1610], 256], 64952: [[1606, 1580, 1581], 256], 64953: [[1605, 1582, 1610], 256], 64954: [[1604, 1580, 1605], 256], 64955: [[1603, 1605, 1605], 256], 64956: [[1604, 1580, 1605], 256], 64957: [[1606, 1580, 1581], 256], 64958: [[1580, 1581, 1610], 256], 64959: [[1581, 1580, 1610], 256], 64960: [[1605, 1580, 1610], 256], 64961: [[1601, 1605, 1610], 256], 64962: [[1576, 1581, 1610], 256], 64963: [[1603, 1605, 1605], 256], 64964: [[1593, 1580, 1605], 256], 64965: [[1589, 1605, 1605], 256], 64966: [[1587, 1582, 1610], 256], 64967: [[1606, 1580, 1610], 256], 65008: [[1589, 1604, 1746], 256], 65009: [[1602, 1604, 1746], 256], 65010: [[1575, 1604, 1604, 1607], 256], 65011: [[1575, 1603, 1576, 1585], 256], 65012: [[1605, 1581, 1605, 1583], 256], 65013: [[1589, 1604, 1593, 1605], 256], 65014: [[1585, 1587, 1608, 1604], 256], 65015: [[1593, 1604, 1610, 1607], 256], 65016: [[1608, 1587, 1604, 1605], 256], 65017: [[1589, 1604, 1609], 256], 65018: [[1589, 1604, 1609, 32, 1575, 1604, 1604, 1607, 32, 1593, 1604, 1610, 1607, 32, 1608, 1587, 1604, 1605], 256], 65019: [[1580, 1604, 32, 1580, 1604, 1575, 1604, 1607], 256], 65020: [[1585, 1740, 1575, 1604], 256] },
  65024: { 65040: [[44], 256], 65041: [[12289], 256], 65042: [[12290], 256], 65043: [[58], 256], 65044: [[59], 256], 65045: [[33], 256], 65046: [[63], 256], 65047: [[12310], 256], 65048: [[12311], 256], 65049: [[8230], 256], 65056: [null, 230], 65057: [null, 230], 65058: [null, 230], 65059: [null, 230], 65060: [null, 230], 65061: [null, 230], 65062: [null, 230], 65063: [null, 220], 65064: [null, 220], 65065: [null, 220], 65066: [null, 220], 65067: [null, 220], 65068: [null, 220], 65069: [null, 220], 65072: [[8229], 256], 65073: [[8212], 256], 65074: [[8211], 256], 65075: [[95], 256], 65076: [[95], 256], 65077: [[40], 256], 65078: [[41], 256], 65079: [[123], 256], 65080: [[125], 256], 65081: [[12308], 256], 65082: [[12309], 256], 65083: [[12304], 256], 65084: [[12305], 256], 65085: [[12298], 256], 65086: [[12299], 256], 65087: [[12296], 256], 65088: [[12297], 256], 65089: [[12300], 256], 65090: [[12301], 256], 65091: [[12302], 256], 65092: [[12303], 256], 65095: [[91], 256], 65096: [[93], 256], 65097: [[8254], 256], 65098: [[8254], 256], 65099: [[8254], 256], 65100: [[8254], 256], 65101: [[95], 256], 65102: [[95], 256], 65103: [[95], 256], 65104: [[44], 256], 65105: [[12289], 256], 65106: [[46], 256], 65108: [[59], 256], 65109: [[58], 256], 65110: [[63], 256], 65111: [[33], 256], 65112: [[8212], 256], 65113: [[40], 256], 65114: [[41], 256], 65115: [[123], 256], 65116: [[125], 256], 65117: [[12308], 256], 65118: [[12309], 256], 65119: [[35], 256], 65120: [[38], 256], 65121: [[42], 256], 65122: [[43], 256], 65123: [[45], 256], 65124: [[60], 256], 65125: [[62], 256], 65126: [[61], 256], 65128: [[92], 256], 65129: [[36], 256], 65130: [[37], 256], 65131: [[64], 256], 65136: [[32, 1611], 256], 65137: [[1600, 1611], 256], 65138: [[32, 1612], 256], 65140: [[32, 1613], 256], 65142: [[32, 1614], 256], 65143: [[1600, 1614], 256], 65144: [[32, 1615], 256], 65145: [[1600, 1615], 256], 65146: [[32, 1616], 256], 65147: [[1600, 1616], 256], 65148: [[32, 1617], 256], 65149: [[1600, 1617], 256], 65150: [[32, 1618], 256], 65151: [[1600, 1618], 256], 65152: [[1569], 256], 65153: [[1570], 256], 65154: [[1570], 256], 65155: [[1571], 256], 65156: [[1571], 256], 65157: [[1572], 256], 65158: [[1572], 256], 65159: [[1573], 256], 65160: [[1573], 256], 65161: [[1574], 256], 65162: [[1574], 256], 65163: [[1574], 256], 65164: [[1574], 256], 65165: [[1575], 256], 65166: [[1575], 256], 65167: [[1576], 256], 65168: [[1576], 256], 65169: [[1576], 256], 65170: [[1576], 256], 65171: [[1577], 256], 65172: [[1577], 256], 65173: [[1578], 256], 65174: [[1578], 256], 65175: [[1578], 256], 65176: [[1578], 256], 65177: [[1579], 256], 65178: [[1579], 256], 65179: [[1579], 256], 65180: [[1579], 256], 65181: [[1580], 256], 65182: [[1580], 256], 65183: [[1580], 256], 65184: [[1580], 256], 65185: [[1581], 256], 65186: [[1581], 256], 65187: [[1581], 256], 65188: [[1581], 256], 65189: [[1582], 256], 65190: [[1582], 256], 65191: [[1582], 256], 65192: [[1582], 256], 65193: [[1583], 256], 65194: [[1583], 256], 65195: [[1584], 256], 65196: [[1584], 256], 65197: [[1585], 256], 65198: [[1585], 256], 65199: [[1586], 256], 65200: [[1586], 256], 65201: [[1587], 256], 65202: [[1587], 256], 65203: [[1587], 256], 65204: [[1587], 256], 65205: [[1588], 256], 65206: [[1588], 256], 65207: [[1588], 256], 65208: [[1588], 256], 65209: [[1589], 256], 65210: [[1589], 256], 65211: [[1589], 256], 65212: [[1589], 256], 65213: [[1590], 256], 65214: [[1590], 256], 65215: [[1590], 256], 65216: [[1590], 256], 65217: [[1591], 256], 65218: [[1591], 256], 65219: [[1591], 256], 65220: [[1591], 256], 65221: [[1592], 256], 65222: [[1592], 256], 65223: [[1592], 256], 65224: [[1592], 256], 65225: [[1593], 256], 65226: [[1593], 256], 65227: [[1593], 256], 65228: [[1593], 256], 65229: [[1594], 256], 65230: [[1594], 256], 65231: [[1594], 256], 65232: [[1594], 256], 65233: [[1601], 256], 65234: [[1601], 256], 65235: [[1601], 256], 65236: [[1601], 256], 65237: [[1602], 256], 65238: [[1602], 256], 65239: [[1602], 256], 65240: [[1602], 256], 65241: [[1603], 256], 65242: [[1603], 256], 65243: [[1603], 256], 65244: [[1603], 256], 65245: [[1604], 256], 65246: [[1604], 256], 65247: [[1604], 256], 65248: [[1604], 256], 65249: [[1605], 256], 65250: [[1605], 256], 65251: [[1605], 256], 65252: [[1605], 256], 65253: [[1606], 256], 65254: [[1606], 256], 65255: [[1606], 256], 65256: [[1606], 256], 65257: [[1607], 256], 65258: [[1607], 256], 65259: [[1607], 256], 65260: [[1607], 256], 65261: [[1608], 256], 65262: [[1608], 256], 65263: [[1609], 256], 65264: [[1609], 256], 65265: [[1610], 256], 65266: [[1610], 256], 65267: [[1610], 256], 65268: [[1610], 256], 65269: [[1604, 1570], 256], 65270: [[1604, 1570], 256], 65271: [[1604, 1571], 256], 65272: [[1604, 1571], 256], 65273: [[1604, 1573], 256], 65274: [[1604, 1573], 256], 65275: [[1604, 1575], 256], 65276: [[1604, 1575], 256] },
  65280: { 65281: [[33], 256], 65282: [[34], 256], 65283: [[35], 256], 65284: [[36], 256], 65285: [[37], 256], 65286: [[38], 256], 65287: [[39], 256], 65288: [[40], 256], 65289: [[41], 256], 65290: [[42], 256], 65291: [[43], 256], 65292: [[44], 256], 65293: [[45], 256], 65294: [[46], 256], 65295: [[47], 256], 65296: [[48], 256], 65297: [[49], 256], 65298: [[50], 256], 65299: [[51], 256], 65300: [[52], 256], 65301: [[53], 256], 65302: [[54], 256], 65303: [[55], 256], 65304: [[56], 256], 65305: [[57], 256], 65306: [[58], 256], 65307: [[59], 256], 65308: [[60], 256], 65309: [[61], 256], 65310: [[62], 256], 65311: [[63], 256], 65312: [[64], 256], 65313: [[65], 256], 65314: [[66], 256], 65315: [[67], 256], 65316: [[68], 256], 65317: [[69], 256], 65318: [[70], 256], 65319: [[71], 256], 65320: [[72], 256], 65321: [[73], 256], 65322: [[74], 256], 65323: [[75], 256], 65324: [[76], 256], 65325: [[77], 256], 65326: [[78], 256], 65327: [[79], 256], 65328: [[80], 256], 65329: [[81], 256], 65330: [[82], 256], 65331: [[83], 256], 65332: [[84], 256], 65333: [[85], 256], 65334: [[86], 256], 65335: [[87], 256], 65336: [[88], 256], 65337: [[89], 256], 65338: [[90], 256], 65339: [[91], 256], 65340: [[92], 256], 65341: [[93], 256], 65342: [[94], 256], 65343: [[95], 256], 65344: [[96], 256], 65345: [[97], 256], 65346: [[98], 256], 65347: [[99], 256], 65348: [[100], 256], 65349: [[101], 256], 65350: [[102], 256], 65351: [[103], 256], 65352: [[104], 256], 65353: [[105], 256], 65354: [[106], 256], 65355: [[107], 256], 65356: [[108], 256], 65357: [[109], 256], 65358: [[110], 256], 65359: [[111], 256], 65360: [[112], 256], 65361: [[113], 256], 65362: [[114], 256], 65363: [[115], 256], 65364: [[116], 256], 65365: [[117], 256], 65366: [[118], 256], 65367: [[119], 256], 65368: [[120], 256], 65369: [[121], 256], 65370: [[122], 256], 65371: [[123], 256], 65372: [[124], 256], 65373: [[125], 256], 65374: [[126], 256], 65375: [[10629], 256], 65376: [[10630], 256], 65377: [[12290], 256], 65378: [[12300], 256], 65379: [[12301], 256], 65380: [[12289], 256], 65381: [[12539], 256], 65382: [[12530], 256], 65383: [[12449], 256], 65384: [[12451], 256], 65385: [[12453], 256], 65386: [[12455], 256], 65387: [[12457], 256], 65388: [[12515], 256], 65389: [[12517], 256], 65390: [[12519], 256], 65391: [[12483], 256], 65392: [[12540], 256], 65393: [[12450], 256], 65394: [[12452], 256], 65395: [[12454], 256], 65396: [[12456], 256], 65397: [[12458], 256], 65398: [[12459], 256], 65399: [[12461], 256], 65400: [[12463], 256], 65401: [[12465], 256], 65402: [[12467], 256], 65403: [[12469], 256], 65404: [[12471], 256], 65405: [[12473], 256], 65406: [[12475], 256], 65407: [[12477], 256], 65408: [[12479], 256], 65409: [[12481], 256], 65410: [[12484], 256], 65411: [[12486], 256], 65412: [[12488], 256], 65413: [[12490], 256], 65414: [[12491], 256], 65415: [[12492], 256], 65416: [[12493], 256], 65417: [[12494], 256], 65418: [[12495], 256], 65419: [[12498], 256], 65420: [[12501], 256], 65421: [[12504], 256], 65422: [[12507], 256], 65423: [[12510], 256], 65424: [[12511], 256], 65425: [[12512], 256], 65426: [[12513], 256], 65427: [[12514], 256], 65428: [[12516], 256], 65429: [[12518], 256], 65430: [[12520], 256], 65431: [[12521], 256], 65432: [[12522], 256], 65433: [[12523], 256], 65434: [[12524], 256], 65435: [[12525], 256], 65436: [[12527], 256], 65437: [[12531], 256], 65438: [[12441], 256], 65439: [[12442], 256], 65440: [[12644], 256], 65441: [[12593], 256], 65442: [[12594], 256], 65443: [[12595], 256], 65444: [[12596], 256], 65445: [[12597], 256], 65446: [[12598], 256], 65447: [[12599], 256], 65448: [[12600], 256], 65449: [[12601], 256], 65450: [[12602], 256], 65451: [[12603], 256], 65452: [[12604], 256], 65453: [[12605], 256], 65454: [[12606], 256], 65455: [[12607], 256], 65456: [[12608], 256], 65457: [[12609], 256], 65458: [[12610], 256], 65459: [[12611], 256], 65460: [[12612], 256], 65461: [[12613], 256], 65462: [[12614], 256], 65463: [[12615], 256], 65464: [[12616], 256], 65465: [[12617], 256], 65466: [[12618], 256], 65467: [[12619], 256], 65468: [[12620], 256], 65469: [[12621], 256], 65470: [[12622], 256], 65474: [[12623], 256], 65475: [[12624], 256], 65476: [[12625], 256], 65477: [[12626], 256], 65478: [[12627], 256], 65479: [[12628], 256], 65482: [[12629], 256], 65483: [[12630], 256], 65484: [[12631], 256], 65485: [[12632], 256], 65486: [[12633], 256], 65487: [[12634], 256], 65490: [[12635], 256], 65491: [[12636], 256], 65492: [[12637], 256], 65493: [[12638], 256], 65494: [[12639], 256], 65495: [[12640], 256], 65498: [[12641], 256], 65499: [[12642], 256], 65500: [[12643], 256], 65504: [[162], 256], 65505: [[163], 256], 65506: [[172], 256], 65507: [[175], 256], 65508: [[166], 256], 65509: [[165], 256], 65510: [[8361], 256], 65512: [[9474], 256], 65513: [[8592], 256], 65514: [[8593], 256], 65515: [[8594], 256], 65516: [[8595], 256], 65517: [[9632], 256], 65518: [[9675], 256] }
};
/*!
 * Unorm
 * https://github.com/walling/unorm
 *
 * The software dual licensed under the MIT and GPL licenses. MIT license:
 *
 * Copyright (c) 2008-2013
 * Matsuza <matsuza@gmail.com>,
 * Bjarke Walling <bwp@bwp.dk>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *
 * GPL notice (please read the [full GPL license] online):
 *
 * Copyright (C) 2008-2013
 * Matsuza <matsuza@gmail.com>,
 * Bjarke Walling <bwp@bwp.dk>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 * [full GPL license]: http://www.gnu.org/licenses/gpl-2.0-standalone.html
*/
var y4;
function lx() {
  if (y4) return Xi;
  y4 = 1;
  const e = hx, c = [null, 0, {}], d = 10, w = 44032, g = 4352, f = 4449, n = 4519, u = 19, a = 21, s = 28, i = a * s, p = u * i, m = {}, E = [];
  for (let ae = 0; ae <= 255; ae++)
    E[ae] = 0;
  let v = null;
  class b {
    constructor(D, Q) {
      this.codepoint = D, this.feature = Q;
    }
    static isHighSurrogate(D) {
      return D >= 55296 && D <= 56319;
    }
    static isLowSurrogate(D) {
      return D >= 56320 && D <= 57343;
    }
    prepFeature() {
      this.feature || (this.feature = v(this.codepoint, !0).feature);
    }
    toString() {
      if (this.codepoint < 65536)
        return String.fromCharCode(this.codepoint);
      const D = this.codepoint - 65536;
      return String.fromCharCode(
        Math.floor(D / 1024) + 55296,
        D % 1024 + 56320
      );
    }
    getDecomp() {
      return this.prepFeature(), this.feature[0] || null;
    }
    isCompatibility() {
      return this.prepFeature(), !!this.feature[1] && (this.feature[1] & 256) !== 0;
    }
    isExclude() {
      return this.prepFeature(), !!this.feature[1] && (this.feature[1] & 512) !== 0;
    }
    getCanonicalClass() {
      return this.prepFeature(), this.feature[1] ? this.feature[1] & 255 : 0;
    }
    getComposite(D) {
      if (this.prepFeature(), !this.feature[2])
        return null;
      const Q = this.feature[2][D.codepoint];
      return Q ? v(Q) : null;
    }
  }
  function h(ae, D, Q) {
    let Z = m[D];
    return Z || (Z = ae(D, Q), Z.feature && ++E[D >> 8 & 255] > d && (m[D] = Z)), Z;
  }
  function o(ae, D, Q) {
    const Z = D & 65280, y = (e[Z] || {})[D];
    return y ? new b(D, y) : new b(D, c);
  }
  function S(ae, D, Q) {
    return Q ? ae(D, Q) : new b(D, null);
  }
  function H(ae, D, Q) {
    if (D < g || g + u <= D && D < w || w + p < D)
      return ae(D, Q);
    if (g <= D && D < g + u) {
      const Y = {}, he = (D - g) * a;
      for (let be = 0; be < a; be++)
        Y[f + be] = w + s * (be + he);
      return new b(D, [null, null, Y]);
    }
    const Z = D - w, oe = Z % s, y = [];
    if (oe !== 0)
      y[0] = [w + Z - oe, n + oe];
    else {
      y[0] = [
        g + Math.floor(Z / i),
        f + Math.floor(Z % i / s)
      ], y[2] = {};
      for (let Y = 1; Y < s; Y++)
        y[2][n + Y] = D + Y;
    }
    return new b(D, y);
  }
  function j(ae, D, Q) {
    return D < 60 || 13311 < D && D < 42607 ? new b(D, c) : ae(D, Q);
  }
  v = [
    j,
    h,
    S,
    H,
    o
  ].reduceRight((ae, D) => (Q, Z) => D(ae, Q, Z), null);
  class N {
    constructor(D) {
      this.str = D, this.cursor = 0;
    }
    next() {
      if (this.str && this.cursor < this.str.length) {
        let D = this.str.charCodeAt(this.cursor++);
        if (b.isHighSurrogate(D) && this.cursor < this.str.length) {
          const Q = this.str.charCodeAt(this.cursor);
          b.isLowSurrogate(Q) && (D = (D - 55296) * 1024 + (Q - 56320) + 65536, this.cursor += 1);
        }
        return v(D);
      }
      return this.str = null, null;
    }
  }
  class z {
    constructor(D, Q) {
      this.it = D, this.canonical = Q, this.resBuf = [];
    }
    recursiveDecomp(D) {
      const Q = this.canonical, Z = D.getDecomp();
      if (Z && !(Q && D.isCompatibility())) {
        let oe = [];
        for (let y = 0; y < Z.length; y++) {
          const Y = this.recursiveDecomp(v(Z[y]));
          oe = oe.concat(Y);
        }
        return oe;
      }
      return [D];
    }
    next() {
      if (this.resBuf.length === 0) {
        const D = this.it.next();
        if (!D)
          return null;
        this.resBuf = this.recursiveDecomp(D);
      }
      return this.resBuf.shift();
    }
  }
  class A {
    constructor(D) {
      this.it = D, this.resBuf = [];
    }
    next() {
      if (this.resBuf.length === 0)
        for (; ; ) {
          const D = this.it.next();
          if (!D)
            break;
          const Q = D.getCanonicalClass();
          let Z = this.resBuf.length;
          if (Q !== 0)
            for (; Z > 0 && !(this.resBuf[Z - 1].getCanonicalClass() <= Q); )
              Z -= 1;
          if (this.resBuf.splice(Z, 0, D), Q === 0)
            break;
        }
      return this.resBuf.shift();
    }
  }
  class q {
    constructor(D) {
      this.it = D, this.procBuf = [], this.resBuf = [], this.lastClass = null;
    }
    next() {
      for (; this.resBuf.length === 0; ) {
        const D = this.it.next();
        if (!D) {
          this.resBuf = this.procBuf, this.procBuf = [];
          break;
        }
        if (this.procBuf.length === 0) {
          this.lastClass = D.getCanonicalClass(), this.procBuf.push(D);
          continue;
        }
        const Z = this.procBuf[0].getComposite(D), oe = D.getCanonicalClass();
        if (Z && (this.lastClass < oe || this.lastClass === 0)) {
          this.procBuf[0] = Z;
          continue;
        }
        oe === 0 && (this.resBuf = this.procBuf, this.procBuf = []), this.lastClass = oe, this.procBuf.push(D);
      }
      return this.resBuf.shift();
    }
  }
  function _(ae, D) {
    switch (ae) {
      case "NFD": {
        const Q = new N(D), Z = new z(Q, !0);
        return new A(Z);
      }
      case "NFKD": {
        const Q = new N(D), Z = new z(Q, !1);
        return new A(Z);
      }
      case "NFC": {
        const Q = new N(D), Z = new z(Q, !0), oe = new A(Z);
        return new q(oe);
      }
      case "NFKC": {
        const Q = new N(D), Z = new z(Q, !1), oe = new A(Z);
        return new q(oe);
      }
    }
    throw new Error(`${ae} is invalid.`);
  }
  function F(ae, D) {
    const Q = _(ae, D);
    let Z = "", oe;
    for (; oe = Q.next(), !!oe; )
      Z += oe.toString();
    return Z;
  }
  function R(ae) {
    return F("NFD", ae);
  }
  function V(ae) {
    return F("NFKD", ae);
  }
  function fe(ae) {
    return F("NFC", ae);
  }
  function ue(ae) {
    return F("NFKC", ae);
  }
  return Xi.nfc = fe, Xi.nfd = R, Xi.nfkc = ue, Xi.nfkd = V, Xi;
}
/*!
 * nfkd-compat.js - unicode normalization for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var du, v4;
function dx() {
  if (v4) return du;
  v4 = 1;
  const e = lx();
  function c(d) {
    return d.normalize ? d.normalize("NFKD") : e.nfkd(d);
  }
  return du = c, du;
}
var bu, S4;
function wo() {
  if (S4) return bu;
  S4 = 1;
  const e = $e(), c = At(), d = wr(), w = mn(), g = pi(), f = xo(), n = gn(), u = t7(), a = go(), s = dx(), { inspectSymbol: i } = Kt(), p = /* @__PURE__ */ Object.create(null);
  class m {
    /**
     * Create a mnemonic.
     * @constructor
     * @param {Object} options
     * @param {Number?} options.bit - Bits of entropy (Must
     * be a multiple of 8) (default=128).
     * @param {Buffer?} options.entropy - Entropy bytes. Will
     * be generated with `options.bits` bits of entropy
     * if not present.
     * @param {String?} options.phrase - Mnemonic phrase (will
     * be generated if not present).
     * @param {String?} options.language - Language.
     */
    constructor(b) {
      this.bits = a.MIN_ENTROPY, this.language = "english", this.entropy = null, this.phrase = null, b && this.fromOptions(b);
    }
    /**
     * Inject properties from options object.
     * @private
     * @param {Object} options
     */
    fromOptions(b) {
      return typeof b == "string" && (b = { phrase: b }), b.bits != null && (e((b.bits & 65535) === b.bits), e(b.bits >= a.MIN_ENTROPY), e(b.bits <= a.MAX_ENTROPY), e(b.bits % 32 === 0), this.bits = b.bits), b.language && (e(typeof b.language == "string"), e(m.languages.indexOf(b.language) !== -1), this.language = b.language), b.phrase ? (this.fromPhrase(b.phrase), this) : b.entropy ? (this.fromEntropy(b.entropy), this) : this;
    }
    /**
     * Instantiate mnemonic from options.
     * @param {Object} options
     * @returns {Mnemonic}
     */
    static fromOptions(b) {
      return new this().fromOptions(b);
    }
    /**
     * Destroy the mnemonic (zeroes entropy).
     */
    destroy() {
      this.bits = a.MIN_ENTROPY, this.language = "english", this.entropy && (w(this.entropy), this.entropy = null), this.phrase = null;
    }
    /**
     * Generate the seed.
     * @param {String?} passphrase
     * @returns {Buffer} pbkdf2 seed.
     */
    toSeed(b) {
      b || (b = "");
      const h = s(this.getPhrase()), o = s(`mnemonic${b}`);
      return f.derive(
        n,
        k.from(h, "utf8"),
        k.from(o, "utf8"),
        2048,
        64
      );
    }
    /**
     * Get or generate entropy.
     * @returns {Buffer}
     */
    getEntropy() {
      return this.entropy || (this.entropy = g.randomBytes(this.bits / 8)), e(this.bits / 8 === this.entropy.length), this.entropy;
    }
    /**
     * Generate a mnemonic phrase from chosen language.
     * @returns {String}
     */
    getPhrase() {
      if (this.phrase)
        return this.phrase;
      const b = this.bits + this.bits / 32, h = this.getEntropy(), o = d.digest(h), S = Math.ceil(b / 8), H = k.allocUnsafe(S);
      h.copy(H, 0), o.copy(H, h.length);
      const j = m.getWordlist(this.language);
      let J = [];
      for (let N = 0; N < b / 11; N++) {
        let z = 0;
        for (let A = 0; A < 11; A++) {
          const q = N * 11 + A, _ = q % 8, F = (q - _) / 8;
          z <<= 1, z |= H[F] >>> 7 - _ & 1;
        }
        J.push(j.words[z]);
      }
      return this.language === "japanese" ? J = J.join("") : J = J.join(" "), this.phrase = J, J;
    }
    /**
     * Inject properties from phrase.
     * @private
     * @param {String} phrase
     */
    fromPhrase(b) {
      e(typeof b == "string"), e(b.length <= 1e3);
      const h = b.trim().split(/[\s\u3000]+/), o = h.length * 11, S = o % 32;
      e(S !== 0, "Invalid checksum.");
      const H = o - S;
      e(H >= a.MIN_ENTROPY), e(H <= a.MAX_ENTROPY), e(H % 32 === 0);
      const j = Math.ceil(o / 8), J = k.allocUnsafe(j);
      J.fill(0);
      const N = m.getLanguage(h[0]), z = m.getWordlist(N);
      for (let R = 0; R < h.length; R++) {
        const V = h[R], fe = z.map[V];
        if (fe == null)
          throw new Error("Could not find word.");
        for (let ue = 0; ue < 11; ue++) {
          const ae = R * 11 + ue, D = ae % 8, Q = (ae - D) / 8, Z = fe >>> 10 - ue & 1;
          J[Q] |= Z << 7 - D;
        }
      }
      const A = Math.ceil(S / 8), q = J.slice(0, J.length - A), _ = J.slice(J.length - A), F = d.digest(q);
      for (let R = 0; R < S; R++) {
        const V = R % 8, fe = (R - V) / 8, ue = _[fe] >>> 7 - V & 1, ae = F[fe] >>> 7 - V & 1;
        if (ue !== ae)
          throw new Error("Invalid checksum.");
      }
      return e(H / 8 === q.length), this.bits = H, this.language = N, this.entropy = q, this.phrase = b, this;
    }
    /**
     * Instantiate mnemonic from a phrase (validates checksum).
     * @param {String} phrase
     * @returns {Mnemonic}
     * @throws on bad checksum
     */
    static fromPhrase(b) {
      return new this().fromPhrase(b);
    }
    /**
     * Inject properties from entropy.
     * @private
     * @param {Buffer} entropy
     * @param {String?} lang
     */
    fromEntropy(b, h) {
      return e(k.isBuffer(b)), e(b.length * 8 >= a.MIN_ENTROPY), e(b.length * 8 <= a.MAX_ENTROPY), e(b.length * 8 % 32 === 0), e(!h || m.languages.indexOf(h) !== -1), this.entropy = b, this.bits = b.length * 8, h && (this.language = h), this;
    }
    /**
     * Instantiate mnemonic from entropy.
     * @param {Buffer} entropy
     * @param {String?} lang
     * @returns {Mnemonic}
     */
    static fromEntropy(b, h) {
      return new this().fromEntropy(b, h);
    }
    /**
     * Determine a single word's language.
     * @param {String} word
     * @returns {String} Language.
     * @throws on not found.
     */
    static getLanguage(b) {
      for (const h of m.languages)
        if (m.getWordlist(h).map[b] != null)
          return h;
      throw new Error("Could not determine language.");
    }
    /**
     * Retrieve the wordlist for a language.
     * @param {String} lang
     * @returns {Object}
     */
    static getWordlist(b) {
      const h = p[b];
      if (h)
        return h;
      const o = u.get(b), S = new E(o);
      return p[b] = S, S;
    }
    /**
     * Convert mnemonic to a json-friendly object.
     * @returns {Object}
     */
    toJSON() {
      return {
        bits: this.bits,
        language: this.language,
        entropy: this.getEntropy().toString("hex"),
        phrase: this.getPhrase()
      };
    }
    /**
     * Inject properties from json object.
     * @private
     * @param {Object} json
     */
    fromJSON(b) {
      return e(b), e((b.bits & 65535) === b.bits), e(typeof b.language == "string"), e(typeof b.entropy == "string"), e(typeof b.phrase == "string"), e(b.bits >= a.MIN_ENTROPY), e(b.bits <= a.MAX_ENTROPY), e(b.bits % 32 === 0), e(b.bits / 8 === b.entropy.length / 2), this.bits = b.bits, this.language = b.language, this.entropy = k.from(b.entropy, "hex"), this.phrase = b.phrase, this;
    }
    /**
     * Instantiate mnemonic from json object.
     * @param {Object} json
     * @returns {Mnemonic}
     */
    static fromJSON(b) {
      return new this().fromJSON(b);
    }
    /**
     * Calculate serialization size.
     * @returns {Number}
     */
    getSize() {
      let b = 0;
      return b += 3, b += this.getEntropy().length, b;
    }
    /**
     * Write the mnemonic to a buffer writer.
     * @params {BufferWriter} bw
     */
    toWriter(b) {
      const h = m.languages.indexOf(this.language);
      return e(h !== -1), b.writeU16(this.bits), b.writeU8(h), b.writeBytes(this.getEntropy()), b;
    }
    /**
     * Serialize mnemonic.
     * @returns {Buffer}
     */
    toRaw(b) {
      const h = this.getSize();
      return this.toWriter(c.write(h)).render();
    }
    /**
     * Inject properties from buffer reader.
     * @private
     * @param {BufferReader} br
     */
    fromReader(b) {
      const h = b.readU16();
      e(h >= a.MIN_ENTROPY), e(h <= a.MAX_ENTROPY), e(h % 32 === 0);
      const o = m.languages[b.readU8()];
      return e(o), this.bits = h, this.language = o, this.entropy = b.readBytes(h / 8), this;
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     */
    fromRaw(b) {
      return this.fromReader(c.read(b));
    }
    /**
     * Instantiate mnemonic from buffer reader.
     * @param {BufferReader} br
     * @returns {Mnemonic}
     */
    static fromReader(b) {
      return new this().fromReader(b);
    }
    /**
     * Instantiate mnemonic from serialized data.
     * @param {Buffer} data
     * @returns {Mnemonic}
     */
    static fromRaw(b) {
      return new this().fromRaw(b);
    }
    /**
     * Convert the mnemonic to a string.
     * @returns {String}
     */
    toString() {
      return this.getPhrase();
    }
    /**
     * Inspect the mnemonic.
     * @returns {String}
     */
    [i]() {
      return `<Mnemonic: ${this.getPhrase()}>`;
    }
    /**
     * Test whether an object is a Mnemonic.
     * @param {Object} obj
     * @returns {Boolean}
     */
    static isMnemonic(b) {
      return b instanceof m;
    }
  }
  m.languages = [
    "simplified chinese",
    "traditional chinese",
    "english",
    "french",
    "italian",
    "japanese",
    "spanish"
  ];
  class E {
    /**
     * Create word list.
     * @constructor
     * @ignore
     * @param {Array} words
     */
    constructor(b) {
      this.words = b, this.map = /* @__PURE__ */ Object.create(null);
      for (let h = 0; h < b.length; h++) {
        const o = b[h];
        this.map[o] = h;
      }
    }
  }
  return bu = m, bu;
}
var pu, E4;
function gl() {
  if (E4) return pu;
  E4 = 1;
  const e = $e(), c = At(), { base58: d } = cn(), w = gn(), g = Hi(), f = hr(), n = mn(), u = Rr(), a = yr(), s = Ht(), i = go();
  class p {
    /**
     * Create an HD public key.
     * @constructor
     * @param {Object|Base58String} options
     * @param {Base58String?} options.xkey - Serialized base58 key.
     * @param {Number?} options.depth
     * @param {Number?} options.parentFingerPrint
     * @param {Number?} options.childIndex
     * @param {Buffer?} options.chainCode
     * @param {Buffer?} options.publicKey
     */
    constructor(E) {
      this.depth = 0, this.parentFingerPrint = 0, this.childIndex = 0, this.chainCode = s.ZERO_HASH, this.publicKey = i.ZERO_KEY, this.fingerPrint = -1, E && this.fromOptions(E);
    }
    /**
     * Inject properties from options object.
     * @private
     * @param {Object} options
     */
    fromOptions(E) {
      return e(E, "No options for HDPublicKey"), e((E.depth & 255) === E.depth), e(E.parentFingerPrint >>> 0 === E.parentFingerPrint), e(E.childIndex >>> 0 === E.childIndex), e(k.isBuffer(E.chainCode)), e(k.isBuffer(E.publicKey)), this.depth = E.depth, this.parentFingerPrint = E.parentFingerPrint, this.childIndex = E.childIndex, this.chainCode = E.chainCode, this.publicKey = E.publicKey, this;
    }
    /**
     * Instantiate HD public key from options object.
     * @param {Object} options
     * @returns {HDPublicKey}
     */
    static fromOptions(E) {
      return new this().fromOptions(E);
    }
    /**
     * Get HD public key (self).
     * @returns {HDPublicKey}
     */
    toPublic() {
      return this;
    }
    /**
     * Get cached base58 xprivkey (always null here).
     * @returns {null}
     */
    xprivkey(E) {
      return null;
    }
    /**
     * Get cached base58 xpubkey.
     * @returns {Base58String}
     */
    xpubkey(E) {
      return this.toBase58(E);
    }
    /**
     * Destroy the key (zeroes chain code and pubkey).
     */
    destroy() {
      this.depth = 0, this.childIndex = 0, this.parentFingerPrint = 0, n(this.chainCode), n(this.publicKey), this.fingerPrint = -1;
    }
    /**
     * Derive a child key.
     * @param {Number} index - Derivation index.
     * @param {Boolean?} hardened - Whether the derivation
     * should be hardened (throws if true).
     * @returns {HDPrivateKey}
     * @throws on `hardened`
     */
    derive(E, v) {
      if (e(typeof E == "number"), E >>> 0 !== E)
        throw new Error("Index out of range.");
      if (E & i.HARDENED || v)
        throw new Error("Cannot derive hardened.");
      if (this.depth >= 255)
        throw new Error("Depth too high.");
      const b = this.getID(E), h = i.cache.get(b);
      if (h)
        return h;
      const o = c.pool(37);
      o.writeBytes(this.publicKey), o.writeU32BE(E);
      const S = o.render(), H = w.mac(S, this.chainCode), j = H.slice(0, 32), J = H.slice(32, 64);
      let N;
      try {
        N = u.publicKeyTweakAdd(this.publicKey, j, !0);
      } catch {
        return this.derive(E + 1);
      }
      if (this.fingerPrint === -1) {
        const A = g.digest(this.publicKey);
        this.fingerPrint = A.readUInt32BE(0, !0);
      }
      const z = new this.constructor();
      return z.depth = this.depth + 1, z.parentFingerPrint = this.fingerPrint, z.childIndex = E, z.chainCode = J, z.publicKey = N, i.cache.set(b, z), z;
    }
    /**
     * Unique HD key ID.
     * @private
     * @param {Number} index
     * @returns {String}
     */
    getID(E) {
      return "b" + this.publicKey.toString("hex") + E;
    }
    /**
     * Derive a BIP44 account key (does not derive, only ensures account key).
     * @method
     * @param {Number} purpose
     * @param {Number} type
     * @param {Number} account
     * @returns {HDPublicKey}
     * @throws Error if key is not already an account key.
     */
    deriveAccount(E, v, b) {
      return e(E >>> 0 === E), e(v >>> 0 === v), e(b >>> 0 === b), e(this.isAccount(b), "Cannot derive account index."), this;
    }
    /**
     * Test whether the key is a master key.
     * @method
     * @returns {Boolean}
     */
    isMaster() {
      return i.isMaster(this);
    }
    /**
     * Test whether the key is (most likely) a BIP44 account key.
     * @method
     * @param {Number?} account
     * @returns {Boolean}
     */
    isAccount(E) {
      return i.isAccount(this, E);
    }
    /**
     * Test whether a string is a valid path.
     * @param {String} path
     * @param {Boolean?} hardened
     * @returns {Boolean}
     */
    static isValidPath(E) {
      try {
        return i.parsePath(E, !1), !0;
      } catch {
        return !1;
      }
    }
    /**
     * Derive a key from a derivation path.
     * @param {String} path
     * @returns {HDPublicKey}
     * @throws Error if `path` is not a valid path.
     * @throws Error if hardened.
     */
    derivePath(E) {
      const v = i.parsePath(E, !1);
      let b = this;
      for (const h of v)
        b = b.derive(h);
      return b;
    }
    /**
     * Compare a key against an object.
     * @param {Object} obj
     * @returns {Boolean}
     */
    equals(E) {
      return e(p.isHDPublicKey(E)), this.depth === E.depth && this.parentFingerPrint === E.parentFingerPrint && this.childIndex === E.childIndex && this.chainCode.equals(E.chainCode) && this.publicKey.equals(E.publicKey);
    }
    /**
     * Compare a key against an object.
     * @param {Object} obj
     * @returns {Boolean}
     */
    compare(E) {
      e(p.isHDPublicKey(E));
      let v = this.depth - E.depth;
      return v !== 0 || (v = this.parentFingerPrint - E.parentFingerPrint, v !== 0) || (v = this.childIndex - E.childIndex, v !== 0) || (v = this.chainCode.compare(E.chainCode), v !== 0) || (v = this.publicKey.compare(E.publicKey), v !== 0) ? v : 0;
    }
    /**
     * Convert key to a more json-friendly object.
     * @returns {Object}
     */
    toJSON(E) {
      return {
        xpubkey: this.xpubkey(E)
      };
    }
    /**
     * Inject properties from json object.
     * @private
     * @param {Object} json
     * @param {Network?} network
     */
    fromJSON(E, v) {
      return e(E.xpubkey, "Could not handle HD key JSON."), this.fromBase58(E.xpubkey, v), this;
    }
    /**
     * Instantiate an HDPublicKey from a jsonified key object.
     * @param {Object} json - The jsonified transaction object.
     * @param {Network?} network
     * @returns {HDPrivateKey}
     */
    static fromJSON(E, v) {
      return new this().fromJSON(E, v);
    }
    /**
     * Test whether an object is in the form of a base58 xpubkey.
     * @param {String} data
     * @param {(Network|NetworkType)?} network
     * @returns {Boolean}
     */
    static isBase58(E, v) {
      if (typeof E != "string" || E.length < 4)
        return !1;
      const b = E.substring(0, 4);
      try {
        return a.fromPublic58(b, v), !0;
      } catch {
        return !1;
      }
    }
    /**
     * Test whether a buffer has a valid network prefix.
     * @param {Buffer} data
     * @param {(Network|NetworkType)?} network
     * @returns {NetworkType}
     */
    static isRaw(E, v) {
      if (!k.isBuffer(E) || E.length < 4)
        return !1;
      const b = E.readUInt32BE(0, !0);
      try {
        return a.fromPublic(b, v), !0;
      } catch {
        return !1;
      }
    }
    /**
     * Inject properties from a base58 key.
     * @private
     * @param {Base58String} xkey
     * @param {Network?} network
     */
    fromBase58(E, v) {
      return e(typeof E == "string"), this.fromRaw(d.decode(E), v);
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {BufferReader} br
     * @param {(Network|NetworkType)?} network
     */
    fromReader(E, v) {
      const b = E.readU32BE();
      return a.fromPublic(b, v), this.depth = E.readU8(), this.parentFingerPrint = E.readU32BE(), this.childIndex = E.readU32BE(), this.chainCode = E.readBytes(32), this.publicKey = E.readBytes(33), E.verifyChecksum(f.digest), this;
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     * @param {(Network|NetworkType)?} network
     */
    fromRaw(E, v) {
      return this.fromReader(c.read(E), v);
    }
    /**
     * Serialize key data to base58 extended key.
     * @param {(Network|NetworkType)?} network
     * @returns {Base58String}
     */
    toBase58(E) {
      return d.encode(this.toRaw(E));
    }
    /**
     * Write the key to a buffer writer.
     * @param {BufferWriter} bw
     * @param {(Network|NetworkType)?} network
     */
    toWriter(E, v) {
      return v = a.get(v), E.writeU32BE(v.keyPrefix.xpubkey), E.writeU8(this.depth), E.writeU32BE(this.parentFingerPrint), E.writeU32BE(this.childIndex), E.writeBytes(this.chainCode), E.writeBytes(this.publicKey), E.writeChecksum(f.digest), E;
    }
    /**
     * Calculate serialization size.
     * @returns {Number}
     */
    getSize() {
      return 82;
    }
    /**
     * Serialize the key.
     * @param {(Network|NetworkType)?} network
     * @returns {Buffer}
     */
    toRaw(E) {
      return this.toWriter(c.write(82), E).render();
    }
    /**
     * Instantiate an HD public key from a base58 string.
     * @param {Base58String} xkey
     * @param {Network?} network
     * @returns {HDPublicKey}
     */
    static fromBase58(E, v) {
      return new this().fromBase58(E, v);
    }
    /**
     * Instantiate key from serialized data.
     * @param {BufferReader} br
     * @param {(Network|NetworkType)?} network
     * @returns {HDPublicKey}
     */
    static fromReader(E, v) {
      return new this().fromReader(E, v);
    }
    /**
     * Instantiate key from serialized data.
     * @param {Buffer} data
     * @param {(Network|NetworkType)?} network
     * @returns {HDPublicKey}
     */
    static fromRaw(E, v) {
      return new this().fromRaw(E, v);
    }
    /**
     * Test whether an object is a HDPublicKey.
     * @param {Object} obj
     * @returns {Boolean}
     */
    static isHDPublicKey(E) {
      return E instanceof p;
    }
  }
  return pu = p, pu;
}
var mu, I4;
function xl() {
  if (I4) return mu;
  I4 = 1;
  const e = $e(), c = At(), { base58: d } = cn(), w = gn(), g = Hi(), f = hr(), n = mn(), u = pi(), a = Rr(), s = yr(), i = Ht(), p = go(), m = wo(), E = gl(), v = k.from("Bitcoin seed", "ascii");
  class b {
    /**
     * Create an hd private key.
     * @constructor
     * @param {Object|String} options
     * @param {Number?} options.depth
     * @param {Number?} options.parentFingerPrint
     * @param {Number?} options.childIndex
     * @param {Buffer?} options.chainCode
     * @param {Buffer?} options.privateKey
     */
    constructor(o) {
      this.depth = 0, this.parentFingerPrint = 0, this.childIndex = 0, this.chainCode = i.ZERO_HASH, this.privateKey = i.ZERO_HASH, this.publicKey = p.ZERO_KEY, this.fingerPrint = -1, this._hdPublicKey = null, o && this.fromOptions(o);
    }
    /**
     * Inject properties from options object.
     * @private
     * @param {Object} options
     */
    fromOptions(o) {
      return e(o, "No options for HD private key."), e((o.depth & 255) === o.depth), e(o.parentFingerPrint >>> 0 === o.parentFingerPrint), e(o.childIndex >>> 0 === o.childIndex), e(k.isBuffer(o.chainCode)), e(k.isBuffer(o.privateKey)), this.depth = o.depth, this.parentFingerPrint = o.parentFingerPrint, this.childIndex = o.childIndex, this.chainCode = o.chainCode, this.privateKey = o.privateKey, this.publicKey = a.publicKeyCreate(o.privateKey, !0), this;
    }
    /**
     * Instantiate HD private key from options object.
     * @param {Object} options
     * @returns {HDPrivateKey}
     */
    static fromOptions(o) {
      return new this().fromOptions(o);
    }
    /**
     * Get HD public key.
     * @returns {HDPublicKey}
     */
    toPublic() {
      let o = this._hdPublicKey;
      return o || (o = new E(), o.depth = this.depth, o.parentFingerPrint = this.parentFingerPrint, o.childIndex = this.childIndex, o.chainCode = this.chainCode, o.publicKey = this.publicKey, this._hdPublicKey = o), o;
    }
    /**
     * Get cached base58 xprivkey.
     * @returns {Base58String}
     */
    xprivkey(o) {
      return this.toBase58(o);
    }
    /**
     * Get cached base58 xpubkey.
     * @returns {Base58String}
     */
    xpubkey(o) {
      return this.toPublic().xpubkey(o);
    }
    /**
     * Destroy the key (zeroes chain code, privkey, and pubkey).
     * @param {Boolean} pub - Destroy hd public key as well.
     */
    destroy(o) {
      this.depth = 0, this.childIndex = 0, this.parentFingerPrint = 0, n(this.chainCode), n(this.privateKey), n(this.publicKey), this.fingerPrint = -1, this._hdPublicKey && (o && this._hdPublicKey.destroy(), this._hdPublicKey = null);
    }
    /**
     * Derive a child key.
     * @param {Number} index - Derivation index.
     * @param {Boolean?} hardened - Whether the derivation should be hardened.
     * @returns {HDPrivateKey}
     */
    derive(o, S) {
      if (e(typeof o == "number"), o >>> 0 !== o)
        throw new Error("Index out of range.");
      if (this.depth >= 255)
        throw new Error("Depth too high.");
      S && (o |= p.HARDENED, o >>>= 0);
      const H = this.getID(o), j = p.cache.get(H);
      if (j)
        return j;
      const J = c.pool(37);
      o & p.HARDENED ? (J.writeU8(0), J.writeBytes(this.privateKey), J.writeU32BE(o)) : (J.writeBytes(this.publicKey), J.writeU32BE(o));
      const N = J.render(), z = w.mac(N, this.chainCode), A = z.slice(0, 32), q = z.slice(32, 64);
      let _;
      try {
        _ = a.privateKeyTweakAdd(this.privateKey, A);
      } catch {
        return this.derive(o + 1);
      }
      if (this.fingerPrint === -1) {
        const R = g.digest(this.publicKey);
        this.fingerPrint = R.readUInt32BE(0, !0);
      }
      const F = new this.constructor();
      return F.depth = this.depth + 1, F.parentFingerPrint = this.fingerPrint, F.childIndex = o, F.chainCode = q, F.privateKey = _, F.publicKey = a.publicKeyCreate(_, !0), p.cache.set(H, F), F;
    }
    /**
     * Unique HD key ID.
     * @private
     * @param {Number} index
     * @returns {String}
     */
    getID(o) {
      return "v" + this.publicKey.toString("hex") + o;
    }
    /**
     * Derive a BIP44 account key.
     * @param {Number} purpose
     * @param {Number} type
     * @param {Number} account
     * @returns {HDPrivateKey}
     * @throws Error if key is not a master key.
     */
    deriveAccount(o, S, H) {
      return e(o >>> 0 === o, "Purpose must be a number."), e(S >>> 0 === S, "Account index must be a number."), e(H >>> 0 === H, "Account index must be a number."), e(this.isMaster(), "Cannot derive account index."), this.derive(o, !0).derive(S, !0).derive(H, !0);
    }
    /**
     * Test whether the key is a master key.
     * @returns {Boolean}
     */
    isMaster() {
      return p.isMaster(this);
    }
    /**
     * Test whether the key is (most likely) a BIP44 account key.
     * @param {Number?} account
     * @returns {Boolean}
     */
    isAccount(o) {
      return p.isAccount(this, o);
    }
    /**
     * Test whether an object is in the form of a base58 xprivkey.
     * @param {String} data
     * @param {Network?} network
     * @returns {Boolean}
     */
    static isBase58(o, S) {
      if (typeof o != "string" || o.length < 4)
        return !1;
      const H = o.substring(0, 4);
      try {
        return s.fromPrivate58(H, S), !0;
      } catch {
        return !1;
      }
    }
    /**
     * Test whether a buffer has a valid network prefix.
     * @param {Buffer} data
     * @param {Network?} network
     * @returns {Boolean}
     */
    static isRaw(o, S) {
      if (!k.isBuffer(o) || o.length < 4)
        return !1;
      const H = o.readUInt32BE(0, !0);
      try {
        return s.fromPrivate(H, S), !0;
      } catch {
        return !1;
      }
    }
    /**
     * Test whether a string is a valid path.
     * @param {String} path
     * @returns {Boolean}
     */
    static isValidPath(o) {
      try {
        return p.parsePath(o, !0), !0;
      } catch {
        return !1;
      }
    }
    /**
     * Derive a key from a derivation path.
     * @param {String} path
     * @returns {HDPrivateKey}
     * @throws Error if `path` is not a valid path.
     */
    derivePath(o) {
      const S = p.parsePath(o, !0);
      let H = this;
      for (const j of S)
        H = H.derive(j);
      return H;
    }
    /**
     * Compare a key against an object.
     * @param {Object} obj
     * @returns {Boolean}
     */
    equals(o) {
      return e(b.isHDPrivateKey(o)), this.depth === o.depth && this.parentFingerPrint === o.parentFingerPrint && this.childIndex === o.childIndex && this.chainCode.equals(o.chainCode) && this.privateKey.equals(o.privateKey);
    }
    /**
     * Compare a key against an object.
     * @param {Object} obj
     * @returns {Boolean}
     */
    compare(o) {
      e(b.isHDPrivateKey(o));
      let S = this.depth - o.depth;
      return S !== 0 || (S = this.parentFingerPrint - o.parentFingerPrint, S !== 0) || (S = this.childIndex - o.childIndex, S !== 0) || (S = this.chainCode.compare(o.chainCode), S !== 0) || (S = this.privateKey.compare(o.privateKey), S !== 0) ? S : 0;
    }
    /**
     * Inject properties from seed.
     * @private
     * @param {Buffer} seed
     */
    fromSeed(o) {
      if (e(k.isBuffer(o)), o.length * 8 < p.MIN_ENTROPY || o.length * 8 > p.MAX_ENTROPY)
        throw new Error("Entropy not in range.");
      const S = w.mac(o, v), H = S.slice(0, 32), j = S.slice(32, 64);
      if (!a.privateKeyVerify(H))
        throw new Error("Master private key is invalid.");
      return this.depth = 0, this.parentFingerPrint = 0, this.childIndex = 0, this.chainCode = j, this.privateKey = H, this.publicKey = a.publicKeyCreate(H, !0), this;
    }
    /**
     * Instantiate an hd private key from a 512 bit seed.
     * @param {Buffer} seed
     * @returns {HDPrivateKey}
     */
    static fromSeed(o) {
      return new this().fromSeed(o);
    }
    /**
     * Inject properties from a mnemonic.
     * @private
     * @param {Mnemonic} mnemonic
     * @param {String?} passphrase
     */
    fromMnemonic(o, S) {
      return e(o instanceof m), this.fromSeed(o.toSeed(S));
    }
    /**
     * Instantiate an hd private key from a mnemonic.
     * @param {Mnemonic} mnemonic
     * @param {String?} passphrase
     * @returns {HDPrivateKey}
     */
    static fromMnemonic(o, S) {
      return new this().fromMnemonic(o, S);
    }
    /**
     * Inject properties from a mnemonic.
     * @private
     * @param {String} mnemonic
     */
    fromPhrase(o) {
      const S = m.fromPhrase(o);
      return this.fromMnemonic(S), this;
    }
    /**
     * Instantiate an hd private key from a phrase.
     * @param {String} phrase
     * @returns {HDPrivateKey}
     */
    static fromPhrase(o) {
      return new this().fromPhrase(o);
    }
    /**
     * Inject properties from privateKey and entropy.
     * @private
     * @param {Buffer} key
     * @param {Buffer} entropy
     */
    fromKey(o, S) {
      return e(k.isBuffer(o) && o.length === 32), e(k.isBuffer(S) && S.length === 32), this.depth = 0, this.parentFingerPrint = 0, this.childIndex = 0, this.chainCode = S, this.privateKey = o, this.publicKey = a.publicKeyCreate(o, !0), this;
    }
    /**
     * Create an hd private key from a key and entropy bytes.
     * @param {Buffer} key
     * @param {Buffer} entropy
     * @returns {HDPrivateKey}
     */
    static fromKey(o, S) {
      return new this().fromKey(o, S);
    }
    /**
     * Generate an hd private key.
     * @returns {HDPrivateKey}
     */
    static generate() {
      const o = a.privateKeyGenerate(), S = u.randomBytes(32);
      return b.fromKey(o, S);
    }
    /**
     * Inject properties from base58 key.
     * @private
     * @param {Base58String} xkey
     * @param {Network?} network
     */
    fromBase58(o, S) {
      return e(typeof o == "string"), this.fromRaw(d.decode(o), S);
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {BufferReader} br
     * @param {(Network|NetworkType)?} network
     */
    fromReader(o, S) {
      const H = o.readU32BE();
      return s.fromPrivate(H, S), this.depth = o.readU8(), this.parentFingerPrint = o.readU32BE(), this.childIndex = o.readU32BE(), this.chainCode = o.readBytes(32), e(o.readU8() === 0), this.privateKey = o.readBytes(32), this.publicKey = a.publicKeyCreate(this.privateKey, !0), o.verifyChecksum(f.digest), this;
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     * @param {(Network|NetworkType)?} network
     */
    fromRaw(o, S) {
      return this.fromReader(c.read(o), S);
    }
    /**
     * Serialize key to a base58 string.
     * @param {(Network|NetworkType)?} network
     * @returns {Base58String}
     */
    toBase58(o) {
      return d.encode(this.toRaw(o));
    }
    /**
     * Calculate serialization size.
     * @returns {Number}
     */
    getSize() {
      return 82;
    }
    /**
     * Write the key to a buffer writer.
     * @param {BufferWriter} bw
     * @param {(Network|NetworkType)?} network
     */
    toWriter(o, S) {
      return S = s.get(S), o.writeU32BE(S.keyPrefix.xprivkey), o.writeU8(this.depth), o.writeU32BE(this.parentFingerPrint), o.writeU32BE(this.childIndex), o.writeBytes(this.chainCode), o.writeU8(0), o.writeBytes(this.privateKey), o.writeChecksum(f.digest), o;
    }
    /**
     * Serialize the key.
     * @param {(Network|NetworkType)?} network
     * @returns {Buffer}
     */
    toRaw(o) {
      return this.toWriter(c.write(82), o).render();
    }
    /**
     * Instantiate an HD private key from a base58 string.
     * @param {Base58String} xkey
     * @param {Network?} network
     * @returns {HDPrivateKey}
     */
    static fromBase58(o, S) {
      return new this().fromBase58(o, S);
    }
    /**
     * Instantiate key from buffer reader.
     * @param {BufferReader} br
     * @param {(Network|NetworkType)?} network
     * @returns {HDPrivateKey}
     */
    static fromReader(o, S) {
      return new this().fromReader(o, S);
    }
    /**
     * Instantiate key from serialized data.
     * @param {Buffer} data
     * @param {(Network|NetworkType)?} network
     * @returns {HDPrivateKey}
     */
    static fromRaw(o, S) {
      return new this().fromRaw(o, S);
    }
    /**
     * Convert key to a more json-friendly object.
     * @returns {Object}
     */
    toJSON(o) {
      return {
        xprivkey: this.xprivkey(o)
      };
    }
    /**
     * Inject properties from json object.
     * @private
     * @param {Object} json
     * @param {Network?} network
     */
    fromJSON(o, S) {
      return e(o.xprivkey, "Could not handle key JSON."), this.fromBase58(o.xprivkey, S), this;
    }
    /**
     * Instantiate an HDPrivateKey from a jsonified key object.
     * @param {Object} json - The jsonified key object.
     * @param {Network?} network
     * @returns {HDPrivateKey}
     */
    static fromJSON(o, S) {
      return new this().fromJSON(o, S);
    }
    /**
     * Test whether an object is an HDPrivateKey.
     * @param {Object} obj
     * @returns {Boolean}
     */
    static isHDPrivateKey(o) {
      return o instanceof b;
    }
  }
  return mu = b, mu;
}
/*!
 * hd.js - hd keys for bcoin
 * Copyright (c) 2015-2016, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var A4;
function wl() {
  return A4 || (A4 = 1, function(e) {
    const c = $e(), d = go(), w = wo(), g = xl(), f = gl(), n = t7(), u = e;
    u.fromBase58 = function(s, i) {
      return g.isBase58(s) ? g.fromBase58(s, i) : f.fromBase58(s, i);
    }, u.generate = function() {
      return g.generate();
    }, u.fromSeed = function(s) {
      return g.fromSeed(s);
    }, u.fromMnemonic = function(s) {
      return g.fromMnemonic(s);
    }, u.fromJSON = function(s, i) {
      return s.xprivkey ? g.fromJSON(s, i) : f.fromJSON(s, i);
    }, u.fromRaw = function(s, i) {
      return g.isRaw(s, i) ? g.fromRaw(s, i) : f.fromRaw(s, i);
    }, u.from = function(s, i) {
      if (c(s, "Options required."), u.isHD(s))
        return s;
      if (u.isBase58(s, i))
        return u.fromBase58(s, i);
      if (u.isRaw(s, i))
        return u.fromRaw(s, i);
      if (s && typeof s == "object")
        return u.fromMnemonic(s);
      throw new Error("Cannot create HD key from bad options.");
    }, u.isBase58 = function(s, i) {
      return g.isBase58(s, i) || f.isBase58(s, i);
    }, u.isRaw = function(s, i) {
      return g.isRaw(s, i) || f.isRaw(s, i);
    }, u.isHD = function(s) {
      return g.isHDPrivateKey(s) || f.isHDPublicKey(s);
    }, u.isPrivate = function(s) {
      return g.isHDPrivateKey(s);
    }, u.isPublic = function(s) {
      return f.isHDPublicKey(s);
    }, u.common = d, u.HD = u, u.Mnemonic = w, u.PrivateKey = g, u.PublicKey = f, u.HDPrivateKey = g, u.HDPublicKey = f, u.wordlist = n;
  }(tu)), tu;
}
/*!
 * hd/index.js - hd keys for bcoin
 * Copyright (c) 2014-2016, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var gu, O4;
function bx() {
  return O4 || (O4 = 1, gu = wl()), gu;
}
var Yt = {}, xu, _4;
function yo() {
  if (_4) return xu;
  _4 = 1;
  const e = At(), c = Zt();
  class d {
    /**
     * Create an inv item.
     * @constructor
     * @param {Number} type
     * @param {Hash} hash
     */
    constructor(g, f) {
      this.type = g, this.hash = f;
    }
    /**
     * Write inv item to buffer writer.
     * @param {BufferWriter} bw
     */
    getSize() {
      return 36;
    }
    /**
     * Write inv item to buffer writer.
     * @param {BufferWriter} bw
     */
    toWriter(g) {
      return g.writeU32(this.type), g.writeHash(this.hash), g;
    }
    /**
     * Serialize inv item.
     * @returns {Buffer}
     */
    toRaw() {
      return this.toWriter(e.write(36)).render();
    }
    /**
     * Inject properties from buffer reader.
     * @private
     * @param {BufferReader} br
     */
    fromReader(g) {
      return this.type = g.readU32(), this.hash = g.readHash(), this;
    }
    /**
     * Inject properties from serialized data.
     * @param {Buffer} data
     */
    fromRaw(g) {
      return this.fromReader(e.read(g));
    }
    /**
     * Instantiate inv item from buffer reader.
     * @param {BufferReader} br
     * @returns {InvItem}
     */
    static fromReader(g) {
      return new this().fromReader(g);
    }
    /**
     * Instantiate inv item from serialized data.
     * @param {Buffer} data
     * @param {String?} enc
     * @returns {InvItem}
     */
    static fromRaw(g, f) {
      return typeof g == "string" && (g = k.from(g, f)), new this().fromRaw(g);
    }
    /**
     * Test whether the inv item is a block.
     * @returns {Boolean}
     */
    isBlock() {
      switch (this.type) {
        case d.types.BLOCK:
        case d.types.FILTERED_BLOCK:
        case d.types.CMPCT_BLOCK:
          return !0;
        default:
          return !1;
      }
    }
    /**
     * Test whether the inv item is a tx.
     * @returns {Boolean}
     */
    isTX() {
      switch (this.type) {
        case d.types.TX:
          return !0;
        default:
          return !1;
      }
    }
    /**
     * Get little-endian hash.
     * @returns {Hash}
     */
    rhash() {
      return c.revHex(this.hash);
    }
  }
  return d.types = {
    TX: 1,
    BLOCK: 2,
    FILTERED_BLOCK: 3,
    CMPCT_BLOCK: 4
  }, d.typesByVal = {
    1: "TX",
    2: "BLOCK",
    3: "FILTERED_BLOCK",
    4: "CMPCT_BLOCK"
  }, xu = d, xu;
}
var wu, R4;
function is() {
  if (R4) return wu;
  R4 = 1;
  const e = $e(), c = hr(), d = At(), w = Zt(), g = yo(), f = Ht();
  class n {
    /**
     * Create an abstract block.
     * @constructor
     */
    constructor() {
      this.version = 1, this.prevBlock = f.ZERO_HASH, this.merkleRoot = f.ZERO_HASH, this.time = 0, this.bits = 0, this.nonce = 0, this.mutable = !1, this._hash = null, this._hhash = null;
    }
    /**
     * Inject properties from options object.
     * @private
     * @param {Object} options
     */
    parseOptions(a) {
      return e(a, "Block data is required."), e(a.version >>> 0 === a.version), e(k.isBuffer(a.prevBlock)), e(k.isBuffer(a.merkleRoot)), e(a.time >>> 0 === a.time), e(a.bits >>> 0 === a.bits), e(a.nonce >>> 0 === a.nonce), this.version = a.version, this.prevBlock = a.prevBlock, this.merkleRoot = a.merkleRoot, this.time = a.time, this.bits = a.bits, this.nonce = a.nonce, a.mutable != null && (e(typeof a.mutable == "boolean"), this.mutable = a.mutable), this;
    }
    /**
     * Inject properties from json object.
     * @private
     * @param {Object} json
     */
    parseJSON(a) {
      return e(a, "Block data is required."), e(a.version >>> 0 === a.version), e(typeof a.prevBlock == "string"), e(typeof a.merkleRoot == "string"), e(a.time >>> 0 === a.time), e(a.bits >>> 0 === a.bits), e(a.nonce >>> 0 === a.nonce), this.version = a.version, this.prevBlock = w.fromRev(a.prevBlock), this.merkleRoot = w.fromRev(a.merkleRoot), this.time = a.time, this.bits = a.bits, this.nonce = a.nonce, this;
    }
    /**
     * Test whether the block is a memblock.
     * @returns {Boolean}
     */
    isMemory() {
      return !1;
    }
    /**
     * Clear any cached values (abstract).
     */
    _refresh() {
      this._hash = null, this._hhash = null;
    }
    /**
     * Clear any cached values.
     */
    refresh() {
      return this._refresh();
    }
    /**
     * Hash the block headers.
     * @param {String?} enc - Can be `'hex'` or `null`.
     * @returns {Hash|Buffer} hash
     */
    hash(a) {
      let s = this._hash;
      if (s || (s = c.digest(this.toHead()), this.mutable || (this._hash = s)), a === "hex") {
        let i = this._hhash;
        i || (i = s.toString("hex"), this.mutable || (this._hhash = i)), s = i;
      }
      return s;
    }
    /**
     * Serialize the block headers.
     * @returns {Buffer}
     */
    toHead() {
      return this.writeHead(d.write(80)).render();
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     */
    fromHead(a) {
      return this.readHead(d.read(a));
    }
    /**
     * Serialize the block headers.
     * @param {BufferWriter} bw
     */
    writeHead(a) {
      return a.writeU32(this.version), a.writeHash(this.prevBlock), a.writeHash(this.merkleRoot), a.writeU32(this.time), a.writeU32(this.bits), a.writeU32(this.nonce), a;
    }
    /**
     * Parse the block headers.
     * @param {BufferReader} br
     */
    readHead(a) {
      return this.version = a.readU32(), this.prevBlock = a.readHash(), this.merkleRoot = a.readHash(), this.time = a.readU32(), this.bits = a.readU32(), this.nonce = a.readU32(), this;
    }
    /**
     * Verify the block.
     * @returns {Boolean}
     */
    verify() {
      return !(!this.verifyPOW() || !this.verifyBody());
    }
    /**
     * Verify proof-of-work.
     * @returns {Boolean}
     */
    verifyPOW() {
      return f.verifyPOW(this.hash(), this.bits);
    }
    /**
     * Verify the block.
     * @returns {Boolean}
     */
    verifyBody() {
      throw new Error("Abstract method.");
    }
    /**
     * Get little-endian block hash.
     * @returns {Hash}
     */
    rhash() {
      return w.revHex(this.hash());
    }
    /**
     * Convert the block to an inv item.
     * @returns {InvItem}
     */
    toInv() {
      return new g(g.types.BLOCK, this.hash());
    }
  }
  return wu = n, wu;
}
var Ji = {}, P4;
function r7() {
  if (P4) return Ji;
  P4 = 1;
  const e = Mt();
  function c(f, n) {
    e(f && typeof f.root == "function"), e(Array.isArray(n));
    const u = new Array(n.length);
    for (let p = 0; p < n.length; p++)
      u[p] = n[p];
    let a = u.length, s = !1, i = 0;
    if (a === 0)
      return u.push(f.zero), [u, s];
    for (; a > 1; ) {
      for (let p = 0; p < a; p += 2) {
        const m = Math.min(p + 1, a - 1), E = u[i + p], v = u[i + m];
        m === p + 1 && m + 1 === a && E.equals(v) && (s = !0);
        const b = f.root(E, v);
        u.push(b);
      }
      i += a, a = a + 1 >>> 1;
    }
    return [u, s];
  }
  function d(f, n) {
    e(f && typeof f.root == "function"), e(Array.isArray(n));
    const [u, a] = c(f, n);
    return [u[u.length - 1], a];
  }
  function w(f, n, u) {
    e(f && typeof f.root == "function"), e(n >>> 0 === n), e(Array.isArray(u)), e(n < u.length);
    let a = u.length;
    const [s] = c(f, u), i = [];
    let p = 0;
    for (; a > 1; ) {
      const m = Math.min(n ^ 1, a - 1);
      i.push(s[p + m]), n >>>= 1, p += a, a = a + 1 >>> 1;
    }
    return i;
  }
  function g(f, n, u, a) {
    e(f && typeof f.root == "function"), e(k.isBuffer(n)), e(Array.isArray(u)), e(a >>> 0 === a);
    let s = n;
    for (const i of u) {
      if (a & 1 && i.equals(s))
        return f.zero;
      a & 1 ? s = f.root(i, s) : s = f.root(s, i), a >>>= 1;
    }
    return s;
  }
  return Ji.createTree = c, Ji.createRoot = d, Ji.createBranch = w, Ji.deriveRoot = g, Ji;
}
var yu, k4;
function vo() {
  if (k4) return yu;
  k4 = 1;
  const e = $e(), c = At(), d = yr(), w = Pr(), g = xi(), { inspectSymbol: f } = Kt();
  class n {
    /**
     * Create transaction input.
     * @constructor
     * @param {Object} options
     */
    constructor(a) {
      this.prevout = new g(), this.script = new w(), this.sequence = 4294967295, a && this.fromOptions(a);
    }
    /**
     * Inject properties from options object.
     * @private
     * @param {Object} options
     */
    fromOptions(a) {
      return e(a, "Input data is required."), this.prevout.fromOptions(a.prevout), a.script && this.script.fromOptions(a.script), a.sequence != null && (e(
        a.sequence >>> 0 === a.sequence,
        "Sequence must be a uint32."
      ), this.sequence = a.sequence), this;
    }
    /**
     * Instantiate an Input from options object.
     * @param {Object} options
     * @returns {Input}
     */
    static fromOptions(a) {
      return new this().fromOptions(a);
    }
    /**
     * Clone the input.
     * @returns {Input}
     */
    clone() {
      const a = new this.constructor();
      return a.prevout = this.prevout, a.script.inject(this.script), a.sequence = this.sequence, a;
    }
    /**
     * Test equality against another input.
     * @param {Input} input
     * @returns {Boolean}
     */
    equals(a) {
      return e(n.isInput(a)), this.prevout.equals(a.prevout);
    }
    /**
     * Compare against another input (BIP69).
     * @param {Input} input
     * @returns {Number}
     */
    compare(a) {
      return e(n.isInput(a)), this.prevout.compare(a.prevout);
    }
    /**
     * Get the previous output script type as a string.
     * Will "guess" based on the input script and/or
     * witness if coin is not available.
     * @param {Coin?} coin
     * @returns {ScriptType} type
     */
    getType(a) {
      if (this.isCoinbase())
        return "coinbase";
      if (a)
        return a.getType();
      const s = this.script.getInputType();
      return w.typesByVal[s].toLowerCase();
    }
    /**
     * Get the redeem script.
     * @param {Coin?} coin
     * @returns {Script?} Redeem script.
     */
    getRedeem(a) {
      if (this.isCoinbase())
        return null;
      if (!a)
        return this.script.isScripthashInput() ? this.script.getRedeem() : null;
      let s = a.script, i = null;
      return s.isScripthash() && (s = this.script.getRedeem(), i = s), i;
    }
    /**
     * Get the redeem script type.
     * @param {Coin?} coin
     * @returns {String} subtype
     */
    getSubtype(a) {
      if (this.isCoinbase())
        return null;
      const s = this.getRedeem(a);
      if (!s)
        return null;
      const i = s.getType();
      return w.typesByVal[i].toLowerCase();
    }
    /**
     * Get the previous output script's address. Will "guess"
     * based on the input script and/or witness if coin
     * is not available.
     * @param {Coin?} coin
     * @returns {Address?} addr
     */
    getAddress(a) {
      return this.isCoinbase() ? null : a ? a.getAddress() : this.script.code.length > 0 ? this.script.getInputAddress() : null;
    }
    /**
     * Get the address hash.
     * @param {Coin?} coin
     * @param {String?} enc
     * @returns {Hash} hash
     */
    getHash(a, s) {
      const i = this.getAddress(a);
      return i ? i.getHash(s) : null;
    }
    /**
     * Test to see if nSequence is equal to uint32max.
     * @returns {Boolean}
     */
    isFinal() {
      return this.sequence === 4294967295;
    }
    /**
     * Test to see if nSequence is less than 0xfffffffe.
     * @returns {Boolean}
     */
    isRBF() {
      return this.sequence < 4294967294;
    }
    /**
     * Test to see if outpoint is null.
     * @returns {Boolean}
     */
    isCoinbase() {
      return this.prevout.isNull();
    }
    /**
     * Convert the input to a more user-friendly object.
     * @returns {Object}
     */
    [f]() {
      return this.format();
    }
    /**
     * Convert the input to a more user-friendly object.
     * @param {Coin?} coin
     * @returns {Object}
     */
    format(a) {
      return {
        type: this.getType(a),
        subtype: this.getSubtype(a),
        address: this.getAddress(a),
        script: this.script,
        redeem: this.getRedeem(a),
        sequence: this.sequence,
        prevout: this.prevout,
        coin: a || null
      };
    }
    /**
     * Convert the input to an object suitable
     * for JSON serialization.
     * @returns {Object}
     */
    toJSON(a, s) {
      return this.getJSON();
    }
    /**
     * Convert the input to an object suitable
     * for JSON serialization. Note that the hashes
     * will be reversed to abide by bitcoind's legacy
     * of little-endian uint256s.
     * @param {Network} network
     * @param {Coin} coin
     * @returns {Object}
     */
    getJSON(a, s) {
      a = d.get(a);
      let i;
      return s || (i = this.getAddress(), i && (i = i.toString(a))), {
        prevout: this.prevout.toJSON(),
        script: this.script.toJSON(),
        sequence: this.sequence,
        address: i,
        coin: s ? s.getJSON(a, !0) : void 0
      };
    }
    /**
     * Inject properties from a JSON object.
     * @private
     * @param {Object} json
     */
    fromJSON(a) {
      return e(a, "Input data is required."), e(
        a.sequence >>> 0 === a.sequence,
        "Sequence must be a uint32."
      ), this.prevout.fromJSON(a.prevout), this.script.fromJSON(a.script), this.sequence = a.sequence, this;
    }
    /**
     * Instantiate an Input from a jsonified input object.
     * @param {Object} json - The jsonified input object.
     * @returns {Input}
     */
    static fromJSON(a) {
      return new this().fromJSON(a);
    }
    /**
     * Calculate size of serialized input.
     * @returns {Number}
     */
    getSize() {
      return 40 + this.script.getVarSize();
    }
    /**
     * Serialize the input.
     * @param {String?} enc - Encoding, can be `'hex'` or null.
     * @returns {Buffer|String}
     */
    toRaw() {
      const a = this.getSize();
      return this.toWriter(c.write(a)).render();
    }
    /**
     * Write the input to a buffer writer.
     * @param {BufferWriter} bw
     */
    toWriter(a) {
      return this.prevout.toWriter(a), a.writeVarBytes(this.script.toRaw()), a.writeU32(this.sequence), a;
    }
    /**
     * Inject properties from buffer reader.
     * @private
     * @param {BufferReader} br
     */
    fromReader(a) {
      return this.prevout.fromReader(a), this.script.fromRaw(a.readVarBytes()), this.sequence = a.readU32(), this;
    }
    /**
     * Inject properties from serialized data.
     * @param {Buffer} data
     */
    fromRaw(a) {
      return this.fromReader(c.read(a));
    }
    /**
     * Instantiate an input from a buffer reader.
     * @param {BufferReader} br
     * @returns {Input}
     */
    static fromReader(a) {
      return new this().fromReader(a);
    }
    /**
     * Instantiate an input from a serialized Buffer.
     * @param {Buffer} data
     * @param {String?} enc - Encoding, can be `'hex'` or null.
     * @returns {Input}
     */
    static fromRaw(a, s) {
      return typeof a == "string" && (a = k.from(a, s)), new this().fromRaw(a);
    }
    /**
     * Inject properties from outpoint.
     * @private
     * @param {Outpoint} outpoint
     */
    fromOutpoint(a) {
      return e(k.isBuffer(a.hash)), e(typeof a.index == "number"), this.prevout.hash = a.hash, this.prevout.index = a.index, this;
    }
    /**
     * Instantiate input from outpoint.
     * @param {Outpoint}
     * @returns {Input}
     */
    static fromOutpoint(a) {
      return new this().fromOutpoint(a);
    }
    /**
     * Inject properties from coin.
     * @private
     * @param {Coin} coin
     */
    fromCoin(a) {
      return e(k.isBuffer(a.hash)), e(typeof a.index == "number"), this.prevout.hash = a.hash, this.prevout.index = a.index, this;
    }
    /**
     * Instantiate input from coin.
     * @param {Coin}
     * @returns {Input}
     */
    static fromCoin(a) {
      return new this().fromCoin(a);
    }
    /**
     * Inject properties from transaction.
     * @private
     * @param {TX} tx
     * @param {Number} index
     */
    fromTX(a, s) {
      return e(a), e(typeof s == "number"), e(s >= 0 && s < a.outputs.length), this.prevout.hash = a.hash(), this.prevout.index = s, this;
    }
    /**
     * Instantiate input from tx.
     * @param {TX} tx
     * @param {Number} index
     * @returns {Input}
     */
    static fromTX(a, s) {
      return new this().fromTX(a, s);
    }
    /**
     * Test an object to see if it is an Input.
     * @param {Object} obj
     * @returns {Boolean}
     */
    static isInput(a) {
      return a instanceof n;
    }
  }
  return yu = n, yu;
}
var vu, B4;
function xn() {
  if (B4) return vu;
  B4 = 1;
  const e = $e(), c = At(), d = hr(), w = Rr(), { BufferSet: g } = Dr(), f = Zt(), n = bi(), u = yr(), a = Pr(), s = bo(), i = vo(), p = gi(), m = xi(), E = yo(), v = Ht(), b = mi(), h = ho(), { encoding: o } = c, { hashType: S } = a, H = ts(), { inspectSymbol: j } = Kt();
  class J {
    /**
     * Create a transaction.
     * @constructor
     * @param {Object?} options
     */
    constructor(A) {
      this.version = 1, this.inputs = [], this.outputs = [], this.locktime = 0, this.mutable = !1, this._hash = null, this._hhash = null, this._raw = null, this._offset = -1, this._block = !1, this._size = -1, this._sigops = -1, this._hashPrevouts = null, this._hashSequence = null, this._hashOutputs = null, A && this.fromOptions(A);
    }
    /**
     * Inject properties from options object.
     * @private
     * @param {Object} options
     */
    fromOptions(A) {
      if (e(A, "TX data is required."), A.version != null && (e(
        A.version >>> 0 === A.version,
        "Version must be a uint32."
      ), this.version = A.version), A.inputs) {
        e(Array.isArray(A.inputs), "Inputs must be an array.");
        for (const q of A.inputs)
          this.inputs.push(new i(q));
      }
      if (A.outputs) {
        e(Array.isArray(A.outputs), "Outputs must be an array.");
        for (const q of A.outputs)
          this.outputs.push(new p(q));
      }
      return A.locktime != null && (e(
        A.locktime >>> 0 === A.locktime,
        "Locktime must be a uint32."
      ), this.locktime = A.locktime), A.slpToken && A.slpToken.constructor === s.TokenRecord().constructor && (this.slpToken = A.slpToken), this;
    }
    /**
     * Instantiate TX from options object.
     * @param {Object} options
     * @returns {TX}
     */
    static fromOptions(A) {
      return new this().fromOptions(A);
    }
    /**
     * Clone the transaction.
     * @returns {TX}
     */
    clone() {
      return new this.constructor().inject(this);
    }
    /**
     * Inject properties from tx.
     * Used for cloning.
     * @private
     * @param {TX} tx
     * @returns {TX}
     */
    inject(A) {
      this.version = A.version;
      for (const q of A.inputs)
        this.inputs.push(q.clone());
      for (const q of A.outputs)
        this.outputs.push(q.clone());
      return this.locktime = A.locktime, this;
    }
    /**
     * Clear any cached values.
     */
    refresh() {
      this._hash = null, this._hhash = null, this._raw = null, this._size = -1, this._offset = -1, this._block = !1, this._sigops = -1, this._hashPrevouts = null, this._hashSequence = null, this._hashOutputs = null;
    }
    /**
     * Hash the transaction with the non-witness serialization.
     * @param {String?} enc - Can be `'hex'` or `null`.
     * @returns {Hash|Buffer} hash
     */
    hash(A) {
      let q = this._hash;
      if (q || (q = d.digest(this.toRaw()), this.mutable || (this._hash = q)), A === "hex") {
        let _ = this._hhash;
        _ || (_ = q.toString("hex"), this.mutable || (this._hhash = _)), q = _;
      }
      return q;
    }
    /**
     * Serialize the transaction. Note
     * that this is cached.
     * @returns {Buffer} Serialized transaction.
     */
    toRaw() {
      return this.frame().data;
    }
    /**
     * Write the transaction to a buffer writer.
     * @param {BufferWriter} bw
     * @param {Boolean} block
     */
    toWriter(A, q) {
      return this.mutable ? this.writeNormal(A) : (q && (this._offset = A.offset, this._block = !0), A.writeBytes(this.toRaw()), A);
    }
    /**
     * Serialize the transaction. Note
     * that this is cached.
     * @private
     * @returns {RawTX}
     */
    frame() {
      if (this.mutable)
        return e(!this._raw), this.frameNormal();
      if (this._raw) {
        e(this._size >= 0);
        const q = new N(this._size);
        return q.data = this._raw, q;
      }
      const A = this.frameNormal();
      return this._raw = A.data, this._size = A.size, A;
    }
    /**
     * Return the offset and size of the transaction. Useful
     * when the transaction is deserialized within a block.
     * @returns {Object} contains `size` and `offset`.
     */
    getPosition() {
      return this._block && this._offset > 80 || console.log(this), e(this._block && this._offset > 80, "Position not available."), {
        offset: this._offset,
        size: this._size
      };
    }
    /**
     * Calculate the real size of the transaction.
     * @returns {Number} size
     */
    getSize() {
      return this.mutable ? this.getNormalSizes().size : this.frame().size;
    }
    /**
     * Get the signature hash of the transaction for signing verifying.
     * @param {Number} index - Index of input being signed/verified.
     * @param {Script} prev - Previous output script or redeem script.
     * @param {Amount} value - Previous output value.
     * @param {SighashType} type - Sighash type.
     * @param {Number} flags - Script flags.
     * @returns {Buffer} Signature hash.
     */
    signatureHash(A, q, _, F, R) {
      if (e(A >= 0 && A < this.inputs.length), e(q instanceof a), e(typeof _ == "number"), e(typeof F == "number"), R == null && (R = a.flags.STANDARD_VERIFY_FLAGS), R & a.flags.VERIFY_REPLAY_PROTECTION) {
        const V = H.getHashTypeForkValue(F) ^ 57005;
        F = H.hashTypeWithForkValue(F, V | 16711680);
      }
      return F & a.hashType.SIGHASH_FORKID && R & a.flags.VERIFY_SIGHASH_FORKID ? this.signatureHashV1(A, q, _, F) : this.signatureHashV0(A, q, F);
    }
    /**
     * Legacy sighashing -- O(n^2).
     * @private
     * @param {Number} index
     * @param {Script} prev
     * @param {SighashType} type
     * @returns {Buffer}
     */
    signatureHashV0(A, q, _) {
      if ((_ & 31) === S.SINGLE && A >= this.outputs.length) {
        const V = k.alloc(32, 0);
        return V[0] = 1, V;
      }
      q = q.removeSeparators();
      const F = this.hashSize(A, q, _), R = c.pool(F);
      if (R.writeU32(this.version), _ & S.ANYONECANPAY) {
        const V = this.inputs[A];
        R.writeVarint(1), V.prevout.toWriter(R), R.writeVarBytes(q.toRaw()), R.writeU32(V.sequence);
      } else {
        R.writeVarint(this.inputs.length);
        for (let V = 0; V < this.inputs.length; V++) {
          const fe = this.inputs[V];
          if (fe.prevout.toWriter(R), V === A) {
            R.writeVarBytes(q.toRaw()), R.writeU32(fe.sequence);
            continue;
          }
          switch (R.writeVarint(0), _ & 31) {
            case S.NONE:
            case S.SINGLE:
              R.writeU32(0);
              break;
            default:
              R.writeU32(fe.sequence);
              break;
          }
        }
      }
      switch (_ & 31) {
        case S.NONE: {
          R.writeVarint(0);
          break;
        }
        case S.SINGLE: {
          const V = this.outputs[A];
          R.writeVarint(A + 1);
          for (let fe = 0; fe < A; fe++)
            R.writeI64(-1), R.writeVarint(0);
          V.toWriter(R);
          break;
        }
        default: {
          R.writeVarint(this.outputs.length);
          for (const V of this.outputs)
            V.toWriter(R);
          break;
        }
      }
      return R.writeU32(this.locktime), R.writeU32(_), d.digest(R.render());
    }
    /**
     * Calculate sighash size.
     * @private
     * @param {Number} index
     * @param {Script} prev
     * @param {Number} type
     * @returns {Number}
     */
    hashSize(A, q, _) {
      let F = 0;
      switch (F += 4, _ & S.ANYONECANPAY ? (F += 1, F += 36, F += q.getVarSize(), F += 4) : (F += o.sizeVarint(this.inputs.length), F += 41 * (this.inputs.length - 1), F += 36, F += q.getVarSize(), F += 4), _ & 31) {
        case S.NONE:
          F += 1;
          break;
        case S.SINGLE:
          F += o.sizeVarint(A + 1), F += 9 * A, F += this.outputs[A].getSize();
          break;
        default:
          F += o.sizeVarint(this.outputs.length);
          for (const R of this.outputs)
            F += R.getSize();
          break;
      }
      return F += 8, F;
    }
    /**
     * Witness sighashing -- O(n).
     * @private
     * @param {Number} index
     * @param {Script} prev
     * @param {Amount} value
     * @param {SighashType} type
     * @returns {Buffer}
     */
    signatureHashV1(A, q, _, F) {
      const R = this.inputs[A];
      let V = v.ZERO_HASH, fe = v.ZERO_HASH, ue = v.ZERO_HASH;
      if (!(F & S.ANYONECANPAY))
        if (this._hashPrevouts)
          V = this._hashPrevouts;
        else {
          const Q = c.pool(this.inputs.length * 36);
          for (const Z of this.inputs)
            Z.prevout.toWriter(Q);
          V = d.digest(Q.render()), this.mutable || (this._hashPrevouts = V);
        }
      if (!(F & S.ANYONECANPAY) && (F & 31) !== S.SINGLE && (F & 31) !== S.NONE)
        if (this._hashSequence)
          fe = this._hashSequence;
        else {
          const Q = c.pool(this.inputs.length * 4);
          for (const Z of this.inputs)
            Q.writeU32(Z.sequence);
          fe = d.digest(Q.render()), this.mutable || (this._hashSequence = fe);
        }
      if ((F & 31) !== S.SINGLE && (F & 31) !== S.NONE)
        if (this._hashOutputs)
          ue = this._hashOutputs;
        else {
          let Q = 0;
          for (const oe of this.outputs)
            Q += oe.getSize();
          const Z = c.pool(Q);
          for (const oe of this.outputs)
            oe.toWriter(Z);
          ue = d.digest(Z.render()), this.mutable || (this._hashOutputs = ue);
        }
      else if ((F & 31) === S.SINGLE && A < this.outputs.length) {
        const Q = this.outputs[A];
        ue = d.digest(Q.toRaw());
      }
      const ae = 156 + q.getVarSize(), D = c.pool(ae);
      return D.writeU32(this.version), D.writeBytes(V), D.writeBytes(fe), D.writeHash(R.prevout.hash), D.writeU32(R.prevout.index), D.writeVarBytes(q.toRaw()), D.writeI64(_), D.writeU32(R.sequence), D.writeBytes(ue), D.writeU32(this.locktime), D.writeU32(F), d.digest(D.render());
    }
    /**
     * Verify signature.
     * @param {Number} index
     * @param {Script} prev
     * @param {Amount} value
     * @param {Buffer} sig
     * @param {Buffer} key
     * @param {Number} flags
     * @returns {Boolean}
     */
    checksig(A, q, _, F, R, V) {
      if (F.length === 0)
        return !1;
      const fe = F[F.length - 1], ue = this.signatureHash(A, q, _, fe, V);
      let ae;
      return H.isSchnorr(F) ? ae = w.schnorrVerify(ue, F.slice(0, -1), R) : ae = w.verifyDER(ue, F.slice(0, -1), R), ae;
    }
    /**
     * Create a signature suitable for inserting into scriptSigs.
     * @param {Number} index - Index of input being signed.
     * @param {Script} prev - Previous output script or redeem script.
     * @param {Amount} value - Previous output value.
     * @param {Buffer} key
     * @param {SighashType} type
     * @param {Number} flags - Script flags.
     * @returns {Buffer} Signature in SCHNORR / DER format.
     */
    signature(A, q, _, F, R, V) {
      let fe;
      R == null && (R = S.ALL), V == null && (V = a.flags.VERIFY_SIGHASH_FORKID);
      const ue = this.signatureHash(A, q, _, R, V), ae = w.signDER(ue, F), D = w.schnorrSign(ue, F);
      H.isSchnorr(D) ? fe = D : fe = ae;
      const Q = c.write(fe.length + 1);
      return Q.writeBytes(fe), Q.writeU8(R), Q.render();
    }
    /**
     * Create a signature suitable for inserting into scriptSigs.
     * @param {Number} index - Index of input being signed.
     * @param {Script} prev - Previous output script or redeem script.
     * @param {Amount} value - Previous output value.
     * @param {Buffer} key
     * @param {SighashType} type
     * @param {Number} flags - Script flags.
     * @returns {Buffer} Signature in Schnorr format.
     */
    schnorrSignature(A, q, _, F, R, V) {
      R == null && (R = S.ALL), V == null && (V = a.flags.VERIFY_SIGHASH_FORKID);
      const fe = this.signatureHash(A, q, _, R, V), ue = w.schnorrSign(fe, F), ae = c.write(ue.length + 1);
      return ae.writeBytes(ue), ae.writeU8(R), ae.render();
    }
    /**
     * Verify all transaction inputs.
     * @param {CoinView} view
     * @param {VerifyFlags?} [flags=STANDARD_VERIFY_FLAGS]
     * @throws {ScriptError} on invalid inputs
     */
    check(A, q) {
      if (this.inputs.length === 0)
        throw new h("UNKNOWN_ERROR", "No inputs.");
      if (!this.isCoinbase())
        for (let _ = 0; _ < this.inputs.length; _++) {
          const { prevout: F } = this.inputs[_], R = A.getOutput(F);
          if (!R)
            throw new h("UNKNOWN_ERROR", "No coin available.");
          this.checkInput(_, R, q);
        }
    }
    /**
     * Verify a transaction input.
     * @param {Number} index - Index of output being
     * verified.
     * @param {Coin|Output} coin - Previous output.
     * @param {VerifyFlags} [flags=STANDARD_VERIFY_FLAGS]
     * @throws {ScriptError} on invalid input
     */
    checkInput(A, q, _) {
      const F = this.inputs[A];
      e(F, "Input does not exist."), e(q, "No coin passed."), a.verify(
        F.script,
        null,
        q.script,
        this,
        A,
        q.value,
        _
      );
    }
    /**
     * Verify the transaction inputs on the worker pool
     * (if workers are enabled).
     * @param {CoinView} view
     * @param {VerifyFlags?} [flags=STANDARD_VERIFY_FLAGS]
     * @param {WorkerPool?} pool
     * @returns {Promise}
     */
    async checkAsync(A, q, _) {
      if (this.inputs.length === 0)
        throw new h("UNKNOWN_ERROR", "No inputs.");
      if (!this.isCoinbase()) {
        if (!_) {
          this.check(A, q);
          return;
        }
        await _.check(this, A, q);
      }
    }
    /**
     * Verify a transaction input asynchronously.
     * @param {Number} index - Index of output being
     * verified.
     * @param {Coin|Output} coin - Previous output.
     * @param {VerifyFlags} [flags=STANDARD_VERIFY_FLAGS]
     * @param {WorkerPool?} pool
     * @returns {Promise}
     */
    async checkInputAsync(A, q, _, F) {
      const R = this.inputs[A];
      if (e(R, "Input does not exist."), e(q, "No coin passed."), !F) {
        this.checkInput(A, q, _);
        return;
      }
      await F.checkInput(this, A, q, _);
    }
    /**
     * Verify all transaction inputs.
     * @param {CoinView} view
     * @param {VerifyFlags?} [flags=STANDARD_VERIFY_FLAGS]
     * @returns {Boolean} Whether the inputs are valid.
     */
    verify(A, q) {
      try {
        this.check(A, q);
      } catch (_) {
        if (_.type === "ScriptError")
          return !1;
        throw _;
      }
      return !0;
    }
    /**
     * Verify a transaction input.
     * @param {Number} index - Index of output being
     * verified.
     * @param {Coin|Output} coin - Previous output.
     * @param {VerifyFlags} [flags=STANDARD_VERIFY_FLAGS]
     * @returns {Boolean} Whether the input is valid.
     */
    verifyInput(A, q, _) {
      try {
        this.checkInput(A, q, _);
      } catch (F) {
        if (F.type === "ScriptError")
          return !1;
        throw F;
      }
      return !0;
    }
    /**
     * Verify the transaction inputs on the worker pool
     * (if workers are enabled).
     * @param {CoinView} view
     * @param {VerifyFlags?} [flags=STANDARD_VERIFY_FLAGS]
     * @param {WorkerPool?} pool
     * @returns {Promise}
     */
    async verifyAsync(A, q, _) {
      try {
        await this.checkAsync(A, q, _);
      } catch (F) {
        if (F.type === "ScriptError")
          return !1;
        throw F;
      }
      return !0;
    }
    /**
     * Verify a transaction input asynchronously.
     * @param {Number} index - Index of output being
     * verified.
     * @param {Coin|Output} coin - Previous output.
     * @param {VerifyFlags} [flags=STANDARD_VERIFY_FLAGS]
     * @param {WorkerPool?} pool
     * @returns {Promise}
     */
    async verifyInputAsync(A, q, _, F) {
      try {
        await this.checkInput(A, q, _, F);
      } catch (R) {
        if (R.type === "ScriptError")
          return !1;
        throw R;
      }
      return !0;
    }
    /**
     * Test whether the transaction is a coinbase
     * by examining the inputs.
     * @returns {Boolean}
     */
    isCoinbase() {
      return this.inputs.length === 1 && this.inputs[0].prevout.isNull();
    }
    /**
     * Test whether the transaction is replaceable.
     * @returns {Boolean}
     */
    isRBF() {
      if (this.version === 2)
        return !1;
      for (const A of this.inputs)
        if (A.isRBF())
          return !0;
      return !1;
    }
    /**
     * Calculate the fee for the transaction.
     * @param {CoinView} view
     * @returns {Amount} fee (zero if not all coins are available).
     */
    getFee(A) {
      return this.hasCoins(A) ? this.getInputValue(A) - this.getOutputValue() : 0;
    }
    /**
     * Calculate the total input value.
     * @param {CoinView} view
     * @returns {Amount} value
     */
    getInputValue(A) {
      let q = 0;
      for (const { prevout: _ } of this.inputs) {
        const F = A.getOutput(_);
        if (!F)
          return 0;
        q += F.value;
      }
      return q;
    }
    /**
     * Calculate the total output value.
     * @returns {Amount} value
     */
    getOutputValue() {
      let A = 0;
      for (const q of this.outputs)
        A += q.value;
      return A;
    }
    /**
     * Get all input addresses.
     * @private
     * @param {CoinView} view
     * @returns {Array} [addrs, table]
     */
    _getInputAddresses(A) {
      const q = new g(), _ = [];
      if (this.isCoinbase())
        return [_, q];
      for (const F of this.inputs) {
        const R = A ? A.getOutputFor(F) : null, V = F.getAddress(R);
        if (!V)
          continue;
        const fe = V.getHash();
        q.has(fe) || (q.add(fe), _.push(V));
      }
      return [_, q];
    }
    /**
     * Get all output addresses.
     * @private
     * @returns {Array} [addrs, table]
     */
    _getOutputAddresses() {
      const A = new g(), q = [];
      for (const _ of this.outputs) {
        const F = _.getAddress();
        if (!F)
          continue;
        const R = F.getHash();
        A.has(R) || (A.add(R), q.push(F));
      }
      return [q, A];
    }
    /**
     * Get all addresses.
     * @private
     * @param {CoinView} view
     * @returns {Array} [addrs, table]
     */
    _getAddresses(A) {
      const [q, _] = this._getInputAddresses(A), F = this.getOutputAddresses();
      for (const R of F) {
        const V = R.getHash();
        _.has(V) || (_.add(V), q.push(R));
      }
      return [q, _];
    }
    /**
     * Get all input addresses.
     * @param {CoinView|null} view
     * @returns {Address[]} addresses
     */
    getInputAddresses(A) {
      const [q] = this._getInputAddresses(A);
      return q;
    }
    /**
     * Get all output addresses.
     * @returns {Address[]} addresses
     */
    getOutputAddresses() {
      const [A] = this._getOutputAddresses();
      return A;
    }
    /**
     * Get all addresses.
     * @param {CoinView|null} view
     * @returns {Address[]} addresses
     */
    getAddresses(A) {
      const [q] = this._getAddresses(A);
      return q;
    }
    /**
     * Get all input address hashes.
     * @param {CoinView|null} view
     * @returns {Hash[]} hashes
     */
    getInputHashes(A, q) {
      const [, _] = this._getInputAddresses(A);
      return q !== "hex" ? _.toArray() : _.toArray().map((F) => F.toString("hex"));
    }
    /**
     * Get all output address hashes.
     * @returns {Hash[]} hashes
     */
    getOutputHashes(A) {
      const [, q] = this._getOutputAddresses();
      return A !== "hex" ? q.toArray() : q.toArray().map((_) => _.toString("hex"));
    }
    /**
     * Get all address hashes.
     * @param {CoinView|null} view
     * @returns {Hash[]} hashes
     */
    getHashes(A, q) {
      const [, _] = this._getAddresses(A);
      return q !== "hex" ? _.toArray() : _.toArray().map((F) => F.toString("hex"));
    }
    /**
     * Test whether the transaction has
     * all coins available.
     * @param {CoinView} view
     * @returns {Boolean}
     */
    hasCoins(A) {
      if (this.inputs.length === 0)
        return !1;
      for (const { prevout: q } of this.inputs)
        if (!A.hasEntry(q))
          return !1;
      return !0;
    }
    /**
     * Check finality of transaction by examining
     * nLocktime and nSequence values.
     * @example
     * tx.isFinal(chain.height + 1, network.now());
     * @param {Number} height - Height at which to test. This
     * is usually the chain height, or the chain height + 1
     * when the transaction entered the mempool.
     * @param {Number} time - Time at which to test. This is
     * usually the chain tip's parent's median time, or the
     * time at which the transaction entered the mempool. If
     * MEDIAN_TIME_PAST is enabled this will be the median
     * time of the chain tip's previous entry's median time.
     * @returns {Boolean}
     */
    isFinal(A, q) {
      const _ = v.LOCKTIME_THRESHOLD;
      if (this.locktime === 0 || this.locktime < (this.locktime < _ ? A : q))
        return !0;
      for (const F of this.inputs)
        if (F.sequence !== 4294967295)
          return !1;
      return !0;
    }
    /**
     * Verify the absolute locktime of a transaction.
     * Called by OP_CHECKLOCKTIMEVERIFY.
     * @param {Number} index - Index of input being verified.
     * @param {Number} predicate - Locktime to verify against.
     * @returns {Boolean}
     */
    verifyLocktime(A, q) {
      const _ = v.LOCKTIME_THRESHOLD, F = this.inputs[A];
      return e(F, "Input does not exist."), e(q >= 0, "Locktime must be non-negative."), !(this.locktime < _ != q < _ || q > this.locktime || F.sequence === 4294967295);
    }
    /**
     * Verify the relative locktime of an input.
     * Called by OP_CHECKSEQUENCEVERIFY.
     * @param {Number} index - Index of input being verified.
     * @param {Number} predicate - Relative locktime to verify against.
     * @returns {Boolean}
     */
    verifySequence(A, q) {
      const _ = v.SEQUENCE_DISABLE_FLAG, F = v.SEQUENCE_TYPE_FLAG, R = v.SEQUENCE_MASK, V = this.inputs[A];
      return e(V, "Input does not exist."), e(q >= 0, "Locktime must be non-negative."), q & _ ? !0 : !(this.version < 2 || V.sequence & _ || (V.sequence & F) !== (q & F) || (q & R) > (V.sequence & R));
    }
    /**
     * Calculate legacy (inaccurate) sigop count.
     * @returns {Number} sigop count
     */
    getLegacySigops() {
      if (this._sigops !== -1)
        return this._sigops;
      let A = 0;
      for (const q of this.inputs)
        A += q.script.getSigops(!1);
      for (const q of this.outputs)
        A += q.script.getSigops(!1);
      return this.mutable || (this._sigops = A), A;
    }
    /**
     * Calculate accurate sigop count, taking into account redeem scripts.
     * @param {CoinView} view
     * @param {VerifyFlags} flags
     * @returns {Number} sigop count
     */
    getScripthashSigops(A, q) {
      if (this.isCoinbase())
        return 0;
      let _ = 0;
      for (const F of this.inputs) {
        const R = A.getOutputFor(F);
        R && R.script.isScripthash() && (_ += R.script.getScripthashSigops(F.script, q));
      }
      return _;
    }
    /**
     * Calculate sigops count.
     * @param {CoinView} view
     * @param {VerifyFlags?} flags
     * @returns {Number} sigop count
     */
    getSigopsCount(A, q) {
      q === null && (q = a.flags.STANDARD_VERIFY_FLAGS);
      let _ = this.getLegacySigops();
      return q & a.flags.VERIFY_P2SH && (_ += this.getScripthashSigops(A, q)), _;
    }
    /**
     * Calculate sigop count.
     * @param {CoinView} view
     * @param {VerifyFlags?} flags
     * @returns {Number} sigop count
     */
    getSigops(A, q) {
      return this.getSigopsCount(A, q);
    }
    /**
     * Non-contextual sanity checks for the transaction.
     * Will mostly verify coin and output values.
     * @see CheckTransaction()
     * @returns {Array} [result, reason, score]
     */
    isSane() {
      const [A] = this.checkSanity();
      return A;
    }
    /**
     * Non-contextual sanity checks for the transaction.
     * Will mostly verify coin and output values.
     * @see CheckTransaction()
     * @returns {Array} [valid, reason, score]
     */
    checkSanity() {
      if (this.inputs.length === 0)
        return [!1, "bad-txns-vin-empty", 100];
      if (this.outputs.length === 0)
        return [!1, "bad-txns-vout-empty", 100];
      if (this.getSize() > v.MAX_TX_SIZE)
        return [!1, "bad-txns-oversize", 100];
      let A = 0;
      for (const _ of this.outputs) {
        if (_.value < 0)
          return [!1, "bad-txns-vout-negative", 100];
        if (_.value > v.MAX_MONEY)
          return [!1, "bad-txns-vout-toolarge", 100];
        if (A += _.value, A < 0 || A > v.MAX_MONEY)
          return [!1, "bad-txns-txouttotal-toolarge", 100];
      }
      const q = new g();
      for (const _ of this.inputs) {
        const F = _.prevout.toKey();
        if (q.has(F))
          return [!1, "bad-txns-inputs-duplicate", 100];
        q.add(F);
      }
      if (this.isCoinbase()) {
        const _ = this.inputs[0].script.getSize();
        if (_ < 2 || _ > v.MAX_COINBASE_SCRIPTSIG_SIZE)
          return [!1, "bad-cb-length", 100];
      } else
        for (const _ of this.inputs)
          if (_.prevout.isNull())
            return [!1, "bad-txns-prevout-null", 10];
      return [!0, "valid", 0];
    }
    /**
     * Non-contextual checks to determine whether the
     * transaction has all standard output script
     * types and standard input script size with only
     * pushdatas in the code.
     * Will mostly verify coin and output values.
     * @see IsStandardTx()
     * @returns {Array} [valid, reason, score]
     */
    isStandard() {
      const [A] = this.checkStandard();
      return A;
    }
    /**
     * Non-contextual checks to determine whether the
     * transaction has all standard output script
     * types and standard input script size with only
     * pushdatas in the code.
     * Will mostly verify coin and output values.
     * @see IsStandardTx()
     * @returns {Array} [valid, reason, score]
     */
    checkStandard() {
      if (this.version < 1 || this.version > b.MAX_TX_VERSION)
        return [!1, "version", 0];
      if (this.getSize() >= b.MAX_TX_SIZE)
        return [!1, "tx-size", 0];
      for (const q of this.inputs) {
        if (q.script.getSize() > 1650)
          return [!1, "scriptsig-size", 0];
        if (!q.script.isPushOnly())
          return [!1, "scriptsig-not-pushonly", 0];
      }
      let A = 0;
      for (const q of this.outputs) {
        if (!q.script.isStandard())
          return [!1, "scriptpubkey", 0];
        if (q.script.isNulldata()) {
          A++;
          continue;
        }
        if (q.script.isMultisig() && !b.BARE_MULTISIG)
          return [!1, "bare-multisig", 0];
        if (q.isDust(b.MIN_RELAY))
          return [!1, "dust", 0];
      }
      return A > 1 ? [!1, "multi-op-return", 0] : [!0, "valid", 0];
    }
    /**
     * Perform contextual checks to verify coin and input
     * script standardness (including the redeem script).
     * @see AreInputsStandard()
     * @param {CoinView} view
     * @param {VerifyFlags?} flags
     * @returns {Boolean}
     */
    hasStandardInputs(A) {
      if (this.isCoinbase())
        return !0;
      for (const q of this.inputs) {
        const _ = A.getOutputFor(q);
        if (!_)
          return !1;
        if (!_.script.isPubkeyhash()) {
          if (_.script.isScripthash()) {
            const F = q.script.getRedeem();
            if (!F || F.getSigops(!0) > b.MAX_P2SH_SIGOPS)
              return !1;
            continue;
          }
          if (_.script.isUnknown())
            return !1;
        }
      }
      return !0;
    }
    /**
     * Perform contextual checks to verify input, output,
     * and fee values, as well as coinbase spend maturity
     * (coinbases can only be spent 100 blocks or more
     * after they're created). Note that this function is
     * consensus critical.
     * @param {CoinView} view
     * @param {Number} height - Height at which the
     * transaction is being spent. In the mempool this is
     * the chain height plus one at the time it entered the pool.
     * @returns {Boolean}
     */
    verifyInputs(A, q) {
      const [_] = this.checkInputs(A, q);
      return _ !== -1;
    }
    /**
     * Perform contextual checks to verify input, output,
     * and fee values, as well as coinbase spend maturity
     * (coinbases can only be spent 100 blocks or more
     * after they're created). Note that this function is
     * consensus critical.
     * @param {CoinView} view
     * @param {Number} height - Height at which the
     * transaction is being spent. In the mempool this is
     * the chain height plus one at the time it entered the pool.
     * @returns {Array} [fee, reason, score]
     */
    checkInputs(A, q) {
      e(typeof q == "number");
      let _ = 0;
      for (const { prevout: V } of this.inputs) {
        const fe = A.getEntry(V);
        if (!fe)
          return [-1, "bad-txns-inputs-missingorspent", 0];
        if (fe.coinbase && q - fe.height < v.COINBASE_MATURITY)
          return [-1, "bad-txns-premature-spend-of-coinbase", 0];
        const ue = A.getOutput(V);
        if (e(ue), ue.value < 0 || ue.value > v.MAX_MONEY)
          return [-1, "bad-txns-inputvalues-outofrange", 100];
        if (_ += ue.value, _ < 0 || _ > v.MAX_MONEY)
          return [-1, "bad-txns-inputvalues-outofrange", 100];
      }
      const F = this.getOutputValue();
      if (_ < F)
        return [-1, "bad-txns-in-belowout", 100];
      const R = _ - F;
      return R < 0 ? [-1, "bad-txns-fee-negative", 100] : R > v.MAX_MONEY ? [-1, "bad-txns-fee-outofrange", 100] : [R, "valid", 0];
    }
    /**
     * Calculate the modified size of the transaction. This
     * is used in the mempool for calculating priority.
     * @param {Number?} size - The size to modify. If not present,
     * virtual size will be used.
     * @returns {Number} Modified size.
     */
    getModifiedSize(A) {
      A == null && (A = this.getSize());
      for (const q of this.inputs) {
        const _ = 41 + Math.min(110, q.script.getSize());
        A > _ && (A -= _);
      }
      return A;
    }
    /**
     * Calculate the transaction priority.
     * @param {CoinView} view
     * @param {Number} height
     * @param {Number?} size - Size to calculate priority
     * based on. If not present, virtual size will be used.
     * @returns {Number}
     */
    getPriority(A, q, _) {
      if (e(typeof q == "number", "Must pass in height."), this.isCoinbase())
        return 0;
      _ == null && (_ = this.getSize());
      let F = 0;
      for (const { prevout: R } of this.inputs) {
        const V = A.getOutput(R);
        if (!V)
          continue;
        const fe = A.getHeight(R);
        if (fe !== -1 && fe <= q) {
          const ue = q - fe;
          F += V.value * ue;
        }
      }
      return Math.floor(F / _);
    }
    /**
     * Calculate the transaction's on-chain value.
     * @param {CoinView} view
     * @returns {Number}
     */
    getChainValue(A) {
      if (this.isCoinbase())
        return 0;
      let q = 0;
      for (const { prevout: _ } of this.inputs) {
        const F = A.getOutput(_);
        !F || A.getHeight(_) === -1 || (q += F.value);
      }
      return q;
    }
    /**
     * Determine whether the transaction is above the
     * free threshold in priority. A transaction which
     * passed this test is most likely relayable
     * without a fee.
     * @param {CoinView} view
     * @param {Number?} height - If not present, tx
     * height or network height will be used.
     * @param {Number?} size - If not present, modified
     * size will be calculated and used.
     * @returns {Boolean}
     */
    isFree(A, q, _) {
      return this.getPriority(A, q, _) > b.FREE_THRESHOLD;
    }
    /**
     * Calculate minimum fee in order for the transaction
     * to be relayable (not the constant min relay fee).
     * @param {Number?} size - If not present, max size
     * estimation will be calculated and used.
     * @param {Rate?} rate - Rate of satoshi per kB.
     * @returns {Amount} fee
     */
    getMinFee(A, q) {
      return A == null && (A = this.getSize()), b.getMinFee(A, q);
    }
    /**
     * Calculate the minimum fee in order for the transaction
     * to be relayable, but _round to the nearest kilobyte
     * when taking into account size.
     * @param {Number?} size - If not present, max size
     * estimation will be calculated and used.
     * @param {Rate?} rate - Rate of satoshi per kB.
     * @returns {Amount} fee
     */
    getRoundFee(A, q) {
      return A == null && (A = this.getSize()), b.getRoundFee(A, q);
    }
    /**
     * Calculate the transaction's rate based on size
     * and fees. Size will be calculated if not present.
     * @param {CoinView} view
     * @param {Number?} size
     * @returns {Rate}
     */
    getRate(A, q) {
      const _ = this.getFee(A);
      return _ < 0 ? 0 : (q == null && (q = this.getSize()), b.getRate(q, _));
    }
    /**
     * Get all unique outpoint hashes.
     * @returns {Hash[]} Outpoint hashes.
     */
    getPrevout() {
      if (this.isCoinbase())
        return [];
      const A = new g();
      for (const q of this.inputs)
        A.add(q.prevout.hash);
      return A.toArray();
    }
    /**
     * Test a transaction against a bloom filter using
     * the BIP37 matching algorithm. Note that this may
     * update the filter depending on what the `update`
     * value is.
     * @see "Filter matching algorithm":
     * @see https://github.com/bitcoin/bips/blob/master/bip-0037.mediawiki
     * @param {BloomFilter} filter
     * @returns {Boolean} True if the transaction matched.
     */
    isWatched(A) {
      let q = !1;
      A.test(this.hash()) && (q = !0);
      for (let _ = 0; _ < this.outputs.length; _++) {
        const F = this.outputs[_];
        if (F.script.test(A)) {
          if (A.update === 1) {
            const R = m.fromTX(this, _);
            A.add(R.toRaw());
          } else if (A.update === 2 && (F.script.isPubkey() || F.script.isMultisig())) {
            const R = m.fromTX(this, _);
            A.add(R.toRaw());
          }
          q = !0;
        }
      }
      if (q)
        return q;
      for (const _ of this.inputs) {
        const F = _.prevout;
        if (A.test(F.toRaw()) || _.script.test(A))
          return !0;
      }
      return !1;
    }
    /**
     * Get little-endian tx hash.
     * @returns {Hash}
     */
    rhash() {
      return f.revHex(this.hash());
    }
    /**
     * Get little-endian tx hash.
     * @returns {Hash}
     */
    txid() {
      return this.rhash();
    }
    /**
     * Convert the tx to an inv item.
     * @returns {InvItem}
     */
    toInv() {
      return new E(E.types.TX, this.hash());
    }
    /**
     * Inspect the transaction and return a more
     * user-friendly representation of the data.
     * @returns {Object}
     */
    [j]() {
      return this.format();
    }
    /**
     * Inspect the transaction and return a more
     * user-friendly representation of the data.
     * @param {CoinView} view
     * @param {ChainEntry} entry
     * @param {Number} index
     * @returns {Object}
     */
    format(A, q, _) {
      let F = 0, R = 0, V = -1, fe = null, ue = 0, ae = null;
      A && (R = this.getFee(A), F = this.getRate(A), Number.isSafeInteger(F) || (F = 0)), q && (V = q.height, fe = f.revHex(q.hash), ue = q.time, ae = f.date(ue)), _ == null && (_ = -1);
      const D = {
        hash: this.txid(),
        size: this.getSize(),
        value: n.btc(this.getOutputValue()),
        fee: n.btc(R),
        rate: n.btc(F),
        minFee: n.btc(this.getMinFee()),
        height: V,
        block: fe,
        time: ue,
        date: ae,
        index: _,
        version: this.version,
        inputs: this.inputs.map((Q) => {
          const Z = A ? A.getOutputFor(Q) : null;
          return Q.format(Z);
        }),
        outputs: this.outputs,
        locktime: this.locktime
      };
      return this.slpToken ? {
        ...D,
        slpToken: this.slpToken
      } : D;
    }
    /**
     * Convert the transaction to an object suitable
     * for JSON serialization.
     * @returns {Object}
     */
    toJSON() {
      return this.getJSON();
    }
    /**
     * Convert the transaction to an object suitable
     * for JSON serialization. Note that the hashes
     * will be reversed to abide by bitcoind's legacy
     * of little-endian uint256s.
     * @param {Network} network
     * @param {CoinView} view
     * @param {ChainEntry} entry
     * @param {Number} index
     * @returns {Object}
     */
    getJSON(A, q, _, F) {
      let R, V, fe, ue, ae, D;
      q && (V = this.getFee(q), R = this.getRate(q), Number.isSafeInteger(R) || (R = 0)), _ && (fe = _.height, ue = f.revHex(_.hash), ae = _.time, D = f.date(ae)), A = u.get(A);
      const Q = {
        hash: this.txid(),
        fee: V,
        rate: R,
        mtime: f.now(),
        height: fe,
        block: ue,
        time: ae,
        date: D,
        index: F,
        version: this.version,
        inputs: this.inputs.map((Z) => {
          const oe = q ? q.getCoinFor(Z) : null;
          return Z.getJSON(A, oe);
        }),
        outputs: this.outputs.map((Z) => Z.getJSON(A)),
        locktime: this.locktime,
        hex: this.toRaw().toString("hex")
      };
      return this.slpToken ? {
        ...Q,
        slpToken: this.slpToken.getJSON()
      } : Q;
    }
    /**
     * Inject properties from a json object.
     * @private
     * @param {Object} json
     */
    fromJSON(A) {
      e(A, "TX data is required."), e(A.version >>> 0 === A.version, "Version must be a uint32."), e(Array.isArray(A.inputs), "Inputs must be an array."), e(Array.isArray(A.outputs), "Outputs must be an array."), e(
        A.locktime >>> 0 === A.locktime,
        "Locktime must be a uint32."
      ), this.version = A.version;
      for (const q of A.inputs)
        this.inputs.push(i.fromJSON(q));
      for (const q of A.outputs)
        this.outputs.push(p.fromJSON(q));
      return this.locktime = A.locktime, A.slpToken && (this.slpToken = s.TokenRecord().fromJSON(A.slpToken)), this;
    }
    /**
     * Instantiate a transaction from a
     * jsonified transaction object.
     * @param {Object} json - The jsonified transaction object.
     * @returns {TX}
     */
    static fromJSON(A) {
      return new this().fromJSON(A);
    }
    /**
     * Instantiate a transaction from a serialized Buffer.
     * @param {Buffer} data
     * @param {String?} enc - Encoding, can be `'hex'` or null.
     * @returns {TX}
     */
    static fromRaw(A, q) {
      return typeof A == "string" && (A = k.from(A, q)), new this().fromRaw(A);
    }
    /**
     * Instantiate a transaction from a buffer reader.
     * @param {BufferReader} br
     * @param {Boolean} block
     * @returns {TX}
     */
    static fromReader(A, q) {
      return new this().fromReader(A, q);
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     */
    fromRaw(A) {
      return this.fromReader(c.read(A));
    }
    /**
     * Inject properties from buffer reader.
     * @private
     * @param {BufferReader} br
     * @param {Boolean} block
     */
    fromReader(A, q) {
      const _ = A.start();
      this.version = A.readU32();
      const F = A.readVarint();
      for (let V = 0; V < F; V++)
        this.inputs.push(i.fromReader(A));
      const R = A.readVarint();
      for (let V = 0; V < R; V++)
        this.outputs.push(p.fromReader(A));
      return this.locktime = A.readU32(), q && (this._offset = _, this._block = !0), this.mutable ? A.end() : (this._raw = A.endData(), this._size = this._raw.length), this;
    }
    /**
     * Serialize transaction without witness.
     * @private
     * @returns {RawTX}
     */
    frameNormal() {
      const A = this.getNormalSizes(), q = c.write(A.size);
      return this.writeNormal(q), A.data = q.render(), A;
    }
    /**
     * Serialize transaction without witness.
     * @private
     * @param {BufferWriter} bw
     * @returns {RawTX}
     */
    writeNormal(A) {
      if (this.inputs.length === 0 && this.outputs.length !== 0)
        throw new Error("Cannot serialize zero-input tx.");
      A.writeU32(this.version), A.writeVarint(this.inputs.length);
      for (const q of this.inputs)
        q.toWriter(A);
      A.writeVarint(this.outputs.length);
      for (const q of this.outputs)
        q.toWriter(A);
      return A.writeU32(this.locktime), A;
    }
    /**
     * Calculate the real size of the transaction
     * without the witness vector.
     * @returns {RawTX}
     */
    getNormalSizes() {
      let A = 0;
      A += 4, A += o.sizeVarint(this.inputs.length);
      for (const q of this.inputs)
        A += q.getSize();
      A += o.sizeVarint(this.outputs.length);
      for (const q of this.outputs)
        A += q.getSize();
      return A += 4, new N(A, 0);
    }
    /**
     * Test whether an object is a TX.
     * @param {Object} obj
     * @returns {Boolean}
     */
    static isTX(A) {
      return A instanceof J;
    }
  }
  class N {
    constructor(A) {
      this.data = null, this.size = A;
    }
  }
  return vu = J, vu;
}
var Su, M4;
function ns() {
  if (M4) return Su;
  M4 = 1;
  const e = At(), c = Zt(), d = is(), { inspectSymbol: w } = Kt();
  class g extends d {
    /**
     * Create headers.
     * @constructor
     * @param {Object} options
     */
    constructor(n) {
      super(), n && this.parseOptions(n);
    }
    /**
     * Perform non-contextual
     * verification on the headers.
     * @returns {Boolean}
     */
    verifyBody() {
      return !0;
    }
    /**
     * Get size of the headers.
     * @returns {Number}
     */
    getSize() {
      return 81;
    }
    /**
     * Serialize the headers to a buffer writer.
     * @param {BufferWriter} bw
     */
    toWriter(n) {
      return this.writeHead(n), n.writeVarint(0), n;
    }
    /**
     * Serialize the headers.
     * @returns {Buffer|String}
     */
    toRaw() {
      const n = this.getSize();
      return this.toWriter(e.write(n)).render();
    }
    /**
     * Inject properties from buffer reader.
     * @private
     * @param {Buffer} data
     */
    fromReader(n) {
      return this.readHead(n), n.readVarint(), this;
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     */
    fromRaw(n) {
      return this.fromReader(e.read(n));
    }
    /**
     * Instantiate headers from buffer reader.
     * @param {BufferReader} br
     * @returns {Headers}
     */
    static fromReader(n) {
      return new this().fromReader(n);
    }
    /**
     * Instantiate headers from serialized data.
     * @param {Buffer} data
     * @param {String?} enc - Encoding, can be `'hex'` or null.
     * @returns {Headers}
     */
    static fromRaw(n, u) {
      return typeof n == "string" && (n = k.from(n, u)), new this().fromRaw(n);
    }
    /**
     * Instantiate headers from serialized data.
     * @param {Buffer} data
     * @param {String?} enc - Encoding, can be `'hex'` or null.
     * @returns {Headers}
     */
    static fromHead(n, u) {
      return typeof n == "string" && (n = k.from(n, u)), new this().fromHead(n);
    }
    /**
     * Instantiate headers from a chain entry.
     * @param {ChainEntry} entry
     * @returns {Headers}
     */
    static fromEntry(n) {
      const u = new this();
      return u.version = n.version, u.prevBlock = n.prevBlock, u.merkleRoot = n.merkleRoot, u.time = n.time, u.bits = n.bits, u.nonce = n.nonce, u._hash = n.hash, u._hhash = n.hash, u;
    }
    /**
     * Convert the block to a headers object.
     * @returns {Headers}
     */
    toHeaders() {
      return this;
    }
    /**
     * Convert the block to a headers object.
     * @param {Block|MerkleBlock} block
     * @returns {Headers}
     */
    static fromBlock(n) {
      const u = new this(n);
      return u._hash = n._hash, u._hhash = n._hhash, u;
    }
    /**
     * Convert the block to an object suitable
     * for JSON serialization.
     * @returns {Object}
     */
    toJSON() {
      return this.getJSON();
    }
    /**
     * Convert the block to an object suitable
     * for JSON serialization. Note that the hashes
     * will be reversed to abide by bitcoind's legacy
     * of little-endian uint256s.
     * @param {Network} network
     * @param {CoinView} view
     * @param {Number} height
     * @returns {Object}
     */
    getJSON(n, u, a) {
      return {
        hash: this.rhash(),
        height: a,
        version: this.version,
        prevBlock: c.revHex(this.prevBlock),
        merkleRoot: c.revHex(this.merkleRoot),
        time: this.time,
        bits: this.bits,
        nonce: this.nonce
      };
    }
    /**
     * Inject properties from json object.
     * @private
     * @param {Object} json
     */
    fromJSON(n) {
      return this.parseJSON(n), this;
    }
    /**
     * Instantiate a merkle block from a jsonified block object.
     * @param {Object} json - The jsonified block object.
     * @returns {Headers}
     */
    static fromJSON(n) {
      return new this().fromJSON(n);
    }
    /**
     * Inspect the headers and return a more
     * user-friendly representation of the data.
     * @returns {Object}
     */
    [w]() {
      return this.format();
    }
    /**
     * Inspect the headers and return a more
     * user-friendly representation of the data.
     * @param {CoinView} view
     * @param {Number} height
     * @returns {Object}
     */
    format(n, u) {
      return {
        hash: this.rhash(),
        height: u ?? -1,
        date: c.date(this.time),
        version: this.version.toString(16),
        prevBlock: c.revHex(this.prevBlock),
        merkleRoot: c.revHex(this.merkleRoot),
        time: this.time,
        bits: this.bits,
        nonce: this.nonce
      };
    }
    /**
     * Test an object to see if it is a Headers object.
     * @param {Object} obj
     * @returns {Boolean}
     */
    static isHeaders(n) {
      return n instanceof g;
    }
  }
  return Su = g, Su;
}
var Eu, N4;
function yl() {
  if (N4) return Eu;
  N4 = 1;
  const e = $e(), c = At(), { BufferMap: d, BufferSet: w } = Dr(), g = Zt(), f = hr(), n = Ht(), u = is(), a = ns(), s = k.from([0]), { encoding: i } = c, { inspectSymbol: p } = Kt();
  class m extends u {
    /**
     * Create a merkle block.
     * @constructor
     * @param {Object} options
     */
    constructor(b) {
      super(), this.txs = [], this.hashes = [], this.flags = s, this.totalTX = 0, this._tree = null, b && this.fromOptions(b);
    }
    /**
     * Inject properties from options object.
     * @private
     * @param {Object} options
     */
    fromOptions(b) {
      if (this.parseOptions(b), e(b, "MerkleBlock data is required."), e(Array.isArray(b.hashes)), e(k.isBuffer(b.flags)), e(b.totalTX >>> 0 === b.totalTX), b.hashes)
        for (const h of b.hashes)
          e(k.isBuffer(h)), this.hashes.push(h);
      return b.flags && (e(k.isBuffer(b.flags)), this.flags = b.flags), b.totalTX != null && (e(b.totalTX >>> 0 === b.totalTX), this.totalTX = b.totalTX), this;
    }
    /**
     * Instantiate merkle block from options object.
     * @param {Object} options
     * @returns {MerkleBlock}
     */
    static fromOptions(b) {
      return new this().fromOptions(b);
    }
    /**
     * Clear any cached values.
     * @param {Boolean?} all - Clear transactions.
     */
    refresh(b) {
      if (this._refresh(), this._tree = null, !!b)
        for (const h of this.txs)
          h.refresh();
    }
    /**
     * Test the block's _matched_ transaction vector against a hash.
     * @param {Hash} hash
     * @returns {Boolean}
     */
    hasTX(b) {
      return this.indexOf(b) !== -1;
    }
    /**
     * Test the block's _matched_ transaction vector against a hash.
     * @param {Hash} hash
     * @returns {Number} Index.
     */
    indexOf(b) {
      const o = this.getTree().map.get(b);
      return o ?? -1;
    }
    /**
     * Verify the partial merkletree.
     * @private
     * @returns {Boolean}
     */
    verifyBody() {
      const [b] = this.checkBody();
      return b;
    }
    /**
     * Verify the partial merkletree.
     * @private
     * @returns {Array} [valid, reason, score]
     */
    checkBody() {
      return this.getTree().root.equals(this.merkleRoot) ? [!0, "valid", 0] : [!1, "bad-txnmrklroot", 100];
    }
    /**
     * Extract the matches from partial merkle
     * tree and calculate merkle root.
     * @returns {Object}
     */
    getTree() {
      if (!this._tree)
        try {
          this._tree = this.extractTree();
        } catch {
          this._tree = new E();
        }
      return this._tree;
    }
    /**
     * Extract the matches from partial merkle
     * tree and calculate merkle root.
     * @private
     * @returns {Object}
     */
    extractTree() {
      const b = [], h = [], o = new d(), S = this.hashes, H = this.flags, j = this.totalTX;
      let J = 0, N = 0, z = !1, A = 0;
      const q = (R) => j + (1 << R) - 1 >>> R, _ = (R, V) => {
        if (J >= H.length * 8)
          return z = !0, n.ZERO_HASH;
        const fe = H[J / 8 | 0] >>> J % 8 & 1;
        if (J += 1, R === 0 || !fe) {
          if (N >= S.length)
            return z = !0, n.ZERO_HASH;
          const D = S[N];
          return N += 1, R === 0 && fe && (b.push(D), h.push(V), o.set(D, V)), D;
        }
        const ue = _(R - 1, V * 2);
        let ae;
        return V * 2 + 1 < q(R - 1) ? (ae = _(R - 1, V * 2 + 1), ae.equals(ue) && (z = !0)) : ae = ue, f.root(ue, ae);
      };
      if (j === 0)
        throw new Error("Zero transactions.");
      if (S.length > j)
        throw new Error("Too many hashes.");
      if (H.length * 8 < S.length)
        throw new Error("Flags too small.");
      for (; q(A) > 1; )
        A += 1;
      const F = _(A, 0);
      if (z)
        throw new Error("Mutated merkle tree.");
      if (((J + 7) / 8 | 0) !== H.length)
        throw new Error("Too many flag bits.");
      if (N !== S.length)
        throw new Error("Incorrect number of hashes.");
      return new E(F, b, h, o);
    }
    /**
     * Extract the coinbase height (always -1).
     * @returns {Number}
     */
    getCoinbaseHeight() {
      return -1;
    }
    /**
     * Inspect the block and return a more
     * user-friendly representation of the data.
     * @returns {Object}
     */
    [p]() {
      return this.format();
    }
    /**
     * Inspect the block and return a more
     * user-friendly representation of the data.
     * @param {CoinView} view
     * @param {Number} height
     * @returns {Object}
     */
    format(b, h) {
      return {
        hash: this.rhash(),
        height: h ?? -1,
        date: g.date(this.time),
        version: this.version.toString(16),
        prevBlock: g.revHex(this.prevBlock),
        merkleRoot: g.revHex(this.merkleRoot),
        time: this.time,
        bits: this.bits,
        nonce: this.nonce,
        totalTX: this.totalTX,
        hashes: this.hashes.map((o) => o.toString("hex")),
        flags: this.flags,
        map: this.getTree().map,
        txs: this.txs.length
      };
    }
    /**
     * Get merkleblock size.
     * @returns {Number} Size.
     */
    getSize() {
      let b = 0;
      return b += 80, b += 4, b += i.sizeVarint(this.hashes.length), b += this.hashes.length * 32, b += i.sizeVarint(this.flags.length), b += this.flags.length, b;
    }
    /**
     * Write the merkleblock to a buffer writer.
     * @param {BufferWriter} bw
     */
    toWriter(b) {
      this.writeHead(b), b.writeU32(this.totalTX), b.writeVarint(this.hashes.length);
      for (const h of this.hashes)
        b.writeHash(h);
      return b.writeVarBytes(this.flags), b;
    }
    /**
     * Serialize the merkleblock.
     * @param {String?} enc - Encoding, can be `'hex'` or null.
     * @returns {Buffer|String}
     */
    toRaw() {
      const b = this.getSize();
      return this.toWriter(c.write(b)).render();
    }
    /**
     * Inject properties from buffer reader.
     * @private
     * @param {BufferReader} br
     */
    fromReader(b) {
      this.readHead(b), this.totalTX = b.readU32();
      const h = b.readVarint();
      for (let o = 0; o < h; o++)
        this.hashes.push(b.readHash());
      return this.flags = b.readVarBytes(), this;
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     */
    fromRaw(b) {
      return this.fromReader(c.read(b));
    }
    /**
     * Instantiate a merkleblock from a buffer reader.
     * @param {BufferReader} br
     * @returns {MerkleBlock}
     */
    static fromReader(b) {
      return new this().fromReader(b);
    }
    /**
     * Instantiate a merkleblock from a serialized data.
     * @param {Buffer} data
     * @param {String?} enc - Encoding, can be `'hex'` or null.
     * @returns {MerkleBlock}
     */
    static fromRaw(b, h) {
      return typeof b == "string" && (b = k.from(b, h)), new this().fromRaw(b);
    }
    /**
     * Convert the block to an object suitable
     * for JSON serialization.
     * @returns {Object}
     */
    toJSON() {
      return this.getJSON();
    }
    /**
     * Convert the block to an object suitable
     * for JSON serialization. Note that the hashes
     * will be reversed to abide by bitcoind's legacy
     * of little-endian uint256s.
     * @param {Network} network
     * @param {CoinView} view
     * @param {Number} height
     * @returns {Object}
     */
    getJSON(b, h, o) {
      return {
        hash: this.rhash(),
        height: o,
        version: this.version,
        prevBlock: g.revHex(this.prevBlock),
        merkleRoot: g.revHex(this.merkleRoot),
        time: this.time,
        bits: this.bits,
        nonce: this.nonce,
        totalTX: this.totalTX,
        hashes: this.hashes.map((S) => g.revHex(S)),
        flags: this.flags.toString("hex")
      };
    }
    /**
     * Inject properties from json object.
     * @private
     * @param {Object} json
     */
    fromJSON(b) {
      e(b, "MerkleBlock data is required."), e(Array.isArray(b.hashes)), e(typeof b.flags == "string"), e(b.totalTX >>> 0 === b.totalTX), this.parseJSON(b);
      for (const h of b.hashes)
        this.hashes.push(g.fromRev(h));
      return this.flags = k.from(b.flags, "hex"), this.totalTX = b.totalTX, this;
    }
    /**
     * Instantiate a merkle block from a jsonified block object.
     * @param {Object} json - The jsonified block object.
     * @returns {MerkleBlock}
     */
    static fromJSON(b) {
      return new this().fromJSON(b);
    }
    /**
     * Create a merkleblock from a {@link Block} object, passing
     * it through a filter first. This will build the partial
     * merkle tree.
     * @param {Block} block
     * @param {Bloom} filter
     * @returns {MerkleBlock}
     */
    static fromBlock(b, h) {
      const o = [];
      for (const S of b.txs)
        o.push(S.isWatched(h) ? 1 : 0);
      return this.fromMatches(b, o);
    }
    /**
     * Create a merkleblock from an array of txids.
     * This will build the partial merkle tree.
     * @param {Block} block
     * @param {Hash[]} hashes
     * @returns {MerkleBlock}
     */
    static fromHashes(b, h) {
      const o = new w();
      for (const H of h)
        o.add(H);
      const S = [];
      for (const H of b.txs) {
        const j = H.hash();
        S.push(o.has(j) ? 1 : 0);
      }
      return this.fromMatches(b, S);
    }
    /**
     * Create a merkleblock from an array of matches.
     * This will build the partial merkle tree.
     * @param {Block} block
     * @param {Number[]} matches
     * @returns {MerkleBlock}
     */
    static fromMatches(b, h) {
      const o = [], S = [], H = [], j = [], J = b.txs.length;
      let N = 0;
      const z = (R) => J + (1 << R) - 1 >>> R, A = (R, V, fe) => {
        if (R === 0)
          return fe[V];
        const ue = A(R - 1, V * 2, fe);
        let ae;
        return V * 2 + 1 < z(R - 1) ? ae = A(R - 1, V * 2 + 1, fe) : ae = ue, f.root(ue, ae);
      }, q = (R, V, fe, ue) => {
        let ae = 0;
        for (let D = V << R; D < V + 1 << R && D < J; D++)
          ae |= ue[D];
        if (H.push(ae), R === 0 || !ae) {
          j.push(A(R, V, fe));
          return;
        }
        q(R - 1, V * 2, fe, ue), V * 2 + 1 < z(R - 1) && q(R - 1, V * 2 + 1, fe, ue);
      };
      for (let R = 0; R < b.txs.length; R++) {
        const V = b.txs[R];
        h[R] && o.push(V), S.push(V.hash());
      }
      for (; z(N) > 1; )
        N += 1;
      q(N, 0, S, h);
      const _ = k.allocUnsafe((H.length + 7) / 8 | 0);
      _.fill(0);
      for (let R = 0; R < H.length; R++)
        _[R / 8 | 0] |= H[R] << R % 8;
      const F = new this();
      return F._hash = b._hash, F._hhash = b._hhash, F.version = b.version, F.prevBlock = b.prevBlock, F.merkleRoot = b.merkleRoot, F.time = b.time, F.bits = b.bits, F.nonce = b.nonce, F.totalTX = J, F.hashes = j, F.flags = _, F.txs = o, F;
    }
    /**
     * Test whether an object is a MerkleBlock.
     * @param {Object} obj
     * @returns {Boolean}
     */
    static isMerkleBlock(b) {
      return b instanceof m;
    }
    /**
     * Convert the block to a headers object.
     * @returns {Headers}
     */
    toHeaders() {
      return a.fromBlock(this);
    }
  }
  class E {
    constructor(b, h, o, S) {
      this.root = b || n.ZERO_HASH, this.matches = h || [], this.indexes = o || [], this.map = S || new d();
    }
  }
  return Eu = m, Eu;
}
var Iu, q4;
function vl() {
  if (q4) return Iu;
  q4 = 1;
  const e = $e(), c = At(), { BufferSet: d } = Dr(), w = hr(), g = r7(), f = Ht(), n = is(), u = xn(), a = yl(), s = ns(), i = yr(), p = Zt(), { encoding: m } = c, { inspectSymbol: E } = Kt();
  class v extends n {
    /**
     * Create a block.
     * @constructor
     * @param {Object} options
     */
    constructor(o) {
      super(), this.txs = [], this._raw = null, this._size = -1, o && this.fromOptions(o);
    }
    /**
     * Inject properties from options object.
     * @private
     * @param {Object} options
     */
    fromOptions(o) {
      if (this.parseOptions(o), o.txs) {
        e(Array.isArray(o.txs));
        for (const S of o.txs)
          e(S instanceof u), this.txs.push(S);
      }
      return this;
    }
    /**
     * Instantiate block from options.
     * @param {Object} options
     * @returns {Block}
     */
    static fromOptions(o) {
      return new this().fromOptions(o);
    }
    /**
     * Clear any cached values.
     * @param {Boolean?} all - Clear transactions.
     */
    refresh(o) {
      if (this._refresh(), this._raw = null, this._size = -1, !o)
        return this;
      for (const S of this.txs)
        S.refresh();
      return this;
    }
    /**
     * Serialize the block.
     * @returns {Buffer}
     */
    toRaw() {
      return this.frame().data;
    }
    /**
     * Check if block has been serialized.
     * @returns {Buffer}
     */
    hasRaw() {
      return !!this._raw;
    }
    /**
     * Serialize the block.
     * @returns {Buffer}
     */
    toNormal() {
      return this.toRaw();
    }
    /**
     * Serialize the block.
     * @param {BufferWriter} bw
     */
    toWriter(o) {
      if (this.mutable)
        return this.writeNormal(o);
      const S = this.frame();
      return o.writeBytes(S.data), o;
    }
    /**
     * Serialize the block.
     * @param {BufferWriter} bw
     */
    toNormalWriter(o) {
      return this.toWriter(o);
    }
    /**
     * Get the raw block serialization.
     * @private
     * @returns {RawBlock}
     */
    frame() {
      if (this.mutable)
        return e(!this._raw), this.frameNormal();
      if (this._raw) {
        e(this._size >= 0);
        const S = new b(this._size);
        return S.data = this._raw, S;
      }
      const o = this.frameNormal();
      return this._raw = o.data, this._size = o.size, o;
    }
    /**
     * Calculate real block size.
     * @returns {Object} Contains `size`
     */
    getSize() {
      return this.mutable ? this.getNormalSizes().size : this.frame().size;
    }
    /**
     * Test the block's transaction vector against a hash.
     * @param {Hash} hash
     * @returns {Boolean}
     */
    hasTX(o) {
      return this.indexOf(o) !== -1;
    }
    /**
     * Find the index of a transaction in the block.
     * @param {Hash} hash
     * @returns {Number} index (-1 if not present).
     */
    indexOf(o) {
      for (let S = 0; S < this.txs.length; S++)
        if (this.txs[S].hash().equals(o))
          return S;
      return -1;
    }
    /**
     * Calculate merkle root. Returns null
     * if merkle tree has been malleated.
     * @param {String?} enc - Encoding, can be `'hex'` or null.
     * @returns {Hash|null}
     */
    createMerkleRoot(o) {
      const S = [];
      for (const J of this.txs)
        S.push(J.hash());
      const [H, j] = g.createRoot(w, S);
      return j ? null : o === "hex" ? H.toString("hex") : H;
    }
    /**
     * Retrieve the merkle root from the block header.
     * @param {String?} enc
     * @returns {Hash}
     */
    getMerkleRoot(o) {
      return o === "hex" ? this.merkleRoot.toString("hex") : this.merkleRoot;
    }
    /**
     * Do non-contextual verification on the block. Including checking the block
     * size, the coinbase and the merkle root. This is consensus-critical.
     * @returns {Boolean}
     */
    verifyBody() {
      const [o] = this.checkBody();
      return o;
    }
    /**
     * Do non-contextual verification on the block. Including checking the block
     * size, the coinbase and the merkle root. This is consensus-critical.
     * @param {Boolean?} skipSigops
     * @returns {Array} [valid, reason, score]
     */
    checkBody(o) {
      if (this.txs.length === 0 || this.txs.length > f.MAX_FORK_BLOCK_SIZE / 10 || this.getSize() > f.MAX_FORK_BLOCK_SIZE)
        return [!1, "bad-blk-length", 100];
      if (this.txs.length === 0 || !this.txs[0].isCoinbase())
        return [!1, "bad-cb-missing", 100];
      const S = this.createMerkleRoot();
      if (!S)
        return [!1, "bad-txns-duplicate", 100];
      if (!this.merkleRoot.equals(S))
        return [!1, "bad-txnmrklroot", 100];
      const H = this.getSize();
      let j = 0;
      for (let J = 0; J < this.txs.length; J++) {
        const N = this.txs[J];
        if (J > 0 && N.isCoinbase())
          return [!1, "bad-cb-multiple", 100];
        const [z, A, q] = N.checkSanity();
        if (!z)
          return [z, A, q];
        if (j += N.getLegacySigops(), !o && j > f.maxBlockSigops(H))
          return [!1, "bad-blk-sigops", 100];
      }
      return [!0, "valid", 0];
    }
    /**
     * Retrieve the coinbase height from the coinbase input script.
     * @returns {Number} height (-1 if not present).
     */
    getCoinbaseHeight() {
      if (this.version < 2 || this.txs.length === 0)
        return -1;
      const o = this.txs[0];
      return o.inputs.length === 0 ? -1 : o.inputs[0].script.getCoinbaseHeight();
    }
    /**
     * Get the "claimed" reward by the coinbase.
     * @returns {Amount} claimed
     */
    getClaimed() {
      return e(this.txs.length > 0), e(this.txs[0].isCoinbase()), this.txs[0].getOutputValue();
    }
    /**
     * Get all unique outpoint hashes in the
     * block. Coinbases are ignored.
     * @returns {Hash[]} Outpoint hashes.
     */
    getPrevout() {
      const o = new d();
      for (let S = 1; S < this.txs.length; S++) {
        const H = this.txs[S];
        for (const j of H.inputs)
          o.add(j.prevout.hash);
      }
      return o.toArray();
    }
    /**
     * Inspect the block and return a more
     * user-friendly representation of the data.
     * @returns {Object}
     */
    [E]() {
      return this.format();
    }
    /**
     * Inspect the block and return a more
     * user-friendly representation of the data.
     * @param {CoinView} view
     * @param {Number} height
     * @returns {Object}
     */
    format(o, S) {
      return {
        hash: this.rhash(),
        height: S ?? -1,
        size: this.getSize(),
        date: p.date(this.time),
        version: this.version.toString(16),
        prevBlock: p.revHex(this.prevBlock),
        merkleRoot: p.revHex(this.merkleRoot),
        time: this.time,
        bits: this.bits,
        nonce: this.nonce,
        txs: this.txs.map((H, j) => H.format(o, null, j))
      };
    }
    /**
     * Convert the block to an object suitable
     * for JSON serialization.
     * @returns {Object}
     */
    toJSON() {
      return this.getJSON();
    }
    /**
     * Convert the block to an object suitable
     * for JSON serialization. Note that the hashes
     * will be reversed to abide by bitcoind's legacy
     * of little-endian uint256s.
     * @param {Network} network
     * @param {CoinView} view
     * @param {Number} height
     * @param {Number} depth
     * @returns {Object}
     */
    getJSON(o, S, H, j) {
      return o = i.get(o), {
        hash: this.rhash(),
        height: H,
        depth: j,
        version: this.version,
        prevBlock: p.revHex(this.prevBlock),
        merkleRoot: p.revHex(this.merkleRoot),
        time: this.time,
        bits: this.bits,
        nonce: this.nonce,
        txs: this.txs.map((J, N) => J.getJSON(o, S, null, N))
      };
    }
    /**
     * Inject properties from json object.
     * @private
     * @param {Object} json
     */
    fromJSON(o) {
      e(o, "Block data is required."), e(Array.isArray(o.txs)), this.parseJSON(o);
      for (const S of o.txs)
        this.txs.push(u.fromJSON(S));
      return this;
    }
    /**
     * Instantiate a block from a jsonified block object.
     * @param {Object} json - The jsonified block object.
     * @returns {Block}
     */
    static fromJSON(o) {
      return new this().fromJSON(o);
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     */
    fromReader(o) {
      o.start(), this.readHead(o);
      const S = o.readVarint();
      for (let H = 0; H < S; H++) {
        const j = u.fromReader(o, !0);
        this.txs.push(j);
      }
      return this.mutable || (this._raw = o.endData(), this._size = this._raw.length), this;
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     */
    fromRaw(o) {
      return this.fromReader(c.read(o));
    }
    /**
     * Instantiate a block from a serialized Buffer.
     * @param {Buffer} data
     * @param {String?} enc - Encoding, can be `'hex'` or null.
     * @returns {Block}
     */
    static fromReader(o) {
      return new this().fromReader(o);
    }
    /**
     * Instantiate a block from a serialized Buffer.
     * @param {Buffer} data
     * @param {String?} enc - Encoding, can be `'hex'` or null.
     * @returns {Block}
     */
    static fromRaw(o, S) {
      return typeof o == "string" && (o = k.from(o, S)), new this().fromRaw(o);
    }
    /**
     * Convert the Block to a MerkleBlock.
     * @param {Bloom} filter - Bloom filter for transactions
     * to match. The merkle block will contain only the
     * matched transactions.
     * @returns {MerkleBlock}
     */
    toMerkle(o) {
      return a.fromBlock(this, o);
    }
    /**
     * Serialze block data.
     * @private
     * @param {BufferWriter?} writer
     * @returns {Buffer}
     */
    writeNormal(o) {
      this.writeHead(o), o.writeVarint(this.txs.length);
      for (const S of this.txs)
        S.toWriter(o);
      return o;
    }
    /**
     * Serialze block data.
     * @private
     * @param {BufferWriter?} writer
     * @returns {Buffer}
     */
    frameNormal() {
      const o = this.getNormalSizes(), S = c.write(o.size);
      return this.writeNormal(S), o.data = S.render(), o;
    }
    /**
     * Convert the block to a headers object.
     * @returns {Headers}
     */
    toHeaders() {
      return s.fromBlock(this);
    }
    /**
     * Get real block size.
     * @returns {RawBlock}
     */
    getNormalSizes() {
      let o = 0;
      o += 80, o += m.sizeVarint(this.txs.length);
      for (const S of this.txs)
        o += S.getSize();
      return new b(o, 0);
    }
    /**
     * Test whether an object is a Block.
     * @param {Object} obj
     * @returns {Boolean}
     */
    static isBlock(o) {
      return o instanceof v;
    }
  }
  class b {
    constructor(o) {
      this.data = null, this.size = o;
    }
  }
  return Iu = v, Iu;
}
var Au, z4;
function Sl() {
  if (z4) return Au;
  z4 = 1;
  const e = $e(), { base58: c } = cn(), d = At(), w = Hi(), g = hr(), f = yr(), n = Pr(), u = Lr(), a = gi(), s = Rr(), { encoding: i } = d, { inspectSymbol: p } = Kt(), m = k.alloc(33, 0);
  class E {
    /**
     * Create a key ring.
     * @constructor
     * @param {Object} options
     */
    constructor(h) {
      this.nested = !1, this.publicKey = m, this.privateKey = null, this.script = null, this._keyHash = null, this._keyAddress = null, this._scriptHash160 = null, this._scriptAddress = null, h && this.fromOptions(h);
    }
    /**
     * Inject properties from options object.
     * @private
     * @param {Object} options
     */
    fromOptions(h) {
      let o = v(h);
      if (k.isBuffer(o))
        return this.fromKey(o);
      o = v(h.key), h.publicKey && (o = v(h.publicKey)), h.privateKey && (o = v(h.privateKey));
      const S = h.script, H = h.compressed;
      return S ? this.fromScript(o, S, H) : this.fromKey(o, H);
    }
    /**
     * Instantiate key ring from options.
     * @param {Object} options
     * @returns {KeyRing}
     */
    static fromOptions(h) {
      return new this().fromOptions(h);
    }
    /**
     * Clear cached key/script hashes.
     */
    refresh() {
      this._keyHash = null, this._keyAddress = null, this._scriptHash160 = null, this._scriptAddress = null;
    }
    /**
     * Inject data from private key.
     * @private
     * @param {Buffer} key
     * @param {Boolean?} compress
     */
    fromPrivate(h, o) {
      return e(k.isBuffer(h), "Private key must be a buffer."), e(s.privateKeyVerify(h), "Not a valid private key."), this.privateKey = h, this.publicKey = s.publicKeyCreate(h, o !== !1), this;
    }
    /**
     * Instantiate keyring from a private key.
     * @param {Buffer} key
     * @param {Boolean?} compress
     * @returns {KeyRing}
     */
    static fromPrivate(h, o) {
      return new this().fromPrivate(h, o);
    }
    /**
     * Inject data from public key.
     * @private
     * @param {Buffer} key
     */
    fromPublic(h) {
      return e(k.isBuffer(h), "Public key must be a buffer."), e(s.publicKeyVerify(h), "Not a valid public key."), this.publicKey = h, this;
    }
    /**
     * Generate a keyring.
     * @private
     * @param {Boolean?} compress
     * @returns {KeyRing}
     */
    generate(h) {
      const o = s.privateKeyGenerate();
      return this.fromKey(o, h);
    }
    /**
     * Generate a keyring.
     * @param {Boolean?} compress
     * @returns {KeyRing}
     */
    static generate(h) {
      return new this().generate(h);
    }
    /**
     * Instantiate keyring from a public key.
     * @param {Buffer} publicKey
     * @returns {KeyRing}
     */
    static fromPublic(h) {
      return new this().fromPublic(h);
    }
    /**
     * Inject data from public key.
     * @private
     * @param {Buffer} privateKey
     * @param {Boolean?} compress
     */
    fromKey(h, o) {
      return e(k.isBuffer(h), "Key must be a buffer."), h.length === 32 ? this.fromPrivate(h, o !== !1) : this.fromPublic(h);
    }
    /**
     * Instantiate keyring from a public key.
     * @param {Buffer} publicKey
     * @param {Boolean?} compress
     * @returns {KeyRing}
     */
    static fromKey(h, o) {
      return new this().fromKey(h, o);
    }
    /**
     * Inject data from script.
     * @private
     * @param {Buffer} key
     * @param {Script} script
     * @param {Boolean?} compress
     */
    fromScript(h, o, S) {
      return e(o instanceof n, "Non-script passed into KeyRing."), this.fromKey(h, S), this.script = o, this;
    }
    /**
     * Instantiate keyring from script.
     * @param {Buffer} key
     * @param {Script} script
     * @param {Boolean?} compress
     * @returns {KeyRing}
     */
    static fromScript(h, o, S) {
      return new this().fromScript(h, o, S);
    }
    /**
     * Get ith public key from multisig script.
     * @private
     * @param {Script} script
     * @param {Number} i
     * @returns {KeyRing}
     */
    fromMultisigScript(h, o) {
      e(h instanceof n, "Non-script passed."), e(h.isMultisig(), "Script must be multisig");
      const S = h.getSmall(-2);
      return e(o >= 1 && o <= S, "Requested `i`th key, `n` available"), this.fromKey(h.code[o].toData()), this;
    }
    /**
     * Instantiate keyring from ith key in multisig script.
     * @param {Script} script
     * @param {Number} i
     * @returns {KeyRing}
     */
    static fromMultisigScript(h, o) {
      return new this().fromMultisigScript(h, o);
    }
    /**
     * Calculate WIF serialization size.
     * @returns {Number}
     */
    getSecretSize() {
      let h = 0;
      return h += 1, h += this.privateKey.length, this.publicKey.length === 33 && (h += 1), h += 4, h;
    }
    /**
     * Convert key to a CBitcoinSecret.
     * @param {(Network|NetworkType)?} network
     * @returns {Base58String}
     */
    toSecret(h) {
      const o = this.getSecretSize(), S = d.write(o);
      return e(this.privateKey, "Cannot serialize without private key."), h = f.get(h), S.writeU8(h.keyPrefix.privkey), S.writeBytes(this.privateKey), this.publicKey.length === 33 && S.writeU8(1), S.writeChecksum(g.digest), c.encode(S.render());
    }
    /**
     * Inject properties from serialized CBitcoinSecret.
     * @private
     * @param {Base58String} secret
     * @param {(Network|NetworkType)?} network
     */
    fromSecret(h, o) {
      const S = d.read(c.decode(h), !0), H = S.readU8();
      f.fromWIF(H, o);
      const j = S.readBytes(32);
      let J = !1;
      return S.left() > 4 && (e(S.readU8() === 1, "Bad compression flag."), J = !0), S.verifyChecksum(g.digest), this.fromPrivate(j, J);
    }
    /**
     * Instantiate a keyring from a serialized CBitcoinSecret.
     * @param {Base58String} secret
     * @param {(Network|NetworkType)?} network
     * @returns {KeyRing}
     */
    static fromSecret(h, o) {
      return new this().fromSecret(h, o);
    }
    /**
     * Get private key.
     * @param {String?} enc - Can be `"hex"`, `"base58"`, or `null`.
     * @returns {Buffer} Private key.
     */
    getPrivateKey(h, o) {
      return this.privateKey ? h === "base58" ? this.toSecret(o) : h === "hex" ? this.privateKey.toString("hex") : this.privateKey : null;
    }
    /**
     * Get public key.
     * @param {String?} enc - `"hex"` or `null`.
     * @returns {Buffer}
     */
    getPublicKey(h) {
      return h === "base58" ? c.encode(this.publicKey) : h === "hex" ? this.publicKey.toString("hex") : this.publicKey;
    }
    /**
     * Get redeem script.
     * @returns {Script}
     */
    getScript() {
      return this.script;
    }
    /**
     * Get scripthash.
     * @param {String?} enc - `"hex"` or `null`.
     * @returns {Buffer}
     */
    getScriptHash(h) {
      return this.getScriptHash160(h);
    }
    /**
     * Get ripemd160 scripthash.
     * @param {String?} enc - `"hex"` or `null`.
     * @returns {Buffer}
     */
    getScriptHash160(h) {
      return this.script ? (this._scriptHash160 || (this._scriptHash160 = this.script.hash160()), h === "hex" ? this._scriptHash160.toString("hex") : this._scriptHash160) : null;
    }
    /**
     * Get scripthash address.
     * @param {String?} enc - `"base58"` or `null`.
     * @returns {Address|AddressString}
     */
    getScriptAddress(h, o) {
      if (!this.script)
        return null;
      if (!this._scriptAddress) {
        const S = this.getScriptHash160(), H = u.fromScripthash(S);
        this._scriptAddress = H;
      }
      return h === "base58" ? this._scriptAddress.toBase58(o) : h === "string" ? this._scriptAddress.toString(o) : this._scriptAddress;
    }
    /**
     * Get public key hash.
     * @param {String?} enc - `"hex"` or `null`.
     * @returns {Buffer}
     */
    getKeyHash(h) {
      return this._keyHash || (this._keyHash = w.digest(this.publicKey)), h === "hex" ? this._keyHash.toString("hex") : this._keyHash;
    }
    /**
     * Get pubkeyhash address.
     * @param {String?} enc - `"base58"` or `null`.
     * @returns {Address|AddressString}
     */
    getKeyAddress(h, o) {
      if (!this._keyAddress) {
        const S = this.getKeyHash(), H = u.fromPubkeyhash(S);
        this._keyAddress = H;
      }
      return h === "base58" ? this._keyAddress.toBase58(o) : h === "string" ? this._keyAddress.toString(o) : this._keyAddress;
    }
    /**
     * Get hash.
     * @param {String?} enc - `"hex"` or `null`.
     * @returns {Buffer}
     */
    getHash(h) {
      return this.script ? this.getScriptHash(h) : this.getKeyHash(h);
    }
    /**
     * Get base58 address.
     * @param {String?} enc - `"base58"` or `null`.
     * @returns {Address|AddressString}
     */
    getAddress(h, o) {
      return this.script ? this.getScriptAddress(h, o) : this.getKeyAddress(h, o);
    }
    /**
     * Test an address hash against hash.
     * @param {Buffer} hash
     * @returns {Boolean}
     */
    ownHash(h) {
      return h ? !!(h.equals(this.getKeyHash()) || this.script && h.equals(this.getScriptHash())) : !1;
    }
    /**
     * Check whether transaction output belongs to this address.
     * @param {TX|Output} tx - Transaction or Output.
     * @param {Number?} index - Output index.
     * @returns {Boolean}
     */
    ownOutput(h, o) {
      let S;
      return h instanceof a ? S = h : (S = h.outputs[o], e(S, "Output does not exist.")), this.ownHash(S.getHash());
    }
    /**
     * Test a hash against script hashes to
     * find the correct redeem script, if any.
     * @param {Buffer} hash
     * @returns {Script|null}
     */
    getRedeem(h) {
      return this.script && h.equals(this.getScriptHash160()) ? this.script : null;
    }
    /**
     * Sign a message.
     * @param {Buffer} msg
     * @returns {Buffer} Signature in DER format.
     */
    sign(h) {
      return e(this.privateKey, "Cannot sign without private key."), s.signDER(h, this.privateKey);
    }
    /**
     * Sign a message.
     * @param {Buffer} msg
     * @returns {Buffer} Signature in Schnorr format.
     */
    signSchnorr(h) {
      return e(this.privateKey, "Cannot sign without private key."), s.schnorrSign(h, this.privateKey);
    }
    /**
     * Verify a message.
     * @param {Buffer} msg
     * @param {Buffer} sig - Signature in DER format.
     * @returns {Boolean}
     */
    verify(h, o) {
      return s.verifyDER(h, o, this.publicKey);
    }
    /**
     * Verify a message.
     * @param {Buffer} msg
     * @param {Buffer} sig - Signature in Schnorr format.
     * @returns {Boolean}
     */
    verifySchnorr(h, o) {
      return s.schnorrVerify(h, o, this.publicKey);
    }
    /**
     * Get witness program version.
     * @returns {Number}
     */
    getVersion() {
      return -1;
    }
    /**
     * Get address type.
     * @returns {ScriptType}
     */
    getType() {
      return this.script ? u.types.SCRIPTHASH : u.types.PUBKEYHASH;
    }
    /**
     * Inspect keyring.
     * @returns {Object}
     */
    [p]() {
      return this.toJSON();
    }
    /**
     * Convert an KeyRing to a more json-friendly object.
     * @returns {Object}
     */
    toJSON(h) {
      return {
        publicKey: this.publicKey.toString("hex"),
        script: this.script ? this.script.toRaw().toString("hex") : null,
        type: u.typesByVal[this.getType()].toLowerCase(),
        address: this.getAddress("string", h)
      };
    }
    /**
     * Inject properties from json object.
     * @private
     * @param {Object} json
     */
    fromJSON(h) {
      return e(h), e(typeof h.publicKey == "string"), e(!h.script || typeof h.script == "string"), this.publicKey = k.from(h.publicKey, "hex"), h.script && (this.script = k.from(h.script, "hex")), this;
    }
    /**
     * Instantiate an KeyRing from a jsonified transaction object.
     * @param {Object} json - The jsonified transaction object.
     * @returns {KeyRing}
     */
    static fromJSON(h) {
      return new this().fromJSON(h);
    }
    /**
     * Calculate serialization size.
     * @returns {Number}
     */
    getSize() {
      let h = 0;
      return h += 1, this.privateKey ? (h += i.sizeVarBytes(this.privateKey), h += 1) : h += i.sizeVarBytes(this.publicKey), h += this.script ? this.script.getVarSize() : 1, h;
    }
    /**
     * Write the keyring to a buffer writer.
     * @param {BufferWriter} bw
     */
    toWriter(h) {
      return h.writeU8(0), this.privateKey ? (h.writeVarBytes(this.privateKey), h.writeU8(this.publicKey.length === 33 ? 1 : 0)) : h.writeVarBytes(this.publicKey), this.script ? h.writeVarBytes(this.script.toRaw()) : h.writeVarint(0), h;
    }
    /**
     * Serialize the keyring.
     * @returns {Buffer}
     */
    toRaw() {
      const h = this.getSize();
      return this.toWriter(d.write(h)).render();
    }
    /**
     * Inject properties from buffer reader.
     * @private
     * @param {BufferReader} br
     */
    fromReader(h) {
      h.readU8();
      const o = h.readVarBytes();
      if (o.length === 32) {
        const H = h.readU8() === 1;
        this.privateKey = o, this.publicKey = s.publicKeyCreate(o, H);
      } else
        this.publicKey = o, e(s.publicKeyVerify(o), "Invalid public key.");
      const S = h.readVarBytes();
      return S.length > 0 && (this.script = n.fromRaw(S)), this;
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     */
    fromRaw(h) {
      return this.fromReader(d.read(h));
    }
    /**
     * Instantiate a keyring from buffer reader.
     * @param {BufferReader} br
     * @returns {KeyRing}
     */
    static fromReader(h) {
      return new this().fromReader(h);
    }
    /**
     * Instantiate a keyring from serialized data.
     * @param {Buffer} data
     * @returns {KeyRing}
     */
    static fromRaw(h) {
      return new this().fromRaw(h);
    }
    /**
     * Test whether an object is a KeyRing.
     * @param {Object} obj
     * @returns {Boolean}
     */
    static isKeyRing(h) {
      return h instanceof E;
    }
  }
  function v(b) {
    return b && (b.privateKey ? b.privateKey : b.publicKey ? b.publicKey : b);
  }
  return Au = E, Au;
}
var Ou, T4;
function px() {
  if (T4) return Ou;
  T4 = 1;
  const e = At(), c = is(), d = vl(), w = ns(), g = Pr(), f = k.alloc(0);
  class n extends c {
    /**
     * Create a mem block.
     * @constructor
     */
    constructor() {
      super(), this._raw = f;
    }
    /**
     * Test whether the block is a memblock.
     * @returns {Boolean}
     */
    isMemory() {
      return !0;
    }
    /**
     * Serialize the block headers.
     * @returns {Buffer}
     */
    toHead() {
      return this._raw.slice(0, 80);
    }
    /**
     * Get the full block size.
     * @returns {Number}
     */
    getSize() {
      return this._raw.length;
    }
    /**
     * Verify the block.
     * @returns {Boolean}
     */
    verifyBody() {
      return !0;
    }
    /**
     * Retrieve the coinbase height
     * from the coinbase input script.
     * @returns {Number} height (-1 if not present).
     */
    getCoinbaseHeight() {
      if (this.version < 2)
        return -1;
      try {
        return this.parseCoinbaseHeight();
      } catch {
        return -1;
      }
    }
    /**
     * Parse the coinbase height
     * from the coinbase input script.
     * @private
     * @returns {Number} height (-1 if not present).
     */
    parseCoinbaseHeight() {
      const a = e.read(this._raw, !0);
      if (a.seek(80), a.readVarint() === 0)
        return -1;
      a.seek(4);
      let i = a.readVarint();
      if (i === 0 && a.readU8() !== 0 && (i = a.readVarint()), i === 0)
        return -1;
      a.seek(36);
      const p = a.readVarBytes();
      return g.getCoinbaseHeight(p);
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     */
    fromRaw(a) {
      const s = e.read(a, !0);
      return this.readHead(s), this._raw = s.data, this;
    }
    /**
     * Insantiate a memblock from serialized data.
     * @param {Buffer} data
     * @returns {MemBlock}
     */
    static fromRaw(a) {
      return new this().fromRaw(a);
    }
    /**
     * Return serialized block data.
     * @returns {Buffer}
     */
    toRaw() {
      return this._raw;
    }
    /**
     * Parse the serialized block data
     * and create an actual {@link Block}.
     * @returns {Block}
     * @throws Parse error
     */
    toBlock() {
      const a = d.fromRaw(this._raw);
      return a._hash = this._hash, a._hhash = this._hhash, a;
    }
    /**
     * Convert the block to a headers object.
     * @returns {Headers}
     */
    toHeaders() {
      return w.fromBlock(this);
    }
    /**
     * Test whether an object is a MemBlock.
     * @param {Object} obj
     * @returns {Boolean}
     */
    static isMemBlock(a) {
      return a instanceof n;
    }
  }
  return Ou = n, Ou;
}
var ys = { exports: {} }, C4;
function El() {
  return C4 || (C4 = 1, function(e, c) {
    const d = $e(), { encoding: w } = At(), { BufferMap: g } = Dr(), f = Pr(), n = xn(), u = vo(), a = gi(), s = rs(), i = xi(), p = mo(), m = Lr(), E = Ht(), v = mi(), b = bi(), h = lo(), o = Zt(), { inspectSymbol: S } = Kt();
    class H extends n {
      /**
       * Create a mutable transaction.
       * @alias module:primitives.MTX
       * @constructor
       * @param {Object} options
       */
      constructor(R) {
        super(), this.mutable = !0, this.changeIndex = -1, this.view = new p(), R && this.fromOptions(R);
      }
      /**
       * Inject properties from options object.
       * @private
       * @param {Object} options
       */
      fromOptions(R) {
        if (R.version != null && (d(
          R.version >>> 0 === R.version,
          "Version must a be uint32."
        ), this.version = R.version), R.inputs) {
          d(Array.isArray(R.inputs), "Inputs must be an array.");
          for (const V of R.inputs)
            this.addInput(V);
        }
        if (R.outputs) {
          d(Array.isArray(R.outputs), "Outputs must be an array.");
          for (const V of R.outputs)
            this.addOutput(V);
        }
        return R.locktime != null && (d(
          R.locktime >>> 0 === R.locktime,
          "Locktime must be a uint32."
        ), this.locktime = R.locktime), R.changeIndex != null && (R.changeIndex !== -1 ? (d(
          R.changeIndex >>> 0 === R.changeIndex,
          "Change index must be a uint32."
        ), this.changeIndex = R.changeIndex) : this.changeIndex = -1), this;
      }
      /**
       * Instantiate MTX from options.
       * @param {Object} options
       * @returns {MTX}
       */
      static fromOptions(R) {
        return new this().fromOptions(R);
      }
      /**
       * Clone the transaction. Note that
       * this will not carry over the view.
       * @returns {MTX}
       */
      clone() {
        const R = new this.constructor();
        return R.inject(this), R.changeIndex = this.changeIndex, R;
      }
      /**
       * Add an input to the transaction.
       * @param {Input|Object} options
       * @returns {Input}
       *
       * @example
       * mtx.addInput({ prevout: { hash: ... }, script: ... });
       * mtx.addInput(new Input());
       */
      addInput(R) {
        const V = u.fromOptions(R);
        return this.inputs.push(V), V;
      }
      /**
       * Add an outpoint as an input.
       * @param {Outpoint|Object} outpoint
       * @returns {Input}
       *
       * @example
       * mtx.addOutpoint({ hash: ..., index: 0 });
       * mtx.addOutpoint(new Outpoint(hash, index));
       */
      addOutpoint(R) {
        const V = i.fromOptions(R), fe = u.fromOutpoint(V);
        return this.inputs.push(fe), fe;
      }
      /**
       * Add a coin as an input. Note that this will
       * add the coin to the internal coin viewpoint.
       * @param {Coin} coin
       * @returns {Input}
       *
       * @example
       * mtx.addCoin(Coin.fromTX(tx, 0, -1));
       */
      addCoin(R) {
        d(R instanceof s, "Cannot add non-coin.");
        const V = u.fromCoin(R);
        return this.inputs.push(V), this.view.addCoin(R), V;
      }
      /**
       * Add a transaction as an input. Note that
       * this will add the coin to the internal
       * coin viewpoint.
       * @param {TX} tx
       * @param {Number} index
       * @param {Number?} height
       * @returns {Input}
       *
       * @example
       * mtx.addTX(tx, 0);
       */
      addTX(R, V, fe) {
        d(R instanceof n, "Cannot add non-transaction."), fe == null && (fe = -1);
        const ue = u.fromTX(R, V);
        return this.inputs.push(ue), this.view.addIndex(R, V, fe), ue;
      }
      /**
       * Add an output.
       * @param {Address|Script|Output|Object} script - Script or output options.
       * @param {Amount?} value
       * @returns {Output}
       *
       * @example
       * mtx.addOutput(new Output());
       * mtx.addOutput({ address: ..., value: 100000 });
       * mtx.addOutput(address, 100000);
       * mtx.addOutput(script, 100000);
       */
      addOutput(R, V) {
        let fe;
        return V != null ? fe = a.fromScript(R, V) : fe = a.fromOptions(R), this.outputs.push(fe), fe;
      }
      /**
       * Verify all transaction inputs.
       * @param {VerifyFlags} [flags=STANDARD_VERIFY_FLAGS]
       * @returns {Boolean} Whether the inputs are valid.
       * @throws {ScriptError} on invalid inputs
       */
      check(R) {
        return super.check(this.view, R);
      }
      /**
       * Verify the transaction inputs on the worker pool
       * (if workers are enabled).
       * @param {VerifyFlags?} [flags=STANDARD_VERIFY_FLAGS]
       * @param {WorkerPool?} pool
       * @returns {Promise}
       */
      checkAsync(R, V) {
        return super.checkAsync(this.view, R, V);
      }
      /**
       * Verify all transaction inputs.
       * @param {VerifyFlags} [flags=STANDARD_VERIFY_FLAGS]
       * @returns {Boolean} Whether the inputs are valid.
       */
      verify(R) {
        try {
          this.check(R);
        } catch (V) {
          if (V.type === "ScriptError")
            return !1;
          throw V;
        }
        return !0;
      }
      /**
       * Verify the transaction inputs on the worker pool
       * (if workers are enabled).
       * @param {VerifyFlags?} [flags=STANDARD_VERIFY_FLAGS]
       * @param {WorkerPool?} pool
       * @returns {Promise}
       */
      async verifyAsync(R, V) {
        try {
          await this.checkAsync(R, V);
        } catch (fe) {
          if (fe.type === "ScriptError")
            return !1;
          throw fe;
        }
        return !0;
      }
      /**
       * Calculate the fee for the transaction.
       * @returns {Amount} fee (zero if not all coins are available).
       */
      getFee() {
        return super.getFee(this.view);
      }
      /**
       * Calculate the total input value.
       * @returns {Amount} value
       */
      getInputValue() {
        return super.getInputValue(this.view);
      }
      /**
       * Get all input addresses.
       * @returns {Address[]} addresses
       */
      getInputAddresses() {
        return super.getInputAddresses(this.view);
      }
      /**
       * Get all addresses.
       * @returns {Address[]} addresses
       */
      getAddresses() {
        return super.getAddresses(this.view);
      }
      /**
       * Get all input address hashes.
       * @returns {Hash[]} hashes
       */
      getInputHashes(R) {
        return super.getInputHashes(this.view, R);
      }
      /**
       * Get all address hashes.
       * @returns {Hash[]} hashes
       */
      getHashes(R) {
        return super.getHashes(this.view, R);
      }
      /**
       * Test whether the transaction has
       * all coins available/filled.
       * @returns {Boolean}
       */
      hasCoins() {
        return super.hasCoins(this.view);
      }
      /**
       * Calculate virtual sigop count.
       * @param {VerifyFlags?} flags
       * @returns {Number} sigop count
       */
      getSigops(R) {
        return super.getSigops(this.view, R);
      }
      /**
       *  Calculate sigops count.
       *  @param {CoinView} view
       *  @param {VerifyFlags?} flags
       *  @returns {Number} sigop count
       */
      getSigopsCount(R) {
        return super.getSigopsCount(this.view, R);
      }
      /**
       * Perform contextual checks to verify input, output,
       * and fee values, as well as coinbase spend maturity
       * (coinbases can only be spent 100 blocks or more
       * after they're created). Note that this function is
       * consensus critical.
       * @param {Number} height - Height at which the
       * transaction is being spent. In the mempool this is
       * the chain height plus one at the time it entered the pool.
       * @returns {Boolean}
       */
      verifyInputs(R) {
        const [V] = this.checkInputs(R);
        return V !== -1;
      }
      /**
       * Perform contextual checks to verify input, output,
       * and fee values, as well as coinbase spend maturity
       * (coinbases can only be spent 100 blocks or more
       * after they're created). Note that this function is
       * consensus critical.
       * @param {Number} height - Height at which the
       * transaction is being spent. In the mempool this is
       * the chain height plus one at the time it entered the pool.
       * @returns {Array} [fee, reason, score]
       */
      checkInputs(R) {
        return super.checkInputs(this.view, R);
      }
      /**
       * Build input script (or witness) templates (with
       * OP_0 in place of signatures).
       * @param {Number} index - Input index.
       * @param {Coin|Output} coin
       * @param {KeyRing} ring
       * @returns {Boolean} Whether the script was able to be built.
       */
      scriptInput(R, V, fe) {
        const ue = this.inputs[R];
        if (d(ue, "Input does not exist."), d(V, "No coin passed."), ue.script.raw.length !== 0)
          return !0;
        const ae = V.script, D = ae.getScripthash();
        if (D) {
          const Z = fe.getRedeem(D);
          if (!Z)
            return !1;
          const oe = this.scriptVector(Z, fe);
          return oe ? (oe.push(Z.toRaw()), ue.script.fromStack(oe), !0) : !1;
        }
        const Q = this.scriptVector(ae, fe);
        return Q ? (ue.script.fromStack(Q), !0) : !1;
      }
      /**
       * Build script for a single vector
       * based on a previous script.
       * @param {Script} prev
       * @param {Buffer} ring
       * @return {Stack}
       */
      scriptVector(R, V) {
        const fe = R.getPubkey();
        if (fe) {
          if (!fe.equals(V.publicKey))
            return null;
          const D = new h();
          return D.pushInt(0), D;
        }
        const ue = R.getPubkeyhash();
        if (ue) {
          if (!ue.equals(V.getKeyHash()))
            return null;
          const D = new h();
          return D.pushInt(0), D.pushData(V.publicKey), D;
        }
        const [, ae] = R.getMultisig();
        if (ae !== -1) {
          if (R.indexOf(V.publicKey) === -1)
            return null;
          const D = new h();
          D.pushInt(0);
          for (let Q = 0; Q < ae; Q++)
            D.pushInt(0);
          return D;
        }
        return null;
      }
      /**
       * Sign a transaction input on the worker pool
       * (if workers are enabled).
       * @param {Number} index
       * @param {Coin|Output} coin
       * @param {KeyRing} ring
       * @param {SighashType?} type
       * @param {WorkerPool?} pool
       * @returns {Promise}
       */
      async signInputAsync(R, V, fe, ue, ae) {
        return ae ? await ae.signInput(this, R, V, fe, ue, ae) : this.signInput(R, V, fe, ue);
      }
      /**
       * Sign an input.
       * @param {Number} index - Index of input being signed.
       * @param {Coin|Output} coin
       * @param {KeyRing} ring - Private key.
       * @param {SighashType} type
       * @returns {Boolean} Whether the input was able to be signed.
       */
      signInput(R, V, fe, ue) {
        const ae = this.inputs[R], D = fe.privateKey;
        d(ae, "Input does not exist."), d(V, "No coin passed.");
        const Q = V.value;
        let Z = V.script;
        const oe = ae.script;
        let y = !1;
        ue == null && (ue = f.hashType.ALL), ue |= f.hashType.SIGHASH_FORKID;
        const Y = f.flags.VERIFY_SIGHASH_FORKID;
        if (Z.isScripthash()) {
          if (Z = ae.script.getRedeem(), !Z)
            throw new Error("Input has not been templated.");
          y = !0;
        }
        const he = this.signature(R, Z, Q, D, ue, Y);
        if (y) {
          const Ie = oe.toStack(), ve = Ie.pop(), C = this.signVector(Z, Ie, he, fe);
          return C ? (C.push(ve), oe.fromStack(C), !0) : !1;
        }
        const be = oe.toStack(), xe = this.signVector(Z, be, he, fe);
        return xe ? (oe.fromStack(xe), !0) : !1;
      }
      /**
       * Add a signature to a vector
       * based on a previous script.
       * @param {Script} prev
       * @param {Stack} vector
       * @param {Buffer} sig
       * @param {KeyRing} ring
       * @return {Boolean}
       */
      signVector(R, V, fe, ue) {
        const ae = R.getPubkey();
        if (ae) {
          if (!ue.publicKey.equals(ae))
            return null;
          if (V.length === 0)
            throw new Error("Input has not been templated.");
          return V.get(0).length > 0 || V.set(0, fe), V;
        }
        const D = R.getPubkeyhash();
        if (D) {
          if (!ue.getKeyHash().equals(D))
            return null;
          if (V.length !== 2)
            throw new Error("Input has not been templated.");
          if (V.get(1).length === 0)
            throw new Error("Input has not been templated.");
          return V.get(0).length > 0 || V.set(0, fe), V;
        }
        const [Q, Z] = R.getMultisig();
        if (Q !== -1) {
          if (V.length < 2)
            throw new Error("Input has not been templated.");
          if (V.get(0).length !== 0)
            throw new Error("Input has not been templated.");
          if (V.length - 1 > Z)
            throw new Error("Input has not been templated.");
          let oe = 0;
          for (let he = 1; he < V.length; he++)
            V.get(he).length > 0 && (oe += 1);
          if (oe === Q && V.length - 1 === Q)
            return V;
          for (; V.length - 1 < Z; )
            V.pushInt(0);
          const y = [];
          for (const he of R.code)
            he.data && y.push(he.data);
          let Y = -1;
          for (let he = 0; he < y.length; he++)
            if (y[he].equals(ue.publicKey)) {
              Y = he;
              break;
            }
          if (Y === -1)
            return null;
          if (Y += 1, Y < V.length && oe < Q && V.get(Y).length === 0 && (V.set(Y, fe), oe += 1), oe >= Q) {
            for (let he = V.length - 1; he >= 1; he--)
              V.get(he).length === 0 && V.remove(he);
            for (; oe > Q; )
              V.pop(), oe -= 1;
            d(oe === Q), d(V.length - 1 === Q);
          }
          return V;
        }
        return null;
      }
      /**
       * Test whether the transaction is fully-signed.
       * @returns {Boolean}
       */
      isSigned() {
        for (let R = 0; R < this.inputs.length; R++) {
          const { prevout: V } = this.inputs[R], fe = this.view.getOutput(V);
          if (!fe || !this.isInputSigned(R, fe))
            return !1;
        }
        return !0;
      }
      /**
       * Test whether an input is fully-signed.
       * @param {Number} index
       * @param {Coin|Output} coin
       * @returns {Boolean}
       */
      isInputSigned(R, V) {
        const fe = this.inputs[R];
        d(fe, "Input does not exist."), d(V, "No coin passed.");
        const ue = fe.script;
        let ae = V.script, D = !1;
        if (ae.isScripthash()) {
          if (ae = fe.script.getRedeem(), !ae)
            return !1;
          D = !0;
        }
        const Q = ue.toStack();
        return D && Q.pop(), this.isVectorSigned(ae, Q);
      }
      /**
       * Test whether a vector is fully-signed.
       * @param {Script} prev
       * @param {Stack} vector
       * @returns {Boolean}
       */
      isVectorSigned(R, V) {
        if (R.isPubkey())
          return !(V.length !== 1 || V.get(0).length === 0);
        if (R.isPubkeyhash())
          return !(V.length !== 2 || V.get(0).length === 0 || V.get(1).length === 0);
        const [fe] = R.getMultisig();
        if (fe !== -1) {
          if (V.length - 1 !== fe)
            return !1;
          for (let ue = 1; ue < V.length; ue++)
            if (V.get(ue).length === 0)
              return !1;
          return !0;
        }
        return !1;
      }
      /**
       * Build input scripts (or witnesses).
       * @param {KeyRing} ring - Address used to sign. The address
       * must be able to redeem the coin.
       * @returns {Number} Number of inputs templated.
       */
      template(R) {
        if (Array.isArray(R)) {
          let fe = 0;
          for (const ue of R)
            fe += this.template(ue);
          return fe;
        }
        let V = 0;
        for (let fe = 0; fe < this.inputs.length; fe++) {
          const { prevout: ue } = this.inputs[fe], ae = this.view.getOutput(ue);
          ae && R.ownOutput(ae) && this.scriptInput(fe, ae, R) && (V += 1);
        }
        return V;
      }
      /**
       * Built input scripts (or witnesses) and sign the inputs.
       * @param {KeyRing} ring - Address used to sign. The address
       * must be able to redeem the coin.
       * @param {SighashType} type
       * @returns {Number} Number of inputs signed.
       */
      sign(R, V) {
        if (Array.isArray(R)) {
          let ue = 0;
          for (const ae of R)
            ue += this.sign(ae, V);
          return ue;
        }
        d(R.privateKey, "No private key available.");
        let fe = 0;
        for (let ue = 0; ue < this.inputs.length; ue++) {
          const { prevout: ae } = this.inputs[ue], D = this.view.getOutput(ae);
          D && R.ownOutput(D) && this.scriptInput(ue, D, R) && this.signInput(ue, D, R, V) && (fe += 1);
        }
        return fe;
      }
      /**
       * Sign the transaction inputs on the worker pool
       * (if workers are enabled).
       * @param {KeyRing} ring
       * @param {SighashType?} type
       * @param {WorkerPool?} pool
       * @returns {Promise}
       */
      async signAsync(R, V, fe) {
        return fe ? await fe.sign(this, R, V) : this.sign(R, V);
      }
      /**
       * Estimate maximum possible size.
       * @param {Function?} estimate - Input script size estimator.
       * @returns {Number}
       */
      async estimateSize(R) {
        let V = 0;
        V += 4, V += w.sizeVarint(this.inputs.length), V += this.inputs.length * 40, V += w.sizeVarint(this.outputs.length);
        for (const fe of this.outputs)
          V += fe.getSize();
        V += 4;
        for (const { prevout: fe } of this.inputs) {
          const ue = this.view.getOutput(fe);
          if (!ue) {
            V += 110;
            continue;
          }
          const ae = ue.script;
          if (ae.isPubkey()) {
            V += 1, V += 74;
            continue;
          }
          if (ae.isPubkeyhash()) {
            V += 1, V += 74, V += 34;
            continue;
          }
          const [D] = ae.getMultisig();
          if (D !== -1) {
            let Q = 0;
            Q += 1, Q += 74 * D, Q += w.sizeVarint(Q), V += Q;
            continue;
          }
          if (R) {
            const Q = await R(ae);
            if (Q !== -1) {
              V += Q;
              continue;
            }
          }
          if (ae.isScripthash()) {
            V += 1, V += 149;
            continue;
          }
          V += 110;
        }
        return V;
      }
      /**
       * Select necessary coins based on total output value.
       * @param {Coin[]} coins
       * @param {Object?} options
       * @returns {CoinSelection}
       * @throws on not enough funds available.
       */
      selectCoins(R, V) {
        return new j(this, V).select(R);
      }
      /**
       * Attempt to subtract a fee from a single output.
       * @param {Number} index
       * @param {Amount} fee
       */
      subtractIndex(R, V) {
        d(typeof R == "number"), d(typeof V == "number");
        const fe = this.outputs[R];
        if (!fe)
          throw new Error("Subtraction index does not exist.");
        if (fe.value < V + fe.getDustThreshold())
          throw new Error("Could not subtract fee.");
        fe.value -= V;
      }
      /**
       * Attempt to subtract a fee from all outputs evenly.
       * @param {Amount} fee
       */
      subtractFee(R) {
        d(typeof R == "number");
        let V = 0;
        for (const ae of this.outputs)
          ae.script.isUnspendable() || (V += 1);
        if (V === 0)
          throw new Error("Could not subtract fee.");
        const fe = R % V, ue = (R - fe) / V;
        for (const ae of this.outputs)
          if (!ae.script.isUnspendable()) {
            if (ae.value < ue + ae.getDustThreshold())
              throw new Error("Could not subtract fee.");
            ae.value -= ue;
          }
        for (const ae of this.outputs)
          if (!ae.script.isUnspendable() && ae.value >= fe + ae.getDustThreshold()) {
            ae.value -= fe;
            return;
          }
        throw new Error("Could not subtract fee.");
      }
      /**
       * Select coins and fill the inputs.
       * @param {Coin[]} coins
       * @param {Object} options - See {@link MTX#selectCoins} options.
       * @returns {CoinSelector}
       */
      async fund(R, V) {
        d(V, "Options are required."), d(V.changeAddress, "Change address is required."), d(this.inputs.length === 0, "TX is already funded.");
        const fe = await this.selectCoins(R, V);
        for (const ae of fe.chosen)
          this.addCoin(ae);
        if (fe.subtractFee) {
          const ae = fe.subtractIndex;
          ae !== -1 ? this.subtractIndex(ae, fe.fee) : this.subtractFee(fe.fee);
        }
        const ue = new a();
        return ue.value = fe.change, ue.script.fromAddress(fe.changeAddress), ue.isDust(v.MIN_RELAY) ? (this.changeIndex = -1, d.strictEqual(this.getFee(), fe.fee + fe.change)) : (this.outputs.push(ue), this.changeIndex = this.outputs.length - 1, d.strictEqual(this.getFee(), fe.fee)), fe;
      }
      /**
       * Sort inputs and outputs according to BIP69.
       * @see https://github.com/bitcoin/bips/blob/master/bip-0069.mediawiki
       */
      sortMembers() {
        let R = null;
        this.changeIndex !== -1 && (R = this.outputs[this.changeIndex], d(R)), this.inputs.sort(q), this.outputs.sort(_), this.changeIndex !== -1 && (this.changeIndex = this.outputs.indexOf(R), d(this.changeIndex !== -1));
      }
      /**
       * Avoid fee sniping.
       * @param {Number} - Current chain height.
       * @see bitcoin/src/wallet/wallet.cpp
       */
      avoidFeeSniping(R) {
        d(typeof R == "number", "Must pass in height."), (Math.random() * 10 | 0) === 0 && (R -= Math.random() * 100 | 0, R < 0 && (R = 0)), this.setLocktime(R);
      }
      /**
       * Set locktime and sequences appropriately.
       * @param {Number} locktime
       */
      setLocktime(R) {
        d(R >>> 0 === R, "Locktime must be a uint32."), d(this.inputs.length > 0, "Cannot set sequence with no inputs.");
        for (const V of this.inputs)
          V.sequence === 4294967295 && (V.sequence = 4294967294);
        this.locktime = R;
      }
      /**
       * Set sequence locktime.
       * @param {Number} index - Input index.
       * @param {Number} locktime
       * @param {Boolean?} seconds
       */
      setSequence(R, V, fe) {
        const ue = this.inputs[R];
        d(ue, "Input does not exist."), d(V >>> 0 === V, "Locktime must be a uint32."), this.version = 2, fe ? (V >>>= E.SEQUENCE_GRANULARITY, V &= E.SEQUENCE_MASK, V |= E.SEQUENCE_TYPE_FLAG) : V &= E.SEQUENCE_MASK, ue.sequence = V;
      }
      /**
       * Inspect the transaction.
       * @returns {Object}
       */
      [S]() {
        return this.format();
      }
      /**
       * Inspect the transaction.
       * @returns {Object}
       */
      format() {
        return super.format(this.view);
      }
      /**
       * Convert transaction to JSON.
       * @returns {Object}
       */
      toJSON() {
        return super.toJSON(null, this.view);
      }
      /**
       * Convert transaction to JSON.
       * @param {Network} network
       * @returns {Object}
       */
      getJSON(R) {
        return super.getJSON(R, this.view);
      }
      /**
       * Inject properties from a json object
       * @param {Object} json
       */
      fromJSON(R) {
        super.fromJSON(R);
        for (let V = 0; V < R.inputs.length; V++) {
          const fe = R.inputs[V], { prevout: ue } = fe;
          if (!fe.coin)
            continue;
          const ae = s.fromJSON(fe.coin);
          ae.hash = o.fromRev(ue.hash), ae.index = ue.index, this.view.addCoin(ae);
        }
        return this;
      }
      /**
       * Instantiate a transaction from a
       * jsonified transaction object.
       * @param {Object} json - The jsonified transaction object.
       * @returns {MTX}
       */
      static fromJSON(R) {
        return new this().fromJSON(R);
      }
      /**
       * Instantiate a transaction from a buffer reader.
       * @param {BufferReader} br
       * @returns {MTX}
       */
      static fromReader(R) {
        return new this().fromReader(R);
      }
      /**
       * Instantiate a transaction from a serialized Buffer.
       * @param {Buffer} data
       * @param {String?} enc - Encoding, can be `'hex'` or null.
       * @returns {MTX}
       */
      static fromRaw(R, V) {
        return typeof R == "string" && (R = k.from(R, V)), new this().fromRaw(R);
      }
      /**
       * Convert the MTX to a TX.
       * @returns {TX}
       */
      toTX() {
        return new n().inject(this);
      }
      /**
       * Convert the MTX to a TX.
       * @returns {Array} [tx, view]
       */
      commit() {
        return [this.toTX(), this.view];
      }
      /**
       * Instantiate MTX from TX.
       * @param {TX} tx
       * @returns {MTX}
       */
      static fromTX(R) {
        return new this().inject(R);
      }
      /**
       * Test whether an object is an MTX.
       * @param {Object} obj
       * @returns {Boolean}
       */
      static isMTX(R) {
        return R instanceof H;
      }
    }
    class j {
      /**
       * Create a coin selector.
       * @constructor
       * @param {TX} tx
       * @param {Object?} options
       */
      constructor(R, V) {
        this.tx = R.clone(), this.coins = [], this.outputValue = 0, this.index = 0, this.chosen = [], this.change = 0, this.fee = j.MIN_FEE, this.selection = "value", this.subtractFee = !1, this.subtractIndex = -1, this.height = -1, this.depth = -1, this.hardFee = -1, this.rate = j.FEE_RATE, this.maxFee = -1, this.round = !1, this.changeAddress = null, this.inputs = new g(), this.estimate = null, this.injectInputs(), V && this.fromOptions(V);
      }
      /**
       * Initialize selector options.
       * @param {Object} options
       * @private
       */
      fromOptions(R) {
        if (R.selection && (d(typeof R.selection == "string"), this.selection = R.selection), R.subtractFee != null && (typeof R.subtractFee == "number" ? (d(Number.isSafeInteger(R.subtractFee)), d(R.subtractFee >= -1), this.subtractIndex = R.subtractFee, this.subtractFee = this.subtractIndex !== -1) : (d(typeof R.subtractFee == "boolean"), this.subtractFee = R.subtractFee)), R.subtractIndex != null && (d(Number.isSafeInteger(R.subtractIndex)), d(R.subtractIndex >= -1), this.subtractIndex = R.subtractIndex, this.subtractFee = this.subtractIndex !== -1), R.height != null && (d(Number.isSafeInteger(R.height)), d(R.height >= -1), this.height = R.height), R.confirmations != null && (d(Number.isSafeInteger(R.confirmations)), d(R.confirmations >= -1), this.depth = R.confirmations), R.depth != null && (d(Number.isSafeInteger(R.depth)), d(R.depth >= -1), this.depth = R.depth), R.hardFee != null && (d(Number.isSafeInteger(R.hardFee)), d(R.hardFee >= -1), this.hardFee = R.hardFee), R.rate != null && (d(Number.isSafeInteger(R.rate)), d(R.rate >= 0), this.rate = R.rate), R.maxFee != null && (d(Number.isSafeInteger(R.maxFee)), d(R.maxFee >= -1), this.maxFee = R.maxFee), R.round != null && (d(typeof R.round == "boolean"), this.round = R.round), R.changeAddress) {
          const V = R.changeAddress;
          typeof V == "string" ? this.changeAddress = m.fromString(V) : (d(V instanceof m), this.changeAddress = V);
        }
        if (R.estimate && (d(typeof R.estimate == "function"), this.estimate = R.estimate), R.inputs) {
          d(Array.isArray(R.inputs));
          for (let V = 0; V < R.inputs.length; V++) {
            const fe = R.inputs[V];
            d(fe && typeof fe == "object");
            const { hash: ue, index: ae } = fe;
            d(k.isBuffer(ue)), d(typeof ae == "number"), this.inputs.set(i.toKey(ue, ae), V);
          }
        }
        return this;
      }
      /**
       * Attempt to inject existing inputs.
       * @private
       */
      injectInputs() {
        if (this.tx.inputs.length > 0)
          for (let R = 0; R < this.tx.inputs.length; R++) {
            const { prevout: V } = this.tx.inputs[R];
            this.inputs.set(V.toKey(), R);
          }
      }
      /**
       * Initialize the selector with coins to select from.
       * @param {Coin[]} coins
       */
      init(R) {
        switch (this.coins = R.slice(), this.outputValue = this.tx.getOutputValue(), this.index = 0, this.chosen = [], this.change = 0, this.fee = j.MIN_FEE, this.tx.inputs.length = 0, this.selection) {
          case "all":
          case "random":
            this.coins.sort(z);
            break;
          case "age":
            this.coins.sort(N);
            break;
          case "value":
            this.coins.sort(A);
            break;
          default:
            throw new J(`Bad selection type: ${this.selection}.`);
        }
      }
      /**
       * Calculate total value required.
       * @returns {Amount}
       */
      total() {
        return this.subtractFee ? this.outputValue : this.outputValue + this.fee;
      }
      /**
       * Test whether the selector has
       * completely funded the transaction.
       * @returns {Boolean}
       */
      isFull() {
        return this.tx.getInputValue() >= this.total();
      }
      /**
       * Test whether a coin is spendable
       * with regards to the options.
       * @param {Coin} coin
       * @returns {Boolean}
       */
      isSpendable(R) {
        return this.tx.view.hasEntry(R) ? !1 : this.height === -1 ? !0 : R.coinbase ? !(R.height === -1 || this.height + 1 < R.height + E.COINBASE_MATURITY) : this.depth === -1 ? !0 : !(R.getDepth(this.height) < this.depth);
      }
      /**
       * Get the current fee based on a size.
       * @param {Number} size
       * @returns {Amount}
       */
      getFee(R) {
        if (this.round) {
          const fe = v.getRoundFee(R, this.rate);
          return Math.min(fe, j.MAX_FEE);
        }
        const V = v.getMinFee(R, this.rate);
        return Math.min(V, j.MAX_FEE);
      }
      /**
       * Fund the transaction with more
       * coins if the `output value + fee`
       * total was updated.
       */
      fund() {
        if (this.inputs.size > 0) {
          const R = [];
          for (let V = 0; V < this.inputs.size; V++)
            R.push(null);
          for (const V of this.coins) {
            const { hash: fe, index: ue } = V, ae = i.toKey(fe, ue), D = this.inputs.get(ae);
            D != null && (R[D] = V, this.inputs.delete(ae));
          }
          if (this.inputs.size > 0)
            throw new Error("Could not resolve preferred inputs.");
          for (const V of R)
            this.tx.addCoin(V), this.chosen.push(V);
        }
        for (; this.index < this.coins.length; ) {
          const R = this.coins[this.index++];
          if (this.isSpendable(R) && (this.tx.addCoin(R), this.chosen.push(R), this.selection !== "all" && this.isFull()))
            break;
        }
      }
      /**
       * Initiate selection from `coins`.
       * @param {Coin[]} coins
       * @returns {CoinSelector}
       */
      async select(R) {
        if (this.init(R), this.hardFee !== -1 ? this.selectHard() : await this.selectEstimate(), !this.isFull())
          throw new J(
            "Not enough funds.",
            this.tx.getInputValue(),
            this.total()
          );
        return this.change = this.tx.getInputValue() - this.total(), this;
      }
      /**
       * Initialize selection based on size estimate.
       */
      async selectEstimate() {
        this.fee = j.MIN_FEE, this.fund();
        const R = new a();
        this.changeAddress ? R.script.fromAddress(this.changeAddress) : R.script.fromPubkeyhash(k.allocUnsafe(20)), this.tx.outputs.push(R);
        do {
          const V = await this.tx.estimateSize(this.estimate);
          if (this.fee = this.getFee(V), this.maxFee > 0 && this.fee > this.maxFee)
            throw new J("Fee is too high.");
          this.isFull() || this.fund();
        } while (!this.isFull() && this.index < this.coins.length);
      }
      /**
       * Initiate selection based on a hard fee.
       */
      selectHard() {
        this.fee = Math.min(this.hardFee, j.MAX_FEE), this.fund();
      }
    }
    j.FEE_RATE = 1e4, j.MIN_FEE = 1e4, j.MAX_FEE = E.COIN / 10;
    class J extends Error {
      /**
       * Create a funding error.
       * @constructor
       * @param {String} msg
       * @param {Amount} available
       * @param {Amount} required
       */
      constructor(R, V, fe) {
        super(), this.type = "FundingError", this.message = R, this.availableFunds = -1, this.requiredFunds = -1, V != null && (this.message += ` (available=${b.btc(V)},`, this.message += ` required=${b.btc(fe)})`, this.availableFunds = V, this.requiredFunds = fe), Error.captureStackTrace && Error.captureStackTrace(this, J);
      }
    }
    function N(F, R) {
      return F = F.height === -1 ? 2147483647 : F.height, R = R.height === -1 ? 2147483647 : R.height, F - R;
    }
    function z(F, R) {
      return Math.random() > 0.5 ? 1 : -1;
    }
    function A(F, R) {
      return F.height === -1 && R.height !== -1 ? 1 : F.height !== -1 && R.height === -1 ? -1 : R.value - F.value;
    }
    function q(F, R) {
      return F.compare(R);
    }
    function _(F, R) {
      return F.compare(R);
    }
    c = H, c.MTX = H, c.Selector = j, c.FundingError = J, e.exports = c;
  }(ys, ys.exports)), ys.exports;
}
var _u, D4;
function mx() {
  if (D4) return _u;
  D4 = 1;
  const e = $e(), c = At(), d = Zt(), w = xn(), { inspectSymbol: g } = Kt();
  class f {
    /**
     * Create an extended transaction.
     * @constructor
     * @param {Object?} options
     */
    constructor(u) {
      this.tx = new w(), this.mtime = d.now(), this.height = -1, this.block = null, this.time = 0, this.index = -1, u && this.fromOptions(u);
    }
    /**
     * Inject properties from options object.
     * @private
     * @param {Object} options
     */
    fromOptions(u) {
      return u.tx && (e(u.tx instanceof w), this.tx = u.tx), u.mtime != null && (e(u.mtime >>> 0 === u.mtime), this.mtime = u.mtime), u.height != null && (e(Number.isSafeInteger(u.height)), this.height = u.height), u.block !== void 0 && (e(u.block == null || k.isBuffer(u.block)), this.block = u.block), u.time != null && (e(u.time >>> 0 === u.time), this.time = u.time), u.index != null && (e(Number.isSafeInteger(u.index)), this.index = u.index), this;
    }
    /**
     * Instantiate TXMeta from options.
     * @param {Object} options
     * @returns {TXMeta}
     */
    static fromOptions(u) {
      return new this().fromOptions(u);
    }
    /**
     * Inject properties from options object.
     * @private
     * @param {Object} options
     */
    fromTX(u, a, s) {
      return this.tx = u, a && (this.height = a.height, this.block = a.hash, this.time = a.time, this.index = s), this;
    }
    /**
     * Instantiate TXMeta from options.
     * @param {Object} options
     * @returns {TXMeta}
     */
    static fromTX(u, a, s) {
      return new this().fromTX(u, a, s);
    }
    /**
     * Inspect the transaction.
     * @returns {Object}
     */
    [g]() {
      return this.format();
    }
    /**
     * Inspect the transaction.
     * @returns {Object}
     */
    format(u) {
      const a = this.tx.format(u, null, this.index);
      return a.mtime = this.mtime, a.height = this.height, a.block = this.block ? d.revHex(this.block) : null, a.time = this.time, a;
    }
    /**
     * Convert transaction to JSON.
     * @returns {Object}
     */
    toJSON() {
      return this.getJSON();
    }
    /**
     * Convert the transaction to an object suitable
     * for JSON serialization.
     * @param {Network} network
     * @param {CoinView} view
     * @returns {Object}
     */
    getJSON(u, a, s) {
      const i = this.tx.getJSON(u, a, null, this.index);
      return i.mtime = this.mtime, i.height = this.height, i.block = this.block ? d.revHex(this.block) : null, i.time = this.time, i.confirmations = 0, s != null && this.height !== -1 && (i.confirmations = s - this.height + 1), i;
    }
    /**
     * Inject properties from a json object.
     * @private
     * @param {Object} json
     */
    fromJSON(u) {
      return this.tx.fromJSON(u), e(u.mtime >>> 0 === u.mtime), e(Number.isSafeInteger(u.height)), e(!u.block || typeof u.block == "string"), e(u.time >>> 0 === u.time), e(Number.isSafeInteger(u.index)), this.mtime = u.mtime, this.height = u.height, this.block = d.fromRev(u.block), this.index = u.index, this;
    }
    /**
     * Instantiate a transaction from a
     * jsonified transaction object.
     * @param {Object} json - The jsonified transaction object.
     * @returns {TX}
     */
    static fromJSON(u) {
      return new this().fromJSON(u);
    }
    /**
     * Calculate serialization size.
     * @returns {Number}
     */
    getSize() {
      let u = 0;
      return u += this.tx.getSize(), u += 4, this.block ? (u += 1, u += 32, u += 12) : u += 1, u;
    }
    /**
     * Serialize a transaction to "extended format".
     * This is the serialization format bcoin uses internally
     * to store transactions in the database. The extended
     * serialization includes the height, block hash, index,
     * timestamp, and pending-since time.
     * @returns {Buffer}
     */
    toRaw() {
      const u = this.getSize(), a = c.write(u);
      return this.tx.toWriter(a), a.writeU32(this.mtime), this.block ? (a.writeU8(1), a.writeHash(this.block), a.writeU32(this.height), a.writeU32(this.time), a.writeU32(this.index)) : a.writeU8(0), a.render();
    }
    /**
     * Inject properties from "extended" serialization format.
     * @private
     * @param {Buffer} data
     */
    fromRaw(u) {
      const a = c.read(u);
      return this.tx.fromReader(a), this.mtime = a.readU32(), a.readU8() === 1 && (this.block = a.readHash(), this.height = a.readU32(), this.time = a.readU32(), this.index = a.readU32(), this.index === 2147483647 && (this.index = -1)), this;
    }
    /**
     * Instantiate a transaction from a Buffer
     * in "extended" serialization format.
     * @param {Buffer} data
     * @param {String?} enc - One of `"hex"` or `null`.
     * @returns {TX}
     */
    static fromRaw(u, a) {
      return typeof u == "string" && (u = k.from(u, a)), new this().fromRaw(u);
    }
    /**
     * Test whether an object is an TXMeta.
     * @param {Object} obj
     * @returns {Boolean}
     */
    static isTXMeta(u) {
      return u instanceof f;
    }
  }
  return _u = f, _u;
}
/*!
 * primitives/index.js - bitcoin primitives for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var U4;
function gx() {
  return U4 || (U4 = 1, Yt.AbstractBlock = is(), Yt.Address = Lr(), Yt.Block = vl(), Yt.Coin = rs(), Yt.Headers = ns(), Yt.Input = vo(), Yt.InvItem = yo(), Yt.KeyRing = Sl(), Yt.MemBlock = px(), Yt.MerkleBlock = yl(), Yt.MTX = El(), Yt.Outpoint = xi(), Yt.Output = gi(), Yt.TX = xn(), Yt.TXMeta = mx()), Yt;
}
var ui = {}, Ru = {};
/*!
 * errors.js - error objects for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var F4;
function xx() {
  if (F4) return Ru;
  F4 = 1;
  const e = $e();
  class c extends Error {
    /**
     * Create a verify error.
     * @constructor
     * @param {Block|TX} msg
     * @param {String} code - Reject packet code.
     * @param {String} reason - Reject packet reason.
     * @param {Number} score - Ban score increase
     * (can be -1 for no reject packet).
     * @param {Boolean} malleated
     */
    constructor(w, g, f, n, u) {
      super(), e(typeof g == "string"), e(typeof f == "string"), e(n >= 0), this.type = "VerifyError", this.message = "", this.code = g, this.reason = f, this.score = n, this.hash = w.hash(), this.malleated = u || !1, this.message = `Verification failure: ${f} (code=${g} score=${n} hash=${w.rhash()})`, Error.captureStackTrace && Error.captureStackTrace(this, c);
    }
  }
  return Ru.VerifyError = c, Ru;
}
/*!
 * protocol/index.js - protocol constants for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var H4;
function wx() {
  return H4 || (H4 = 1, ui.consensus = Ht(), ui.errors = xx(), ui.Network = yr(), ui.networks = dl(), ui.policy = mi(), ui.timedata = Fb()), ui;
}
var Ir = {}, Pu, L4;
function i7() {
  if (L4) return Pu;
  L4 = 1;
  const e = $e(), { BufferMap: c } = Dr(), d = Rr();
  class w {
    /**
     * Create a signature cache.
     * @constructor
     * @param {Number} [size=10000]
     */
    constructor(n) {
      n == null && (n = 1e4), e(n >>> 0 === n), this.size = n, this.keys = [], this.valid = new c();
    }
    /**
     * Resize the sigcache.
     * @param {Number} size
     */
    resize(n) {
      e(n >>> 0 === n), this.size = n, this.keys.length = 0, this.valid.clear();
    }
    /**
     * Add item to the sigcache.
     * Potentially evict a random member.
     * @param {Hash} msg - Sig hash.
     * @param {Buffer} sig
     * @param {Buffer} key
     */
    add(n, u, a) {
      if (this.size !== 0)
        if (this.valid.set(n, new g(u, a)), this.keys.length >= this.size) {
          const s = Math.floor(Math.random() * this.keys.length), i = this.keys[s];
          this.valid.delete(i), this.keys[s] = n;
        } else
          this.keys.push(n);
    }
    /**
     * Test whether the sig exists.
     * @param {Hash} msg - Sig hash.
     * @param {Buffer} sig
     * @param {Buffer} key
     * @returns {Boolean}
     */
    has(n, u, a) {
      const s = this.valid.get(n);
      return s ? s.equals(u, a) : !1;
    }
    /**
     * Verify a signature, testing
     * it against the cache first.
     * @param {Buffer} msg
     * @param {Buffer} sig
     * @param {Buffer} key
     * @returns {Boolean}
     */
    verify(n, u, a) {
      return this.size === 0 ? d.verifyDER(n, u, a) : this.has(n, u, a) ? !0 : d.verifyDER(n, u, a) ? (this.add(n, u, a), !0) : !1;
    }
    /**
     * Verify a schnorr signature, testing
     * it against the cache first.
     * @param {Buffer} msg
     * @param {Buffer} sig
     * @param {Buffer} key
     * @returns {Boolean}
     */
    verifySchnorr(n, u, a) {
      return this.size === 0 ? d.schnorrVerify(n, u, a) : this.has(n, u, a) ? !0 : d.schnorrVerify(n, u, a) ? (this.add(n, u, a), !0) : !1;
    }
  }
  class g {
    /**
     * Create a cache entry.
     * @constructor
     * @param {Buffer} sig
     * @param {Buffer} key
     */
    constructor(n, u) {
      this.sig = k.from(n), this.key = k.from(u);
    }
    /**
     * Compare an entry to a sig and key.
     * @param {Buffer} sig
     * @param {Buffer} key
     * @returns {Boolean}
     */
    equals(n, u) {
      return this.sig.equals(n) && this.key.equals(u);
    }
  }
  return Pu = w, Pu;
}
/*!
 * script/index.js - bitcoin scripting for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var K4;
function yx() {
  return K4 || (K4 = 1, Ir.common = ts(), Ir.Opcode = pl(), Ir.Script = Pr(), Ir.ScriptError = ho(), Ir.ScriptNum = Li(), Ir.sigcache = i7(), Ir.Stack = lo(), Ir.Metrics = Zb(), Ir.SLP = bo()), Ir;
}
var ku, V4;
function n7() {
  if (V4) return ku;
  V4 = 1;
  function e(g) {
    if (typeof g != "string")
      throw new TypeError("Path must be a string. Received " + JSON.stringify(g));
  }
  function c(g, f) {
    for (var n = "", u = 0, a = -1, s = 0, i, p = 0; p <= g.length; ++p) {
      if (p < g.length)
        i = g.charCodeAt(p);
      else {
        if (i === 47)
          break;
        i = 47;
      }
      if (i === 47) {
        if (!(a === p - 1 || s === 1)) if (a !== p - 1 && s === 2) {
          if (n.length < 2 || u !== 2 || n.charCodeAt(n.length - 1) !== 46 || n.charCodeAt(n.length - 2) !== 46) {
            if (n.length > 2) {
              var m = n.lastIndexOf("/");
              if (m !== n.length - 1) {
                m === -1 ? (n = "", u = 0) : (n = n.slice(0, m), u = n.length - 1 - n.lastIndexOf("/")), a = p, s = 0;
                continue;
              }
            } else if (n.length === 2 || n.length === 1) {
              n = "", u = 0, a = p, s = 0;
              continue;
            }
          }
          f && (n.length > 0 ? n += "/.." : n = "..", u = 2);
        } else
          n.length > 0 ? n += "/" + g.slice(a + 1, p) : n = g.slice(a + 1, p), u = p - a - 1;
        a = p, s = 0;
      } else i === 46 && s !== -1 ? ++s : s = -1;
    }
    return n;
  }
  function d(g, f) {
    var n = f.dir || f.root, u = f.base || (f.name || "") + (f.ext || "");
    return n ? n === f.root ? n + u : n + g + u : u;
  }
  var w = {
    // path.resolve([from ...], to)
    resolve: function() {
      for (var f = "", n = !1, u, a = arguments.length - 1; a >= -1 && !n; a--) {
        var s;
        a >= 0 ? s = arguments[a] : (u === void 0 && (u = It.cwd()), s = u), e(s), s.length !== 0 && (f = s + "/" + f, n = s.charCodeAt(0) === 47);
      }
      return f = c(f, !n), n ? f.length > 0 ? "/" + f : "/" : f.length > 0 ? f : ".";
    },
    normalize: function(f) {
      if (e(f), f.length === 0) return ".";
      var n = f.charCodeAt(0) === 47, u = f.charCodeAt(f.length - 1) === 47;
      return f = c(f, !n), f.length === 0 && !n && (f = "."), f.length > 0 && u && (f += "/"), n ? "/" + f : f;
    },
    isAbsolute: function(f) {
      return e(f), f.length > 0 && f.charCodeAt(0) === 47;
    },
    join: function() {
      if (arguments.length === 0)
        return ".";
      for (var f, n = 0; n < arguments.length; ++n) {
        var u = arguments[n];
        e(u), u.length > 0 && (f === void 0 ? f = u : f += "/" + u);
      }
      return f === void 0 ? "." : w.normalize(f);
    },
    relative: function(f, n) {
      if (e(f), e(n), f === n || (f = w.resolve(f), n = w.resolve(n), f === n)) return "";
      for (var u = 1; u < f.length && f.charCodeAt(u) === 47; ++u)
        ;
      for (var a = f.length, s = a - u, i = 1; i < n.length && n.charCodeAt(i) === 47; ++i)
        ;
      for (var p = n.length, m = p - i, E = s < m ? s : m, v = -1, b = 0; b <= E; ++b) {
        if (b === E) {
          if (m > E) {
            if (n.charCodeAt(i + b) === 47)
              return n.slice(i + b + 1);
            if (b === 0)
              return n.slice(i + b);
          } else s > E && (f.charCodeAt(u + b) === 47 ? v = b : b === 0 && (v = 0));
          break;
        }
        var h = f.charCodeAt(u + b), o = n.charCodeAt(i + b);
        if (h !== o)
          break;
        h === 47 && (v = b);
      }
      var S = "";
      for (b = u + v + 1; b <= a; ++b)
        (b === a || f.charCodeAt(b) === 47) && (S.length === 0 ? S += ".." : S += "/..");
      return S.length > 0 ? S + n.slice(i + v) : (i += v, n.charCodeAt(i) === 47 && ++i, n.slice(i));
    },
    _makeLong: function(f) {
      return f;
    },
    dirname: function(f) {
      if (e(f), f.length === 0) return ".";
      for (var n = f.charCodeAt(0), u = n === 47, a = -1, s = !0, i = f.length - 1; i >= 1; --i)
        if (n = f.charCodeAt(i), n === 47) {
          if (!s) {
            a = i;
            break;
          }
        } else
          s = !1;
      return a === -1 ? u ? "/" : "." : u && a === 1 ? "//" : f.slice(0, a);
    },
    basename: function(f, n) {
      if (n !== void 0 && typeof n != "string") throw new TypeError('"ext" argument must be a string');
      e(f);
      var u = 0, a = -1, s = !0, i;
      if (n !== void 0 && n.length > 0 && n.length <= f.length) {
        if (n.length === f.length && n === f) return "";
        var p = n.length - 1, m = -1;
        for (i = f.length - 1; i >= 0; --i) {
          var E = f.charCodeAt(i);
          if (E === 47) {
            if (!s) {
              u = i + 1;
              break;
            }
          } else
            m === -1 && (s = !1, m = i + 1), p >= 0 && (E === n.charCodeAt(p) ? --p === -1 && (a = i) : (p = -1, a = m));
        }
        return u === a ? a = m : a === -1 && (a = f.length), f.slice(u, a);
      } else {
        for (i = f.length - 1; i >= 0; --i)
          if (f.charCodeAt(i) === 47) {
            if (!s) {
              u = i + 1;
              break;
            }
          } else a === -1 && (s = !1, a = i + 1);
        return a === -1 ? "" : f.slice(u, a);
      }
    },
    extname: function(f) {
      e(f);
      for (var n = -1, u = 0, a = -1, s = !0, i = 0, p = f.length - 1; p >= 0; --p) {
        var m = f.charCodeAt(p);
        if (m === 47) {
          if (!s) {
            u = p + 1;
            break;
          }
          continue;
        }
        a === -1 && (s = !1, a = p + 1), m === 46 ? n === -1 ? n = p : i !== 1 && (i = 1) : n !== -1 && (i = -1);
      }
      return n === -1 || a === -1 || // We saw a non-dot character immediately before the dot
      i === 0 || // The (right-most) trimmed path component is exactly '..'
      i === 1 && n === a - 1 && n === u + 1 ? "" : f.slice(n, a);
    },
    format: function(f) {
      if (f === null || typeof f != "object")
        throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof f);
      return d("/", f);
    },
    parse: function(f) {
      e(f);
      var n = { root: "", dir: "", base: "", ext: "", name: "" };
      if (f.length === 0) return n;
      var u = f.charCodeAt(0), a = u === 47, s;
      a ? (n.root = "/", s = 1) : s = 0;
      for (var i = -1, p = 0, m = -1, E = !0, v = f.length - 1, b = 0; v >= s; --v) {
        if (u = f.charCodeAt(v), u === 47) {
          if (!E) {
            p = v + 1;
            break;
          }
          continue;
        }
        m === -1 && (E = !1, m = v + 1), u === 46 ? i === -1 ? i = v : b !== 1 && (b = 1) : i !== -1 && (b = -1);
      }
      return i === -1 || m === -1 || // We saw a non-dot character immediately before the dot
      b === 0 || // The (right-most) trimmed path component is exactly '..'
      b === 1 && i === m - 1 && i === p + 1 ? m !== -1 && (p === 0 && a ? n.base = n.name = f.slice(1, m) : n.base = n.name = f.slice(p, m)) : (p === 0 && a ? (n.name = f.slice(1, i), n.base = f.slice(1, m)) : (n.name = f.slice(p, i), n.base = f.slice(p, m)), n.ext = f.slice(i, m)), p > 0 ? n.dir = f.slice(0, p - 1) : a && (n.dir = "/"), n;
    },
    sep: "/",
    delimiter: ":",
    win32: null,
    posix: null
  };
  return w.posix = w, ku = w, ku;
}
var vs = {}, zn = {}, $4;
function Il() {
  if ($4) return zn;
  $4 = 1;
  const e = Mt();
  function c(n, u) {
    e(k.isBuffer(n)), e(typeof u == "number");
    const a = n.length - (n.length & 3), s = 3432918353, i = 461845907;
    let p = u | 0;
    for (let E = 0; E < a; E += 4) {
      let v = f(n, E);
      v = w(v, s), v = g(v, 15), v = w(v, i), p ^= v, p = g(p, 13), p = w(p, 5) + 3864292196 | 0;
    }
    let m = 0;
    switch (n.length & 3) {
      case 3:
        m ^= n[a + 2] << 16;
      case 2:
        m ^= n[a + 1] << 8;
      case 1:
        m ^= n[a + 0], m = w(m, s), m = g(m, 15), m = w(m, i), p ^= m;
    }
    return p ^= n.length, p ^= p >>> 16, p = w(p, 2246822507), p ^= p >>> 13, p = w(p, 3266489909), p ^= p >>> 16, p >>> 0;
  }
  function d(n, u, a) {
    e(typeof u == "number"), e(typeof a == "number");
    const s = w(u, 4221880213) + (a | 0);
    return c(n, s);
  }
  function w(n, u) {
    const a = n & 65535, s = u & 65535, i = n >>> 16, p = u >>> 16, m = a * s;
    return i * s + p * a + (m >>> 16) << 16 | m & 65535;
  }
  function g(n, u) {
    return n << u | n >>> 32 - u;
  }
  function f(n, u) {
    return n[u++] + n[u++] * 256 + n[u++] * 65536 + n[u] * 16777216;
  }
  return zn.native = 0, zn.sum = c, zn.tweak = d, zn;
}
var Bu, j4;
function vx() {
  if (j4) return Bu;
  j4 = 1;
  const { enforce: e } = $e(), c = At(), d = Il(), w = k.alloc(0), g = 0.48045301391820144, f = 0.6931471805599453;
  class n extends c.Struct {
    /**
     * Create a bloom filter.
     * @constructor
     * @param {Number} size - Filter size in bits.
     * @param {Number} n - Number of hash functions.
     * @param {Number} tweak - Seed value.
     * @param {Number|String} - Update type.
     * @property {Buffer} filter
     * @property {Number} size
     * @property {Number} n
     * @property {Number} tweak
     * @property {Number} update - Update flag (see {@link BloomFilter.flags}).
     */
    constructor(s, i, p, m) {
      super(), this.filter = w, this.size = 0, this.n = 0, this.tweak = 0, this.update = n.flags.NONE, s != null && this.fromOptions(s, i, p, m);
    }
    /**
     * Inject properties from options.
     * @private
     * @param {Number} size - Filter size in bits.
     * @param {Number} n - Number of hash functions.
     * @param {Number} tweak - Seed value.
     * @param {Number|String} - Update type.
     * @returns {BloomFilter}
     */
    fromOptions(s, i, p, m) {
      return (p == null || p === -1) && (p = Math.random() * 4294967296 >>> 0), (m == null || m === -1) && (m = n.flags.NONE), typeof m == "string" && (m = n.flags[m.toUpperCase()], e(m != null, "update", "flag")), e(Number.isSafeInteger(s) && s >= 0, "size", "integer"), e(Number.isSafeInteger(i) && i >= 0, "n", "integer"), e(p >>> 0 === p, "tweak", "integer"), e(m >>> 0 === m, "update", "integer"), e(m <= 2, "update", "range between 0 and 2"), s < 8 && (s = 8), i === 0 && (i = 1), s -= s & 7, this.filter = k.alloc(s / 8, 0), this.size = s, this.n = i, this.tweak = p, this.update = m, this;
    }
    /**
     * Instantiate bloom filter from options.
     * @param {Number} size - Filter size in bits.
     * @param {Number} n - Number of hash functions.
     * @param {Number} tweak - Seed value.
     * @param {Number|String} - Update type.
     * @returns {BloomFilter}
     */
    static fromOptions(s, i, p, m) {
      return new this().fromOptions(s, i, p, m);
    }
    /**
     * Perform the mumur3 hash on data.
     * @param {Buffer} value
     * @param {Number} n
     * @returns {Number}
     */
    hash(s, i) {
      return d.tweak(s, i, this.tweak) % this.size;
    }
    /**
     * Reset the filter.
     */
    reset() {
      this.filter.fill(0);
    }
    /**
     * Add data to the filter.
     * @param {Buffer|String}
     * @param {String?} enc - Can be any of the Buffer object's encodings.
     */
    add(s, i) {
      const p = u(s, i);
      for (let m = 0; m < this.n; m++) {
        const E = this.hash(p, m);
        this.filter[E >>> 3] |= 1 << (7 & E);
      }
    }
    /**
     * Test whether data is present in the filter.
     * @param {Buffer|String} value
     * @param {String?} enc - Can be any of the Buffer object's encodings.
     * @returns {Boolean}
     */
    test(s, i) {
      const p = u(s, i);
      for (let m = 0; m < this.n; m++) {
        const E = this.hash(p, m);
        if ((this.filter[E >>> 3] & 1 << (7 & E)) === 0)
          return !1;
      }
      return !0;
    }
    /**
     * Test whether data is present in the
     * filter and potentially add data.
     * @param {Buffer|String} value
     * @param {String?} enc - Can be any of the Buffer object's encodings.
     * @returns {Boolean} Whether data was added.
     */
    added(s, i) {
      const p = u(s, i);
      let m = !1;
      for (let E = 0; E < this.n; E++) {
        const v = this.hash(p, E);
        !m && (this.filter[v >>> 3] & 1 << (7 & v)) === 0 && (m = !0), this.filter[v >>> 3] |= 1 << (7 & v);
      }
      return m;
    }
    /**
     * Create a filter from a false positive rate.
     * @param {Number} items - Expected number of items.
     * @param {Number} rate - False positive rate (0.0-1.0).
     * @param {Number|String} update
     * @example
     * BloomFilter.fromRate(800000, 0.0001, 'none');
     * @returns {BloomFilter}
     */
    static fromRate(s, i, p) {
      e(Number.isSafeInteger(s) && s > 0, "items", "integer"), e(typeof i == "number" && isFinite(i), "rate", "number"), e(i >= 0 && i <= 1, "rate", "range between 0.1 and 1.0.");
      const m = -1 / g * s * Math.log(i) | 0, E = Math.max(8, m);
      if (p !== -1 && E > n.MAX_BLOOM_FILTER_SIZE * 8)
        throw new Error("Bloom filter size violates policy limits!");
      const v = Math.max(1, E / s * f | 0);
      if (p !== -1 && v > n.MAX_HASH_FUNCS)
        throw new Error("Bloom filter size violates policy limits!");
      return new this(E, v, -1, p);
    }
    /**
     * Ensure the filter is within the size limits.
     * @returns {Boolean}
     */
    isWithinConstraints() {
      return !(this.size > n.MAX_BLOOM_FILTER_SIZE * 8 || this.n > n.MAX_HASH_FUNCS);
    }
    /**
     * Get serialization size.
     * @returns {Number}
     */
    getSize() {
      return c.sizeVarBytes(this.filter) + 9;
    }
    /**
     * Write filter to buffer writer.
     * @param {BufferWriter} bw
     */
    write(s) {
      return s.writeVarBytes(this.filter), s.writeU32(this.n), s.writeU32(this.tweak), s.writeU8(this.update), s;
    }
    /**
     * Inject properties from buffer reader.
     * @private
     * @param {BufferReader} br
     */
    read(s) {
      if (this.filter = s.readVarBytes(), this.size = this.filter.length * 8, this.n = s.readU32(), this.tweak = s.readU32(), this.update = s.readU8(), this.update > 2)
        throw new Error("Invalid update flag.");
      return this;
    }
  }
  n.MAX_BLOOM_FILTER_SIZE = 36e3, n.MAX_HASH_FUNCS = 50, n.flags = {
    /**
     * Never update the filter with outpoints.
     */
    NONE: 0,
    /**
     * Always update the filter with outpoints.
     */
    ALL: 1,
    /**
     * Only update the filter with outpoints if it is
     * "asymmetric" in terms of addresses (pubkey/multisig).
     */
    PUBKEY_ONLY: 2
  }, n.flagsByVal = [
    "NONE",
    "ALL",
    "PUBKEY_ONLY"
  ];
  function u(a, s) {
    return typeof a != "string" ? (e(k.isBuffer(a), "value", "buffer"), a) : (e(typeof s == "string", "enc", "string"), k.from(a, s));
  }
  return Bu = n, Bu;
}
var Mu, Y4;
function Sx() {
  if (Y4) return Mu;
  Y4 = 1;
  const { enforce: e } = $e(), { encoding: c } = At(), d = Il(), w = k.alloc(0);
  class g {
    /**
     * Create a rolling bloom filter.
     * @constructor
     * @param {Number} items - Expected number of items.
     * @param {Number} rate - False positive rate (0.0-1.0).
     */
    constructor(i, p) {
      this.entries = 0, this.generation = 1, this.n = 0, this.limit = 0, this.size = 0, this.items = 0, this.tweak = 0, this.filter = w, i != null && this.fromRate(i, p);
    }
    /**
     * Inject properties from items and FPR.
     * @private
     * @param {Number} items - Expected number of items.
     * @param {Number} rate - False positive rate (0.0-1.0).
     * @returns {RollingFilter}
     */
    fromRate(i, p) {
      e(Number.isSafeInteger(i) && i > 0, "items", "integer"), e(typeof p == "number" && isFinite(p), "rate", "number"), e(p >= 0 && p <= 1, "rate", "range between 0.1 and 1.0.");
      const m = Math.log(p), E = Math.max(1, Math.min(Math.round(m / Math.log(0.5)), 50)), v = (i + 1) / 2 | 0, b = v * 3;
      let h = -1 * E * b / Math.log(1 - Math.exp(m / E));
      h = Math.ceil(h), i = ((h + 63) / 64 | 0) << 1, i >>>= 0, i = Math.max(1, i);
      const o = Math.random() * 4294967296 >>> 0, S = k.alloc(i * 8, 0);
      return this.n = E, this.limit = v, this.size = h, this.items = i, this.tweak = o, this.filter = S, this;
    }
    /**
     * Instantiate rolling filter from items and FPR.
     * @param {Number} items - Expected number of items.
     * @param {Number} rate - False positive rate (0.0-1.0).
     * @returns {RollingFilter}
     */
    static fromRate(i, p) {
      return new this().fromRate(i, p);
    }
    /**
     * Perform the mumur3 hash on data.
     * @param {Buffer} value
     * @param {Number} seed
     * @returns {Number}
     */
    hash(i, p) {
      return d.tweak(i, p, this.tweak);
    }
    /**
     * Reset the filter.
     */
    reset() {
      this.entries !== 0 && (this.entries = 0, this.generation = 1, this.filter.fill(0));
    }
    /**
     * Add data to the filter.
     * @param {Buffer|String}
     * @param {String?} enc - Can be any of the Buffer object's encodings.
     */
    add(i, p) {
      const m = a(i, p);
      if (this.entries === this.limit) {
        this.entries = 0, this.generation += 1, this.generation === 4 && (this.generation = 1);
        const E = (this.generation & 1) * 4294967295, v = (this.generation >>> 1) * 4294967295;
        for (let b = 0; b < this.items; b += 2) {
          const h = b * 8, o = (b + 1) * 8, S = n(this.filter, h), H = n(this.filter, o), j = S.hi ^ E | H.hi ^ v, J = S.lo ^ E | H.lo ^ v;
          S.hi &= j, S.lo &= J, H.hi &= j, H.lo &= J, u(this.filter, S, h), u(this.filter, H, o);
        }
      }
      this.entries += 1;
      for (let E = 0; E < this.n; E++) {
        const v = this.hash(m, E), b = v & 63, h = (v >>> 6) % this.items, o = (h & -2) * 8, S = (h | 1) * 8, H = b % 8, j = (b - H) / 8;
        this.filter[o + j] &= ~(1 << H), this.filter[o + j] |= (this.generation & 1) << H, this.filter[S + j] &= ~(1 << H), this.filter[S + j] |= this.generation >>> 1 << H;
      }
    }
    /**
     * Test whether data is present in the filter.
     * @param {Buffer|String} value
     * @param {String?} enc - Can be any of the Buffer object's encodings.
     * @returns {Boolean}
     */
    test(i, p) {
      if (this.entries === 0)
        return !1;
      const m = a(i, p);
      for (let E = 0; E < this.n; E++) {
        const v = this.hash(m, E), b = v & 63, h = (v >>> 6) % this.items, o = (h & -2) * 8, S = (h | 1) * 8, H = b % 8, j = (b - H) / 8, J = this.filter[o + j] >>> H & 1, N = this.filter[S + j] >>> H & 1;
        if ((J | N) === 0)
          return !1;
      }
      return !0;
    }
    /**
     * Test whether data is present in the
     * filter and potentially add data.
     * @param {Buffer|String} value
     * @param {String?} enc - Can be any of the Buffer object's encodings.
     * @returns {Boolean} Whether data was added.
     */
    added(i, p) {
      const m = a(i, p);
      return this.test(m) ? !1 : (this.add(m), !0);
    }
  }
  class f {
    constructor(i, p) {
      this.hi = i, this.lo = p;
    }
  }
  function n(s, i) {
    const p = c.readU32(s, i + 4), m = c.readU32(s, i);
    return new f(p, m);
  }
  function u(s, i, p) {
    c.writeU32(s, i.hi, p + 4), c.writeU32(s, i.lo, p);
  }
  function a(s, i) {
    return typeof s != "string" ? (e(k.isBuffer(s), "value", "buffer"), s) : (e(typeof i == "string", "enc", "string"), k.from(s, i));
  }
  return Mu = g, Mu;
}
/*!
 * bfilter.js - bloom filters for javascript
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var X4;
function s7() {
  if (X4) return vs;
  X4 = 1;
  const e = vx(), c = Sx();
  return vs.BloomFilter = e, vs.RollingFilter = c, vs;
}
var Ss = {}, Nu, J4;
function Ex() {
  if (J4) return Nu;
  J4 = 1;
  const e = $e();
  class c {
    /**
     * Create a lock.
     * @constructor
     * @param {Boolean?} named - Whether to
     * maintain a map of queued jobs by job name.
     * @param {Function?} CustomMap
     */
    constructor(f = !1, n) {
      e(typeof f == "boolean"), e(!n || typeof n == "function"), this.named = f, this.jobs = [], this.busy = !1, this.destroyed = !1, this.map = n ? new n() : /* @__PURE__ */ new Map(), this.current = null, this.unlocker = this.unlock.bind(this);
    }
    /**
     * Create a closure scoped lock.
     * @param {Boolean?} named
     * @param {Function?} CustomMap
     * @returns {Function} Lock method.
     */
    static create(f, n) {
      const u = new c(f, n);
      return function(s, i) {
        return u.lock(s, i);
      };
    }
    /**
     * Test whether the lock has a pending
     * job or a job in progress (by name).
     * @param {String} name
     * @returns {Boolean}
     */
    has(f) {
      if (e(this.named, "Must use named jobs."), this.current) {
        if (k.isBuffer(f)) {
          if (this.current.equals(f))
            return !0;
        } else if (this.current === f)
          return !0;
      }
      return this.pending(f);
    }
    /**
     * Test whether the lock has
     * a pending job by name.
     * @param {String} name
     * @returns {Boolean}
     */
    pending(f) {
      e(this.named, "Must use named jobs.");
      const n = this.map.get(f);
      return n == null ? !1 : n > 0;
    }
    /**
     * Lock the parent object and all its methods
     * which use the lock. Begin to queue calls.
     * @param {String?} name - Job name.
     * @param {Boolean?} force - Bypass the lock.
     * @returns {Promise} - Returns {Function}, must be
     * called once the method finishes executing in order
     * to resolve the queue.
     */
    lock(f, n) {
      let u, a;
      if (this.named ? (u = f || null, a = n || !1) : (u = null, a = f || !1), this.destroyed)
        return Promise.reject(new Error("Lock is destroyed."));
      if (a)
        return e(this.busy), Promise.resolve(w);
      if (this.busy) {
        if (u) {
          const s = this.map.get(u) || 0;
          this.map.set(u, s + 1);
        }
        return new Promise((s, i) => {
          this.jobs.push(new d(s, i, u));
        });
      }
      return this.busy = !0, this.current = u, Promise.resolve(this.unlocker);
    }
    /**
     * The actual unlock callback.
     * @private
     */
    unlock() {
      if (e(this.destroyed || this.busy), this.busy = !1, this.current = null, this.jobs.length === 0)
        return;
      e(!this.destroyed);
      const f = this.jobs.shift();
      if (f.name) {
        let n = this.map.get(f.name);
        e(n > 0), --n === 0 ? this.map.delete(f.name) : this.map.set(f.name, n);
      }
      this.busy = !0, this.current = f.name, f.resolve(this.unlocker);
    }
    /**
     * Destroy the lock. Purge all pending calls.
     */
    destroy() {
      e(!this.destroyed, "Lock is already destroyed."), this.destroyed = !0;
      const f = this.jobs;
      this.busy = !1, this.jobs = [], this.map.clear(), this.current = null;
      for (const n of f)
        n.reject(new Error("Lock was destroyed."));
    }
  }
  class d {
    /**
     * Create a lock job.
     * @constructor
     * @param {Function} resolve
     * @param {Function} reject
     * @param {String?} name
     */
    constructor(f, n, u) {
      this.resolve = f, this.reject = n, this.name = u || null;
    }
  }
  function w() {
  }
  return Nu = c, Nu;
}
/*!
 * maplock.js - lock and queue for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var qu, G4;
function Ix() {
  if (G4) return qu;
  G4 = 1;
  const e = $e();
  class c {
    /**
     * Create a mapped lock.
     * @param {Function?} CustomMap
     * @param {Function?} CustomSet
     * @constructor
     */
    constructor(f, n) {
      e(!f || typeof f == "function"), e(!n || typeof n == "function"), this.Map = f || Map, this.Set = n || Set, this.jobs = new this.Map(), this.busy = new this.Set(), this.destroyed = !1;
    }
    /**
     * Create a closure scoped lock.
     * @param {Function?} CustomMap
     * @param {Function?} CustomSet
     * @returns {Function} Lock method.
     */
    static create(f, n) {
      const u = new c(f, n);
      return function(s, i) {
        return u.lock(s, i);
      };
    }
    /**
     * Test whether the lock has a pending
     * job or a job in progress (by name).
     * @param {String} name
     * @returns {Boolean}
     */
    has(f) {
      return this.busy.has(f);
    }
    /**
     * Test whether the lock has
     * a pending job by name.
     * @param {String} name
     * @returns {Boolean}
     */
    pending(f) {
      return this.jobs.has(f);
    }
    /**
     * Lock the parent object and all its methods
     * which use the lock with a specified key.
     * Begin to queue calls.
     * @param {String|Number} key
     * @param {Boolean} [force=false] - Force a call.
     * @returns {Promise} - Returns {Function}, must be
     * called once the method finishes executing in order
     * to resolve the queue.
     */
    lock(f, n = !1) {
      return this.destroyed ? Promise.reject(new Error("Lock is destroyed.")) : f == null ? Promise.resolve(w) : n ? (e(this.busy.has(f)), Promise.resolve(w)) : this.busy.has(f) ? new Promise((u, a) => {
        this.jobs.has(f) || this.jobs.set(f, []), this.jobs.get(f).push(new d(u, a));
      }) : (this.busy.add(f), Promise.resolve(this._unlock(f)));
    }
    /**
     * Create an unlock callback.
     * @private
     * @param {String} key
     * @returns {Function} Unlocker.
     */
    _unlock(f) {
      const n = this;
      return function u() {
        n.unlock(f, u);
      };
    }
    /**
     * Unlock the mutex.
     * @param {String|Number} key
     * @param {Function} [unlocker=undefined]
     */
    unlock(f, n = void 0) {
      const u = this.jobs.get(f);
      if (e(this.destroyed || this.busy.has(f)), this.busy.delete(f), !u)
        return;
      e(!this.destroyed);
      const a = u.shift();
      e(a), u.length === 0 && this.jobs.delete(f), this.busy.add(f), a.resolve(n);
    }
    /**
     * Destroy the lock. Purge all pending calls.
     */
    destroy() {
      e(!this.destroyed, "Lock is already destroyed.");
      const f = this.jobs;
      this.destroyed = !0, this.jobs = new this.Map(), this.busy = new this.Set();
      for (const n of f.values())
        for (const u of n)
          u.reject(new Error("Lock was destroyed."));
    }
  }
  class d {
    /**
     * Create a lock job.
     * @constructor
     * @param {Function} resolve
     * @param {Function} reject
     */
    constructor(f, n) {
      this.resolve = f, this.reject = n;
    }
  }
  function w() {
  }
  return qu = c, qu;
}
/*!
 * bmutex.js - lock and queue for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var W4;
function Al() {
  return W4 || (W4 = 1, Ss.Lock = Ex(), Ss.MapLock = Ix()), Ss;
}
var Gi = {}, zu, Z4;
function Ax() {
  if (Z4) return zu;
  Z4 = 1;
  const e = $e(), c = k.alloc(1, 0), d = k.alloc(255, 255);
  class w {
    /**
     * Create a DB instance.
     * @constructor
     * @param {Function} backend - Database backend.
     * @param {String} location - File location.
     * @param {Object?} options - Leveldown options.
     */
    constructor(o, S, H) {
      e(typeof o == "function", "Backend is required."), e(typeof S == "string", "Filename is required."), this.options = new a(H), this.backend = o, this.location = S, this.loading = !1, this.closing = !1, this.loaded = !1, this.binding = null, this.leveldown = !1, this.init();
    }
    /**
     * Initialize the database.
     * @private
     */
    init() {
      const o = this.backend;
      o.leveldown ? (this.binding = new o(this.location), this.leveldown = !0) : this.binding = new o(this.location);
    }
    /**
     * Open the database.
     * @returns {Promise}
     */
    async open() {
      if (this.loaded)
        throw new Error("Database is already open.");
      e(!this.loading), e(!this.closing);
      try {
        this.loading = !0, await this.load();
      } finally {
        this.loading = !1;
      }
      this.loaded = !0;
    }
    /**
     * Close the database.
     * @returns {Promise}
     */
    async close() {
      if (!this.loaded)
        throw new Error("Database is already closed.");
      e(!this.loading), e(!this.closing);
      try {
        this.loaded = !1, this.closing = !0, await this.unload();
      } catch (o) {
        throw this.loaded = !0, o;
      } finally {
        this.closing = !1;
      }
    }
    /**
     * Open the database.
     * @private
     * @returns {Promise}
     */
    load() {
      return new Promise((o, S) => {
        this.binding.open(this.options, p(o, S));
      });
    }
    /**
     * Close the database.
     * @private
     * @returns {Promise}
     */
    unload() {
      return new Promise((o, S) => {
        this.binding.close(p(o, S));
      });
    }
    /**
     * Destroy the database.
     * @returns {Promise}
     */
    destroy() {
      return new Promise((o, S) => {
        if (this.loaded || this.closing) {
          S(new Error("Cannot destroy open database."));
          return;
        }
        if (!this.backend.destroy) {
          S(new Error("Cannot destroy (method not available)."));
          return;
        }
        this.backend.destroy(this.location, p(o, S));
      });
    }
    /**
     * Repair the database.
     * @returns {Promise}
     */
    repair() {
      return new Promise((o, S) => {
        if (this.loaded || this.closing) {
          S(new Error("Cannot repair open database."));
          return;
        }
        if (!this.backend.repair) {
          S(new Error("Cannot repair (method not available)."));
          return;
        }
        this.backend.repair(this.location, p(o, S));
      });
    }
    /**
     * Backup the database.
     * @param {String} path
     * @returns {Promise}
     */
    backup(o) {
      return this.binding.backup ? new Promise((S, H) => {
        if (!this.loaded) {
          H(new Error("Database is closed."));
          return;
        }
        this.binding.backup(o, p(S, H));
      }) : this.clone(o);
    }
    /**
     * Create a bucket.
     * @param {Buffer} prefix
     * @returns {Bucket}
     */
    bucket(o) {
      return new f(this, o);
    }
    /**
     * Get root bucket.
     * @returns {Bucket}
     */
    root() {
      return this;
    }
    /**
     * Get child bucket.
     * @param {Buffer} prefix
     * @returns {Bucket}
     */
    child(o) {
      return this.bucket(o);
    }
    /**
     * Wrap a batch or iterator.
     * @param {Object} obj
     * @returns {Object}
     */
    wrap(o) {
      return o.root();
    }
    /**
     * Retrieve a record from the database.
     * @param {Buffer} key
     * @returns {Promise} - Returns Buffer.
     */
    get(o) {
      return new Promise((S, H) => {
        if (!this.loaded) {
          H(new Error("Database is closed."));
          return;
        }
        if (!k.isBuffer(o)) {
          H(new Error("Key must be a buffer."));
          return;
        }
        this.binding.get(o, (j, J) => {
          if (j) {
            if (i(j)) {
              S(null);
              return;
            }
            H(j);
            return;
          }
          S(J);
        });
      });
    }
    /**
     * Store a record in the database.
     * @param {Buffer} key
     * @param {Buffer} value
     * @returns {Promise}
     */
    put(o, S) {
      return S == null && (S = c), new Promise((H, j) => {
        if (!this.loaded) {
          j(new Error("Database is closed."));
          return;
        }
        if (!k.isBuffer(o) || !k.isBuffer(S)) {
          j(new Error("Key and value must be buffers."));
          return;
        }
        this.binding.put(o, S, p(H, j));
      });
    }
    /**
     * Remove a record from the database.
     * @param {Buffer} key
     * @returns {Promise}
     */
    del(o) {
      return new Promise((S, H) => {
        if (!this.loaded) {
          H(new Error("Database is closed."));
          return;
        }
        if (!k.isBuffer(o)) {
          H(new Error("Key must be a buffer."));
          return;
        }
        this.binding.del(o, p(S, H));
      });
    }
    /**
     * Create an atomic batch.
     * @returns {Batch}
     */
    batch() {
      if (!this.loaded)
        throw new Error("Database is closed.");
      return new g(this.binding.batch());
    }
    /**
     * Create an iterator.
     * @param {Object} options
     * @returns {Iterator}
     */
    iterator(o) {
      if (!this.loaded)
        throw new Error("Database is closed.");
      return new n(this, o);
    }
    /**
     * Get a database property.
     * @param {String} name - Property name.
     * @returns {String}
     */
    getProperty(o) {
      if (!this.loaded)
        throw new Error("Database is closed.");
      return this.binding.getProperty ? this.binding.getProperty(o) : "";
    }
    /**
     * Calculate approximate database size.
     * @param {Buffer|null} start - Start key.
     * @param {Buffer|null} end - End key.
     * @returns {Promise} - Returns Number.
     */
    approximateSize(o, S) {
      return o == null && (o = c), S == null && (S = d), new Promise((H, j) => {
        if (!this.loaded) {
          j(new Error("Database is closed."));
          return;
        }
        if (!this.binding.approximateSize) {
          j(new Error("Cannot get size."));
          return;
        }
        if (!k.isBuffer(o) || !k.isBuffer(S)) {
          j(new Error("Start and end must be buffers."));
          return;
        }
        this.binding.approximateSize(o, S, p(H, j));
      });
    }
    /**
     * Compact range of keys.
     * @param {Buffer|null} start - Start key.
     * @param {Buffer|null} end - End key.
     * @returns {Promise}
     */
    compactRange(o, S) {
      return o == null && (o = c), S == null && (S = d), new Promise((H, j) => {
        if (!this.loaded) {
          j(new Error("Database is closed."));
          return;
        }
        if (!this.binding.compactRange) {
          H();
          return;
        }
        if (!k.isBuffer(o) || !k.isBuffer(S)) {
          j(new Error("Start and end must be buffers."));
          return;
        }
        this.binding.compactRange(o, S, p(H, j));
      });
    }
    /**
     * Test whether a key exists.
     * @param {Buffer} key
     * @returns {Promise} - Returns Boolean.
     */
    async has(o) {
      return await this.get(o) != null;
    }
    /**
     * Collect all keys from iterator options.
     * @param {Object} options - Iterator options.
     * @returns {Promise} - Returns Array.
     */
    async range(o) {
      return o == null && (o = {}), this.iterator({
        gt: o.gt,
        lt: o.lt,
        gte: o.gte,
        lte: o.lte,
        limit: o.limit,
        reverse: o.reverse,
        keys: !0,
        values: !0
      }).range(o.parse);
    }
    /**
     * Collect all keys from iterator options.
     * @param {Object} options - Iterator options.
     * @returns {Promise} - Returns Array.
     */
    async keys(o) {
      return o == null && (o = {}), this.iterator({
        gt: o.gt,
        lt: o.lt,
        gte: o.gte,
        lte: o.lte,
        limit: o.limit,
        reverse: o.reverse,
        keys: !0,
        values: !1
      }).keys(o.parse);
    }
    /**
     * Collect all keys from iterator options.
     * @param {Object} options - Iterator options.
     * @returns {Promise} - Returns Array.
     */
    async values(o) {
      return o == null && (o = {}), this.iterator({
        gt: o.gt,
        lt: o.lt,
        gte: o.gte,
        lte: o.lte,
        limit: o.limit,
        reverse: o.reverse,
        keys: !1,
        values: !0
      }).values(o.parse);
    }
    /**
     * Dump database (for debugging).
     * @returns {Promise} - Returns Object.
     */
    async dump() {
      const o = /* @__PURE__ */ Object.create(null), S = await this.range();
      for (const H of S) {
        const j = H.key.toString("hex"), J = H.value.toString("hex");
        o[j] = J;
      }
      return o;
    }
    /**
     * Write and assert a version number for the database.
     * @param {Buffer} key
     * @param {String} name
     * @param {Number} version
     * @returns {Promise}
     */
    async verify(o, S, H) {
      e(typeof S == "string"), e(H >>> 0 === H);
      const j = await this.get(o);
      if (!j) {
        const N = k.alloc(S.length + 4);
        N.write(S, 0, "ascii"), N.writeUInt32LE(H, S.length);
        const z = this.batch();
        z.put(o, N), await z.write();
        return;
      }
      if (j.length !== S.length + 4)
        throw new Error(b(S));
      if (j.toString("ascii", 0, S.length) !== S)
        throw new Error(b(S));
      if (j.readUInt32LE(S.length) !== H)
        throw new Error(b(S));
    }
    /**
     * Clone the database.
     * @param {String} path
     * @returns {Promise}
     */
    async clone(o) {
      if (!this.loaded)
        throw new Error("Database is closed.");
      const S = new a(this.options);
      S.createIfMissing = !0, S.errorIfExists = !0;
      const H = new w(this.backend, o, S);
      await H.open();
      try {
        await this.cloneTo(H);
      } finally {
        await H.close();
      }
    }
    /**
     * Clone the database.
     * @param {Object} db
     * @returns {Promise}
     */
    async cloneTo(o) {
      const H = this.iterator({
        keys: !0,
        values: !0
      });
      let j = o.batch(), J = 0;
      return await H.each(async (N, z) => {
        j.put(N, z), J += N.length + 80, J += z.length + 80, J >= 268435456 && (await j.write(), j = o.batch(), J = 0);
      }), j.write();
    }
  }
  class g {
    /**
     * Create a batch.
     * @constructor
     * @ignore
     * @param {Object} binding
     * @param {Buffer} [prefix=null]
     */
    constructor(o, S) {
      this.binding = o, this.prefix = S || null;
    }
    /**
     * Get bucket.
     * @returns {Batch}
     */
    bucket(o) {
      return new g(this.binding, o);
    }
    /**
     * Get root batch.
     * @returns {Batch}
     */
    root() {
      return this.bucket(null);
    }
    /**
     * Get child batch.
     * @param {Buffer} prefix
     * @returns {Batch}
     */
    child(o) {
      return this.bucket(E(this.prefix, o));
    }
    /**
     * Wrap a batch or iterator.
     * @param {Object} obj
     * @returns {Object}
     */
    wrap(o) {
      return o.bucket(this.prefix);
    }
    /**
     * Write a value to the batch.
     * @param {Buffer} key
     * @param {Buffer} value
     */
    put(o, S) {
      return S == null && (S = c), e(k.isBuffer(S), "Value must be a buffer."), this.binding.put(E(this.prefix, o), S), this;
    }
    /**
     * Delete a value from the batch.
     * @param {Buffer} key
     */
    del(o) {
      return this.binding.del(E(this.prefix, o)), this;
    }
    /**
     * Write batch to database.
     * @returns {Promise}
     */
    write() {
      return new Promise((o, S) => {
        this.binding.write(p(o, S));
      });
    }
    /**
     * Clear the batch.
     */
    clear() {
      return this.binding.clear(), this;
    }
  }
  class f {
    /**
     * Create a bucket.
     * @constructor
     * @ignore
     * @param {DB} db
     * @param {Batch} batch
     * @param {Buffer} prefix
     */
    constructor(o, S) {
      e(
        S == null || k.isBuffer(S),
        "Prefix must be a buffer."
      ), this.db = o, this.prefix = S || null;
    }
    /**
     * Get bucket.
     * @param {Buffer} prefix
     * @returns {Bucket}
     */
    bucket(o) {
      return new f(this.db, o);
    }
    /**
     * Get root bucket.
     * @returns {Bucket}
     */
    root() {
      return this.bucket(null);
    }
    /**
     * Get child bucket.
     * @param {Buffer} prefix
     * @returns {Bucket}
     */
    child(o) {
      return this.bucket(E(this.prefix, o));
    }
    /**
     * Wrap a batch or iterator.
     * @param {Object} obj
     * @returns {Object}
     */
    wrap(o) {
      return o.bucket(this.prefix);
    }
    /**
     * Create a batch.
     * @returns {Batch}
     */
    batch() {
      return new g(this.db.binding.batch(), this.prefix);
    }
    /**
     * Get a value from the bucket.
     * @param {Buffer} key
     * @returns {Promise}
     */
    has(o) {
      return this.db.has(E(this.prefix, o));
    }
    /**
     * Get a value from the bucket.
     * @param {Buffer} key
     * @returns {Promise}
     */
    get(o) {
      return this.db.get(E(this.prefix, o));
    }
    /**
     * Create an iterator.
     * @param {Object} options
     * @returns {Iterator}
     */
    iterator(o) {
      return new n(this.db, o, this.prefix);
    }
    /**
     * Collect all keys from iterator options.
     * @param {Object} options - Iterator options.
     * @returns {Promise} - Returns Array.
     */
    async range(o) {
      return o == null && (o = {}), this.iterator({
        gt: o.gt,
        lt: o.lt,
        gte: o.gte,
        lte: o.lte,
        limit: o.limit,
        reverse: o.reverse,
        keys: !0,
        values: !0
      }).range(o.parse);
    }
    /**
     * Collect all keys from iterator options.
     * @param {Object} options - Iterator options.
     * @returns {Promise} - Returns Array.
     */
    async keys(o) {
      return o == null && (o = {}), this.iterator({
        gt: o.gt,
        lt: o.lt,
        gte: o.gte,
        lte: o.lte,
        limit: o.limit,
        reverse: o.reverse,
        keys: !0,
        values: !1
      }).keys(o.parse);
    }
    /**
     * Collect all keys from iterator options.
     * @param {Object} options - Iterator options.
     * @returns {Promise} - Returns Array.
     */
    async values(o) {
      return o == null && (o = {}), this.iterator({
        gt: o.gt,
        lt: o.lt,
        gte: o.gte,
        lte: o.lte,
        limit: o.limit,
        reverse: o.reverse,
        keys: !1,
        values: !0
      }).values(o.parse);
    }
  }
  class n {
    /**
     * Create an iterator.
     * @constructor
     * @ignore
     * @param {DB} db
     * @param {Object} [options=null]
     * @param {Buffer} [prefix=null]
     */
    constructor(o, S, H) {
      this.db = o, this.options = S || null, this.prefix = H || null, this.binding = null, this.cache = [], this.finished = !1, this.key = null, this.value = null;
    }
    /**
     * Start the iterator.
     */
    start() {
      if (this.binding)
        return;
      const o = new s(this.options);
      this.prefix != null && (e(k.isBuffer(this.prefix)), o.gte != null && (o.gte = E(this.prefix, o.gte)), o.lte != null && (o.lte = E(this.prefix, o.lte)), o.gt != null && (o.gt = E(this.prefix, o.gt)), o.lt != null && (o.lt = E(this.prefix, o.lt)), o.gt == null && o.gte == null && (o.gt = this.prefix), o.lt == null && o.lte == null && (o.lt = v(this.prefix))), this.binding = this.db.binding.iterator(o);
    }
    /**
     * Get bucket.
     * @param {Buffer} prefix
     * @returns {Iterator}
     */
    bucket(o) {
      return e(!this.binding), new n(this.db, this.options, o);
    }
    /**
     * Get root iterator.
     * @returns {Iterator}
     */
    root() {
      return this.bucket(null);
    }
    /**
     * Get child iterator.
     * @param {Buffer} prefix
     * @returns {Iterator}
     */
    child(o) {
      return this.bucket(E(this.prefix, o));
    }
    /**
     * Wrap a batch or iterator.
     * @param {Object} obj
     * @returns {Object}
     */
    wrap(o) {
      return o.bucket(this.prefix);
    }
    /**
     * Clean up iterator.
     * @private
     */
    cleanup() {
      this.cache = [], this.finished = !0, this.key = null, this.value = null;
    }
    /**
     * For each.
     * @returns {Promise}
     */
    async each(o) {
      for (e(typeof o == "function"); !this.finished; )
        for (await this.read(); this.cache.length > 0; ) {
          const S = m(this.prefix, this.cache.pop()), H = this.cache.pop();
          let j = null;
          try {
            j = o(S, H), j instanceof Promise && (j = await j);
          } catch (J) {
            throw await this.end(), J;
          }
          if (j === !1)
            return this.end();
        }
      return this.end();
    }
    /**
     * Seek to the next key.
     * @returns {Promise}
     */
    async next() {
      return this.finished || this.cache.length === 0 && await this.read(), this.cache.length > 0 ? (this.key = m(this.prefix, this.cache.pop()), this.value = this.cache.pop(), !0) : (e(this.finished), this.cleanup(), !1);
    }
    /**
     * Seek to the next key.
     * @private
     * @param {Function} callback
     */
    _read(o) {
      if (this.db.leveldown) {
        this.binding.next(o);
        return;
      }
      this.binding.next((S, H, j) => {
        if (S) {
          o(S);
          return;
        }
        if (H === void 0 && j === void 0) {
          o(null, [], !0);
          return;
        }
        o(null, [j, H], !1);
      });
    }
    /**
     * Seek to the next key (buffer values).
     * @private
     * @returns {Promise}
     */
    read() {
      return new Promise((o, S) => {
        if (!this.binding)
          try {
            this.start();
          } catch (H) {
            S(H);
            return;
          }
        this._read((H, j, J) => {
          if (H) {
            this.cleanup(), this.binding.end(() => S(H));
            return;
          }
          this.cache = j, this.finished = J, o();
        });
      });
    }
    /**
     * Seek to an arbitrary key.
     * @param {Buffer} key
     */
    seek(o) {
      return e(k.isBuffer(o), "Key must be a buffer."), this.start(), this.binding.seek(o), this;
    }
    /**
     * End the iterator.
     * @returns {Promise}
     */
    end() {
      return new Promise((o, S) => {
        if (!this.binding)
          try {
            this.start();
          } catch (H) {
            S(H);
            return;
          }
        this.cleanup(), this.binding.end(p(o, S));
      });
    }
    /**
     * Collect all keys and values from iterator options.
     * @param {Function} parse
     * @returns {Promise} - Returns Array.
     */
    async range(o) {
      e(!o || typeof o == "function");
      const S = [];
      return await this.each((H, j) => {
        if (o) {
          const J = o(H, j);
          J != null && S.push(J);
        } else
          S.push(new u(H, j));
      }), S;
    }
    /**
     * Collect all keys from iterator options.
     * @param {Function} parse
     * @returns {Promise} - Returns Array.
     */
    async keys(o) {
      e(!o || typeof o == "function");
      const S = [];
      return await this.each((H, j) => {
        o && (H = o(H)), H != null && S.push(H);
      }), S;
    }
    /**
     * Collect all values from iterator options.
     * @param {Function} parse
     * @returns {Promise} - Returns Array.
     */
    async values(o) {
      e(!o || typeof o == "function");
      const S = [];
      return await this.each((H, j) => {
        o && (j = o(j)), j != null && S.push(j);
      }), S;
    }
  }
  class u {
    /**
     * Create an iterator item.
     * @constructor
     * @ignore
     * @param {Buffer} key
     * @param {Buffer} value
     * @property {Buffer} key
     * @property {Buffer} value
     */
    constructor(o, S) {
      this.key = o, this.value = S;
    }
  }
  class a {
    /**
     * Create DBOptions.
     * @constructor
     * @ignore
     * @param {Object} options
     */
    constructor(o) {
      this.createIfMissing = !0, this.errorIfExists = !1, this.compression = !0, this.cacheSize = 8 << 20, this.writeBufferSize = 4 << 20, this.maxOpenFiles = 64, this.maxFileSize = 2 << 20, this.paranoidChecks = !1, this.memory = !1, o && this.fromOptions(o);
    }
    /**
     * Inject properties from options.
     * @private
     * @param {Object} options
     * @returns {DBOptions}
     */
    fromOptions(o) {
      return e(o, "Options are required."), o.createIfMissing != null && (e(
        typeof o.createIfMissing == "boolean",
        "`createIfMissing` must be a boolean."
      ), this.createIfMissing = o.createIfMissing), o.errorIfExists != null && (e(
        typeof o.errorIfExists == "boolean",
        "`errorIfExists` must be a boolean."
      ), this.errorIfExists = o.errorIfExists), o.compression != null && (e(
        typeof o.compression == "boolean",
        "`compression` must be a boolean."
      ), this.compression = o.compression), o.cacheSize != null && (e(
        typeof o.cacheSize == "number",
        "`cacheSize` must be a number."
      ), e(o.cacheSize >= 0), this.cacheSize = Math.floor(o.cacheSize / 2), this.writeBufferSize = Math.floor(o.cacheSize / 4)), o.maxFiles != null && (e(
        typeof o.maxFiles == "number",
        "`maxFiles` must be a number."
      ), e(o.maxFiles >= 0), this.maxOpenFiles = o.maxFiles), o.maxFileSize != null && (e(
        typeof o.maxFileSize == "number",
        "`maxFileSize` must be a number."
      ), e(o.maxFileSize >= 0), this.maxFileSize = o.maxFileSize), o.paranoidChecks != null && (e(
        typeof o.paranoidChecks == "boolean",
        "`paranoidChecks` must be a boolean."
      ), this.paranoidChecks = o.paranoidChecks), o.memory != null && (e(
        typeof o.memory == "boolean",
        "`memory` must be a boolean."
      ), this.memory = o.memory), this;
    }
  }
  class s {
    /**
     * Create iterator options.
     * @constructor
     * @ignore
     * @param {Object} options
     */
    constructor(o) {
      this.gte = null, this.lte = null, this.gt = null, this.lt = null, this.keys = !0, this.values = !1, this.fillCache = !1, this.keyAsBuffer = !0, this.valueAsBuffer = !0, this.reverse = !1, this.highWaterMark = 16 * 1024, o && this.fromOptions(o);
    }
    /**
     * Inject properties from options.
     * @private
     * @param {Object} options
     * @returns {IteratorOptions}
     */
    fromOptions(o) {
      if (e(o, "Options are required."), o.gte != null && (e(k.isBuffer(o.gte), "`gte` must be a buffer."), this.gte = o.gte), o.lte != null && (e(k.isBuffer(o.lte), "`lte` must be a buffer."), this.lte = o.lte), o.gt != null && (e(k.isBuffer(o.gt), "`gt` must be a buffer."), this.gt = o.gt), o.lt != null && (e(k.isBuffer(o.lt), "`lt` must be a buffer."), this.lt = o.lt), o.keys != null && (e(typeof o.keys == "boolean"), this.keys = o.keys), o.values != null && (e(typeof o.values == "boolean"), this.values = o.values), o.fillCache != null && (e(typeof o.fillCache == "boolean"), this.fillCache = o.fillCache), o.reverse != null && (e(typeof o.reverse == "boolean"), this.reverse = o.reverse), o.limit != null && (e(typeof o.limit == "number"), e(o.limit >= 0), this.limit = o.limit), !this.keys && !this.values)
        throw new Error("Keys and/or values must be chosen.");
      return this;
    }
  }
  function i(h) {
    return h ? h.notFound || h.type === "NotFoundError" || /not\s*found/i.test(h.message) : !1;
  }
  function p(h, o) {
    return function(S, H) {
      if (S) {
        o(S);
        return;
      }
      h(H);
    };
  }
  function m(h, o) {
    return o == null || (e(k.isBuffer(o), "Key must be a buffer."), o.length === 0) || h == null ? o : (e(k.isBuffer(h)), e(o.length >= h.length), o.slice(h.length));
  }
  function E(h, o) {
    if (e(k.isBuffer(o), "Key must be a buffer."), h == null)
      return o;
    e(k.isBuffer(h));
    const S = k.allocUnsafe(h.length + o.length);
    return h.copy(S, 0), o.copy(S, h.length), S;
  }
  function v(h) {
    if (h.length === 0)
      return null;
    const o = k.from(h);
    let S = o.length - 1;
    for (; S >= 0 && (o[S] += 1, o[S] === 0); S--)
      ;
    return S === -1 ? null : o;
  }
  function b(h) {
    return `Database version mismatch for database: "${h}". Please run a data migration before opening.`;
  }
  return zu = w, zu;
}
var Tu, Q4;
function Ox() {
  if (Q4) return Tu;
  Q4 = 1;
  const e = $e(), c = /* @__PURE__ */ Object.create(null), d = k.alloc(0), w = k.alloc(255, 255), g = {
    char: {
      min: "\0",
      max: "",
      dynamic: !1,
      size(N) {
        return 1;
      },
      read(N, z) {
        return h(z + 1 <= N.length), String.fromCharCode(N[z]);
      },
      write(N, z, A) {
        return o(typeof z == "string"), o(z.length === 1), h(A + 1 <= N.length), N[A] = z.charCodeAt(0), 1;
      }
    },
    uint8: {
      min: 0,
      max: 255,
      dynamic: !1,
      size(N) {
        return 1;
      },
      read(N, z) {
        return h(z + 1 <= N.length), N[z];
      },
      write(N, z, A) {
        return o((z & 255) === z), h(A + 1 <= N.length), N[A] = z, 1;
      }
    },
    uint16: {
      min: 0,
      max: 65535,
      dynamic: !1,
      size(N) {
        return 2;
      },
      read(N, z) {
        return h(z + 2 <= N.length), H(N, z);
      },
      write(N, z, A) {
        return o((z & 65535) === z), h(A + 2 <= N.length), J(N, z, A), 2;
      }
    },
    uint32: {
      min: 0,
      max: 4294967295,
      dynamic: !1,
      size(N) {
        return 4;
      },
      read(N, z) {
        return h(z + 4 <= N.length), S(N, z);
      },
      write(N, z, A) {
        return o(z >>> 0 === z), h(A + 4 <= N.length), j(N, z, A), 4;
      }
    },
    buffer: {
      min: d,
      max: w,
      dynamic: !0,
      size(N) {
        return p(N);
      },
      read(N, z) {
        return m(N, z);
      },
      write(N, z, A) {
        return E(N, z, A);
      }
    },
    hex: {
      min: d.toString("hex"),
      max: w.toString("hex"),
      dynamic: !0,
      size(N) {
        return a(N, "hex");
      },
      read(N, z) {
        return s(N, z, "hex");
      },
      write(N, z, A) {
        return i(N, z, A, "hex");
      }
    },
    ascii: {
      min: d.toString("binary"),
      max: w.toString("binary"),
      dynamic: !0,
      size(N) {
        return a(N, "binary");
      },
      read(N, z) {
        return s(N, z, "binary");
      },
      write(N, z, A) {
        return i(N, z, A, "binary");
      }
    },
    utf8: {
      min: d.toString("utf8"),
      max: w.toString("utf8"),
      dynamic: !0,
      size(N) {
        return a(N, "utf8");
      },
      read(N, z) {
        return s(N, z, "utf8");
      },
      write(N, z, A) {
        return i(N, z, A, "utf8");
      }
    },
    hash160: {
      min: k.alloc(20, 0),
      max: k.alloc(20, 255),
      dynamic: !1,
      size(N) {
        return 20;
      },
      read(N, z) {
        return h(z + 20 <= N.length), N.slice(z, z + 20);
      },
      write(N, z, A) {
        return o(k.isBuffer(z)), o(z.copy(N, A) === 20), 20;
      }
    },
    hash256: {
      min: k.alloc(32, 0),
      max: k.alloc(32, 255),
      dynamic: !1,
      size(N) {
        return 32;
      },
      read(N, z) {
        return h(z + 32 <= N.length), N.slice(z, z + 32);
      },
      write(N, z, A) {
        return o(k.isBuffer(z)), o(z.copy(N, A) === 32), 32;
      }
    },
    hash: {
      min: k.alloc(1, 0),
      max: k.alloc(64, 255),
      dynamic: !0,
      size(N) {
        return o(k.isBuffer(N)), 1 + N.length;
      },
      read(N, z) {
        return h(z + 1 <= N.length), h(N[z] >= 1 && N[z] <= 64), h(z + 1 + N[z] <= N.length), N.slice(z + 1, z + 1 + N[z]);
      },
      write(N, z, A) {
        return o(k.isBuffer(z)), o(z.length >= 1 && z.length <= 64), h(A + 1 <= N.length), N[A] = z.length, o(z.copy(N, A + 1) === z.length), 1 + z.length;
      }
    },
    hhash160: {
      min: k.alloc(20, 0),
      max: k.alloc(20, 255),
      dynamic: !1,
      size(N) {
        return 20;
      },
      read(N, z) {
        return h(z + 20 <= N.length), N.toString("hex", z, z + 20);
      },
      write(N, z, A) {
        return o(b(N, z, A) === 20), 20;
      }
    },
    hhash256: {
      min: k.alloc(32, 0),
      max: k.alloc(32, 255),
      dynamic: !1,
      size(N) {
        return 32;
      },
      read(N, z) {
        return h(z + 32 <= N.length), N.toString("hex", z, z + 32);
      },
      write(N, z, A) {
        return o(b(N, z, A) === 32), 32;
      }
    },
    hhash: {
      min: k.alloc(1, 0),
      max: k.alloc(64, 255),
      dynamic: !0,
      size(N) {
        return 1 + v(N);
      },
      read(N, z) {
        return h(z + 1 <= N.length), h(N[z] >= 1 && N[z] <= 64), h(z + 1 + N[z] <= N.length), N.toString("hex", z + 1, z + 1 + N[z]);
      },
      write(N, z, A) {
        const q = v(z);
        return o(q >= 1 && q <= 64), h(A + 1 <= N.length), N[A] = q, o(b(N, z, A + 1) === q), 1 + q;
      }
    }
  };
  class f {
    /**
     * Create a base key.
     * @constructor
     * @param {String[]|null} ops
     */
    constructor(z = []) {
      e(Array.isArray(z)), this.ops = [], this.size = 0, this.index = -1, this.init(z);
    }
    static create(z) {
      const A = z ? z.join(":") : "", q = c[A];
      if (q)
        return q;
      const _ = new f(z);
      return c[A] = _, _;
    }
    init(z) {
      for (let A = 0; A < z.length; A++) {
        const q = z[A];
        if (e(typeof q == "string"), !g.hasOwnProperty(q))
          throw new Error(`Invalid type name: ${q}.`);
        const _ = g[q];
        _.dynamic ? this.index === -1 && (this.index = A) : this.size += _.size(), this.ops.push(_);
      }
    }
    getSize(z) {
      e(z.length === this.ops.length);
      let A = 1 + this.size;
      if (this.index === -1)
        return A;
      for (let q = this.index; q < z.length; q++) {
        const _ = this.ops[q], F = z[q];
        _.dynamic && (A += _.size(F));
      }
      return A;
    }
    encode(z, A) {
      if (e(Array.isArray(A)), A.length !== this.ops.length)
        throw new Error("Wrong number of arguments passed to key.");
      const q = this.getSize(A), _ = k.allocUnsafe(q);
      _[0] = z;
      let F = 1;
      for (let R = 0; R < this.ops.length; R++) {
        const V = this.ops[R], fe = A[R];
        F += V.write(_, fe, F);
      }
      return _;
    }
    decode(z, A) {
      if (e(k.isBuffer(A)), this.ops.length === 0)
        return A;
      if (A.length === 0 || A[0] !== z)
        throw new Error("Key prefix mismatch.");
      const q = [];
      let _ = 1;
      for (const F of this.ops) {
        const R = F.read(A, _);
        _ += F.size(R), q.push(R);
      }
      return q;
    }
    min(z, A) {
      for (let q = A.length; q < this.ops.length; q++) {
        const _ = this.ops[q];
        A.push(_.min);
      }
      return this.encode(z, A);
    }
    max(z, A) {
      for (let q = A.length; q < this.ops.length; q++) {
        const _ = this.ops[q];
        A.push(_.max);
      }
      return this.encode(z, A);
    }
    root(z) {
      const A = k.allocUnsafe(1);
      return A[0] = z, A;
    }
  }
  class n {
    /**
     * Create a key.
     * @constructor
     * @param {Number|String} id
     * @param {String[]|null} ops
     */
    constructor(z, A = []) {
      e(Array.isArray(A)), this.id = u(z), this.base = f.create(A);
    }
    encode(...z) {
      return this.base.encode(this.id, z);
    }
    decode(z) {
      return this.base.decode(this.id, z);
    }
    min(...z) {
      return this.base.min(this.id, z);
    }
    max(...z) {
      return this.base.max(this.id, z);
    }
    root() {
      return this.base.root(this.id);
    }
  }
  function u(N) {
    return typeof N == "string" && (e(N.length === 1), N = N.charCodeAt(0)), e((N & 255) === N), e(N !== 255), N;
  }
  function a(N, z) {
    return o(typeof N == "string"), 1 + k.byteLength(N, z);
  }
  function s(N, z, A) {
    return h(z + 1 <= N.length), h(z + 1 + N[z] <= N.length), N.toString(A, z + 1, z + 1 + N[z]);
  }
  function i(N, z, A, q) {
    o(typeof z == "string");
    const _ = k.byteLength(z, q);
    return o(_ <= 255), h(A + 1 <= N.length), N[A] = _, _ > 0 && o(N.write(z, A + 1, q) === _), 1 + _;
  }
  function p(N) {
    return o(k.isBuffer(N)), 1 + N.length;
  }
  function m(N, z) {
    return h(z + 1 <= N.length), h(z + 1 + N[z] <= N.length), N.slice(z + 1, z + 1 + N[z]);
  }
  function E(N, z, A, q) {
    return o(k.isBuffer(z)), h(z.length <= 255), h(A + 1 <= N.length), N[A] = z.length, h(z.copy(N, A + 1) === z.length), 1 + z.length;
  }
  function v(N) {
    return k.isBuffer(N) ? N.length : (o(typeof N == "string"), N.length >>> 1);
  }
  function b(N, z, A) {
    return k.isBuffer(z) ? z.copy(N, A) : (o(typeof z == "string"), N.write(z, A, "hex"));
  }
  function h(N) {
    if (!N) {
      const z = new RangeError("Invalid length for database key.");
      throw Error.captureStackTrace && Error.captureStackTrace(z, h), z;
    }
  }
  function o(N) {
    if (!N) {
      const z = new TypeError("Invalid type for database key.");
      throw Error.captureStackTrace && Error.captureStackTrace(z, o), z;
    }
  }
  function S(N, z) {
    return N[z++] * 16777216 + N[z++] * 65536 + N[z++] * 256 + N[z];
  }
  function H(N, z) {
    return N[z++] * 256 + N[z];
  }
  function j(N, z, A) {
    return N[A + 3] = z, z >>>= 8, N[A + 2] = z, z >>>= 8, N[A + 1] = z, z >>>= 8, N[A] = z, A + 4;
  }
  function J(N, z, A) {
    return N[A++] = z >>> 8, N[A++] = z, A;
  }
  return Tu = n, Tu;
}
/*!
 * rbt.js - red black tree for bcoin
 * Copyright (c) 2016-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var Cu, e3;
function _x() {
  if (e3) return Cu;
  e3 = 1;
  const e = $e(), c = 0, d = 1;
  let w = null;
  class g {
    /**
     * Create a red black tree.
     * @constructor
     * @param {Function} compare - Comparator.
     * @param {Boolean?} unique
     */
    constructor(m, E) {
      e(typeof m == "function"), this.root = w, this.compare = m, this.unique = E || !1;
    }
    /**
     * Clear the tree.
     */
    reset() {
      this.root = w;
    }
    /**
     * Do a key lookup.
     * @param {Buffer|String} key
     * @returns {Buffer?} value
     */
    search(m) {
      let E = this.root;
      for (; !E.isNull(); ) {
        const v = this.compare(m, E.key);
        if (v === 0)
          return E;
        v < 0 ? E = E.left : E = E.right;
      }
      return null;
    }
    /**
     * Insert a record.
     * @param {Buffer|String} key
     * @param {Buffer} value
     */
    insert(m, E) {
      let v = this.root, b = !1, h;
      for (; !v.isNull(); ) {
        const S = this.compare(m, v.key);
        if (this.unique && S === 0)
          return v.key = m, v.value = E, v;
        h = v, S < 0 ? (b = !0, v = v.left) : (b = !1, v = v.right);
      }
      const o = new n(m, E);
      return h ? (o.parent = h, b ? h.left = o : h.right = o, this.insertFixup(o), o) : (this.root = o, this.insertFixup(o), o);
    }
    /**
     * Repaint necessary nodes after insertion.
     * @private
     * @param {RBTNode} x
     */
    insertFixup(m) {
      for (m.color = c; m !== this.root && m.parent.color === c; )
        if (m.parent === m.parent.parent.left) {
          const E = m.parent.parent.right;
          !E.isNull() && E.color === c ? (m.parent.color = d, E.color = d, m.parent.parent.color = c, m = m.parent.parent) : (m === m.parent.right && (m = m.parent, this.rotl(m)), m.parent.color = d, m.parent.parent.color = c, this.rotr(m.parent.parent));
        } else {
          const E = m.parent.parent.left;
          !E.isNull() && E.color === c ? (m.parent.color = d, E.color = d, m.parent.parent.color = c, m = m.parent.parent) : (m === m.parent.left && (m = m.parent, this.rotr(m)), m.parent.color = d, m.parent.parent.color = c, this.rotl(m.parent.parent));
        }
      this.root.color = d;
    }
    /**
     * Remove a record.
     * @param {Buffer|String} key
     * @returns {Boolean}
     */
    remove(m) {
      let E = this.root;
      for (; !E.isNull(); ) {
        const v = this.compare(m, E.key);
        if (v === 0)
          return this.removeNode(E), E;
        v < 0 ? E = E.left : E = E.right;
      }
      return null;
    }
    /**
     * Remove a single node.
     * @private
     * @param {RBTNode} z
     */
    removeNode(m) {
      let E = m;
      !m.left.isNull() && !m.right.isNull() && (E = this.successor(m));
      const v = E.left.isNull() ? E.right : E.left;
      v.parent = E.parent, E.parent.isNull() ? this.root = v : E === E.parent.left ? E.parent.left = v : E.parent.right = v, E !== m && (m.key = E.key, m.value = E.value), E.color === d && this.removeFixup(v);
    }
    /**
     * Repaint necessary nodes after removal.
     * @private
     * @param {RBTNode} x
     */
    removeFixup(m) {
      for (; m !== this.root && m.color === d; )
        if (m === m.parent.left) {
          let E = m.parent.right;
          E.color === c && (E.color = d, m.parent.color = c, this.rotl(m.parent), E = m.parent.right), E.left.color === d && E.right.color === d ? (E.color = c, m = m.parent) : (E.right.color === d && (E.left.color = d, E.color = c, this.rotr(E), E = m.parent.right), E.color = m.parent.color, m.parent.color = d, E.right.color = d, this.rotl(m.parent), m = this.root);
        } else {
          let E = m.parent.left;
          E.color === c && (E.color = d, m.parent.color = c, this.rotr(m.parent), E = m.parent.left), E.right.color === d && E.left.color === d ? (E.color = c, m = m.parent) : (E.left.color === d && (E.right.color = d, E.color = c, this.rotl(E), E = m.parent.left), E.color = m.parent.color, m.parent.color = d, E.left.color = d, this.rotr(m.parent), m = this.root);
        }
      m.color = d;
    }
    /**
     * Do a left rotate.
     * @private
     * @param {RBTNode} x
     */
    rotl(m) {
      const E = m.right;
      m.right = E.left, E.left.isNull() || (E.left.parent = m), E.parent = m.parent, m.parent.isNull() ? this.root = E : m === m.parent.left ? m.parent.left = E : m.parent.right = E, E.left = m, m.parent = E;
    }
    /**
     * Do a right rotate.
     * @private
     * @param {RBTNode} x
     */
    rotr(m) {
      const E = m.left;
      m.left = E.right, E.right.isNull() || (E.right.parent = m), E.parent = m.parent, m.parent.isNull() ? this.root = E : m === m.parent.right ? m.parent.right = E : m.parent.left = E, E.right = m, m.parent = E;
    }
    /**
     * Minimum subtree.
     * @private
     * @param {RBTNode} z
     * @returns {RBTNode}
     */
    min(m) {
      if (m.isNull())
        return m;
      for (; !m.left.isNull(); )
        m = m.left;
      return m;
    }
    /**
     * Maximum subtree.
     * @private
     * @param {RBTNode} z
     * @returns {RBTNode}
     */
    max(m) {
      if (m.isNull())
        return m;
      for (; !m.right.isNull(); )
        m = m.right;
      return m;
    }
    /**
     * Successor node.
     * @private
     * @param {RBTNode} x
     * @returns {RBTNode}
     */
    successor(m) {
      if (!m.right.isNull()) {
        for (m = m.right; !m.left.isNull(); )
          m = m.left;
        return m;
      }
      let E = m.parent;
      for (; !E.isNull() && m === E.right; )
        m = E, E = E.parent;
      return E;
    }
    /**
     * Predecessor node.
     * @private
     * @param {RBTNode} x
     * @returns {RBTNode}
     */
    predecessor(m) {
      if (!m.left.isNull()) {
        for (m = m.left; !m.right.isNull(); )
          m = m.right;
        return m;
      }
      let E = m.parent;
      for (; !E.isNull() && m === E.left; )
        m = E, E = E.parent;
      return E;
    }
    /**
     * Take a snapshot and return
     * a cloned root node (iterative).
     * @returns {RBTNode}
     */
    clone() {
      if (this.root.isNull())
        return w;
      const m = [];
      let E = this.root, v = !0, b, h;
      for (; ; ) {
        if (!E.isNull()) {
          const o = E.clone();
          b && (o.parent = b), v ? b ? b.left = o : h = o : b ? b.right = o : h = o, m.push(o), b = o, v = !0, E = E.left;
          continue;
        }
        if (m.length === 0)
          break;
        E = m.pop(), b = E, v = !1, E = E.right;
      }
      return e(h), h;
    }
    /**
     * Take a snapshot and return
     * a cloned root node (recursive).
     * @returns {RBTNode}
     */
    snapshot() {
      if (this.root.isNull())
        return w;
      const m = this.root.clone();
      return s(m, m.left), i(m, m.right), m;
    }
    /**
     * Create an iterator.
     * @param {RBTNode?} snapshot
     * @returns {RBTIterator}
     */
    iterator(m) {
      return new f(this, m || this.root);
    }
    /**
     * Traverse between a range of keys and collect records.
     * @param {Buffer} min
     * @param {Buffer} max
     * @returns {RBTNode[]} Records.
     */
    range(m, E) {
      const v = this.iterator(), b = [];
      for (m ? v.seekMin(m) : v.seekFirst(); v.next() && !(E && v.compare(E) > 0); )
        b.push(v.data());
      return b;
    }
  }
  class f {
    /**
     * Create an iterator.
     * @constructor
     * @param {RBT} tree
     * @param {RBTNode} snapshot
     * @property {RBT} tree
     * @property {RBTNode} current
     * @property {Object} key
     * @property {Object} value
     */
    constructor(m, E) {
      this.tree = m, this.root = E, this.current = E, this.key = null, this.value = null;
    }
    /**
     * Compare keys using tree's comparator.
     * @param {Object} key
     */
    compare(m) {
      return e(this.key != null, "No key."), this.tree.compare(this.key, m);
    }
    /**
     * Test whether current node is valid.
     */
    valid() {
      return !this.current.isNull();
    }
    /**
     * Seek to the root.
     */
    reset() {
      this.current = this.root, this.key = null, this.value = null;
    }
    /**
     * Seek to the start of the tree.
     */
    seekFirst() {
      this.current = this.tree.min(this.root), this.key = this.current.key, this.value = this.current.value;
    }
    /**
     * Seek to the end of the tree.
     */
    seekLast() {
      this.current = this.tree.max(this.root), this.key = this.current.key, this.value = this.current.value;
    }
    /**
     * Seek to a key from the current node (gte).
     * @param {String} key
     */
    seek(m) {
      return this.seekMin(m);
    }
    /**
     * Seek to a key from the current node (gte).
     * @param {String} key
     */
    seekMin(m) {
      e(m != null, "No key passed to seek.");
      let E = this.current, v = w;
      for (; !E.isNull(); ) {
        const b = this.tree.compare(E.key, m);
        if (b === 0) {
          v = E;
          break;
        }
        b > 0 ? (v = E, E = E.left) : E = E.right;
      }
      this.current = v, this.key = v.key, this.value = v.value;
    }
    /**
     * Seek to a key from the current node (lte).
     * @param {String} key
     */
    seekMax(m) {
      e(m != null, "No key passed to seek.");
      let E = this.current, v = w;
      for (; !E.isNull(); ) {
        const b = this.tree.compare(E.key, m);
        if (b === 0) {
          v = E;
          break;
        }
        b < 0 ? (v = E, E = E.right) : E = E.left;
      }
      this.current = v, this.key = v.key, this.value = v.value;
    }
    /**
     * Seek to previous node.
     * @param {String} key
     */
    prev() {
      return this.current.isNull() ? (this.key = null, this.value = null, !1) : (this.key = this.current.key, this.value = this.current.value, this.current = this.tree.predecessor(this.current), !0);
    }
    /**
     * Seek to next node.
     * @returns {Boolean}
     */
    next() {
      return this.current.isNull() ? (this.key = null, this.value = null, !1) : (this.key = this.current.key, this.value = this.current.value, this.current = this.tree.successor(this.current), !0);
    }
    /**
     * Return the current key/value pair.
     * @returns {RBTData}
     */
    data() {
      return e(this.key != null, "No data available."), new a(this.key, this.value);
    }
  }
  class n {
    /**
     * Create an RBT node.
     * @constructor
     * @param {Buffer} key
     * @param {Buffer} value
     * @property {Buffer} key
     * @property {Buffer} value
     * @property {Number} color
     * @property {RBTNode|RBTSentinel} parent
     * @property {RBTNode|RBTSentinel} left
     * @property {RBTNode|RBTSentinel} right
     */
    constructor(m, E) {
      this.key = m, this.value = E, this.color = c, this.parent = w, this.left = w, this.right = w;
    }
    /**
     * Clone the node.
     * @returns {RBTNode}
     */
    clone() {
      const m = new n(this.key, this.value);
      return m.color = this.color, m.parent = this.parent, m.left = this.left, m.right = this.right, m;
    }
    /**
     * Clone the node (key/value only).
     * @returns {RBTData}
     */
    copy() {
      return new a(this.key, this.value);
    }
    /**
     * Inspect the rbt node.
     * @returns {Object}
     */
    inspect() {
      return {
        key: this.key,
        value: this.value,
        color: this.color === c ? "red" : "black",
        left: this.left,
        right: this.right
      };
    }
    /**
     * Test whether the node is a leaf.
     * Always returns false.
     * @returns {Boolean}
     */
    isNull() {
      return !1;
    }
  }
  class u {
    /**
     * Create an RBT Sentinel Node.
     * @constructor
     * @property {null} key
     * @property {null} value
     * @property {Number} [color=BLACK]
     * @property {null} parent
     * @property {null} left
     * @property {null} right
     */
    constructor() {
      this.key = null, this.value = null, this.color = d, this.parent = null, this.left = null, this.right = null;
    }
    /**
     * Inspect the rbt node.
     * @returns {String}
     */
    inspect() {
      return "NIL";
    }
    /**
     * Test whether the node is a leaf.
     * Always returns true.
     * @returns {Boolean}
     */
    isNull() {
      return !0;
    }
  }
  class a {
    /**
     * Create an RBT key/value pair.
     * @constructor
     * @param {Buffer} key
     * @param {Buffer} value
     * @property {Buffer} key
     * @property {Buffer} value
     */
    constructor(m, E) {
      this.key = m, this.value = E;
    }
  }
  w = new u();
  function s(p, m) {
    m.isNull() || (p.left = m.clone(), p.left.parent = p, s(p.left, m.left), i(p.left, m.right));
  }
  function i(p, m) {
    m.isNull() || (p.right = m.clone(), p.right.parent = p, s(p.right, m.left), i(p.right, m.right));
  }
  return Cu = g, Cu;
}
var Du, t3;
function Rx() {
  if (t3) return Du;
  t3 = 1;
  const e = $e(), c = _x(), d = k.alloc(0);
  class w {
    /**
     * Create a memdb.
     * @constructor
     * @param {String?} location - Phony location.
     * @param {Object?} options
     * @param {Function} options.compare - Comparator.
     */
    constructor(i) {
      this.location = i || "memory", this.options = {}, this.tree = new c(a, !0);
    }
    /**
     * Do a key lookup.
     * @private
     * @param {Buffer|String} key
     * @returns {Buffer?} value
     */
    search(i) {
      typeof i == "string" && (i = k.from(i, "utf8")), e(k.isBuffer(i), "Key must be a Buffer.");
      const p = this.tree.search(i);
      if (p)
        return p.value;
    }
    /**
     * Insert a record.
     * @private
     * @param {Buffer|String} key
     * @param {Buffer} value
     */
    insert(i, p) {
      return typeof i == "string" && (i = k.from(i, "utf8")), typeof p == "string" && (p = k.from(p, "utf8")), p == null && (p = d), e(k.isBuffer(i), "Key must be a Buffer."), e(k.isBuffer(p), "Value must be a Buffer."), this.tree.insert(i, p) != null;
    }
    /**
     * Remove a record.
     * @private
     * @param {Buffer|String} key
     * @returns {Boolean}
     */
    remove(i) {
      return typeof i == "string" && (i = k.from(i, "utf8")), e(k.isBuffer(i), "Key must be a Buffer."), this.tree.remove(i) != null;
    }
    /**
     * Traverse between a range of keys and collect records.
     * @private
     * @param {Buffer} min
     * @param {Buffer} max
     * @returns {RBTData[]} Records.
     */
    range(i, p) {
      return typeof i == "string" && (i = k.from(i, "utf8")), typeof p == "string" && (p = k.from(p, "utf8")), e(!i || k.isBuffer(i), "Key must be a Buffer."), e(!p || k.isBuffer(p), "Key must be a Buffer."), this.tree.range(i, p);
    }
    /**
     * Open the database (leveldown method).
     * @param {Object?} options
     * @param {Function} callback
     */
    open(i, p) {
      p || (p = i, i = null), i || (i = {}), this.options = i, setImmediate(p);
    }
    /**
     * Close the database (leveldown method).
     * @param {Function} callback
     */
    close(i) {
      setImmediate(i);
    }
    /**
     * Retrieve a record (leveldown method).
     * @param {Buffer|String} key
     * @param {Object?} options
     * @param {Function} callback - Returns Buffer.
     */
    get(i, p, m) {
      m || (m = p, p = null), p || (p = {});
      let E = this.search(i);
      if (!E) {
        const v = new Error("MEMDB_NOTFOUND: Key not found.");
        v.notFound = !0, v.type = "NotFoundError", setImmediate(() => m(v));
        return;
      }
      p.asBuffer === !1 && (E = E.toString("utf8")), setImmediate(() => m(null, E));
    }
    /**
     * Insert a record (leveldown method).
     * @param {Buffer|String} key
     * @param {Buffer} value
     * @param {Object?} options
     * @param {Function} callback
     */
    put(i, p, m, E) {
      E || (E = m, m = null), this.insert(i, p), setImmediate(E);
    }
    /**
     * Remove a record (leveldown method).
     * @param {Buffer|String} key
     * @param {Object?} options
     * @param {Function} callback
     */
    del(i, p, m) {
      m || (m = p, p = null), this.remove(i), setImmediate(m);
    }
    /**
     * Create an atomic batch (leveldown method).
     * @see Leveldown.Batch
     * @param {Object[]?} ops
     * @param {Object?} options
     * @param {Function} callback
     */
    batch(i, p, m) {
      m || (m = p, p = null);
      const E = new g(this, p);
      if (i) {
        E.ops = i, E.write(m);
        return;
      }
      return E;
    }
    /**
     * Create an iterator (leveldown method).
     * @param {Object} options - See {Leveldown.Iterator}.
     * @returns {Leveldown.Iterator}.
     */
    iterator(i) {
      return new n(this, i);
    }
    /**
     * Get a database property (leveldown method) (NOP).
     * @param {String} name - Property name.
     * @returns {String}
     */
    getProperty(i) {
      return "";
    }
    /**
     * Calculate approximate database size (leveldown method).
     * @param {Buffer|String} start - Start key.
     * @param {Buffer|String} end - End key.
     * @param {Function} callback - Returns Number.
     */
    approximateSize(i, p, m) {
      const E = this.range(i, p);
      let v = 0;
      for (const b of E)
        v += b.key.length, v += b.value.length;
      setImmediate(() => m(null, v));
    }
    /**
     * Destroy the database (leveldown function) (NOP).
     * @param {String} location
     * @param {Function} callback
     */
    static destroy(i, p) {
      setImmediate(p);
    }
    /**
     * Repair the database (leveldown function) (NOP).
     * @param {String} location
     * @param {Function} callback
     */
    static repair(i, p) {
      setImmediate(p);
    }
  }
  class g {
    /**
     * Create a batch.
     * @constructor
     * @ignore
     * @param {MemDB} db
     * @param {Object?} options
     */
    constructor(i, p) {
      this.options = p || {}, this.ops = [], this.db = i, this.written = !1;
    }
    /**
     * Insert a record.
     * @param {Buffer|String} key
     * @param {Buffer} value
     */
    put(i, p) {
      return e(!this.written, "Already written."), this.ops.push(new f("put", i, p)), this;
    }
    /**
     * Remove a record.
     * @param {Buffer|String} key
     */
    del(i) {
      return e(!this.written, "Already written."), this.ops.push(new f("del", i)), this;
    }
    /**
     * Commit the batch.
     * @param {Function} callback
     */
    write(i) {
      if (this.written)
        return setImmediate(() => i(new Error("Already written."))), this;
      for (const p of this.ops)
        switch (p.type) {
          case "put":
            this.db.insert(p.key, p.value);
            break;
          case "del":
            this.db.remove(p.key);
            break;
          default:
            return setImmediate(() => i(new Error("Bad op."))), this;
        }
      return this.ops = [], this.written = !0, setImmediate(i), this;
    }
    /**
     * Clear batch of all ops.
     */
    clear() {
      return e(!this.written, "Already written."), this.ops = [], this;
    }
  }
  class f {
    /**
     * Create a batch op.
     * @constructor
     * @ignore
     * @param {String} type
     * @param {Buffer} key
     * @param {Buffer|null} value
     */
    constructor(i, p, m) {
      this.type = i, this.key = p, this.value = m;
    }
  }
  class n {
    /**
     * Create an iterator.
     * @constructor
     * @ignore
     * @param {RBT} db
     * @param {Object?} options
     */
    constructor(i, p) {
      this.db = i, this.options = new u(p), this.iter = null, this.ended = !1, this.total = 0, this.init();
    }
    /**
     * Initialize the iterator.
     */
    init() {
      const i = this.db.tree.snapshot(), p = this.db.tree.iterator(i);
      this.options.reverse ? this.options.end ? (p.seekMax(this.options.end), this.options.lt && p.valid() && p.compare(this.options.end) === 0 && p.prev()) : p.seekLast() : this.options.start ? (p.seekMin(this.options.start), this.options.gt && p.valid() && p.compare(this.options.start) === 0 && p.next()) : p.seekFirst(), this.iter = p;
    }
    /**
     * Seek to the next key.
     * @param {Function} callback
     */
    next(i) {
      const p = this.options, m = this.iter;
      if (!this.iter) {
        setImmediate(() => i(new Error("Cannot call next.")));
        return;
      }
      let E;
      if (p.reverse ? (E = m.prev(), E && p.start && (p.gt ? m.compare(p.start) <= 0 && (E = !1) : m.compare(p.start) < 0 && (E = !1))) : (E = m.next(), E && p.end && (p.lt ? m.compare(p.end) >= 0 && (E = !1) : m.compare(p.end) > 0 && (E = !1))), !E) {
        this.iter = null, setImmediate(i);
        return;
      }
      if (p.limit !== -1) {
        if (this.total >= p.limit) {
          this.iter = null, setImmediate(i);
          return;
        }
        this.total += 1;
      }
      let v = m.key, b = m.value;
      p.keys || (v = d), p.values || (b = d), p.keyAsBuffer || (v = v.toString("utf8")), p.valueAsBuffer || (b = b.toString("utf8")), setImmediate(() => i(null, v, b));
    }
    /**
     * Seek to a key gte to `key`.
     * @param {String|Buffer} key
     */
    seek(i) {
      e(this.iter, "Already ended."), typeof i == "string" && (i = k.from(i, "utf8")), e(k.isBuffer(i), "Key must be a Buffer."), this.options.reverse ? this.iter.seekMax(i) : this.iter.seekMin(i);
    }
    /**
     * End the iterator. Free up snapshot.
     * @param {Function} callback
     */
    end(i) {
      if (this.ended) {
        setImmediate(() => i(new Error("Already ended.")));
        return;
      }
      this.ended = !0, this.iter = null, setImmediate(i);
    }
  }
  class u {
    /**
     * Create iterator options.
     * @constructor
     * @ignore
     * @param {Object} options
     */
    constructor(i) {
      this.keys = !0, this.values = !0, this.start = null, this.end = null, this.gt = !1, this.lt = !1, this.keyAsBuffer = !0, this.valueAsBuffer = !0, this.reverse = !1, this.limit = -1, i && this.fromOptions(i);
    }
    /**
     * Inject properties from options.
     * @private
     * @param {Object} options
     * @returns {IteratorOptions}
     */
    fromOptions(i) {
      return i.keys != null && (e(typeof i.keys == "boolean"), this.keys = i.keys), i.values != null && (e(typeof i.values == "boolean"), this.values = i.values), i.start != null && (this.start = i.start), i.end != null && (this.end = i.end), i.gte != null && (this.start = i.gte), i.lte != null && (this.end = i.lte), i.gt != null && (this.gt = !0, this.start = i.gt), i.lt != null && (this.lt = !0, this.end = i.lt), this.start != null && (typeof this.start == "string" && (this.start = k.from(this.start, "utf8")), e(k.isBuffer(this.start), "`start` must be a Buffer.")), this.end != null && (typeof this.end == "string" && (this.end = k.from(this.end, "utf8")), e(k.isBuffer(this.end), "`end` must be a Buffer.")), i.keyAsBuffer != null && (e(typeof i.keyAsBuffer == "boolean"), this.keyAsBuffer = i.keyAsBuffer), i.valueAsBuffer != null && (e(typeof i.valueAsBuffer == "boolean"), this.valueAsBuffer = i.valueAsBuffer), i.reverse != null && (e(typeof i.reverse == "boolean"), this.reverse = i.reverse), i.limit != null && (e(typeof i.limit == "number"), this.limit = i.limit), this;
    }
  }
  function a(s, i) {
    return s.compare(i);
  }
  return Du = w, Du;
}
var Uu, r3;
function Px() {
  if (r3) return Uu;
  r3 = 1;
  const e = $e(), c = Lt.indexedDB || Lt.webkitIndexedDB || Lt.mozIndexedDB || Lt.shimIndexedDB, d = Lt.IDBKeyRange || Lt.webkitIDBKeyRange || Lt.mozIDBKeyRange, w = {
    READ_ONLY: "readonly",
    READ_WRITE: "readwrite",
    NEXT: "next",
    PREV: "prev"
  };
  class g {
    constructor(E) {
      e(typeof E == "string"), this.options = {}, this.version = 1, this.name = `bdb-${E}`, this.location = E, this.db = null, this.store = null;
    }
    transaction(E) {
      return this.db.transaction([this.location], E);
    }
    open(E, v) {
      v || (v = E, E = null), E || (E = {}), this.options = E;
      const b = c.open(this.name, this.version);
      return b.onerror = p(v), b.onsuccess = (h) => {
        if (this.db) {
          v();
          return;
        }
        if (this.db = h.target.result, typeof this.db.version == "string") {
          v(new Error("IndexedDB is out of date."));
          return;
        }
        if (!this.db.objectStoreNames.contains(this.location)) {
          v(new Error("Could not create object store."));
          return;
        }
        const o = this.transaction(w.READ_ONLY);
        this.store = o.objectStore(this.location), v();
      }, b.onupgradeneeded = (h) => {
        if (this.db = h.target.result, this.db.objectStoreNames.contains(this.location)) {
          this.store = h.target.transaction.objectStore(this.location);
          return;
        }
        this.store = this.db.createObjectStore(this.location, {
          autoIncrement: !1
        });
      }, this;
    }
    close(E) {
      return this.db.close(), E(), this;
    }
    put(E, v, b) {
      const h = p(b), o = this.transaction(w.READ_WRITE);
      let S = !1;
      o.oncomplete = () => {
        if (!S) {
          b(new Error("Operation failed."));
          return;
        }
        b();
      }, o.onabort = h, o.onerror = h;
      const H = o.objectStore(this.location).put(v, s(E));
      return H.onsuccess = (j) => {
        S = !0;
      }, H.onerror = h, this;
    }
    get(E, v, b) {
      b || (b = v, v = null), v || (v = {});
      const h = p(b), o = this.transaction(w.READ_ONLY);
      let S = !1, H = null;
      o.oncomplete = () => {
        if (!S) {
          b(new Error("Operation failed."));
          return;
        }
        if (H === void 0) {
          const J = new Error("IDB_NOTFOUND: Key not found.");
          J.notFound = !0, J.type = "NotFoundError", b(J);
          return;
        }
        H && !k.isBuffer(H) && H.buffer && (H = k.from(H.buffer)), v.asBuffer === !1 && (H = H.toString("utf8")), b(null, H);
      }, o.onabort = h, o.onerror = h;
      const j = o.objectStore(this.location).get(s(E));
      return j.onsuccess = function(J) {
        S = !0, H = J.target.result;
      }, j.onerror = h, this;
    }
    del(E, v) {
      const b = p(v), h = this.transaction(w.READ_WRITE);
      let o = !1;
      h.oncomplete = () => {
        if (!o) {
          v(new Error("Operation failed."));
          return;
        }
        v();
      }, h.onabort = b, h.onerror = b;
      const S = h.objectStore(this.location).delete(s(E));
      return S.onsuccess = (H) => {
        o = !0;
      }, S.onerror = b, this;
    }
    batch(E, v, b) {
      b || (b = v, v = null);
      const h = new f(this, v);
      if (E) {
        h.ops = E, h.write(b);
        return;
      }
      return h;
    }
    iterator(E) {
      return new u(this, E);
    }
    static destroy(E, v) {
      if (!c.deleteDatabase) {
        v(new Error("Destroy not supported."));
        return;
      }
      const b = c.deleteDatabase(`bdb-${E}`);
      b.onsuccess = () => v(), b.onerror = p(v);
    }
  }
  class f {
    /**
     * Create a batch.
     * @constructor
     * @ignore
     * @param {Level} db
     * @param {Object?} options
     */
    constructor(E, v) {
      this.db = E, this.options = v || {}, this.ops = [], this.written = !1;
    }
    /**
     * Insert a record.
     * @param {Buffer|String} key
     * @param {Buffer} value
     */
    put(E, v) {
      return e(!this.written, "Already written."), this.ops.push(new n("put", E, v)), this;
    }
    /**
     * Remove a record.
     * @param {Buffer|String} key
     */
    del(E) {
      return e(!this.written, "Already written."), this.ops.push(new n("del", E)), this;
    }
    /**
     * Commit the batch.
     * @param {Function} callback
     */
    write(E) {
      if (this.written)
        return E(new Error("Already written.")), this;
      const v = p(E), b = this.db.transaction(w.READ_WRITE);
      let h = this.ops.length, o = !1, S = !1;
      b.oncomplete = () => {
        if (!S) {
          E(new Error("Operation failed."));
          return;
        }
        E();
      }, b.onabort = v, b.onerror = v;
      const H = () => {
        h -= 1, h === 0 && !o && (o = !0, S = !0);
      }, j = (J) => {
        b.abort(), o || (o = !0, v(J));
      };
      for (const { type: J, key: N, value: z } of this.ops) {
        const A = b.objectStore(this.db.location);
        switch (J) {
          case "put": {
            const q = A.put(z, s(N));
            q.onsuccess = H, q.onerror = j;
            break;
          }
          case "del": {
            const q = A.delete(s(N));
            q.onsuccess = H, q.onerror = j;
            break;
          }
          default:
            return E(new Error("Bad op type.")), this;
        }
      }
      return this;
    }
    /**
     * Clear batch of all ops.
     */
    clear() {
      return e(!this.written, "Already written."), this.ops = [], this;
    }
  }
  class n {
    /**
     * Create a batch op.
     * @constructor
     * @ignore
     * @param {String} type
     * @param {Buffer} key
     * @param {Buffer|null} value
     */
    constructor(E, v, b) {
      this.type = E, this.key = v, this.value = b;
    }
  }
  class u {
    constructor(E, v) {
      this.db = E, this.options = new a(v), this.cursor = null, this.error = null, this.started = !1, this.ended = !1, this.callback = null;
    }
    seek(E) {
      throw new Error("Not implemented.");
    }
    next(E) {
      if (this.ended) {
        E(new Error("Iterator already ended."));
        return;
      }
      if (this.callback) {
        E(new Error("Callback already pending."));
        return;
      }
      if (this.error) {
        E(this.error);
        return;
      }
      if (!this.started) {
        this.callback = E, this.start();
        return;
      }
      e(this.cursor), this.callback = E, this.cursor.continue(), this.cursor = null;
    }
    end(E) {
      if (this.ended) {
        E(new Error("Iterator already ended."));
        return;
      }
      this.ended = !0, E();
    }
    start() {
      if (this.started)
        return;
      const E = this.options, v = this.db.transaction(w.READ_ONLY), b = v.objectStore(this.db.location);
      let h = !1, o = 0;
      v.oncomplete = () => {
        if (!h && !this.error && (this.error = new Error("Iterator ended early.")), this.error) {
          this.respond(this.error);
          return;
        }
        this.respond(null, void 0, void 0);
      };
      const S = (A) => {
        this.error = i(A), this.respond(this.error);
      };
      v.onabort = S, v.onerror = S;
      const H = s(E.start), j = s(E.end);
      let J = null;
      H && j ? J = d.bound(H, j, E.gt, E.lt) : H ? J = d.lowerBound(H, E.gt) : j ? J = d.upperBound(j, E.lt) : J = d.lowerBound("\0", !0);
      const N = E.reverse ? w.PREV : w.NEXT, z = b.openCursor(J, N);
      z.onerror = S, z.onsuccess = (A) => {
        const q = A.target.result;
        if (this.error) {
          this.respond(this.error);
          return;
        }
        if (!q) {
          h = !0;
          return;
        }
        if (E.limit !== -1) {
          if (o >= E.limit) {
            h = !0;
            return;
          }
          o += 1;
        }
        let _ = k.from(q.key, "hex"), F = q.value;
        F && !k.isBuffer(F) && F.buffer && (F = k.from(F.buffer)), E.keyAsBuffer || (_ = _.toString("utf8")), E.valueAsBuffer || (F = F.toString("utf8")), this.cursor = q, this.respond(null, _, F);
      }, this.started = !0;
    }
    respond(E, v, b) {
      if (!this.callback)
        return;
      const h = this.callback;
      this.callback = null, h(E, v, b);
    }
  }
  class a {
    /**
     * Create iterator options.
     * @constructor
     * @ignore
     * @param {Object} options
     */
    constructor(E) {
      this.keys = !0, this.values = !0, this.start = null, this.end = null, this.gt = !1, this.lt = !1, this.keyAsBuffer = !0, this.valueAsBuffer = !0, this.reverse = !1, this.limit = -1, E && this.fromOptions(E);
    }
    /**
     * Inject properties from options.
     * @private
     * @param {Object} options
     * @returns {IteratorOptions}
     */
    fromOptions(E) {
      return E.keys != null && (e(typeof E.keys == "boolean"), this.keys = E.keys), E.values != null && (e(typeof E.values == "boolean"), this.values = E.values), E.start != null && (this.start = E.start), E.end != null && (this.end = E.end), E.gte != null && (this.start = E.gte), E.lte != null && (this.end = E.lte), E.gt != null && (this.gt = !0, this.start = E.gt), E.lt != null && (this.lt = !0, this.end = E.lt), this.start != null && (typeof this.start == "string" && (this.start = k.from(this.start, "utf8")), e(k.isBuffer(this.start), "`start` must be a Buffer.")), this.end != null && (typeof this.end == "string" && (this.end = k.from(this.end, "utf8")), e(k.isBuffer(this.end), "`end` must be a Buffer.")), E.keyAsBuffer != null && (e(typeof E.keyAsBuffer == "boolean"), this.keyAsBuffer = E.keyAsBuffer), E.valueAsBuffer != null && (e(typeof E.valueAsBuffer == "boolean"), this.valueAsBuffer = E.valueAsBuffer), E.reverse != null && (e(typeof E.reverse == "boolean"), this.reverse = E.reverse), E.limit != null && (e(typeof E.limit == "number"), this.limit = E.limit), this;
    }
  }
  function s(m) {
    return m == null ? m : (typeof m == "string" && (m = k.from(m, "utf8")), e(k.isBuffer(m)), m.toString("hex"));
  }
  function i(m) {
    if (!m)
      return new Error("Unknown IndexedDB error (no event).");
    if (m instanceof Error)
      return m;
    const { target: E } = m;
    if (!E)
      return new Error("Unknown IndexedDB error (no target).");
    if (E.error) {
      const { error: v } = E;
      return v instanceof Error ? v : v.name === "VersionError" ? new Error("IndexedDB version error.") : new Error(String(v));
    }
    return E.errorCode != null ? E.errorCode === 12 ? new Error("IndexedDB version error.") : new Error(`IndexedDB error: ${E.errorCode}.`) : new Error("Unknown IndexedDB error (no error).");
  }
  function p(m) {
    return (E) => m(i(E));
  }
  return Uu = g, Uu;
}
var i3;
function o7() {
  if (i3) return Gi;
  i3 = 1;
  const e = $e(), c = Ax(), d = Ox(), w = Rx(), g = Px();
  return Gi.DB = c, Gi.Key = d, Gi.create = (f) => {
    f == null && (f = {}), typeof f == "string" && (f = { location: f }), e(f && typeof f == "object");
    const { memory: n, location: u } = f;
    return n ? new c(w, "memory", f) : new c(g, u, f);
  }, Gi.key = (f, n) => new d(f, n), Gi;
}
var Fu, n3;
function kx() {
  return n3 || (n3 = 1, Fu = function(c) {
    if (c === void 0)
      return "undefined";
    if (c !== c)
      return "NaN";
    try {
      return JSON.stringify(c, null, 2);
    } catch {
      return "{}";
    }
  }), Fu;
}
var Hu, s3;
function Bx() {
  if (s3) return Hu;
  s3 = 1;
  const e = kx(), c = {
    showHidden: !1,
    depth: 20,
    colors: !1,
    customInspect: !0,
    showProxy: !1,
    maxArrayLength: 1e4,
    breakLength: 60,
    compact: !0
  };
  function d(a, s) {
    if (a.length === 0)
      return "";
    const i = a[0];
    if (c.colors = s, typeof i != "string")
      return e(i, c);
    if (a.length === 1)
      return i;
    let p = "", m = 1, E = 0, v;
    for (let b = 0; b < i.length - 1; b++) {
      if (i.charCodeAt(b) !== 37)
        continue;
      const h = i.charCodeAt(++b);
      if (m !== a.length) {
        switch (h) {
          case 115:
            v = String(a[m++]);
            break;
          case 106:
            v = w(a[m++]);
            break;
          case 100:
            v = n(a[m++]);
            break;
          case 79:
          // 'O'
          case 111:
            v = e(a[m++], c);
            break;
          case 105:
            v = u(a[m++]);
            break;
          case 102:
            v = `${parseFloat(a[m++])}`;
            break;
          case 120:
            v = g(a[m++], !1);
            break;
          case 104:
            v = g(a[m++], !0);
            break;
          case 37:
            p += i.slice(E, b), E = b + 1;
            continue;
          default:
            continue;
        }
        E !== b - 1 && (p += i.slice(E, b - 1)), p += v, E = b + 1;
      } else h === 37 && (p += i.slice(E, b), E = b + 1);
    }
    for (E === 0 ? p = i : E < i.length && (p += i.slice(E)); m < a.length; ) {
      const b = a[m++];
      typeof b != "object" && typeof b != "symbol" || b === null ? p += ` ${b}` : p += ` ${e(b, c)}`;
    }
    return p;
  }
  function w(a) {
    try {
      return JSON.stringify(a);
    } catch {
      return "[error]";
    }
  }
  function g(a, s) {
    if (a == null)
      return "null";
    if (!k.isBuffer(a)) {
      let p = (a >>> 0).toString(16);
      for (; p.length < 8; )
        p = "0" + p;
      return s && (p = f(p)), `0x${p}`;
    }
    const i = a.toString("hex");
    return s ? f(i) : i;
  }
  function f(a) {
    let s = "";
    for (let i = a.length - 2; i >= 0; i -= 2)
      s += a[i] + a[i + 1];
    return s;
  }
  function n(a) {
    return typeof a == "bigint" ? `${a}n` : `${Number(a)}`;
  }
  function u(a) {
    return typeof a == "bigint" ? `${a}n` : `${parseInt(a)}`;
  }
  return Hu = d, Hu;
}
var Lu = {}, o3;
function Mx() {
  return o3 || (o3 = 1, Lu.unsupported = !0), Lu;
}
var Ku, a3;
function Nx() {
  if (a3) return Ku;
  a3 = 1;
  const e = n7(), c = $e(), d = Bx(), w = Mx();
  class g {
    /**
     * Create a logger.
     * @constructor
     * @param {(String|Object)?} options/level
     * @param {String?} options.level
     * @param {Boolean} [options.colors=true]
     */
    constructor(p) {
      this.level = g.levels.NONE, this.colors = g.HAS_TTY, this.maxFileSize = g.MAX_FILE_SIZE, this.maxFiles = g.MAX_ARCHIVAL_FILES, this.console = !0, this.closed = !0, this.closing = !1, this.filename = null, this.stream = null, this.contexts = /* @__PURE__ */ Object.create(null), this.fmt = d, this.rotating = !1, this._fileSize = 0, this._buffer = [], p && this.set(p);
    }
    /**
     * Set logger options.
     * @param {Object} options
     */
    set(p) {
      if (c(p), c(this.closed), typeof p == "string") {
        this.setLevel(p);
        return;
      }
      p.level != null && (c(typeof p.level == "string"), this.setLevel(p.level)), p.colors != null && g.HAS_TTY && (c(typeof p.colors == "boolean"), this.colors = p.colors), p.console != null && (c(typeof p.console == "boolean"), this.console = p.console), p.filename != null && (c(typeof p.filename == "string", "Bad file."), this.filename = p.filename), p.maxFileSize != null && (c(p.maxFileSize >>> 0 === p.maxFileSize), this.maxFileSize = p.maxFileSize), p.maxFiles != null && (c(p.maxFiles >>> 0 === p.maxFiles), this.maxFiles = p.maxFiles);
    }
    /**
     * Open the logger.
     * @method
     * @returns {Promise}
     */
    async open() {
      if (!this.filename) {
        this.closed = !1;
        return;
      }
      if (this.stream) {
        this.closed = !1;
        return;
      }
      if (w.unsupported) {
        this.closed = !1;
        return;
      }
      this._fileSize = await this.getSize(), this.stream = await u(this.filename), this.stream.once("error", this.handleError.bind(this)), this.closed = !1;
    }
    /**
     * Destroy the write stream.
     * @method
     * @returns {Promise}
     */
    async close() {
      if (this.timer != null && (clearTimeout(this.timer), this.timer = null), w.unsupported) {
        this.closed = !0, this.stream = null;
        return;
      }
      if (this.stream) {
        try {
          this.closing = !0, await a(this.stream);
        } finally {
          this.closing = !1;
        }
        this.stream = null;
      }
      this._fileSize = 0, this.closed = !0;
    }
    /**
     * Rotate out the current log file.
     * @method
     * @private
     * @returns {Promise} - Returns String
     */
    async rotate() {
      if (this.rotating || !this.filename || w.unsupported)
        return null;
      this.rotating = !0, await this.close();
      const p = e.extname(this.filename), m = e.basename(this.filename, p), E = e.dirname(this.filename), v = e.join(E, m + "_" + s() + p);
      for (await w.rename(this.filename, v), await this.open(); this._buffer.length > 0; ) {
        const b = this._buffer.shift();
        this.stream.write(b), this._fileSize += b.length;
      }
      return this.rotating = !1, this.prune(E, m, p), v;
    }
    /**
     * Remove old log files
     * @method
     * @private
     * @param {String} dir
     * @param {String} base
     * @param {String} ext
     * @returns {Promise} - Returns Number
     */
    async prune(p, m, E) {
      const v = await w.readdir(p), b = new RegExp(`${m}_.*${E}`), h = v.filter((S) => b.test(S));
      if (h.length <= this.maxFiles)
        return;
      h.sort();
      const o = h.slice(0, -1 * this.maxFiles);
      for (const S of o)
        await w.unlink(e.join(p, S));
    }
    /**
     * Get the size of the current log file in bytes.
     * @method
     * @private
     * @returns {Promise} - Returns Number
     */
    async getSize() {
      try {
        return (await w.stat(this.filename)).size;
      } catch (p) {
        if (p.code === "ENOENT")
          return 0;
        throw p;
      }
    }
    /**
     * Handle write stream error.
     * @param {Error} err
     */
    handleError(p) {
      try {
        this.stream.close();
      } catch {
      }
      this.stream = null, this.retry();
    }
    /**
     * Try to reopen the logger.
     * @method
     * @private
     * @returns {Promise}
     */
    async reopen() {
      if (!this.stream && !this.closed && !w.unsupported) {
        try {
          this.stream = await u(this.filename);
        } catch {
          this.retry();
          return;
        }
        this.stream.once("error", (p) => this.handleError(p));
      }
    }
    /**
     * Try to reopen the logger after a timeout.
     * @method
     * @private
     * @returns {Promise}
     */
    retry() {
      this.timer == null && (this.timer = setTimeout(() => {
        this.timer = null, this.reopen();
      }, 1e4));
    }
    /**
     * Set the log file location.
     * @param {String} filename
     */
    setFile(p) {
      c(typeof p == "string"), c(!this.stream, "Log stream has already been created."), this.filename = p;
    }
    /**
     * Set or reset the log level.
     * @param {String} level
     */
    setLevel(p) {
      const m = g.levels[p.toUpperCase()];
      c(m != null, "Invalid log level."), this.level = m;
    }
    /**
     * Output a log to the `error` log level.
     * @param {String|Object|Error} err
     * @param {...Object} args
     */
    error(...p) {
      if (this.level < g.levels.ERROR)
        return;
      const m = p[0];
      if (m instanceof Error) {
        this.logError(g.levels.ERROR, null, m);
        return;
      }
      this.log(g.levels.ERROR, null, p);
    }
    /**
     * Output a log to the `warning` log level.
     * @param {String|Object} obj
     * @param {...Object} args
     */
    warning(...p) {
      if (this.level < g.levels.WARNING)
        return;
      const m = p[0];
      if (m instanceof Error) {
        this.logError(g.levels.WARNING, null, m);
        return;
      }
      this.log(g.levels.WARNING, null, p);
    }
    /**
     * Output a log to the `info` log level.
     * @param {String|Object} obj
     * @param {...Object} args
     */
    info(...p) {
      if (this.level < g.levels.INFO)
        return;
      const m = p[0];
      if (m instanceof Error) {
        this.logError(g.levels.INFO, null, m);
        return;
      }
      this.log(g.levels.INFO, null, p);
    }
    /**
     * Output a log to the `debug` log level.
     * @param {String|Object} obj
     * @param {...Object} args
     */
    debug(...p) {
      if (this.level < g.levels.DEBUG)
        return;
      const m = p[0];
      if (m instanceof Error) {
        this.logError(g.levels.DEBUG, null, m);
        return;
      }
      this.log(g.levels.DEBUG, null, p);
    }
    /**
     * Output a log to the `spam` log level.
     * @param {String|Object} obj
     * @param {...Object} args
     */
    spam(...p) {
      if (this.level < g.levels.SPAM)
        return;
      const m = p[0];
      if (m instanceof Error) {
        this.logError(g.levels.SPAM, null, m);
        return;
      }
      this.log(g.levels.SPAM, null, p);
    }
    /**
     * Output a log to the desired log level.
     * Note that this bypasses the level check.
     * @param {String} level
     * @param {String|null} module
     * @param {Object[]} args
     */
    log(p, m, E) {
      this.closed && !this.rotating || this.level < p || (this.writeConsole(p, m, E), this.writeStream(p, m, E));
    }
    /**
     * Create logger context.
     * @param {String} module
     * @returns {LoggerContext}
     */
    context(p) {
      let m = this.contexts[p];
      return m || (m = new f(this, p), this.contexts[p] = m), m;
    }
    /**
     * Write log to the console.
     * @param {String} level
     * @param {String|null} module
     * @param {Object[]} args
     */
    writeConsole(p, m, E) {
      const v = g.levelsByVal[p];
      if (c(v, "Invalid log level."), !this.console)
        return !1;
      if (!It.stdout) {
        let h = `[${v}] `;
        if (m && (h += `(${m}) `), E.length > 0) {
          const [o] = E;
          if (o && typeof o == "object")
            return p === g.levels.ERROR ? console.error(h, o) : console.log(h, o);
        }
        return h += d(E, !1), p === g.levels.ERROR ? console.error(h) : console.log(h), !0;
      }
      let b;
      if (this.colors) {
        const h = g.styles[p];
        c(h), b = `\x1B[${h}m[${v}]\x1B[m `;
      } else
        b = `[${v}] `;
      return m && (b += `(${m}) `), b += d(E, this.colors), b += `
`, p === g.levels.ERROR ? It.stderr.write(b) : It.stdout.write(b);
    }
    /**
     * Write a string to the output stream (usually a file).
     * @param {String} level
     * @param {String|null} module
     * @param {Object[]} args
     */
    writeStream(p, m, E) {
      const v = g.prefixByVal[p];
      if (c(v, "Invalid log level."), !this.stream && !this.rotating || this.closing && !this.rotating)
        return;
      const b = (/* @__PURE__ */ new Date()).toISOString().slice(0, -5) + "Z";
      let h = `[${v}:${b}] `;
      m && (h += `(${m}) `), h += d(E, !1), h += `
`, this.rotating ? this._buffer.push(h) : (this.stream.write(h), this._fileSize += h.length, this._fileSize >= this.maxFileSize && this.rotate());
    }
    /**
     * Helper to parse an error into a nicer
     * format. Call's `log` internally.
     * @private
     * @param {Number} level
     * @param {String|null} module
     * @param {Error} err
     */
    logError(p, m, E) {
      if (this.closed && !this.rotating)
        return;
      w.unsupported && this.console && p <= g.levels.WARNING && console.error(E);
      let v = String(E.message).replace(/^ *Error: */, "");
      p !== g.levels.ERROR && (v = `Error: ${v}`), p <= g.levels.WARNING && E.stack && (v += `
` + String(E.stack).split(`
`).slice(1).join(`
`)), this.log(p, m, [v]);
    }
    /**
     * Get the current memory usage.
     * @returns {Object}
     */
    memoryUsage() {
      if (!It.memoryUsage)
        return {
          total: 0,
          jsHeap: 0,
          jsHeapTotal: 0,
          nativeHeap: 0,
          external: 0
        };
      const p = It.memoryUsage();
      return {
        total: n(p.rss),
        jsHeap: n(p.heapUsed),
        jsHeapTotal: n(p.heapTotal),
        nativeHeap: n(p.rss - p.heapTotal),
        external: n(p.external)
      };
    }
    /**
     * Log the current memory usage.
     * @param {String|null} module
     */
    memory(p) {
      const m = this.memoryUsage();
      this.log(g.levels.DEBUG, p, [
        "Memory: rss=%dmb, js-heap=%d/%dmb native-heap=%dmb",
        m.total,
        m.jsHeap,
        m.jsHeapTotal,
        m.nativeHeap
      ]);
    }
  }
  class f {
    /**
     * Create a logger context.
     * @constructor
     * @ignore
     * @param {Logger} logger
     * @param {String} module
     */
    constructor(p, m) {
      c(typeof m == "string"), this.logger = p, this.module = m;
    }
    /**
     * Open the logger.
     * @returns {Promise}
     */
    open() {
      return this.logger.open();
    }
    /**
     * Destroy the write stream.
     * @returns {Promise}
     */
    close() {
      return this.logger.close();
    }
    /**
     * Set the log file location.
     * @param {String} filename
     */
    setFile(p) {
      this.logger.setFile(p);
    }
    /**
     * Set or reset the log level.
     * @param {String} level
     */
    setLevel(p) {
      this.logger.setLevel(p);
    }
    /**
     * Output a log to the `error` log level.
     * @param {String|Object|Error} err
     * @param {...Object} args
     */
    error(...p) {
      if (this.logger.level < g.levels.ERROR)
        return;
      const m = p[0];
      if (m instanceof Error) {
        this.logError(g.levels.ERROR, m);
        return;
      }
      this.log(g.levels.ERROR, p);
    }
    /**
     * Output a log to the `warning` log level.
     * @param {String|Object} obj
     * @param {...Object} args
     */
    warning(...p) {
      if (this.logger.level < g.levels.WARNING)
        return;
      const m = p[0];
      if (m instanceof Error) {
        this.logError(g.levels.WARNING, m);
        return;
      }
      this.log(g.levels.WARNING, p);
    }
    /**
     * Output a log to the `info` log level.
     * @param {String|Object} obj
     * @param {...Object} args
     */
    info(...p) {
      if (this.logger.level < g.levels.INFO)
        return;
      const m = p[0];
      if (m instanceof Error) {
        this.logError(g.levels.INFO, m);
        return;
      }
      this.log(g.levels.INFO, p);
    }
    /**
     * Output a log to the `debug` log level.
     * @param {String|Object} obj
     * @param {...Object} args
     */
    debug(...p) {
      if (this.logger.level < g.levels.DEBUG)
        return;
      const m = p[0];
      if (m instanceof Error) {
        this.logError(g.levels.DEBUG, m);
        return;
      }
      this.log(g.levels.DEBUG, p);
    }
    /**
     * Output a log to the `spam` log level.
     * @param {String|Object} obj
     * @param {...Object} args
     */
    spam(...p) {
      if (this.logger.level < g.levels.SPAM)
        return;
      const m = p[0];
      if (m instanceof Error) {
        this.logError(g.levels.SPAM, m);
        return;
      }
      this.log(g.levels.SPAM, p);
    }
    /**
     * Output a log to the desired log level.
     * Note that this bypasses the level check.
     * @param {String} level
     * @param {Object[]} args
     */
    log(p, m) {
      this.logger.log(p, this.module, m);
    }
    /**
     * Create logger context.
     * @param {String} module
     * @returns {LoggerContext}
     */
    context(p) {
      return new f(this.logger, p);
    }
    /**
     * Helper to parse an error into a nicer
     * format. Call's `log` internally.
     * @private
     * @param {Number} level
     * @param {Error} err
     */
    logError(p, m) {
      this.logger.logError(p, this.module, m);
    }
    /**
     * Get the current memory usage.
     * @returns {Object}
     */
    memoryUsage() {
      return this.logger.memoryUsage();
    }
    /**
     * Log the current memory usage.
     */
    memory() {
      this.logger.memory(this.module);
    }
  }
  g.HAS_TTY = !!(It.stdout && It.stdout.isTTY), g.MAX_FILE_SIZE = 20 << 20, g.MAX_ARCHIVAL_FILES = 10, g.levels = {
    NONE: 0,
    ERROR: 1,
    WARNING: 2,
    INFO: 3,
    DEBUG: 4,
    SPAM: 5
  }, g.levelsByVal = [
    "none",
    "error",
    "warning",
    "info",
    "debug",
    "spam"
  ], g.prefixByVal = [
    "N",
    "E",
    "W",
    "I",
    "D",
    "S"
  ], g.styles = [
    "0",
    "1;31",
    "1;33",
    "94",
    "90",
    "90"
  ], g.global = new g();
  function n(i) {
    return Math.floor(i / (1 << 20));
  }
  function u(i) {
    return new Promise((p, m) => {
      const E = w.createWriteStream(i, { flags: "a" }), v = () => {
        E.removeListener("error", b), E.removeListener("open", h);
      }, b = (o) => {
        try {
          E.close();
        } catch {
        }
        v(), m(o);
      }, h = () => {
        v(), p(E);
      };
      E.once("error", b), E.once("open", h);
    });
  }
  function a(i) {
    return new Promise((p, m) => {
      const E = () => {
        i.removeListener("error", v), i.removeListener("close", b);
      }, v = (h) => {
        E(), m(h);
      }, b = () => {
        E(), p(i);
      };
      i.removeAllListeners("error"), i.removeAllListeners("close"), i.once("error", v), i.once("close", b), i.close();
    });
  }
  function s() {
    let i = (/* @__PURE__ */ new Date()).toJSON();
    return i = i.replace(/:/g, "-").replace("T", "_").replace(".", "-").slice(0, -1), i;
  }
  return Ku = g, Ku;
}
/*!
 * blgr.js - basic logger for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var Vu, f3;
function qx() {
  return f3 || (f3 = 1, Vu = Nx()), Vu;
}
var Wt = {}, c3;
function Ol() {
  if (c3) return Wt;
  c3 = 1;
  const e = Mt();
  function c(b, h) {
    if (e(k.isBuffer(b)), e(k.isBuffer(h)), g(b.length, 0))
      return g(h.length, 0);
    let o = b.length ^ h.length;
    for (let S = 0; S < h.length; S++)
      o |= b[S % b.length] ^ h[S];
    return o - 1 >>> 31;
  }
  function d(b, h) {
    if (e(k.isBuffer(b)), e(k.isBuffer(h)), !g(b.length, h.length))
      return 0;
    let o = 0;
    for (let S = 0; S < b.length; S++)
      o |= b[S] ^ h[S];
    return o - 1 >>> 31;
  }
  function w(b, h) {
    return g(b & 255, h & 255);
  }
  function g(b, h) {
    return (b ^ h) - 1 >>> 31;
  }
  function f(b, h, o) {
    return b & o - 1 | h & ~(o - 1);
  }
  function n(b, h) {
    return b - h >>> 31;
  }
  function u(b, h) {
    return b - h - 1 >>> 31;
  }
  function a(b, h) {
    return h - b >>> 31;
  }
  function s(b, h) {
    return h - b - 1 >>> 31;
  }
  function i(b, h) {
    return f(b, h, n(h, b));
  }
  function p(b, h) {
    return f(b, h, a(h, b));
  }
  function m(b) {
    return (b | 0) * (b >> 31 | 1);
  }
  function E(b) {
    return (b >> 31 | -b >> 31) & 1;
  }
  function v(b, h, o) {
    e(k.isBuffer(b)), e(k.isBuffer(h)), e(g(b.length, h.length));
    const S = o - 1 & 255, H = ~(o - 1) & 255;
    for (let j = 0; j < b.length; j++)
      b[j] = b[j] & S | h[j] & H;
  }
  return Wt.safeCompare = c, Wt.safeEqual = d, Wt.safeEqualByte = w, Wt.safeEqualInt = g, Wt.safeSelect = f, Wt.safeLT = n, Wt.safeLTE = u, Wt.safeGT = a, Wt.safeGTE = s, Wt.safeMin = i, Wt.safeMax = p, Wt.safeAbs = m, Wt.safeBool = E, Wt.safeCopy = v, Wt;
}
var Tn = {}, $u, u3;
function zx() {
  if (u3) return $u;
  u3 = 1;
  const e = Mt(), c = new Uint32Array([
    3328402341,
    4168907908,
    4000806809,
    4135287693,
    4294111757,
    3597364157,
    3731845041,
    2445657428,
    1613770832,
    33620227,
    3462883241,
    1445669757,
    3892248089,
    3050821474,
    1303096294,
    3967186586,
    2412431941,
    528646813,
    2311702848,
    4202528135,
    4026202645,
    2992200171,
    2387036105,
    4226871307,
    1101901292,
    3017069671,
    1604494077,
    1169141738,
    597466303,
    1403299063,
    3832705686,
    2613100635,
    1974974402,
    3791519004,
    1033081774,
    1277568618,
    1815492186,
    2118074177,
    4126668546,
    2211236943,
    1748251740,
    1369810420,
    3521504564,
    4193382664,
    3799085459,
    2883115123,
    1647391059,
    706024767,
    134480908,
    2512897874,
    1176707941,
    2646852446,
    806885416,
    932615841,
    168101135,
    798661301,
    235341577,
    605164086,
    461406363,
    3756188221,
    3454790438,
    1311188841,
    2142417613,
    3933566367,
    302582043,
    495158174,
    1479289972,
    874125870,
    907746093,
    3698224818,
    3025820398,
    1537253627,
    2756858614,
    1983593293,
    3084310113,
    2108928974,
    1378429307,
    3722699582,
    1580150641,
    327451799,
    2790478837,
    3117535592,
    0,
    3253595436,
    1075847264,
    3825007647,
    2041688520,
    3059440621,
    3563743934,
    2378943302,
    1740553945,
    1916352843,
    2487896798,
    2555137236,
    2958579944,
    2244988746,
    3151024235,
    3320835882,
    1336584933,
    3992714006,
    2252555205,
    2588757463,
    1714631509,
    293963156,
    2319795663,
    3925473552,
    67240454,
    4269768577,
    2689618160,
    2017213508,
    631218106,
    1269344483,
    2723238387,
    1571005438,
    2151694528,
    93294474,
    1066570413,
    563977660,
    1882732616,
    4059428100,
    1673313503,
    2008463041,
    2950355573,
    1109467491,
    537923632,
    3858759450,
    4260623118,
    3218264685,
    2177748300,
    403442708,
    638784309,
    3287084079,
    3193921505,
    899127202,
    2286175436,
    773265209,
    2479146071,
    1437050866,
    4236148354,
    2050833735,
    3362022572,
    3126681063,
    840505643,
    3866325909,
    3227541664,
    427917720,
    2655997905,
    2749160575,
    1143087718,
    1412049534,
    999329963,
    193497219,
    2353415882,
    3354324521,
    1807268051,
    672404540,
    2816401017,
    3160301282,
    369822493,
    2916866934,
    3688947771,
    1681011286,
    1949973070,
    336202270,
    2454276571,
    201721354,
    1210328172,
    3093060836,
    2680341085,
    3184776046,
    1135389935,
    3294782118,
    965841320,
    831886756,
    3554993207,
    4068047243,
    3588745010,
    2345191491,
    1849112409,
    3664604599,
    26054028,
    2983581028,
    2622377682,
    1235855840,
    3630984372,
    2891339514,
    4092916743,
    3488279077,
    3395642799,
    4101667470,
    1202630377,
    268961816,
    1874508501,
    4034427016,
    1243948399,
    1546530418,
    941366308,
    1470539505,
    1941222599,
    2546386513,
    3421038627,
    2715671932,
    3899946140,
    1042226977,
    2521517021,
    1639824860,
    227249030,
    260737669,
    3765465232,
    2084453954,
    1907733956,
    3429263018,
    2420656344,
    100860677,
    4160157185,
    470683154,
    3261161891,
    1781871967,
    2924959737,
    1773779408,
    394692241,
    2579611992,
    974986535,
    664706745,
    3655459128,
    3958962195,
    731420851,
    571543859,
    3530123707,
    2849626480,
    126783113,
    865375399,
    765172662,
    1008606754,
    361203602,
    3387549984,
    2278477385,
    2857719295,
    1344809080,
    2782912378,
    59542671,
    1503764984,
    160008576,
    437062935,
    1707065306,
    3622233649,
    2218934982,
    3496503480,
    2185314755,
    697932208,
    1512910199,
    504303377,
    2075177163,
    2824099068,
    1841019862,
    739644986
  ]), d = new Uint32Array([
    2781242211,
    2230877308,
    2582542199,
    2381740923,
    234877682,
    3184946027,
    2984144751,
    1418839493,
    1348481072,
    50462977,
    2848876391,
    2102799147,
    434634494,
    1656084439,
    3863849899,
    2599188086,
    1167051466,
    2636087938,
    1082771913,
    2281340285,
    368048890,
    3954334041,
    3381544775,
    201060592,
    3963727277,
    1739838676,
    4250903202,
    3930435503,
    3206782108,
    4149453988,
    2531553906,
    1536934080,
    3262494647,
    484572669,
    2923271059,
    1783375398,
    1517041206,
    1098792767,
    49674231,
    1334037708,
    1550332980,
    4098991525,
    886171109,
    150598129,
    2481090929,
    1940642008,
    1398944049,
    1059722517,
    201851908,
    1385547719,
    1699095331,
    1587397571,
    674240536,
    2704774806,
    252314885,
    3039795866,
    151914247,
    908333586,
    2602270848,
    1038082786,
    651029483,
    1766729511,
    3447698098,
    2682942837,
    454166793,
    2652734339,
    1951935532,
    775166490,
    758520603,
    3000790638,
    4004797018,
    4217086112,
    4137964114,
    1299594043,
    1639438038,
    3464344499,
    2068982057,
    1054729187,
    1901997871,
    2534638724,
    4121318227,
    1757008337,
    0,
    750906861,
    1614815264,
    535035132,
    3363418545,
    3988151131,
    3201591914,
    1183697867,
    3647454910,
    1265776953,
    3734260298,
    3566750796,
    3903871064,
    1250283471,
    1807470800,
    717615087,
    3847203498,
    384695291,
    3313910595,
    3617213773,
    1432761139,
    2484176261,
    3481945413,
    283769337,
    100925954,
    2180939647,
    4037038160,
    1148730428,
    3123027871,
    3813386408,
    4087501137,
    4267549603,
    3229630528,
    2315620239,
    2906624658,
    3156319645,
    1215313976,
    82966005,
    3747855548,
    3245848246,
    1974459098,
    1665278241,
    807407632,
    451280895,
    251524083,
    1841287890,
    1283575245,
    337120268,
    891687699,
    801369324,
    3787349855,
    2721421207,
    3431482436,
    959321879,
    1469301956,
    4065699751,
    2197585534,
    1199193405,
    2898814052,
    3887750493,
    724703513,
    2514908019,
    2696962144,
    2551808385,
    3516813135,
    2141445340,
    1715741218,
    2119445034,
    2872807568,
    2198571144,
    3398190662,
    700968686,
    3547052216,
    1009259540,
    2041044702,
    3803995742,
    487983883,
    1991105499,
    1004265696,
    1449407026,
    1316239930,
    504629770,
    3683797321,
    168560134,
    1816667172,
    3837287516,
    1570751170,
    1857934291,
    4014189740,
    2797888098,
    2822345105,
    2754712981,
    936633572,
    2347923833,
    852879335,
    1133234376,
    1500395319,
    3084545389,
    2348912013,
    1689376213,
    3533459022,
    3762923945,
    3034082412,
    4205598294,
    133428468,
    634383082,
    2949277029,
    2398386810,
    3913789102,
    403703816,
    3580869306,
    2297460856,
    1867130149,
    1918643758,
    607656988,
    4049053350,
    3346248884,
    1368901318,
    600565992,
    2090982877,
    2632479860,
    557719327,
    3717614411,
    3697393085,
    2249034635,
    2232388234,
    2430627952,
    1115438654,
    3295786421,
    2865522278,
    3633334344,
    84280067,
    33027830,
    303828494,
    2747425121,
    1600795957,
    4188952407,
    3496589753,
    2434238086,
    1486471617,
    658119965,
    3106381470,
    953803233,
    334231800,
    3005978776,
    857870609,
    3151128937,
    1890179545,
    2298973838,
    2805175444,
    3056442267,
    574365214,
    2450884487,
    550103529,
    1233637070,
    4289353045,
    2018519080,
    2057691103,
    2399374476,
    4166623649,
    2148108681,
    387583245,
    3664101311,
    836232934,
    3330556482,
    3100665960,
    3280093505,
    2955516313,
    2002398509,
    287182607,
    3413881008,
    4238890068,
    3597515707,
    975967766
  ]), w = new Uint32Array([
    1671808611,
    2089089148,
    2006576759,
    2072901243,
    4061003762,
    1807603307,
    1873927791,
    3310653893,
    810573872,
    16974337,
    1739181671,
    729634347,
    4263110654,
    3613570519,
    2883997099,
    1989864566,
    3393556426,
    2191335298,
    3376449993,
    2106063485,
    4195741690,
    1508618841,
    1204391495,
    4027317232,
    2917941677,
    3563566036,
    2734514082,
    2951366063,
    2629772188,
    2767672228,
    1922491506,
    3227229120,
    3082974647,
    4246528509,
    2477669779,
    644500518,
    911895606,
    1061256767,
    4144166391,
    3427763148,
    878471220,
    2784252325,
    3845444069,
    4043897329,
    1905517169,
    3631459288,
    827548209,
    356461077,
    67897348,
    3344078279,
    593839651,
    3277757891,
    405286936,
    2527147926,
    84871685,
    2595565466,
    118033927,
    305538066,
    2157648768,
    3795705826,
    3945188843,
    661212711,
    2999812018,
    1973414517,
    152769033,
    2208177539,
    745822252,
    439235610,
    455947803,
    1857215598,
    1525593178,
    2700827552,
    1391895634,
    994932283,
    3596728278,
    3016654259,
    695947817,
    3812548067,
    795958831,
    2224493444,
    1408607827,
    3513301457,
    0,
    3979133421,
    543178784,
    4229948412,
    2982705585,
    1542305371,
    1790891114,
    3410398667,
    3201918910,
    961245753,
    1256100938,
    1289001036,
    1491644504,
    3477767631,
    3496721360,
    4012557807,
    2867154858,
    4212583931,
    1137018435,
    1305975373,
    861234739,
    2241073541,
    1171229253,
    4178635257,
    33948674,
    2139225727,
    1357946960,
    1011120188,
    2679776671,
    2833468328,
    1374921297,
    2751356323,
    1086357568,
    2408187279,
    2460827538,
    2646352285,
    944271416,
    4110742005,
    3168756668,
    3066132406,
    3665145818,
    560153121,
    271589392,
    4279952895,
    4077846003,
    3530407890,
    3444343245,
    202643468,
    322250259,
    3962553324,
    1608629855,
    2543990167,
    1154254916,
    389623319,
    3294073796,
    2817676711,
    2122513534,
    1028094525,
    1689045092,
    1575467613,
    422261273,
    1939203699,
    1621147744,
    2174228865,
    1339137615,
    3699352540,
    577127458,
    712922154,
    2427141008,
    2290289544,
    1187679302,
    3995715566,
    3100863416,
    339486740,
    3732514782,
    1591917662,
    186455563,
    3681988059,
    3762019296,
    844522546,
    978220090,
    169743370,
    1239126601,
    101321734,
    611076132,
    1558493276,
    3260915650,
    3547250131,
    2901361580,
    1655096418,
    2443721105,
    2510565781,
    3828863972,
    2039214713,
    3878868455,
    3359869896,
    928607799,
    1840765549,
    2374762893,
    3580146133,
    1322425422,
    2850048425,
    1823791212,
    1459268694,
    4094161908,
    3928346602,
    1706019429,
    2056189050,
    2934523822,
    135794696,
    3134549946,
    2022240376,
    628050469,
    779246638,
    472135708,
    2800834470,
    3032970164,
    3327236038,
    3894660072,
    3715932637,
    1956440180,
    522272287,
    1272813131,
    3185336765,
    2340818315,
    2323976074,
    1888542832,
    1044544574,
    3049550261,
    1722469478,
    1222152264,
    50660867,
    4127324150,
    236067854,
    1638122081,
    895445557,
    1475980887,
    3117443513,
    2257655686,
    3243809217,
    489110045,
    2662934430,
    3778599393,
    4162055160,
    2561878936,
    288563729,
    1773916777,
    3648039385,
    2391345038,
    2493985684,
    2612407707,
    505560094,
    2274497927,
    3911240169,
    3460925390,
    1442818645,
    678973480,
    3749357023,
    2358182796,
    2717407649,
    2306869641,
    219617805,
    3218761151,
    3862026214,
    1120306242,
    1756942440,
    1103331905,
    2578459033,
    762796589,
    252780047,
    2966125488,
    1425844308,
    3151392187,
    372911126
  ]), g = new Uint32Array([
    1667474886,
    2088535288,
    2004326894,
    2071694838,
    4075949567,
    1802223062,
    1869591006,
    3318043793,
    808472672,
    16843522,
    1734846926,
    724270422,
    4278065639,
    3621216949,
    2880169549,
    1987484396,
    3402253711,
    2189597983,
    3385409673,
    2105378810,
    4210693615,
    1499065266,
    1195886990,
    4042263547,
    2913856577,
    3570689971,
    2728590687,
    2947541573,
    2627518243,
    2762274643,
    1920112356,
    3233831835,
    3082273397,
    4261223649,
    2475929149,
    640051788,
    909531756,
    1061110142,
    4160160501,
    3435941763,
    875846760,
    2779116625,
    3857003729,
    4059105529,
    1903268834,
    3638064043,
    825316194,
    353713962,
    67374088,
    3351728789,
    589522246,
    3284360861,
    404236336,
    2526454071,
    84217610,
    2593830191,
    117901582,
    303183396,
    2155911963,
    3806477791,
    3958056653,
    656894286,
    2998062463,
    1970642922,
    151591698,
    2206440989,
    741110872,
    437923380,
    454765878,
    1852748508,
    1515908788,
    2694904667,
    1381168804,
    993742198,
    3604373943,
    3014905469,
    690584402,
    3823320797,
    791638366,
    2223281939,
    1398011302,
    3520161977,
    0,
    3991743681,
    538992704,
    4244381667,
    2981218425,
    1532751286,
    1785380564,
    3419096717,
    3200178535,
    960056178,
    1246420628,
    1280103576,
    1482221744,
    3486468741,
    3503319995,
    4025428677,
    2863326543,
    4227536621,
    1128514950,
    1296947098,
    859002214,
    2240123921,
    1162203018,
    4193849577,
    33687044,
    2139062782,
    1347481760,
    1010582648,
    2678045221,
    2829640523,
    1364325282,
    2745433693,
    1077985408,
    2408548869,
    2459086143,
    2644360225,
    943212656,
    4126475505,
    3166494563,
    3065430391,
    3671750063,
    555836226,
    269496352,
    4294908645,
    4092792573,
    3537006015,
    3452783745,
    202118168,
    320025894,
    3974901699,
    1600119230,
    2543297077,
    1145359496,
    387397934,
    3301201811,
    2812801621,
    2122220284,
    1027426170,
    1684319432,
    1566435258,
    421079858,
    1936954854,
    1616945344,
    2172753945,
    1330631070,
    3705438115,
    572679748,
    707427924,
    2425400123,
    2290647819,
    1179044492,
    4008585671,
    3099120491,
    336870440,
    3739122087,
    1583276732,
    185277718,
    3688593069,
    3772791771,
    842159716,
    976899700,
    168435220,
    1229577106,
    101059084,
    606366792,
    1549591736,
    3267517855,
    3553849021,
    2897014595,
    1650632388,
    2442242105,
    2509612081,
    3840161747,
    2038008818,
    3890688725,
    3368567691,
    926374254,
    1835907034,
    2374863873,
    3587531953,
    1313788572,
    2846482505,
    1819063512,
    1448540844,
    4109633523,
    3941213647,
    1701162954,
    2054852340,
    2930698567,
    134748176,
    3132806511,
    2021165296,
    623210314,
    774795868,
    471606328,
    2795958615,
    3031746419,
    3334885783,
    3907527627,
    3722280097,
    1953799400,
    522133822,
    1263263126,
    3183336545,
    2341176845,
    2324333839,
    1886425312,
    1044267644,
    3048588401,
    1718004428,
    1212733584,
    50529542,
    4143317495,
    235803164,
    1633788866,
    892690282,
    1465383342,
    3115962473,
    2256965911,
    3250673817,
    488449850,
    2661202215,
    3789633753,
    4177007595,
    2560144171,
    286339874,
    1768537042,
    3654906025,
    2391705863,
    2492770099,
    2610673197,
    505291324,
    2273808917,
    3924369609,
    3469625735,
    1431699370,
    673740880,
    3755965093,
    2358021891,
    2711746649,
    2307489801,
    218961690,
    3217021541,
    3873845719,
    1111672452,
    1751693520,
    1094828930,
    2576986153,
    757954394,
    252645662,
    2964376443,
    1414855848,
    3149649517,
    370555436
  ]), f = new Uint32Array([
    1374988112,
    2118214995,
    437757123,
    975658646,
    1001089995,
    530400753,
    2902087851,
    1273168787,
    540080725,
    2910219766,
    2295101073,
    4110568485,
    1340463100,
    3307916247,
    641025152,
    3043140495,
    3736164937,
    632953703,
    1172967064,
    1576976609,
    3274667266,
    2169303058,
    2370213795,
    1809054150,
    59727847,
    361929877,
    3211623147,
    2505202138,
    3569255213,
    1484005843,
    1239443753,
    2395588676,
    1975683434,
    4102977912,
    2572697195,
    666464733,
    3202437046,
    4035489047,
    3374361702,
    2110667444,
    1675577880,
    3843699074,
    2538681184,
    1649639237,
    2976151520,
    3144396420,
    4269907996,
    4178062228,
    1883793496,
    2403728665,
    2497604743,
    1383856311,
    2876494627,
    1917518562,
    3810496343,
    1716890410,
    3001755655,
    800440835,
    2261089178,
    3543599269,
    807962610,
    599762354,
    33778362,
    3977675356,
    2328828971,
    2809771154,
    4077384432,
    1315562145,
    1708848333,
    101039829,
    3509871135,
    3299278474,
    875451293,
    2733856160,
    92987698,
    2767645557,
    193195065,
    1080094634,
    1584504582,
    3178106961,
    1042385657,
    2531067453,
    3711829422,
    1306967366,
    2438237621,
    1908694277,
    67556463,
    1615861247,
    429456164,
    3602770327,
    2302690252,
    1742315127,
    2968011453,
    126454664,
    3877198648,
    2043211483,
    2709260871,
    2084704233,
    4169408201,
    0,
    159417987,
    841739592,
    504459436,
    1817866830,
    4245618683,
    260388950,
    1034867998,
    908933415,
    168810852,
    1750902305,
    2606453969,
    607530554,
    202008497,
    2472011535,
    3035535058,
    463180190,
    2160117071,
    1641816226,
    1517767529,
    470948374,
    3801332234,
    3231722213,
    1008918595,
    303765277,
    235474187,
    4069246893,
    766945465,
    337553864,
    1475418501,
    2943682380,
    4003061179,
    2743034109,
    4144047775,
    1551037884,
    1147550661,
    1543208500,
    2336434550,
    3408119516,
    3069049960,
    3102011747,
    3610369226,
    1113818384,
    328671808,
    2227573024,
    2236228733,
    3535486456,
    2935566865,
    3341394285,
    496906059,
    3702665459,
    226906860,
    2009195472,
    733156972,
    2842737049,
    294930682,
    1206477858,
    2835123396,
    2700099354,
    1451044056,
    573804783,
    2269728455,
    3644379585,
    2362090238,
    2564033334,
    2801107407,
    2776292904,
    3669462566,
    1068351396,
    742039012,
    1350078989,
    1784663195,
    1417561698,
    4136440770,
    2430122216,
    775550814,
    2193862645,
    2673705150,
    1775276924,
    1876241833,
    3475313331,
    3366754619,
    270040487,
    3902563182,
    3678124923,
    3441850377,
    1851332852,
    3969562369,
    2203032232,
    3868552805,
    2868897406,
    566021896,
    4011190502,
    3135740889,
    1248802510,
    3936291284,
    699432150,
    832877231,
    708780849,
    3332740144,
    899835584,
    1951317047,
    4236429990,
    3767586992,
    866637845,
    4043610186,
    1106041591,
    2144161806,
    395441711,
    1984812685,
    1139781709,
    3433712980,
    3835036895,
    2664543715,
    1282050075,
    3240894392,
    1181045119,
    2640243204,
    25965917,
    4203181171,
    4211818798,
    3009879386,
    2463879762,
    3910161971,
    1842759443,
    2597806476,
    933301370,
    1509430414,
    3943906441,
    3467192302,
    3076639029,
    3776767469,
    2051518780,
    2631065433,
    1441952575,
    404016761,
    1942435775,
    1408749034,
    1610459739,
    3745345300,
    2017778566,
    3400528769,
    3110650942,
    941896748,
    3265478751,
    371049330,
    3168937228,
    675039627,
    4279080257,
    967311729,
    135050206,
    3635733660,
    1683407248,
    2076935265,
    3576870512,
    1215061108,
    3501741890
  ]), n = new Uint32Array([
    1347548327,
    1400783205,
    3273267108,
    2520393566,
    3409685355,
    4045380933,
    2880240216,
    2471224067,
    1428173050,
    4138563181,
    2441661558,
    636813900,
    4233094615,
    3620022987,
    2149987652,
    2411029155,
    1239331162,
    1730525723,
    2554718734,
    3781033664,
    46346101,
    310463728,
    2743944855,
    3328955385,
    3875770207,
    2501218972,
    3955191162,
    3667219033,
    768917123,
    3545789473,
    692707433,
    1150208456,
    1786102409,
    2029293177,
    1805211710,
    3710368113,
    3065962831,
    401639597,
    1724457132,
    3028143674,
    409198410,
    2196052529,
    1620529459,
    1164071807,
    3769721975,
    2226875310,
    486441376,
    2499348523,
    1483753576,
    428819965,
    2274680428,
    3075636216,
    598438867,
    3799141122,
    1474502543,
    711349675,
    129166120,
    53458370,
    2592523643,
    2782082824,
    4063242375,
    2988687269,
    3120694122,
    1559041666,
    730517276,
    2460449204,
    4042459122,
    2706270690,
    3446004468,
    3573941694,
    533804130,
    2328143614,
    2637442643,
    2695033685,
    839224033,
    1973745387,
    957055980,
    2856345839,
    106852767,
    1371368976,
    4181598602,
    1033297158,
    2933734917,
    1179510461,
    3046200461,
    91341917,
    1862534868,
    4284502037,
    605657339,
    2547432937,
    3431546947,
    2003294622,
    3182487618,
    2282195339,
    954669403,
    3682191598,
    1201765386,
    3917234703,
    3388507166,
    0,
    2198438022,
    1211247597,
    2887651696,
    1315723890,
    4227665663,
    1443857720,
    507358933,
    657861945,
    1678381017,
    560487590,
    3516619604,
    975451694,
    2970356327,
    261314535,
    3535072918,
    2652609425,
    1333838021,
    2724322336,
    1767536459,
    370938394,
    182621114,
    3854606378,
    1128014560,
    487725847,
    185469197,
    2918353863,
    3106780840,
    3356761769,
    2237133081,
    1286567175,
    3152976349,
    4255350624,
    2683765030,
    3160175349,
    3309594171,
    878443390,
    1988838185,
    3704300486,
    1756818940,
    1673061617,
    3403100636,
    272786309,
    1075025698,
    545572369,
    2105887268,
    4174560061,
    296679730,
    1841768865,
    1260232239,
    4091327024,
    3960309330,
    3497509347,
    1814803222,
    2578018489,
    4195456072,
    575138148,
    3299409036,
    446754879,
    3629546796,
    4011996048,
    3347532110,
    3252238545,
    4270639778,
    915985419,
    3483825537,
    681933534,
    651868046,
    2755636671,
    3828103837,
    223377554,
    2607439820,
    1649704518,
    3270937875,
    3901806776,
    1580087799,
    4118987695,
    3198115200,
    2087309459,
    2842678573,
    3016697106,
    1003007129,
    2802849917,
    1860738147,
    2077965243,
    164439672,
    4100872472,
    32283319,
    2827177882,
    1709610350,
    2125135846,
    136428751,
    3874428392,
    3652904859,
    3460984630,
    3572145929,
    3593056380,
    2939266226,
    824852259,
    818324884,
    3224740454,
    930369212,
    2801566410,
    2967507152,
    355706840,
    1257309336,
    4148292826,
    243256656,
    790073846,
    2373340630,
    1296297904,
    1422699085,
    3756299780,
    3818836405,
    457992840,
    3099667487,
    2135319889,
    77422314,
    1560382517,
    1945798516,
    788204353,
    1521706781,
    1385356242,
    870912086,
    325965383,
    2358957921,
    2050466060,
    2388260884,
    2313884476,
    4006521127,
    901210569,
    3990953189,
    1014646705,
    1503449823,
    1062597235,
    2031621326,
    3212035895,
    3931371469,
    1533017514,
    350174575,
    2256028891,
    2177544179,
    1052338372,
    741876788,
    1606591296,
    1914052035,
    213705253,
    2334669897,
    1107234197,
    1899603969,
    3725069491,
    2631447780,
    2422494913,
    1635502980,
    1893020342,
    1950903388,
    1120974935
  ]), u = new Uint32Array([
    2807058932,
    1699970625,
    2764249623,
    1586903591,
    1808481195,
    1173430173,
    1487645946,
    59984867,
    4199882800,
    1844882806,
    1989249228,
    1277555970,
    3623636965,
    3419915562,
    1149249077,
    2744104290,
    1514790577,
    459744698,
    244860394,
    3235995134,
    1963115311,
    4027744588,
    2544078150,
    4190530515,
    1608975247,
    2627016082,
    2062270317,
    1507497298,
    2200818878,
    567498868,
    1764313568,
    3359936201,
    2305455554,
    2037970062,
    1047239e3,
    1910319033,
    1337376481,
    2904027272,
    2892417312,
    984907214,
    1243112415,
    830661914,
    861968209,
    2135253587,
    2011214180,
    2927934315,
    2686254721,
    731183368,
    1750626376,
    4246310725,
    1820824798,
    4172763771,
    3542330227,
    48394827,
    2404901663,
    2871682645,
    671593195,
    3254988725,
    2073724613,
    145085239,
    2280796200,
    2779915199,
    1790575107,
    2187128086,
    472615631,
    3029510009,
    4075877127,
    3802222185,
    4107101658,
    3201631749,
    1646252340,
    4270507174,
    1402811438,
    1436590835,
    3778151818,
    3950355702,
    3963161475,
    4020912224,
    2667994737,
    273792366,
    2331590177,
    104699613,
    95345982,
    3175501286,
    2377486676,
    1560637892,
    3564045318,
    369057872,
    4213447064,
    3919042237,
    1137477952,
    2658625497,
    1119727848,
    2340947849,
    1530455833,
    4007360968,
    172466556,
    266959938,
    516552836,
    0,
    2256734592,
    3980931627,
    1890328081,
    1917742170,
    4294704398,
    945164165,
    3575528878,
    958871085,
    3647212047,
    2787207260,
    1423022939,
    775562294,
    1739656202,
    3876557655,
    2530391278,
    2443058075,
    3310321856,
    547512796,
    1265195639,
    437656594,
    3121275539,
    719700128,
    3762502690,
    387781147,
    218828297,
    3350065803,
    2830708150,
    2848461854,
    428169201,
    122466165,
    3720081049,
    1627235199,
    648017665,
    4122762354,
    1002783846,
    2117360635,
    695634755,
    3336358691,
    4234721005,
    4049844452,
    3704280881,
    2232435299,
    574624663,
    287343814,
    612205898,
    1039717051,
    840019705,
    2708326185,
    793451934,
    821288114,
    1391201670,
    3822090177,
    376187827,
    3113855344,
    1224348052,
    1679968233,
    2361698556,
    1058709744,
    752375421,
    2431590963,
    1321699145,
    3519142200,
    2734591178,
    188127444,
    2177869557,
    3727205754,
    2384911031,
    3215212461,
    2648976442,
    2450346104,
    3432737375,
    1180849278,
    331544205,
    3102249176,
    4150144569,
    2952102595,
    2159976285,
    2474404304,
    766078933,
    313773861,
    2570832044,
    2108100632,
    1668212892,
    3145456443,
    2013908262,
    418672217,
    3070356634,
    2594734927,
    1852171925,
    3867060991,
    3473416636,
    3907448597,
    2614737639,
    919489135,
    164948639,
    2094410160,
    2997825956,
    590424639,
    2486224549,
    1723872674,
    3157750862,
    3399941250,
    3501252752,
    3625268135,
    2555048196,
    3673637356,
    1343127501,
    4130281361,
    3599595085,
    2957853679,
    1297403050,
    81781910,
    3051593425,
    2283490410,
    532201772,
    1367295589,
    3926170974,
    895287692,
    1953757831,
    1093597963,
    492483431,
    3528626907,
    1446242576,
    1192455638,
    1636604631,
    209336225,
    344873464,
    1015671571,
    669961897,
    3375740769,
    3857572124,
    2973530695,
    3747192018,
    1933530610,
    3464042516,
    935293895,
    3454686199,
    2858115069,
    1863638845,
    3683022916,
    4085369519,
    3292445032,
    875313188,
    1080017571,
    3279033885,
    621591778,
    1233856572,
    2504130317,
    24197544,
    3017672716,
    3835484340,
    3247465558,
    2220981195,
    3060847922,
    1551124588,
    1463996600
  ]), a = new Uint32Array([
    4104605777,
    1097159550,
    396673818,
    660510266,
    2875968315,
    2638606623,
    4200115116,
    3808662347,
    821712160,
    1986918061,
    3430322568,
    38544885,
    3856137295,
    718002117,
    893681702,
    1654886325,
    2975484382,
    3122358053,
    3926825029,
    4274053469,
    796197571,
    1290801793,
    1184342925,
    3556361835,
    2405426947,
    2459735317,
    1836772287,
    1381620373,
    3196267988,
    1948373848,
    3764988233,
    3385345166,
    3263785589,
    2390325492,
    1480485785,
    3111247143,
    3780097726,
    2293045232,
    548169417,
    3459953789,
    3746175075,
    439452389,
    1362321559,
    1400849762,
    1685577905,
    1806599355,
    2174754046,
    137073913,
    1214797936,
    1174215055,
    3731654548,
    2079897426,
    1943217067,
    1258480242,
    529487843,
    1437280870,
    3945269170,
    3049390895,
    3313212038,
    923313619,
    679998e3,
    3215307299,
    57326082,
    377642221,
    3474729866,
    2041877159,
    133361907,
    1776460110,
    3673476453,
    96392454,
    878845905,
    2801699524,
    777231668,
    4082475170,
    2330014213,
    4142626212,
    2213296395,
    1626319424,
    1906247262,
    1846563261,
    562755902,
    3708173718,
    1040559837,
    3871163981,
    1418573201,
    3294430577,
    114585348,
    1343618912,
    2566595609,
    3186202582,
    1078185097,
    3651041127,
    3896688048,
    2307622919,
    425408743,
    3371096953,
    2081048481,
    1108339068,
    2216610296,
    0,
    2156299017,
    736970802,
    292596766,
    1517440620,
    251657213,
    2235061775,
    2933202493,
    758720310,
    265905162,
    1554391400,
    1532285339,
    908999204,
    174567692,
    1474760595,
    4002861748,
    2610011675,
    3234156416,
    3693126241,
    2001430874,
    303699484,
    2478443234,
    2687165888,
    585122620,
    454499602,
    151849742,
    2345119218,
    3064510765,
    514443284,
    4044981591,
    1963412655,
    2581445614,
    2137062819,
    19308535,
    1928707164,
    1715193156,
    4219352155,
    1126790795,
    600235211,
    3992742070,
    3841024952,
    836553431,
    1669664834,
    2535604243,
    3323011204,
    1243905413,
    3141400786,
    4180808110,
    698445255,
    2653899549,
    2989552604,
    2253581325,
    3252932727,
    3004591147,
    1891211689,
    2487810577,
    3915653703,
    4237083816,
    4030667424,
    2100090966,
    865136418,
    1229899655,
    953270745,
    3399679628,
    3557504664,
    4118925222,
    2061379749,
    3079546586,
    2915017791,
    983426092,
    2022837584,
    1607244650,
    2118541908,
    2366882550,
    3635996816,
    972512814,
    3283088770,
    1568718495,
    3499326569,
    3576539503,
    621982671,
    2895723464,
    410887952,
    2623762152,
    1002142683,
    645401037,
    1494807662,
    2595684844,
    1335535747,
    2507040230,
    4293295786,
    3167684641,
    367585007,
    3885750714,
    1865862730,
    2668221674,
    2960971305,
    2763173681,
    1059270954,
    2777952454,
    2724642869,
    1320957812,
    2194319100,
    2429595872,
    2815956275,
    77089521,
    3973773121,
    3444575871,
    2448830231,
    1305906550,
    4021308739,
    2857194700,
    2516901860,
    3518358430,
    1787304780,
    740276417,
    1699839814,
    1592394909,
    2352307457,
    2272556026,
    188821243,
    1729977011,
    3687994002,
    274084841,
    3594982253,
    3613494426,
    2701949495,
    4162096729,
    322734571,
    2837966542,
    1640576439,
    484830689,
    1202797690,
    3537852828,
    4067639125,
    349075736,
    3342319475,
    4157467219,
    4255800159,
    1030690015,
    1155237496,
    2951971274,
    1757691577,
    607398968,
    2738905026,
    499347990,
    3794078908,
    1011452712,
    227885567,
    2818666809,
    213114376,
    3034881240,
    1455525988,
    3414450555,
    850817237,
    1817998408,
    3092726480
  ]), s = new Uint8Array([
    82,
    9,
    106,
    213,
    48,
    54,
    165,
    56,
    191,
    64,
    163,
    158,
    129,
    243,
    215,
    251,
    124,
    227,
    57,
    130,
    155,
    47,
    255,
    135,
    52,
    142,
    67,
    68,
    196,
    222,
    233,
    203,
    84,
    123,
    148,
    50,
    166,
    194,
    35,
    61,
    238,
    76,
    149,
    11,
    66,
    250,
    195,
    78,
    8,
    46,
    161,
    102,
    40,
    217,
    36,
    178,
    118,
    91,
    162,
    73,
    109,
    139,
    209,
    37,
    114,
    248,
    246,
    100,
    134,
    104,
    152,
    22,
    212,
    164,
    92,
    204,
    93,
    101,
    182,
    146,
    108,
    112,
    72,
    80,
    253,
    237,
    185,
    218,
    94,
    21,
    70,
    87,
    167,
    141,
    157,
    132,
    144,
    216,
    171,
    0,
    140,
    188,
    211,
    10,
    247,
    228,
    88,
    5,
    184,
    179,
    69,
    6,
    208,
    44,
    30,
    143,
    202,
    63,
    15,
    2,
    193,
    175,
    189,
    3,
    1,
    19,
    138,
    107,
    58,
    145,
    17,
    65,
    79,
    103,
    220,
    234,
    151,
    242,
    207,
    206,
    240,
    180,
    230,
    115,
    150,
    172,
    116,
    34,
    231,
    173,
    53,
    133,
    226,
    249,
    55,
    232,
    28,
    117,
    223,
    110,
    71,
    241,
    26,
    113,
    29,
    41,
    197,
    137,
    111,
    183,
    98,
    14,
    170,
    24,
    190,
    27,
    252,
    86,
    62,
    75,
    198,
    210,
    121,
    32,
    154,
    219,
    192,
    254,
    120,
    205,
    90,
    244,
    31,
    221,
    168,
    51,
    136,
    7,
    199,
    49,
    177,
    18,
    16,
    89,
    39,
    128,
    236,
    95,
    96,
    81,
    127,
    169,
    25,
    181,
    74,
    13,
    45,
    229,
    122,
    159,
    147,
    201,
    156,
    239,
    160,
    224,
    59,
    77,
    174,
    42,
    245,
    176,
    200,
    235,
    187,
    60,
    131,
    83,
    153,
    97,
    23,
    43,
    4,
    126,
    186,
    119,
    214,
    38,
    225,
    105,
    20,
    99,
    85,
    33,
    12,
    125
  ]), i = new Uint32Array([
    16777216,
    33554432,
    67108864,
    134217728,
    268435456,
    536870912,
    1073741824,
    2147483648,
    452984832,
    905969664
  ]);
  class p {
    constructor(h = 256) {
      e(h >>> 0 === h), this.bits = h, this.rounds = m(h), this.key = null, this.encKey = null, this.decKey = null;
    }
    get blockSize() {
      return 16;
    }
    init(h) {
      if (e(k.isBuffer(h)), h.length !== this.bits >>> 3)
        throw new Error("Invalid key size.");
      return this.destroy(), this.key = k.from(h), this.encKey = null, this.decKey = null, this;
    }
    createEncryptKey() {
      if (!this.key)
        throw new Error("Cipher is not initialized.");
      const h = this.key;
      if (h.length !== this.bits >>> 3)
        throw new Error("Invalid key size.");
      const o = new Uint32Array(60);
      o[0] = E(h, 0), o[1] = E(h, 4), o[2] = E(h, 8), o[3] = E(h, 12);
      let S = 0, H = 0;
      if (this.bits === 128) {
        for (; ; ) {
          const j = o[S + 3];
          if (o[S + 4] = o[S] ^ w[j >>> 16 & 255] & 4278190080 ^ g[j >>> 8 & 255] & 16711680 ^ c[j >>> 0 & 255] & 65280 ^ d[j >>> 24 & 255] & 255 ^ i[H], o[S + 5] = o[S + 1] ^ o[S + 4], o[S + 6] = o[S + 2] ^ o[S + 5], o[S + 7] = o[S + 3] ^ o[S + 6], H += 1, H === 10)
            break;
          S += 4;
        }
        return o;
      }
      if (o[S + 4] = E(h, 16), o[S + 5] = E(h, 20), this.bits === 192) {
        for (; ; ) {
          const j = o[S + 5];
          if (o[S + 6] = o[S] ^ w[j >>> 16 & 255] & 4278190080 ^ g[j >>> 8 & 255] & 16711680 ^ c[j >>> 0 & 255] & 65280 ^ d[j >>> 24 & 255] & 255 ^ i[H], o[S + 7] = o[S + 1] ^ o[S + 6], o[S + 8] = o[S + 2] ^ o[S + 7], o[S + 9] = o[S + 3] ^ o[S + 8], H += 1, H === 8)
            break;
          o[S + 10] = o[S + 4] ^ o[S + 9], o[S + 11] = o[S + 5] ^ o[S + 10], S += 6;
        }
        return o;
      }
      if (o[S + 6] = E(h, 24), o[S + 7] = E(h, 28), this.bits === 256) {
        for (; ; ) {
          let j = o[S + 7];
          if (o[S + 8] = o[S] ^ w[j >>> 16 & 255] & 4278190080 ^ g[j >>> 8 & 255] & 16711680 ^ c[j >>> 0 & 255] & 65280 ^ d[j >>> 24 & 255] & 255 ^ i[H], o[S + 9] = o[S + 1] ^ o[S + 8], o[S + 10] = o[S + 2] ^ o[S + 9], o[S + 11] = o[S + 3] ^ o[S + 10], H += 1, H === 7)
            break;
          j = o[S + 11], o[S + 12] = o[S + 4] ^ w[j >>> 24 & 255] & 4278190080 ^ g[j >>> 16 & 255] & 16711680 ^ c[j >>> 8 & 255] & 65280 ^ d[j >>> 0 & 255] & 255, o[S + 13] = o[S + 5] ^ o[S + 12], o[S + 14] = o[S + 6] ^ o[S + 13], o[S + 15] = o[S + 7] ^ o[S + 14], S += 8;
        }
        return o;
      }
      throw new Error("Bad key size.");
    }
    createDecryptKey() {
      const h = this.createEncryptKey();
      let o = 0;
      for (let S = 0, H = 4 * this.rounds; S < H; S += 4, H -= 4) {
        let j = h[o + S + 0];
        h[o + S + 0] = h[o + H + 0], h[o + H + 0] = j, j = h[o + S + 1], h[o + S + 1] = h[o + H + 1], h[o + H + 1] = j, j = h[o + S + 2], h[o + S + 2] = h[o + H + 2], h[o + H + 2] = j, j = h[o + S + 3], h[o + S + 3] = h[o + H + 3], h[o + H + 3] = j;
      }
      for (let S = 1; S < this.rounds; S++)
        o += 4, h[o + 0] = f[d[h[o + 0] >>> 24 & 255] & 255] ^ n[d[h[o + 0] >>> 16 & 255] & 255] ^ u[d[h[o + 0] >>> 8 & 255] & 255] ^ a[d[h[o + 0] >>> 0 & 255] & 255], h[o + 1] = f[d[h[o + 1] >>> 24 & 255] & 255] ^ n[d[h[o + 1] >>> 16 & 255] & 255] ^ u[d[h[o + 1] >>> 8 & 255] & 255] ^ a[d[h[o + 1] >>> 0 & 255] & 255], h[o + 2] = f[d[h[o + 2] >>> 24 & 255] & 255] ^ n[d[h[o + 2] >>> 16 & 255] & 255] ^ u[d[h[o + 2] >>> 8 & 255] & 255] ^ a[d[h[o + 2] >>> 0 & 255] & 255], h[o + 3] = f[d[h[o + 3] >>> 24 & 255] & 255] ^ n[d[h[o + 3] >>> 16 & 255] & 255] ^ u[d[h[o + 3] >>> 8 & 255] & 255] ^ a[d[h[o + 3] >>> 0 & 255] & 255];
      return h;
    }
    getEncryptKey() {
      return this.encKey || (this.encKey = this.createEncryptKey()), this.encKey;
    }
    getDecryptKey() {
      return this.decKey || (this.decKey = this.createDecryptKey()), this.decKey;
    }
    encrypt(h, o, S, H) {
      const j = this.getEncryptKey();
      let J = E(S, H + 0) ^ j[0], N = E(S, H + 4) ^ j[1], z = E(S, H + 8) ^ j[2], A = E(S, H + 12) ^ j[3], q = this.rounds >>> 1, _ = 0, F, R, V, fe;
      for (; F = c[J >>> 24 & 255] ^ d[N >>> 16 & 255] ^ w[z >>> 8 & 255] ^ g[A >>> 0 & 255] ^ j[_ + 4], R = c[N >>> 24 & 255] ^ d[z >>> 16 & 255] ^ w[A >>> 8 & 255] ^ g[J >>> 0 & 255] ^ j[_ + 5], V = c[z >>> 24 & 255] ^ d[A >>> 16 & 255] ^ w[J >>> 8 & 255] ^ g[N >>> 0 & 255] ^ j[_ + 6], fe = c[A >>> 24 & 255] ^ d[J >>> 16 & 255] ^ w[N >>> 8 & 255] ^ g[z >>> 0 & 255] ^ j[_ + 7], _ += 8, q -= 1, q !== 0; )
        J = c[F >>> 24 & 255] ^ d[R >>> 16 & 255] ^ w[V >>> 8 & 255] ^ g[fe >>> 0 & 255] ^ j[_ + 0], N = c[R >>> 24 & 255] ^ d[V >>> 16 & 255] ^ w[fe >>> 8 & 255] ^ g[F >>> 0 & 255] ^ j[_ + 1], z = c[V >>> 24 & 255] ^ d[fe >>> 16 & 255] ^ w[F >>> 8 & 255] ^ g[R >>> 0 & 255] ^ j[_ + 2], A = c[fe >>> 24 & 255] ^ d[F >>> 16 & 255] ^ w[R >>> 8 & 255] ^ g[V >>> 0 & 255] ^ j[_ + 3];
      return J = w[F >>> 24 & 255] & 4278190080 ^ g[R >>> 16 & 255] & 16711680 ^ c[V >>> 8 & 255] & 65280 ^ d[fe >>> 0 & 255] & 255 ^ j[_ + 0], N = w[R >>> 24 & 255] & 4278190080 ^ g[V >>> 16 & 255] & 16711680 ^ c[fe >>> 8 & 255] & 65280 ^ d[F >>> 0 & 255] & 255 ^ j[_ + 1], z = w[V >>> 24 & 255] & 4278190080 ^ g[fe >>> 16 & 255] & 16711680 ^ c[F >>> 8 & 255] & 65280 ^ d[R >>> 0 & 255] & 255 ^ j[_ + 2], A = w[fe >>> 24 & 255] & 4278190080 ^ g[F >>> 16 & 255] & 16711680 ^ c[R >>> 8 & 255] & 65280 ^ d[V >>> 0 & 255] & 255 ^ j[_ + 3], v(h, J, o + 0), v(h, N, o + 4), v(h, z, o + 8), v(h, A, o + 12), this;
    }
    decrypt(h, o, S, H) {
      const j = this.getDecryptKey();
      let J = E(S, H + 0) ^ j[0], N = E(S, H + 4) ^ j[1], z = E(S, H + 8) ^ j[2], A = E(S, H + 12) ^ j[3], q = this.rounds >>> 1, _ = 0, F, R, V, fe;
      for (; F = f[J >>> 24 & 255] ^ n[A >>> 16 & 255] ^ u[z >>> 8 & 255] ^ a[N >>> 0 & 255] ^ j[_ + 4], R = f[N >>> 24 & 255] ^ n[J >>> 16 & 255] ^ u[A >>> 8 & 255] ^ a[z >>> 0 & 255] ^ j[_ + 5], V = f[z >>> 24 & 255] ^ n[N >>> 16 & 255] ^ u[J >>> 8 & 255] ^ a[A >>> 0 & 255] ^ j[_ + 6], fe = f[A >>> 24 & 255] ^ n[z >>> 16 & 255] ^ u[N >>> 8 & 255] ^ a[J >>> 0 & 255] ^ j[_ + 7], _ += 8, q -= 1, q !== 0; )
        J = f[F >>> 24 & 255] ^ n[fe >>> 16 & 255] ^ u[V >>> 8 & 255] ^ a[R >>> 0 & 255] ^ j[_ + 0], N = f[R >>> 24 & 255] ^ n[F >>> 16 & 255] ^ u[fe >>> 8 & 255] ^ a[V >>> 0 & 255] ^ j[_ + 1], z = f[V >>> 24 & 255] ^ n[R >>> 16 & 255] ^ u[F >>> 8 & 255] ^ a[fe >>> 0 & 255] ^ j[_ + 2], A = f[fe >>> 24 & 255] ^ n[V >>> 16 & 255] ^ u[R >>> 8 & 255] ^ a[F >>> 0 & 255] ^ j[_ + 3];
      return J = s[F >>> 24 & 255] << 24 ^ s[fe >>> 16 & 255] << 16 ^ s[V >>> 8 & 255] << 8 ^ s[R >>> 0 & 255] << 0 ^ j[_ + 0], N = s[R >>> 24 & 255] << 24 ^ s[F >>> 16 & 255] << 16 ^ s[fe >>> 8 & 255] << 8 ^ s[V >>> 0 & 255] << 0 ^ j[_ + 1], z = s[V >>> 24 & 255] << 24 ^ s[R >>> 16 & 255] << 16 ^ s[F >>> 8 & 255] << 8 ^ s[fe >>> 0 & 255] << 0 ^ j[_ + 2], A = s[fe >>> 24 & 255] << 24 ^ s[V >>> 16 & 255] << 16 ^ s[R >>> 8 & 255] << 8 ^ s[F >>> 0 & 255] << 0 ^ j[_ + 3], v(h, J, o + 0), v(h, N, o + 4), v(h, z, o + 8), v(h, A, o + 12), this;
    }
    destroy() {
      if (this.key)
        for (let h = 0; h < this.key.length; h++)
          this.key[h] = 0;
      if (this.encKey)
        for (let h = 0; h < 60; h++)
          this.encKey[h] = 0;
      if (this.decKey)
        for (let h = 0; h < 60; h++)
          this.decKey[h] = 0;
      return this.key = null, this.encKey = null, this.decKey = null, this;
    }
  }
  function m(b) {
    switch (b) {
      case 128:
        return 10;
      case 192:
        return 12;
      case 256:
        return 14;
      default:
        throw new Error("Bad key size.");
    }
  }
  function E(b, h) {
    return b[h++] * 16777216 + b[h++] * 65536 + b[h++] * 256 + b[h];
  }
  function v(b, h, o) {
    return b[o++] = h >>> 24, b[o++] = h >>> 16, b[o++] = h >>> 8, b[o++] = h, o;
  }
  return $u = p, $u;
}
var yt = {}, ju, h3;
function Tx() {
  if (h3) return ju;
  h3 = 1;
  const e = Mt(), c = k.alloc(16, 0), d = -1, w = new Uint16Array([
    0,
    7200,
    14400,
    9312,
    28800,
    27808,
    18624,
    21728,
    57600,
    64800,
    55616,
    50528,
    37248,
    36256,
    43456,
    46560
  ]);
  class g {
    constructor() {
      this.state = new Uint32Array(4), this.block = k.alloc(16), this.size = d, this.adLen = 0, this.ctLen = 0, this.table = new Array(16);
      for (let p = 0; p < 16; p++)
        this.table[p] = new Uint32Array(4);
    }
    init(p) {
      e(k.isBuffer(p)), e(p.length === 16);
      for (let E = 0; E < 4; E++)
        this.state[E] = 0;
      this.size = 0, this.adLen = 0, this.ctLen = 0;
      for (let E = 0; E < 16; E++)
        for (let v = 0; v < 4; v++)
          this.table[E][v] = 0;
      const m = new Uint32Array(4);
      m[1] = a(p, 0), m[0] = a(p, 4), m[3] = a(p, 8), m[2] = a(p, 12), this.table[u(1)] = m;
      for (let E = 2; E < 16; E += 2)
        this.table[u(E)] = this.double(this.table[u(E >>> 1)]), this.table[u(E + 1)] = this.add(this.table[u(E)], m);
      return this;
    }
    absorb(p) {
      return this._absorb(p, p.length), this;
    }
    _absorb(p, m) {
      e(this.size !== d, "Context is not initialized.");
      let E = this.size & 15, v = 0;
      if (this.size += m, E > 0) {
        let b = 16 - E;
        if (b > m && (b = m), p.copy(this.block, E, v, v + b), E += b, m -= b, v += b, E < 16)
          return;
        this.transform(this.block, 0);
      }
      for (; m >= 16; )
        this.transform(p, v), v += 16, m -= 16;
      m > 0 && p.copy(this.block, 0, v, v + m);
    }
    transform(p, m) {
      this.state[1] ^= a(p, m + 0), this.state[0] ^= a(p, m + 4), this.state[3] ^= a(p, m + 8), this.state[2] ^= a(p, m + 12), this.mul(this.state);
    }
    pad() {
      const p = this.size & 15;
      p !== 0 && this._absorb(c, 16 - p);
    }
    aad(p) {
      return e(k.isBuffer(p)), e(this.ctLen === 0), this.adLen += p.length, this.absorb(p);
    }
    update(p) {
      return e(k.isBuffer(p)), p.length === 0 ? this : (this.ctLen === 0 && this.pad(), this.ctLen += p.length, this.absorb(p));
    }
    final() {
      const p = k.alloc(16);
      this.pad();
      const m = this.adLen * 8, E = this.ctLen * 8;
      this.state[1] ^= f(m), this.state[0] ^= n(m), this.state[3] ^= f(E), this.state[2] ^= n(E), this.mul(this.state), s(p, this.state[1], 0), s(p, this.state[0], 4), s(p, this.state[3], 8), s(p, this.state[2], 12);
      for (let v = 0; v < 4; v++)
        this.state[v] = 0;
      for (let v = 0; v < 16; v++)
        this.block[v] = 0;
      this.size = d, this.adLen = 0, this.ctLen = 0;
      for (let v = 0; v < 16; v++)
        for (let b = 0; b < 4; b++)
          this.table[v][b] = 0;
      return p;
    }
    destroy() {
      for (let p = 0; p < 4; p++)
        this.state[p] = 0;
      for (let p = 0; p < 16; p++)
        this.block[p] = 0;
      this.size = d, this.adLen = 0, this.ctLen = 0;
      for (let p = 0; p < 16; p++)
        for (let m = 0; m < 4; m++)
          this.table[p][m] = 0;
    }
    add(p, m) {
      e(p instanceof Uint32Array), e(p.length === 4), e(m instanceof Uint32Array), e(m.length === 4);
      const E = new Uint32Array(4);
      return E[0] = p[0] ^ m[0], E[1] = p[1] ^ m[1], E[2] = p[2] ^ m[2], E[3] = p[3] ^ m[3], E;
    }
    double(p) {
      e(p instanceof Uint32Array), e(p.length === 4);
      const m = new Uint32Array(4), E = (p[2] & 1) === 1;
      let v;
      return m[3] = p[3], m[2] = p[2], v = m[3] & 1, m[3] >>>= 1, m[2] >>>= 1, m[2] |= v << 31, m[3] |= (p[0] & 1) << 31, m[1] = p[1], m[0] = p[0], v = m[1] & 1, m[1] >>>= 1, m[0] >>>= 1, m[0] |= v << 31, E && (m[1] ^= 3774873600, m[0] ^= 0), m;
    }
    mul(p) {
      e(p instanceof Uint32Array), e(p.length === 4);
      const m = new Uint32Array(4), E = new Uint32Array(2);
      let v, b;
      for (let h = 0; h < 2; h++) {
        E[0] = p[2], E[1] = p[3], h === 1 && (E[0] = p[0], E[1] = p[1]);
        for (let o = 0; o < 64; o += 4) {
          const S = m[2] & 15;
          v = m[3] & 15, m[3] >>>= 4, m[2] >>>= 4, m[2] |= v << 28, m[3] |= m[0] << 28, v = m[1] & 15, m[1] >>>= 4, m[0] >>>= 4, m[0] |= v << 28, m[1] ^= w[S] << 16, b = this.table[E[0] & 15], m[0] ^= b[0], m[1] ^= b[1], m[2] ^= b[2], m[3] ^= b[3], v = E[1] & 15, E[1] >>>= 4, E[0] >>>= 4, E[0] |= v << 28;
        }
      }
      p[0] = m[0], p[1] = m[1], p[2] = m[2], p[3] = m[3];
    }
  }
  function f(i) {
    return i * (1 / 4294967296) >>> 0;
  }
  function n(i) {
    return i >>> 0;
  }
  function u(i) {
    return i = i << 2 & 12 | i >>> 2 & 3, i = i << 1 & 10 | i >>> 1 & 5, i;
  }
  function a(i, p) {
    return i[p++] * 16777216 + i[p++] * 65536 + i[p++] * 256 + i[p++];
  }
  function s(i, p, m) {
    return i[m++] = p >>> 24, i[m++] = p >>> 16, i[m++] = p >>> 8, i[m++] = p, m;
  }
  return ju = g, ju;
}
var l3;
function Cx() {
  if (l3) return yt;
  l3 = 1;
  const e = Mt(), c = Tx(), d = k.alloc(0), w = new Uint32Array([
    27,
    // 8
    135,
    // 16
    1061,
    // 32
    0,
    293,
    // 64
    0,
    0,
    0,
    524355
    // 128
  ]);
  class g {
    constructor(C) {
      e(C && typeof C.encrypt == "function"), e(typeof C.blockSize == "number"), this.ctx = C;
    }
    get blockSize() {
      return this.ctx.blockSize;
    }
    init(C, I) {
      throw new Error("Not implemented.");
    }
    update(C) {
      throw new Error("Not implemented.");
    }
    crypt(C, I) {
      throw new Error("Not implemented.");
    }
    final() {
      throw new Error("Not implemented.");
    }
    destroy() {
      throw new Error("Not implemented.");
    }
    setAutoPadding(C) {
      return e(typeof C == "boolean"), this._setAutoPadding(C), this;
    }
    setAAD(C) {
      return e(k.isBuffer(C)), this._setAAD(C), this;
    }
    setCCM(C, I, se) {
      return e(C >>> 0 === C), e(I >>> 0 === I), e(se == null || k.isBuffer(se)), this._setCCM(C, I, se), this;
    }
    getAuthTag() {
      return this._getAuthTag();
    }
    setAuthTag(C) {
      return e(k.isBuffer(C)), this._setAuthTag(C), this;
    }
    _setAutoPadding(C) {
      throw new Error("Not available.");
    }
    _setAAD(C) {
      throw new Error("Cipher is not authenticated.");
    }
    _setCCM(C, I, se) {
      throw new Error("Not available.");
    }
    _getAuthTag() {
      throw new Error("Cipher is not authenticated.");
    }
    _setAuthTag(C) {
      throw new Error("Cipher is not authenticated.");
    }
  }
  class f extends g {
    constructor(C, I) {
      super(C), this.padding = !0, this.unpad = I, this.block = k.alloc(this.blockSize), this.blockPos = -1, this.last = null, this.lastSize = 0, I && (this.last = k.alloc(this.blockSize));
    }
    init(C, I) {
      return I == null && (I = d), e(k.isBuffer(C)), e(k.isBuffer(I)), this.ctx.init(C), this.blockPos = 0, this.lastSize = 0, this._init(C, I), this;
    }
    _updateSize(C) {
      if (this.blockPos + C < this.blockSize)
        return 0;
      let I = 0;
      return this.unpad && (I += this.lastSize), this.blockPos > 0 && (C -= this.blockSize - this.blockPos, I += this.blockSize), C >= this.blockSize && (I += C - C % this.blockSize), e(I >= this.blockSize), I;
    }
    update(C) {
      if (e(k.isBuffer(C)), this.blockPos === -1)
        throw new Error("Cipher is not initialized.");
      const I = this._updateSize(C.length), se = k.alloc(I);
      if (this.blockPos + C.length < this.blockSize)
        return this.blockPos += C.copy(this.block, this.blockPos, 0, C.length), se;
      let t = C.length, l = 0, B = 0;
      if (this.unpad && (B += this.last.copy(se, B, 0, this.lastSize)), this.blockPos > 0) {
        const U = this.blockSize - this.blockPos;
        l += C.copy(this.block, this.blockPos, l, l + U), t -= U, this._update(se, B, this.block, 0), B += this.blockSize, this.blockPos = 0;
      }
      for (; t >= this.blockSize; )
        this._update(se, B, C, l), l += this.blockSize, t -= this.blockSize, B += this.blockSize;
      return t > 0 && (this.blockPos = C.copy(this.block, 0, l, l + t)), e(B === I), this.unpad ? (this.lastSize = se.copy(this.last, 0, I - this.blockSize, I), se.slice(0, I - this.blockSize)) : se;
    }
    crypt(C, I) {
      if (e(k.isBuffer(C)), e(k.isBuffer(I)), e(C.length === I.length), this.blockPos === -1)
        throw new Error("Cipher is not initialized.");
      if (this.unpad || this.blockPos !== 0)
        throw new Error("Cannot crypt while buffering.");
      if (I.length % this.blockSize !== 0)
        throw new Error("Input must be a multiple of the block size.");
      const se = this.blockSize;
      let t = I.length, l = 0;
      for (; t > 0; )
        this._update(C, l, I, l), l += se, t -= se;
      return C;
    }
    final() {
      if (this.blockPos === -1)
        throw new Error("Cipher is not initialized.");
      try {
        return this._final();
      } finally {
        this.destroy();
      }
    }
    destroy() {
      this.ctx.destroy(), this.blockPos = -1, this.lastSize = 0;
      for (let C = 0; C < this.blockSize; C++)
        this.block[C] = 0;
      if (this.unpad)
        for (let C = 0; C < this.blockSize; C++)
          this.last[C] = 0;
      return this._destroy(), this;
    }
    _init(C, I) {
      throw new Error("Not implemented.");
    }
    _update(C, I, se, t) {
      throw new Error("Not implemented.");
    }
    _final() {
      throw new Error("Not implemented.");
    }
    _destroy() {
      throw new Error("Not implemented.");
    }
  }
  class n extends g {
    constructor(C) {
      super(C), this.pos = -1;
    }
    init(C, I) {
      return I == null && (I = d), e(k.isBuffer(C)), e(k.isBuffer(I)), this.ctx.init(C), this.pos = 0, this._init(C, I), this;
    }
    update(C) {
      if (e(k.isBuffer(C)), this.pos === -1)
        throw new Error("Cipher is not initialized.");
      const I = k.alloc(C.length);
      return this._crypt(I, C), I;
    }
    crypt(C, I) {
      if (e(k.isBuffer(C)), e(k.isBuffer(I)), e(C.length === I.length), this.pos === -1)
        throw new Error("Cipher is not initialized.");
      return this._crypt(C, I), C;
    }
    final() {
      if (this.pos === -1)
        throw new Error("Cipher is not initialized.");
      try {
        return this._final();
      } finally {
        this.destroy();
      }
    }
    destroy() {
      return this.ctx.destroy(), this.pos = -1, this._destroy(), this;
    }
    _init(C, I) {
      throw new Error("Not implemented.");
    }
    _crypt(C, I) {
      throw new Error("Not implemented.");
    }
    _final() {
      throw new Error("Not implemented.");
    }
    _destroy() {
      throw new Error("Not implemented.");
    }
  }
  class u extends f {
    constructor(C) {
      super(C, !1);
    }
    _init(C, I) {
      e(I.length === 0);
    }
    _update(C, I, se, t) {
      this.ctx.encrypt(C, I, se, t);
    }
    _final() {
      if (this.blockPos !== 0)
        throw new Error("Bad encrypt (trailing bytes).");
      return k.alloc(0);
    }
    _destroy() {
    }
  }
  class a extends f {
    constructor(C) {
      super(C, !1);
    }
    _init(C, I) {
      e(I.length === 0);
    }
    _update(C, I, se, t) {
      this.ctx.decrypt(C, I, se, t);
    }
    _final() {
      if (this.blockPos !== 0)
        throw new Error("Bad decrypt (trailing bytes).");
      return k.alloc(0);
    }
    _destroy() {
    }
  }
  class s extends f {
    constructor(C) {
      super(C, !1);
    }
    _final() {
      if (!this.padding) {
        if (this.blockPos !== 0)
          throw new Error("Bad encrypt (trailing bytes).");
        return k.alloc(0);
      }
      const C = this.blockSize - this.blockPos, I = k.from(this.block);
      for (let se = this.blockPos; se < this.blockSize; se++)
        I[se] = C;
      return this._update(I, 0, I, 0), I;
    }
    _setAutoPadding(C) {
      this.padding = C;
    }
  }
  class i extends f {
    constructor(C) {
      super(C, !0);
    }
    _final() {
      if (this.blockPos !== 0)
        throw new Error("Bad decrypt (trailing bytes).");
      if (!this.padding)
        return k.alloc(0);
      if (this.lastSize === 0)
        throw new Error("Bad decrypt (no data).");
      e(this.lastSize === this.last.length), e(this.lastSize === this.blockSize);
      const C = k.from(this.last);
      let I = C[C.length - 1], se = 1;
      se &= I - 1 >>> 31 ^ 1, se &= I - this.blockSize - 1 >>> 31, I &= -se;
      const t = this.blockSize - I;
      for (let l = 0; l < this.blockSize; l++) {
        const B = C[l];
        se &= l - t >>> 31 | (B ^ I) - 1 >>> 31;
      }
      if (!se)
        throw new Error("Bad decrypt (padding).");
      return C.slice(0, t);
    }
    _setAutoPadding(C) {
      if (this.lastSize !== 0 || this.blockPos !== 0)
        throw new Error("Cannot set auto padding.");
      this.padding = C, this.unpad = C;
    }
  }
  class p extends s {
    constructor(C) {
      super(C);
    }
    _init(C, I) {
      e(I.length === 0);
    }
    _update(C, I, se, t) {
      this.ctx.encrypt(C, I, se, t);
    }
    _destroy() {
    }
  }
  class m extends i {
    constructor(C) {
      super(C);
    }
    _init(C, I) {
      e(I.length === 0);
    }
    _update(C, I, se, t) {
      this.ctx.decrypt(C, I, se, t);
    }
    _destroy() {
    }
  }
  class E extends s {
    constructor(C) {
      super(C), this.prev = k.alloc(this.blockSize);
    }
    _init(C, I) {
      e(I.length === this.blockSize), I.copy(this.prev, 0);
    }
    _update(C, I, se, t) {
      for (let l = 0; l < this.blockSize; l++)
        this.prev[l] ^= se[t + l];
      this.ctx.encrypt(C, I, this.prev, 0), C.copy(this.prev, 0, I, I + this.blockSize);
    }
    _destroy() {
      for (let C = 0; C < this.blockSize; C++)
        this.prev[C] = 0;
    }
  }
  class v extends i {
    constructor(C) {
      super(C), this.prev = k.alloc(this.blockSize), this.tmp = k.alloc(this.blockSize);
    }
    _init(C, I) {
      e(I.length === this.blockSize), I.copy(this.prev, 0);
    }
    _update(C, I, se, t) {
      if (xe(C, I, se, t)) {
        this.prev.copy(this.tmp, 0), se.copy(this.prev, 0, t, t + this.blockSize), this.ctx.decrypt(C, I, se, t);
        for (let l = 0; l < this.blockSize; l++)
          C[I + l] ^= this.tmp[l];
      } else {
        this.ctx.decrypt(C, I, se, t);
        for (let l = 0; l < this.blockSize; l++)
          C[I + l] ^= this.prev[l];
        se.copy(this.prev, 0, t, t + this.blockSize);
      }
    }
    _destroy() {
      for (let C = 0; C < this.blockSize; C++)
        this.prev[C] = 0, this.tmp[C] = 0;
    }
  }
  class b extends f {
    constructor(C) {
      super(C, !0), this.prev = k.alloc(this.blockSize);
    }
    _init(C, I) {
      e(I.length === this.blockSize), I.copy(this.prev, 0);
    }
    _update(C, I, se, t) {
      for (let l = 0; l < this.blockSize; l++)
        this.prev[l] ^= se[t + l];
      this.ctx.encrypt(C, I, this.prev, 0), C.copy(this.prev, 0, I, I + this.blockSize);
    }
    _final() {
      if (!this.padding) {
        if (this.blockPos !== 0)
          throw new Error("Bad encrypt (trailing bytes).");
        return k.alloc(0);
      }
      if (this.lastSize === 0)
        throw new Error("Bad encrypt (no data).");
      for (let I = 0; I < this.blockPos; I++)
        this.prev[I] ^= this.block[I];
      this.ctx.encrypt(this.prev, 0, this.prev, 0);
      const C = this.last.slice(0, this.blockPos);
      return k.concat([this.prev, C]);
    }
    _destroy() {
      for (let C = 0; C < this.blockSize; C++)
        this.prev[C] = 0;
    }
    _setAutoPadding(C) {
      if (this.lastSize !== 0 || this.blockPos !== 0)
        throw new Error("Cannot set auto padding.");
      this.padding = C, this.unpad = C;
    }
  }
  class h extends f {
    constructor(C) {
      super(C, !0), this.prev = k.alloc(this.blockSize), this.tmp = k.alloc(this.blockSize);
    }
    _init(C, I) {
      e(I.length === this.blockSize), I.copy(this.prev, 0);
    }
    _update(C, I, se, t) {
      if (xe(C, I, se, t)) {
        this.prev.copy(this.tmp, 0), se.copy(this.prev, 0, t, t + this.blockSize), this.ctx.decrypt(C, I, se, t);
        for (let l = 0; l < this.blockSize; l++)
          C[I + l] ^= this.tmp[l];
      } else {
        this.ctx.decrypt(C, I, se, t);
        for (let l = 0; l < this.blockSize; l++)
          C[I + l] ^= this.prev[l];
        se.copy(this.prev, 0, t, t + this.blockSize);
      }
    }
    _final() {
      if (!this.padding) {
        if (this.blockPos !== 0)
          throw new Error("Bad decrypt (trailing bytes).");
        return k.alloc(0);
      }
      if (this.lastSize === 0)
        throw new Error("Bad decrypt (no data).");
      const C = k.alloc(this.blockSize);
      this.ctx.decrypt(this.prev, 0, this.prev, 0);
      for (let se = 0; se < this.blockSize; se++)
        C[se] = this.last[se] ^ this.prev[se];
      for (let se = 0; se < this.blockPos; se++)
        this.last[se] = this.block[se], this.block[se] ^= this.prev[se];
      for (let se = this.blockPos; se < this.blockSize; se++)
        this.last[se] = this.prev[se];
      this.ctx.decrypt(this.last, 0, this.last, 0);
      for (let se = 0; se < this.blockSize; se++)
        this.last[se] ^= C[se];
      const I = this.block.slice(0, this.blockPos);
      return k.concat([this.last, I]);
    }
    _destroy() {
      for (let C = 0; C < this.blockSize; C++)
        this.prev[C] = 0, this.tmp[C] = 0;
    }
    _setAutoPadding(C) {
      if (this.lastSize !== 0 || this.blockPos !== 0)
        throw new Error("Cannot set auto padding.");
      this.padding = C, this.unpad = C;
    }
  }
  class o extends f {
    constructor(C, I) {
      super(C, !0), this.encrypt = I, this.poly = w[this.blockSize >>> 4], this.tweak = k.alloc(this.blockSize), this.prev = k.alloc(this.blockSize);
    }
    init(C, I) {
      e(k.isBuffer(C)), e(k.isBuffer(I)), e(C.length > 0 && (C.length & 1) === 0), e(I.length === this.blockSize);
      const se = C.length >>> 1, t = C.slice(0, se), l = C.slice(se);
      if (Ie(t, l, se))
        throw new Error("XTS keys are equal.");
      return this.ctx.init(l), this.ctx.encrypt(this.tweak, 0, I, 0), this.ctx.init(t), this.blockPos = 0, this.lastSize = 0, this;
    }
    _shift() {
      let C = 0;
      this.encrypt || this.tweak.copy(this.prev, 0);
      for (let I = 0; I < this.blockSize; I++) {
        const se = this.tweak[I] >> 7;
        this.tweak[I] <<= 1, this.tweak[I] |= C, C = se;
      }
      C = -C & 255, this.tweak[2] ^= this.poly >> 16 & C, this.tweak[1] ^= this.poly >> 8 & C, this.tweak[0] ^= this.poly >> 0 & C;
    }
    _update(C, I, se, t) {
      for (let l = 0; l < this.blockSize; l++)
        C[I + l] = se[t + l] ^ this.tweak[l];
      this.encrypt ? this.ctx.encrypt(C, I, C, I) : this.ctx.decrypt(C, I, C, I);
      for (let l = 0; l < this.blockSize; l++)
        C[I + l] ^= this.tweak[l];
      this._shift();
    }
    _destroy() {
      for (let C = 0; C < this.blockSize; C++)
        this.tweak[C] = 0, this.prev[C] = 0;
    }
    _setAutoPadding(C) {
      if (this.lastSize !== 0 || this.blockPos !== 0)
        throw new Error("Cannot set auto padding.");
      this.padding = C, this.unpad = C;
    }
  }
  class S extends o {
    constructor(C) {
      super(C, !0);
    }
    _final() {
      if (!this.padding) {
        if (this.blockPos !== 0)
          throw new Error("Bad encrypt (trailing bytes).");
        return k.alloc(0);
      }
      if (this.lastSize === 0)
        throw new Error("Bad encrypt (no data).");
      if (this.blockPos === 0)
        return k.from(this.last);
      const C = k.alloc(this.blockPos);
      for (let I = 0; I < this.blockPos; I++)
        C[I] = this.last[I], this.last[I] = this.block[I];
      for (let I = 0; I < this.blockSize; I++)
        this.last[I] ^= this.tweak[I];
      this.ctx.encrypt(this.last, 0, this.last, 0);
      for (let I = 0; I < this.blockSize; I++)
        this.last[I] ^= this.tweak[I];
      return k.concat([this.last, C]);
    }
  }
  class H extends o {
    constructor(C) {
      super(C, !1);
    }
    _final() {
      if (!this.padding) {
        if (this.blockPos !== 0)
          throw new Error("Bad decrypt (trailing bytes).");
        return k.alloc(0);
      }
      if (this.lastSize === 0)
        throw new Error("Bad decrypt (no data).");
      if (this.blockPos === 0)
        return k.from(this.last);
      for (let I = 0; I < this.blockSize; I++)
        this.last[I] ^= this.prev[I];
      this.ctx.encrypt(this.last, 0, this.last, 0);
      for (let I = 0; I < this.blockSize; I++)
        this.last[I] ^= this.prev[I];
      for (let I = 0; I < this.blockSize; I++)
        this.last[I] ^= this.tweak[I];
      this.ctx.decrypt(this.last, 0, this.last, 0);
      for (let I = 0; I < this.blockSize; I++)
        this.last[I] ^= this.tweak[I];
      const C = k.alloc(this.blockPos);
      for (let I = 0; I < this.blockPos; I++)
        C[I] = this.last[I], this.last[I] = this.block[I];
      for (let I = 0; I < this.blockSize; I++)
        this.last[I] ^= this.prev[I];
      this.ctx.decrypt(this.last, 0, this.last, 0);
      for (let I = 0; I < this.blockSize; I++)
        this.last[I] ^= this.prev[I];
      return k.concat([this.last, C]);
    }
  }
  class j extends n {
    constructor(C) {
      super(C), this.state = k.alloc(this.blockSize), this.ctr = k.alloc(this.blockSize);
    }
    _init(C, I) {
      e(I.length === this.blockSize), I.copy(this.ctr, 0);
    }
    _increment() {
      for (let C = this.ctr.length - 1; C >= 0 && (this.ctr[C] += 1, this.ctr[C] === 0); C--)
        ;
    }
    _crypt(C, I) {
      const se = this.blockSize - 1;
      for (let t = 0; t < I.length; t++)
        (this.pos & se) === 0 && (this.ctx.encrypt(this.state, 0, this.ctr, 0), this._increment(), this.pos = 0), C[t] = I[t] ^ this.state[this.pos++];
    }
    _final() {
      return k.alloc(0);
    }
    _destroy() {
      for (let C = 0; C < this.blockSize; C++)
        this.state[C] = 0, this.ctr[C] = 0;
    }
  }
  class J extends j {
    constructor(C) {
      super(C);
    }
  }
  class N extends j {
    constructor(C) {
      super(C);
    }
  }
  class z extends n {
    constructor(C) {
      super(C), this.state = k.alloc(this.blockSize), this.prev = k.alloc(this.blockSize);
    }
    _init(C, I) {
      e(I.length === this.blockSize), I.copy(this.prev, 0);
    }
    _final() {
      return k.alloc(0);
    }
    _destroy() {
      for (let C = 0; C < this.blockSize; C++)
        this.state[C] = 0, this.prev[C] = 0;
    }
  }
  class A extends z {
    constructor(C) {
      super(C);
    }
    _crypt(C, I) {
      const se = this.blockSize - 1;
      for (let t = 0; t < I.length; t++)
        (this.pos & se) === 0 && (this.ctx.encrypt(this.state, 0, this.prev, 0), this.pos = 0), C[t] = I[t] ^ this.state[this.pos], this.prev[this.pos] = C[t], this.pos += 1;
    }
  }
  class q extends z {
    constructor(C) {
      super(C);
    }
    _crypt(C, I) {
      const se = this.blockSize - 1;
      for (let t = 0; t < I.length; t++)
        (this.pos & se) === 0 && (this.ctx.encrypt(this.state, 0, this.prev, 0), this.pos = 0), this.prev[this.pos] = I[t], C[t] = I[t] ^ this.state[this.pos], this.pos += 1;
    }
  }
  class _ extends n {
    constructor(C) {
      super(C), this.state = k.alloc(this.blockSize);
    }
    _init(C, I) {
      e(k.isBuffer(I)), e(I.length === this.blockSize), I.copy(this.state, 0);
    }
    _crypt(C, I) {
      const se = this.blockSize - 1;
      for (let t = 0; t < I.length; t++)
        (this.pos & se) === 0 && (this.ctx.encrypt(this.state, 0, this.state, 0), this.pos = 0), C[t] = I[t] ^ this.state[this.pos++];
    }
    _final() {
      return k.alloc(0);
    }
    _destroy() {
      for (let C = 0; C < this.blockSize; C++)
        this.state[C] = 0;
    }
  }
  class F extends _ {
    constructor(C) {
      super(C);
    }
  }
  class R extends _ {
    constructor(C) {
      super(C);
    }
  }
  class V extends n {
    constructor(C, I) {
      e(C.blockSize === 16), super(C), this.encrypt = I, this.hash = new c(), this.ctr = k.alloc(16), this.state = k.alloc(16), this.key = k.alloc(16), this.mask = k.alloc(16), this.tag = null, this.mac = null;
    }
    _init(C, I) {
      for (let se = 0; se < 16; se++)
        this.ctr[se] = 0, this.key[se] = 0, this.mask[se] = 0;
      return this._encipher(this.key, this.key), this.hash.init(this.key), I.length !== 12 && (this.hash.update(I), I = this.hash.final(), this.hash.init(this.key)), I.copy(this.ctr, 0), I.length === 12 && (this.ctr[12] = 0, this.ctr[13] = 0, this.ctr[14] = 0, this.ctr[15] = 1), this._encipher(this.mask, this.mask), this.tag = null, this.mac = null, this;
    }
    _increment() {
      let C = 1, I = 4;
      for (; I--; )
        C += this.ctr[12 + I], this.ctr[12 + I] = C, C >>= 8;
    }
    _encipher(C, I) {
      for (let se = 0; se < I.length; se++)
        (this.pos & 15) === 0 && (this.ctx.encrypt(this.state, 0, this.ctr, 0), this._increment(), this.pos = 0), C[se] = I[se] ^ this.state[this.pos++];
    }
    _crypt(C, I) {
      this.encrypt ? (this._encipher(C, I), this.hash.update(C)) : (this.hash.update(I), this._encipher(C, I));
    }
    _final() {
      const C = this.hash.final();
      for (let I = 0; I < 16; I++)
        C[I] ^= this.mask[I];
      if (this.encrypt)
        return this.mac = C, k.alloc(0);
      if (!this.tag)
        throw new Error("No tag provided.");
      if (!Ie(C, this.tag, this.tag.length))
        throw new Error("Invalid tag.");
      return k.alloc(0);
    }
    _destroy() {
      this.hash.destroy();
      for (let C = 0; C < 16; C++)
        this.ctr[C] = 0, this.state[C] = 0, this.key[C] = 0, this.mask[C] = 0;
      if (this.tag) {
        for (let C = 0; C < this.tag.length; C++)
          this.tag[C] = 0;
        this.tag = null;
      }
    }
    _setAAD(C) {
      if (this.pos === -1)
        throw new Error("Cipher is not initialized.");
      return this.hash.aad(C), this;
    }
    _getAuthTag() {
      if (!this.encrypt)
        throw new Error("Must be a cipher context.");
      if (!this.mac)
        throw new Error("Cipher is not finalized.");
      return k.from(this.mac);
    }
    _setAuthTag(C) {
      if (this.encrypt)
        throw new Error("Must be a decipher context.");
      if (this.pos === -1)
        throw new Error("Cipher is not initialized.");
      if (C.length !== 4 && C.length !== 8 && (C.length < 12 || C.length > 16))
        throw new RangeError("Invalid tag size.");
      return this.tag = k.from(C), this;
    }
  }
  class fe extends V {
    constructor(C) {
      super(C, !0);
    }
  }
  class ue extends V {
    constructor(C) {
      super(C, !1);
    }
  }
  class ae {
    constructor(C) {
      this.ctx = C, this.size = C.blockSize, this.mac = k.alloc(this.size), this.pos = -1;
    }
    init() {
      return this.mac.fill(0), this.pos = 0, this;
    }
    update(C) {
      if (e(k.isBuffer(C)), this.pos === -1)
        throw new Error("Context is not initialized.");
      for (let I = 0; I < C.length; I++)
        this.mac[this.pos++] ^= C[I], this.pos === this.size && (this.ctx.encrypt(this.mac, 0, this.mac, 0), this.pos = 0);
    }
    pad() {
      this.pos > 0 && (this.ctx.encrypt(this.mac, 0, this.mac, 0), this.pos = 0);
    }
    final() {
      if (this.pos === -1)
        throw new Error("Context is not initialized.");
      return this.pad(), this.pos = -1, k.from(this.mac);
    }
  }
  class D extends n {
    constructor(C, I) {
      e(C.blockSize === 16), super(C), this.encrypt = I, this.hash = new ae(C), this.state = k.alloc(16), this.ctr = k.alloc(16), this.tagLen = 0, this.iv = null, this.mac = null, this.tag = null;
    }
    _increment() {
      for (let C = 15; C >= 1 && (this.ctr[C] += 1, this.ctr[C] === 0); C--)
        ;
    }
    _encipher(C, I) {
      for (let se = 0; se < I.length; se++)
        (this.pos & 15) === 0 && (this.ctx.encrypt(this.state, 0, this.ctr, 0), this._increment(), this.pos = 0), C[se] = I[se] ^ this.state[this.pos++];
    }
    _init(C, I) {
      if (I.length < 7)
        throw new RangeError("Invalid nonce length.");
      I.length > 13 && (I = I.slice(0, 13)), this.iv = k.from(I), this.pos = -1, this.tagLen = 0, this.mac = null, this.tag = null;
    }
    _setCCM(C, I, se) {
      if (!this.iv)
        throw new Error("Cipher is not initialized.");
      let t = C, l = Math.ceil((32 - Math.clz32(t)) / 8);
      l < 2 && (l = 2);
      const B = I, U = 15 - l, G = (se && se.length > 0) | 0, T = k.alloc(16);
      if (B < 4 || B > 16 || (B & 1) !== 0)
        throw new RangeError("Invalid tag length.");
      T[0] = 64 * G + 8 * ((B - 2) / 2) + (l - 1), this.iv.copy(T, 1, 0, Math.min(U, this.iv.length));
      for (let M = 15; M >= 1 + U; M--)
        T[M] = t & 255, t >>>= 8;
      if (e(t === 0), this.hash.init(), this.hash.update(T), G) {
        if (se.length < 65280) {
          const M = k.alloc(2);
          M[0] = se.length >>> 8, M[1] = se.length >>> 0, this.hash.update(M);
        } else if (se.length < 4294967295) {
          const M = k.alloc(6);
          M[0] = 255, M[1] = 254, M[2] = se.length >>> 24, M[3] = se.length >>> 16, M[4] = se.length >>> 8, M[5] = se.length >>> 0, this.hash.update(M);
        } else
          throw new RangeError("Invalid AAD length.");
        this.hash.update(se), this.hash.pad();
      }
      T[0] &= 7, T[15] = 1;
      for (let M = 14; M >= 1 + U; M--)
        T[M] = 0;
      T.copy(this.ctr, 0), this.pos = 0, this.tagLen = B, this.iv = null;
    }
    _crypt(C, I) {
      this.encrypt ? (this.hash.update(I), this._encipher(C, I)) : (this._encipher(C, I), this.hash.update(C));
    }
    _final() {
      const C = this.hash.final();
      let I = 16 - ((this.ctr[0] & 7) + 1);
      for (; I < 16; )
        this.ctr[I++] = 0;
      if (this.pos = 0, this._encipher(C, C), this.encrypt)
        return this.mac = C.slice(0, this.tagLen), k.alloc(0);
      if (!this.tag)
        throw new Error("No tag provided.");
      if (!Ie(C, this.tag, this.tagLen))
        throw new Error("Invalid tag.");
      return k.alloc(0);
    }
    _destroy() {
      for (let C = 0; C < 16; C++)
        this.state[C] = 0, this.ctr[C] = 0;
      this.tagLen = 0, this.iv = null, this.tag = null;
    }
    _getAuthTag() {
      if (!this.encrypt)
        throw new Error("Must be a cipher context.");
      if (!this.mac)
        throw new Error("Cipher is not finalized.");
      return k.from(this.mac);
    }
    _setAuthTag(C) {
      if (this.encrypt)
        throw new Error("Must be a decipher context.");
      if (this.pos === -1)
        throw new Error("Cipher is not initialized.");
      if (this.tagLen === 0 || C.length !== this.tagLen)
        throw new RangeError("Invalid tag size.");
      return this.tag = k.from(C), this;
    }
  }
  class Q extends D {
    constructor(C) {
      super(C, !0);
    }
  }
  class Z extends D {
    constructor(C) {
      super(C, !1);
    }
  }
  class oe {
    constructor(C) {
      this.ctx = C, this.poly = w[C.blockSize >>> 4], this.size = C.blockSize, this.mac = k.alloc(this.size), this.pos = -1;
    }
    init(C) {
      return this.mac.fill(0), this.pos = 0, C != null && (this.mac[this.size - 1] ^= C, this.pos = this.size), this;
    }
    shift(C, I) {
      let se = 0;
      for (let t = this.size - 1; t >= 0; t--) {
        const l = I[t] >> 7;
        C[t] = I[t] << 1 | se, se = l;
      }
      se = -se & 255, C[this.size - 3] ^= this.poly >> 16 & se, C[this.size - 2] ^= this.poly >> 8 & se, C[this.size - 1] ^= this.poly >> 0 & se;
    }
    update(C) {
      if (e(k.isBuffer(C)), this.pos === -1)
        throw new Error("Context is not initialized.");
      for (let I = 0; I < C.length; I++)
        this.pos === this.size && (this.ctx.encrypt(this.mac, 0, this.mac, 0), this.pos = 0), this.mac[this.pos++] ^= C[I];
    }
    final() {
      if (this.pos === -1)
        throw new Error("Context is not initialized.");
      const C = k.alloc(this.size);
      this.ctx.encrypt(C, 0, C, 0), this.shift(C, C), this.pos < this.size && (this.mac[this.pos] ^= 128, this.shift(C, C));
      for (let I = 0; I < this.size; I++)
        this.mac[I] ^= C[I];
      return this.ctx.encrypt(this.mac, 0, this.mac, 0), this.pos = -1, k.from(this.mac);
    }
  }
  class y extends n {
    constructor(C, I) {
      super(C), this.encrypt = I, this.hash1 = new oe(C), this.hash2 = new oe(C), this.state = k.alloc(this.blockSize), this.ctr = k.alloc(this.blockSize), this.mask = k.alloc(this.blockSize), this.mac = null, this.tag = null;
    }
    _increment() {
      let C = this.blockSize, I = 1;
      for (; C--; )
        I += this.ctr[C], this.ctr[C] = I, I >>= 8;
    }
    _encipher(C, I) {
      const se = this.blockSize - 1;
      for (let t = 0; t < I.length; t++)
        (this.pos & se) === 0 && (this.ctx.encrypt(this.state, 0, this.ctr, 0), this._increment(), this.pos = 0), C[t] = I[t] ^ this.state[this.pos++];
    }
    _init(C, I) {
      e(I.length > 0), this.hash1.init(0), this.hash1.update(I), this.mask = this.hash1.final(), this.mask.copy(this.ctr, 0), this.hash1.init(1), this.hash2.init(2), this.mac = null, this.tag = null;
    }
    _crypt(C, I) {
      this.encrypt ? (this._encipher(C, I), this.hash2.update(C)) : (this.hash2.update(I), this._encipher(C, I));
    }
    _final() {
      const C = k.alloc(this.blockSize), I = this.hash1.final(), se = this.hash2.final();
      for (let t = 0; t < this.blockSize; t++)
        C[t] = I[t] ^ se[t] ^ this.mask[t];
      if (this.encrypt)
        return this.mac = C, k.alloc(0);
      if (!this.tag)
        throw new Error("No tag provided.");
      if (!Ie(C, this.tag, this.tag.length))
        throw new Error("Invalid tag.");
      return k.alloc(0);
    }
    _destroy() {
      for (let C = 0; C < this.blockSize; C++)
        this.state[C] = 0, this.ctr[C] = 0, this.mask[C] = 0;
      this.tag = null;
    }
    _setAAD(C) {
      if (this.pos === -1)
        throw new Error("Cipher is not initialized.");
      return this.hash1.update(C), this;
    }
    _getAuthTag() {
      if (!this.encrypt)
        throw new Error("Must be a cipher context.");
      if (!this.mac)
        throw new Error("Cipher is not finalized.");
      return k.from(this.mac);
    }
    _setAuthTag(C) {
      if (this.encrypt)
        throw new Error("Must be a decipher context.");
      if (this.pos === -1)
        throw new Error("Cipher is not initialized.");
      if (C.length === 0 || C.length > this.blockSize)
        throw new RangeError("Invalid tag size.");
      return this.tag = k.from(C), this;
    }
  }
  class Y extends y {
    constructor(C) {
      super(C, !0);
    }
  }
  class he extends y {
    constructor(C) {
      super(C, !1);
    }
  }
  function be(ve, C = !0) {
    switch (e(typeof ve == "string"), e(typeof C == "boolean"), ve) {
      case "RAW":
        return C ? u : a;
      case "ECB":
        return C ? p : m;
      case "CBC":
        return C ? E : v;
      case "CTS":
        return C ? b : h;
      case "XTS":
        return C ? S : H;
      case "CTR":
        return C ? J : N;
      case "CFB":
        return C ? A : q;
      case "OFB":
        return C ? F : R;
      case "GCM":
        return C ? fe : ue;
      case "CCM":
        return C ? Q : Z;
      case "EAX":
        return C ? Y : he;
      default:
        throw new Error(`Unknown mode: ${ve}.`);
    }
  }
  function xe(ve, C, I, se) {
    return ve.buffer === I.buffer && ve.byteOffset === I.byteOffset && C === se;
  }
  function Ie(ve, C, I) {
    let se = 0;
    for (let t = 0; t < I; t++)
      se |= ve[t] ^ C[t];
    return se - 1 >>> 31;
  }
  return yt.Mode = g, yt.Block = f, yt.Stream = n, yt.RawCipher = u, yt.RawDecipher = a, yt.PKCS7Cipher = s, yt.PKCS7Decipher = i, yt.ECBCipher = p, yt.ECBDecipher = m, yt.CBCCipher = E, yt.CBCDecipher = v, yt.CTSCipher = b, yt.CTSDecipher = h, yt.XTS = o, yt.XTSCipher = S, yt.XTSDecipher = H, yt.CTR = j, yt.CTRCipher = J, yt.CTRDecipher = N, yt.CFB = z, yt.CFBCipher = A, yt.CFBDecipher = q, yt.OFB = _, yt.OFBCipher = F, yt.OFBDecipher = R, yt.GCM = V, yt.GCMCipher = fe, yt.GCMDecipher = ue, yt.CBCMAC = ae, yt.CCM = D, yt.CCMCipher = Q, yt.CCMDecipher = Z, yt.CMAC = oe, yt.EAX = y, yt.EAXCipher = Y, yt.EAXDecipher = he, yt.get = be, yt;
}
var d3;
function _l() {
  if (d3) return Tn;
  d3 = 1;
  const e = zx(), { CBCCipher: c, CBCDecipher: d } = Cx();
  function w(f, n, u) {
    const a = new c(new e(256));
    return a.init(n, u), k.concat([a.update(f), a.final()]);
  }
  function g(f, n, u) {
    const a = new d(new e(256));
    return a.init(n, u), k.concat([a.update(f), a.final()]);
  }
  return Tn.native = 0, Tn.encipher = w, Tn.decipher = g, Tn;
}
/*!
 * path.js - path object for wallets
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var Yu, b3;
function So() {
  if (b3) return Yu;
  b3 = 1;
  const e = $e(), c = At(), d = Lr(), { encoding: w } = c, { inspectSymbol: g } = Kt();
  class f {
    /**
     * Create a path.
     * @constructor
     * @param {Object?} options
     */
    constructor(u) {
      this.keyType = f.types.HD, this.name = null, this.account = 0, this.type = d.types.PUBKEYHASH, this.version = -1, this.branch = -1, this.index = -1, this.encrypted = !1, this.data = null, this.hash = null, u && this.fromOptions(u);
    }
    /**
     * Instantiate path from options object.
     * @private
     * @param {Object} options
     * @returns {Path}
     */
    fromOptions(u) {
      return this.keyType = u.keyType, this.name = u.name, this.account = u.account, this.branch = u.branch, this.index = u.index, this.encrypted = u.encrypted, this.data = u.data, this.type = u.type, this.version = u.version, this.hash = u.hash, this;
    }
    /**
     * Instantiate path from options object.
     * @param {Object} options
     * @returns {Path}
     */
    static fromOptions(u) {
      return new this().fromOptions(u);
    }
    /**
     * Clone the path object.
     * @returns {Path}
     */
    clone() {
      const u = new this.constructor();
      return u.keyType = this.keyType, u.name = this.name, u.account = this.account, u.branch = this.branch, u.index = this.index, u.encrypted = this.encrypted, u.data = this.data, u.type = this.type, u.version = this.version, u.hash = this.hash, u;
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     */
    fromRaw(u) {
      const a = c.read(u);
      this.account = a.readU32(), this.keyType = a.readU8();
      const s = a.readU8();
      switch (this.type = s & 7, this.version = s >>> 3, this.version === 31 && (this.version = -1), this.keyType) {
        case f.types.HD:
          this.branch = a.readU32(), this.index = a.readU32();
          break;
        case f.types.KEY:
          this.encrypted = a.readU8() === 1, this.data = a.readVarBytes();
          break;
        case f.types.ADDRESS:
          break;
        default:
          e(!1);
          break;
      }
      return this;
    }
    /**
     * Instantiate path from serialized data.
     * @param {Buffer} data
     * @returns {Path}
     */
    static fromRaw(u) {
      return new this().fromRaw(u);
    }
    /**
     * Calculate serialization size.
     * @returns {Number}
     */
    getSize() {
      let u = 0;
      switch (u += 6, this.keyType) {
        case f.types.HD:
          u += 8;
          break;
        case f.types.KEY:
          u += 1, u += w.sizeVarBytes(this.data);
          break;
      }
      return u;
    }
    /**
     * Serialize path.
     * @returns {Buffer}
     */
    toRaw() {
      const u = this.getSize(), a = c.write(u);
      a.writeU32(this.account), a.writeU8(this.keyType);
      let s = this.version;
      s === -1 && (s = 31);
      const i = s << 3 | this.type;
      switch (a.writeU8(i), this.keyType) {
        case f.types.HD:
          e(!this.data), e(this.index !== -1), a.writeU32(this.branch), a.writeU32(this.index);
          break;
        case f.types.KEY:
          e(this.data), e(this.index === -1), a.writeU8(this.encrypted ? 1 : 0), a.writeVarBytes(this.data);
          break;
        case f.types.ADDRESS:
          e(!this.data), e(this.index === -1);
          break;
        default:
          e(!1);
          break;
      }
      return a.render();
    }
    /**
     * Inject properties from address.
     * @private
     * @param {Account} account
     * @param {Address} address
     */
    fromAddress(u, a) {
      return this.keyType = f.types.ADDRESS, this.name = u.name, this.account = u.accountIndex, this.version = a.version, this.type = a.type, this.hash = a.getHash(), this;
    }
    /**
     * Instantiate path from address.
     * @param {Account} account
     * @param {Address} address
     * @returns {Path}
     */
    static fromAddress(u, a) {
      return new this().fromAddress(u, a);
    }
    /**
     * Convert path object to string derivation path.
     * @returns {String}
     */
    toPath() {
      return this.keyType !== f.types.HD ? null : `m/${this.account}'/${this.branch}/${this.index}`;
    }
    /**
     * Convert path object to an address (currently unused).
     * @returns {Address}
     */
    toAddress() {
      return d.fromHash(this.hash, this.type, this.version);
    }
    /**
     * Convert path to a json-friendly object.
     * @returns {Object}
     */
    toJSON() {
      return {
        name: this.name,
        account: this.account,
        change: this.branch === 1,
        derivation: this.toPath()
      };
    }
    /**
     * Inspect the path.
     * @returns {String}
     */
    [g]() {
      return `<Path: ${this.name}:${this.toPath()}>`;
    }
  }
  return f.types = {
    HD: 0,
    KEY: 1,
    ADDRESS: 2
  }, f.typesByVal = [
    "HD",
    "KEY",
    "ADDRESS"
  ], Yu = f, Yu;
}
var Xu = {};
/*!
 * common.js - commonly required functions for wallet.
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var p3;
function Rl() {
  return p3 || (p3 = 1, function(e) {
    const { BufferMap: c } = Dr(), d = e;
    d.isName = function(g) {
      if (typeof g != "string" || g.length === 0 || !/^[\-\._0-9A-Za-z]+$/.test(g))
        return !1;
      switch (g[0]) {
        case "_":
        case "-":
        case ".":
          return !1;
      }
      switch (g[g.length - 1]) {
        case "_":
        case "-":
        case ".":
          return !1;
      }
      return g.length >= 1 && g.length <= 40;
    }, d.sortTX = function(g) {
      return g.sort((f, n) => f.mtime - n.mtime);
    }, d.sortCoins = function(g) {
      return g.sort((f, n) => (f = f.height === -1 ? 2147483647 : f.height, n = n.height === -1 ? 2147483647 : n.height, f - n));
    }, d.sortDeps = function(g) {
      const f = new c();
      for (const i of g) {
        const p = i.hash();
        f.set(p, i);
      }
      const n = new c(), u = new c(), a = [];
      for (const [i, p] of f) {
        u.set(i, 0);
        let m = !1;
        for (const E of p.inputs) {
          const v = E.prevout.hash;
          if (!f.has(v))
            continue;
          const b = u.get(i);
          u.set(i, b + 1), m = !0, n.has(v) || n.set(v, []), n.get(v).push(p);
        }
        m || a.push(p);
      }
      const s = [];
      for (const i of a) {
        const p = n.get(i.hash());
        if (s.push(i), !!p)
          for (const m of p) {
            let E = u.get(m.hash());
            --E === 0 && a.push(m), u.set(m.hash(), E);
          }
      }
      return s;
    };
  }(Xu)), Xu;
}
var Es = { exports: {} };
/*!
 * records.js - walletdb records
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var m3;
function a7() {
  return m3 || (m3 = 1, function(e, c) {
    const d = $e(), w = At(), g = Zt(), f = xn(), n = Ht();
    class u {
      /**
       * Create a chain state.
       * @constructor
       */
      constructor() {
        this.startHeight = 0, this.startHash = n.ZERO_HASH, this.height = 0, this.marked = !1;
      }
      /**
       * Clone the state.
       * @returns {ChainState}
       */
      clone() {
        const m = new u();
        return m.startHeight = this.startHeight, m.startHash = this.startHash, m.height = this.height, m.marked = this.marked, m;
      }
      /**
       * Inject properties from serialized data.
       * @private
       * @param {Buffer} data
       */
      fromRaw(m) {
        const E = w.read(m);
        return this.startHeight = E.readU32(), this.startHash = E.readHash(), this.height = E.readU32(), this.marked = E.readU8() === 1, this;
      }
      /**
       * Instantiate chain state from serialized data.
       * @param {Hash} hash
       * @param {Buffer} data
       * @returns {ChainState}
       */
      static fromRaw(m) {
        return new this().fromRaw(m);
      }
      /**
       * Serialize the chain state.
       * @returns {Buffer}
       */
      toRaw() {
        const m = w.write(41);
        return m.writeU32(this.startHeight), m.writeHash(this.startHash), m.writeU32(this.height), m.writeU8(this.marked ? 1 : 0), m.render();
      }
    }
    class a {
      /**
       * Create block meta.
       * @constructor
       * @param {Hash} hash
       * @param {Number} height
       * @param {Number} time
       */
      constructor(m, E, v) {
        this.hash = m || n.ZERO_HASH, this.height = E ?? -1, this.time = v || 0;
      }
      /**
       * Clone the block.
       * @returns {BlockMeta}
       */
      clone() {
        return new this.constructor(this.hash, this.height, this.time);
      }
      /**
       * Get block meta hash as a buffer.
       * @returns {Buffer}
       */
      toHash() {
        return this.hash;
      }
      /**
       * Instantiate block meta from chain entry.
       * @private
       * @param {ChainEntry} entry
       */
      fromEntry(m) {
        return this.hash = m.hash, this.height = m.height, this.time = m.time, this;
      }
      /**
       * Instantiate block meta from json object.
       * @private
       * @param {Object} json
       */
      fromJSON(m) {
        return this.hash = g.revHex(m.hash), this.height = m.height, this.time = m.time, this;
      }
      /**
       * Instantiate block meta from serialized tip data.
       * @private
       * @param {Buffer} data
       */
      fromRaw(m) {
        const E = w.read(m);
        return this.hash = E.readHash(), this.height = E.readU32(), this.time = E.readU32(), this;
      }
      /**
       * Instantiate block meta from chain entry.
       * @param {ChainEntry} entry
       * @returns {BlockMeta}
       */
      static fromEntry(m) {
        return new this().fromEntry(m);
      }
      /**
       * Instantiate block meta from json object.
       * @param {Object} json
       * @returns {BlockMeta}
       */
      static fromJSON(m) {
        return new this().fromJSON(m);
      }
      /**
       * Instantiate block meta from serialized data.
       * @param {Hash} hash
       * @param {Buffer} data
       * @returns {BlockMeta}
       */
      static fromRaw(m) {
        return new this().fromRaw(m);
      }
      /**
       * Serialize the block meta.
       * @returns {Buffer}
       */
      toRaw() {
        const m = w.write(42);
        return m.writeHash(this.hash), m.writeU32(this.height), m.writeU32(this.time), m.render();
      }
      /**
       * Convert the block meta to a more json-friendly object.
       * @returns {Object}
       */
      toJSON() {
        return {
          hash: g.revHex(this.hash),
          height: this.height,
          time: this.time
        };
      }
    }
    class s {
      /**
       * Create tx record.
       * @constructor
       * @param {TX} tx
       * @param {BlockMeta?} block
       */
      constructor(m, E) {
        this.tx = null, this.hash = null, this.mtime = g.now(), this.height = -1, this.block = null, this.index = -1, this.time = 0, m && this.fromTX(m, E);
      }
      /**
       * Inject properties from tx and block.
       * @private
       * @param {TX} tx
       * @param {Block?} block
       * @returns {TXRecord}
       */
      fromTX(m, E) {
        return this.tx = m, this.hash = m.hash(), E && this.setBlock(E), this;
      }
      /**
       * Instantiate tx record from tx and block.
       * @param {TX} tx
       * @param {Block?} block
       * @returns {TXRecord}
       */
      static fromTX(m, E) {
        return new this().fromTX(m, E);
      }
      /**
       * Set block data (confirm).
       * @param {BlockMeta} block
       */
      setBlock(m) {
        this.height = m.height, this.block = m.hash, this.time = m.time;
      }
      /**
       * Unset block (unconfirm).
       */
      unsetBlock() {
        this.height = -1, this.block = null, this.time = 0;
      }
      /**
       * Convert tx record to a block meta.
       * @returns {BlockMeta}
       */
      getBlock() {
        return this.height === -1 ? null : new a(this.block, this.height, this.time);
      }
      /**
       * Calculate current number of transaction confirmations.
       * @param {Number} height - Current chain height.
       * @returns {Number} confirmations
       */
      getDepth(m) {
        return d(typeof m == "number", "Must pass in height."), this.height === -1 || m < this.height ? 0 : m - this.height + 1;
      }
      /**
       * Get serialization size.
       * @returns {Number}
       */
      getSize() {
        let m = 0;
        return m += this.tx.getSize(), m += 4, this.block ? (m += 1, m += 32, m += 12) : m += 1, m;
      }
      /**
       * Serialize a transaction to "extended format".
       * @returns {Buffer}
       */
      toRaw() {
        const m = this.getSize(), E = w.write(m);
        let v = this.index;
        return this.tx.toWriter(E), E.writeU32(this.mtime), this.block ? (v === -1 && (v = 2147483647), E.writeU8(1), E.writeHash(this.block), E.writeU32(this.height), E.writeU32(this.time), E.writeU32(v)) : E.writeU8(0), E.render();
      }
      /**
       * Inject properties from "extended" format.
       * @private
       * @param {Buffer} data
       */
      fromRaw(m) {
        const E = w.read(m);
        return this.tx = new f(), this.tx.fromReader(E), this.hash = this.tx.hash(), this.mtime = E.readU32(), E.readU8() === 1 && (this.block = E.readHash(), this.height = E.readU32(), this.time = E.readU32(), this.index = E.readU32(), this.index === 2147483647 && (this.index = -1)), this;
      }
      /**
       * Instantiate a transaction from a buffer
       * in "extended" serialization format.
       * @param {Buffer} data
       * @returns {TX}
       */
      static fromRaw(m) {
        return new this().fromRaw(m);
      }
    }
    class i {
      /**
       * Create map record.
       * @constructor
       */
      constructor() {
        this.wids = /* @__PURE__ */ new Set();
      }
      add(m) {
        return this.wids.has(m) ? !1 : (this.wids.add(m), !0);
      }
      remove(m) {
        return this.wids.delete(m);
      }
      toWriter(m) {
        m.writeU32(this.wids.size);
        for (const E of this.wids)
          m.writeU32(E);
        return m;
      }
      getSize() {
        return 4 + this.wids.size * 4;
      }
      toRaw() {
        const m = this.getSize();
        return this.toWriter(w.write(m)).render();
      }
      fromReader(m) {
        const E = m.readU32();
        for (let v = 0; v < E; v++)
          this.wids.add(m.readU32());
        return this;
      }
      fromRaw(m) {
        return this.fromReader(w.read(m));
      }
      static fromReader(m) {
        return new this().fromReader(m);
      }
      static fromRaw(m) {
        return new this().fromRaw(m);
      }
    }
    c.ChainState = u, c.BlockMeta = a, c.TXRecord = s, c.MapRecord = i, e.exports = c;
  }(Es, Es.exports)), Es.exports;
}
var Is = {};
/*!
 * layout.js - data layout for wallets
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var g3;
function f7() {
  if (g3) return Is;
  g3 = 1;
  const e = o7();
  return Is.wdb = {
    V: e.key("V"),
    O: e.key("O"),
    R: e.key("R"),
    D: e.key("D"),
    p: e.key("p", ["hash"]),
    P: e.key("P", ["uint32", "hash"]),
    r: e.key("r", ["uint32", "uint32", "hash"]),
    w: e.key("w", ["uint32"]),
    W: e.key("W", ["uint32"]),
    l: e.key("l", ["ascii"]),
    a: e.key("a", ["uint32", "uint32"]),
    i: e.key("i", ["uint32", "ascii"]),
    n: e.key("n", ["uint32", "uint32"]),
    h: e.key("h", ["uint32"]),
    b: e.key("b", ["uint32"]),
    o: e.key("o", ["hash256", "uint32"]),
    T: e.key("T", ["hash256"]),
    t: e.key("t", ["uint32"])
  }, Is.txdb = {
    prefix: e.key("t", ["uint32"]),
    R: e.key("R"),
    r: e.key("r", ["uint32"]),
    t: e.key("t", ["hash256"]),
    c: e.key("c", ["hash256", "uint32"]),
    d: e.key("d", ["hash256", "uint32"]),
    s: e.key("s", ["hash256", "uint32"]),
    p: e.key("p", ["hash256"]),
    m: e.key("m", ["uint32", "hash256"]),
    h: e.key("h", ["uint32", "hash256"]),
    T: e.key("T", ["uint32", "hash256"]),
    P: e.key("P", ["uint32", "hash256"]),
    M: e.key("M", ["uint32", "uint32", "hash256"]),
    H: e.key("H", ["uint32", "uint32", "hash256"]),
    C: e.key("C", ["uint32", "hash256", "uint32"]),
    b: e.key("b", ["uint32"])
  }, Is;
}
var Ju, x3;
function Dx() {
  if (x3) return Ju;
  x3 = 1;
  const e = $e(), c = At(), { BufferSet: d } = Dr(), w = Zt(), g = bi(), f = mo(), n = rs(), u = xi(), a = a7(), s = f7().txdb, i = Ht(), p = mi(), { TXRecord: m } = a, { inspectSymbol: E } = Kt();
  class v {
    /**
     * Create a TXDB.
     * @constructor
     * @param {WalletDB} wdb
     */
    constructor(N, z) {
      this.wdb = N, this.db = N.db, this.logger = N.logger, this.wid = z || 0, this.bucket = null, this.wallet = null, this.locked = new d();
    }
    /**
     * Open TXDB.
     * @returns {Promise}
     */
    async open(N) {
      const z = s.prefix.encode(N.wid);
      this.wid = N.wid, this.bucket = this.db.bucket(z), this.wallet = N;
    }
    /**
     * Emit transaction event.
     * @private
     * @param {String} event
     * @param {Object} data
     * @param {Details} details
     */
    emit(N, z, A) {
      this.wdb.emit(N, this.wallet, z, A), this.wallet.emit(N, z, A);
    }
    /**
     * Get wallet path for output.
     * @param {Output} output
     * @returns {Promise} - Returns {@link Path}.
     */
    getPath(N) {
      const z = N.getHash();
      return z ? this.wdb.getPath(this.wid, z) : null;
    }
    /**
     * Test whether path exists for output.
     * @param {Output} output
     * @returns {Promise} - Returns Boolean.
     */
    hasPath(N) {
      const z = N.getHash();
      return z ? this.wdb.hasPath(this.wid, z) : !1;
    }
    /**
     * Save credit.
     * @param {Credit} credit
     * @param {Path} path
     */
    async saveCredit(N, z, A) {
      const { coin: q } = z;
      return N.put(s.c.encode(q.hash, q.index), z.toRaw()), N.put(s.C.encode(A.account, q.hash, q.index), null), this.addOutpointMap(N, q.hash, q.index);
    }
    /**
     * Remove credit.
     * @param {Credit} credit
     * @param {Path} path
     */
    async removeCredit(N, z, A) {
      const { coin: q } = z;
      return N.del(s.c.encode(q.hash, q.index)), N.del(s.C.encode(A.account, q.hash, q.index)), this.removeOutpointMap(N, q.hash, q.index);
    }
    /**
     * Spend credit.
     * @param {Credit} credit
     * @param {TX} tx
     * @param {Number} index
     */
    spendCredit(N, z, A, q) {
      const _ = A.inputs[q].prevout, F = u.fromTX(A, q);
      N.put(s.s.encode(_.hash, _.index), F.toRaw()), N.put(s.d.encode(F.hash, F.index), z.coin.toRaw());
    }
    /**
     * Unspend credit.
     * @param {TX} tx
     * @param {Number} index
     */
    unspendCredit(N, z, A) {
      const q = z.inputs[A].prevout, _ = u.fromTX(z, A);
      N.del(s.s.encode(q.hash, q.index)), N.del(s.d.encode(_.hash, _.index));
    }
    /**
     * Write input record.
     * @param {TX} tx
     * @param {Number} index
     */
    async writeInput(N, z, A) {
      const q = z.inputs[A].prevout, _ = u.fromTX(z, A);
      return N.put(s.s.encode(q.hash, q.index), _.toRaw()), this.addOutpointMap(N, q.hash, q.index);
    }
    /**
     * Remove input record.
     * @param {TX} tx
     * @param {Number} index
     */
    async removeInput(N, z, A) {
      const q = z.inputs[A].prevout;
      return N.del(s.s.encode(q.hash, q.index)), this.removeOutpointMap(N, q.hash, q.index);
    }
    /**
     * Update wallet balance.
     * @param {BalanceDelta} state
     */
    async updateBalance(N, z) {
      const A = await this.getWalletBalance();
      return z.applyTo(A), N.put(s.R.encode(), A.toRaw()), A;
    }
    /**
     * Update account balance.
     * @param {Number} acct
     * @param {Balance} delta
     */
    async updateAccountBalance(N, z, A) {
      const q = await this.getAccountBalance(z);
      return A.applyTo(q), N.put(s.r.encode(z), q.toRaw()), q;
    }
    /**
     * Test a whether a coin has been spent.
     * @param {Hash} hash
     * @param {Number} index
     * @returns {Promise} - Returns Boolean.
     */
    async getSpent(N, z) {
      const A = await this.bucket.get(s.s.encode(N, z));
      return A ? u.fromRaw(A) : null;
    }
    /**
     * Test a whether a coin has been spent.
     * @param {Hash} hash
     * @param {Number} index
     * @returns {Promise} - Returns Boolean.
     */
    isSpent(N, z) {
      return this.bucket.has(s.s.encode(N, z));
    }
    /**
     * Append to global map.
     * @param {Number} height
     * @returns {Promise}
     */
    addBlockMap(N, z) {
      return this.wdb.addBlockMap(N.root(), z, this.wid);
    }
    /**
     * Remove from global map.
     * @param {Number} height
     * @returns {Promise}
     */
    removeBlockMap(N, z) {
      return this.wdb.removeBlockMap(N.root(), z, this.wid);
    }
    /**
     * Append to global map.
     * @param {Hash} hash
     * @returns {Promise}
     */
    addTXMap(N, z) {
      return this.wdb.addTXMap(N.root(), z, this.wid);
    }
    /**
     * Remove from global map.
     * @param {Hash} hash
     * @returns {Promise}
     */
    removeTXMap(N, z) {
      return this.wdb.removeTXMap(N.root(), z, this.wid);
    }
    /**
     * Append to global map.
     * @param {Hash} hash
     * @param {Number} index
     * @returns {Promise}
     */
    addOutpointMap(N, z, A) {
      return this.wdb.addOutpointMap(N.root(), z, A, this.wid);
    }
    /**
     * Remove from global map.
     * @param {Hash} hash
     * @param {Number} index
     * @returns {Promise}
     */
    removeOutpointMap(N, z, A) {
      return this.wdb.removeOutpointMap(N.root(), z, A, this.wid);
    }
    /**
     * List block records.
     * @returns {Promise}
     */
    getBlocks() {
      return this.bucket.keys({
        gte: s.b.min(),
        lte: s.b.max(),
        parse: (N) => s.b.decode(N)[0]
      });
    }
    /**
     * Get block record.
     * @param {Number} height
     * @returns {Promise}
     */
    async getBlock(N) {
      const z = await this.bucket.get(s.b.encode(N));
      return z ? j.fromRaw(z) : null;
    }
    /**
     * Append to the global block record.
     * @param {Hash} hash
     * @param {BlockMeta} block
     * @returns {Promise}
     */
    async addBlock(N, z, A) {
      const q = s.b.encode(A.height), _ = await this.bucket.get(q);
      if (!_) {
        const V = j.fromMeta(A);
        V.add(z), N.put(q, V.toRaw());
        return;
      }
      const F = k.allocUnsafe(_.length + 32);
      _.copy(F, 0);
      const R = F.readUInt32LE(40, !0);
      F.writeUInt32LE(R + 1, 40, !0), z.copy(F, _.length), N.put(q, F);
    }
    /**
     * Remove from the global block record.
     * @param {Hash} hash
     * @param {Number} height
     * @returns {Promise}
     */
    async removeBlock(N, z, A) {
      const q = s.b.encode(A), _ = await this.bucket.get(q);
      if (!_)
        return;
      const F = _.readUInt32LE(40, !0);
      if (e(F > 0), e(_.slice(-32).equals(z)), F === 1) {
        N.del(q);
        return;
      }
      const R = _.slice(0, -32);
      R.writeUInt32LE(F - 1, 40, !0), N.put(q, R);
    }
    /**
     * Remove from the global block record.
     * @param {Hash} hash
     * @param {Number} height
     * @returns {Promise}
     */
    async spliceBlock(N, z, A) {
      const q = await this.getBlock(A);
      if (q && q.remove(z)) {
        if (q.hashes.size === 0) {
          N.del(s.b.encode(A));
          return;
        }
        N.put(s.b.encode(A), q.toRaw());
      }
    }
    /**
     * Add transaction without a batch.
     * @private
     * @param {TX} tx
     * @returns {Promise}
     */
    async add(N, z) {
      const A = N.hash(), q = await this.getTX(A);
      if (e(!N.mutable, "Cannot add mutable TX to wallet."), q)
        return q.height !== -1 || !z ? null : this.confirm(q, z);
      const _ = m.fromTX(N, z);
      if (z)
        await this.removeConflicts(N, !1);
      else if (!await this.removeConflicts(N, !0))
        return null;
      return this.insert(_, z);
    }
    /**
     * Insert transaction.
     * @private
     * @param {TXRecord} wtx
     * @param {BlockMeta} block
     * @returns {Promise}
     */
    async insert(N, z) {
      const A = this.bucket.batch(), { tx: q, hash: _ } = N, F = z ? z.height : -1, R = new S(N, z), V = new h();
      let fe = !1;
      if (!q.isCoinbase())
        for (let ae = 0; ae < q.inputs.length; ae++) {
          const D = q.inputs[ae], { hash: Q, index: Z } = D.prevout, oe = await this.getCredit(Q, Z);
          if (!oe) {
            z || await this.writeInput(A, q, ae);
            continue;
          }
          const y = oe.coin, Y = await this.getPath(y);
          e(Y), R.setInput(ae, Y, y), this.spendCredit(A, oe, q, ae), V.tx(Y, 1), V.coin(Y, -1), V.unconfirmed(Y, -y.value), z ? (V.confirmed(Y, -y.value), await this.removeCredit(A, oe, Y)) : (oe.spent = !0, await this.saveCredit(A, oe, Y)), fe = !0;
        }
      for (let ae = 0; ae < q.outputs.length; ae++) {
        const D = q.outputs[ae], Q = await this.getPath(D);
        if (!Q)
          continue;
        R.setOutput(ae, Q);
        const Z = o.fromTX(q, ae, F);
        Z.own = fe, V.tx(Q, 1), V.coin(Q, 1), V.unconfirmed(Q, D.value), z && V.confirmed(Q, D.value), await this.saveCredit(A, Z, Q);
      }
      if (!V.updated())
        return null;
      A.put(s.t.encode(_), N.toRaw()), A.put(s.m.encode(N.mtime, _), null), z ? A.put(s.h.encode(F, _), null) : A.put(s.p.encode(_), null);
      for (const [ae, D] of V.accounts)
        await this.updateAccountBalance(A, ae, D), A.put(s.T.encode(ae, _), null), A.put(s.M.encode(ae, N.mtime, _), null), z ? A.put(s.H.encode(ae, F, _), null) : A.put(s.P.encode(ae, _), null);
      z ? (await this.addBlockMap(A, F), await this.addBlock(A, q.hash(), z)) : await this.addTXMap(A, _);
      const ue = await this.updateBalance(A, V);
      return await A.write(), this.unlockTX(q), this.emit("tx", q, R), this.emit("balance", ue), R;
    }
    /**
     * Attempt to confirm a transaction.
     * @private
     * @param {TXRecord} wtx
     * @param {BlockMeta} block
     * @returns {Promise}
     */
    async confirm(N, z) {
      const A = this.bucket.batch(), { tx: q, hash: _ } = N, F = z.height, R = new S(N, z), V = new h();
      if (N.setBlock(z), !q.isCoinbase()) {
        const ue = await this.getSpentCredits(q);
        for (let ae = 0; ae < q.inputs.length; ae++) {
          const D = q.inputs[ae], { hash: Q, index: Z } = D.prevout;
          let oe = !1;
          if (!ue[ae]) {
            await this.removeInput(A, q, ae);
            const be = await this.getCredit(Q, Z);
            if (!be)
              continue;
            this.spendCredit(A, be, q, ae), ue[ae] = be, oe = !0;
          }
          const y = ue[ae], Y = y.coin;
          e(Y.height !== -1);
          const he = await this.getPath(Y);
          e(he), R.setInput(ae, he, Y), oe && (V.coin(he, -1), V.unconfirmed(he, -Y.value)), V.confirmed(he, -Y.value), await this.removeCredit(A, y, he);
        }
      }
      for (let ue = 0; ue < q.outputs.length; ue++) {
        const ae = q.outputs[ue], D = await this.getPath(ae);
        if (!D)
          continue;
        R.setOutput(ue, D);
        const Q = await this.getCredit(_, ue);
        e(Q), Q.spent && await this.updateSpentCoin(A, q, ue, F), V.confirmed(D, ae.value), Q.coin.height = F, await this.saveCredit(A, Q, D);
      }
      A.put(s.t.encode(_), N.toRaw()), A.del(s.p.encode(_)), A.put(s.h.encode(F, _), null);
      for (const [ue, ae] of V.accounts)
        await this.updateAccountBalance(A, ue, ae), A.del(s.P.encode(ue, _)), A.put(s.H.encode(ue, F, _), null);
      await this.removeTXMap(A, _), await this.addBlockMap(A, F), await this.addBlock(A, q.hash(), z);
      const fe = await this.updateBalance(A, V);
      return await A.write(), this.unlockTX(q), this.emit("confirmed", q, R), this.emit("balance", fe), R;
    }
    /**
     * Recursively remove a transaction
     * from the database.
     * @param {Hash} hash
     * @returns {Promise}
     */
    async remove(N) {
      const z = await this.getTX(N);
      return z ? this.removeRecursive(z) : null;
    }
    /**
     * Remove a transaction from the
     * database. Disconnect inputs.
     * @private
     * @param {TXRecord} wtx
     * @returns {Promise}
     */
    async erase(N, z) {
      const A = this.bucket.batch(), { tx: q, hash: _ } = N, F = z ? z.height : -1, R = new S(N, z), V = new h();
      if (!q.isCoinbase()) {
        const ue = await this.getSpentCredits(q);
        for (let ae = 0; ae < q.inputs.length; ae++) {
          const D = ue[ae];
          if (!D) {
            z || await this.removeInput(A, q, ae);
            continue;
          }
          const Q = D.coin, Z = await this.getPath(Q);
          e(Z), R.setInput(ae, Z, Q), V.tx(Z, -1), V.coin(Z, 1), V.unconfirmed(Z, Q.value), z && V.confirmed(Z, Q.value), this.unspendCredit(A, q, ae), D.spent = !1, await this.saveCredit(A, D, Z);
        }
      }
      for (let ue = 0; ue < q.outputs.length; ue++) {
        const ae = q.outputs[ue], D = await this.getPath(ae);
        if (!D)
          continue;
        R.setOutput(ue, D);
        const Q = o.fromTX(q, ue, F);
        V.tx(D, -1), V.coin(D, -1), V.unconfirmed(D, -ae.value), z && V.confirmed(D, -ae.value), await this.removeCredit(A, Q, D);
      }
      A.del(s.t.encode(_)), A.del(s.m.encode(N.mtime, _)), z ? A.del(s.h.encode(F, _)) : A.del(s.p.encode(_));
      for (const [ue, ae] of V.accounts)
        await this.updateAccountBalance(A, ue, ae), A.del(s.T.encode(ue, _)), A.del(s.M.encode(ue, N.mtime, _)), z ? A.del(s.H.encode(ue, F, _)) : A.del(s.P.encode(ue, _));
      z ? (await this.removeBlockMap(A, F), await this.spliceBlock(A, _, F)) : await this.removeTXMap(A, _);
      const fe = await this.updateBalance(A, V);
      return await A.write(), this.emit("remove tx", q, R), this.emit("balance", fe), R;
    }
    /**
     * Remove a transaction and recursively
     * remove all of its spenders.
     * @private
     * @param {TXRecord} wtx
     * @returns {Promise}
     */
    async removeRecursive(N) {
      const { tx: z, hash: A } = N;
      if (!await this.hasTX(A))
        return null;
      for (let q = 0; q < z.outputs.length; q++) {
        const _ = await this.getSpent(A, q);
        if (!_)
          continue;
        const F = await this.getTX(_.hash);
        e(F), await this.removeRecursive(F);
      }
      return this.erase(N, N.getBlock());
    }
    /**
     * Revert a block.
     * @param {Number} height
     * @returns {Promise}
     */
    async revert(N) {
      const z = await this.getBlock(N);
      if (!z)
        return 0;
      this.logger.debug("Rescan: reverting block %d", N);
      const A = z.toArray();
      for (let q = A.length - 1; q >= 0; q--) {
        const _ = A[q];
        await this.unconfirm(_);
      }
      return A.length;
    }
    /**
     * Unconfirm a transaction without a batch.
     * @private
     * @param {Hash} hash
     * @returns {Promise}
     */
    async unconfirm(N) {
      const z = await this.getTX(N);
      return !z || z.height === -1 ? null : this.disconnect(z, z.getBlock());
    }
    /**
     * Unconfirm a transaction. Necessary after a reorg.
     * @param {TXRecord} wtx
     * @returns {Promise}
     */
    async disconnect(N, z) {
      const A = this.bucket.batch(), { tx: q, hash: _, height: F } = N, R = new S(N, z), V = new h();
      if (e(z), N.unsetBlock(), !q.isCoinbase()) {
        const ue = await this.getSpentCredits(q);
        for (let ae = 0; ae < q.inputs.length; ae++) {
          const D = ue[ae];
          if (!D) {
            await this.writeInput(A, q, ae);
            continue;
          }
          const Q = D.coin;
          e(Q.height !== -1);
          const Z = await this.getPath(Q);
          e(Z), R.setInput(ae, Z, Q), V.confirmed(Z, Q.value), D.spent = !0, await this.saveCredit(A, D, Z);
        }
      }
      for (let ue = 0; ue < q.outputs.length; ue++) {
        const ae = q.outputs[ue], D = await this.getPath(ae);
        if (!D)
          continue;
        const Q = await this.getCredit(_, ue);
        if (!Q) {
          await this.updateSpentCoin(A, q, ue, F);
          continue;
        }
        Q.spent && await this.updateSpentCoin(A, q, ue, F), R.setOutput(ue, D), Q.coin.height = -1, V.confirmed(D, -ae.value), await this.saveCredit(A, Q, D);
      }
      await this.addTXMap(A, _), await this.removeBlockMap(A, F), await this.removeBlock(A, q.hash(), F), A.put(s.t.encode(_), N.toRaw()), A.put(s.p.encode(_), null), A.del(s.h.encode(F, _));
      for (const [ue, ae] of V.accounts)
        await this.updateAccountBalance(A, ue, ae), A.put(s.P.encode(ue, _), null), A.del(s.H.encode(ue, F, _));
      const fe = await this.updateBalance(A, V);
      return await A.write(), this.emit("unconfirmed", q, R), this.emit("balance", fe), R;
    }
    /**
     * Remove spenders that have not been confirmed. We do this in the
     * odd case of stuck transactions or when a coin is double-spent
     * by a newer transaction. All previously-spending transactions
     * of that coin that are _not_ confirmed will be removed from
     * the database.
     * @private
     * @param {Hash} hash
     * @param {TX} ref - Reference tx, the tx that double-spent.
     * @returns {Promise} - Returns Boolean.
     */
    async removeConflict(N) {
      const z = N.tx;
      this.logger.warning("Handling conflicting tx: %h.", z.hash());
      const A = await this.removeRecursive(N);
      return A ? (this.logger.warning("Removed conflict: %h.", z.hash()), this.emit("conflict", z, A), A) : null;
    }
    /**
     * Retrieve coins for own inputs, remove
     * double spenders, and verify inputs.
     * @private
     * @param {TX} tx
     * @returns {Promise}
     */
    async removeConflicts(N, z) {
      if (N.isCoinbase())
        return !0;
      const A = N.hash(), q = [];
      for (const { prevout: _ } of N.inputs) {
        const { hash: F, index: R } = _, V = await this.getSpent(F, R);
        if (!V || V.hash.equals(A))
          continue;
        const fe = await this.getTX(V.hash);
        if (e(fe), z && fe.height !== -1)
          return !1;
        q.push(fe);
      }
      for (const _ of q)
        await this.removeConflict(_);
      return !0;
    }
    /**
     * Lock all coins in a transaction.
     * @param {TX} tx
     */
    lockTX(N) {
      if (!N.isCoinbase())
        for (const z of N.inputs)
          this.lockCoin(z.prevout);
    }
    /**
     * Unlock all coins in a transaction.
     * @param {TX} tx
     */
    unlockTX(N) {
      if (!N.isCoinbase())
        for (const z of N.inputs)
          this.unlockCoin(z.prevout);
    }
    /**
     * Lock a single coin.
     * @param {Coin|Outpoint} coin
     */
    lockCoin(N) {
      const z = N.toKey();
      this.locked.add(z);
    }
    /**
     * Unlock a single coin.
     * @param {Coin|Outpoint} coin
     */
    unlockCoin(N) {
      const z = N.toKey();
      return this.locked.delete(z);
    }
    /**
     * Unlock all coins.
     */
    unlockCoins() {
      for (const N of this.getLocked())
        this.unlockCoin(N);
    }
    /**
     * Test locked status of a single coin.
     * @param {Coin|Outpoint} coin
     */
    isLocked(N) {
      const z = N.toKey();
      return this.locked.has(z);
    }
    /**
     * Filter array of coins or outpoints
     * for only unlocked ones.
     * @param {Coin[]|Outpoint[]}
     * @returns {Array}
     */
    filterLocked(N) {
      const z = [];
      for (const A of N)
        this.isLocked(A) || z.push(A);
      return z;
    }
    /**
     * Return an array of all locked outpoints.
     * @returns {Outpoint[]}
     */
    getLocked() {
      const N = [];
      for (const z of this.locked.keys())
        N.push(u.fromKey(z));
      return N;
    }
    /**
     * Get hashes of all transactions in the database.
     * @param {Number} acct
     * @returns {Promise} - Returns {@link Hash}[].
     */
    getAccountHistoryHashes(N) {
      return e(typeof N == "number"), this.bucket.keys({
        gte: s.T.min(N),
        lte: s.T.max(N),
        parse: (z) => {
          const [, A] = s.T.decode(z);
          return A;
        }
      });
    }
    /**
     * Get hashes of all transactions in the database.
     * @param {Number} acct
     * @returns {Promise} - Returns {@link Hash}[].
     */
    getHistoryHashes(N) {
      return e(typeof N == "number"), N !== -1 ? this.getAccountHistoryHashes(N) : this.bucket.keys({
        gte: s.t.min(),
        lte: s.t.max(),
        parse: (z) => s.t.decode(z)[0]
      });
    }
    /**
     * Get hashes of all unconfirmed transactions in the database.
     * @param {Number} acct
     * @returns {Promise} - Returns {@link Hash}[].
     */
    getAccountPendingHashes(N) {
      return e(typeof N == "number"), this.bucket.keys({
        gte: s.P.min(N),
        lte: s.P.max(N),
        parse: (z) => {
          const [, A] = s.P.decode(z);
          return A;
        }
      });
    }
    /**
     * Get hashes of all unconfirmed transactions in the database.
     * @param {Number} acct
     * @returns {Promise} - Returns {@link Hash}[].
     */
    getPendingHashes(N) {
      return e(typeof N == "number"), N !== -1 ? this.getAccountPendingHashes(N) : this.bucket.keys({
        gte: s.p.min(),
        lte: s.p.max(),
        parse: (z) => s.p.decode(z)[0]
      });
    }
    /**
     * Get all coin hashes in the database.
     * @param {Number} acct
     * @returns {Promise} - Returns {@link Hash}[].
     */
    getAccountOutpoints(N) {
      return e(typeof N == "number"), this.bucket.keys({
        gte: s.C.min(N),
        lte: s.C.max(N),
        parse: (z) => {
          const [, A, q] = s.C.decode(z);
          return new u(A, q);
        }
      });
    }
    /**
     * Get all coin hashes in the database.
     * @param {Number} acct
     * @returns {Promise} - Returns {@link Hash}[].
     */
    getOutpoints(N) {
      return e(typeof N == "number"), N !== -1 ? this.getAccountOutpoints(N) : this.bucket.keys({
        gte: s.c.min(),
        lte: s.c.max(),
        parse: (z) => {
          const [A, q] = s.c.decode(z);
          return new u(A, q);
        }
      });
    }
    /**
     * Get TX hashes by height range.
     * @param {Number} acct
     * @param {Object} options
     * @param {Number} options.start - Start height.
     * @param {Number} options.end - End height.
     * @param {Number?} options.limit - Max number of records.
     * @param {Boolean?} options.reverse - Reverse order.
     * @returns {Promise} - Returns {@link Hash}[].
     */
    getAccountHeightRangeHashes(N, z) {
      e(typeof N == "number");
      const A = z.start || 0, q = z.end || 4294967295;
      return this.bucket.keys({
        gte: s.H.min(N, A),
        lte: s.H.max(N, q),
        limit: z.limit,
        reverse: z.reverse,
        parse: (_) => {
          const [, , F] = s.H.decode(_);
          return F;
        }
      });
    }
    /**
     * Get TX hashes by height range.
     * @param {Number} acct
     * @param {Object} options
     * @param {Number} options.start - Start height.
     * @param {Number} options.end - End height.
     * @param {Number?} options.limit - Max number of records.
     * @param {Boolean?} options.reverse - Reverse order.
     * @returns {Promise} - Returns {@link Hash}[].
     */
    getHeightRangeHashes(N, z) {
      if (e(typeof N == "number"), N !== -1)
        return this.getAccountHeightRangeHashes(N, z);
      const A = z.start || 0, q = z.end || 4294967295;
      return this.bucket.keys({
        gte: s.h.min(A),
        lte: s.h.max(q),
        limit: z.limit,
        reverse: z.reverse,
        parse: (_) => {
          const [, F] = s.h.decode(_);
          return F;
        }
      });
    }
    /**
     * Get TX hashes by height.
     * @param {Number} height
     * @returns {Promise} - Returns {@link Hash}[].
     */
    getHeightHashes(N) {
      return this.getHeightRangeHashes({ start: N, end: N });
    }
    /**
     * Get TX hashes by timestamp range.
     * @param {Number} acct
     * @param {Object} options
     * @param {Number} options.start - Start height.
     * @param {Number} options.end - End height.
     * @param {Number?} options.limit - Max number of records.
     * @param {Boolean?} options.reverse - Reverse order.
     * @returns {Promise} - Returns {@link Hash}[].
     */
    getAccountRangeHashes(N, z) {
      e(typeof N == "number");
      const A = z.start || 0, q = z.end || 4294967295;
      return this.bucket.keys({
        gte: s.M.min(N, A),
        lte: s.M.max(N, q),
        limit: z.limit,
        reverse: z.reverse,
        parse: (_) => {
          const [, , F] = s.M.decode(_);
          return F;
        }
      });
    }
    /**
     * Get TX hashes by timestamp range.
     * @param {Number} acct
     * @param {Object} options
     * @param {Number} options.start - Start height.
     * @param {Number} options.end - End height.
     * @param {Number?} options.limit - Max number of records.
     * @param {Boolean?} options.reverse - Reverse order.
     * @returns {Promise} - Returns {@link Hash}[].
     */
    getRangeHashes(N, z) {
      if (e(typeof N == "number"), N !== -1)
        return this.getAccountRangeHashes(N, z);
      const A = z.start || 0, q = z.end || 4294967295;
      return this.bucket.keys({
        gte: s.m.min(A),
        lte: s.m.max(q),
        limit: z.limit,
        reverse: z.reverse,
        parse: (_) => {
          const [, F] = s.m.decode(_);
          return F;
        }
      });
    }
    /**
     * Get transactions by timestamp range.
     * @param {Number} acct
     * @param {Object} options
     * @param {Number} options.start - Start time.
     * @param {Number} options.end - End time.
     * @param {Number?} options.limit - Max number of records.
     * @param {Boolean?} options.reverse - Reverse order.
     * @returns {Promise} - Returns {@link TX}[].
     */
    async getRange(N, z) {
      const A = await this.getRangeHashes(N, z), q = [];
      for (const _ of A) {
        const F = await this.getTX(_);
        e(F), q.push(F);
      }
      return q;
    }
    /**
     * Get last N transactions.
     * @param {Number} acct
     * @param {Number} limit - Max number of transactions.
     * @returns {Promise} - Returns {@link TX}[].
     */
    getLast(N, z) {
      return this.getRange(N, {
        start: 0,
        end: 4294967295,
        reverse: !0,
        limit: z || 10
      });
    }
    /**
     * Get all transactions.
     * @param {Number} acct
     * @returns {Promise} - Returns {@link TX}[].
     */
    getHistory(N) {
      return e(typeof N == "number"), N !== -1 ? this.getAccountHistory(N) : this.bucket.values({
        gte: s.t.min(),
        lte: s.t.max(),
        parse: (z) => m.fromRaw(z)
      });
    }
    /**
     * Get all acct transactions.
     * @param {Number} acct
     * @returns {Promise} - Returns {@link TX}[].
     */
    async getAccountHistory(N) {
      const z = await this.getHistoryHashes(N), A = [];
      for (const q of z) {
        const _ = await this.getTX(q);
        e(_), A.push(_);
      }
      return A;
    }
    /**
     * Get unconfirmed transactions.
     * @param {Number} acct
     * @returns {Promise} - Returns {@link TX}[].
     */
    async getPending(N) {
      const z = await this.getPendingHashes(N), A = [];
      for (const q of z) {
        const _ = await this.getTX(q);
        e(_), A.push(_);
      }
      return A;
    }
    /**
     * Get coins.
     * @param {Number} acct
     * @returns {Promise} - Returns {@link Coin}[].
     */
    getCredits(N) {
      return e(typeof N == "number"), N !== -1 ? this.getAccountCredits(N) : this.bucket.range({
        gte: s.c.min(),
        lte: s.c.max(),
        parse: (z, A) => {
          const [q, _] = s.c.decode(z), F = o.fromRaw(A);
          return F.coin.hash = q, F.coin.index = _, F;
        }
      });
    }
    /**
     * Get coins by account.
     * @param {Number} acct
     * @returns {Promise} - Returns {@link Coin}[].
     */
    async getAccountCredits(N) {
      const z = await this.getOutpoints(N), A = [];
      for (const { hash: q, index: _ } of z) {
        const F = await this.getCredit(q, _);
        e(F), A.push(F);
      }
      return A;
    }
    /**
     * Fill a transaction with coins (all historical coins).
     * @param {TX} tx
     * @returns {Promise} - Returns {@link TX}.
     */
    async getSpentCredits(N) {
      if (N.isCoinbase())
        return [];
      const z = N.hash(), A = [];
      for (let q = 0; q < N.inputs.length; q++)
        A.push(null);
      return await this.bucket.range({
        gte: s.d.min(z),
        lte: s.d.max(z),
        parse: (q, _) => {
          const [, F] = s.d.decode(q), R = n.fromRaw(_), V = N.inputs[F];
          e(V), R.hash = V.prevout.hash, R.index = V.prevout.index, A[F] = new o(R);
        }
      }), A;
    }
    /**
     * Get coins.
     * @param {Number} acct
     * @returns {Promise} - Returns {@link Coin}[].
     */
    async getCoins(N) {
      const z = await this.getCredits(N), A = [];
      for (const q of z)
        q.spent || A.push(q.coin);
      return A;
    }
    /**
     * Get coins by account.
     * @param {Number} acct
     * @returns {Promise} - Returns {@link Coin}[].
     */
    async getAccountCoins(N) {
      const z = await this.getAccountCredits(N), A = [];
      for (const q of z)
        q.spent || A.push(q.coin);
      return A;
    }
    /**
     * Get historical coins for a transaction.
     * @param {TX} tx
     * @returns {Promise} - Returns {@link TX}.
     */
    async getSpentCoins(N) {
      if (N.isCoinbase())
        return [];
      const z = await this.getSpentCredits(N), A = [];
      for (const q of z) {
        if (!q) {
          A.push(null);
          continue;
        }
        A.push(q.coin);
      }
      return A;
    }
    /**
     * Get a coin viewpoint.
     * @param {TX} tx
     * @returns {Promise} - Returns {@link CoinView}.
     */
    async getCoinView(N) {
      const z = new f();
      if (N.isCoinbase())
        return z;
      for (const { prevout: A } of N.inputs) {
        const { hash: q, index: _ } = A, F = await this.getCoin(q, _);
        F && z.addCoin(F);
      }
      return z;
    }
    /**
     * Get historical coin viewpoint.
     * @param {TX} tx
     * @returns {Promise} - Returns {@link CoinView}.
     */
    async getSpentView(N) {
      const z = new f();
      if (N.isCoinbase())
        return z;
      const A = await this.getSpentCoins(N);
      for (const q of A)
        q && z.addCoin(q);
      return z;
    }
    /**
     * Get transaction.
     * @param {Hash} hash
     * @returns {Promise} - Returns {@link TX}.
     */
    async getTX(N) {
      const z = await this.bucket.get(s.t.encode(N));
      return z ? m.fromRaw(z) : null;
    }
    /**
     * Get transaction details.
     * @param {Hash} hash
     * @returns {Promise} - Returns {@link TXDetails}.
     */
    async getDetails(N) {
      const z = await this.getTX(N);
      return z ? this.toDetails(z) : null;
    }
    /**
     * Convert transaction to transaction details.
     * @param {TXRecord[]} wtxs
     * @returns {Promise}
     */
    async toDetails(N) {
      const z = [];
      if (!Array.isArray(N))
        return this._toDetails(N);
      for (const A of N) {
        const q = await this._toDetails(A);
        q && z.push(q);
      }
      return z;
    }
    /**
     * Convert transaction to transaction details.
     * @private
     * @param {TXRecord} wtx
     * @returns {Promise}
     */
    async _toDetails(N) {
      const z = N.tx, A = N.getBlock(), q = new S(N, A), _ = await this.getSpentCoins(z);
      for (let F = 0; F < z.inputs.length; F++) {
        const R = _[F];
        let V = null;
        R && (V = await this.getPath(R)), q.setInput(F, V, R);
      }
      for (let F = 0; F < z.outputs.length; F++) {
        const R = z.outputs[F], V = await this.getPath(R);
        q.setOutput(F, V);
      }
      return q;
    }
    /**
     * Test whether the database has a transaction.
     * @param {Hash} hash
     * @returns {Promise} - Returns Boolean.
     */
    hasTX(N) {
      return this.bucket.has(s.t.encode(N));
    }
    /**
     * Get coin.
     * @param {Hash} hash
     * @param {Number} index
     * @returns {Promise} - Returns {@link Coin}.
     */
    async getCoin(N, z) {
      const A = await this.getCredit(N, z);
      return A ? A.coin : null;
    }
    /**
     * Get coin.
     * @param {Hash} hash
     * @param {Number} index
     * @returns {Promise} - Returns {@link Coin}.
     */
    async getCredit(N, z) {
      const A = await this.bucket.get(s.c.encode(N, z));
      if (!A)
        return null;
      const q = o.fromRaw(A);
      return q.coin.hash = N, q.coin.index = z, q;
    }
    /**
     * Get spender coin.
     * @param {Outpoint} spent
     * @param {Outpoint} prevout
     * @returns {Promise} - Returns {@link Coin}.
     */
    async getSpentCoin(N, z) {
      const A = await this.bucket.get(s.d.encode(
        N.hash,
        N.index
      ));
      if (!A)
        return null;
      const q = n.fromRaw(A);
      return q.hash = z.hash, q.index = z.index, q;
    }
    /**
     * Test whether the database has a spent coin.
     * @param {Outpoint} spent
     * @returns {Promise} - Returns {@link Coin}.
     */
    hasSpentCoin(N) {
      return this.bucket.has(s.d.encode(N.hash, N.index));
    }
    /**
     * Update spent coin height in storage.
     * @param {TX} tx - Sending transaction.
     * @param {Number} index
     * @param {Number} height
     * @returns {Promise}
     */
    async updateSpentCoin(N, z, A, q) {
      const _ = u.fromTX(z, A), F = await this.getSpent(_.hash, _.index);
      if (!F)
        return;
      const R = await this.getSpentCoin(F, _);
      R && (R.height = q, N.put(s.d.encode(F.hash, F.index), R.toRaw()));
    }
    /**
     * Test whether the database has a transaction.
     * @param {Hash} hash
     * @returns {Promise} - Returns Boolean.
     */
    async hasCoin(N, z) {
      return this.bucket.has(s.c.encode(N, z));
    }
    /**
     * Calculate balance.
     * @param {Number?} account
     * @returns {Promise} - Returns {@link Balance}.
     */
    async getBalance(N) {
      return e(typeof N == "number"), N !== -1 ? this.getAccountBalance(N) : this.getWalletBalance();
    }
    /**
     * Calculate balance.
     * @returns {Promise} - Returns {@link Balance}.
     */
    async getWalletBalance() {
      const N = await this.bucket.get(s.R.encode());
      return N ? b.fromRaw(-1, N) : new b();
    }
    /**
     * Calculate balance by account.
     * @param {Number} acct
     * @returns {Promise} - Returns {@link Balance}.
     */
    async getAccountBalance(N) {
      const z = await this.bucket.get(s.r.encode(N));
      return z ? b.fromRaw(N, z) : new b(N);
    }
    /**
     * Zap pending transactions older than `age`.
     * @param {Number} acct
     * @param {Number} age - Age delta.
     * @returns {Promise}
     */
    async zap(N, z) {
      e(z >>> 0 === z);
      const A = w.now(), q = await this.getRange(N, {
        start: 0,
        end: A - z
      }), _ = [];
      for (const F of q)
        F.height === -1 && (e(A - F.mtime >= z), this.logger.debug(
          "Zapping TX: %h (%d)",
          F.tx.hash(),
          this.wid
        ), await this.remove(F.hash), _.push(F.hash));
      return _;
    }
    /**
     * Abandon transaction.
     * @param {Hash} hash
     * @returns {Promise}
     */
    async abandon(N) {
      if (!await this.bucket.has(s.p.encode(N)))
        throw new Error("TX not eligible.");
      return this.remove(N);
    }
  }
  class b {
    /**
     * Create a balance.
     * @constructor
     * @param {Number} account
     */
    constructor(N = -1) {
      e(typeof N == "number"), this.account = N, this.tx = 0, this.coin = 0, this.unconfirmed = 0, this.confirmed = 0;
    }
    /**
     * Apply delta.
     * @param {Balance} balance
     */
    applyTo(N) {
      N.tx += this.tx, N.coin += this.coin, N.unconfirmed += this.unconfirmed, N.confirmed += this.confirmed, e(N.tx >= 0), e(N.coin >= 0), e(N.unconfirmed >= 0), e(N.confirmed >= 0);
    }
    /**
     * Serialize balance.
     * @returns {Buffer}
     */
    toRaw() {
      const N = c.write(32);
      return N.writeU64(this.tx), N.writeU64(this.coin), N.writeU64(this.unconfirmed), N.writeU64(this.confirmed), N.render();
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     * @returns {TXDBState}
     */
    fromRaw(N) {
      const z = c.read(N);
      return this.tx = z.readU64(), this.coin = z.readU64(), this.unconfirmed = z.readU64(), this.confirmed = z.readU64(), this;
    }
    /**
     * Instantiate balance from serialized data.
     * @param {Number} acct
     * @param {Buffer} data
     * @returns {TXDBState}
     */
    static fromRaw(N, z) {
      return new this(N).fromRaw(z);
    }
    /**
     * Convert balance to a more json-friendly object.
     * @param {Boolean?} minimal
     * @returns {Object}
     */
    toJSON(N) {
      return {
        account: N ? void 0 : this.account,
        tx: this.tx,
        coin: this.coin,
        unconfirmed: this.unconfirmed,
        confirmed: this.confirmed
      };
    }
    /**
     * Inspect balance.
     * @param {String}
     */
    [E]() {
      return `<Balance tx=${this.tx} coin=${this.coin} unconfirmed=${g.btc(this.unconfirmed)} confirmed=${g.btc(this.confirmed)}>`;
    }
  }
  class h {
    /**
     * Create a balance delta.
     * @constructor
     */
    constructor() {
      this.wallet = new b(), this.accounts = /* @__PURE__ */ new Map();
    }
    updated() {
      return this.wallet.tx !== 0;
    }
    applyTo(N) {
      this.wallet.applyTo(N);
    }
    get(N) {
      return this.accounts.has(N.account) || this.accounts.set(N.account, new b()), this.accounts.get(N.account);
    }
    tx(N, z) {
      const A = this.get(N);
      A.tx = z, this.wallet.tx = z;
    }
    coin(N, z) {
      const A = this.get(N);
      A.coin += z, this.wallet.coin += z;
    }
    unconfirmed(N, z) {
      const A = this.get(N);
      A.unconfirmed += z, this.wallet.unconfirmed += z;
    }
    confirmed(N, z) {
      const A = this.get(N);
      A.confirmed += z, this.wallet.confirmed += z;
    }
  }
  class o {
    /**
     * Create a credit.
     * @constructor
     * @param {Coin} coin
     * @param {Boolean?} spent
     */
    constructor(N, z) {
      this.coin = N || new n(), this.spent = z || !1, this.own = !1;
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     */
    fromRaw(N) {
      const z = c.read(N);
      return this.coin.fromReader(z), this.spent = z.readU8() === 1, this.own = z.readU8() === 1, this;
    }
    /**
     * Instantiate credit from serialized data.
     * @param {Buffer} data
     * @returns {Credit}
     */
    static fromRaw(N) {
      return new this().fromRaw(N);
    }
    /**
     * Get serialization size.
     * @returns {Number}
     */
    getSize() {
      return this.coin.getSize() + 2;
    }
    /**
     * Serialize credit.
     * @returns {Buffer}
     */
    toRaw() {
      const N = this.getSize(), z = c.write(N);
      return this.coin.toWriter(z), z.writeU8(this.spent ? 1 : 0), z.writeU8(this.own ? 1 : 0), z.render();
    }
    /**
     * Inject properties from tx object.
     * @private
     * @param {TX} tx
     * @param {Number} index
     * @returns {Credit}
     */
    fromTX(N, z, A) {
      return this.coin.fromTX(N, z, A), this.spent = !1, this.own = !1, this;
    }
    /**
     * Instantiate credit from transaction.
     * @param {TX} tx
     * @param {Number} index
     * @returns {Credit}
     */
    static fromTX(N, z, A) {
      return new this().fromTX(N, z, A);
    }
  }
  class S {
    /**
     * Create transaction details.
     * @constructor
     * @param {TXRecord} wtx
     * @param {BlockMeta} block
     */
    constructor(N, z) {
      this.hash = N.hash, this.tx = N.tx, this.mtime = N.mtime, this.size = this.tx.getSize(), this.block = null, this.height = -1, this.time = 0, z && (this.block = z.hash, this.height = z.height, this.time = z.time), this.inputs = [], this.outputs = [], this.init();
    }
    /**
     * Initialize transaction details.
     * @private
     */
    init() {
      for (const N of this.tx.inputs) {
        const z = new H();
        z.address = N.getAddress(), this.inputs.push(z);
      }
      for (const N of this.tx.outputs) {
        const z = new H();
        z.value = N.value, z.address = N.getAddress(), this.outputs.push(z);
      }
    }
    /**
     * Add necessary info to input member.
     * @param {Number} i
     * @param {Path} path
     * @param {Coin} coin
     */
    setInput(N, z, A) {
      const q = this.inputs[N];
      A && (q.value = A.value, q.address = A.getAddress()), z && (q.path = z);
    }
    /**
     * Add necessary info to output member.
     * @param {Number} i
     * @param {Path} path
     */
    setOutput(N, z) {
      const A = this.outputs[N];
      z && (A.path = z);
    }
    /**
     * Calculate confirmations.
     * @returns {Number}
     */
    getDepth(N) {
      if (this.height === -1 || N == null)
        return 0;
      const z = N - this.height;
      return z < 0 ? 0 : z + 1;
    }
    /**
     * Calculate fee. Only works if wallet
     * owns all inputs. Returns 0 otherwise.
     * @returns {Amount}
     */
    getFee() {
      let N = 0, z = 0;
      for (const A of this.inputs) {
        if (!A.path)
          return 0;
        N += A.value;
      }
      for (const A of this.outputs)
        z += A.value;
      return N - z;
    }
    /**
     * Calculate fee rate. Only works if wallet
     * owns all inputs. Returns 0 otherwise.
     * @param {Amount} fee
     * @returns {Rate}
     */
    getRate(N) {
      return p.getRate(this.size, N);
    }
    /**
     * Convert details to a more json-friendly object.
     * @returns {Object}
     */
    toJSON(N, z) {
      const A = this.getFee(), q = this.getRate(A);
      return {
        hash: w.revHex(this.hash),
        height: this.height,
        block: this.block ? w.revHex(this.block) : null,
        time: this.time,
        mtime: this.mtime,
        date: w.date(this.time),
        mdate: w.date(this.mtime),
        size: this.size,
        fee: A,
        rate: q,
        confirmations: this.getDepth(z),
        inputs: this.inputs.map((_) => _.getJSON(N)),
        outputs: this.outputs.map((_) => _.getJSON(N)),
        tx: this.tx.toRaw().toString("hex")
      };
    }
  }
  class H {
    /**
     * Create details member.
     * @constructor
     */
    constructor() {
      this.value = 0, this.address = null, this.path = null;
    }
    /**
     * Convert the member to a more json-friendly object.
     * @returns {Object}
     */
    toJSON() {
      return this.getJSON();
    }
    /**
     * Convert the member to a more json-friendly object.
     * @param {Network} network
     * @returns {Object}
     */
    getJSON(N) {
      return {
        value: this.value,
        address: this.address ? this.address.toString(N) : null,
        path: this.path ? this.path.toJSON() : null
      };
    }
  }
  class j {
    /**
     * Create a block record.
     * @constructor
     * @param {Hash} hash
     * @param {Number} height
     * @param {Number} time
     */
    constructor(N, z, A) {
      this.hash = N || i.ZERO_HASH, this.height = z ?? -1, this.time = A || 0, this.hashes = new d();
    }
    /**
     * Add transaction to block record.
     * @param {Hash} hash
     * @returns {Boolean}
     */
    add(N) {
      return this.hashes.has(N) ? !1 : (this.hashes.add(N), !0);
    }
    /**
     * Remove transaction from block record.
     * @param {Hash} hash
     * @returns {Boolean}
     */
    remove(N) {
      return this.hashes.delete(N);
    }
    /**
     * Instantiate wallet block from serialized tip data.
     * @private
     * @param {Buffer} data
     */
    fromRaw(N) {
      const z = c.read(N);
      this.hash = z.readHash(), this.height = z.readU32(), this.time = z.readU32();
      const A = z.readU32();
      for (let q = 0; q < A; q++) {
        const _ = z.readHash();
        this.hashes.add(_);
      }
      return this;
    }
    /**
     * Instantiate wallet block from serialized data.
     * @param {Buffer} data
     * @returns {BlockRecord}
     */
    static fromRaw(N) {
      return new this().fromRaw(N);
    }
    /**
     * Get serialization size.
     * @returns {Number}
     */
    getSize() {
      return 44 + this.hashes.size * 32;
    }
    /**
     * Serialize the wallet block as a tip (hash and height).
     * @returns {Buffer}
     */
    toRaw() {
      const N = this.getSize(), z = c.write(N);
      z.writeHash(this.hash), z.writeU32(this.height), z.writeU32(this.time), z.writeU32(this.hashes.size);
      for (const A of this.hashes)
        z.writeHash(A);
      return z.render();
    }
    /**
     * Convert hashes set to an array.
     * @returns {Hash[]}
     */
    toArray() {
      const N = [];
      for (const z of this.hashes)
        N.push(z);
      return N;
    }
    /**
     * Convert the block to a more json-friendly object.
     * @returns {Object}
     */
    toJSON() {
      return {
        hash: w.revHex(this.hash),
        height: this.height,
        time: this.time,
        hashes: this.toArray().map(w.revHex)
      };
    }
    /**
     * Instantiate wallet block from block meta.
     * @private
     * @param {BlockMeta} block
     */
    fromMeta(N) {
      return this.hash = N.hash, this.height = N.height, this.time = N.time, this;
    }
    /**
     * Instantiate wallet block from block meta.
     * @param {BlockMeta} block
     * @returns {BlockRecord}
     */
    static fromMeta(N) {
      return new this().fromMeta(N);
    }
  }
  return Ju = v, Ju;
}
/*!
 * walletkey.js - walletkey object for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var Gu, w3;
function c7() {
  if (w3) return Gu;
  w3 = 1;
  const e = Lr(), c = Sl(), d = So();
  class w extends c {
    /**
     * Create a wallet key.
     * @constructor
     * @param {Object?} options
     */
    constructor(f) {
      super(f), this.keyType = d.types.HD, this.name = null, this.account = -1, this.branch = -1, this.index = -1;
    }
    /**
     * Convert an WalletKey to a more json-friendly object.
     * @returns {Object}
     */
    toJSON(f) {
      return {
        name: this.name,
        account: this.account,
        branch: this.branch,
        index: this.index,
        publicKey: this.publicKey.toString("hex"),
        script: this.script ? this.script.toRaw().toString("hex") : null,
        type: e.typesByVal[this.getType()].toLowerCase(),
        address: this.getAddress("string", f)
      };
    }
    /**
     * Inject properties from hd key.
     * @private
     * @param {Account} account
     * @param {HDPrivateKey|HDPublicKey} key
     * @param {Number} branch
     * @param {Number} index
     * @returns {WalletKey}
     */
    fromHD(f, n, u, a) {
      return this.keyType = d.types.HD, this.name = f.name, this.account = f.accountIndex, this.branch = u, this.index = a, n.privateKey ? this.fromPrivate(n.privateKey) : this.fromPublic(n.publicKey);
    }
    /**
     * Instantiate a wallet key from hd key.
     * @param {Account} account
     * @param {HDPrivateKey|HDPublicKey} key
     * @param {Number} branch
     * @param {Number} index
     * @returns {WalletKey}
     */
    static fromHD(f, n, u, a) {
      return new this().fromHD(f, n, u, a);
    }
    /**
     * Inject properties from imported data.
     * @private
     * @param {Account} account
     * @param {Buffer} data
     * @returns {WalletKey}
     */
    fromImport(f, n) {
      return this.keyType = d.types.KEY, this.name = f.name, this.account = f.accountIndex, this.fromRaw(n);
    }
    /**
     * Instantiate a wallet key from imported data.
     * @param {Account} account
     * @param {Buffer} data
     * @returns {WalletKey}
     */
    static fromImport(f, n) {
      return new this().fromImport(f, n);
    }
    /**
     * Inject properties from key.
     * @private
     * @param {Account} account
     * @param {KeyRing} ring
     * @returns {WalletKey}
     */
    fromRing(f, n) {
      return this.keyType = d.types.KEY, this.name = f.name, this.account = f.accountIndex, this.fromOptions(n);
    }
    /**
     * Instantiate a wallet key from regular key.
     * @param {Account} account
     * @param {KeyRing} ring
     * @returns {WalletKey}
     */
    static fromRing(f, n) {
      return new this().fromRing(f, n);
    }
    /**
     * Convert wallet key to a path.
     * @returns {Path}
     */
    toPath() {
      const f = new d();
      switch (f.name = this.name, f.account = this.account, this.keyType) {
        case d.types.HD:
          f.branch = this.branch, f.index = this.index;
          break;
        case d.types.KEY:
          f.data = this.toRaw();
          break;
      }
      return f.keyType = this.keyType, f.version = this.getVersion(), f.type = this.getType(), f.hash = this.getHash(), f;
    }
    /**
     * Test whether an object is a WalletKey.
     * @param {Object} obj
     * @returns {Boolean}
     */
    static isWalletKey(f) {
      return f instanceof w;
    }
  }
  return Gu = w, Gu;
}
/*!
 * account.js - account object for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var Wu, y3;
function u7() {
  if (y3) return Wu;
  y3 = 1;
  const e = $e(), c = At(), d = so(), w = So(), g = Rl(), f = Pr(), n = c7(), { HDPublicKey: u } = wl(), { inspectSymbol: a } = Kt();
  class s {
    /**
     * Create an account.
     * @constructor
     * @param {Object} options
     */
    constructor(v, b) {
      e(v, "Database is required."), this.wdb = v, this.network = v.network, this.wid = 0, this.id = null, this.accountIndex = 0, this.name = null, this.initialized = !1, this.watchOnly = !1, this.type = s.types.PUBKEYHASH, this.m = 1, this.n = 1, this.receiveDepth = 0, this.changeDepth = 0, this.lookahead = 10, this.accountKey = null, this.keys = [], b && this.fromOptions(b);
    }
    /**
     * Inject properties from options object.
     * @private
     * @param {Object} options
     */
    fromOptions(v) {
      if (e(v, "Options are required."), e(v.wid >>> 0 === v.wid), e(g.isName(v.id), "Bad Wallet ID."), e(
        u.isHDPublicKey(v.accountKey),
        "Account key is required."
      ), e(
        v.accountIndex >>> 0 === v.accountIndex,
        "Account index is required."
      ), this.wid = v.wid, this.id = v.id, v.accountIndex != null && (e(v.accountIndex >>> 0 === v.accountIndex), this.accountIndex = v.accountIndex), v.name != null && (e(g.isName(v.name), "Bad account name."), this.name = v.name), v.initialized != null && (e(typeof v.initialized == "boolean"), this.initialized = v.initialized), v.watchOnly != null && (e(typeof v.watchOnly == "boolean"), this.watchOnly = v.watchOnly), v.type != null && (typeof v.type == "string" ? (this.type = s.types[v.type.toUpperCase()], e(this.type != null)) : (e(typeof v.type == "number"), this.type = v.type, e(s.typesByVal[this.type]))), v.m != null && (e((v.m & 255) === v.m), this.m = v.m), v.n != null && (e((v.n & 255) === v.n), this.n = v.n), v.receiveDepth != null && (e(v.receiveDepth >>> 0 === v.receiveDepth), this.receiveDepth = v.receiveDepth), v.changeDepth != null && (e(v.changeDepth >>> 0 === v.changeDepth), this.changeDepth = v.changeDepth), v.lookahead != null && (e(v.lookahead >>> 0 === v.lookahead), e(v.lookahead >= 0), e(v.lookahead <= s.MAX_LOOKAHEAD), this.lookahead = v.lookahead), this.accountKey = v.accountKey, this.n > 1 && (this.type = s.types.MULTISIG), this.name || (this.name = this.accountIndex.toString(10)), this.m < 1 || this.m > this.n)
        throw new Error("m ranges between 1 and n");
      if (v.keys) {
        e(Array.isArray(v.keys));
        for (const b of v.keys)
          this.pushKey(b);
      }
      return this;
    }
    /**
     * Instantiate account from options.
     * @param {WalletDB} wdb
     * @param {Object} options
     * @returns {Account}
     */
    static fromOptions(v, b) {
      return new this(v).fromOptions(b);
    }
    /**
     * Attempt to intialize the account (generating
     * the first addresses along with the lookahead
     * addresses). Called automatically from the
     * walletdb.
     * @returns {Promise}
     */
    async init(v) {
      if (this.keys.length !== this.n - 1) {
        e(!this.initialized), this.save(v);
        return;
      }
      e(this.receiveDepth === 0), e(this.changeDepth === 0), this.initialized = !0, await this.initDepth(v);
    }
    /**
     * Add a public account key to the account (multisig).
     * Does not update the database.
     * @param {HDPublicKey} key - Account (bip44)
     * key (can be in base58 form).
     * @throws Error on non-hdkey/non-accountkey.
     */
    pushKey(v) {
      if (typeof v == "string" && (v = u.fromBase58(v, this.network)), !u.isHDPublicKey(v))
        throw new Error("Must add HD keys to wallet.");
      if (!v.isAccount())
        throw new Error("Must add HD account keys to BIP44 wallet.");
      if (this.type !== s.types.MULTISIG)
        throw new Error("Cannot add keys to non-multisig wallet.");
      if (v.equals(this.accountKey))
        throw new Error("Cannot add own key.");
      if (d.insert(this.keys, v, i, !0) === -1)
        return !1;
      if (this.keys.length > this.n - 1)
        throw d.remove(this.keys, v, i), new Error("Cannot add more keys.");
      return !0;
    }
    /**
     * Remove a public account key to the account (multisig).
     * Does not update the database.
     * @param {HDPublicKey} key - Account (bip44)
     * key (can be in base58 form).
     * @throws Error on non-hdkey/non-accountkey.
     */
    spliceKey(v) {
      if (typeof v == "string" && (v = u.fromBase58(v, this.network)), !u.isHDPublicKey(v))
        throw new Error("Must add HD keys to wallet.");
      if (!v.isAccount())
        throw new Error("Must add HD account keys to BIP44 wallet.");
      if (this.type !== s.types.MULTISIG)
        throw new Error("Cannot remove keys from non-multisig wallet.");
      if (this.keys.length === this.n - 1)
        throw new Error("Cannot remove key.");
      return d.remove(this.keys, v, i);
    }
    /**
     * Add a public account key to the account (multisig).
     * Saves the key in the wallet database.
     * @param {HDPublicKey} key
     * @returns {Promise}
     */
    async addSharedKey(v, b) {
      const h = this.pushKey(b);
      if (await this.hasDuplicate())
        throw this.spliceKey(b), new Error("Cannot add a key from another account.");
      return await this.init(v), h;
    }
    /**
     * Ensure accounts are not sharing keys.
     * @private
     * @returns {Promise}
     */
    async hasDuplicate() {
      if (this.keys.length !== this.n - 1)
        return !1;
      const b = this.deriveReceive(0).getScriptHash();
      return this.wdb.hasPath(this.wid, b);
    }
    /**
     * Remove a public account key from the account (multisig).
     * Remove the key from the wallet database.
     * @param {HDPublicKey} key
     * @returns {Promise}
     */
    removeSharedKey(v, b) {
      return this.spliceKey(b) ? (this.save(v), !0) : !1;
    }
    /**
     * Create a new receiving address (increments receiveDepth).
     * @returns {Promise} - Returns {@link WalletKey}
     */
    createReceive(v) {
      return this.createKey(v, 0);
    }
    /**
     * Create a new change address (increments receiveDepth).
     * @returns {Promise} - Returns {@link WalletKey}
     */
    createChange(v) {
      return this.createKey(v, 1);
    }
    /**
     * Create a new address (increments depth).
     * @param {Boolean} change
     * @returns {Promise} - Returns {@link WalletKey}.
     */
    async createKey(v, b) {
      let h, o;
      switch (b) {
        case 0:
          h = this.deriveReceive(this.receiveDepth), o = this.deriveReceive(this.receiveDepth + this.lookahead), await this.saveKey(v, o), this.receiveDepth += 1, this.receive = h;
          break;
        case 1:
          h = this.deriveChange(this.changeDepth), o = this.deriveChange(this.changeDepth + this.lookahead), await this.saveKey(v, o), this.changeDepth += 1, this.change = h;
          break;
        default:
          throw new Error(`Bad branch: ${b}.`);
      }
      return this.save(v), h;
    }
    /**
     * Derive a receiving address at `index`. Do not increment depth.
     * @param {Number} index
     * @returns {WalletKey}
     */
    deriveReceive(v, b) {
      return this.deriveKey(0, v, b);
    }
    /**
     * Derive a change address at `index`. Do not increment depth.
     * @param {Number} index
     * @returns {WalletKey}
     */
    deriveChange(v, b) {
      return this.deriveKey(1, v, b);
    }
    /**
     * Derive an address from `path` object.
     * @param {Path} path
     * @param {MasterKey} master
     * @returns {WalletKey}
     */
    derivePath(v, b) {
      switch (v.keyType) {
        case w.types.HD:
          return this.deriveKey(v.branch, v.index, b);
        case w.types.KEY: {
          e(this.type === s.types.PUBKEYHASH);
          let h = v.data;
          return v.encrypted && (h = b.decipher(h, v.hash), !h) ? null : n.fromImport(this, h);
        }
        case w.types.ADDRESS:
          return null;
        default:
          throw new Error("Bad key type.");
      }
    }
    /**
     * Derive an address at `index`. Do not increment depth.
     * @param {Number} branch
     * @param {Number} index
     * @returns {WalletKey}
     */
    deriveKey(v, b, h) {
      e(typeof v == "number");
      const o = [];
      let S;
      if (h && h.key && !this.watchOnly) {
        const j = this.network.keyPrefix.coinType;
        S = h.key.deriveAccount(44, j, this.accountIndex), S = S.derive(v).derive(b);
      } else
        S = this.accountKey.derive(v).derive(b);
      const H = n.fromHD(this, S, v, b);
      switch (this.type) {
        case s.types.PUBKEYHASH:
          break;
        case s.types.MULTISIG:
          o.push(S.publicKey);
          for (const j of this.keys) {
            const J = j.derive(v).derive(b);
            o.push(J.publicKey);
          }
          H.script = f.fromMultisig(this.m, this.n, o);
          break;
      }
      return H;
    }
    /**
     * Save the account to the database. Necessary
     * when address depth and keys change.
     * @returns {Promise}
     */
    save(v) {
      return this.wdb.saveAccount(v, this);
    }
    /**
     * Save addresses to path map.
     * @param {WalletKey[]} rings
     * @returns {Promise}
     */
    saveKey(v, b) {
      return this.wdb.saveKey(v, this.wid, b);
    }
    /**
     * Save paths to path map.
     * @param {Path[]} rings
     * @returns {Promise}
     */
    savePath(v, b) {
      return this.wdb.savePath(v, this.wid, b);
    }
    /**
     * Initialize address depths (including lookahead).
     * @returns {Promise}
     */
    async initDepth(v) {
      this.receiveDepth = 1;
      for (let b = 0; b <= this.lookahead; b++) {
        const h = this.deriveReceive(b);
        await this.saveKey(v, h);
      }
      this.changeDepth = 1;
      for (let b = 0; b <= this.lookahead; b++) {
        const h = this.deriveChange(b);
        await this.saveKey(v, h);
      }
      this.save(v);
    }
    /**
     * Allocate new lookahead addresses if necessary.
     * @param {Number} receiveDepth
     * @param {Number} changeDepth
     * @returns {Promise} - Returns {@link WalletKey}.
     */
    async syncDepth(v, b, h) {
      let o = !1, S = null;
      if (b > this.receiveDepth) {
        const H = this.receiveDepth + this.lookahead;
        e(b <= H + 1);
        for (let j = H; j < b + this.lookahead; j++) {
          const J = this.deriveReceive(j);
          await this.saveKey(v, J), S = J;
        }
        this.receiveDepth = b, o = !0;
      }
      if (h > this.changeDepth) {
        const H = this.changeDepth + this.lookahead;
        e(h <= H + 1);
        for (let j = H; j < h + this.lookahead; j++) {
          const J = this.deriveChange(j);
          await this.saveKey(v, J);
        }
        this.changeDepth = h, o = !0;
      }
      return o && this.save(v), S;
    }
    /**
     * Allocate new lookahead addresses.
     * @param {Number} lookahead
     * @returns {Promise}
     */
    async setLookahead(v, b) {
      if (b !== this.lookahead) {
        if (b < this.lookahead) {
          const h = this.lookahead - b;
          this.receiveDepth += h, this.changeDepth += h, this.lookahead = b, this.save(v);
          return;
        }
        {
          const h = this.receiveDepth + this.lookahead, o = this.receiveDepth + b;
          for (let S = h; S < o; S++) {
            const H = this.deriveReceive(S);
            await this.saveKey(v, H);
          }
        }
        {
          const h = this.changeDepth + this.lookahead, o = this.changeDepth + b;
          for (let S = h; S < o; S++) {
            const H = this.deriveChange(S);
            await this.saveKey(v, H);
          }
        }
        this.lookahead = b, this.save(v);
      }
    }
    /**
     * Get current receive key.
     * @returns {WalletKey}
     */
    receiveKey() {
      return this.initialized ? this.deriveReceive(this.receiveDepth - 1) : null;
    }
    /**
     * Get current change key.
     * @returns {WalletKey}
     */
    changeKey() {
      return this.initialized ? this.deriveChange(this.changeDepth - 1) : null;
    }
    /**
     * Get current receive address.
     * @returns {Address}
     */
    receiveAddress() {
      const v = this.receiveKey();
      return v ? v.getAddress() : null;
    }
    /**
     * Get current change address.
     * @returns {Address}
     */
    changeAddress() {
      const v = this.changeKey();
      return v ? v.getAddress() : null;
    }
    /**
     * Convert the account to a more inspection-friendly object.
     * @returns {Object}
     */
    [a]() {
      const v = this.receiveAddress(), b = this.changeAddress();
      return {
        id: this.id,
        wid: this.wid,
        name: this.name,
        network: this.network.type,
        initialized: this.initialized,
        watchOnly: this.watchOnly,
        type: s.typesByVal[this.type].toLowerCase(),
        m: this.m,
        n: this.n,
        accountIndex: this.accountIndex,
        receiveDepth: this.receiveDepth,
        changeDepth: this.changeDepth,
        lookahead: this.lookahead,
        receiveAddress: v ? v.toString(this.network) : null,
        changeAddress: b ? b.toString(this.network) : null,
        accountKey: this.accountKey.toBase58(this.network),
        keys: this.keys.map((h) => h.toBase58(this.network))
      };
    }
    /**
     * Convert the account to an object suitable for
     * serialization.
     * @returns {Object}
     */
    toJSON(v) {
      const b = this.receiveAddress(), h = this.changeAddress();
      return {
        name: this.name,
        initialized: this.initialized,
        watchOnly: this.watchOnly,
        type: s.typesByVal[this.type].toLowerCase(),
        m: this.m,
        n: this.n,
        accountIndex: this.accountIndex,
        receiveDepth: this.receiveDepth,
        changeDepth: this.changeDepth,
        lookahead: this.lookahead,
        receiveAddress: b ? b.toString(this.network) : null,
        changeAddress: h ? h.toString(this.network) : null,
        accountKey: this.accountKey.toBase58(this.network),
        keys: this.keys.map((o) => o.toBase58(this.network)),
        balance: v ? v.toJSON(!0) : null
      };
    }
    /**
     * Calculate serialization size.
     * @returns {Number}
     */
    getSize() {
      let v = 0;
      return v += 88, v += this.keys.length * 74, v;
    }
    /**
     * Serialize the account.
     * @returns {Buffer}
     */
    toRaw() {
      const v = this.getSize(), b = c.write(v);
      let h = 0;
      this.initialized && (h |= 1), b.writeU8(h), b.writeU8(this.type), b.writeU8(this.m), b.writeU8(this.n), b.writeU32(this.receiveDepth), b.writeU32(this.changeDepth), b.writeU8(this.lookahead), p(this.accountKey, b), b.writeU8(this.keys.length);
      for (const o of this.keys)
        p(o, b);
      return b.render();
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     * @returns {Object}
     */
    fromRaw(v) {
      const b = c.read(v), h = b.readU8();
      this.initialized = (h & 1) !== 0, this.type = b.readU8(), this.m = b.readU8(), this.n = b.readU8(), this.receiveDepth = b.readU32(), this.changeDepth = b.readU32(), this.lookahead = b.readU8(), this.accountKey = m(b), e(this.type < s.typesByVal.length);
      const o = b.readU8();
      for (let S = 0; S < o; S++) {
        const H = m(b);
        d.insert(this.keys, H, i, !0);
      }
      return this;
    }
    /**
     * Instantiate a account from serialized data.
     * @param {WalletDB} data
     * @param {Buffer} data
     * @returns {Account}
     */
    static fromRaw(v, b) {
      return new this(v).fromRaw(b);
    }
    /**
     * Test an object to see if it is a Account.
     * @param {Object} obj
     * @returns {Boolean}
     */
    static isAccount(v) {
      return v instanceof s;
    }
  }
  s.types = {
    PUBKEYHASH: 0,
    MULTISIG: 1
  }, s.typesByVal = [
    "PUBKEYHASH",
    "MULTISIG"
  ], s.MAX_LOOKAHEAD = 40;
  function i(E, v) {
    return E.compare(v);
  }
  function p(E, v) {
    v.writeU8(E.depth), v.writeU32BE(E.parentFingerPrint), v.writeU32BE(E.childIndex), v.writeBytes(E.chainCode), v.writeBytes(E.publicKey);
  }
  function m(E) {
    const v = new u();
    return v.depth = E.readU8(), v.parentFingerPrint = E.readU32BE(), v.childIndex = E.readU32BE(), v.chainCode = E.readBytes(32), v.publicKey = E.readBytes(33), v;
  }
  return Wu = s, Wu;
}
var Cn = {}, v3;
function h7() {
  if (v3) return Cn;
  v3 = 1;
  const e = Mt(), c = xo(), d = wr(), w = k.alloc(64), g = new Uint32Array(16), f = new Uint32Array(16);
  function n(j, J, N, z, A, q) {
    if (typeof j == "string" && (j = k.from(j, "utf8")), typeof J == "string" && (J = k.from(J, "utf8")), J == null && (J = k.alloc(0)), e(k.isBuffer(j)), e(k.isBuffer(J)), e(N >>> 0 === N), e(z >>> 0 === z), e(A >>> 0 === A), e(q >>> 0 === q), z * A >= 1 << 30)
      throw new Error("EFBIG");
    if ((N & N - 1) !== 0 || N === 0)
      throw new Error("EINVAL");
    if (N > 4294967295)
      throw new Error("EINVAL");
    const _ = k.alloc(256 * z), F = k.alloc(128 * z * N), R = c.derive(d, j, J, 1, A * 128 * z);
    for (let V = 0; V < A; V++)
      m(R, V * 128 * z, z, N, F, _);
    return o(), c.derive(d, j, R, 1, q);
  }
  async function u(j, J, N, z, A, q) {
    if (typeof j == "string" && (j = k.from(j, "utf8")), typeof J == "string" && (J = k.from(J, "utf8")), J == null && (J = k.alloc(0)), e(k.isBuffer(j)), e(k.isBuffer(J)), e(N >>> 0 === N), e(z >>> 0 === z), e(A >>> 0 === A), e(q >>> 0 === q), z * A >= 1 << 30)
      throw new Error("EFBIG");
    if ((N & N - 1) !== 0 || N === 0)
      throw new Error("EINVAL");
    if (N > 4294967295)
      throw new Error("EINVAL");
    const _ = k.alloc(256 * z), F = k.alloc(128 * z * N), R = await c.deriveAsync(d, j, J, 1, A * 128 * z);
    for (let V = 0; V < A; V++)
      await E(R, V * 128 * z, z, N, F, _);
    return o(), c.deriveAsync(d, j, R, 1, q);
  }
  function a(j) {
    const J = g, N = f;
    for (let z = 0; z < 16; z++)
      J[z] = S(j, z * 4);
    for (let z = 0; z < 16; z++)
      N[z] = J[z];
    for (let z = 0; z < 8; z += 2)
      N[4] ^= s(N[0] + N[12], 7), N[8] ^= s(N[4] + N[0], 9), N[12] ^= s(N[8] + N[4], 13), N[0] ^= s(N[12] + N[8], 18), N[9] ^= s(N[5] + N[1], 7), N[13] ^= s(N[9] + N[5], 9), N[1] ^= s(N[13] + N[9], 13), N[5] ^= s(N[1] + N[13], 18), N[14] ^= s(N[10] + N[6], 7), N[2] ^= s(N[14] + N[10], 9), N[6] ^= s(N[2] + N[14], 13), N[10] ^= s(N[6] + N[2], 18), N[3] ^= s(N[15] + N[11], 7), N[7] ^= s(N[3] + N[15], 9), N[11] ^= s(N[7] + N[3], 13), N[15] ^= s(N[11] + N[7], 18), N[1] ^= s(N[0] + N[3], 7), N[2] ^= s(N[1] + N[0], 9), N[3] ^= s(N[2] + N[1], 13), N[0] ^= s(N[3] + N[2], 18), N[6] ^= s(N[5] + N[4], 7), N[7] ^= s(N[6] + N[5], 9), N[4] ^= s(N[7] + N[6], 13), N[5] ^= s(N[4] + N[7], 18), N[11] ^= s(N[10] + N[9], 7), N[8] ^= s(N[11] + N[10], 9), N[9] ^= s(N[8] + N[11], 13), N[10] ^= s(N[9] + N[8], 18), N[12] ^= s(N[15] + N[14], 7), N[13] ^= s(N[12] + N[15], 9), N[14] ^= s(N[13] + N[12], 13), N[15] ^= s(N[14] + N[13], 18);
    for (let z = 0; z < 16; z++)
      J[z] += N[z];
    for (let z = 0; z < 16; z++)
      H(j, J[z], 4 * z);
  }
  function s(j, J) {
    return j << J | j >>> 32 - J;
  }
  function i(j, J, N, z) {
    const A = w;
    v(A, j, 0, (2 * z - 1) * 64, 64);
    for (let q = 0; q < 2 * z; q++)
      b(A, j, 0, q * 64, 64), a(A), v(J, A, N + q * 64, 0, 64);
    for (let q = 0; q < z; q++)
      v(j, J, q * 64, N + q * 2 * 64, 64);
    for (let q = 0; q < z; q++)
      v(j, J, (q + z) * 64, N + (q * 2 + 1) * 64, 64);
  }
  function p(j, J) {
    return S(j, (2 * J - 1) * 64);
  }
  function m(j, J, N, z, A, q) {
    const _ = q, F = q;
    v(_, j, 0, J, 128 * N);
    for (let R = 0; R < z; R++)
      v(A, _, R * (128 * N), 0, 128 * N), i(_, F, 128 * N, N);
    for (let R = 0; R < z; R++) {
      const V = p(_, N) & z - 1;
      b(_, A, 0, V * (128 * N), 128 * N), i(_, F, 128 * N, N);
    }
    v(j, _, J, 0, 128 * N);
  }
  async function E(j, J, N, z, A, q) {
    const _ = q, F = q;
    v(_, j, 0, J, 128 * N);
    for (let R = 0; R < z; R++)
      v(A, _, R * (128 * N), 0, 128 * N), i(_, F, 128 * N, N), await h();
    for (let R = 0; R < z; R++) {
      const V = p(_, N) & z - 1;
      b(_, A, 0, V * (128 * N), 128 * N), i(_, F, 128 * N, N), await h();
    }
    v(j, _, J, 0, 128 * N);
  }
  function v(j, J, N, z, A) {
    J.copy(j, N, z, z + A);
  }
  function b(j, J, N, z, A) {
    for (let q = 0; q < A; q++)
      j[N + q] ^= J[z + q];
  }
  function h() {
    return new Promise((j) => setImmediate(j));
  }
  function o() {
    for (let j = 0; j < 64; j++)
      w[j] = 0;
    for (let j = 0; j < 16; j++)
      g[j] = 0, f[j] = 0;
  }
  function S(j, J) {
    return j[J++] + j[J++] * 256 + j[J++] * 65536 + j[J] * 16777216;
  }
  function H(j, J, N) {
    return j[N++] = J, J >>>= 8, j[N++] = J, J >>>= 8, j[N++] = J, J >>>= 8, j[N++] = J, N;
  }
  return Cn.native = 0, Cn.derive = n, Cn.deriveAsync = u, Cn;
}
var Zu, S3;
function Ux() {
  if (S3) return Zu;
  S3 = 1;
  const e = $e(), c = At(), { Lock: d } = Al(), w = pi(), g = mn(), f = _l(), n = wr(), u = hr(), a = Rr(), s = xo(), i = h7(), p = Zt(), m = xl(), E = wo(), { encoding: v } = c, { inspectSymbol: b } = Kt();
  class h {
    /**
     * Create a master key.
     * @constructor
     * @param {Object} options
     */
    constructor(H) {
      this.encrypted = !1, this.iv = null, this.ciphertext = null, this.key = null, this.mnemonic = null, this.alg = h.alg.PBKDF2, this.n = 5e4, this.r = 0, this.p = 0, this.aesKey = null, this.timer = null, this.until = 0, this.locker = new d(), H && this.fromOptions(H);
    }
    /**
     * Inject properties from options object.
     * @private
     * @param {Object} options
     */
    fromOptions(H) {
      return e(H), H.encrypted != null && (e(typeof H.encrypted == "boolean"), this.encrypted = H.encrypted), H.iv && (e(k.isBuffer(H.iv)), this.iv = H.iv), H.ciphertext && (e(k.isBuffer(H.ciphertext)), this.ciphertext = H.ciphertext), H.key && (e(m.isHDPrivateKey(H.key)), this.key = H.key), H.mnemonic && (e(H.mnemonic instanceof E), this.mnemonic = H.mnemonic), H.alg != null && (typeof H.alg == "string" ? (this.alg = h.alg[H.alg.toUpperCase()], e(this.alg != null, "Unknown algorithm.")) : (e(typeof H.alg == "number"), e(h.algByVal[H.alg]), this.alg = H.alg)), H.rounds != null && (e(H.rounds >>> 0 === H.rounds), this.rounds = H.rounds), H.n != null && (e(H.n >>> 0 === H.n), this.n = H.n), H.r != null && (e(H.r >>> 0 === H.r), this.r = H.r), H.p != null && (e(H.p >>> 0 === H.p), this.p = H.p), e(this.encrypted ? !this.key : this.key), this;
    }
    /**
     * Instantiate master key from options.
     * @returns {MasterKey}
     */
    static fromOptions(H) {
      return new this().fromOptions(H);
    }
    /**
     * Decrypt the key and set a timeout to destroy decrypted data.
     * @param {Buffer|String} passphrase - Zero this yourself.
     * @param {Number} [timeout=60000] timeout in ms.
     * @returns {Promise} - Returns {@link HDPrivateKey}.
     */
    async unlock(H, j) {
      const J = await this.locker.lock();
      try {
        return await this._unlock(H, j);
      } finally {
        J();
      }
    }
    /**
     * Decrypt the key without a lock.
     * @private
     * @param {Buffer|String} passphrase - Zero this yourself.
     * @param {Number} [timeout=60000] timeout in ms.
     * @returns {Promise} - Returns {@link HDPrivateKey}.
     */
    async _unlock(H, j) {
      if (this.key)
        return this.encrypted && (e(this.timer != null), this.start(j)), this.key;
      if (!H)
        throw new Error("No passphrase.");
      e(this.encrypted);
      const J = await this.derive(H), N = f.decipher(this.ciphertext, J, this.iv);
      return this.readKey(N), this.start(j), this.aesKey = J, this.key;
    }
    /**
     * Start the destroy timer.
     * @private
     * @param {Number} [timeout=60] timeout in seconds.
     */
    start(H) {
      H || (H = 60), this.stop(), H !== -1 && (e(H >>> 0 === H), this.until = p.now() + H, this.timer = setTimeout(() => this.lock(), H * 1e3));
    }
    /**
     * Stop the destroy timer.
     * @private
     */
    stop() {
      this.timer != null && (clearTimeout(this.timer), this.timer = null, this.until = 0);
    }
    /**
     * Derive an aes key based on params.
     * @param {String|Buffer} passphrase
     * @returns {Promise}
     */
    async derive(H) {
      const j = h.SALT, J = this.n, N = this.r, z = this.p;
      switch (typeof H == "string" && (H = k.from(H, "utf8")), this.alg) {
        case h.alg.PBKDF2:
          return s.deriveAsync(n, H, j, J, 32);
        case h.alg.SCRYPT:
          return i.deriveAsync(H, j, J, N, z, 32);
        default:
          throw new Error(`Unknown algorithm: ${this.alg}.`);
      }
    }
    /**
     * Encrypt data with in-memory aes key.
     * @param {Buffer} data
     * @param {Buffer} iv
     * @returns {Buffer}
     */
    encipher(H, j) {
      return this.aesKey ? f.encipher(H, this.aesKey, j.slice(0, 16)) : null;
    }
    /**
     * Decrypt data with in-memory aes key.
     * @param {Buffer} data
     * @param {Buffer} iv
     * @returns {Buffer}
     */
    decipher(H, j) {
      return this.aesKey ? f.decipher(H, this.aesKey, j.slice(0, 16)) : null;
    }
    /**
     * Destroy the key by zeroing the
     * privateKey and chainCode. Stop
     * the timer if there is one.
     * @returns {Promise}
     */
    async lock() {
      const H = await this.locker.lock();
      try {
        return await this._lock();
      } finally {
        H();
      }
    }
    /**
     * Destroy the key by zeroing the
     * privateKey and chainCode. Stop
     * the timer if there is one.
     */
    _lock() {
      if (!this.encrypted) {
        e(this.timer == null), e(this.key);
        return;
      }
      this.stop(), this.key && (this.key.destroy(!0), this.key = null), this.aesKey && (g(this.aesKey), this.aesKey = null);
    }
    /**
     * Destroy the key permanently.
     */
    async destroy() {
      await this.lock(), this.locker.destroy();
    }
    /**
     * Decrypt the key permanently.
     * @param {Buffer|String} passphrase - Zero this yourself.
     * @returns {Promise}
     */
    async decrypt(H, j) {
      const J = await this.locker.lock();
      try {
        return await this._decrypt(H, j);
      } finally {
        J();
      }
    }
    /**
     * Decrypt the key permanently without a lock.
     * @private
     * @param {Buffer|String} passphrase - Zero this yourself.
     * @returns {Promise}
     */
    async _decrypt(H, j) {
      if (!this.encrypted)
        throw new Error("Master key is not encrypted.");
      if (!H)
        throw new Error("No passphrase provided.");
      this._lock();
      const J = await this.derive(H), N = f.decipher(this.ciphertext, J, this.iv);
      return this.readKey(N), this.encrypted = !1, this.iv = null, this.ciphertext = null, j ? J : (g(J), null);
    }
    /**
     * Encrypt the key permanently.
     * @param {Buffer|String} passphrase - Zero this yourself.
     * @returns {Promise}
     */
    async encrypt(H, j) {
      const J = await this.locker.lock();
      try {
        return await this._encrypt(H, j);
      } finally {
        J();
      }
    }
    /**
     * Encrypt the key permanently without a lock.
     * @private
     * @param {Buffer|String} passphrase - Zero this yourself.
     * @returns {Promise}
     */
    async _encrypt(H, j) {
      if (this.encrypted)
        throw new Error("Master key is already encrypted.");
      if (!H)
        throw new Error("No passphrase provided.");
      const J = this.writeKey(), N = w.randomBytes(16);
      this.stop();
      const z = await this.derive(H), A = f.encipher(J, z, N);
      return this.key = null, this.mnemonic = null, this.encrypted = !0, this.iv = N, this.ciphertext = A, j ? z : (g(z), null);
    }
    /**
     * Calculate key serialization size.
     * @returns {Number}
     */
    keySize() {
      let H = 0;
      return H += 64, H += 1, this.mnemonic && (H += this.mnemonic.getSize()), H;
    }
    /**
     * Serialize key and menmonic to a single buffer.
     * @returns {Buffer}
     */
    writeKey() {
      const H = c.write(this.keySize());
      return H.writeBytes(this.key.chainCode), H.writeBytes(this.key.privateKey), this.mnemonic ? (H.writeU8(1), this.mnemonic.toWriter(H)) : H.writeU8(0), H.render();
    }
    /**
     * Inject properties from serialized key.
     * @param {Buffer} data
     */
    readKey(H) {
      const j = c.read(H);
      return this.key = new m(), o(H) ? (j.seek(13), this.key.chainCode = j.readBytes(32), e(j.readU8() === 0), this.key.privateKey = j.readBytes(32)) : (this.key.chainCode = j.readBytes(32), this.key.privateKey = j.readBytes(32)), this.key.publicKey = a.publicKeyCreate(this.key.privateKey, !0), j.readU8() === 1 && (this.mnemonic = E.fromReader(j)), this;
    }
    /**
     * Calculate serialization size.
     * @returns {Number}
     */
    getSize() {
      let H = 0;
      return this.encrypted ? (H += 1, H += v.sizeVarBytes(this.iv), H += v.sizeVarBytes(this.ciphertext), H += 13, H) : (H += 1, H += this.keySize(), H);
    }
    /**
     * Serialize the key in the form of:
     * `[enc-flag][iv?][ciphertext?][extended-key?]`
     * @returns {Buffer}
     */
    toWriter(H) {
      return this.encrypted ? (H.writeU8(1), H.writeVarBytes(this.iv), H.writeVarBytes(this.ciphertext), H.writeU8(this.alg), H.writeU32(this.n), H.writeU32(this.r), H.writeU32(this.p), H) : (H.writeU8(0), H.writeBytes(this.key.chainCode), H.writeBytes(this.key.privateKey), this.mnemonic ? (H.writeU8(1), this.mnemonic.toWriter(H)) : H.writeU8(0), H);
    }
    /**
     * Serialize the key in the form of:
     * `[enc-flag][iv?][ciphertext?][extended-key?]`
     * @returns {Buffer}
     */
    toRaw() {
      const H = this.getSize();
      return this.toWriter(c.write(H)).render();
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} raw
     */
    fromReader(H) {
      return this.encrypted = H.readU8() === 1, this.encrypted ? (this.iv = H.readVarBytes(), this.ciphertext = H.readVarBytes(), this.alg = H.readU8(), e(this.alg < h.algByVal.length), this.n = H.readU32(), this.r = H.readU32(), this.p = H.readU32(), this) : (this.key = new m(), this.key.chainCode = H.readBytes(32), this.key.privateKey = H.readBytes(32), this.key.publicKey = a.publicKeyCreate(this.key.privateKey, !0), H.readU8() === 1 && (this.mnemonic = E.fromReader(H)), this);
    }
    /**
     * Instantiate master key from serialized data.
     * @returns {MasterKey}
     */
    static fromReader(H) {
      return new this().fromReader(H);
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} raw
     */
    fromRaw(H) {
      return this.fromReader(c.read(H));
    }
    /**
     * Instantiate master key from serialized data.
     * @returns {MasterKey}
     */
    static fromRaw(H) {
      return new this().fromRaw(H);
    }
    /**
     * Inject properties from an HDPrivateKey.
     * @private
     * @param {HDPrivateKey} key
     * @param {Mnemonic?} mnemonic
     */
    fromKey(H, j) {
      return this.encrypted = !1, this.iv = null, this.ciphertext = null, this.key = H, this.mnemonic = j || null, this;
    }
    /**
     * Instantiate master key from an HDPrivateKey.
     * @param {HDPrivateKey} key
     * @param {Mnemonic?} mnemonic
     * @returns {MasterKey}
     */
    static fromKey(H, j) {
      return new this().fromKey(H, j);
    }
    /**
     * Convert master key to a jsonifiable object.
     * @param {Network?} network
     * @param {Boolean?} unsafe - Whether to include
     * the key data in the JSON.
     * @returns {Object}
     */
    toJSON(H, j) {
      return this.encrypted ? {
        encrypted: !0,
        until: this.until,
        iv: this.iv.toString("hex"),
        ciphertext: j ? this.ciphertext.toString("hex") : void 0,
        algorithm: h.algByVal[this.alg].toLowerCase(),
        n: this.n,
        r: this.r,
        p: this.p
      } : {
        encrypted: !1,
        key: j ? this.key.toJSON(H) : void 0,
        mnemonic: j && this.mnemonic ? this.mnemonic.toJSON() : void 0
      };
    }
    /**
     * Inspect the key.
     * @returns {Object}
     */
    [b]() {
      const H = this.toJSON(null, !0);
      return this.key && (H.key = this.key.toJSON()), this.mnemonic && (H.mnemonic = this.mnemonic.toJSON()), H;
    }
    /**
     * Test whether an object is a MasterKey.
     * @param {Object} obj
     * @returns {Boolean}
     */
    static isMasterKey(H) {
      return H instanceof h;
    }
  }
  h.SALT = k.from("bcoin", "ascii"), h.alg = {
    PBKDF2: 0,
    SCRYPT: 1
  }, h.algByVal = [
    "PBKDF2",
    "SCRYPT"
  ];
  function o(S) {
    if (S.length < 82)
      return !1;
    const H = S.slice(0, 78), j = S.readUInt32LE(78, !0);
    return u.digest(H).readUInt32LE(0, !0) === j;
  }
  return Zu = h, Zu;
}
var Qu, E3;
function Fx() {
  if (E3) return Qu;
  E3 = 1;
  const e = $e(), c = co(), { Lock: d } = Al(), { base58: w } = cn(), g = At(), f = Hi(), n = hr(), u = mn(), a = Dx(), s = So(), i = Rl(), p = Lr(), m = El(), E = Pr(), v = c7(), b = wl(), h = gi(), o = u7(), S = Ux(), H = mi(), j = Ht(), { encoding: J } = g, { Mnemonic: N } = b, { inspectSymbol: z } = Kt();
  class A extends c {
    /**
     * Create a wallet.
     * @constructor
     * @param {Object} options
     */
    constructor(_, F) {
      super(), e(_, "WDB required."), this.wdb = _, this.db = _.db, this.network = _.network, this.logger = _.logger, this.writeLock = new d(), this.fundLock = new d(), this.wid = 0, this.id = null, this.watchOnly = !1, this.accountDepth = 0, this.token = j.ZERO_HASH, this.tokenDepth = 0, this.master = new S(), this.txdb = new a(this.wdb), F && this.fromOptions(F);
    }
    /**
     * Inject properties from options object.
     * @private
     * @param {Object} options
     */
    fromOptions(_) {
      if (!_)
        return this;
      let F = _.master, R, V, fe;
      return F ? (typeof F == "string" && (F = b.PrivateKey.fromBase58(F, this.network)), e(
        b.isPrivate(F),
        "Must create wallet with hd private key."
      )) : (fe = new N(_.mnemonic), F = b.fromMnemonic(fe, _.password)), this.master.fromKey(F, fe), _.wid != null && (e(_.wid >>> 0 === _.wid), this.wid = _.wid), _.id && (e(i.isName(_.id), "Bad wallet ID."), R = _.id), _.watchOnly != null && (e(typeof _.watchOnly == "boolean"), this.watchOnly = _.watchOnly), _.accountDepth != null && (e(_.accountDepth >>> 0 === _.accountDepth), this.accountDepth = _.accountDepth), _.token && (e(k.isBuffer(_.token)), e(_.token.length === 32), V = _.token), _.tokenDepth != null && (e(_.tokenDepth >>> 0 === _.tokenDepth), this.tokenDepth = _.tokenDepth), R || (R = this.getID()), V || (V = this.getToken(this.tokenDepth)), this.id = R, this.token = V, this;
    }
    /**
     * Instantiate wallet from options.
     * @param {WalletDB} wdb
     * @param {Object} options
     * @returns {Wallet}
     */
    static fromOptions(_, F) {
      return new this(_).fromOptions(F);
    }
    /**
     * Attempt to intialize the wallet (generating
     * the first addresses along with the lookahead
     * addresses). Called automatically from the
     * walletdb.
     * @returns {Promise}
     */
    async init(_, F) {
      F && await this.master.encrypt(F);
      const R = await this._createAccount(_, F);
      return e(R), this.logger.info("Wallet initialized (%s).", this.id), this.txdb.open(this);
    }
    /**
     * Open wallet (done after retrieval).
     * @returns {Promise}
     */
    async open() {
      if (!await this.getAccount(0))
        throw new Error("Default account not found.");
      return this.logger.info("Wallet opened (%s).", this.id), this.txdb.open(this);
    }
    /**
     * Close the wallet, unregister with the database.
     * @returns {Promise}
     */
    async destroy() {
      const _ = await this.writeLock.lock(), F = await this.fundLock.lock();
      try {
        await this.master.destroy(), this.writeLock.destroy(), this.fundLock.destroy();
      } finally {
        F(), _();
      }
    }
    /**
     * Add a public account key to the wallet (multisig).
     * Saves the key in the wallet database.
     * @param {(Number|String)} acct
     * @param {HDPublicKey} key
     * @returns {Promise}
     */
    async addSharedKey(_, F) {
      const R = await this.writeLock.lock();
      try {
        return await this._addSharedKey(_, F);
      } finally {
        R();
      }
    }
    /**
     * Add a public account key to the wallet without a lock.
     * @private
     * @param {(Number|String)} acct
     * @param {HDPublicKey} key
     * @returns {Promise}
     */
    async _addSharedKey(_, F) {
      const R = await this.getAccount(_);
      if (!R)
        throw new Error("Account not found.");
      const V = this.db.batch(), fe = await R.addSharedKey(V, F);
      return await V.write(), fe;
    }
    /**
     * Remove a public account key from the wallet (multisig).
     * @param {(Number|String)} acct
     * @param {HDPublicKey} key
     * @returns {Promise}
     */
    async removeSharedKey(_, F) {
      const R = await this.writeLock.lock();
      try {
        return await this._removeSharedKey(_, F);
      } finally {
        R();
      }
    }
    /**
     * Remove a public account key from the wallet (multisig).
     * @private
     * @param {(Number|String)} acct
     * @param {HDPublicKey} key
     * @returns {Promise}
     */
    async _removeSharedKey(_, F) {
      const R = await this.getAccount(_);
      if (!R)
        throw new Error("Account not found.");
      const V = this.db.batch(), fe = await R.removeSharedKey(V, F);
      return await V.write(), fe;
    }
    /**
     * Change or set master key's passphrase.
     * @param {String|Buffer} passphrase
     * @param {String|Buffer} old
     * @returns {Promise}
     */
    async setPassphrase(_, F) {
      F != null && await this.decrypt(F), await this.encrypt(_);
    }
    /**
     * Encrypt the wallet permanently.
     * @param {String|Buffer} passphrase
     * @returns {Promise}
     */
    async encrypt(_) {
      const F = await this.writeLock.lock();
      try {
        return await this._encrypt(_);
      } finally {
        F();
      }
    }
    /**
     * Encrypt the wallet permanently, without a lock.
     * @private
     * @param {String|Buffer} passphrase
     * @returns {Promise}
     */
    async _encrypt(_) {
      const F = await this.master.encrypt(_, !0), R = this.db.batch();
      try {
        await this.wdb.encryptKeys(R, this.wid, F);
      } finally {
        u(F);
      }
      this.save(R), await R.write();
    }
    /**
     * Decrypt the wallet permanently.
     * @param {String|Buffer} passphrase
     * @returns {Promise}
     */
    async decrypt(_) {
      const F = await this.writeLock.lock();
      try {
        return await this._decrypt(_);
      } finally {
        F();
      }
    }
    /**
     * Decrypt the wallet permanently, without a lock.
     * @private
     * @param {String|Buffer} passphrase
     * @returns {Promise}
     */
    async _decrypt(_) {
      const F = await this.master.decrypt(_, !0), R = this.db.batch();
      try {
        await this.wdb.decryptKeys(R, this.wid, F);
      } finally {
        u(F);
      }
      this.save(R), await R.write();
    }
    /**
     * Generate a new token.
     * @param {(String|Buffer)?} passphrase
     * @returns {Promise}
     */
    async retoken(_) {
      const F = await this.writeLock.lock();
      try {
        return await this._retoken(_);
      } finally {
        F();
      }
    }
    /**
     * Generate a new token without a lock.
     * @private
     * @param {(String|Buffer)?} passphrase
     * @returns {Promise}
     */
    async _retoken(_) {
      _ && await this.unlock(_), this.tokenDepth += 1, this.token = this.getToken(this.tokenDepth);
      const F = this.db.batch();
      return this.save(F), await F.write(), this.token;
    }
    /**
     * Rename the wallet.
     * @param {String} id
     * @returns {Promise}
     */
    async rename(_) {
      const F = await this.writeLock.lock();
      try {
        return await this.wdb.rename(this, _);
      } finally {
        F();
      }
    }
    /**
     * Rename account.
     * @param {(String|Number)?} acct
     * @param {String} name
     * @returns {Promise}
     */
    async renameAccount(_, F) {
      const R = await this.writeLock.lock();
      try {
        return await this._renameAccount(_, F);
      } finally {
        R();
      }
    }
    /**
     * Rename account without a lock.
     * @private
     * @param {(String|Number)?} acct
     * @param {String} name
     * @returns {Promise}
     */
    async _renameAccount(_, F) {
      if (!i.isName(F))
        throw new Error("Bad account name.");
      const R = await this.getAccount(_);
      if (!R)
        throw new Error("Account not found.");
      if (R.accountIndex === 0)
        throw new Error("Cannot rename default account.");
      if (await this.hasAccount(F))
        throw new Error("Account name not available.");
      const V = this.db.batch();
      this.wdb.renameAccount(V, R, F), await V.write();
    }
    /**
     * Lock the wallet, destroy decrypted key.
     */
    async lock() {
      const _ = await this.writeLock.lock(), F = await this.fundLock.lock();
      try {
        await this.master.lock();
      } finally {
        F(), _();
      }
    }
    /**
     * Unlock the key for `timeout` seconds.
     * @param {Buffer|String} passphrase
     * @param {Number?} [timeout=60]
     */
    unlock(_, F) {
      return this.master.unlock(_, F);
    }
    /**
     * Generate the wallet ID if none was passed in.
     * It is represented as HASH160(m/44->public|magic)
     * converted to an "address" with a prefix
     * of `0x03be04` (`WLT` in base58).
     * @private
     * @returns {Base58String}
     */
    getID() {
      e(this.master.key, "Cannot derive id.");
      const _ = this.master.key.derive(44), F = g.write(37);
      F.writeBytes(_.publicKey), F.writeU32(this.network.magic);
      const R = f.digest(F.render()), V = g.write(27);
      return V.writeU8(3), V.writeU8(190), V.writeU8(4), V.writeBytes(R), V.writeChecksum(n.digest), w.encode(V.render());
    }
    /**
     * Generate the wallet api key if none was passed in.
     * It is represented as HASH256(m/44'->private|nonce).
     * @private
     * @param {HDPrivateKey} master
     * @param {Number} nonce
     * @returns {Buffer}
     */
    getToken(_) {
      if (!this.master.key)
        throw new Error("Cannot derive token.");
      const F = this.master.key.derive(44, !0), R = g.write(36);
      return R.writeBytes(F.privateKey), R.writeU32(_), n.digest(R.render());
    }
    /**
     * Create an account. Requires passphrase if master key is encrypted.
     * @param {Object} options - See {@link Account} options.
     * @returns {Promise} - Returns {@link Account}.
     */
    async createAccount(_, F) {
      const R = await this.writeLock.lock();
      try {
        return await this._createAccount(_, F);
      } finally {
        R();
      }
    }
    /**
     * Create an account without a lock.
     * @param {Object} options - See {@link Account} options.
     * @returns {Promise} - Returns {@link Account}.
     */
    async _createAccount(_, F) {
      let R = _.name;
      if (R || (R = this.accountDepth.toString(10)), await this.hasAccount(R))
        throw new Error("Account already exists.");
      await this.unlock(F);
      let V;
      if (this.watchOnly) {
        if (V = _.accountKey, typeof V == "string" && (V = b.PublicKey.fromBase58(V, this.network)), !b.isPublic(V))
          throw new Error("Must add HD public keys to watch only wallet.");
      } else {
        e(this.master.key);
        const D = this.network.keyPrefix.coinType;
        V = this.master.key.deriveAccount(44, D, this.accountDepth), V = V.toPublic();
      }
      const fe = {
        wid: this.wid,
        id: this.id,
        name: this.accountDepth === 0 ? "default" : R,
        watchOnly: this.watchOnly,
        accountKey: V,
        accountIndex: this.accountDepth,
        type: _.type,
        m: _.m,
        n: _.n,
        keys: _.keys
      }, ue = this.db.batch(), ae = o.fromOptions(this.wdb, fe);
      return await ae.init(ue), this.logger.info(
        "Created account %s/%s/%d.",
        ae.id,
        ae.name,
        ae.accountIndex
      ), this.accountDepth += 1, this.save(ue), this.accountDepth === 1 && this.increment(ue), await ue.write(), ae;
    }
    /**
     * Ensure an account. Requires passphrase if master key is encrypted.
     * @param {Object} options - See {@link Account} options.
     * @returns {Promise} - Returns {@link Account}.
     */
    async ensureAccount(_, F) {
      const R = _.name, V = await this.getAccount(R);
      return V || this.createAccount(_, F);
    }
    /**
     * List account names and indexes from the db.
     * @returns {Promise} - Returns Array.
     */
    getAccounts() {
      return this.wdb.getAccounts(this.wid);
    }
    /**
     * Get all wallet address hashes.
     * @param {(String|Number)?} acct
     * @returns {Promise} - Returns Array.
     */
    getAddressHashes(_) {
      return _ != null ? this.getAccountHashes(_) : this.wdb.getWalletHashes(this.wid);
    }
    /**
     * Get all account address hashes.
     * @param {String|Number} acct
     * @returns {Promise} - Returns Array.
     */
    async getAccountHashes(_) {
      const F = await this.getAccountIndex(_);
      if (F === -1)
        throw new Error("Account not found.");
      return this.wdb.getAccountHashes(this.wid, F);
    }
    /**
     * Retrieve an account from the database.
     * @param {Number|String} acct
     * @returns {Promise} - Returns {@link Account}.
     */
    async getAccount(_) {
      const F = await this.getAccountIndex(_);
      if (F === -1)
        return null;
      const R = await this.wdb.getAccount(this.wid, F);
      return R ? (R.wid = this.wid, R.id = this.id, R.watchOnly = this.watchOnly, R) : null;
    }
    /**
     * Lookup the corresponding account name's index.
     * @param {String|Number} acct - Account name/index.
     * @returns {Promise} - Returns Number.
     */
    getAccountIndex(_) {
      return _ == null ? -1 : typeof _ == "number" ? _ : this.wdb.getAccountIndex(this.wid, _);
    }
    /**
     * Lookup the corresponding account name's index.
     * @param {String|Number} acct - Account name/index.
     * @returns {Promise} - Returns Number.
     * @throws on non-existent account
     */
    async ensureIndex(_) {
      if (_ == null || _ === -1)
        return -1;
      const F = await this.getAccountIndex(_);
      if (F === -1)
        throw new Error("Account not found.");
      return F;
    }
    /**
     * Lookup the corresponding account index's name.
     * @param {Number} index - Account index.
     * @returns {Promise} - Returns String.
     */
    async getAccountName(_) {
      return typeof _ == "string" ? _ : this.wdb.getAccountName(this.wid, _);
    }
    /**
     * Test whether an account exists.
     * @param {Number|String} acct
     * @returns {Promise} - Returns {@link Boolean}.
     */
    async hasAccount(_) {
      const F = await this.getAccountIndex(_);
      return F === -1 ? !1 : this.wdb.hasAccount(this.wid, F);
    }
    /**
     * Create a new receiving address (increments receiveDepth).
     * @param {(Number|String)?} acct
     * @returns {Promise} - Returns {@link WalletKey}.
     */
    createReceive(_ = 0) {
      return this.createKey(_, 0);
    }
    /**
     * Create a new change address (increments receiveDepth).
     * @param {(Number|String)?} acct
     * @returns {Promise} - Returns {@link WalletKey}.
     */
    createChange(_ = 0) {
      return this.createKey(_, 1);
    }
    /**
     * Create a new address (increments depth).
     * @param {(Number|String)?} acct
     * @param {Number} branch
     * @returns {Promise} - Returns {@link WalletKey}.
     */
    async createKey(_, F) {
      const R = await this.writeLock.lock();
      try {
        return await this._createKey(_, F);
      } finally {
        R();
      }
    }
    /**
     * Create a new address (increments depth) without a lock.
     * @private
     * @param {(Number|String)?} acct
     * @param {Number} branch
     * @returns {Promise} - Returns {@link WalletKey}.
     */
    async _createKey(_, F) {
      const R = await this.getAccount(_);
      if (!R)
        throw new Error("Account not found.");
      const V = this.db.batch(), fe = await R.createKey(V, F);
      return await V.write(), fe;
    }
    /**
     * Save the wallet to the database. Necessary
     * when address depth and keys change.
     * @returns {Promise}
     */
    save(_) {
      return this.wdb.save(_, this);
    }
    /**
     * Increment the wid depth.
     * @returns {Promise}
     */
    increment(_) {
      return this.wdb.increment(_, this.wid);
    }
    /**
     * Test whether the wallet possesses an address.
     * @param {Address|Hash} address
     * @returns {Promise} - Returns Boolean.
     */
    async hasAddress(_) {
      const F = p.getHash(_);
      return await this.getPath(F) != null;
    }
    /**
     * Get path by address hash.
     * @param {Address|Hash} address
     * @returns {Promise} - Returns {@link Path}.
     */
    async getPath(_) {
      const F = p.getHash(_);
      return this.wdb.getPath(this.wid, F);
    }
    /**
     * Get path by address hash (without account name).
     * @private
     * @param {Address|Hash} address
     * @returns {Promise} - Returns {@link Path}.
     */
    async readPath(_) {
      const F = p.getHash(_);
      return this.wdb.readPath(this.wid, F);
    }
    /**
     * Test whether the wallet contains a path.
     * @param {Address|Hash} address
     * @returns {Promise} - Returns {Boolean}.
     */
    async hasPath(_) {
      const F = p.getHash(_);
      return this.wdb.hasPath(this.wid, F);
    }
    /**
     * Get all wallet paths.
     * @param {(String|Number)?} acct
     * @returns {Promise} - Returns {@link Path}.
     */
    async getPaths(_) {
      return _ != null ? this.getAccountPaths(_) : this.wdb.getWalletPaths(this.wid);
    }
    /**
     * Get all account paths.
     * @param {String|Number} acct
     * @returns {Promise} - Returns {@link Path}.
     */
    async getAccountPaths(_) {
      const F = await this.getAccountIndex(_);
      if (F === -1)
        throw new Error("Account not found.");
      const R = await this.getAccountHashes(F), V = await this.getAccountName(_);
      e(V);
      const fe = [];
      for (const ue of R) {
        const ae = await this.readPath(ue);
        e(ae), e(ae.account === F), ae.name = V, fe.push(ae);
      }
      return fe;
    }
    /**
     * Import a keyring (will not exist on derivation chain).
     * Rescanning must be invoked manually.
     * @param {(String|Number)?} acct
     * @param {WalletKey} ring
     * @param {(String|Buffer)?} passphrase
     * @returns {Promise}
     */
    async importKey(_, F, R) {
      const V = await this.writeLock.lock();
      try {
        return await this._importKey(_, F, R);
      } finally {
        V();
      }
    }
    /**
     * Import a keyring (will not exist on derivation chain) without a lock.
     * @private
     * @param {(String|Number)?} acct
     * @param {WalletKey} ring
     * @param {(String|Buffer)?} passphrase
     * @returns {Promise}
     */
    async _importKey(_, F, R) {
      if (this.watchOnly) {
        if (F.privateKey)
          throw new Error("Cannot import privkey into watch-only wallet.");
      } else if (!F.privateKey)
        throw new Error("Cannot import pubkey into non watch-only wallet.");
      const V = F.getHash();
      if (await this.getPath(V))
        throw new Error("Key already exists.");
      const fe = await this.getAccount(_);
      if (!fe)
        throw new Error("Account not found.");
      if (fe.type !== o.types.PUBKEYHASH)
        throw new Error("Cannot import into non-pkh account.");
      await this.unlock(R);
      const ae = v.fromRing(fe, F).toPath();
      this.master.encrypted && (ae.data = this.master.encipher(ae.data, ae.hash), e(ae.data), ae.encrypted = !0);
      const D = this.db.batch();
      await fe.savePath(D, ae), await D.write();
    }
    /**
     * Import a keyring (will not exist on derivation chain).
     * Rescanning must be invoked manually.
     * @param {(String|Number)?} acct
     * @param {WalletKey} ring
     * @param {(String|Buffer)?} passphrase
     * @returns {Promise}
     */
    async importAddress(_, F) {
      const R = await this.writeLock.lock();
      try {
        return await this._importAddress(_, F);
      } finally {
        R();
      }
    }
    /**
     * Import a keyring (will not exist on derivation chain) without a lock.
     * @private
     * @param {(String|Number)?} acct
     * @param {WalletKey} ring
     * @param {(String|Buffer)?} passphrase
     * @returns {Promise}
     */
    async _importAddress(_, F) {
      if (!this.watchOnly)
        throw new Error("Cannot import address into non watch-only wallet.");
      if (await this.getPath(F))
        throw new Error("Address already exists.");
      const R = await this.getAccount(_);
      if (!R)
        throw new Error("Account not found.");
      if (R.type !== o.types.PUBKEYHASH)
        throw new Error("Cannot import into non-pkh account.");
      const V = s.fromAddress(R, F), fe = this.db.batch();
      await R.savePath(fe, V), await fe.write();
    }
    /**
     * Fill a transaction with inputs, estimate
     * transaction size, calculate fee, and add a change output.
     * @see MTX#selectCoins
     * @see MTX#fill
     * @param {MTX} mtx - _Must_ be a mutable transaction.
     * @param {Object?} options
     * @param {(String|Number)?} options.account - If no account is
     * specified, coins from the entire wallet will be filled.
     * @param {String?} options.selection - Coin selection priority. Can
     * be `age`, `random`, or `all`. (default=age).
     * @param {Boolean} options.round - Whether to round to the nearest
     * kilobyte for fee calculation.
     * See {@link TX#getMinFee} vs. {@link TX#getRoundFee}.
     * @param {Rate} options.rate - Rate used for fee calculation.
     * @param {Boolean} options.confirmed - Select only confirmed coins.
     * @param {Boolean} options.free - Do not apply a fee if the
     * transaction priority is high enough to be considered free.
     * @param {Amount?} options.hardFee - Use a hard fee rather than
     * calculating one.
     * @param {Number|Boolean} options.subtractFee - Whether to subtract the
     * fee from existing outputs rather than adding more inputs.
     */
    async fund(_, F, R) {
      const V = await this.fundLock.lock(R);
      try {
        return await this._fund(_, F);
      } finally {
        V();
      }
    }
    /**
     * Fill a transaction with inputs without a lock.
     * @private
     * @see MTX#selectCoins
     * @see MTX#fill
     */
    async _fund(_, F) {
      F || (F = {});
      const R = F.account || 0, V = await this.changeAddress(R);
      if (!V)
        throw new Error("Account not found.");
      let fe = F.rate;
      fe == null && (fe = await this.wdb.estimateFee(F.blocks));
      let ue;
      F.smart ? ue = await this.getSmartCoins(F.account) : (ue = await this.getCoins(F.account), ue = this.txdb.filterLocked(ue)), await _.fund(ue, {
        selection: F.selection,
        round: F.round,
        depth: F.depth,
        hardFee: F.hardFee,
        subtractFee: F.subtractFee,
        subtractIndex: F.subtractIndex,
        changeAddress: V,
        height: this.wdb.state.height,
        rate: fe,
        maxFee: F.maxFee,
        estimate: (ae) => this.estimateSize(ae)
      }), e(_.getFee() <= m.Selector.MAX_FEE, "TX exceeds MAX_FEE.");
    }
    /**
     * Get account by address.
     * @param {Address} address
     * @returns {Account}
     */
    async getAccountByAddress(_) {
      const F = p.getHash(_), R = await this.getPath(F);
      return R ? this.getAccount(R.account) : null;
    }
    /**
     * Input size estimator for max possible tx size.
     * @param {Script} prev
     * @returns {Number}
     */
    async estimateSize(_) {
      const F = _.getAddress();
      if (!F)
        return -1;
      const R = await this.getAccountByAddress(F);
      if (!R)
        return -1;
      let V = 0;
      switch (R.type) {
        case o.types.PUBKEYHASH:
          V += 74, V += 34;
          break;
        case o.types.MULTISIG:
          V += 1, V += 74 * R.m, V += 3, V += 1, V += 34 * R.n, V += 1, V += 1;
          break;
      }
      return V += J.sizeVarint(V), V;
    }
    /**
     * Build a transaction, fill it with outputs and inputs,
     * sort the members according to BIP69 (set options.sort=false
     * to avoid sorting), set locktime, and template it.
     * @param {Object} options - See {@link Wallet#fund options}.
     * @param {Object[]} options.outputs - See {@link MTX#addOutput}.
     * @param {Boolean} options.sort - Sort inputs and outputs (BIP69).
     * @param {Boolean} options.template - Build scripts for inputs.
     * @param {Number} options.locktime - TX locktime
     * @returns {Promise} - Returns {@link MTX}.
     */
    async createTX(_, F) {
      const R = _.outputs, V = new m();
      e(Array.isArray(R), "Outputs must be an array."), e(R.length > 0, "At least one output required");
      for (const ue of R) {
        const ae = new h(ue), D = ae.getAddress();
        if (ae.isDust())
          throw new Error("Output is dust.");
        if (ae.value > 0) {
          if (!D)
            throw new Error("Cannot send to unknown address.");
          if (D.isNull())
            throw new Error("Cannot send to null address.");
        }
        V.outputs.push(ae);
      }
      if (await this.fund(V, _, F), _.sort !== !1 && V.sortMembers(), _.locktime != null && V.setLocktime(_.locktime), e(V.isSane(), "TX failed sanity check."), e(
        V.verifyInputs(this.wdb.state.height + 1),
        "TX failed context check."
      ), _.template === !1)
        return V;
      if (await this.template(V) === 0)
        throw new Error("Templating failed.");
      return V;
    }
    /**
     * Build a transaction, fill it with outputs and inputs,
     * sort the members according to BIP69, set locktime,
     * sign and broadcast. Doing this all in one go prevents
     * coins from being double spent.
     * @param {Object} options - See {@link Wallet#fund options}.
     * @param {Object[]} options.outputs - See {@link MTX#addOutput}.
     * @returns {Promise} - Returns {@link TX}.
     */
    async send(_, F) {
      const R = await this.fundLock.lock();
      try {
        return await this._send(_, F);
      } finally {
        R();
      }
    }
    /**
     * Build and send a transaction without a lock.
     * @private
     * @param {Object} options - See {@link Wallet#fund options}.
     * @param {Object[]} options.outputs - See {@link MTX#addOutput}.
     * @returns {Promise} - Returns {@link TX}.
     */
    async _send(_, F) {
      const R = await this.createTX(_, !0);
      if (await this.sign(R, F), !R.isSigned())
        throw new Error("TX could not be fully signed.");
      const V = R.toTX();
      if (V.getSigopsCount(R.view) > H.MAX_TX_SIGOPS)
        throw new Error("TX exceeds policy sigops.");
      if (V.getSize() > H.MAX_TX_SIZE)
        throw new Error("TX exceeds policy size.");
      return await this.wdb.addTX(V), this.logger.debug("Sending wallet tx (%s): %h", this.id, V.hash()), await this.wdb.send(V), V;
    }
    /**
     * Intentionally double-spend outputs by
     * increasing fee for an existing transaction.
     * @param {Hash} hash
     * @param {Rate} rate
     * @param {(String|Buffer)?} passphrase
     * @returns {Promise} - Returns {@link TX}.
     */
    async increaseFee(_, F, R) {
      e(F >>> 0 === F, "Rate must be a number.");
      const V = await this.getTX(_);
      if (!V)
        throw new Error("Transaction not found.");
      if (V.height !== -1)
        throw new Error("Transaction is confirmed.");
      const fe = V.tx;
      if (fe.isCoinbase())
        throw new Error("Transaction is a coinbase.");
      const ue = await this.getSpentView(fe);
      if (!fe.hasCoins(ue))
        throw new Error("Not all coins available.");
      const ae = fe.getFee(ue);
      let D = fe.getMinFee(null, F);
      if (D > m.Selector.MAX_FEE && (D = m.Selector.MAX_FEE), ae >= D)
        throw new Error("Fee is not increasing.");
      const Q = m.fromTX(fe);
      Q.view = ue;
      for (const y of Q.inputs)
        y.script.clear();
      let Z;
      for (let y = 0; y < Q.outputs.length; y++) {
        const Y = Q.outputs[y], he = Y.getAddress();
        if (!he)
          continue;
        const be = await this.getPath(he);
        if (be && be.branch === 1) {
          Z = Y, Q.changeIndex = y;
          break;
        }
      }
      if (!Z)
        throw new Error("No change output.");
      if (Z.value += ae, Q.getFee() !== 0)
        throw new Error("Arithmetic error for change.");
      if (Z.value -= D, Z.value < 0)
        throw new Error("Fee is too high.");
      if (Z.isDust() && (Q.outputs.splice(Q.changeIndex, 1), Q.changeIndex = -1), await this.sign(Q, R), !Q.isSigned())
        throw new Error("TX could not be fully signed.");
      const oe = Q.toTX();
      return this.logger.debug(
        "Increasing fee for wallet tx (%s): %h",
        this.id,
        oe.hash()
      ), await this.wdb.addTX(oe), await this.wdb.send(oe), oe;
    }
    /**
     * Resend pending wallet transactions.
     * @returns {Promise}
     */
    async resend() {
      const _ = await this.getPending();
      _.length > 0 && this.logger.info("Rebroadcasting %d transactions.", _.length);
      const F = [];
      for (const V of _)
        F.push(V.tx);
      const R = i.sortDeps(F);
      for (const V of R)
        await this.wdb.send(V);
      return F;
    }
    /**
     * Derive necessary addresses for signing a transaction.
     * @param {MTX} mtx
     * @param {Number?} index - Input index.
     * @returns {Promise} - Returns {@link WalletKey}[].
     */
    async deriveInputs(_) {
      e(_.mutable);
      const F = await this.getInputPaths(_), R = [];
      for (const V of F) {
        const fe = await this.getAccount(V.account);
        if (!fe)
          continue;
        const ue = fe.derivePath(V, this.master);
        ue && R.push(ue);
      }
      return R;
    }
    /**
     * Retrieve a single keyring by address.
     * @param {Address|Hash} hash
     * @returns {Promise}
     */
    async getKey(_) {
      const F = p.getHash(_), R = await this.getPath(F);
      if (!R)
        return null;
      const V = await this.getAccount(R.account);
      return V ? V.derivePath(R, this.master) : null;
    }
    /**
     * Retrieve a single keyring by address
     * (with the private key reference).
     * @param {Address|Hash} hash
     * @param {(Buffer|String)?} passphrase
     * @returns {Promise}
     */
    async getPrivateKey(_, F) {
      const R = p.getHash(_), V = await this.getPath(R);
      if (!V)
        return null;
      const fe = await this.getAccount(V.account);
      if (!fe)
        return null;
      await this.unlock(F);
      const ue = fe.derivePath(V, this.master);
      return ue.privateKey ? ue : null;
    }
    /**
     * Map input addresses to paths.
     * @param {MTX} mtx
     * @returns {Promise} - Returns {@link Path}[].
     */
    async getInputPaths(_) {
      if (e(_.mutable), !_.hasCoins())
        throw new Error("Not all coins available.");
      const F = _.getInputHashes(), R = [];
      for (const V of F) {
        const fe = await this.getPath(V);
        fe && R.push(fe);
      }
      return R;
    }
    /**
     * Map output addresses to paths.
     * @param {TX} tx
     * @returns {Promise} - Returns {@link Path}[].
     */
    async getOutputPaths(_) {
      const F = [], R = _.getOutputHashes();
      for (const V of R) {
        const fe = await this.getPath(V);
        fe && F.push(fe);
      }
      return F;
    }
    /**
     * Increase lookahead for account.
     * @param {(Number|String)?} account
     * @param {Number} lookahead
     * @returns {Promise}
     */
    async setLookahead(_, F) {
      const R = await this.writeLock.lock();
      try {
        return this._setLookahead(_, F);
      } finally {
        R();
      }
    }
    /**
     * Increase lookahead for account (without a lock).
     * @private
     * @param {(Number|String)?} account
     * @param {Number} lookahead
     * @returns {Promise}
     */
    async _setLookahead(_, F) {
      const R = await this.getAccount(_);
      if (!R)
        throw new Error("Account not found.");
      const V = this.db.batch();
      await R.setLookahead(V, F), await V.write();
    }
    /**
     * Sync address depths based on a transaction's outputs.
     * This is used for deriving new addresses when
     * a confirmed transaction is seen.
     * @param {TX} tx
     * @returns {Promise}
     */
    async syncOutputDepth(_) {
      const F = /* @__PURE__ */ new Map();
      for (const fe of _.getOutputHashes()) {
        const ue = await this.readPath(fe);
        ue && ue.index !== -1 && (F.has(ue.account) || F.set(ue.account, []), F.get(ue.account).push(ue));
      }
      const R = [], V = this.db.batch();
      for (const [fe, ue] of F) {
        let ae = -1, D = -1;
        for (const oe of ue)
          switch (oe.branch) {
            case 0:
              oe.index > ae && (ae = oe.index);
              break;
            case 1:
              oe.index > D && (D = oe.index);
              break;
          }
        ae += 2, D += 2;
        const Q = await this.getAccount(fe);
        e(Q);
        const Z = await Q.syncDepth(V, ae, D);
        Z && R.push(Z);
      }
      return await V.write(), R;
    }
    /**
     * Build input scripts templates for a transaction (does not
     * sign, only creates signature slots). Only builds scripts
     * for inputs that are redeemable by this wallet.
     * @param {MTX} mtx
     * @returns {Promise} - Returns Number
     * (total number of scripts built).
     */
    async template(_) {
      const F = await this.deriveInputs(_);
      return _.template(F);
    }
    /**
     * Build input scripts and sign inputs for a transaction. Only attempts
     * to build/sign inputs that are redeemable by this wallet.
     * @param {MTX} tx
     * @param {Object|String|Buffer} options - Options or passphrase.
     * @returns {Promise} - Returns Number (total number
     * of inputs scripts built and signed).
     */
    async sign(_, F) {
      if (this.watchOnly)
        throw new Error("Cannot sign from a watch-only wallet.");
      await this.unlock(F);
      const R = await this.deriveInputs(_);
      return _.signAsync(R, E.hashType.ALL, this.wdb.workers);
    }
    /**
     * Get a coin viewpoint.
     * @param {TX} tx
     * @returns {Promise} - Returns {@link CoinView}.
     */
    getCoinView(_) {
      return this.txdb.getCoinView(_);
    }
    /**
     * Get a historical coin viewpoint.
     * @param {TX} tx
     * @returns {Promise} - Returns {@link CoinView}.
     */
    getSpentView(_) {
      return this.txdb.getSpentView(_);
    }
    /**
     * Convert transaction to transaction details.
     * @param {TXRecord} wtx
     * @returns {Promise} - Returns {@link Details}.
     */
    toDetails(_) {
      return this.txdb.toDetails(_);
    }
    /**
     * Get transaction details.
     * @param {Hash} hash
     * @returns {Promise} - Returns {@link Details}.
     */
    getDetails(_) {
      return this.txdb.getDetails(_);
    }
    /**
     * Get a coin from the wallet.
     * @param {Hash} hash
     * @param {Number} index
     * @returns {Promise} - Returns {@link Coin}.
     */
    getCoin(_, F) {
      return this.txdb.getCoin(_, F);
    }
    /**
     * Get a transaction from the wallet.
     * @param {Hash} hash
     * @returns {Promise} - Returns {@link TX}.
     */
    getTX(_) {
      return this.txdb.getTX(_);
    }
    /**
     * List blocks for the wallet.
     * @returns {Promise} - Returns {@link BlockRecord}.
     */
    getBlocks() {
      return this.txdb.getBlocks();
    }
    /**
     * Get a block from the wallet.
     * @param {Number} height
     * @returns {Promise} - Returns {@link BlockRecord}.
     */
    getBlock(_) {
      return this.txdb.getBlock(_);
    }
    /**
     * Add a transaction to the wallets TX history.
     * @param {TX} tx
     * @returns {Promise}
     */
    async add(_, F) {
      const R = await this.writeLock.lock();
      try {
        return await this._add(_, F);
      } finally {
        R();
      }
    }
    /**
     * Add a transaction to the wallet without a lock.
     * Potentially resolves orphans.
     * @private
     * @param {TX} tx
     * @returns {Promise}
     */
    async _add(_, F) {
      const R = await this.txdb.add(_, F);
      if (R) {
        const V = await this.syncOutputDepth(_);
        V.length > 0 && (this.wdb.emit("address", this, V), this.emit("address", V));
      }
      return R;
    }
    /**
     * Revert a block.
     * @param {Number} height
     * @returns {Promise}
     */
    async revert(_) {
      const F = await this.writeLock.lock();
      try {
        return await this.txdb.revert(_);
      } finally {
        F();
      }
    }
    /**
     * Remove a wallet transaction.
     * @param {Hash} hash
     * @returns {Promise}
     */
    async remove(_) {
      const F = await this.writeLock.lock();
      try {
        return await this.txdb.remove(_);
      } finally {
        F();
      }
    }
    /**
     * Zap stale TXs from wallet.
     * @param {(Number|String)?} acct
     * @param {Number} age - Age threshold (unix time, default=72 hours).
     * @returns {Promise}
     */
    async zap(_, F) {
      const R = await this.writeLock.lock();
      try {
        return await this._zap(_, F);
      } finally {
        R();
      }
    }
    /**
     * Zap stale TXs from wallet without a lock.
     * @private
     * @param {(Number|String)?} acct
     * @param {Number} age
     * @returns {Promise}
     */
    async _zap(_, F) {
      const R = await this.ensureIndex(_);
      return this.txdb.zap(R, F);
    }
    /**
     * Abandon transaction.
     * @param {Hash} hash
     * @returns {Promise}
     */
    async abandon(_) {
      const F = await this.writeLock.lock();
      try {
        return await this._abandon(_);
      } finally {
        F();
      }
    }
    /**
     * Abandon transaction without a lock.
     * @private
     * @param {Hash} hash
     * @returns {Promise}
     */
    _abandon(_) {
      return this.txdb.abandon(_);
    }
    /**
     * Lock a single coin.
     * @param {Coin|Outpoint} coin
     */
    lockCoin(_) {
      return this.txdb.lockCoin(_);
    }
    /**
     * Unlock a single coin.
     * @param {Coin|Outpoint} coin
     */
    unlockCoin(_) {
      return this.txdb.unlockCoin(_);
    }
    /**
     * Unlock all locked coins.
     */
    unlockCoins() {
      return this.txdb.unlockCoins();
    }
    /**
     * Test locked status of a single coin.
     * @param {Coin|Outpoint} coin
     */
    isLocked(_) {
      return this.txdb.isLocked(_);
    }
    /**
     * Return an array of all locked outpoints.
     * @returns {Outpoint[]}
     */
    getLocked() {
      return this.txdb.getLocked();
    }
    /**
     * Get all transactions in transaction history.
     * @param {(String|Number)?} acct
     * @returns {Promise} - Returns {@link TX}[].
     */
    async getHistory(_) {
      const F = await this.ensureIndex(_);
      return this.txdb.getHistory(F);
    }
    /**
     * Get all available coins.
     * @param {(String|Number)?} account
     * @returns {Promise} - Returns {@link Coin}[].
     */
    async getCoins(_) {
      const F = await this.ensureIndex(_);
      return this.txdb.getCoins(F);
    }
    /**
     * Get all available credits.
     * @param {(String|Number)?} account
     * @returns {Promise} - Returns {@link Credit}[].
     */
    async getCredits(_) {
      const F = await this.ensureIndex(_);
      return this.txdb.getCredits(F);
    }
    /**
     * Get "smart" coins.
     * @param {(String|Number)?} account
     * @returns {Promise} - Returns {@link Coin}[].
     */
    async getSmartCoins(_) {
      const F = await this.getCredits(_), R = [];
      for (const V of F) {
        const fe = V.coin;
        if (!V.spent && !this.txdb.isLocked(fe)) {
          if (fe.height !== -1) {
            R.push(fe);
            continue;
          }
          V.own && R.push(fe);
        }
      }
      return R;
    }
    /**
     * Get all pending/unconfirmed transactions.
     * @param {(String|Number)?} acct
     * @returns {Promise} - Returns {@link TX}[].
     */
    async getPending(_) {
      const F = await this.ensureIndex(_);
      return this.txdb.getPending(F);
    }
    /**
     * Get wallet balance.
     * @param {(String|Number)?} acct
     * @returns {Promise} - Returns {@link Balance}.
     */
    async getBalance(_) {
      const F = await this.ensureIndex(_);
      return this.txdb.getBalance(F);
    }
    /**
     * Get a range of transactions between two timestamps.
     * @param {(String|Number)?} acct
     * @param {Object} options
     * @param {Number} options.start
     * @param {Number} options.end
     * @returns {Promise} - Returns {@link TX}[].
     */
    async getRange(_, F) {
      const R = await this.ensureIndex(_);
      return this.txdb.getRange(R, F);
    }
    /**
     * Get the last N transactions.
     * @param {(String|Number)?} acct
     * @param {Number} limit
     * @returns {Promise} - Returns {@link TX}[].
     */
    async getLast(_, F) {
      const R = await this.ensureIndex(_);
      return this.txdb.getLast(R, F);
    }
    /**
     * Get account key.
     * @param {Number} [acct=0]
     * @returns {HDPublicKey}
     */
    async accountKey(_ = 0) {
      const F = await this.getAccount(_);
      if (!F)
        throw new Error("Account not found.");
      return F.accountKey;
    }
    /**
     * Get current receive depth.
     * @param {Number} [acct=0]
     * @returns {Number}
     */
    async receiveDepth(_ = 0) {
      const F = await this.getAccount(_);
      if (!F)
        throw new Error("Account not found.");
      return F.receiveDepth;
    }
    /**
     * Get current change depth.
     * @param {Number} [acct=0]
     * @returns {Number}
     */
    async changeDepth(_ = 0) {
      const F = await this.getAccount(_);
      if (!F)
        throw new Error("Account not found.");
      return F.changeDepth;
    }
    /**
     * Get current receive address.
     * @param {Number} [acct=0]
     * @returns {Address}
     */
    async receiveAddress(_ = 0) {
      const F = await this.getAccount(_);
      if (!F)
        throw new Error("Account not found.");
      return F.receiveAddress();
    }
    /**
     * Get current change address.
     * @param {Number} [acct=0]
     * @returns {Address}
     */
    async changeAddress(_ = 0) {
      const F = await this.getAccount(_);
      if (!F)
        throw new Error("Account not found.");
      return F.changeAddress();
    }
    /**
     * Get current receive key.
     * @param {Number} [acct=0]
     * @returns {WalletKey}
     */
    async receiveKey(_ = 0) {
      const F = await this.getAccount(_);
      if (!F)
        throw new Error("Account not found.");
      return F.receiveKey();
    }
    /**
     * Get current change key.
     * @param {Number} [acct=0]
     * @returns {WalletKey}
     */
    async changeKey(_ = 0) {
      const F = await this.getAccount(_);
      if (!F)
        throw new Error("Account not found.");
      return F.changeKey();
    }
    /**
     * Convert the wallet to a more inspection-friendly object.
     * @returns {Object}
     */
    [z]() {
      return {
        wid: this.wid,
        id: this.id,
        network: this.network.type,
        accountDepth: this.accountDepth,
        token: this.token.toString("hex"),
        tokenDepth: this.tokenDepth,
        master: this.master
      };
    }
    /**
     * Convert the wallet to an object suitable for
     * serialization.
     * @param {Boolean?} unsafe - Whether to include
     * the master key in the JSON.
     * @returns {Object}
     */
    toJSON(_, F) {
      return {
        network: this.network.type,
        wid: this.wid,
        id: this.id,
        watchOnly: this.watchOnly,
        accountDepth: this.accountDepth,
        token: this.token.toString("hex"),
        tokenDepth: this.tokenDepth,
        master: this.master.toJSON(this.network, _),
        balance: F ? F.toJSON(!0) : null
      };
    }
    /**
     * Calculate serialization size.
     * @returns {Number}
     */
    getSize() {
      let _ = 0;
      return _ += 41, _ += this.master.getSize(), _;
    }
    /**
     * Serialize the wallet.
     * @returns {Buffer}
     */
    toRaw() {
      const _ = this.getSize(), F = g.write(_);
      let R = 0;
      return this.watchOnly && (R |= 1), F.writeU8(R), F.writeU32(this.accountDepth), F.writeBytes(this.token), F.writeU32(this.tokenDepth), this.master.toWriter(F), F.render();
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     */
    fromRaw(_) {
      const F = g.read(_), R = F.readU8();
      return this.watchOnly = (R & 1) !== 0, this.accountDepth = F.readU32(), this.token = F.readBytes(32), this.tokenDepth = F.readU32(), this.master.fromReader(F), this;
    }
    /**
     * Instantiate a wallet from serialized data.
     * @param {Buffer} data
     * @returns {Wallet}
     */
    static fromRaw(_, F) {
      return new this(_).fromRaw(F);
    }
    /**
     * Test an object to see if it is a Wallet.
     * @param {Object} obj
     * @returns {Boolean}
     */
    static isWallet(_) {
      return _ instanceof A;
    }
  }
  return Qu = A, Qu;
}
/*!
 * nullclient.js - node client for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var eh, I3;
function Hx() {
  if (I3) return eh;
  I3 = 1;
  const e = $e(), c = co();
  class d extends c {
    /**
     * Create a client.
     * @constructor
     */
    constructor(g) {
      super(), this.wdb = g, this.network = g.network, this.opened = !1;
    }
    /**
     * Open the client.
     * @returns {Promise}
     */
    async open(g) {
      e(!this.opened, "NullClient is already open."), this.opened = !0, setImmediate(() => this.emit("connect"));
    }
    /**
     * Close the client.
     * @returns {Promise}
     */
    async close() {
      e(this.opened, "NullClient is not open."), this.opened = !1, setImmediate(() => this.emit("disconnect"));
    }
    /**
     * Add a listener.
     * @param {String} type
     * @param {Function} handler
     */
    bind(g, f) {
      return this.on(g, f);
    }
    /**
     * Add a listener.
     * @param {String} type
     * @param {Function} handler
     */
    hook(g, f) {
      return this.on(g, f);
    }
    /**
     * Get chain tip.
     * @returns {Promise}
     */
    async getTip() {
      const { hash: g, height: f, time: n } = this.network.genesis;
      return { hash: g, height: f, time: n };
    }
    /**
     * Get chain entry.
     * @param {Hash} hash
     * @returns {Promise}
     */
    async getEntry(g) {
      return { hash: g, height: 0, time: 0 };
    }
    /**
     * Send a transaction. Do not wait for promise.
     * @param {TX} tx
     * @returns {Promise}
     */
    async send(g) {
      this.wdb.emit("send", g);
    }
    /**
     * Set bloom filter.
     * @param {Bloom} filter
     * @returns {Promise}
     */
    async setFilter(g) {
      this.wdb.emit("set filter", g);
    }
    /**
     * Add data to filter.
     * @param {Buffer} data
     * @returns {Promise}
     */
    async addFilter(g) {
      this.wdb.emit("add filter", g);
    }
    /**
     * Reset filter.
     * @returns {Promise}
     */
    async resetFilter() {
      this.wdb.emit("reset filter");
    }
    /**
     * Esimate smart fee.
     * @param {Number?} blocks
     * @returns {Promise}
     */
    async estimateFee(g) {
      return this.network.feeRate;
    }
    /**
     * Get hash range.
     * @param {Number} start
     * @param {Number} end
     * @returns {Promise}
     */
    async getHashes(g = -1, f = -1) {
      return [this.network.genesis.hash];
    }
    /**
     * Rescan for any missed transactions.
     * @param {Number|Hash} start - Start block.
     * @param {Bloom} filter
     * @param {Function} iter - Iterator.
     * @returns {Promise}
     */
    async rescan(g) {
    }
  }
  return eh = d, eh;
}
var th, A3;
function Lx() {
  if (A3) return th;
  A3 = 1;
  const e = $e(), c = n7(), d = co(), w = At(), { BufferMap: g } = Dr(), { BloomFilter: f } = s7(), { Lock: n, MapLock: u } = Al(), a = o7(), s = qx(), { safeEqual: i } = Ol(), p = _l(), m = yr(), E = So(), v = Rl(), b = Fx(), h = u7(), o = xi(), S = f7(), H = a7(), j = Hx(), J = S.wdb, N = S.txdb, {
    ChainState: z,
    BlockMeta: A,
    TXRecord: q,
    MapRecord: _
  } = H;
  class F extends d {
    /**
     * Create a wallet db.
     * @constructor
     * @param {Object} options
     */
    constructor(D) {
      super(), this.options = new R(D), this.network = this.options.network, this.logger = this.options.logger.context("wallet"), this.workers = this.options.workers, this.client = this.options.client || new j(this), this.feeRate = this.options.feeRate, this.db = a.create(this.options), this.primary = null, this.state = new z(), this.confirming = !1, this.height = 0, this.wallets = /* @__PURE__ */ new Map(), this.depth = 0, this.rescanning = !1, this.filterSent = !1, this.readLock = new u(), this.writeLock = new n(), this.txLock = new n(), this.filter = new f(), this.init();
    }
    /**
     * Initialize walletdb.
     * @private
     */
    init() {
      let D = 3e6, Q = -1;
      this.options.spv && (D = 2e4, Q = f.flags.ALL), this.filter = f.fromRate(D, 1e-3, Q), this._bind();
    }
    /**
     * Bind to node events.
     * @private
     */
    _bind() {
      this.client.on("error", (D) => {
        this.emit("error", D);
      }), this.client.on("connect", async () => {
        try {
          await this.syncNode();
        } catch (D) {
          this.emit("error", D);
        }
      }), this.client.on("disconnect", async () => {
        this.filterSent = !1;
      }), this.client.bind("block connect", async (D, Q) => {
        try {
          await this.addBlock(D, Q);
        } catch (Z) {
          this.emit("error", Z);
        }
      }), this.client.bind("block disconnect", async (D) => {
        try {
          await this.removeBlock(D);
        } catch (Q) {
          this.emit("error", Q);
        }
      }), this.client.hook("block rescan", async (D, Q) => {
        try {
          await this.rescanBlock(D, Q);
        } catch (Z) {
          this.emit("error", Z);
        }
      }), this.client.bind("tx", async (D) => {
        try {
          await this.addTX(D);
        } catch (Q) {
          this.emit("error", Q);
        }
      }), this.client.bind("chain reset", async (D) => {
        try {
          await this.resetChain(D);
        } catch (Q) {
          this.emit("error", Q);
        }
      });
    }
    /**
     * Open the walletdb, wait for the database to load.
     * @returns {Promise}
     */
    async open() {
      this.logger.info("Opening WalletDB..."), await this.db.open(), await this.db.verify(J.V.encode(), "wallet", 135), await this.verifyNetwork(), this.depth = await this.getDepth(), this.options.wipeNoReally && await this.wipe(), await this.watch(), await this.connect(), this.logger.info(
        "WalletDB loaded (depth=%d, height=%d, start=%d).",
        this.depth,
        this.state.height,
        this.state.startHeight
      );
      const D = await this.ensure({
        id: "primary"
      }), Q = await D.receiveAddress();
      this.logger.info(
        "Loaded primary wallet (id=%s, wid=%d, address=%s)",
        D.id,
        D.wid,
        Q.toString(this.network)
      ), this.primary = D;
    }
    /**
     * Verify network.
     * @returns {Promise}
     */
    async verifyNetwork() {
      const D = await this.db.get(J.O.encode());
      if (!D) {
        const Z = this.db.batch();
        return Z.put(J.O.encode(), V(this.network.magic)), Z.write();
      }
      if (D.readUInt32LE(0, !0) !== this.network.magic)
        throw new Error("Network mismatch for WalletDB.");
    }
    /**
     * Close the walletdb, wait for the database to close.
     * @returns {Promise}
     */
    async close() {
      await this.disconnect();
      for (const D of this.wallets.values())
        await D.destroy(), this.unregister(D);
      return this.db.close();
    }
    /**
     * Watch addresses and outpoints.
     * @private
     * @returns {Promise}
     */
    async watch() {
      const D = this.db.iterator({
        gte: J.p.min(),
        lte: J.p.max()
      });
      let Q = 0;
      await D.each((y) => {
        const [Y] = J.p.decode(y);
        this.filter.add(Y), Q += 1;
      }), this.logger.info("Added %d hashes to WalletDB filter.", Q);
      const Z = this.db.iterator({
        gte: J.o.min(),
        lte: J.o.max()
      });
      let oe = 0;
      await Z.each((y) => {
        const [Y, he] = J.o.decode(y), xe = new o(Y, he).toRaw();
        this.filter.add(xe), oe += 1;
      }), this.logger.info("Added %d outpoints to WalletDB filter.", oe);
    }
    /**
     * Connect to the node server (client required).
     * @returns {Promise}
     */
    async connect() {
      return this.client.open();
    }
    /**
     * Disconnect from node server (client required).
     * @returns {Promise}
     */
    async disconnect() {
      return this.client.close();
    }
    /**
     * Sync state with server on every connect.
     * @returns {Promise}
     */
    async syncNode() {
      const D = await this.txLock.lock();
      try {
        this.logger.info("Resyncing from server..."), await this.syncState(), await this.syncFilter(), await this.syncChain(), await this.resend();
      } finally {
        D();
      }
    }
    /**
     * Initialize and write initial sync state.
     * @returns {Promise}
     */
    async syncState() {
      const D = await this.getState();
      if (D) {
        if (!await this.getBlock(0))
          return this.migrateState(D);
        this.state = D, this.height = D.height;
        return;
      }
      this.logger.info("Initializing database state from server.");
      const Q = this.db.batch(), Z = await this.client.getHashes();
      let oe = null;
      for (let Y = 0; Y < Z.length; Y++) {
        const he = Z[Y], be = new A(he, Y);
        Q.put(J.h.encode(Y), be.toHash()), oe = be;
      }
      e(oe);
      const y = this.state.clone();
      y.startHeight = oe.height, y.startHash = oe.hash, y.height = oe.height, y.marked = !1, Q.put(J.R.encode(), y.toRaw()), await Q.write(), this.state = y, this.height = y.height;
    }
    /**
     * Migrate sync state.
     * @private
     * @param {ChainState} state
     * @returns {Promise}
     */
    async migrateState(D) {
      const Q = this.db.batch();
      this.logger.info("Migrating to new sync state.");
      const Z = await this.client.getHashes(0, D.height);
      for (let oe = 0; oe < Z.length; oe++) {
        const y = Z[oe], Y = new A(y, oe);
        Q.put(J.h.encode(oe), Y.toHash());
      }
      await Q.write(), this.state = D, this.height = D.height;
    }
    /**
     * Connect and sync with the chain server.
     * @private
     * @returns {Promise}
     */
    async syncChain() {
      let D = this.state.height;
      for (this.logger.info("Syncing state from height %d.", D); ; ) {
        const Q = await this.getBlock(D);
        if (e(Q), await this.client.getEntry(Q.hash))
          break;
        e(D !== 0), D -= 1;
      }
      return this.scan(D);
    }
    /**
     * Rescan blockchain from a given height.
     * @private
     * @param {Number?} height
     * @returns {Promise}
     */
    async scan(D) {
      D == null && (D = this.state.startHeight), e(D >>> 0 === D, "WDB: Must pass in a height."), this.logger.info(
        "WalletDB is scanning %d blocks.",
        this.state.height - D + 1
      ), await this.rollback(D);
      const Q = await this.getTip();
      try {
        this.rescanning = !0, await this.client.rescan(Q.hash);
      } finally {
        this.rescanning = !1;
      }
    }
    /**
     * Force a rescan.
     * @param {Number} height
     * @returns {Promise}
     */
    async rescan(D) {
      const Q = await this.txLock.lock();
      try {
        return await this._rescan(D);
      } finally {
        Q();
      }
    }
    /**
     * Force a rescan (without a lock).
     * @private
     * @param {Number} height
     * @returns {Promise}
     */
    async _rescan(D) {
      return this.scan(D);
    }
    /**
     * Broadcast a transaction via chain server.
     * @param {TX} tx
     * @returns {Promise}
     */
    async send(D) {
      return this.client.send(D);
    }
    /**
     * Estimate smart fee from chain server.
     * @param {Number} blocks
     * @returns {Promise}
     */
    async estimateFee(D) {
      if (this.feeRate > 0)
        return this.feeRate;
      const Q = await this.client.estimateFee(D);
      return Q < this.network.feeRate ? this.network.feeRate : Q > this.network.maxFeeRate ? this.network.maxFeeRate : Q;
    }
    /**
     * Send filter to the remote node.
     * @private
     * @returns {Promise}
     */
    syncFilter() {
      return this.logger.info(
        "Sending filter to server (%dmb).",
        this.filter.size / 8 / (1 << 20)
      ), this.filterSent = !0, this.client.setFilter(this.filter);
    }
    /**
     * Add data to remote filter.
     * @private
     * @param {Buffer} data
     * @returns {Promise}
     */
    addFilter(D) {
      if (this.filterSent)
        return this.client.addFilter(D);
    }
    /**
     * Reset remote filter.
     * @private
     * @returns {Promise}
     */
    resetFilter() {
      if (this.filterSent)
        return this.client.resetFilter();
    }
    /**
     * Backup the wallet db.
     * @param {String} path
     * @returns {Promise}
     */
    backup(D) {
      return this.db.backup(D);
    }
    /**
     * Wipe the txdb - NEVER USE.
     * @returns {Promise}
     */
    async wipe() {
      this.logger.warning("Wiping WalletDB TXDB..."), this.logger.warning("I hope you know what you're doing.");
      const D = this.db.iterator(), Q = this.db.batch();
      let Z = 0;
      return await D.each((oe) => {
        switch (oe[0]) {
          case 98:
          // b
          case 99:
          // c
          case 101:
          // e
          case 116:
          // t
          case 111:
          // o
          case 104:
          // h
          case 82:
            Q.del(oe), Z += 1;
            break;
        }
      }), this.logger.warning("Wiped %d txdb records.", Z), Q.write();
    }
    /**
     * Get current wallet wid depth.
     * @private
     * @returns {Promise}
     */
    async getDepth() {
      const D = await this.db.get(J.D.encode());
      return D ? D.readUInt32LE(0, !0) : 0;
    }
    /**
     * Test the bloom filter against a tx or address hash.
     * @private
     * @param {Hash} hash
     * @returns {Boolean}
     */
    testFilter(D) {
      return this.filter.test(D);
    }
    /**
     * Add hash to local and remote filters.
     * @private
     * @param {Hash} hash
     */
    addHash(D) {
      return this.filter.add(D), this.addFilter(D);
    }
    /**
     * Add outpoint to local filter.
     * @private
     * @param {Hash} hash
     * @param {Number} index
     */
    addOutpoint(D, Q) {
      const Z = new o(D, Q);
      this.filter.add(Z.toRaw());
    }
    /**
     * Dump database (for debugging).
     * @returns {Promise} - Returns Object.
     */
    dump() {
      return this.db.dump();
    }
    /**
     * Register an object with the walletdb.
     * @param {Object} object
     */
    register(D) {
      e(!this.wallets.has(D.wid)), this.wallets.set(D.wid, D);
    }
    /**
     * Unregister a object with the walletdb.
     * @param {Object} object
     * @returns {Boolean}
     */
    unregister(D) {
      e(this.wallets.has(D.wid)), this.wallets.delete(D.wid);
    }
    /**
     * Map wallet id to wid.
     * @param {String|Number} id
     * @returns {Promise} - Returns {Number}.
     */
    async ensureWID(D) {
      return typeof D == "number" ? await this.db.has(J.W.encode(D)) ? D : -1 : this.getWID(D);
    }
    /**
     * Map wallet id to wid.
     * @param {String} id
     * @returns {Promise} - Returns {Number}.
     */
    async getWID(D) {
      const Q = await this.db.get(J.l.encode(D));
      return Q ? (e(Q.length === 4), Q.readUInt32LE(0, !0)) : -1;
    }
    /**
     * Map wallet wid to id.
     * @param {Number} wid
     * @returns {Promise} - Returns {String}.
     */
    async getID(D) {
      const Q = await this.db.get(J.W.encode(D));
      return Q ? ue(Q) : null;
    }
    /**
     * Get a wallet from the database, setup watcher.
     * @param {Number|String} id
     * @returns {Promise} - Returns {@link Wallet}.
     */
    async get(D) {
      const Q = await this.ensureWID(D);
      if (Q === -1)
        return null;
      const Z = await this.readLock.lock(Q);
      try {
        return await this._get(Q);
      } finally {
        Z();
      }
    }
    /**
     * Get a wallet from the database without a lock.
     * @private
     * @param {Number} wid
     * @returns {Promise} - Returns {@link Wallet}.
     */
    async _get(D) {
      const Q = this.wallets.get(D);
      if (Q)
        return Q;
      const Z = await this.getID(D);
      if (!Z)
        return null;
      const oe = await this.db.get(J.w.encode(D));
      e(oe);
      const y = b.fromRaw(this, oe);
      return y.wid = D, y.id = Z, await y.open(), this.register(y), y;
    }
    /**
     * Save a wallet to the database.
     * @param {Wallet} wallet
     */
    save(D, Q) {
      const Z = Q.wid, oe = Q.id;
      D.put(J.w.encode(Z), Q.toRaw()), D.put(J.W.encode(Z), fe(oe)), D.put(J.l.encode(oe), V(Z));
    }
    /**
     * Increment the wid depth.
     * @param {Batch} b
     * @param {Number} wid
     */
    increment(D, Q) {
      D.put(J.D.encode(), V(Q + 1));
    }
    /**
     * Rename a wallet.
     * @param {Wallet} wallet
     * @param {String} id
     * @returns {Promise}
     */
    async rename(D, Q) {
      const Z = await this.writeLock.lock();
      try {
        return await this._rename(D, Q);
      } finally {
        Z();
      }
    }
    /**
     * Rename a wallet without a lock.
     * @private
     * @param {Wallet} wallet
     * @param {String} id
     * @returns {Promise}
     */
    async _rename(D, Q) {
      if (!v.isName(Q))
        throw new Error("WDB: Bad wallet ID.");
      if (await this.has(Q))
        throw new Error("WDB: ID not available.");
      const Z = this.db.batch();
      Z.put(J.W.encode(D.wid), fe(Q)), Z.del(J.l.encode(D.id)), Z.put(J.l.encode(Q), V(D.wid)), await Z.write(), D.id = Q;
    }
    /**
     * Rename an account.
     * @param {Account} account
     * @param {String} name
     */
    renameAccount(D, Q, Z) {
      const oe = Q.wid, y = Q.accountIndex;
      D.del(J.i.encode(oe, Q.name)), D.put(J.i.encode(oe, Z), V(y)), D.put(J.n.encode(oe, y), fe(Z)), Q.name = Z;
    }
    /**
     * Remove a wallet.
     * @param {Number|String} id
     * @returns {Promise}
     */
    async remove(D) {
      const Q = await this.ensureWID(D);
      if (Q === -1)
        return !1;
      const Z = await this.readLock.lock(Q), oe = await this.writeLock.lock(), y = await this.txLock.lock();
      try {
        return await this._remove(Q);
      } finally {
        y(), oe(), Z();
      }
    }
    /**
     * Remove a wallet (without a lock).
     * @private
     * @param {Number} wid
     * @returns {Promise}
     */
    async _remove(D) {
      const Q = await this.getID(D);
      if (!Q)
        return !1;
      if (Q === "primary")
        throw new Error("Cannot remove primary wallet.");
      const Z = this.db.batch();
      Z.del(J.w.encode(D)), Z.del(J.W.encode(D)), Z.del(J.l.encode(Q)), await this.db.iterator({
        gte: J.P.min(D),
        lte: J.P.max(D)
      }).each((ve, C) => {
        const [, I] = J.P.decode(ve);
        return Z.del(ve), this.removePathMap(Z, I, D);
      });
      const y = (ve) => this.db.iterator(ve).each((C) => Z.del(C));
      await y({
        gte: J.r.min(D),
        lte: J.r.max(D)
      }), await y({
        gte: J.a.min(D),
        lte: J.a.max(D)
      }), await y({
        gte: J.i.min(D),
        lte: J.i.max(D)
      }), await y({
        gte: J.n.min(D),
        lte: J.n.max(D)
      }), await y({
        gt: J.t.encode(D),
        lt: J.t.encode(D + 1)
      });
      const Y = this.db.bucket(J.t.encode(D));
      await Y.iterator({
        gte: N.b.min(),
        lte: N.b.max()
      }).each((ve, C) => {
        const [I] = N.b.decode(ve);
        return this.removeBlockMap(Z, I, D);
      }), await Y.iterator({
        gte: N.s.min(),
        lte: N.s.max(),
        keys: !0
      }).each((ve, C) => {
        const [I, se] = N.s.decode(ve);
        return this.removeOutpointMap(Z, I, se, D);
      }), await Y.iterator({
        gte: N.p.min(),
        lte: N.p.max(),
        keys: !0
      }).each((ve, C) => {
        const [I] = N.p.decode(ve);
        return this.removeTXMap(Z, I, D);
      });
      const Ie = this.wallets.get(D);
      return Ie && (await Ie.destroy(), this.unregister(Ie)), await Z.write(), !0;
    }
    /**
     * Get a wallet with token auth first.
     * @param {Number|String} id
     * @param {Buffer} token
     * @returns {Promise} - Returns {@link Wallet}.
     */
    async auth(D, Q) {
      const Z = await this.get(D);
      if (!Z)
        return null;
      if (!i(Q, Z.token))
        throw new Error("WDB: Authentication error.");
      return Z;
    }
    /**
     * Create a new wallet, save to database, setup watcher.
     * @param {Object} options - See {@link Wallet}.
     * @returns {Promise} - Returns {@link Wallet}.
     */
    async create(D) {
      const Q = await this.writeLock.lock();
      D || (D = {});
      try {
        return await this._create(D);
      } finally {
        Q();
      }
    }
    /**
     * Create a new wallet, save to database without a lock.
     * @private
     * @param {Object} options - See {@link Wallet}.
     * @returns {Promise} - Returns {@link Wallet}.
     */
    async _create(D) {
      if (D.id && await this.has(D.id))
        throw new Error("WDB: Wallet already exists.");
      const Q = b.fromOptions(this, D);
      return Q.wid = this.depth, await Q.init(D, D.passphrase), this.depth += 1, this.register(Q), this.logger.info("Created wallet %s in WalletDB.", Q.id), Q;
    }
    /**
     * Test for the existence of a wallet.
     * @param {Number|String} id
     * @returns {Promise}
     */
    async has(D) {
      return await this.ensureWID(D) !== -1;
    }
    /**
     * Attempt to create wallet, return wallet if already exists.
     * @param {Object} options - See {@link Wallet}.
     * @returns {Promise}
     */
    async ensure(D) {
      if (D.id) {
        const Q = await this.get(D.id);
        if (Q)
          return Q;
      }
      return this.create(D);
    }
    /**
     * Get an account from the database by wid.
     * @private
     * @param {Number} wid
     * @param {Number} index - Account index.
     * @returns {Promise} - Returns {@link Wallet}.
     */
    async getAccount(D, Q) {
      const Z = await this.getAccountName(D, Q);
      if (!Z)
        return null;
      const oe = await this.db.get(J.a.encode(D, Q));
      e(oe);
      const y = h.fromRaw(this, oe);
      return y.accountIndex = Q, y.name = Z, y;
    }
    /**
     * List account names and indexes from the db.
     * @param {Number} wid
     * @returns {Promise} - Returns Array.
     */
    async getAccounts(D) {
      return this.db.values({
        gte: J.n.min(D),
        lte: J.n.max(D),
        parse: ue
      });
    }
    /**
     * Lookup the corresponding account name's index.
     * @param {Number} wid
     * @param {String} name - Account name/index.
     * @returns {Promise} - Returns Number.
     */
    async getAccountIndex(D, Q) {
      const Z = await this.db.get(J.i.encode(D, Q));
      return Z ? Z.readUInt32LE(0, !0) : -1;
    }
    /**
     * Lookup the corresponding account index's name.
     * @param {Number} wid
     * @param {Number} index
     * @returns {Promise} - Returns Number.
     */
    async getAccountName(D, Q) {
      const Z = await this.db.get(J.n.encode(D, Q));
      return Z ? ue(Z) : null;
    }
    /**
     * Save an account to the database.
     * @param {Account} account
     * @returns {Promise}
     */
    saveAccount(D, Q) {
      const Z = Q.wid, oe = Q.accountIndex, y = Q.name;
      D.put(J.a.encode(Z, oe), Q.toRaw()), D.put(J.i.encode(Z, y), V(oe)), D.put(J.n.encode(Z, oe), fe(y));
    }
    /**
     * Test for the existence of an account.
     * @param {Number} wid
     * @param {String|Number} acct
     * @returns {Promise} - Returns Boolean.
     */
    async hasAccount(D, Q) {
      return this.db.has(J.a.encode(D, Q));
    }
    /**
     * Save an address to the path map.
     * @param {Wallet} wallet
     * @param {WalletKey} ring
     * @returns {Promise}
     */
    async saveKey(D, Q, Z) {
      return this.savePath(D, Q, Z.toPath());
    }
    /**
     * Save a path to the path map.
     *
     * The path map exists in the form of:
     *   - `p[address-hash] -> wid map`
     *   - `P[wid][address-hash] -> path data`
     *   - `r[wid][account-index][address-hash] -> dummy`
     *
     * @param {Wallet} wallet
     * @param {Path} path
     * @returns {Promise}
     */
    async savePath(D, Q, Z) {
      await this.addPathMap(D, Z.hash, Q), D.put(J.P.encode(Q, Z.hash), Z.toRaw()), D.put(J.r.encode(Q, Z.account, Z.hash), null);
    }
    /**
     * Retrieve path by hash.
     * @param {Number} wid
     * @param {Hash} hash
     * @returns {Promise}
     */
    async getPath(D, Q) {
      const Z = await this.readPath(D, Q);
      return Z ? (Z.name = await this.getAccountName(D, Z.account), e(Z.name), Z) : null;
    }
    /**
     * Retrieve path by hash.
     * @param {Number} wid
     * @param {Hash} hash
     * @returns {Promise}
     */
    async readPath(D, Q) {
      const Z = await this.db.get(J.P.encode(D, Q));
      if (!Z)
        return null;
      const oe = E.fromRaw(Z);
      return oe.hash = Q, oe;
    }
    /**
     * Test whether a wallet contains a path.
     * @param {Number} wid
     * @param {Hash} hash
     * @returns {Promise}
     */
    async hasPath(D, Q) {
      return this.db.has(J.P.encode(D, Q));
    }
    /**
     * Get all address hashes.
     * @returns {Promise}
     */
    async getHashes() {
      return this.db.keys({
        gte: J.p.min(),
        lte: J.p.max(),
        parse: (D) => J.p.decode(D)[0]
      });
    }
    /**
     * Get all outpoints.
     * @returns {Promise}
     */
    async getOutpoints() {
      return this.db.keys({
        gte: J.o.min(),
        lte: J.o.max(),
        parse: (D) => {
          const [Q, Z] = J.o.decode(D);
          return new o(Q, Z);
        }
      });
    }
    /**
     * Get all address hashes.
     * @param {Number} wid
     * @returns {Promise}
     */
    async getWalletHashes(D) {
      return this.db.keys({
        gte: J.P.min(D),
        lte: J.P.max(D),
        parse: (Q) => J.P.decode(Q)[1]
      });
    }
    /**
     * Get all account address hashes.
     * @param {Number} wid
     * @param {Number} account
     * @returns {Promise}
     */
    async getAccountHashes(D, Q) {
      return this.db.keys({
        gte: J.r.min(D, Q),
        lte: J.r.max(D, Q),
        parse: (Z) => J.r.decode(Z)[2]
      });
    }
    /**
     * Get all paths for a wallet.
     * @param {Number} wid
     * @returns {Promise}
     */
    async getWalletPaths(D) {
      const Q = await this.db.range({
        gte: J.P.min(D),
        lte: J.P.max(D)
      }), Z = [];
      for (const { key: oe, value: y } of Q) {
        const [, Y] = J.P.decode(oe), he = E.fromRaw(y);
        he.hash = Y, he.name = await this.getAccountName(D, he.account), e(he.name), Z.push(he);
      }
      return Z;
    }
    /**
     * Get all wallet ids.
     * @returns {Promise}
     */
    async getWallets() {
      return this.db.values({
        gte: J.W.min(),
        lte: J.W.max(),
        parse: ue
      });
    }
    /**
     * Encrypt all imported keys for a wallet.
     * @param {Number} wid
     * @param {Buffer} key
     * @returns {Promise}
     */
    async encryptKeys(D, Q, Z) {
      await this.db.iterator({
        gte: J.P.min(Q),
        lte: J.P.max(Q),
        values: !0
      }).each((y, Y) => {
        const [, he] = J.P.decode(y), be = E.fromRaw(Y);
        if (!be.data)
          return;
        e(!be.encrypted);
        const xe = he.slice(0, 16);
        be.data = p.encipher(be.data, Z, xe), be.encrypted = !0, D.put(y, be.toRaw());
      });
    }
    /**
     * Decrypt all imported keys for a wallet.
     * @param {Number} wid
     * @param {Buffer} key
     * @returns {Promise}
     */
    async decryptKeys(D, Q, Z) {
      await this.db.iterator({
        gte: J.P.min(Q),
        lte: J.P.max(Q),
        values: !0
      }).each((y, Y) => {
        const [, he] = J.P.decode(y), be = E.fromRaw(Y);
        if (!be.data)
          return;
        e(be.encrypted);
        const xe = he.slice(0, 16);
        be.data = p.decipher(be.data, Z, xe), be.encrypted = !1, D.put(y, be.toRaw());
      });
    }
    /**
     * Resend all pending transactions.
     * @returns {Promise}
     */
    async resend() {
      const D = await this.db.keys({
        gte: J.w.min(),
        lte: J.w.max(),
        parse: (Q) => J.w.decode(Q)[0]
      });
      this.logger.info("Resending from %d wallets.", D.length);
      for (const Q of D)
        await this.resendPending(Q);
    }
    /**
     * Resend all pending transactions for a specific wallet.
     * @private
     * @param {Number} wid
     * @returns {Promise}
     */
    async resendPending(D) {
      const Q = J.t.encode(D), Z = this.db.bucket(Q), oe = await Z.keys({
        gte: N.p.min(),
        lte: N.p.max(),
        parse: (Y) => N.p.decode(Y)[0]
      });
      if (oe.length === 0)
        return;
      this.logger.info(
        "Rebroadcasting %d transactions for %d.",
        oe.length,
        D
      );
      const y = [];
      for (const Y of oe) {
        const he = await Z.get(N.t.encode(Y));
        if (!he)
          continue;
        const be = q.fromRaw(he);
        be.tx.isCoinbase() || y.push(be.tx);
      }
      for (const Y of v.sortDeps(y))
        await this.send(Y);
    }
    /**
     * Get all wallet ids by output addresses and outpoints.
     * @param {Hash[]} hashes
     * @returns {Promise}
     */
    async getWalletsByTX(D) {
      const Q = /* @__PURE__ */ new Set();
      if (!D.isCoinbase())
        for (const { prevout: oe } of D.inputs) {
          const { hash: y, index: Y } = oe;
          if (!this.testFilter(oe.toRaw()))
            continue;
          const he = await this.getOutpointMap(y, Y);
          if (he)
            for (const be of he.wids)
              Q.add(be);
        }
      const Z = D.getOutputHashes();
      for (const oe of Z) {
        if (!this.testFilter(oe))
          continue;
        const y = await this.getPathMap(oe);
        if (y)
          for (const Y of y.wids)
            Q.add(Y);
      }
      return Q.size === 0 ? null : Q;
    }
    /**
     * Get the best block hash.
     * @returns {Promise}
     */
    async getState() {
      const D = await this.db.get(J.R.encode());
      return D ? z.fromRaw(D) : null;
    }
    /**
     * Sync the current chain state to tip.
     * @param {BlockMeta} tip
     * @returns {Promise}
     */
    async setTip(D) {
      const Q = this.db.batch(), Z = this.state.clone();
      if (D.height < Z.height)
        for (; Z.height !== D.height; )
          Q.del(J.h.encode(Z.height)), Z.height -= 1;
      else D.height > Z.height && (e(D.height === Z.height + 1, "Bad chain sync."), Z.height += 1);
      D.height < Z.startHeight && (Z.startHeight = D.height, Z.startHash = D.hash, Z.marked = !1), Q.put(J.h.encode(D.height), D.toHash()), Q.put(J.R.encode(), Z.toRaw()), await Q.write(), this.state = Z, this.height = Z.height;
    }
    /**
     * Will return the current height and will increment
     * to the current height of a block currently being
     * added to the wallet.
     * @returns {Number}
     */
    liveHeight() {
      let D = this.height;
      return this.confirming && (D += 1), D;
    }
    /**
     * Mark current state.
     * @param {BlockMeta} block
     * @returns {Promise}
     */
    async markState(D) {
      const Q = this.state.clone();
      Q.startHeight = D.height, Q.startHash = D.hash, Q.marked = !0;
      const Z = this.db.batch();
      Z.put(J.R.encode(), Q.toRaw()), await Z.write(), this.state = Q, this.height = Q.height;
    }
    /**
     * Get a wallet map.
     * @param {Buffer} key
     * @returns {Promise}
     */
    async getMap(D) {
      const Q = await this.db.get(D);
      return Q ? _.fromRaw(Q) : null;
    }
    /**
     * Add wid to a wallet map.
     * @param {Wallet} wallet
     * @param {Buffer} key
     * @param {Number} wid
     */
    async addMap(D, Q, Z) {
      const oe = await this.db.get(Q);
      if (!oe) {
        const he = new _();
        he.add(Z), D.put(Q, he.toRaw());
        return;
      }
      e(oe.length >= 4);
      const y = oe.readUInt32LE(0, !0), Y = w.write(oe.length + 4);
      Y.writeU32(y + 1), Y.copy(oe, 4, oe.length), Y.writeU32(Z), D.put(Q, Y.render());
    }
    /**
     * Remove wid from a wallet map.
     * @param {Wallet} wallet
     * @param {Buffer} key
     * @param {Number} wid
     */
    async removeMap(D, Q, Z) {
      const oe = await this.getMap(Q);
      if (oe && oe.remove(Z)) {
        if (oe.size === 0) {
          D.del(Q);
          return;
        }
        D.put(Q, oe.toRaw());
      }
    }
    /**
     * Get a wallet map.
     * @param {Buffer} key
     * @returns {Promise}
     */
    async getPathMap(D) {
      return this.getMap(J.p.encode(D));
    }
    /**
     * Add wid to a wallet map.
     * @param {Wallet} wallet
     * @param {Buffer} key
     * @param {Number} wid
     */
    async addPathMap(D, Q, Z) {
      return await this.addHash(Q), this.addMap(D, J.p.encode(Q), Z);
    }
    /**
     * Remove wid from a wallet map.
     * @param {Wallet} wallet
     * @param {Buffer} key
     * @param {Number} wid
     */
    async removePathMap(D, Q, Z) {
      return this.removeMap(D, J.p.encode(Q), Z);
    }
    /**
     * Get a wallet map.
     * @param {Buffer} key
     * @returns {Promise}
     */
    async getBlockMap(D) {
      return this.getMap(J.b.encode(D));
    }
    /**
     * Add wid to a wallet map.
     * @param {Wallet} wallet
     * @param {Buffer} key
     * @param {Number} wid
     */
    async addBlockMap(D, Q, Z) {
      return this.addMap(D, J.b.encode(Q), Z);
    }
    /**
     * Remove wid from a wallet map.
     * @param {Wallet} wallet
     * @param {Buffer} key
     * @param {Number} wid
     */
    async removeBlockMap(D, Q, Z) {
      return this.removeMap(D, J.b.encode(Q), Z);
    }
    /**
     * Get a wallet map.
     * @param {Buffer} key
     * @returns {Promise}
     */
    async getTXMap(D) {
      return this.getMap(J.T.encode(D));
    }
    /**
     * Add wid to a wallet map.
     * @param {Wallet} wallet
     * @param {Buffer} key
     * @param {Number} wid
     */
    async addTXMap(D, Q, Z) {
      return this.addMap(D, J.T.encode(Q), Z);
    }
    /**
     * Remove wid from a wallet map.
     * @param {Wallet} wallet
     * @param {Buffer} key
     * @param {Number} wid
     */
    async removeTXMap(D, Q, Z) {
      return this.removeMap(D, J.T.encode(Q), Z);
    }
    /**
     * Get a wallet map.
     * @param {Buffer} key
     * @returns {Promise}
     */
    async getOutpointMap(D, Q) {
      return this.getMap(J.o.encode(D, Q));
    }
    /**
     * Add wid to a wallet map.
     * @param {Wallet} wallet
     * @param {Buffer} key
     * @param {Number} wid
     */
    async addOutpointMap(D, Q, Z, oe) {
      return await this.addOutpoint(Q, Z), this.addMap(D, J.o.encode(Q, Z), oe);
    }
    /**
     * Remove wid from a wallet map.
     * @param {Wallet} wallet
     * @param {Buffer} key
     * @param {Number} wid
     */
    async removeOutpointMap(D, Q, Z, oe) {
      return this.removeMap(D, J.o.encode(Q, Z), oe);
    }
    /**
     * Get a wallet block meta.
     * @param {Hash} hash
     * @returns {Promise}
     */
    async getBlock(D) {
      const Q = await this.db.get(J.h.encode(D));
      if (!Q)
        return null;
      const Z = new A();
      return Z.hash = Q, Z.height = D, Z;
    }
    /**
     * Get wallet tip.
     * @param {Hash} hash
     * @returns {Promise}
     */
    async getTip() {
      const D = await this.getBlock(this.state.height);
      if (!D)
        throw new Error("WDB: Tip not found!");
      return D;
    }
    /**
     * Sync with chain height.
     * @param {Number} height
     * @returns {Promise}
     */
    async rollback(D) {
      if (D > this.state.height)
        throw new Error("WDB: Cannot rollback to the future.");
      if (D === this.state.height) {
        this.logger.info("Rolled back to same height (%d).", D);
        return;
      }
      this.logger.info(
        "Rolling back %d WalletDB blocks to height %d.",
        this.state.height - D,
        D
      );
      const Q = await this.getBlock(D);
      e(Q), await this.revert(Q.height), await this.setTip(Q);
    }
    /**
     * Revert TXDB to an older state.
     * @param {Number} target
     * @returns {Promise}
     */
    async revert(D) {
      const Q = this.db.iterator({
        gte: J.b.encode(D + 1),
        lte: J.b.max(),
        reverse: !0,
        values: !0
      });
      let Z = 0;
      await Q.each(async (oe, y) => {
        const [Y] = J.b.decode(oe), he = _.fromRaw(y);
        for (const be of he.wids) {
          const xe = await this.get(be);
          e(xe), Z += await xe.revert(Y);
        }
      }), this.logger.info("Rolled back %d WalletDB transactions.", Z);
    }
    /**
     * Add a block's transactions and write the new best hash.
     * @param {ChainEntry} entry
     * @returns {Promise}
     */
    async addBlock(D, Q) {
      const Z = await this.txLock.lock();
      try {
        return await this._addBlock(D, Q);
      } finally {
        Z();
      }
    }
    /**
     * Add a block's transactions without a lock.
     * @private
     * @param {ChainEntry} entry
     * @param {TX[]} txs
     * @returns {Promise}
     */
    async _addBlock(D, Q) {
      const Z = A.fromEntry(D);
      if (Z.height < this.state.height)
        return this.logger.warning(
          "WalletDB is connecting low blocks (%d).",
          Z.height
        ), 0;
      if (Z.height >= this.network.block.slowHeight && this.logger.debug("Adding block: %d.", Z.height), Z.height === this.state.height)
        this.logger.warning("Already saw WalletDB block (%d).", Z.height);
      else if (Z.height !== this.state.height + 1)
        return await this.scan(this.state.height), 0;
      let oe = 0;
      try {
        this.confirming = !0;
        for (const y of Q)
          await this._addTX(y, Z) && (oe += 1);
        await this.setTip(Z);
      } finally {
        this.confirming = !1;
      }
      return oe > 0 && this.logger.info(
        "Connected WalletDB block %h (tx=%d).",
        Z.hash,
        oe
      ), oe;
    }
    /**
     * Unconfirm a block's transactions
     * and write the new best hash (SPV version).
     * @param {ChainEntry} entry
     * @returns {Promise}
     */
    async removeBlock(D) {
      const Q = await this.txLock.lock();
      try {
        return await this._removeBlock(D);
      } finally {
        Q();
      }
    }
    /**
     * Unconfirm a block's transactions.
     * @private
     * @param {ChainEntry} entry
     * @returns {Promise}
     */
    async _removeBlock(D) {
      const Q = A.fromEntry(D);
      if (Q.height === 0)
        throw new Error("WDB: Bad disconnection (genesis block).");
      if (Q.height > this.state.height)
        return this.logger.warning(
          "WalletDB is disconnecting high blocks (%d).",
          Q.height
        ), 0;
      if (Q.height !== this.state.height)
        throw new Error("WDB: Bad disconnection (height mismatch).");
      const Z = await this.getBlock(Q.height - 1);
      e(Z);
      const oe = await this.getBlockMap(Q.height);
      if (!oe)
        return await this.setTip(Z), 0;
      let y = 0;
      for (const Y of oe.wids) {
        const he = await this.get(Y);
        e(he), y += await he.revert(Q.height);
      }
      return await this.setTip(Z), this.logger.warning(
        "Disconnected wallet block %h (tx=%d).",
        Q.hash,
        y
      ), y;
    }
    /**
     * Rescan a block.
     * @private
     * @param {ChainEntry} entry
     * @param {TX[]} txs
     * @returns {Promise}
     */
    async rescanBlock(D, Q) {
      if (!this.rescanning) {
        this.logger.warning("Unsolicited rescan block: %d.", D.height);
        return;
      }
      if (D.height > this.state.height + 1) {
        this.logger.warning("Rescan block too high: %d.", D.height);
        return;
      }
      try {
        await this._addBlock(D, Q);
      } catch (Z) {
        throw this.emit("error", Z), Z;
      }
    }
    /**
     * Add a transaction to the database, map addresses
     * to wallet IDs, potentially store orphans, resolve
     * orphans, or confirm a transaction.
     * @param {TX} tx
     * @param {BlockMeta?} block
     * @returns {Promise}
     */
    async addTX(D, Q) {
      const Z = await this.txLock.lock();
      try {
        return await this._addTX(D, Q);
      } finally {
        Z();
      }
    }
    /**
     * Add a transaction to the database without a lock.
     * @private
     * @param {TX} tx
     * @param {BlockMeta} block
     * @returns {Promise}
     */
    async _addTX(D, Q) {
      const Z = await this.getWalletsByTX(D);
      if (e(!D.mutable, "WDB: Cannot add mutable TX."), !Z)
        return null;
      Q && !this.state.marked && await this.markState(Q), this.logger.info(
        "Incoming transaction for %d wallets in WalletDB (%h).",
        Z.size,
        D.hash()
      );
      let oe = !1;
      for (const y of Z) {
        const Y = await this.get(y);
        e(Y), await Y.add(D, Q) && (this.logger.info(
          "Added transaction to wallet in WalletDB: %s (%d).",
          Y.id,
          y
        ), oe = !0);
      }
      return oe ? Z : null;
    }
    /**
     * Handle a chain reset.
     * @param {ChainEntry} entry
     * @returns {Promise}
     */
    async resetChain(D) {
      const Q = await this.txLock.lock();
      try {
        return await this._resetChain(D);
      } finally {
        Q();
      }
    }
    /**
     * Handle a chain reset without a lock.
     * @private
     * @param {ChainEntry} entry
     * @returns {Promise}
     */
    async _resetChain(D) {
      if (D.height > this.state.height)
        throw new Error("WDB: Bad reset height.");
      return this.rollback(D.height);
    }
  }
  class R {
    /**
     * Create wallet options.
     * @constructor
     * @param {Object} options
     */
    constructor(D) {
      this.network = m.primary, this.logger = s.global, this.workers = null, this.client = null, this.feeRate = 0, this.prefix = null, this.location = null, this.memory = !0, this.maxFiles = 64, this.cacheSize = 16 << 20, this.compression = !0, this.spv = !1, this.checkpoints = !1, this.wipeNoReally = !1, D && this.fromOptions(D);
    }
    /**
     * Inject properties from object.
     * @private
     * @param {Object} options
     * @returns {WalletOptions}
     */
    fromOptions(D) {
      return D.network != null && (this.network = m.get(D.network)), D.logger != null && (e(typeof D.logger == "object"), this.logger = D.logger), D.workers != null && (e(typeof D.workers == "object"), this.workers = D.workers), D.client != null && (e(typeof D.client == "object"), this.client = D.client), D.feeRate != null && (e(D.feeRate >>> 0 === D.feeRate), this.feeRate = D.feeRate), D.prefix != null && (e(typeof D.prefix == "string"), this.prefix = D.prefix, this.location = c.join(this.prefix, "wallet")), D.location != null && (e(typeof D.location == "string"), this.location = D.location), D.memory != null && (e(typeof D.memory == "boolean"), this.memory = D.memory), D.maxFiles != null && (e(D.maxFiles >>> 0 === D.maxFiles), this.maxFiles = D.maxFiles), D.cacheSize != null && (e(Number.isSafeInteger(D.cacheSize) && D.cacheSize >= 0), this.cacheSize = D.cacheSize), D.compression != null && (e(typeof D.compression == "boolean"), this.compression = D.compression), D.spv != null && (e(typeof D.spv == "boolean"), this.spv = D.spv), D.checkpoints != null && (e(typeof D.checkpoints == "boolean"), this.checkpoints = D.checkpoints), D.wipeNoReally != null && (e(typeof D.wipeNoReally == "boolean"), this.wipeNoReally = D.wipeNoReally), this;
    }
    /**
     * Instantiate chain options from object.
     * @param {Object} options
     * @returns {WalletOptions}
     */
    static fromOptions(D) {
      return new this().fromOptions(D);
    }
  }
  function V(ae) {
    const D = k.allocUnsafe(4);
    return D.writeUInt32LE(ae, 0, !0), D;
  }
  function fe(ae) {
    const D = k.alloc(1 + ae.length);
    return D[0] = ae.length, D.write(ae, 1, ae.length, "ascii"), D;
  }
  function ue(ae) {
    return e(ae.length > 0), e(ae[0] === ae.length - 1), ae.toString("ascii", 1, ae.length);
  }
  return th = F, th;
}
var rh = {}, ih, O3;
function l7() {
  if (O3) return ih;
  O3 = 1;
  const e = Mt(), c = ni(), d = 2147483648, w = new Uint32Array([
    1,
    0,
    32898,
    0,
    32906,
    2147483648,
    2147516416,
    2147483648,
    32907,
    0,
    2147483649,
    0,
    2147516545,
    2147483648,
    32777,
    2147483648,
    138,
    0,
    136,
    0,
    2147516425,
    0,
    2147483658,
    0,
    2147516555,
    0,
    139,
    2147483648,
    32905,
    2147483648,
    32771,
    2147483648,
    32770,
    2147483648,
    128,
    2147483648,
    32778,
    0,
    2147483658,
    2147483648,
    2147516545,
    2147483648,
    32896,
    2147483648,
    2147483649,
    0,
    2147516424,
    2147483648
  ]);
  class g {
    constructor() {
      this.state = new Uint32Array(50), this.block = k.alloc(200), this.bs = 136, this.pos = d;
    }
    init(u) {
      u == null && (u = 256), e(u >>> 0 === u), e(u >= 128), e(u <= 512);
      const a = 1600 - u * 2;
      return e(a >= 0 && (a & 63) === 0), this.bs = a >>> 3, this.pos = 0, this;
    }
    update(u) {
      e(k.isBuffer(u)), e(!(this.pos & d), "Context is not initialized.");
      let a = u.length, s = this.pos, i = 0;
      if (this.pos = (this.pos + a) % this.bs, s > 0) {
        let p = this.bs - s;
        if (p > a && (p = a), u.copy(this.block, s, i, i + p), s += p, a -= p, i += p, s < this.bs)
          return this;
        this._transform(this.block, 0);
      }
      for (; a >= this.bs; )
        this._transform(u, i), i += this.bs, a -= this.bs;
      return a > 0 && u.copy(this.block, 0, i, i + a), this;
    }
    final(u, a) {
      u == null && (u = 1), (a == null || a === 0) && (a = 100 - (this.bs >>> 1)), e((u & 255) === u), e(a >>> 0 === a), e(!(this.pos & d), "Context is not initialized."), this.block.fill(0, this.pos, this.bs), this.block[this.pos] |= u, this.block[this.bs - 1] |= 128, this._transform(this.block, 0), this.pos = d, e(a <= this.bs);
      const s = k.alloc(a);
      for (let i = 0; i < a; i++)
        s[i] = this.state[i >>> 2] >>> 8 * (i & 3);
      for (let i = 0; i < 50; i++)
        this.state[i] = 0;
      for (let i = 0; i < this.bs; i++)
        this.block[i] = 0;
      return s;
    }
    _transform(u, a) {
      const s = this.bs >>> 2, i = this.state;
      for (let p = 0; p < s; p++)
        i[p] ^= f(u, a + p * 4);
      for (let p = 0; p < 48; p += 2) {
        const m = i[0] ^ i[10] ^ i[20] ^ i[30] ^ i[40], E = i[1] ^ i[11] ^ i[21] ^ i[31] ^ i[41], v = i[2] ^ i[12] ^ i[22] ^ i[32] ^ i[42], b = i[3] ^ i[13] ^ i[23] ^ i[33] ^ i[43], h = i[4] ^ i[14] ^ i[24] ^ i[34] ^ i[44], o = i[5] ^ i[15] ^ i[25] ^ i[35] ^ i[45], S = i[6] ^ i[16] ^ i[26] ^ i[36] ^ i[46], H = i[7] ^ i[17] ^ i[27] ^ i[37] ^ i[47], j = i[8] ^ i[18] ^ i[28] ^ i[38] ^ i[48], J = i[9] ^ i[19] ^ i[29] ^ i[39] ^ i[49], N = j ^ (v << 1 | b >>> 31), z = J ^ (b << 1 | v >>> 31), A = m ^ (h << 1 | o >>> 31), q = E ^ (o << 1 | h >>> 31), _ = v ^ (S << 1 | H >>> 31), F = b ^ (H << 1 | S >>> 31), R = h ^ (j << 1 | J >>> 31), V = o ^ (J << 1 | j >>> 31), fe = S ^ (m << 1 | E >>> 31), ue = H ^ (E << 1 | m >>> 31);
        i[0] ^= N, i[1] ^= z, i[10] ^= N, i[11] ^= z, i[20] ^= N, i[21] ^= z, i[30] ^= N, i[31] ^= z, i[40] ^= N, i[41] ^= z, i[2] ^= A, i[3] ^= q, i[12] ^= A, i[13] ^= q, i[22] ^= A, i[23] ^= q, i[32] ^= A, i[33] ^= q, i[42] ^= A, i[43] ^= q, i[4] ^= _, i[5] ^= F, i[14] ^= _, i[15] ^= F, i[24] ^= _, i[25] ^= F, i[34] ^= _, i[35] ^= F, i[44] ^= _, i[45] ^= F, i[6] ^= R, i[7] ^= V, i[16] ^= R, i[17] ^= V, i[26] ^= R, i[27] ^= V, i[36] ^= R, i[37] ^= V, i[46] ^= R, i[47] ^= V, i[8] ^= fe, i[9] ^= ue, i[18] ^= fe, i[19] ^= ue, i[28] ^= fe, i[29] ^= ue, i[38] ^= fe, i[39] ^= ue, i[48] ^= fe, i[49] ^= ue;
        const ae = i[0], D = i[1], Q = i[11] << 4 | i[10] >>> 28, Z = i[10] << 4 | i[11] >>> 28, oe = i[20] << 3 | i[21] >>> 29, y = i[21] << 3 | i[20] >>> 29, Y = i[31] << 9 | i[30] >>> 23, he = i[30] << 9 | i[31] >>> 23, be = i[40] << 18 | i[41] >>> 14, xe = i[41] << 18 | i[40] >>> 14, Ie = i[2] << 1 | i[3] >>> 31, ve = i[3] << 1 | i[2] >>> 31, C = i[13] << 12 | i[12] >>> 20, I = i[12] << 12 | i[13] >>> 20, se = i[22] << 10 | i[23] >>> 22, t = i[23] << 10 | i[22] >>> 22, l = i[33] << 13 | i[32] >>> 19, B = i[32] << 13 | i[33] >>> 19, U = i[42] << 2 | i[43] >>> 30, G = i[43] << 2 | i[42] >>> 30, T = i[5] << 30 | i[4] >>> 2, M = i[4] << 30 | i[5] >>> 2, $ = i[14] << 6 | i[15] >>> 26, r = i[15] << 6 | i[14] >>> 26, x = i[25] << 11 | i[24] >>> 21, O = i[24] << 11 | i[25] >>> 21, L = i[34] << 15 | i[35] >>> 17, X = i[35] << 15 | i[34] >>> 17, P = i[45] << 29 | i[44] >>> 3, K = i[44] << 29 | i[45] >>> 3, re = i[6] << 28 | i[7] >>> 4, ce = i[7] << 28 | i[6] >>> 4, le = i[17] << 23 | i[16] >>> 9, me = i[16] << 23 | i[17] >>> 9, ne = i[26] << 25 | i[27] >>> 7, W = i[27] << 25 | i[26] >>> 7, te = i[36] << 21 | i[37] >>> 11, pe = i[37] << 21 | i[36] >>> 11, Ee = i[47] << 24 | i[46] >>> 8, Ae = i[46] << 24 | i[47] >>> 8, Oe = i[8] << 27 | i[9] >>> 5, Be = i[9] << 27 | i[8] >>> 5, ke = i[18] << 20 | i[19] >>> 12, Ne = i[19] << 20 | i[18] >>> 12, Ke = i[29] << 7 | i[28] >>> 25, Ce = i[28] << 7 | i[29] >>> 25, Ye = i[38] << 8 | i[39] >>> 24, vt = i[39] << 8 | i[38] >>> 24, Ve = i[48] << 14 | i[49] >>> 18, Xe = i[49] << 14 | i[48] >>> 18;
        i[0] = ae ^ ~C & x, i[1] = D ^ ~I & O, i[10] = re ^ ~ke & oe, i[11] = ce ^ ~Ne & y, i[20] = Ie ^ ~$ & ne, i[21] = ve ^ ~r & W, i[30] = Oe ^ ~Q & se, i[31] = Be ^ ~Z & t, i[40] = T ^ ~le & Ke, i[41] = M ^ ~me & Ce, i[2] = C ^ ~x & te, i[3] = I ^ ~O & pe, i[12] = ke ^ ~oe & l, i[13] = Ne ^ ~y & B, i[22] = $ ^ ~ne & Ye, i[23] = r ^ ~W & vt, i[32] = Q ^ ~se & L, i[33] = Z ^ ~t & X, i[42] = le ^ ~Ke & Y, i[43] = me ^ ~Ce & he, i[4] = x ^ ~te & Ve, i[5] = O ^ ~pe & Xe, i[14] = oe ^ ~l & P, i[15] = y ^ ~B & K, i[24] = ne ^ ~Ye & be, i[25] = W ^ ~vt & xe, i[34] = se ^ ~L & Ee, i[35] = t ^ ~X & Ae, i[44] = Ke ^ ~Y & U, i[45] = Ce ^ ~he & G, i[6] = te ^ ~Ve & ae, i[7] = pe ^ ~Xe & D, i[16] = l ^ ~P & re, i[17] = B ^ ~K & ce, i[26] = Ye ^ ~be & Ie, i[27] = vt ^ ~xe & ve, i[36] = L ^ ~Ee & Oe, i[37] = X ^ ~Ae & Be, i[46] = Y ^ ~U & T, i[47] = he ^ ~G & M, i[8] = Ve ^ ~ae & C, i[9] = Xe ^ ~D & I, i[18] = P ^ ~re & ke, i[19] = K ^ ~ce & Ne, i[28] = be ^ ~Ie & $, i[29] = xe ^ ~ve & r, i[38] = Ee ^ ~Oe & Q, i[39] = Ae ^ ~Be & Z, i[48] = U ^ ~T & le, i[49] = G ^ ~M & me, i[0] ^= w[p + 0], i[1] ^= w[p + 1];
      }
    }
    static hash() {
      return new g();
    }
    static hmac(u, a, s) {
      u == null && (u = 256), e(u >>> 0 === u);
      const i = 1600 - u * 2;
      return e(i >= 0 && (i & 63) === 0), new c(g, i >>> 3, [u], [a, s]);
    }
    static digest(u, a, s, i) {
      return g.ctx.init(a).update(u).final(s, i);
    }
    static root(u, a, s, i, p) {
      return s == null && (s = 256), p == null && (p = 0), p === 0 && (p = s >>> 3), e(s >>> 0 === s), e((s & 7) === 0), e(p >>> 0 === p), e(k.isBuffer(u) && u.length === p), e(k.isBuffer(a) && a.length === p), g.ctx.init(s).update(u).update(a).final(i, p);
    }
    static multi(u, a, s, i, p, m) {
      const { ctx: E } = g;
      return E.init(i), E.update(u), E.update(a), s && E.update(s), E.final(p, m);
    }
    static mac(u, a, s, i, p) {
      return g.hmac(s, i, p).init(a).update(u).final();
    }
  }
  g.native = 0, g.id = "KECCAK256", g.size = 32, g.bits = 256, g.blockSize = 136, g.zero = k.alloc(32, 0), g.ctx = new g();
  function f(n, u) {
    return n[u++] + n[u++] * 256 + n[u++] * 65536 + n[u] * 16777216;
  }
  return ih = g, ih;
}
/*!
 * p224.js - ECDSA-P224 for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var nh, _3;
function Kx() {
  if (_3) return nh;
  _3 = 1;
  const e = es(), c = wr();
  return nh = new e("P224", c, c), nh;
}
/*!
 * p256.js - ECDSA-P256 for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var sh, R3;
function Vx() {
  if (R3) return sh;
  R3 = 1;
  const e = es(), c = wr();
  return sh = new e("P256", c, c), sh;
}
var oh, P3;
function d7() {
  if (P3) return oh;
  P3 = 1;
  const e = Mt(), c = gn(), d = ni();
  class w extends c {
    constructor() {
      super();
    }
    init() {
      return this.state[0] = 3418070365, this.state[1] = 3238371032, this.state[2] = 1654270250, this.state[3] = 914150663, this.state[4] = 2438529370, this.state[5] = 812702999, this.state[6] = 355462360, this.state[7] = 4144912697, this.state[8] = 1731405415, this.state[9] = 4290775857, this.state[10] = 2394180231, this.state[11] = 1750603025, this.state[12] = 3675008525, this.state[13] = 1694076839, this.state[14] = 1203062813, this.state[15] = 3204075428, this.size = 0, this;
    }
    final() {
      return super.final().slice(0, 48);
    }
    static hash() {
      return new w();
    }
    static hmac() {
      return new d(w, 128);
    }
    static digest(f) {
      return w.ctx.init().update(f).final();
    }
    static root(f, n) {
      return e(k.isBuffer(f) && f.length === 48), e(k.isBuffer(n) && n.length === 48), w.ctx.init().update(f).update(n).final();
    }
    static multi(f, n, u) {
      const { ctx: a } = w;
      return a.init(), a.update(f), a.update(n), u && a.update(u), a.final();
    }
    static mac(f, n) {
      return w.hmac().init(n).update(f).final();
    }
  }
  return w.native = 0, w.id = "SHA384", w.size = 48, w.bits = 384, w.blockSize = 128, w.zero = k.alloc(48, 0), w.ctx = new w(), oh = w, oh;
}
/*!
 * p384.js - ECDSA-P384 for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var ah, k3;
function $x() {
  if (k3) return ah;
  k3 = 1;
  const e = es(), c = d7();
  return ah = new e("P384", c, c), ah;
}
var fh, B3;
function b7() {
  if (B3) return fh;
  B3 = 1;
  const e = l7();
  class c extends e {
    /**
     * Create a SHAKE Context.
     * @constructor
     */
    constructor() {
      super();
    }
    final(w) {
      return super.final(31, w);
    }
    static hash() {
      return new c();
    }
    static hmac(w, g) {
      return super.hmac(w, 31, g);
    }
    static digest(w, g, f) {
      return super.digest(w, g, 31, f);
    }
    static root(w, g, f, n) {
      return super.root(w, g, f, 31, n);
    }
    static multi(w, g, f, n, u) {
      return super.multi(w, g, f, n, 31, u);
    }
    static mac(w, g, f, n) {
      return super.mac(w, g, f, 31, n);
    }
  }
  return c.native = e.native, c.id = "SHAKE256", c.size = 32, c.bits = 256, c.blockSize = 136, c.zero = k.alloc(32, 0), c.ctx = new c(), fh = c, fh;
}
var ch, M3;
function p7() {
  if (M3) return ch;
  M3 = 1;
  const e = b7();
  class c extends e {
    constructor() {
      super();
    }
    init() {
      return super.init(256);
    }
    static hash() {
      return new c();
    }
    static hmac(w) {
      return super.hmac(256, w);
    }
    static digest(w, g) {
      return super.digest(w, 256, g);
    }
    static root(w, g, f) {
      return super.root(w, g, 256, f);
    }
    static multi(w, g, f, n) {
      return super.multi(w, g, f, 256, n);
    }
    static mac(w, g, f) {
      return super.mac(w, g, 256, f);
    }
  }
  return c.native = e.native, c.id = "SHAKE256", c.size = 32, c.bits = 256, c.blockSize = 136, c.zero = k.alloc(32, 0), c.ctx = new c(), ch = c, ch;
}
/*!
 * p521.js - ECDSA-P521 for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var uh, N3;
function jx() {
  if (N3) return uh;
  N3 = 1;
  const e = es(), c = gn(), d = p7();
  return uh = new e("P521", c, d), uh;
}
var Tt = {}, Dn = {};
/*!
 * primes.js - Prime number generation for javascript
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on golang/go:
 *   Copyright (c) 2009, The Go Authors. All rights reserved.
 *   https://github.com/golang/go
 *
 * Parts of this software are based on indutny/miller-rabin:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/miller-rabin
 *
 * Resources:
 *   https://github.com/golang/go/blob/master/src/crypto/rsa/rsa.go
 *   https://github.com/golang/go/blob/master/src/math/big/prime.go
 *   https://github.com/golang/go/blob/master/src/math/big/int.go
 *   https://github.com/golang/go/blob/master/src/math/big/nat.go
 *   https://github.com/golang/go/blob/master/src/crypto/rand/util.go
 *   https://github.com/indutny/miller-rabin/blob/master/lib/mr.js
 */
var q3;
function Yx() {
  if (q3) return Dn;
  q3 = 1;
  const e = Mt(), c = Hr(), d = pi(), w = new Uint8Array([
    3,
    5,
    7,
    11,
    13,
    17,
    19,
    23,
    29,
    31,
    37,
    41,
    43,
    47,
    53
  ]), g = new c("16294579238595022365", 10), f = 10412 | 1 << 17 | 1 << 19 | 1 << 23 | 1 << 29 | 1 << 31, n = 35360 | 1 << 21 | 1 << 27 | 1 << 29, u = new c(1155 * 13 * 17 * 19 * 23 * 37), a = new c(899 * 41 * 43 * 47 * 53);
  function s(m, E = 20, v = d) {
    if (e(m >>> 0 === m), e(E >>> 0 === E), e(v != null), m < 2)
      throw new Error("Prime must be at least 2 bits.");
    for (; ; ) {
      const b = c.randomBits(v, m);
      b.setn(m - 1, 1), b.setn(m - 2, 1), b.setn(0, 1);
      const h = b.mod(g);
      e:
        for (let o = 0; o < 1 << 20; o += 2) {
          const S = h.addn(o);
          for (let H = 0; H < w.length; H++) {
            const j = w[H];
            if (S.modrn(j) === 0 && (m > 6 || S.cmpn(j) !== 0))
              continue e;
          }
          b.iaddn(o);
          break;
        }
      if (b.bitLength() === m && i(b, E, v))
        return b;
    }
  }
  function i(m, E, v = d) {
    if (e(m instanceof c), m.sign() <= 0)
      return !1;
    if (m.cmpn(64) < 0) {
      const o = m.word(0);
      return o > 31 ? (n & 1 << o - 32) !== 0 : (f & 1 << o) !== 0;
    }
    if (m.isEven())
      return !1;
    const b = m.mod(u).toNumber(), h = m.mod(a).toNumber();
    return b % 3 === 0 || b % 5 === 0 || b % 7 === 0 || b % 11 === 0 || b % 13 === 0 || b % 17 === 0 || b % 19 === 0 || b % 23 === 0 || b % 37 === 0 || h % 29 === 0 || h % 31 === 0 || h % 41 === 0 || h % 43 === 0 || h % 47 === 0 || h % 53 === 0 ? !1 : m.isPrime(v, E);
  }
  function p(m, E, v) {
    if (!i(m, E, v))
      return !1;
    const b = m.subn(1).iushrn(1);
    return !!i(b, E, v);
  }
  return Dn.randomPrime = s, Dn.isProbablePrime = i, Dn.isSafePrime = p, Dn;
}
var Wr = {}, z3;
function Xx() {
  if (z3) return Wr;
  z3 = 1;
  const e = Mt(), c = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", d = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", w = [
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    62,
    -1,
    -1,
    -1,
    63,
    52,
    53,
    54,
    55,
    56,
    57,
    58,
    59,
    60,
    61,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    16,
    17,
    18,
    19,
    20,
    21,
    22,
    23,
    24,
    25,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    26,
    27,
    28,
    29,
    30,
    31,
    32,
    33,
    34,
    35,
    36,
    37,
    38,
    39,
    40,
    41,
    42,
    43,
    44,
    45,
    46,
    47,
    48,
    49,
    50,
    51,
    -1,
    -1,
    -1,
    -1,
    -1
  ], g = [
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    62,
    -1,
    -1,
    52,
    53,
    54,
    55,
    56,
    57,
    58,
    59,
    60,
    61,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    16,
    17,
    18,
    19,
    20,
    21,
    22,
    23,
    24,
    25,
    -1,
    -1,
    -1,
    -1,
    63,
    -1,
    26,
    27,
    28,
    29,
    30,
    31,
    32,
    33,
    34,
    35,
    36,
    37,
    38,
    39,
    40,
    41,
    42,
    43,
    44,
    45,
    46,
    47,
    48,
    49,
    50,
    51,
    -1,
    -1,
    -1,
    -1,
    -1
  ];
  function f(h, o, S) {
    e(k.isBuffer(h));
    let H = h.length, j = "", J = 0;
    for (; H >= 3; ) {
      const N = h[J++], z = h[J++], A = h[J++];
      j += o[N >> 2], j += o[(N & 3) << 4 | z >> 4], j += o[(z & 15) << 2 | A >> 6], j += o[A & 63], H -= 3;
    }
    switch (H) {
      case 1: {
        const N = h[J++];
        j += o[N >> 2], j += o[(N & 3) << 4], S && (j += "==");
        break;
      }
      case 2: {
        const N = h[J++], z = h[J++];
        j += o[N >> 2], j += o[(N & 3) << 4 | z >> 4], j += o[(z & 15) << 2], S && (j += "=");
        break;
      }
    }
    return j;
  }
  function n(h, o, S) {
    e(typeof h == "string");
    const H = k.alloc(S);
    let j = h.length, J = 0, N = 0;
    if (j > 0 && h[j - 1] === "=" && (j -= 1), j > 0 && h[j - 1] === "=" && (j -= 1), (j & 3) === 1)
      throw new Error("Invalid base64 string.");
    for (; j >= 4; ) {
      const z = h.charCodeAt(J++), A = h.charCodeAt(J++), q = h.charCodeAt(J++), _ = h.charCodeAt(J++);
      if ((z | A | q | _) & 65408)
        throw new Error("Invalid base64 string.");
      const F = o[z], R = o[A], V = o[q], fe = o[_];
      if ((F | R | V | fe) < 0)
        throw new Error("Invalid base64 string.");
      H[N++] = F << 2 | R >> 4, H[N++] = R << 4 | V >> 2, H[N++] = V << 6 | fe >> 0, j -= 4;
    }
    switch (j) {
      case 1:
        throw new Error("Invalid base64 string.");
      case 2: {
        const z = h.charCodeAt(J++), A = h.charCodeAt(J++);
        if ((z | A) & 65408)
          throw new Error("Invalid base64 string.");
        const q = o[z], _ = o[A];
        if ((q | _) < 0)
          throw new Error("Invalid base64 string.");
        if (H[N++] = q << 2 | _ >> 4, _ & 15)
          throw new Error("Invalid base64 string.");
        break;
      }
      case 3: {
        const z = h.charCodeAt(J++), A = h.charCodeAt(J++), q = h.charCodeAt(J++);
        if ((z | A | q) & 65408)
          throw new Error("Invalid base64 string.");
        const _ = o[z], F = o[A], R = o[q];
        if ((_ | F | R) < 0)
          throw new Error("Invalid base64 string.");
        if (H[N++] = _ << 2 | F >> 4, H[N++] = F << 4 | R >> 2, R & 3)
          throw new Error("Invalid base64 string.");
        break;
      }
    }
    return e(N === S), H;
  }
  function u(h, o) {
    e(typeof h == "string");
    let S = h.length;
    if (S > 0 && h[S - 1] === "=" && (S -= 1), S > 0 && h[S - 1] === "=" && (S -= 1), (S & 3) === 1)
      return !1;
    for (let H = 0; H < S; H++) {
      const j = h.charCodeAt(H);
      if (j & 65408 || o[j] === -1)
        return !1;
    }
    switch (S & 3) {
      case 1:
        return !1;
      case 2:
        return (o[h.charCodeAt(S - 1)] & 15) === 0;
      case 3:
        return (o[h.charCodeAt(S - 1)] & 3) === 0;
    }
    return !0;
  }
  function a(h) {
    return f(h, c, !0);
  }
  function s(h) {
    const o = v(h);
    if (!b(h, o))
      throw new Error("Invalid base64 padding.");
    return n(h, w, o);
  }
  function i(h) {
    const o = v(h);
    return b(h, o) ? u(h, w) : !1;
  }
  function p(h) {
    return f(h, d, !1);
  }
  function m(h) {
    const o = v(h);
    if (!b(h, 0))
      throw new Error("Invalid base64 padding.");
    return n(h, g, o);
  }
  function E(h) {
    return b(h, 0) ? u(h, g) : !1;
  }
  function v(h) {
    e(typeof h == "string");
    let o = h.length;
    o > 0 && h[o - 1] === "=" && (o -= 1), o > 0 && h[o - 1] === "=" && (o -= 1);
    let S = (o >>> 2) * 3;
    const H = o & 3;
    return H && (S += H - 1), S;
  }
  function b(h, o) {
    switch (e(typeof h == "string"), o % 3) {
      case 0:
        return h.length === 0 ? !0 : h.length === 1 ? h[0] !== "=" : h[h.length - 2] !== "=" && h[h.length - 1] !== "=";
      case 1:
        return h.length >= 4 && h[h.length - 2] === "=" && h[h.length - 1] === "=";
      case 2:
        return h.length >= 4 && h[h.length - 2] !== "=" && h[h.length - 1] === "=";
      default:
        throw new Error("unreachable");
    }
  }
  return Wr.native = 0, Wr.encode = a, Wr.decode = s, Wr.test = i, Wr.encodeURL = p, Wr.decodeURL = m, Wr.testURL = E, Wr;
}
var T3;
function Jx() {
  if (T3) return Tt;
  T3 = 1;
  const e = Mt(), c = Hr(), d = pi(), { randomPrime: w } = Yx(), g = Xx(), f = Yb(), n = Ol(), {
    safeEqual: u,
    safeEqualByte: a,
    safeSelect: s,
    safeLTE: i
  } = n, p = 2048, m = 65537, E = 512, v = 16384, b = 3, h = 2 ** 33 - 1, o = 33, S = 0, H = -1, j = k.alloc(8, 0), J = k.alloc(0), N = {
    __proto__: null,
    BLAKE2B160: k.from("3027300f060b2b060104018d3a0c02010505000414", "hex"),
    BLAKE2B256: k.from("3033300f060b2b060104018d3a0c02010805000420", "hex"),
    BLAKE2B384: k.from("3043300f060b2b060104018d3a0c02010c05000430", "hex"),
    BLAKE2B512: k.from("3053300f060b2b060104018d3a0c02011005000440", "hex"),
    BLAKE2S128: k.from("3023300f060b2b060104018d3a0c02020405000410", "hex"),
    BLAKE2S160: k.from("3027300f060b2b060104018d3a0c02020505000414", "hex"),
    BLAKE2S224: k.from("302f300f060b2b060104018d3a0c0202070500041c", "hex"),
    BLAKE2S256: k.from("3033300f060b2b060104018d3a0c02020805000420", "hex"),
    GOST94: k.from("302e300a06062a850302021405000420", "hex"),
    HASH160: k.from([20]),
    HASH256: k.from([32]),
    KECCAK224: k.from([28]),
    KECCAK256: k.from([32]),
    KECCAK384: k.from([48]),
    KECCAK512: k.from([64]),
    MD2: k.from("3020300c06082a864886f70d020205000410", "hex"),
    MD4: k.from("3020300c06082a864886f70d020405000410", "hex"),
    MD5: k.from("3020300c06082a864886f70d020505000410", "hex"),
    MD5SHA1: k.from([36]),
    RIPEMD160: k.from("3021300906052b2403020105000414", "hex"),
    SHA1: k.from("3021300906052b0e03021a05000414", "hex"),
    SHA224: k.from("302d300d06096086480165030402040500041c", "hex"),
    SHA256: k.from("3031300d060960864801650304020105000420", "hex"),
    SHA384: k.from("3041300d060960864801650304020205000430", "hex"),
    SHA512: k.from("3051300d060960864801650304020305000440", "hex"),
    SHA3_224: k.from("302d300d06096086480165030402070500041c", "hex"),
    SHA3_256: k.from("3031300d060960864801650304020805000420", "hex"),
    SHA3_384: k.from("3041300d060960864801650304020905000430", "hex"),
    SHA3_512: k.from("3051300d060960864801650304020a05000440", "hex"),
    SHAKE128: k.from("3021300d060960864801650304020b05000410", "hex"),
    SHAKE256: k.from("3031300d060960864801650304020c05000420", "hex"),
    WHIRLPOOL: k.from("304e300a060628cf0603003705000440", "hex")
  };
  class z {
    constructor() {
      this.n = new c(0), this.e = new c(0);
    }
    bits() {
      return this.n.bitLength();
    }
    size() {
      return this.n.byteLength();
    }
    isSane() {
      return this.n.sign() > 0 && this.e.sign() > 0 && this.n.bitLength() <= v && this.e.bitLength() <= o;
    }
    verify() {
      return !(!this.isSane() || this.n.bitLength() < E || !this.n.isOdd() || this.e.cmpn(b) < 0 || !this.e.isOdd());
    }
    encrypt(M) {
      e(k.isBuffer(M));
      const { n: $, e: r } = this, x = c.decode(M);
      if (x.cmp($) >= 0)
        throw new Error("Invalid RSA message size.");
      return x.powm(r, $).encode("be", $.byteLength());
    }
    encode() {
      const M = f.sizeInt(this.n) + f.sizeInt(this.e), $ = k.alloc(f.sizeSeq(M));
      let r = 0;
      return r = f.writeSeq($, r, M), r = f.writeInt($, r, this.n), r = f.writeInt($, r, this.e), e(r === $.length), $;
    }
    decode(M) {
      let $ = 0;
      if ($ = f.readSeq(M, $), [this.n, $] = f.readInt(M, $), [this.e, $] = f.readInt(M, $), $ !== M.length)
        throw new Error("Trailing bytes.");
      return this;
    }
    static decode(M) {
      return new z().decode(M);
    }
  }
  class A extends z {
    constructor() {
      super(), this.d = new c(0), this.p = new c(0), this.q = new c(0), this.dp = new c(0), this.dq = new c(0), this.qi = new c(0);
    }
    isSane() {
      return this.n.sign() > 0 && this.e.sign() > 0 && this.d.sign() > 0 && this.p.sign() > 0 && this.q.sign() > 0 && this.dp.sign() > 0 && this.dq.sign() > 0 && this.qi.sign() > 0 && this.n.bitLength() <= v && this.e.bitLength() <= o && this.d.bitLength() <= v && this.p.bitLength() <= v && this.q.bitLength() <= v && this.dp.bitLength() <= v && this.dq.bitLength() <= v && this.qi.bitLength() <= v;
    }
    verify() {
      if (!this.isSane() || this.n.bitLength() < E || !this.n.isOdd() || this.e.cmpn(b) < 0 || !this.e.isOdd() || this.p.cmpn(3) < 0 || !this.p.isOdd() || this.q.cmpn(3) < 0 || !this.q.isOdd())
        return !1;
      const M = this.p.subn(1), $ = this.q.subn(1), r = M.mul($);
      if (this.d.cmpn(2) < 0 || this.d.cmp(r) >= 0 || this.dp.sign() === 0 || this.dp.cmp(M) >= 0 || this.dq.sign() === 0 || this.dq.cmp($) >= 0 || this.qi.cmpn(2) < 0 || this.qi.cmp(this.p) >= 0 || this.p.cmp(this.q) === 0 || this.p.mul(this.q).cmp(this.n) !== 0)
        return !1;
      const x = r.div(M.gcd($));
      return !(this.e.mul(this.d).imod(x).cmpn(1) !== 0 || this.d.mod(M).cmp(this.dp) !== 0 || this.d.mod($).cmp(this.dq) !== 0 || this.q.mul(this.qi).imod(this.p).cmpn(1) !== 0);
    }
    decrypt(M) {
      e(k.isBuffer(M));
      const { n: $, e: r, p: x, q: O, dp: L, dq: X, qi: P } = this, K = c.decode(M);
      if (K.cmp($) >= 0)
        throw new Error("Invalid RSA message size.");
      let re, ce;
      for (; ; ) {
        const te = c.random(d, 1, $);
        try {
          ce = te.invert($);
        } catch {
          continue;
        }
        re = te.powm(r, $);
        break;
      }
      K.imul(re).imod($);
      const le = K.powm(L, x, !0), me = K.powm(X, O, !0), W = le.sub(me).mul(P).imod(x).mul(O).iadd(me).imod($);
      if (W.powm(r, $).cmp(K) !== 0)
        throw new Error("Invalid RSA private key.");
      return W.imul(ce).imod($), W.encode("be", $.byteLength());
    }
    generate(M, $) {
      e(M >>> 0 === M), e(Number.isSafeInteger($) && $ >= 0), e(M >= 64), e($ >= 3 && ($ & 1) !== 0);
      const r = new c($);
      for (; ; ) {
        const x = w((M >>> 1) + (M & 1)), O = w(M >>> 1);
        if (x.cmp(O) === 0 || (x.cmp(O) < 0 && x.swap(O), x.sub(O).bitLength() <= (M >>> 1) - 99))
          continue;
        const L = x.mul(O);
        if (L.bitLength() !== M)
          continue;
        const X = x.subn(1), P = O.subn(1), K = X.mul(P);
        if (r.gcd(K).cmpn(1) !== 0)
          continue;
        const re = K.div(X.gcd(P)), ce = r.invert(re);
        if (ce.bitLength() <= M + 1 >>> 1)
          continue;
        const le = ce.mod(X), me = ce.mod(P), ne = O.invert(x);
        return this.n = L, this.e = r, this.d = ce, this.p = x, this.q = O, this.dp = le, this.dq = me, this.qi = ne, this;
      }
    }
    async _generateSubtle(M, $) {
      e(M >>> 0 === M), e(Number.isSafeInteger($) && $ >= 0), e(M >= 64), e($ >= 3 && ($ & 1) !== 0);
      const r = Lt.crypto || Lt.msCrypto;
      if (!r)
        throw new Error("Crypto API not available.");
      const { subtle: x } = r;
      if (!x || !x.generateKey || !x.exportKey)
        throw new Error("Subtle API not available.");
      const O = new c($), L = {
        name: "RSASSA-PKCS1-v1_5",
        modulusLength: M,
        publicExponent: O.toArrayLike(Uint8Array, "be", 8),
        hash: { name: "SHA-256" }
      }, X = await x.generateKey(L, !0, ["sign"]), P = await x.exportKey("jwk", X.privateKey), K = c.decode(g.decodeURL(P.p)), re = c.decode(g.decodeURL(P.q));
      return this.fromPQE(K, re, O);
    }
    async generateAsync(M, $) {
      try {
        return await this._generateSubtle(M, $);
      } catch {
        return this.generate(M, $);
      }
    }
    fromPQE(M, $, r) {
      if (e(M instanceof c), e($ instanceof c), e(r instanceof c), M.cmp($) < 0 && ([M, $] = [$, M]), M.cmp($) === 0)
        throw new Error("Invalid RSA private key.");
      if (M.cmpn(3) < 0 || M.bitLength() > v)
        throw new Error("Invalid RSA private key.");
      if ($.cmpn(3) < 0 || $.bitLength() > v)
        throw new Error("Invalid RSA private key.");
      if (r.cmpn(b) < 0 || r.bitLength() > o)
        throw new Error("Invalid RSA private key.");
      if (!M.isOdd() || !$.isOdd() || !r.isOdd())
        throw new Error("Invalid RSA private key.");
      const x = M.mul($);
      if (e(x.isOdd()), x.bitLength() < E || x.bitLength() > v)
        throw new Error("Invalid RSA private key.");
      const O = M.subn(1), L = $.subn(1), X = O.lcm(L), P = r.invert(X), K = P.mod(O), re = P.mod(L), ce = $.invert(M);
      return this.n = x, this.e = r, this.d = P, this.p = M, this.q = $, this.dp = K, this.dq = re, this.qi = ce, this;
    }
    fromPQD(M, $, r) {
      if (e(M instanceof c), e($ instanceof c), e(r instanceof c), M.cmpn(3) < 0 || M.bitLength() > v)
        throw new Error("Invalid RSA private key.");
      if ($.cmpn(3) < 0 || $.bitLength() > v)
        throw new Error("Invalid RSA private key.");
      if (!M.isOdd() || !$.isOdd())
        throw new Error("Invalid RSA private key.");
      const x = M.subn(1), O = $.subn(1), L = x.mul(O);
      if (r.cmpn(2) < 0 || r.cmp(L) >= 0)
        throw new Error("Invalid RSA private key.");
      const X = L.div(x.gcd(O)), P = r.invert(X);
      return this.fromPQE(M, $, P);
    }
    fromNED(M, $, r) {
      if (e(M instanceof c), e($ instanceof c), e(r instanceof c), M.sign() < 0)
        throw new Error("Invalid RSA private key.");
      if (M.bitLength() < E || M.bitLength() > v)
        throw new Error("Invalid RSA private key.");
      if ($.cmpn(b) < 0 || $.bitLength() > o)
        throw new Error("Invalid RSA private key.");
      if (r.cmpn(2) < 0 || r.bitLength() > v)
        throw new Error("Invalid RSA private key.");
      if (!M.isOdd() || !$.isOdd())
        throw new Error("Invalid RSA private key.");
      const x = $.mul(r).isubn(1), O = M.subn(1), L = x.zeroBits(), X = x.ushrn(L);
      for (let P = 0; P < 64; P++) {
        let re = c.random(d, 2, O).powm(X, M);
        if (!(re.cmpn(1) === 0 || re.cmp(O) === 0))
          for (let ce = 1; ce < L; ce++) {
            const le = re.sqr().imod(M);
            if (le.cmpn(1) === 0) {
              const me = M.gcd(re.subn(1)), ne = M.gcd(re.addn(1));
              return this.fromPQE(me, ne, $);
            }
            if (le.cmp(O) === 0)
              break;
            re = le;
          }
      }
      throw new Error("Invalid RSA private key.");
    }
    toPublic() {
      const M = new z();
      return M.n = this.n, M.e = this.e, M;
    }
    encode() {
      let M = 0;
      M += f.sizeVersion(0), M += f.sizeInt(this.n), M += f.sizeInt(this.e), M += f.sizeInt(this.d), M += f.sizeInt(this.p), M += f.sizeInt(this.q), M += f.sizeInt(this.dp), M += f.sizeInt(this.dq), M += f.sizeInt(this.qi);
      const $ = k.alloc(f.sizeSeq(M));
      let r = 0;
      return r = f.writeSeq($, r, M), r = f.writeVersion($, r, 0), r = f.writeInt($, r, this.n), r = f.writeInt($, r, this.e), r = f.writeInt($, r, this.d), r = f.writeInt($, r, this.p), r = f.writeInt($, r, this.q), r = f.writeInt($, r, this.dp), r = f.writeInt($, r, this.dq), r = f.writeInt($, r, this.qi), e(r === $.length), $;
    }
    decode(M) {
      let $ = 0;
      if ($ = f.readSeq(M, $), $ = f.readVersion(M, $, 0), [this.n, $] = f.readInt(M, $), [this.e, $] = f.readInt(M, $), [this.d, $] = f.readInt(M, $), [this.p, $] = f.readInt(M, $), [this.q, $] = f.readInt(M, $), [this.dp, $] = f.readInt(M, $), [this.dq, $] = f.readInt(M, $), [this.qi, $] = f.readInt(M, $), $ !== M.length)
        throw new Error("Trailing bytes.");
      return this;
    }
    static generate(M, $) {
      return new A().generate(M, $);
    }
    static async generateAsync(M, $) {
      return new A().generateAsync(M, $);
    }
    static fromPQE(M, $, r) {
      return new A().fromPQE(M, $, r);
    }
    static fromPQD(M, $, r) {
      return new A().fromPQD(M, $, r);
    }
    static fromNED(M, $, r) {
      return new A().fromNED(M, $, r);
    }
    static decode(M) {
      return new A().decode(M);
    }
  }
  function q(T, M) {
    if (T == null && (T = p), M == null && (M = m), e(T >>> 0 === T), e(Number.isSafeInteger(M) && M >= 0), T < E || T > v)
      throw new RangeError(`"bits" ranges from ${E} to ${v}.`);
    if (M < b || M > h)
      throw new RangeError(`"exponent" ranges from ${b} to ${h}.`);
    if (M === 1 || (M & 1) === 0)
      throw new RangeError('"exponent" must be odd.');
    return A.generate(T, M).encode();
  }
  async function _(T, M) {
    if (T == null && (T = p), M == null && (M = m), e(T >>> 0 === T), e(Number.isSafeInteger(M) && M >= 0), T < E || T > v)
      throw new RangeError(`"bits" ranges from ${E} to ${v}.`);
    if (M < b || M > h)
      throw new RangeError(`"exponent" ranges from ${b} to ${h}.`);
    if (M === 1 || (M & 1) === 0)
      throw new RangeError('"exponent" must be odd.');
    return (await A.generateAsync(T, M)).encode();
  }
  function F(T) {
    const M = A.decode(T);
    if (!M.verify())
      throw new Error("Invalid RSA private key.");
    return M.bits();
  }
  function R(T) {
    e(k.isBuffer(T));
    let M;
    try {
      M = A.decode(T);
    } catch {
      return !1;
    }
    return M.verify();
  }
  function V(T) {
    e(T && typeof T == "object");
    let M = new A();
    return T.n != null && (M.n = c.decode(T.n)), T.e != null && (M.e = c.decode(T.e)), T.d != null && (M.d = c.decode(T.d)), T.p != null && (M.p = c.decode(T.p)), T.q != null && (M.q = c.decode(T.q)), T.dp != null && (M.dp = c.decode(T.dp)), T.dq != null && (M.dq = c.decode(T.dq)), T.qi != null && (M.qi = c.decode(T.qi)), M.verify() || (!M.p.isZero() && !M.q.isZero() ? M.e.isZero() ? M = A.fromPQD(M.p, M.q, M.d) : M = A.fromPQE(M.p, M.q, M.e) : M = A.fromNED(M.n, M.e, M.d)), M.encode();
  }
  function fe(T) {
    const M = A.decode(T);
    if (!M.verify())
      throw new Error("Invalid RSA private key.");
    return {
      n: M.n.encode(),
      e: M.e.encode(),
      d: M.d.encode(),
      p: M.p.encode(),
      q: M.q.encode(),
      dp: M.dp.encode(),
      dq: M.dq.encode(),
      qi: M.qi.encode()
    };
  }
  function ue(T) {
    const M = A.decode(T);
    if (!M.verify())
      throw new Error("Invalid RSA private key.");
    return M.toPublic().encode();
  }
  function ae(T) {
    const M = z.decode(T);
    if (!M.verify())
      throw new Error("Invalid RSA public key.");
    return M.bits();
  }
  function D(T) {
    e(k.isBuffer(T));
    let M;
    try {
      M = z.decode(T);
    } catch {
      return !1;
    }
    return M.verify();
  }
  function Q(T) {
    e(T && typeof T == "object");
    const M = new z();
    if (T.n != null && (M.n = c.decode(T.n)), T.e != null && (M.e = c.decode(T.e)), !M.verify())
      throw new Error("Invalid RSA public key.");
    return M.encode();
  }
  function Z(T) {
    const M = z.decode(T);
    if (!M.verify())
      throw new Error("Invalid RSA public key.");
    return {
      n: M.n.encode(),
      e: M.e.encode()
    };
  }
  function oe(T, M, $) {
    T && typeof T.id == "string" && (T = T.id), e(T == null || typeof T == "string"), e(k.isBuffer(M));
    const [r, x] = l(T, M);
    if (!r)
      throw new Error("Unknown RSA hash function.");
    if (M.length !== x)
      throw new Error("Invalid RSA message size.");
    const O = A.decode($);
    if (!O.verify())
      throw new Error("Invalid RSA private key.");
    const L = r.length + x, X = O.size();
    if (X < L + 11)
      throw new Error("Invalid RSA message size.");
    const P = k.alloc(X);
    P[0] = 0, P[1] = 1;
    for (let K = 2; K < X - L - 1; K++)
      P[K] = 255;
    return P[X - L - 1] = 0, r.copy(P, X - L), M.copy(P, X - x), O.decrypt(P);
  }
  function y(T, M, $, r) {
    T && typeof T.id == "string" && (T = T.id), e(T == null || typeof T == "string"), e(k.isBuffer(M)), e(k.isBuffer($)), e(k.isBuffer(r));
    try {
      return Y(T, M, $, r);
    } catch {
      return !1;
    }
  }
  function Y(T, M, $, r) {
    const [x, O] = l(T, M);
    if (!x || M.length !== O)
      return !1;
    const L = z.decode(r);
    if (!L.verify())
      return !1;
    const X = L.size();
    if ($.length !== X)
      return !1;
    const P = x.length + O;
    if (X < P + 11)
      return !1;
    const K = L.encrypt($);
    let re = 1;
    re &= a(K[0], 0), re &= a(K[1], 1);
    for (let ce = 2; ce < X - P - 1; ce++)
      re &= a(K[ce], 255);
    return re &= a(K[X - P - 1], 0), re &= u(K.slice(X - P, X - O), x), re &= u(K.slice(X - O, X), M), re === 1;
  }
  function he(T, M) {
    e(k.isBuffer(T));
    const $ = z.decode(M);
    if (!$.verify())
      throw new Error("Invalid RSA public key.");
    const r = $.size();
    if (T.length > r - 11)
      throw new Error("Invalid RSA message size.");
    const x = k.alloc(r), O = T.length, L = r - O - 3;
    x[0] = 0, x[1] = 2, d.randomFill(x, 2, L);
    for (let X = 2; X < 2 + L; X++)
      for (; x[X] === 0; )
        d.randomFill(x, X, 1);
    return x[r - O - 1] = 0, T.copy(x, r - O), $.encrypt(x);
  }
  function be(T, M) {
    e(k.isBuffer(T));
    const $ = A.decode(M);
    if (!$.verify())
      throw new Error("Invalid RSA private key.");
    const r = $.size();
    if (r < 11)
      throw new Error("Invalid RSA private key.");
    if (T.length !== r)
      throw new Error("Invalid RSA message size.");
    const x = $.decrypt(T), O = a(x[0], 0), L = a(x[1], 2);
    let X = 0, P = 1;
    for (let le = 2; le < x.length; le++) {
      const me = a(x[le], 0);
      X = s(X, le, P & me), P = s(P, 0, me);
    }
    const K = i(10, X), re = O & L & (P ^ 1) & K, ce = s(0, X + 1, re);
    if (re === 0)
      throw new Error("Invalid RSA ciphertext.");
    return x.slice(ce);
  }
  function xe(T, M, $, r) {
    if (r == null && (r = H), e(T && typeof T.id == "string"), e(k.isBuffer(M)), e((r | 0) === r), M.length !== T.size)
      throw new Error("Invalid RSA message size.");
    const x = A.decode($);
    if (!x.verify())
      throw new Error("Invalid RSA private key.");
    const O = x.bits(), L = O + 7 >>> 3, X = O + 6 >>> 3;
    if (r === S ? r = X - 2 - T.size : r === H && (r = T.size), r < 0 || r > L)
      throw new Error("Invalid PSS salt length.");
    const P = d.randomBytes(r), K = U(T, M, O - 1, P);
    return x.decrypt(K);
  }
  function Ie(T, M, $, r, x) {
    x == null && (x = H), e(T && typeof T.id == "string"), e(k.isBuffer(M)), e(k.isBuffer($)), e(k.isBuffer(r)), e((x | 0) === x);
    try {
      return ve(T, M, $, r, x);
    } catch {
      return !1;
    }
  }
  function ve(T, M, $, r, x) {
    if (M.length !== T.size)
      return !1;
    const O = z.decode(r);
    if (!O.verify())
      return !1;
    const L = O.bits(), X = L + 7 >>> 3;
    if ($.length !== X || (x === S ? x = 0 : x === H && (x = T.size), x < 0 || x > X))
      return !1;
    let P = O.encrypt($);
    if ((L - 1 & 7) === 0) {
      if (P[0] !== 0)
        return !1;
      P = P.slice(1);
    }
    return G(T, M, P, L - 1, x);
  }
  function C(T, M, $, r) {
    r == null && (r = J), e(T && typeof T.id == "string"), e(k.isBuffer(M)), e(k.isBuffer(r));
    const x = z.decode($);
    if (!x.verify())
      throw new Error("Invalid RSA public key.");
    const O = x.size(), L = M.length, X = T.size;
    if (L > O - 2 * X - 2)
      throw new Error("Invalid RSA message size.");
    const P = k.alloc(O), K = T.digest(r), re = P.slice(1, 1 + X), ce = P.slice(1 + X), le = ce.length;
    return P[0] = 0, d.randomFill(re, 0, re.length), K.copy(ce, 0), ce.fill(0, X, le - L - 1), ce[le - L - 1] = 1, M.copy(ce, le - L), B(T, ce, re), B(T, re, ce), x.encrypt(P);
  }
  function I(T, M, $, r) {
    r == null && (r = J), e(T && typeof T.id == "string"), e(k.isBuffer(M)), e(k.isBuffer(r));
    const x = A.decode($);
    if (!x.verify())
      throw new Error("Invalid RSA private key.");
    const O = x.size(), L = M.length, X = T.size;
    if (O < X * 2 + 2)
      throw new Error("Invalid RSA private key size.");
    if (L !== O)
      throw new Error("Invalid RSA message size.");
    const P = x.decrypt(M), K = T.digest(r), re = a(P[0], 0), ce = P.slice(1, X + 1), le = P.slice(X + 1);
    B(T, ce, le), B(T, le, ce);
    const me = le.slice(0, X), ne = u(me, K), W = le.slice(X);
    let te = 1, pe = 0, Ee = 0;
    for (let Oe = 0; Oe < W.length; Oe++) {
      const Be = a(W[Oe], 0), ke = a(W[Oe], 1);
      pe = s(pe, Oe, te & ke), te = s(te, 0, ke), Ee = s(Ee, 1, te & (Be ^ 1));
    }
    if ((re & ne & (Ee ^ 1) & (te ^ 1)) === 0)
      throw new Error("Invalid RSA ciphertext.");
    return W.slice(pe + 1);
  }
  function se(T, M, $) {
    e(k.isBuffer(T)), e(M >>> 0 === M);
    const r = z.decode($);
    if (!r.verify())
      throw new Error("Invalid RSA public key.");
    if (T.length !== r.size())
      throw new Error("Invalid RSA ciphertext.");
    if (M < r.bits())
      throw new Error("Cannot make ciphertext smaller.");
    const x = M + 7 >>> 3, O = c.decode(T);
    if (O.cmp(r.n) >= 0)
      throw new Error("Invalid RSA ciphertext.");
    const L = c.shift(1, M), X = L.sub(O).iadd(r.n).isubn(1).div(r.n);
    e(X.sign() > 0);
    let P = L;
    for (; P.cmp(L) >= 0; ) {
      const K = c.random(d, 0, X);
      P = O.add(K.mul(r.n));
    }
    return e(P.mod(r.n).cmp(O) === 0), e(P.bitLength() <= M), P.encode("be", x);
  }
  function t(T, M, $) {
    e(k.isBuffer(T)), e(M >>> 0 === M);
    const r = z.decode($);
    if (!r.verify())
      throw new Error("Invalid RSA public key.");
    const x = r.size();
    if (T.length < x)
      throw new Error("Invalid RSA ciphertext.");
    const O = c.decode(T);
    if (M !== 0 && O.bitLength() > M)
      throw new Error("Invalid RSA ciphertext.");
    return O.imod(r.n).encode("be", x);
  }
  function l(T, M) {
    if (e(T == null || typeof T == "string"), e(k.isBuffer(M)), T == null)
      return [J, M.length];
    const $ = N[T];
    return $ == null ? [null, 0] : $.length === 1 ? [J, $[0]] : [
      $,
      $[$.length - 1]
    ];
  }
  function B(T, M, $) {
    e(T && typeof T.id == "string"), e(k.isBuffer(M)), e(k.isBuffer($));
    const r = k.alloc(4, 0);
    let x = 0;
    for (; x < M.length; ) {
      const O = T.multi($, r);
      let L = 0;
      for (; x < M.length && L < O.length; )
        M[x++] ^= O[L++];
      for (L = 3; L >= 0 && (r[L] += 1, r[L] === 0); L--)
        ;
    }
  }
  function U(T, M, $, r) {
    e(T && typeof T.id == "string"), e(k.isBuffer(M)), e($ >>> 0 === $), e(k.isBuffer(r));
    const x = T.size, O = r.length, L = $ + 7 >>> 3;
    if (M.length !== x)
      throw new Error("Invalid RSA message size.");
    if (L < x + O + 2)
      throw new Error("Message too long.");
    const X = k.alloc(L), P = X.slice(0, L - x - 1), K = X.slice(L - x - 1, L - 1), re = T.multi(j, M, r), ce = 255 >>> 8 * L - $;
    return P.fill(0, 0, L - O - x - 2), P[L - O - x - 2] = 1, r.copy(P, L - O - x - 1), re.copy(K, 0), X[L - 1] = 188, B(T, P, K), P[0] &= ce, X;
  }
  function G(T, M, $, r, x) {
    e(T && typeof T.id == "string"), e(k.isBuffer(M)), e(k.isBuffer($)), e(r >>> 0 === r), e(x >>> 0 === x);
    const O = T.size, L = r + 7 >>> 3;
    if (M.length !== O || L < O + x + 2 || $[L - 1] !== 188)
      return !1;
    const X = $.slice(0, L - O - 1), P = $.slice(L - O - 1, L - 1), K = 255 >>> 8 * L - r;
    if ($[0] & ~K)
      return !1;
    if (B(T, X, P), X[0] &= K, x === 0) {
      x = -1;
      for (let le = 0; le < X.length; le++)
        if (X[le] !== 0) {
          if (X[le] === 1) {
            x = X.length - (le + 1);
            break;
          }
          return !1;
        }
      if (x === -1)
        return !1;
    } else {
      const le = X.length - x - 1;
      for (let me = 0; me < le; me++)
        if (X[me] !== 0)
          return !1;
      if (X[le] !== 1)
        return !1;
    }
    const re = X.slice(X.length - x);
    return T.multi(j, M, re).equals(P);
  }
  return Tt.native = 0, Tt.SALT_LENGTH_AUTO = S, Tt.SALT_LENGTH_HASH = H, Tt.privateKeyGenerate = q, Tt.privateKeyGenerateAsync = _, Tt.privateKeyBits = F, Tt.privateKeyVerify = R, Tt.privateKeyImport = V, Tt.privateKeyExport = fe, Tt.publicKeyCreate = ue, Tt.publicKeyBits = ae, Tt.publicKeyVerify = D, Tt.publicKeyImport = Q, Tt.publicKeyExport = Z, Tt.sign = oe, Tt.verify = y, Tt.encrypt = he, Tt.decrypt = be, Tt.signPSS = xe, Tt.verifyPSS = Ie, Tt.encryptOAEP = C, Tt.decryptOAEP = I, Tt.veil = se, Tt.unveil = t, Tt;
}
var hh, C3;
function Gx() {
  if (C3) return hh;
  C3 = 1;
  const e = Mt(), c = wr(), d = ni();
  class w extends c {
    constructor() {
      super();
    }
    init() {
      return this.state[0] = 3238371032, this.state[1] = 914150663, this.state[2] = 812702999, this.state[3] = 4144912697, this.state[4] = 4290775857, this.state[5] = 1750603025, this.state[6] = 1694076839, this.state[7] = 3204075428, this.size = 0, this;
    }
    final() {
      return super.final().slice(0, 28);
    }
    static hash() {
      return new w();
    }
    static hmac() {
      return new d(w, 64);
    }
    static digest(f) {
      return w.ctx.init().update(f).final();
    }
    static root(f, n) {
      return e(k.isBuffer(f) && f.length === 28), e(k.isBuffer(n) && n.length === 28), w.ctx.init().update(f).update(n).final();
    }
    static multi(f, n, u) {
      const { ctx: a } = w;
      return a.init(), a.update(f), a.update(n), u && a.update(u), a.final();
    }
    static mac(f, n) {
      return w.hmac().init(n).update(f).final();
    }
  }
  return w.native = 0, w.id = "SHA224", w.size = 28, w.bits = 224, w.blockSize = 64, w.zero = k.alloc(28, 0), w.ctx = new w(), hh = w, hh;
}
/*!
 * bcrypto.js - crypto for bcrypto
 * Copyright (c) 2014-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var D3;
function Wx() {
  return D3 || (D3 = 1, function(e) {
    e.aes = _l(), e.BN = Hr(), e.ChaCha20 = Xb(), e.cleanse = mn(), e.Hash160 = Hi(), e.Hash256 = hr(), e.HmacDRBG = Jb(), e.Keccak = l7(), e.merkle = r7(), e.murmur3 = Il(), e.p224 = Kx(), e.p256 = Vx(), e.p384 = $x(), e.p521 = jx(), e.pbkdf2 = xo(), e.random = pi(), e.RIPEMD160 = sl(), e.rsa = Jx(), e.safe = Ol(), e.scrypt = h7(), e.secp256k1 = Rr(), e.SHA1 = Wb(), e.SHA224 = Gx(), e.SHA256 = wr(), e.SHA384 = d7(), e.SHA512 = gn(), e.SHAKE = b7(), e.SHAKE256 = p7(), e.version = "5.5.1", e.native = e.SHA256.native;
  }(rh)), rh;
}
var lh = {};
const Zx = "@hansekontor/checkout-components", Qx = "1.0.0", U3 = {
  name: Zx,
  version: Qx
};
/*!
 * pkg.js - package constants
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * Copyright (c) 2018, bcash developers.
 * https://github.com/bcoin-org/bcash
 */
var F3;
function ew() {
  return F3 || (F3 = 1, function(e) {
    const c = e;
    c.name = U3.name, c.core = "bcash", c.organization = "badger-cash", c.currency = "bitcoin cash", c.unit = "bch", c.base = "satoshi", c.cfg = `${c.core}.conf`, c.url = `https://github.com/${c.organization}/${c.name}`, c.version = U3.version;
  }(lh)), lh;
}
/*!
 * bcoin.js - a javascript bitcoin library.
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License).
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var H3;
function m7() {
  return H3 || (H3 = 1, function(e) {
    const c = e;
    c.set = function(w) {
      return c.Network.set(w), c;
    }, c.btc = tx(), c.Amount = bi(), c.URI = Gb(), c.coins = rx(), c.Coins = ml(), c.CoinEntry = po(), c.CoinView = mo(), c.hd = bx(), c.HDPrivateKey = xl(), c.HDPublicKey = gl(), c.Mnemonic = wo(), c.primitives = gx(), c.Address = Lr(), c.Block = vl(), c.Coin = rs(), c.Headers = ns(), c.Input = vo(), c.InvItem = yo(), c.KeyRing = Sl(), c.MerkleBlock = yl(), c.MTX = El(), c.Outpoint = xi(), c.Output = gi(), c.TX = xn(), c.protocol = wx(), c.consensus = Ht(), c.Network = yr(), c.networks = dl(), c.policy = mi(), c.script = yx(), c.Opcode = pl(), c.Script = Pr(), c.ScriptNum = Li(), c.SigCache = i7(), c.Stack = lo(), c.utils = Kt(), c.util = Zt(), c.WalletDB = Lx(), c.bcrypto = Wx(), c.bfilter = s7(), c.pkg = ew();
  }(ja)), ja;
}
var dh = {}, L3;
function tw() {
  return L3 || (L3 = 1, function(e) {
    const c = At(), d = e;
    d.readTag = function(g) {
      let f = g.readU8();
      const n = (f & 32) === 0;
      if ((f & 31) === 31) {
        let u = f;
        for (f = 0; (u & 128) === 128; )
          u = g.readU8(), f <<= 7, f |= u & 127;
      } else
        f &= 31;
      return {
        type: f,
        primitive: n,
        size: d.readSize(g, n)
      };
    }, d.readSize = function(g, f) {
      let n = g.readU8();
      if (!f && n === 128)
        throw new Error("Indefinite size.");
      if ((n & 128) === 0)
        return n;
      const u = n & 127;
      if (u > 3)
        throw new Error("Length octet is too long.");
      n = 0;
      for (let a = 0; a < u; a++)
        n <<= 8, n |= g.readU8();
      return n;
    }, d.readSeq = function(g) {
      const f = d.implicit(g, 16);
      return g.readBytes(f.size);
    }, d.implicit = function(g, f) {
      const n = d.readTag(g);
      if (n.type !== f)
        throw new Error(`Unexpected tag: ${n.type}.`);
      return n;
    }, d.explicit = function(g, f) {
      const n = g.offset;
      return d.readTag(g).type !== f ? (g.offset = n, !1) : !0;
    }, d.seq = function(g) {
      return c.read(d.readSeq(g), !0);
    }, d.readInt = function(g, f) {
      const n = d.implicit(g, 2), u = g.readBytes(n.size);
      return f ? u.readUIntBE(0, u.length) : u;
    }, d.readExplicitInt = function(g, f, n) {
      return d.explicit(g, f) ? d.readInt(g, n) : -1;
    }, d.readBitstr = function(g) {
      const f = d.implicit(g, 3), n = g.readBytes(f.size);
      return d.alignBitstr(n);
    }, d.readString = function(g) {
      const f = d.readTag(g);
      switch (f.type) {
        case 3: {
          const n = g.readBytes(f.size);
          return d.alignBitstr(n).toString("utf8");
        }
        // Note:
        // Fuck all these.
        case 4:
        // octstr
        case 18:
        // numstr
        case 19:
        // prinstr
        case 20:
        // t61str
        case 21:
        // videostr
        case 22:
        // ia5str
        case 25:
        // graphstr
        case 12:
        // utf8str
        case 26:
        // iso646str
        case 27:
        // genstr
        case 28:
        // unistr
        case 29:
        // charstr
        case 30:
          return g.readString(f.size, "utf8");
        default:
          throw new Error(`Unexpected tag: ${f.type}.`);
      }
    }, d.alignBitstr = function(g) {
      const f = g[0], n = (g.length - 1) * 8 - f, u = g.slice(1), a = 8 - n % 8;
      if (a === 8 || u.length === 0)
        return u;
      const s = k.allocUnsafe(u.length);
      s[0] = u[0] >>> a;
      for (let i = 1; i < u.length; i++)
        s[i] = u[i - 1] << 8 - a, s[i] |= u[i] >>> a;
      return s;
    }, d.readCert = function(g) {
      const f = g;
      return f.start(), g = d.seq(f), {
        tbs: d.readTBS(g),
        sigAlg: d.readAlgIdent(g),
        sig: d.readBitstr(g),
        raw: f.endData(!0)
      };
    }, d.readTBS = function(g) {
      const f = g;
      return f.start(), g = d.seq(f), {
        version: d.readExplicitInt(g, 0, !0),
        serial: d.readInt(g),
        sig: d.readAlgIdent(g),
        issuer: d.readName(g),
        validity: d.readValidity(g),
        subject: d.readName(g),
        pubkey: d.readPubkey(g),
        raw: f.endData(!0)
      };
    }, d.readPubkey = function(g) {
      return g = d.seq(g), {
        alg: d.readAlgIdent(g),
        pubkey: d.readBitstr(g)
      };
    }, d.readName = function(g) {
      const f = [];
      for (g = d.seq(g); g.left(); )
        d.implicit(g, 17), d.implicit(g, 16), f.push({
          type: d.readOID(g),
          value: d.readString(g)
        });
      return f;
    }, d.readValidity = function(g) {
      return g = d.seq(g), {
        notBefore: d.readTime(g),
        notAfter: d.readTime(g)
      };
    }, d.readTime = function(g) {
      const f = d.readTag(g), n = g.readString(f.size, "ascii");
      let u, a, s, i, p, m;
      switch (f.type) {
        case 23:
          u = n.slice(0, 2) | 0, a = n.slice(2, 4) | 0, s = n.slice(4, 6) | 0, i = n.slice(6, 8) | 0, p = n.slice(8, 10) | 0, m = n.slice(10, 12) | 0, u < 70 ? u = 2e3 + u : u = 1900 + u;
          break;
        case 24:
          u = n.slice(0, 4) | 0, a = n.slice(4, 6) | 0, s = n.slice(6, 8) | 0, i = n.slice(8, 10) | 0, p = n.slice(10, 12) | 0, m = n.slice(12, 14) | 0;
          break;
        default:
          throw new Error(`Unexpected tag: ${f.type}.`);
      }
      return Date.UTC(u, a - 1, s, i, p, m, 0) / 1e3;
    }, d.readOID = function(g) {
      const f = d.implicit(g, 6), n = g.readBytes(f.size);
      return d.formatOID(n);
    }, d.formatOID = function(g) {
      const f = c.read(g), n = [];
      let u = 0, a = 0;
      for (; f.left(); )
        a = f.readU8(), u <<= 7, u |= a & 127, (a & 128) === 0 && (n.push(u), u = 0);
      a & 128 && n.push(u);
      const s = n[0] / 40 | 0, i = n[0] % 40;
      return [s, i].concat(n.slice(1)).join(".");
    }, d.readAlgIdent = function(g) {
      let f = null;
      g = d.seq(g);
      const n = d.readOID(g);
      if (g.left() > 0) {
        const u = d.readTag(g);
        f = g.readBytes(u.size), f.length === 0 && (f = null);
      }
      return {
        alg: n,
        params: f
      };
    }, d.readRSAPublic = function(g) {
      return g = d.seq(g), {
        modulus: d.readInt(g),
        publicExponent: d.readInt(g)
      };
    }, d.readRSAPrivate = function(g) {
      return g = d.seq(g), {
        version: d.readInt(g, !0),
        modulus: d.readInt(g),
        publicExponent: d.readInt(g),
        privateExponent: d.readInt(g),
        prime1: d.readInt(g),
        prime2: d.readInt(g),
        exponent1: d.readInt(g),
        exponent2: d.readInt(g),
        coefficient: d.readInt(g)
      };
    }, d.parseRSAPublic = function(g) {
      return d.readRSAPublic(c.read(g, !0));
    }, d.parseRSAPrivate = function(g) {
      return d.readRSAPrivate(c.read(g, !0));
    }, d.parseCert = function(g) {
      return d.readCert(c.read(g, !0));
    }, d.parseTBS = function(g) {
      return d.readTBS(c.read(g, !0));
    };
  }(dh)), dh;
}
var As = {};
/*!
 * pk.js - public key algorithms for bcoin
 * Copyright (c) 2016-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var K3;
function rw() {
  if (K3) return As;
  K3 = 1;
  const e = $e(), c = m7().bcrypto, {
    SHA224: d,
    SHA256: w,
    SHA384: g,
    SHA512: f,
    rsa: n,
    p224: u,
    p256: a,
    p384: s,
    p521: i
  } = c;
  As.verify = function(v, b, h, o) {
    const S = p(v);
    if (!S)
      return !1;
    switch (o.alg) {
      case "rsa":
        return n.verify(S, S.digest(b), h, o.data);
      case "ecdsa": {
        const H = m(o.curve);
        return H ? H.verifyDER(S.digest(b), h, o.data) : !1;
      }
      default:
        throw new Error(`Unsupported algorithm: ${o.alg}.`);
    }
  }, As.sign = function(v, b, h) {
    const o = p(v);
    if (!o)
      throw new Error(`Unsupported hash algorithm: ${v}.`);
    switch (h.alg) {
      case "rsa":
        return n.sign(o, o.digest(b), h.data);
      case "ecdsa": {
        const S = m(h.curve);
        if (!S)
          throw new Error(`Unsupported curve: ${h.curve}.`);
        return S.signDER(o.digest(b), h.data);
      }
      default:
        throw new Error(`Unsupported algorithm: ${h.alg}.`);
    }
  };
  function p(E) {
    switch (e(typeof E == "string"), E) {
      case "sha224":
        return d;
      case "sha256":
        return w;
      case "sha384":
        return g;
      case "sha512":
        return f;
      default:
        return null;
    }
  }
  function m(E) {
    switch (e(typeof E == "string"), E) {
      case "p224":
        return u;
      case "p256":
        return a;
      case "p384":
        return s;
      case "p521":
        return i;
      default:
        return null;
    }
  }
  return As;
}
var V3;
function g7() {
  return V3 || (V3 = 1, function(e) {
    const c = $e(), d = m7().bcrypto, { SHA256: w } = d, g = tw(), f = rw(), n = Rb(), u = e;
    u.trusted = /* @__PURE__ */ new Set(), u.allowUntrusted = !1, u.oid = {
      "1.2.840.10040.4.1": { key: "dsa", hash: null },
      "1.2.840.10040.4.2": { key: "dsa", hash: null },
      "1.2.840.10040.4.3": { key: "dsa", hash: "sha1" },
      "1.2.840.113549.1.1.1": { key: "rsa", hash: null },
      "1.2.840.113549.1.1.2": { key: "rsa", hash: "md2" },
      "1.2.840.113549.1.1.3": { key: "rsa", hash: "md4" },
      "1.2.840.113549.1.1.4": { key: "rsa", hash: "md5" },
      "1.2.840.113549.1.1.5": { key: "rsa", hash: "sha1" },
      "1.2.840.113549.1.1.11": { key: "rsa", hash: "sha256" },
      "1.2.840.113549.1.1.12": { key: "rsa", hash: "sha384" },
      "1.2.840.113549.1.1.13": { key: "rsa", hash: "sha512" },
      "1.2.840.113549.1.1.14": { key: "rsa", hash: "sha224" },
      "2.16.840.1.101.3.4.2.8": { key: "rsa", hash: "sha3-256" },
      "2.16.840.1.101.3.4.2.9": { key: "rsa", hash: "sha3-384" },
      "2.16.840.1.101.3.4.2.10": { key: "rsa", hash: "sha3-512" },
      "1.2.840.10045.2.1": { key: "ecdsa", hash: null },
      "1.2.840.10045.4.1": { key: "ecdsa", hash: "sha1" },
      "1.2.840.10045.4.3.1": { key: "ecdsa", hash: "sha224" },
      "1.2.840.10045.4.3.2": { key: "ecdsa", hash: "sha256" },
      "1.2.840.10045.4.3.3": { key: "ecdsa", hash: "sha384" },
      "1.2.840.10045.4.3.4": { key: "ecdsa", hash: "sha512" }
    }, u.curves = {
      "1.3.132.0.33": "p224",
      "1.2.840.10045.3.1.7": "p256",
      "1.3.132.0.34": "p384",
      "1.3.132.0.35": "p521"
    }, u.getSubjectOID = function(s, i) {
      const p = s.tbs.subject;
      for (const m of p)
        if (m.type === i)
          return m.value;
      return null;
    }, u.getCAName = function(s) {
      return u.getSubjectOID(s, "2.5.4.3") || u.getSubjectOID(s, "2.5.4.11") || u.getSubjectOID(s, "2.5.4.10") || "Unknown";
    }, u.isTrusted = function(s) {
      const p = w.digest(s.raw).toString("hex");
      return u.trusted.has(p);
    }, u.setTrust = function(s) {
      c(Array.isArray(s), "Certs must be an array.");
      for (const i of s) {
        c(k.isBuffer(i), "Certificates must be DER.");
        const p = u.parse(i), E = w.digest(p.raw).toString("hex");
        u.trusted.add(E);
      }
    }, u.setFingerprints = function(s) {
      c(Array.isArray(s), "Certs must be an array.");
      for (const i of s) {
        c(k.isBuffer(i), "Fingerprint must be a buffer."), c(i.length === 32, "Fingerprint must be a sha256 hash.");
        const p = i.toString("hex");
        u.trusted.add(p);
      }
    }, u.getKeyAlgorithm = function(s) {
      const i = s.tbs.pubkey.alg.alg, p = u.oid[i];
      if (!p)
        throw new Error(`Unknown key algorithm: ${i}.`);
      return p;
    }, u.getSigAlgorithm = function(s) {
      const i = s.sigAlg.alg, p = u.oid[i];
      if (!p || !p.hash)
        throw new Error(`Unknown signature algorithm: ${i}.`);
      return p;
    }, u.getCurve = function(s) {
      let i;
      try {
        i = g.parseOID(s);
      } catch {
        throw new Error("Could not parse curve OID.");
      }
      const p = u.curves[i];
      if (!p)
        throw new Error(`Unknown ECDSA curve: ${i}.`);
      return p;
    }, u.parse = function(s) {
      try {
        return g.parseCert(s);
      } catch {
        throw new Error("Could not parse DER certificate.");
      }
    }, u.getPublicKey = function(s) {
      const i = u.getKeyAlgorithm(s), p = s.tbs.pubkey.pubkey, m = s.tbs.pubkey.alg.params;
      let E = null;
      if (i.key === "ecdsa") {
        if (!m)
          throw new Error("No curve selected for ECDSA (cert).");
        E = u.getCurve(m);
      }
      return {
        alg: i.key,
        data: p,
        params: m,
        curve: E
      };
    }, u.verifyTime = function(s) {
      const i = s.tbs.validity, p = Math.floor(Date.now() / 1e3);
      return p > i.notBefore && p < i.notAfter;
    }, u.getSigningKey = function(s, i) {
      c(i.length !== 0, "No chain available.");
      const p = u.parse(i[0]), m = u.getPublicKey(p);
      return {
        alg: m.alg,
        data: s,
        params: m.params,
        curve: m.curve
      };
    }, u.signSubject = function(s, i, p, m) {
      const E = u.getSigningKey(p, m);
      return f.sign(s, i, E);
    }, u.getVerifyKey = function(s) {
      if (s.length === 0)
        throw new Error("No verify key available (cert chain).");
      const i = u.parse(s[0]);
      return u.getPublicKey(i);
    }, u.verifySubject = function(s, i, p, m) {
      const E = u.getVerifyKey(m);
      return f.verify(s, i, p, E);
    }, u.parseChain = function(s) {
      const i = [];
      for (const p of s) {
        const m = u.parse(p);
        i.push(m);
      }
      return i;
    }, u.verifyTimes = function(s) {
      for (const i of s)
        if (!u.verifyTime(i))
          return !1;
      return !0;
    }, u.verifyTrust = function(s) {
      if (u.allowUntrusted)
        return !0;
      for (const i of s)
        if (u.isTrusted(i))
          return !0;
      return !1;
    }, u.verifyChain = function(s) {
      const i = u.parseChain(s);
      if (!u.verifyTimes(i))
        throw new Error("Invalid certificate times.");
      for (let p = 1; p < i.length; p++) {
        const m = i[p - 1], E = i[p], v = u.getSigAlgorithm(m), b = u.getPublicKey(E), h = m.tbs.raw, o = m.sig;
        if (!f.verify(v.hash, h, o, b))
          throw new Error(`${v.key} verification failed for chain.`);
      }
      if (!u.verifyTrust(i))
        throw new Error("Certificate chain is untrusted.");
      return !0;
    }, u.setFingerprints(n);
  }($a)), $a;
}
var bh, $3;
function iw() {
  if ($3) return bh;
  $3 = 1;
  const e = $e(), c = io(), d = no(), w = nl(), g = g7();
  class f {
    /**
     * Create a payment request.
     * @constructor
     * @param {Object?} options
     * @property {Number} version
     * @property {String|null} pkiType
     * @property {Buffer|null} pkiData
     * @property {PaymentDetails} paymentDetails
     * @property {Buffer|null} signature
     */
    constructor(s) {
      this.version = -1, this.pkiType = null, this.pkiData = null, this.paymentDetails = new w(), this.signature = null, s && this.fromOptions(s);
    }
    /**
     * Inject properties from options.
     * @private
     * @param {Object} options
     * @returns {PaymentRequest}
     */
    fromOptions(s) {
      return s.version != null && (e((s.version | 0) === s.version), this.version = s.version), s.pkiType != null && (e(typeof s.pkiType == "string"), this.pkiType = s.pkiType), s.pkiData && (e(k.isBuffer(s.pkiData)), this.pkiData = s.pkiData), s.paymentDetails && this.paymentDetails.fromOptions(s.paymentDetails), s.signature && (e(k.isBuffer(s.signature)), this.signature = s.signature), s.chain && this.setChain(s.chain), this;
    }
    /**
     * Instantiate payment request from options.
     * @param {Object} options
     * @returns {PaymentRequest}
     */
    static fromOptions(s) {
      return new f().fromOptions(s);
    }
    /**
     * Inject properties from serialized data.
     * @private
     * @param {Buffer} data
     * @returns {PaymentRequest}
     */
    fromRaw(s) {
      const i = new c(s);
      return this.version = i.readFieldU32(1, !0), this.pkiType = i.readFieldString(2, !0), this.pkiData = i.readFieldBytes(3, !0), this.paymentDetails.fromRaw(i.readFieldBytes(4)), this.signature = i.readFieldBytes(5, !0), this;
    }
    /**
     * Instantiate payment request from serialized data.
     * @param {Buffer} data
     * @returns {PaymentRequest}
     */
    static fromRaw(s, i) {
      return typeof s == "string" && (s = k.from(s, i)), new f().fromRaw(s);
    }
    /**
     * Serialize the payment request (protobuf).
     * @returns {Buffer}
     */
    toRaw() {
      const s = new d();
      return this.version !== -1 && s.writeFieldU32(1, this.version), this.pkiType != null && s.writeFieldString(2, this.pkiType), this.pkiData && s.writeFieldBytes(3, this.pkiData), s.writeFieldBytes(4, this.paymentDetails.toRaw()), this.signature && s.writeFieldBytes(5, this.signature), s.render();
    }
    /**
     * Get payment request signature algorithm.
     * @returns {Object|null}
     */
    getAlgorithm() {
      if (!this.pkiType)
        throw new Error("No PKI type available.");
      const s = this.pkiType.split("+");
      if (s.length !== 2)
        throw new Error("Could not parse PKI algorithm.");
      if (s[0] !== "x509")
        throw new Error(`Unknown PKI type: ${s[0]}.`);
      if (s[1] !== "sha1" && s[1] !== "sha256")
        throw new Error(`Unknown hash algorithm: ${s[1]}.`);
      return new n(s[0], s[1]);
    }
    /**
     * Serialize payment request for sighash.
     * @returns {Buffer}
     */
    signatureData() {
      const s = this.signature;
      this.signature = k.alloc(0);
      const i = this.toRaw();
      return this.signature = s, i;
    }
    /**
     * Set x509 certificate chain.
     * @param {Buffer[]} chain
     */
    setChain(s) {
      const i = new d();
      e(Array.isArray(s), "Chain must be an array.");
      for (const p of s)
        e(k.isBuffer(p), "Certificates must be DER."), i.writeFieldBytes(1, p);
      this.pkiData = i.render();
    }
    /**
     * Get x509 certificate chain.
     * @returns {Buffer[]}
     */
    getChain() {
      const s = [];
      if (!this.pkiData)
        return s;
      const i = new c(this.pkiData);
      for (; i.nextTag() === 1; )
        s.push(i.readFieldBytes(1));
      return s;
    }
    /**
     * Sign payment request (chain must be set).
     * @param {Buffer} key
     * @param {Buffer[]?} certs
     */
    sign(s, i) {
      i && this.setChain(i), this.pkiType || (this.pkiType = "x509+sha256");
      const p = this.getAlgorithm(), m = this.signatureData(), E = this.getChain();
      this.signature = g.signSubject(p.hash, m, s, E);
    }
    /**
     * Verify payment request signature.
     * @returns {Boolean}
     */
    verify() {
      if (!this.pkiType || this.pkiType === "none" || !this.signature)
        return !1;
      let s;
      try {
        s = this.getAlgorithm();
      } catch {
        return !1;
      }
      const i = this.signatureData(), p = this.signature, m = this.getChain();
      try {
        return g.verifySubject(s.hash, i, p, m);
      } catch {
        return !1;
      }
    }
    /**
     * Verify x509 certificate chain.
     * @returns {Boolean}
     */
    verifyChain() {
      if (!this.pkiType || this.pkiType === "none")
        return !1;
      try {
        return g.verifyChain(this.getChain());
      } catch {
        return !1;
      }
    }
    /**
     * Get root certificate authority.
     * @returns {Object|null}
     */
    getCA() {
      if (!this.pkiType || this.pkiType === "none")
        throw new Error("No CA found (pkiType).");
      const s = this.getChain();
      if (s.length === 0)
        throw new Error("No CA found (chain).");
      const i = g.parse(s[s.length - 1]);
      return new u(i);
    }
  }
  class n {
    /**
     * Create an algorithm.
     * @constructor
     * @ignore
     */
    constructor(s, i) {
      this.key = s, this.hash = i;
    }
  }
  class u {
    /**
     * Create a CA.
     * @constructor
     * @ignore
     */
    constructor(s) {
      this.name = g.getCAName(s), this.trusted = g.isTrusted(s), this.cert = s;
    }
  }
  return bh = f, bh;
}
/*!
 * b70.js - bip70 for bcoin
 * Copyright (c) 2016-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var j3;
function nw() {
  return j3 || (j3 = 1, fi.certs = Rb(), fi.PaymentACK = sg(), fi.PaymentDetails = nl(), fi.Payment = Pb(), fi.PaymentRequest = iw(), fi.x509 = g7()), fi;
}
var Y3 = nw();
const sw = (e, c, d) => new Promise((w, g) => {
  let f = new XMLHttpRequest();
  f.open("POST", e, !0), Object.entries(c).forEach(([n, u]) => {
    f.setRequestHeader(n, u);
  }), f.responseType = "arraybuffer", f.onload = function(n) {
    let u = f.response;
    if (f.status === 400 || f.status === 404 || f.status === 500) {
      g(
        new Error(
          `${f.status} Error processing payment, please check with the merchant and try again.`
        )
      );
      return;
    }
    u && w(u);
  }, f.onerror = function(n) {
    console.warn(n), g(n);
  }, f.send(d);
}), ow = async (e, c, d) => {
  const g = new Y3.Payment(c).toRaw(), f = {
    Accept: `application/${d}-paymentrequest, application/${d}-paymentack`,
    "Content-Type": `application/${d}-payment`,
    "Content-Transfer-Encoding": "binary"
  }, n = await sw(
    e,
    f,
    g
  ), u = k.from(n);
  return Y3.PaymentACK.fromRaw(u);
}, { Coin: X3, MTX: aw, Input: fw, Script: cw } = Wn, Os = {
  etokenSats: 546,
  defaultFee: 1.01
}, uw = () => {
  const e = async (n, u, a, s, i, p) => {
    const m = u.state.slpBalancesAndUtxos, E = m.nonSlpUtxos.map(
      (V) => X3.fromJSON(V)
    ), v = m.slpUtxos.filter(
      (V) => {
        if (V && V.slp.tokenId === s && V.slp.type !== "BATON")
          return !0;
      }
    );
    if (v.length === 0)
      throw new Error("No MUSD could be found");
    const b = m.tokens;
    let h = {};
    switch (s) {
      case b.prod.tokenId:
        h = b.prod;
        break;
      case b.sandbox.tokenId:
        h = b.sandbox;
        break;
    }
    if (!h)
      throw new Error("Unknown token");
    const o = h.info, S = new aw();
    let H = new xr(0), j = new xr(0), J = new xr(n).times(10 ** o.decimals), N = J;
    const z = [];
    for (let V = 0; V < v.length; V++) {
      const fe = X3.fromJSON(v[V]);
      z.push(fe);
      const ue = new xr(v[V].slp.value);
      H = H.plus(ue);
      const ae = z.length, D = d(ae, 1, i);
      if (j = new xr(D), N = J.plus(j), N.lte(H))
        break;
    }
    const A = [J.toString()];
    j.gt(0) && A.push(j.toString());
    const q = H.minus(N);
    q.gt(0) && A.push(q.toString());
    const _ = w(s, A);
    S.addOutput(_, 0);
    const F = Oi.decode(a[0]), R = Oi.encode(
      "ecash",
      F.type,
      F.hash
    );
    if (S.addOutput(
      R,
      Os.etokenSats
    ), j.gt(0)) {
      const V = Oi.decode(i.address), fe = Oi.encode(
        "ecash",
        V.type,
        V.hash
      );
      S.addOutput(fe, Os.etokenSats);
    }
    if (q.gt(0) && S.addOutput(p, Os.etokenSats), i)
      for (let V = 0; V < z.length; V++)
        S.addCoin(z[V]);
    else {
      const V = {
        inputs: z.map((fe) => fw.fromCoin(fe).prevout),
        changeAddress: p,
        rate: Os.defaultFee * 1e3
      };
      await S.fund([...z, E], V);
    }
    return console.log("build tx", S.toRaw().toString("hex")), S;
  }, c = async (n) => {
    const u = "https://ecash.badger.cash:8332/broadcast", a = "POST", s = JSON.stringify({ tx: n });
    return await (await fetch(u, { method: a, body: s })).json();
  }, d = (n, u, a) => {
    const s = ["1", "1"];
    for (let v = 0; v < u; v++)
      s.push("1");
    const i = w(
      k.alloc(32).toString("hex"),
      s
    );
    let p = g(
      { P2PKH: n },
      { P2PKH: s.length }
    );
    p += 9 + i.length, p += 546 * (s.length - n);
    let m = Math.ceil(p / a.weight);
    return m < 1 && (m = 1), a.stamp.rate * m;
  }, w = (n, u) => {
    const s = new cw().pushSym("return").pushData(k.concat([
      k.from("SLP", "ascii"),
      k.alloc(1)
    ])).pushPush(k.alloc(1, 2)).pushData(k.from("SEND", "ascii")).pushData(k.from(n, "hex"));
    for (let i = 0; i < u.length; i++) {
      const p = u[i];
      s.pushData(a8.U64.fromString(p).toBE(k));
    }
    return s.compile();
  }, g = (n, u) => {
    let a = 0, s = !1;
    const m = {
      inputs: {
        "MULTISIG-P2SH": 196,
        "MULTISIG-P2WSH": 170,
        "MULTISIG-P2SH-P2WSH": 310,
        P2PKH: 592,
        P2WPKH: 272,
        "P2SH-P2WPKH": 364
      },
      outputs: {
        P2SH: 128,
        P2PKH: 136,
        P2WPKH: 124,
        P2WSH: 172
      }
    };
    return Object.keys(n).forEach(function(E) {
      if (E.slice(0, 8) === "MULTISIG") {
        const v = E.split(":");
        if (v.length !== 2) throw new Error(`invalid input: ${E}`);
        const b = v[0], h = v[1].split("-").map(function(S) {
          return parseInt(S);
        });
        a += m.inputs[b] * n[E];
        const o = b === "MULTISIG-P2SH" ? 4 : 1;
        a += (73 * h[0] + 34 * h[1]) * o;
      } else
        a += m.inputs[E] * n[E];
      E.indexOf("W") >= 0 && (s = !0);
    }), Object.keys(u).forEach(function(E) {
      a += m.outputs[E] * u[E];
    }), s && (a += 2), a += 40, Math.ceil(a / 4);
  };
  return {
    getPostage: async (n) => {
      try {
        const s = await (await fetch("https://pay.badger.cash/postage?currency=etoken")).json(), i = s.stamps.find(
          (p) => p.tokenId === n
        );
        if (console.log("postageObj", s), console.log("stamp", i), i)
          return {
            address: s.address,
            weight: s.weight,
            stamp: i
          };
      } catch (u) {
        console.error(u);
      }
      return null;
    },
    buildSendTx: e,
    broadcastTx: c,
    postPayment: ow
  };
}, {
  TX: hw,
  KeyRing: lw,
  Script: J3
} = Wn, x7 = vh({}), dw = ({ children: e }) => {
  const { createWallet: c, cashtab: d, wallet: w, activateWallet: g, update: f, walletLoading: n, removeWallet: u } = ig(), { getPostage: a, buildSendTx: s, broadcastTx: i, postPayment: p } = uw(), [m, E] = Un("IDLE");
  return ph(() => {
    const z = "WALLET_LOADING";
    n ? E(z) : m === z && E("IDLE");
  }, [n]), /* @__PURE__ */ Qi(x7, { value: {
    status: m,
    wallet: w,
    cashtab: d,
    validateMnemonic: D2,
    updateWallet: async () => {
      f(d);
    },
    changeWallet: async (z) => {
      if (z.length === 5) {
        const q = d.wallets.find((_) => _.name === z);
        if (q)
          await g(q);
        else
          throw new Error("Wallet not found");
      } else
        throw new Error("Invalid wallet name");
    },
    addWallet: async (z) => {
      console.log("addWallet mnemonic", z), z ? (console.log("addWallet import wallet"), D2(z) && c(z)) : (console.log("addWallet create new wallet"), c());
    },
    deleteWallet: async (z) => {
      if (console.log("deleteWallet()"), z.length === 5) {
        const q = d.wallets.find((_) => _.name === z);
        if (q)
          await u(q);
        else
          throw new Error("Wallet not found");
      } else
        throw new Error("Invalid wallet name");
    },
    send: async (z, A, q, _ = !1) => {
      if (!w?.Path1899)
        throw new Error("No wallet found");
      E("SENDING"), console.log(z, A, _);
      const F = w.state.slpBalancesAndUtxos.tokens, R = q ? F.sandbox.tokenId : F.prod.tokenId, V = await a(R), fe = w.Path1899.cashAddress, ue = await s(z, w, A, R, V, fe), ae = lw.fromSecret(w.Path1899.fundingWif), D = J3.hashType, Q = V ? D.ALL | D.ANYONECANPAY | D.SIGHASH_FORKID : D.ALL | D.SIGHASH_FORKID;
      ue.sign(ae, Q);
      let Z;
      const oe = ue.toRaw(), y = oe.toString("hex");
      if (console.log("hex", y), V) {
        const he = "https://pay.badger.cash/postage?currency=etoken", be = {
          merchantData: k.alloc(0),
          transactions: [oe],
          refundTo: [{
            script: J3.fromAddress(fe).toRaw(),
            value: 0
          }],
          memo: ""
        }, Ie = await p(
          he,
          be,
          "etoken"
        );
        Ie.payment && (Z = Ie.payment.transactions.map(
          (C) => hw.fromRaw(C).txid()
        )[0], console.log("MUSD txid", Z));
      } else {
        let he = { success: !0 };
        _ || (he = await i(y)), Z = ue.txid().toString("hex"), he.success && (console.log("MUSD txid", Z), E("SENDING_SUCCESS"));
      }
      return `https://explorer.e.cash/tx/${Z}`;
    },
    receive: {},
    bridge: () => {
    },
    withdraw: (z, A) => {
      console.log(z, A);
    }
  }, children: e });
}, ww = () => {
  const e = Sh(x7);
  if (!e)
    throw new Error("useApp must be used within an AppProvider");
  return e;
}, yw = ({
  children: e
}) => /* @__PURE__ */ Qi(S7, { children: /* @__PURE__ */ Qi(rg, { children: /* @__PURE__ */ Qi(dw, { children: e }) }) });
export {
  x7 as AppContext,
  dw as AppProvider,
  G3 as AuthContext,
  S7 as AuthProvider,
  ms as EventBus,
  yw as MUSDProvider,
  _b as WalletContext,
  rg as WalletProvider,
  ww as useApp,
  gw as useAuth,
  ig as useWallet
};
